
#include "uv.h"
#include "internal.h"

#if TARGET_OS_IPHONE || MAC_OS_X_VERSION_MAX_ALLOWED < 1070
int uv__fsevents_init(uv_fs_event_t* handle) { return 0;}int uv__fsevents_close(uv_fs_event_t* handle) { return 0;}void uv__fsevents_loop_delete(uv_loop_t* loop) {}
#else 

#include "darwin-stub.h"

#include <dlfcn.h>
#include <assert.h>
#include <stdlib.h>
#include <pthread.h>
static const int kFSEventsModified = kFSEventStreamEventFlagItemChangeOwner | kFSEventStreamEventFlagItemFinderInfoMod | kFSEventStreamEventFlagItemInodeMetaMod | kFSEventStreamEventFlagItemModified | kFSEventStreamEventFlagItemXattrMod;static const int kFSEventsRenamed = kFSEventStreamEventFlagItemCreated | kFSEventStreamEventFlagItemRemoved | kFSEventStreamEventFlagItemRenamed;static const int kFSEventsSystem = kFSEventStreamEventFlagUserDropped | kFSEventStreamEventFlagKernelDropped | kFSEventStreamEventFlagEventIdsWrapped | kFSEventStreamEventFlagHistoryDone | kFSEventStreamEventFlagMount | kFSEventStreamEventFlagUnmount | kFSEventStreamEventFlagRootChanged;typedef struct uv__fsevents_event_s uv__fsevents_event_t;typedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;typedef struct uv__cf_loop_state_s uv__cf_loop_state_t;enum uv__cf_loop_signal_type_e { kUVCFLoopSignalRegular, kUVCFLoopSignalClosing};typedef enum uv__cf_loop_signal_type_e uv__cf_loop_signal_type_t;struct uv__cf_loop_signal_s { QUEUE member; uv_fs_event_t* handle; uv__cf_loop_signal_type_t type;};struct uv__fsevents_event_s { QUEUE member; int events; char path[1];};struct uv__cf_loop_state_s { CFRunLoopRef loop; CFRunLoopSourceRef signal_source; int fsevent_need_reschedule; FSEventStreamRef fsevent_stream; uv_sem_t fsevent_sem; uv_mutex_t fsevent_mutex; void* fsevent_handles[2]; unsigned int fsevent_handle_count;};static void uv__cf_loop_cb(void* arg);static void* uv__cf_loop_runner(void* arg);static int uv__cf_loop_signal(uv_loop_t* loop, uv_fs_event_t* handle, uv__cf_loop_signal_type_t type);static CFArrayRef (*pCFArrayCreate)(CFAllocatorRef, const void**, CFIndex, const CFArrayCallBacks*);static void (*pCFRelease)(CFTypeRef);static void (*pCFRunLoopAddSource)(CFRunLoopRef, CFRunLoopSourceRef, CFStringRef);static CFRunLoopRef (*pCFRunLoopGetCurrent)(void);static void (*pCFRunLoopRemoveSource)(CFRunLoopRef, CFRunLoopSourceRef, CFStringRef);static void (*pCFRunLoopRun)(void);static CFRunLoopSourceRef (*pCFRunLoopSourceCreate)(CFAllocatorRef, CFIndex, CFRunLoopSourceContext*);static void (*pCFRunLoopSourceSignal)(CFRunLoopSourceRef);static void (*pCFRunLoopStop)(CFRunLoopRef);static void (*pCFRunLoopWakeUp)(CFRunLoopRef);static CFStringRef (*pCFStringCreateWithFileSystemRepresentation)( CFAllocatorRef, const char*);static CFStringEncoding (*pCFStringGetSystemEncoding)(void);static CFStringRef (*pkCFRunLoopDefaultMode);static FSEventStreamRef (*pFSEventStreamCreate)(CFAllocatorRef, FSEventStreamCallback, FSEventStreamContext*, CFArrayRef, FSEventStreamEventId, CFTimeInterval, FSEventStreamCreateFlags);static void (*pFSEventStreamFlushSync)(FSEventStreamRef);static void (*pFSEventStreamInvalidate)(FSEventStreamRef);static void (*pFSEventStreamRelease)(FSEventStreamRef);static void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef, CFRunLoopRef, CFStringRef);static int (*pFSEventStreamStart)(FSEventStreamRef);static void (*pFSEventStreamStop)(FSEventStreamRef);
#define UV__FSEVENTS_PROCESS(handle, block)  do { QUEUE events;  QUEUE* q;  uv__fsevents_event_t* event; int err; uv_mutex_lock(&(handle)->cf_mutex); QUEUE_MOVE(&(handle)->cf_events, &events); err = (handle)->cf_error;  (handle)->cf_error = 0;  uv_mutex_unlock(&(handle)->cf_mutex); while (!QUEUE_EMPTY(&events)) {  q = QUEUE_HEAD(&events); event = QUEUE_DATA(q, uv__fsevents_event_t, member); QUEUE_REMOVE(q);  if (!uv__is_closing((handle)) && uv__is_active((handle)))  block uv__free(event); }  if (err != 0 && !uv__is_closing((handle)) && uv__is_active((handle)))  (handle)->cb((handle), NULL, 0, err);  } while (0)
static void uv__fsevents_cb(uv_async_t* cb) { uv_fs_event_t* handle; handle = cb->data; UV__FSEVENTS_PROCESS(handle, { handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0); });}static void uv__fsevents_push_event(uv_fs_event_t* handle, QUEUE* events, int err) { assert(events != NULL || err != 0); uv_mutex_lock(&handle->cf_mutex); if (events != NULL) QUEUE_ADD(&handle->cf_events, events); if (err != 0) handle->cf_error = err; uv_mutex_unlock(&handle->cf_mutex); uv_async_send(handle->cf_cb);}static void uv__fsevents_event_cb(const FSEventStreamRef streamRef, void* info, size_t numEvents, void* eventPaths, const FSEventStreamEventFlags eventFlags[], const FSEventStreamEventId eventIds[]) { size_t i; int len; char** paths; char* path; char* pos; uv_fs_event_t* handle; QUEUE* q; uv_loop_t* loop; uv__cf_loop_state_t* state; uv__fsevents_event_t* event; FSEventStreamEventFlags flags; QUEUE head; loop = info; state = loop->cf_state; assert(state != NULL); paths = eventPaths; uv_mutex_lock(&state->fsevent_mutex); QUEUE_FOREACH(q, &state->fsevent_handles) { handle = QUEUE_DATA(q, uv_fs_event_t, cf_member); QUEUE_INIT(&head); for (i = 0; i < numEvents; ++i) { flags = eventFlags[i]; if (flags & kFSEventsSystem) continue; path = paths[i]; len = strlen(path); if (handle->realpath_len == 0) continue;  if (len < handle->realpath_len) continue; if (handle->realpath_len != len && handle->realpath_len > 1 && path[handle->realpath_len] != '/') continue; if (memcmp(path, handle->realpath, handle->realpath_len) != 0) continue; if (!(handle->realpath_len == 1 && handle->realpath[0] == '/')) { path += handle->realpath_len; len -= handle->realpath_len; if (len <= 1 && (flags & kFSEventStreamEventFlagItemIsDir)) continue; if (len == 0) { while (len < handle->realpath_len && path[-1] != '/') { --path; ++len; } flags &= ~kFSEventsRenamed; } else { ++path; --len; } } if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != '\0') { pos = strchr(path + 1, '/'); if (pos != NULL) continue; } event = uv__malloc(sizeof(*event) + len); if (event == NULL) break; memset(event, 0, sizeof(*event)); memcpy(event->path, path, len + 1); event->events = UV_RENAME; if (0 == (flags & kFSEventsRenamed)) { if (0 != (flags & kFSEventsModified) || 0 == (flags & kFSEventStreamEventFlagItemIsDir)) event->events = UV_CHANGE; } QUEUE_INSERT_TAIL(&head, &event->member); } if (!QUEUE_EMPTY(&head)) uv__fsevents_push_event(handle, &head, 0); } uv_mutex_unlock(&state->fsevent_mutex);}static int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) { uv__cf_loop_state_t* state; FSEventStreamContext ctx; FSEventStreamRef ref; CFAbsoluteTime latency; FSEventStreamCreateFlags flags; memset(&ctx, 0, sizeof(ctx)); ctx.info = loop; latency = 0.05; flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents; ref = pFSEventStreamCreate(NULL, &uv__fsevents_event_cb, &ctx, paths, kFSEventStreamEventIdSinceNow, latency, flags); assert(ref != NULL); state = loop->cf_state; pFSEventStreamScheduleWithRunLoop(ref, state->loop, *pkCFRunLoopDefaultMode); if (!pFSEventStreamStart(ref)) { pFSEventStreamInvalidate(ref); pFSEventStreamRelease(ref); return UV_EMFILE; } state->fsevent_stream = ref; return 0;}static void uv__fsevents_destroy_stream(uv_loop_t* loop) { uv__cf_loop_state_t* state; state = loop->cf_state; if (state->fsevent_stream == NULL) return; pFSEventStreamStop(state->fsevent_stream); pFSEventStreamInvalidate(state->fsevent_stream); pFSEventStreamRelease(state->fsevent_stream); state->fsevent_stream = NULL;}static void uv__fsevents_reschedule(uv_fs_event_t* handle, uv__cf_loop_signal_type_t type) { uv__cf_loop_state_t* state; QUEUE* q; uv_fs_event_t* curr; CFArrayRef cf_paths; CFStringRef* paths; unsigned int i; int err; unsigned int path_count; state = handle->loop->cf_state; paths = NULL; cf_paths = NULL; err = 0; i = 0; uv_mutex_lock(&state->fsevent_mutex); if (state->fsevent_need_reschedule == 0) { uv_mutex_unlock(&state->fsevent_mutex); goto final; } state->fsevent_need_reschedule = 0; uv_mutex_unlock(&state->fsevent_mutex); uv__fsevents_destroy_stream(handle->loop); err = UV_ENOMEM; uv_mutex_lock(&state->fsevent_mutex); path_count = state->fsevent_handle_count; if (path_count != 0) { paths = uv__malloc(sizeof(*paths) * path_count); if (paths == NULL) { uv_mutex_unlock(&state->fsevent_mutex); goto final; } q = &state->fsevent_handles; for (; i < path_count; ++i) { q = QUEUE_NEXT(q); assert(q != &state->fsevent_handles); curr = QUEUE_DATA(q, uv_fs_event_t, cf_member); assert(curr->realpath != NULL); paths[i] = pCFStringCreateWithFileSystemRepresentation(NULL, curr->realpath); if (paths[i] == NULL) { uv_mutex_unlock(&state->fsevent_mutex); goto final; } } } uv_mutex_unlock(&state->fsevent_mutex); err = 0; if (path_count != 0) { cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL); if (cf_paths == NULL) { err = UV_ENOMEM; goto final; } err = uv__fsevents_create_stream(handle->loop, cf_paths); }final: if (err != 0) { if (cf_paths == NULL) { while (i != 0) pCFRelease(paths[--i]); uv__free(paths); } else { pCFRelease(cf_paths); } uv_mutex_lock(&state->fsevent_mutex); QUEUE_FOREACH(q, &state->fsevent_handles) { curr = QUEUE_DATA(q, uv_fs_event_t, cf_member); uv__fsevents_push_event(curr, NULL, err); } uv_mutex_unlock(&state->fsevent_mutex); }  if (type == kUVCFLoopSignalClosing) uv_sem_post(&state->fsevent_sem);}static int uv__fsevents_global_init(void) { static pthread_mutex_t global_init_mutex = PTHREAD_MUTEX_INITIALIZER; static void* core_foundation_handle; static void* core_services_handle; int err; err = 0; pthread_mutex_lock(&global_init_mutex); if (core_foundation_handle != NULL) goto out;  err = UV_ENOSYS; core_foundation_handle = dlopen("/System/Library/Frameworks/" "CoreFoundation.framework/" "Versions/A/CoreFoundation", RTLD_LAZY | RTLD_LOCAL); if (core_foundation_handle == NULL) goto out; core_services_handle = dlopen("/System/Library/Frameworks/" "CoreServices.framework/" "Versions/A/CoreServices", RTLD_LAZY | RTLD_LOCAL); if (core_services_handle == NULL) goto out; err = UV_ENOENT;
#define V(handle, symbol)  do { *(void **)(&p ## symbol) = dlsym((handle), #symbol); if (p ## symbol == NULL) goto out;  }  while (0)
 V(core_foundation_handle, CFArrayCreate); V(core_foundation_handle, CFRelease); V(core_foundation_handle, CFRunLoopAddSource); V(core_foundation_handle, CFRunLoopGetCurrent); V(core_foundation_handle, CFRunLoopRemoveSource); V(core_foundation_handle, CFRunLoopRun); V(core_foundation_handle, CFRunLoopSourceCreate); V(core_foundation_handle, CFRunLoopSourceSignal); V(core_foundation_handle, CFRunLoopStop); V(core_foundation_handle, CFRunLoopWakeUp); V(core_foundation_handle, CFStringCreateWithFileSystemRepresentation); V(core_foundation_handle, CFStringGetSystemEncoding); V(core_foundation_handle, kCFRunLoopDefaultMode); V(core_services_handle, FSEventStreamCreate); V(core_services_handle, FSEventStreamFlushSync); V(core_services_handle, FSEventStreamInvalidate); V(core_services_handle, FSEventStreamRelease); V(core_services_handle, FSEventStreamScheduleWithRunLoop); V(core_services_handle, FSEventStreamStart); V(core_services_handle, FSEventStreamStop);
#undef V
 err = 0;out: if (err && core_services_handle != NULL) { dlclose(core_services_handle); core_services_handle = NULL; } if (err && core_foundation_handle != NULL) { dlclose(core_foundation_handle); core_foundation_handle = NULL; } pthread_mutex_unlock(&global_init_mutex); return err;}static int uv__fsevents_loop_init(uv_loop_t* loop) { CFRunLoopSourceContext ctx; uv__cf_loop_state_t* state; pthread_attr_t attr; int err; if (loop->cf_state != NULL) return 0; err = uv__fsevents_global_init(); if (err) return err; state = uv__calloc(1, sizeof(*state)); if (state == NULL) return UV_ENOMEM; err = uv_mutex_init(&loop->cf_mutex); if (err) goto fail_mutex_init; err = uv_sem_init(&loop->cf_sem, 0); if (err) goto fail_sem_init; QUEUE_INIT(&loop->cf_signals); err = uv_sem_init(&state->fsevent_sem, 0); if (err) goto fail_fsevent_sem_init; err = uv_mutex_init(&state->fsevent_mutex); if (err) goto fail_fsevent_mutex_init; QUEUE_INIT(&state->fsevent_handles); state->fsevent_need_reschedule = 0; state->fsevent_handle_count = 0; memset(&ctx, 0, sizeof(ctx)); ctx.info = loop; ctx.perform = uv__cf_loop_cb; state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx); if (state->signal_source == NULL) { err = UV_ENOMEM; goto fail_signal_source_create; } if (pthread_attr_init(&attr)) abort(); if (pthread_attr_setstacksize(&attr, uv__thread_stack_size())) abort(); loop->cf_state = state; err = UV__ERR(pthread_create(&loop->cf_thread, &attr, uv__cf_loop_runner, loop)); if (pthread_attr_destroy(&attr)) abort(); if (err) goto fail_thread_create; uv_sem_wait(&loop->cf_sem); return 0;fail_thread_create: loop->cf_state = NULL;fail_signal_source_create: uv_mutex_destroy(&state->fsevent_mutex);fail_fsevent_mutex_init: uv_sem_destroy(&state->fsevent_sem);fail_fsevent_sem_init: uv_sem_destroy(&loop->cf_sem);fail_sem_init: uv_mutex_destroy(&loop->cf_mutex);fail_mutex_init: uv__free(state); return err;}void uv__fsevents_loop_delete(uv_loop_t* loop) { uv__cf_loop_signal_t* s; uv__cf_loop_state_t* state; QUEUE* q; if (loop->cf_state == NULL) return; if (uv__cf_loop_signal(loop, NULL, kUVCFLoopSignalRegular) != 0) abort(); uv_thread_join(&loop->cf_thread); uv_sem_destroy(&loop->cf_sem); uv_mutex_destroy(&loop->cf_mutex); while (!QUEUE_EMPTY(&loop->cf_signals)) { q = QUEUE_HEAD(&loop->cf_signals); s = QUEUE_DATA(q, uv__cf_loop_signal_t, member); QUEUE_REMOVE(q); uv__free(s); } state = loop->cf_state; uv_sem_destroy(&state->fsevent_sem); uv_mutex_destroy(&state->fsevent_mutex); pCFRelease(state->signal_source); uv__free(state); loop->cf_state = NULL;}static void* uv__cf_loop_runner(void* arg) { uv_loop_t* loop; uv__cf_loop_state_t* state; loop = arg; state = loop->cf_state; state->loop = pCFRunLoopGetCurrent(); pCFRunLoopAddSource(state->loop, state->signal_source, *pkCFRunLoopDefaultMode); uv_sem_post(&loop->cf_sem); pCFRunLoopRun(); pCFRunLoopRemoveSource(state->loop, state->signal_source, *pkCFRunLoopDefaultMode); state->loop = NULL; return NULL;}static void uv__cf_loop_cb(void* arg) { uv_loop_t* loop; uv__cf_loop_state_t* state; QUEUE* item; QUEUE split_head; uv__cf_loop_signal_t* s; loop = arg; state = loop->cf_state; uv_mutex_lock(&loop->cf_mutex); QUEUE_MOVE(&loop->cf_signals, &split_head); uv_mutex_unlock(&loop->cf_mutex); while (!QUEUE_EMPTY(&split_head)) { item = QUEUE_HEAD(&split_head); QUEUE_REMOVE(item); s = QUEUE_DATA(item, uv__cf_loop_signal_t, member); if (s->handle == NULL) pCFRunLoopStop(state->loop); else uv__fsevents_reschedule(s->handle, s->type); uv__free(s); }}int uv__cf_loop_signal(uv_loop_t* loop, uv_fs_event_t* handle, uv__cf_loop_signal_type_t type) { uv__cf_loop_signal_t* item; uv__cf_loop_state_t* state; item = uv__malloc(sizeof(*item)); if (item == NULL) return UV_ENOMEM; item->handle = handle; item->type = type; uv_mutex_lock(&loop->cf_mutex); QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member); state = loop->cf_state; assert(state != NULL); pCFRunLoopSourceSignal(state->signal_source); pCFRunLoopWakeUp(state->loop); uv_mutex_unlock(&loop->cf_mutex); return 0;}int uv__fsevents_init(uv_fs_event_t* handle) { int err; uv__cf_loop_state_t* state; err = uv__fsevents_loop_init(handle->loop); if (err) return err; handle->realpath = realpath(handle->path, NULL); if (handle->realpath == NULL) return UV__ERR(errno); handle->realpath_len = strlen(handle->realpath); QUEUE_INIT(&handle->cf_events); handle->cf_error = 0; handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb)); if (handle->cf_cb == NULL) { err = UV_ENOMEM; goto fail_cf_cb_malloc; } handle->cf_cb->data = handle; uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb); handle->cf_cb->flags |= UV_HANDLE_INTERNAL; uv_unref((uv_handle_t*) handle->cf_cb); err = uv_mutex_init(&handle->cf_mutex); if (err) goto fail_cf_mutex_init; state = handle->loop->cf_state; uv_mutex_lock(&state->fsevent_mutex); QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member); ++state->fsevent_handle_count; state->fsevent_need_reschedule = 1; uv_mutex_unlock(&state->fsevent_mutex); assert(handle != NULL); err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalRegular); if (err) goto fail_loop_signal; return 0;fail_loop_signal: uv_mutex_destroy(&handle->cf_mutex);fail_cf_mutex_init: uv__free(handle->cf_cb); handle->cf_cb = NULL;fail_cf_cb_malloc: uv__free(handle->realpath); handle->realpath = NULL; handle->realpath_len = 0; return err;}int uv__fsevents_close(uv_fs_event_t* handle) { int err; uv__cf_loop_state_t* state; if (handle->cf_cb == NULL) return UV_EINVAL; state = handle->loop->cf_state; uv_mutex_lock(&state->fsevent_mutex); QUEUE_REMOVE(&handle->cf_member); --state->fsevent_handle_count; state->fsevent_need_reschedule = 1; uv_mutex_unlock(&state->fsevent_mutex); assert(handle != NULL); err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing); if (err) return UV__ERR(err); uv_sem_wait(&state->fsevent_sem); uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) uv__free); handle->cf_cb = NULL; UV__FSEVENTS_PROCESS(handle, { }); uv_mutex_destroy(&handle->cf_mutex); uv__free(handle->realpath); handle->realpath = NULL; handle->realpath_len = 0; return 0;}
#endif 
