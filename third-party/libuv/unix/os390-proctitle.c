
#include "uv.h"
#include "internal.h"

#include <stdlib.h>
#include <string.h>
static uv_mutex_t process_title_mutex;static uv_once_t process_title_mutex_once = UV_ONCE_INIT;static char* process_title = NULL;static void* args_mem = NULL;static void init_process_title_mutex_once(void) { uv_mutex_init(&process_title_mutex);}char** uv_setup_args(int argc, char** argv) { char** new_argv; size_t size; char* s; int i; if (argc <= 0) return argv; size = 0; for (i = 0; i < argc; ++i) size += strlen(argv[i]) + 1; size += (argc + 1) * sizeof(char*); new_argv = uv__malloc(size); if (new_argv == NULL) return argv; s = (char*) &new_argv[argc + 1]; for (i = 0; i < argc; ++i) { size = strlen(argv[i]) + 1; memcpy(s, argv[i], size); new_argv[i] = s; s += size; } new_argv[i] = NULL; args_mem = new_argv; process_title = uv__strdup(argv[0]); return new_argv;}int uv_set_process_title(const char* title) { char* new_title; if (args_mem == NULL) return UV_ENOBUFS; new_title = uv__strdup(title); if (new_title == NULL) return UV_ENOMEM; uv_once(&process_title_mutex_once, init_process_title_mutex_once); uv_mutex_lock(&process_title_mutex); if (process_title != NULL) uv__free(process_title); process_title = new_title; uv_mutex_unlock(&process_title_mutex); return 0;}int uv_get_process_title(char* buffer, size_t size) { size_t len; if (buffer == NULL || size == 0) return UV_EINVAL; if (args_mem == NULL || process_title == NULL) return UV_ENOBUFS; uv_once(&process_title_mutex_once, init_process_title_mutex_once); uv_mutex_lock(&process_title_mutex); len = strlen(process_title); if (size <= len) { uv_mutex_unlock(&process_title_mutex); return UV_ENOBUFS; } strcpy(buffer, process_title); uv_mutex_unlock(&process_title_mutex); return 0;}void uv__process_title_cleanup(void) { uv__free(args_mem); args_mem = NULL;}