
#include "uv.h"
#include "internal.h"
#include <errno.h>
#include <sys/epoll.h>
int uv__epoll_init(uv_loop_t* loop) { int fd; fd = epoll_create1(O_CLOEXEC); if (fd == -1 && (errno == ENOSYS || errno == EINVAL)) { fd = epoll_create(256); if (fd != -1) uv__cloexec(fd, 1); } loop->backend_fd = fd; if (fd == -1) return UV__ERR(errno); return 0;}void uv__platform_invalidate_fd(uv_loop_t* loop, int fd) { struct epoll_event* events; struct epoll_event dummy; uintptr_t i; uintptr_t nfds; assert(loop->watchers != NULL); assert(fd >= 0); events = (struct epoll_event*) loop->watchers[loop->nwatchers]; nfds = (uintptr_t) loop->watchers[loop->nwatchers + 1]; if (events != NULL) for (i = 0; i < nfds; ++i) if (events[i].data.fd == fd) events[i].data.fd = -1;  if (loop->backend_fd >= 0) { memset(&dummy, 0, sizeof(dummy)); epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, &dummy); }}int uv__io_check_fd(uv_loop_t* loop, int fd) { struct epoll_event e; int rc; memset(&e, 0, sizeof(e)); e.events = POLLIN; e.data.fd = -1; rc = 0; if (epoll_ctl(loop->backend_fd, EPOLL_CTL_ADD, fd, &e)) if (errno != EEXIST) rc = UV__ERR(errno); if (rc == 0) if (epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, &e)) abort(); return rc;}void uv__io_poll(uv_loop_t* loop, int timeout) { static const int max_safe_timeout = 1789569; static int no_epoll_pwait_cached; static int no_epoll_wait_cached; int no_epoll_pwait; int no_epoll_wait; struct epoll_event events[1024]; struct epoll_event* pe; struct epoll_event e; int real_timeout; QUEUE* q; uv__io_t* w; sigset_t sigset; uint64_t sigmask; uint64_t base; int have_signals; int nevents; int count; int nfds; int fd; int op; int i; int user_timeout; int reset_timeout; if (loop->nfds == 0) { assert(QUEUE_EMPTY(&loop->watcher_queue)); return; } memset(&e, 0, sizeof(e)); while (!QUEUE_EMPTY(&loop->watcher_queue)) { q = QUEUE_HEAD(&loop->watcher_queue); QUEUE_REMOVE(q); QUEUE_INIT(q); w = QUEUE_DATA(q, uv__io_t, watcher_queue); assert(w->pevents != 0); assert(w->fd >= 0); assert(w->fd < (int) loop->nwatchers); e.events = w->pevents; e.data.fd = w->fd; if (w->events == 0) op = EPOLL_CTL_ADD; else op = EPOLL_CTL_MOD;  if (epoll_ctl(loop->backend_fd, op, w->fd, &e)) { if (errno != EEXIST) abort(); assert(op == EPOLL_CTL_ADD); if (epoll_ctl(loop->backend_fd, EPOLL_CTL_MOD, w->fd, &e)) abort(); } w->events = w->pevents; } sigmask = 0; if (loop->flags & UV_LOOP_BLOCK_SIGPROF) { sigemptyset(&sigset); sigaddset(&sigset, SIGPROF); sigmask |= 1 << (SIGPROF - 1); } assert(timeout >= -1); base = loop->time; count = 48; real_timeout = timeout; if (uv__get_internal_fields(loop)->flags & UV_METRICS_IDLE_TIME) { reset_timeout = 1; user_timeout = timeout; timeout = 0; } else { reset_timeout = 0; user_timeout = 0; } no_epoll_pwait = uv__load_relaxed(&no_epoll_pwait_cached); no_epoll_wait = uv__load_relaxed(&no_epoll_wait_cached); for (;;) { if (timeout != 0) uv__metrics_set_provider_entry_time(loop); if (sizeof(int32_t) == sizeof(long) && timeout >= max_safe_timeout) timeout = max_safe_timeout; if (sigmask != 0 && no_epoll_pwait != 0) if (pthread_sigmask(SIG_BLOCK, &sigset, NULL)) abort(); if (no_epoll_wait != 0 || (sigmask != 0 && no_epoll_pwait == 0)) { nfds = epoll_pwait(loop->backend_fd, events, ARRAY_SIZE(events), timeout, &sigset); if (nfds == -1 && errno == ENOSYS) { uv__store_relaxed(&no_epoll_pwait_cached, 1); no_epoll_pwait = 1; } } else { nfds = epoll_wait(loop->backend_fd, events, ARRAY_SIZE(events), timeout); if (nfds == -1 && errno == ENOSYS) { uv__store_relaxed(&no_epoll_wait_cached, 1); no_epoll_wait = 1; } } if (sigmask != 0 && no_epoll_pwait != 0) if (pthread_sigmask(SIG_UNBLOCK, &sigset, NULL)) abort(); SAVE_ERRNO(uv__update_time(loop)); if (nfds == 0) { assert(timeout != -1); if (reset_timeout != 0) { timeout = user_timeout; reset_timeout = 0; } if (timeout == -1) continue; if (timeout == 0) return; goto update_timeout; } if (nfds == -1) { if (errno == ENOSYS) { assert(no_epoll_wait == 0 || no_epoll_pwait == 0); continue; } if (errno != EINTR) abort(); if (reset_timeout != 0) { timeout = user_timeout; reset_timeout = 0; } if (timeout == -1) continue; if (timeout == 0) return; goto update_timeout; } have_signals = 0; nevents = 0; { union { struct epoll_event* events; uv__io_t* watchers; } x; x.events = events; assert(loop->watchers != NULL); loop->watchers[loop->nwatchers] = x.watchers; loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds; } for (i = 0; i < nfds; ++i) { pe = events + i; fd = pe->data.fd; if (fd == -1) continue; assert(fd >= 0); assert((unsigned) fd < loop->nwatchers); w = loop->watchers[fd]; if (w == NULL) { epoll_ctl(loop->backend_fd, EPOLL_CTL_DEL, fd, pe); continue; } pe->events &= w->pevents | POLLERR | POLLHUP; if (pe->events == POLLERR || pe->events == POLLHUP) pe->events |= w->pevents & (POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI); if (pe->events != 0) {  if (w == &loop->signal_io_watcher) { have_signals = 1; } else { uv__metrics_update_idle_time(loop); w->cb(loop, w, pe->events); } ++nevents; } } if (reset_timeout != 0) { timeout = user_timeout; reset_timeout = 0; } if (have_signals != 0) { uv__metrics_update_idle_time(loop); loop->signal_io_watcher.cb(loop, &loop->signal_io_watcher, POLLIN); } loop->watchers[loop->nwatchers] = NULL; loop->watchers[loop->nwatchers + 1] = NULL; if (have_signals != 0) return; if (nevents != 0) { if (nfds == ARRAY_SIZE(events) && --count != 0) { timeout = 0; continue; } return; } if (timeout == 0) return; if (timeout == -1) continue;update_timeout: assert(timeout > 0); real_timeout -= (loop->time - base); if (real_timeout <= 0) return; timeout = real_timeout; }}