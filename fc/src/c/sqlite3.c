
#define SQLITE_CORE 1
#define SQLITE_AMALGAMATION 1
#ifndef SQLITE_PRIVATE
# define SQLITE_PRIVATE static
#endif
#define SQLITE_UDL_CAPABLE_PARSER 1
#ifndef SQLITEINT_H
#define SQLITEINT_H
#ifndef SQLITE_TCLAPI
# define SQLITE_TCLAPI
#endif
#ifndef SQLITE_MSVC_H
#define SQLITE_MSVC_H
#if defined(_MSC_VER)
#pragma warning(disable : 4054)
#pragma warning(disable : 4055)
#pragma warning(disable : 4100)
#pragma warning(disable : 4127)
#pragma warning(disable : 4130)
#pragma warning(disable : 4152)
#pragma warning(disable : 4189)
#pragma warning(disable : 4206)
#pragma warning(disable : 4210)
#pragma warning(disable : 4232)
#pragma warning(disable : 4244)
#pragma warning(disable : 4305)
#pragma warning(disable : 4306)
#pragma warning(disable : 4702)
#pragma warning(disable : 4706)
#endif
#if defined(_MSC_VER) && !defined(_WIN64)
#undef SQLITE_4_BYTE_ALIGNED_MALLOC
#define SQLITE_4_BYTE_ALIGNED_MALLOC
#endif
#endif
#if defined(__RTP__) || defined(_WRS_KERNEL)
#include <vxWorks.h>
#include <pthread.h>
#define OS_VXWORKS 1
#define SQLITE_OS_OTHER 0
#define SQLITE_HOMEGROWN_RECURSIVE_MUTEX 1
#define SQLITE_OMIT_LOAD_EXTENSION 1
#define SQLITE_ENABLE_LOCKING_STYLE 0
#define HAVE_UTIME 1
#else
#define OS_VXWORKS 0
#define HAVE_FCHOWN 1
#define HAVE_READLINK 1
#define HAVE_LSTAT 1
#endif
#ifndef SQLITE_DISABLE_LFS
# define _LARGE_FILE  1
# ifndef _FILE_OFFSET_BITS
#  define _FILE_OFFSET_BITS 64
# endif
# define _LARGEFILE_SOURCE 1
#endif
#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)
# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)
#else
# define GCC_VERSION 0
#endif
#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)
# define MSVC_VERSION _MSC_VER
#else
# define MSVC_VERSION 0
#endif
#ifndef SQLITE_HAVE_C99_MATH_FUNCS
# if MSVC_VERSION==0 || MSVC_VERSION>=1800
# define SQLITE_HAVE_C99_MATH_FUNCS (1)
# else
# define SQLITE_HAVE_C99_MATH_FUNCS (0)
# endif
#endif
#if defined(__GNUC__) && !defined(_GNU_SOURCE)
# define _GNU_SOURCE
#endif
#if defined(__OpenBSD__) && !defined(_BSD_SOURCE)
# define _BSD_SOURCE
#endif
#if GCC_VERSION>=7000000
# define deliberate_fall_through __attribute__((fallthrough));
#else
# define deliberate_fall_through
#endif
#if defined(_HAVE_MINGW_H)
# include "mingw.h"
#elif defined(_HAVE__MINGW_H)
# include "_mingw.h"
#endif
#if !defined(_USE_32BIT_TIME_T) && !defined(_USE_64BIT_TIME_T) &&  defined(_WIN32) && !defined(_WIN64) &&  defined(__MINGW_MAJOR_VERSION) && __MINGW_MAJOR_VERSION >= 4 &&  defined(__MSVCRT__)

# define _USE_32BIT_TIME_T
#endif
#ifdef SQLITE_CUSTOM_INCLUDE
# define INC_STRINGIFY_(f) #f
# define INC_STRINGIFY(f) INC_STRINGIFY_(f)
# include INC_STRINGIFY(SQLITE_CUSTOM_INCLUDE)
#endif
#ifndef SQLITE3_H
#define SQLITE3_H
#include <stdarg.h>
#if 0
extern "C" {
#endif
#ifndef SQLITE_EXTERN
# define SQLITE_EXTERN extern
#endif
#ifndef SQLITE_API
# define SQLITE_API
#endif
#ifndef SQLITE_CDECL
# define SQLITE_CDECL
#endif
#ifndef SQLITE_APICALL
# define SQLITE_APICALL
#endif
#ifndef SQLITE_STDCALL
# define SQLITE_STDCALL SQLITE_APICALL
#endif
#ifndef SQLITE_CALLBACK
# define SQLITE_CALLBACK
#endif
#ifndef SQLITE_SYSAPI
# define SQLITE_SYSAPI
#endif
#define SQLITE_DEPRECATED
#define SQLITE_EXPERIMENTAL
#ifdef SQLITE_VERSION
# undef SQLITE_VERSION
#endif
#ifdef SQLITE_VERSION_NUMBER
# undef SQLITE_VERSION_NUMBER
#endif
#define SQLITE_VERSION "3.66.6"
#define SQLITE_VERSION_NUMBER 3066006
#define SQLITE_SOURCE_ID "2023-06-06 16:26:46 877ba266cbf61d9290b571c0e6d62a20c224ca3ad82971edc46b29818d6d16a1"
SQLITE_API const char sqlite3_version[] = SQLITE_VERSION; SQLITE_API const char *sqlite3_libversion(void); SQLITE_API const char *sqlite3_sourceid(void); SQLITE_API int sqlite3_libversion_number(void);
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
SQLITE_API int sqlite3_compileoption_used(const char *zOptName); SQLITE_API const char *sqlite3_compileoption_get(int N);
#else
# define sqlite3_compileoption_used(X) 0
# define sqlite3_compileoption_get(X) ((void*)0)
#endif
SQLITE_API int sqlite3_threadsafe(void); typedef struct sqlite3 sqlite3;
#ifdef SQLITE_INT64_TYPE
 typedef SQLITE_INT64_TYPE sqlite_int64;
# ifdef SQLITE_UINT64_TYPE
 typedef SQLITE_UINT64_TYPE sqlite_uint64;
# else
 typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;
# endif
#elif defined(_MSC_VER) || defined(__BORLANDC__)
 typedef __int64 sqlite_int64;  typedef unsigned __int64 sqlite_uint64;
#else
 typedef long long int sqlite_int64;  typedef unsigned long long int sqlite_uint64;
#endif
typedef sqlite_int64 sqlite3_int64; typedef sqlite_uint64 sqlite3_uint64;
#ifdef SQLITE_OMIT_FLOATING_POINT
# define double sqlite3_int64
#endif
SQLITE_API int sqlite3_close(sqlite3*); SQLITE_API int sqlite3_close_v2(sqlite3*); typedef int (*sqlite3_callback)(void*,int,char**, char**); SQLITE_API int sqlite3_exec(  sqlite3*,  const char *sql,  int (*callback)(void*,int,char**,char**),  void *,  char **errmsg );
#define SQLITE_OK  0
#define SQLITE_ERROR 1
#define SQLITE_INTERNAL  2
#define SQLITE_PERM  3
#define SQLITE_ABORT 4
#define SQLITE_BUSY  5
#define SQLITE_LOCKED  6
#define SQLITE_NOMEM 7
#define SQLITE_READONLY  8
#define SQLITE_INTERRUPT 9
#define SQLITE_IOERR  10
#define SQLITE_CORRUPT  11
#define SQLITE_NOTFOUND 12
#define SQLITE_FULL 13
#define SQLITE_CANTOPEN 14
#define SQLITE_PROTOCOL 15
#define SQLITE_EMPTY  16
#define SQLITE_SCHEMA 17
#define SQLITE_TOOBIG 18
#define SQLITE_CONSTRAINT 19
#define SQLITE_MISMATCH 20
#define SQLITE_MISUSE 21
#define SQLITE_NOLFS  22
#define SQLITE_AUTH 23
#define SQLITE_FORMAT 24
#define SQLITE_RANGE  25
#define SQLITE_NOTADB 26
#define SQLITE_NOTICE 27
#define SQLITE_WARNING  28
#define SQLITE_ROW  100
#define SQLITE_DONE 101
#define SQLITE_ERROR_MISSING_COLLSEQ  (SQLITE_ERROR | (1<<8))
#define SQLITE_ERROR_RETRY  (SQLITE_ERROR | (2<<8))
#define SQLITE_ERROR_SNAPSHOT (SQLITE_ERROR | (3<<8))
#define SQLITE_IOERR_READ (SQLITE_IOERR | (1<<8))
#define SQLITE_IOERR_SHORT_READ (SQLITE_IOERR | (2<<8))
#define SQLITE_IOERR_WRITE  (SQLITE_IOERR | (3<<8))
#define SQLITE_IOERR_FSYNC  (SQLITE_IOERR | (4<<8))
#define SQLITE_IOERR_DIR_FSYNC  (SQLITE_IOERR | (5<<8))
#define SQLITE_IOERR_TRUNCATE (SQLITE_IOERR | (6<<8))
#define SQLITE_IOERR_FSTAT  (SQLITE_IOERR | (7<<8))
#define SQLITE_IOERR_UNLOCK (SQLITE_IOERR | (8<<8))
#define SQLITE_IOERR_RDLOCK (SQLITE_IOERR | (9<<8))
#define SQLITE_IOERR_DELETE (SQLITE_IOERR | (10<<8))
#define SQLITE_IOERR_BLOCKED  (SQLITE_IOERR | (11<<8))
#define SQLITE_IOERR_NOMEM  (SQLITE_IOERR | (12<<8))
#define SQLITE_IOERR_ACCESS (SQLITE_IOERR | (13<<8))
#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))
#define SQLITE_IOERR_LOCK (SQLITE_IOERR | (15<<8))
#define SQLITE_IOERR_CLOSE  (SQLITE_IOERR | (16<<8))
#define SQLITE_IOERR_DIR_CLOSE  (SQLITE_IOERR | (17<<8))
#define SQLITE_IOERR_SHMOPEN  (SQLITE_IOERR | (18<<8))
#define SQLITE_IOERR_SHMSIZE  (SQLITE_IOERR | (19<<8))
#define SQLITE_IOERR_SHMLOCK  (SQLITE_IOERR | (20<<8))
#define SQLITE_IOERR_SHMMAP (SQLITE_IOERR | (21<<8))
#define SQLITE_IOERR_SEEK (SQLITE_IOERR | (22<<8))
#define SQLITE_IOERR_DELETE_NOENT (SQLITE_IOERR | (23<<8))
#define SQLITE_IOERR_MMAP (SQLITE_IOERR | (24<<8))
#define SQLITE_IOERR_GETTEMPPATH  (SQLITE_IOERR | (25<<8))
#define SQLITE_IOERR_CONVPATH (SQLITE_IOERR | (26<<8))
#define SQLITE_IOERR_VNODE  (SQLITE_IOERR | (27<<8))
#define SQLITE_IOERR_AUTH (SQLITE_IOERR | (28<<8))
#define SQLITE_IOERR_BEGIN_ATOMIC (SQLITE_IOERR | (29<<8))
#define SQLITE_IOERR_COMMIT_ATOMIC  (SQLITE_IOERR | (30<<8))
#define SQLITE_IOERR_ROLLBACK_ATOMIC  (SQLITE_IOERR | (31<<8))
#define SQLITE_IOERR_DATA (SQLITE_IOERR | (32<<8))
#define SQLITE_IOERR_CORRUPTFS  (SQLITE_IOERR | (33<<8))
#define SQLITE_LOCKED_SHAREDCACHE (SQLITE_LOCKED | (1<<8))
#define SQLITE_LOCKED_VTAB  (SQLITE_LOCKED | (2<<8))
#define SQLITE_BUSY_RECOVERY  (SQLITE_BUSY  | (1<<8))
#define SQLITE_BUSY_SNAPSHOT  (SQLITE_BUSY  | (2<<8))
#define SQLITE_BUSY_TIMEOUT (SQLITE_BUSY  | (3<<8))
#define SQLITE_CANTOPEN_NOTEMPDIR (SQLITE_CANTOPEN | (1<<8))
#define SQLITE_CANTOPEN_ISDIR (SQLITE_CANTOPEN | (2<<8))
#define SQLITE_CANTOPEN_FULLPATH  (SQLITE_CANTOPEN | (3<<8))
#define SQLITE_CANTOPEN_CONVPATH  (SQLITE_CANTOPEN | (4<<8))
#define SQLITE_CANTOPEN_DIRTYWAL  (SQLITE_CANTOPEN | (5<<8))
#define SQLITE_CANTOPEN_SYMLINK (SQLITE_CANTOPEN | (6<<8))
#define SQLITE_CORRUPT_VTAB (SQLITE_CORRUPT | (1<<8))
#define SQLITE_CORRUPT_SEQUENCE (SQLITE_CORRUPT | (2<<8))
#define SQLITE_CORRUPT_INDEX  (SQLITE_CORRUPT | (3<<8))
#define SQLITE_READONLY_RECOVERY  (SQLITE_READONLY | (1<<8))
#define SQLITE_READONLY_CANTLOCK  (SQLITE_READONLY | (2<<8))
#define SQLITE_READONLY_ROLLBACK  (SQLITE_READONLY | (3<<8))
#define SQLITE_READONLY_DBMOVED (SQLITE_READONLY | (4<<8))
#define SQLITE_READONLY_CANTINIT  (SQLITE_READONLY | (5<<8))
#define SQLITE_READONLY_DIRECTORY (SQLITE_READONLY | (6<<8))
#define SQLITE_ABORT_ROLLBACK (SQLITE_ABORT | (2<<8))
#define SQLITE_CONSTRAINT_CHECK (SQLITE_CONSTRAINT | (1<<8))
#define SQLITE_CONSTRAINT_COMMITHOOK  (SQLITE_CONSTRAINT | (2<<8))
#define SQLITE_CONSTRAINT_FOREIGNKEY  (SQLITE_CONSTRAINT | (3<<8))
#define SQLITE_CONSTRAINT_FUNCTION  (SQLITE_CONSTRAINT | (4<<8))
#define SQLITE_CONSTRAINT_NOTNULL (SQLITE_CONSTRAINT | (5<<8))
#define SQLITE_CONSTRAINT_PRIMARYKEY  (SQLITE_CONSTRAINT | (6<<8))
#define SQLITE_CONSTRAINT_TRIGGER (SQLITE_CONSTRAINT | (7<<8))
#define SQLITE_CONSTRAINT_UNIQUE  (SQLITE_CONSTRAINT | (8<<8))
#define SQLITE_CONSTRAINT_VTAB  (SQLITE_CONSTRAINT | (9<<8))
#define SQLITE_CONSTRAINT_ROWID (SQLITE_CONSTRAINT |(10<<8))
#define SQLITE_CONSTRAINT_PINNED  (SQLITE_CONSTRAINT |(11<<8))
#define SQLITE_CONSTRAINT_DATATYPE  (SQLITE_CONSTRAINT |(12<<8))
#define SQLITE_NOTICE_RECOVER_WAL (SQLITE_NOTICE | (1<<8))
#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))
#define SQLITE_WARNING_AUTOINDEX  (SQLITE_WARNING | (1<<8))
#define SQLITE_AUTH_USER  (SQLITE_AUTH | (1<<8))
#define SQLITE_OK_LOAD_PERMANENTLY  (SQLITE_OK | (1<<8))
#define SQLITE_OK_SYMLINK (SQLITE_OK | (2<<8))
#define SQLITE_OPEN_READONLY  0x00000001
#define SQLITE_OPEN_READWRITE 0x00000002
#define SQLITE_OPEN_CREATE  0x00000004
#define SQLITE_OPEN_DELETEONCLOSE 0x00000008
#define SQLITE_OPEN_EXCLUSIVE 0x00000010
#define SQLITE_OPEN_AUTOPROXY 0x00000020
#define SQLITE_OPEN_URI 0x00000040
#define SQLITE_OPEN_MEMORY  0x00000080
#define SQLITE_OPEN_MAIN_DB 0x00000100
#define SQLITE_OPEN_TEMP_DB 0x00000200
#define SQLITE_OPEN_TRANSIENT_DB  0x00000400
#define SQLITE_OPEN_MAIN_JOURNAL  0x00000800
#define SQLITE_OPEN_TEMP_JOURNAL  0x00001000
#define SQLITE_OPEN_SUBJOURNAL  0x00002000
#define SQLITE_OPEN_SUPER_JOURNAL 0x00004000
#define SQLITE_OPEN_NOMUTEX 0x00008000
#define SQLITE_OPEN_FULLMUTEX 0x00010000
#define SQLITE_OPEN_SHAREDCACHE 0x00020000
#define SQLITE_OPEN_PRIVATECACHE  0x00040000
#define SQLITE_OPEN_WAL 0x00080000
#define SQLITE_OPEN_NOFOLLOW  0x01000000
#define SQLITE_OPEN_EXRESCODE 0x02000000
#define SQLITE_OPEN_MASTER_JOURNAL  0x00004000
#define SQLITE_IOCAP_ATOMIC  0x00000001
#define SQLITE_IOCAP_ATOMIC512 0x00000002
#define SQLITE_IOCAP_ATOMIC1K  0x00000004
#define SQLITE_IOCAP_ATOMIC2K  0x00000008
#define SQLITE_IOCAP_ATOMIC4K  0x00000010
#define SQLITE_IOCAP_ATOMIC8K  0x00000020
#define SQLITE_IOCAP_ATOMIC16K 0x00000040
#define SQLITE_IOCAP_ATOMIC32K 0x00000080
#define SQLITE_IOCAP_ATOMIC64K 0x00000100
#define SQLITE_IOCAP_SAFE_APPEND 0x00000200
#define SQLITE_IOCAP_SEQUENTIAL  0x00000400
#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN 0x00000800
#define SQLITE_IOCAP_POWERSAFE_OVERWRITE 0x00001000
#define SQLITE_IOCAP_IMMUTABLE 0x00002000
#define SQLITE_IOCAP_BATCH_ATOMIC  0x00004000
#define SQLITE_LOCK_NONE 0
#define SQLITE_LOCK_SHARED 1
#define SQLITE_LOCK_RESERVED 2
#define SQLITE_LOCK_PENDING  3
#define SQLITE_LOCK_EXCLUSIVE  4
#define SQLITE_SYNC_NORMAL 0x00002
#define SQLITE_SYNC_FULL 0x00003
#define SQLITE_SYNC_DATAONLY 0x00010
typedef struct sqlite3_file sqlite3_file; struct sqlite3_file {  const struct sqlite3_io_methods *pMethods; }; typedef struct sqlite3_io_methods sqlite3_io_methods; struct sqlite3_io_methods {  int iVersion;  int (*xClose)(sqlite3_file*);  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);  int (*xSync)(sqlite3_file*, int flags);  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);  int (*xLock)(sqlite3_file*, int);  int (*xUnlock)(sqlite3_file*, int);  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);  int (*xFileControl)(sqlite3_file*, int op, void *pArg);  int (*xSectorSize)(sqlite3_file*);  int (*xDeviceCharacteristics)(sqlite3_file*);  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);  void (*xShmBarrier)(sqlite3_file*);  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p); };
#define SQLITE_FCNTL_LOCKSTATE  1
#define SQLITE_FCNTL_GET_LOCKPROXYFILE  2
#define SQLITE_FCNTL_SET_LOCKPROXYFILE  3
#define SQLITE_FCNTL_LAST_ERRNO 4
#define SQLITE_FCNTL_SIZE_HINT  5
#define SQLITE_FCNTL_CHUNK_SIZE 6
#define SQLITE_FCNTL_FILE_POINTER 7
#define SQLITE_FCNTL_SYNC_OMITTED 8
#define SQLITE_FCNTL_WIN32_AV_RETRY 9
#define SQLITE_FCNTL_PERSIST_WAL 10
#define SQLITE_FCNTL_OVERWRITE 11
#define SQLITE_FCNTL_VFSNAME 12
#define SQLITE_FCNTL_POWERSAFE_OVERWRITE 13
#define SQLITE_FCNTL_PRAGMA  14
#define SQLITE_FCNTL_BUSYHANDLER 15
#define SQLITE_FCNTL_TEMPFILENAME  16
#define SQLITE_FCNTL_MMAP_SIZE 18
#define SQLITE_FCNTL_TRACE 19
#define SQLITE_FCNTL_HAS_MOVED 20
#define SQLITE_FCNTL_SYNC  21
#define SQLITE_FCNTL_COMMIT_PHASETWO 22
#define SQLITE_FCNTL_WIN32_SET_HANDLE  23
#define SQLITE_FCNTL_WAL_BLOCK 24
#define SQLITE_FCNTL_ZIPVFS  25
#define SQLITE_FCNTL_RBU 26
#define SQLITE_FCNTL_VFS_POINTER 27
#define SQLITE_FCNTL_JOURNAL_POINTER 28
#define SQLITE_FCNTL_WIN32_GET_HANDLE  29
#define SQLITE_FCNTL_PDB 30
#define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE  31
#define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE 32
#define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE 33
#define SQLITE_FCNTL_LOCK_TIMEOUT  34
#define SQLITE_FCNTL_DATA_VERSION  35
#define SQLITE_FCNTL_SIZE_LIMIT  36
#define SQLITE_FCNTL_CKPT_DONE 37
#define SQLITE_FCNTL_RESERVE_BYTES 38
#define SQLITE_FCNTL_CKPT_START  39
#define SQLITE_FCNTL_EXTERNAL_READER 40
#define SQLITE_FCNTL_CKSM_FILE 41
#define SQLITE_GET_LOCKPROXYFILE SQLITE_FCNTL_GET_LOCKPROXYFILE
#define SQLITE_SET_LOCKPROXYFILE SQLITE_FCNTL_SET_LOCKPROXYFILE
#define SQLITE_LAST_ERRNO  SQLITE_FCNTL_LAST_ERRNO
typedef struct sqlite3_mutex sqlite3_mutex; typedef struct sqlite3_api_routines sqlite3_api_routines; typedef struct sqlite3_vfs sqlite3_vfs; typedef void (*sqlite3_syscall_ptr)(void); struct sqlite3_vfs {  int iVersion;  int szOsFile;  int mxPathname;  sqlite3_vfs *pNext;  const char *zName;  void *pAppData;  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,   int flags, int *pOutFlags);  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);  void (*xDlClose)(sqlite3_vfs*, void*);  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);  int (*xSleep)(sqlite3_vfs*, int microseconds);  int (*xCurrentTime)(sqlite3_vfs*, double*);  int (*xGetLastError)(sqlite3_vfs*, int, char *);  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName); };
#define SQLITE_ACCESS_EXISTS 0
#define SQLITE_ACCESS_READWRITE 1
#define SQLITE_ACCESS_READ 2
#define SQLITE_SHM_UNLOCK  1
#define SQLITE_SHM_LOCK  2
#define SQLITE_SHM_SHARED  4
#define SQLITE_SHM_EXCLUSIVE 8
#define SQLITE_SHM_NLOCK 8
SQLITE_API int sqlite3_initialize(void); SQLITE_API int sqlite3_shutdown(void); SQLITE_API int sqlite3_os_init(void); SQLITE_API int sqlite3_os_end(void); SQLITE_API int sqlite3_config(int, ...); SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...); typedef struct sqlite3_mem_methods sqlite3_mem_methods; struct sqlite3_mem_methods {  void *(*xMalloc)(int);  void (*xFree)(void*);  void *(*xRealloc)(void*,int);  int (*xSize)(void*);  int (*xRoundup)(int);  int (*xInit)(void*);  void (*xShutdown)(void*);  void *pAppData; };
#define SQLITE_CONFIG_SINGLETHREAD 1
#define SQLITE_CONFIG_MULTITHREAD  2
#define SQLITE_CONFIG_SERIALIZED 3
#define SQLITE_CONFIG_MALLOC 4
#define SQLITE_CONFIG_GETMALLOC  5
#define SQLITE_CONFIG_SCRATCH  6
#define SQLITE_CONFIG_PAGECACHE  7
#define SQLITE_CONFIG_HEAP 8
#define SQLITE_CONFIG_MEMSTATUS  9
#define SQLITE_CONFIG_MUTEX 10
#define SQLITE_CONFIG_GETMUTEX  11
#define SQLITE_CONFIG_LOOKASIDE 13
#define SQLITE_CONFIG_PCACHE  14
#define SQLITE_CONFIG_GETPCACHE 15
#define SQLITE_CONFIG_LOG 16
#define SQLITE_CONFIG_URI 17
#define SQLITE_CONFIG_PCACHE2 18
#define SQLITE_CONFIG_GETPCACHE2  19
#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20
#define SQLITE_CONFIG_SQLLOG  21
#define SQLITE_CONFIG_MMAP_SIZE 22
#define SQLITE_CONFIG_WIN32_HEAPSIZE 23
#define SQLITE_CONFIG_PCACHE_HDRSZ 24
#define SQLITE_CONFIG_PMASZ  25
#define SQLITE_CONFIG_STMTJRNL_SPILL 26
#define SQLITE_CONFIG_SMALL_MALLOC 27
#define SQLITE_CONFIG_SORTERREF_SIZE 28
#define SQLITE_CONFIG_MEMDB_MAXSIZE  29
#define SQLITE_DBCONFIG_MAINDBNAME 1000
#define SQLITE_DBCONFIG_LOOKASIDE  1001
#define SQLITE_DBCONFIG_ENABLE_FKEY  1002
#define SQLITE_DBCONFIG_ENABLE_TRIGGER 1003
#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004
#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005
#define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE 1006
#define SQLITE_DBCONFIG_ENABLE_QPSG  1007
#define SQLITE_DBCONFIG_TRIGGER_EQP  1008
#define SQLITE_DBCONFIG_RESET_DATABASE 1009
#define SQLITE_DBCONFIG_DEFENSIVE  1010
#define SQLITE_DBCONFIG_WRITABLE_SCHEMA  1011
#define SQLITE_DBCONFIG_LEGACY_ALTER_TABLE 1012
#define SQLITE_DBCONFIG_DQS_DML  1013
#define SQLITE_DBCONFIG_DQS_DDL  1014
#define SQLITE_DBCONFIG_ENABLE_VIEW  1015
#define SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 1016
#define SQLITE_DBCONFIG_TRUSTED_SCHEMA 1017
#define SQLITE_DBCONFIG_MAX  1017
SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff); SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*); SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64); SQLITE_API int sqlite3_changes(sqlite3*); SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3*); SQLITE_API int sqlite3_total_changes(sqlite3*); SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3*); SQLITE_API void sqlite3_interrupt(sqlite3*); SQLITE_API int sqlite3_complete(const char *sql); SQLITE_API int sqlite3_complete16(const void *sql); SQLITE_API int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*); SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms); SQLITE_API int sqlite3_get_table(  sqlite3 *db,  const char *zSql,  char ***pazResult,  int *pnRow,  int *pnColumn,  char **pzErrmsg ); SQLITE_API void sqlite3_free_table(char **result); SQLITE_API char *sqlite3_mprintf(const char*,...); SQLITE_API char *sqlite3_vmprintf(const char*, va_list); SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...); SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list); SQLITE_API void *sqlite3_malloc(int); SQLITE_API void *sqlite3_malloc64(sqlite3_uint64); SQLITE_API void *sqlite3_realloc(void*, int); SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64); SQLITE_API void sqlite3_free(void*); SQLITE_API sqlite3_uint64 sqlite3_msize(void*); SQLITE_API sqlite3_int64 sqlite3_memory_used(void); SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag); SQLITE_API void sqlite3_randomness(int N, void *P); SQLITE_API int sqlite3_set_authorizer(  sqlite3*,  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),  void *pUserData );
#define SQLITE_DENY  1
#define SQLITE_IGNORE 2
#define SQLITE_CREATE_INDEX 1
#define SQLITE_CREATE_TABLE 2
#define SQLITE_CREATE_TEMP_INDEX  3
#define SQLITE_CREATE_TEMP_TABLE  4
#define SQLITE_CREATE_TEMP_TRIGGER  5
#define SQLITE_CREATE_TEMP_VIEW 6
#define SQLITE_CREATE_TRIGGER 7
#define SQLITE_CREATE_VIEW  8
#define SQLITE_DELETE 9
#define SQLITE_DROP_INDEX  10
#define SQLITE_DROP_TABLE  11
#define SQLITE_DROP_TEMP_INDEX 12
#define SQLITE_DROP_TEMP_TABLE 13
#define SQLITE_DROP_TEMP_TRIGGER 14
#define SQLITE_DROP_TEMP_VIEW  15
#define SQLITE_DROP_TRIGGER  16
#define SQLITE_DROP_VIEW 17
#define SQLITE_INSERT  18
#define SQLITE_PRAGMA  19
#define SQLITE_READ  20
#define SQLITE_SELECT  21
#define SQLITE_TRANSACTION 22
#define SQLITE_UPDATE  23
#define SQLITE_ATTACH  24
#define SQLITE_DETACH  25
#define SQLITE_ALTER_TABLE 26
#define SQLITE_REINDEX 27
#define SQLITE_ANALYZE 28
#define SQLITE_CREATE_VTABLE 29
#define SQLITE_DROP_VTABLE 30
#define SQLITE_FUNCTION  31
#define SQLITE_SAVEPOINT 32
#define SQLITE_COPY 0
#define SQLITE_RECURSIVE 33
SQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3*,   void(*xTrace)(void*,const char*), void*); SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*,   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
#define SQLITE_TRACE_STMT  0x01
#define SQLITE_TRACE_PROFILE 0x02
#define SQLITE_TRACE_ROW 0x04
#define SQLITE_TRACE_CLOSE 0x08
SQLITE_API int sqlite3_trace_v2(  sqlite3*,  unsigned uMask,  int(*xCallback)(unsigned,void*,void*,void*),  void *pCtx ); SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*); SQLITE_API int sqlite3_open(  const char *filename,  sqlite3 **ppDb ); SQLITE_API int sqlite3_open16(  const void *filename,  sqlite3 **ppDb ); SQLITE_API int sqlite3_open_v2(  const char *filename,  sqlite3 **ppDb,  int flags,  const char *zVfs ); SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam); SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault); SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64); SQLITE_API const char *sqlite3_uri_key(const char *zFilename, int N); SQLITE_API const char *sqlite3_filename_database(const char*); SQLITE_API const char *sqlite3_filename_journal(const char*); SQLITE_API const char *sqlite3_filename_wal(const char*); SQLITE_API sqlite3_file *sqlite3_database_file_object(const char*); SQLITE_API char *sqlite3_create_filename(  const char *zDatabase,  const char *zJournal,  const char *zWal,  int nParam,  const char **azParam ); SQLITE_API void sqlite3_free_filename(char*); SQLITE_API int sqlite3_errcode(sqlite3 *db); SQLITE_API int sqlite3_extended_errcode(sqlite3 *db); SQLITE_API const char *sqlite3_errmsg(sqlite3*); SQLITE_API const void *sqlite3_errmsg16(sqlite3*); SQLITE_API const char *sqlite3_errstr(int); typedef struct sqlite3_stmt sqlite3_stmt; SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
#define SQLITE_LIMIT_LENGTH 0
#define SQLITE_LIMIT_SQL_LENGTH 1
#define SQLITE_LIMIT_COLUMN 2
#define SQLITE_LIMIT_EXPR_DEPTH 3
#define SQLITE_LIMIT_COMPOUND_SELECT  4
#define SQLITE_LIMIT_VDBE_OP  5
#define SQLITE_LIMIT_FUNCTION_ARG 6
#define SQLITE_LIMIT_ATTACHED 7
#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH  8
#define SQLITE_LIMIT_VARIABLE_NUMBER  9
#define SQLITE_LIMIT_TRIGGER_DEPTH 10
#define SQLITE_LIMIT_WORKER_THREADS  11
#define SQLITE_PREPARE_PERSISTENT 0x01
#define SQLITE_PREPARE_NORMALIZE  0x02
#define SQLITE_PREPARE_NO_VTAB  0x04
SQLITE_API int sqlite3_prepare(  sqlite3 *db,  const char *zSql,  int nByte,  sqlite3_stmt **ppStmt,  const char **pzTail ); SQLITE_API int sqlite3_prepare_v2(  sqlite3 *db,  const char *zSql,  int nByte,  sqlite3_stmt **ppStmt,  const char **pzTail ); SQLITE_API int sqlite3_prepare_v3(  sqlite3 *db,  const char *zSql,  int nByte,  unsigned int prepFlags,  sqlite3_stmt **ppStmt,  const char **pzTail ); SQLITE_API int sqlite3_prepare16(  sqlite3 *db,  const void *zSql,  int nByte,  sqlite3_stmt **ppStmt,  const void **pzTail ); SQLITE_API int sqlite3_prepare16_v2(  sqlite3 *db,  const void *zSql,  int nByte,  sqlite3_stmt **ppStmt,  const void **pzTail ); SQLITE_API int sqlite3_prepare16_v3(  sqlite3 *db,  const void *zSql,  int nByte,  unsigned int prepFlags,  sqlite3_stmt **ppStmt,  const void **pzTail ); SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt); SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);
#ifdef SQLITE_ENABLE_NORMALIZE
SQLITE_API const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt);
#endif
SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt); SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt); SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*); typedef struct sqlite3_value sqlite3_value; typedef struct sqlite3_context sqlite3_context; SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*)); SQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,  void(*)(void*)); SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double); SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int); SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64); SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int); SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*)); SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*)); SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,   void(*)(void*), unsigned char encoding); SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*); SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*)); SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n); SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64); SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*); SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int); SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName); SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*); SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt); SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N); SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N); SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int); SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int); SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int); SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int); SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int); SQLITE_API int sqlite3_step(sqlite3_stmt*); SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
#define SQLITE_INTEGER 1
#define SQLITE_FLOAT 2
#define SQLITE_BLOB  4
#define SQLITE_NULL  5
#ifdef SQLITE_TEXT
# undef SQLITE_TEXT
#else
# define SQLITE_TEXT  3
#endif
#define SQLITE3_TEXT  3
SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol); SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol); SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol); SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol); SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol); SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol); SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt); SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt); SQLITE_API int sqlite3_create_function(  sqlite3 *db,  const char *zFunctionName,  int nArg,  int eTextRep,  void *pApp,  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*) ); SQLITE_API int sqlite3_create_function16(  sqlite3 *db,  const void *zFunctionName,  int nArg,  int eTextRep,  void *pApp,  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*) ); SQLITE_API int sqlite3_create_function_v2(  sqlite3 *db,  const char *zFunctionName,  int nArg,  int eTextRep,  void *pApp,  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*),  void(*xDestroy)(void*) ); SQLITE_API int sqlite3_create_window_function(  sqlite3 *db,  const char *zFunctionName,  int nArg,  int eTextRep,  void *pApp,  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*),  void (*xValue)(sqlite3_context*),  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),  void(*xDestroy)(void*) );
#define SQLITE_UTF8  1
#define SQLITE_UTF16LE 2
#define SQLITE_UTF16BE 3
#define SQLITE_UTF16 4
#define SQLITE_ANY 5
#define SQLITE_UTF16_ALIGNED 8
#define SQLITE_DETERMINISTIC 0x000000800
#define SQLITE_DIRECTONLY  0x000080000
#define SQLITE_SUBTYPE 0x000100000
#define SQLITE_INNOCUOUS 0x000200000
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*); SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*); SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*); SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void); SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void); SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),  void*,sqlite3_int64);
#endif
SQLITE_API const void *sqlite3_value_blob(sqlite3_value*); SQLITE_API double sqlite3_value_double(sqlite3_value*); SQLITE_API int sqlite3_value_int(sqlite3_value*); SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*); SQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*); SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*); SQLITE_API const void *sqlite3_value_text16(sqlite3_value*); SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*); SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*); SQLITE_API int sqlite3_value_bytes(sqlite3_value*); SQLITE_API int sqlite3_value_bytes16(sqlite3_value*); SQLITE_API int sqlite3_value_type(sqlite3_value*); SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*); SQLITE_API int sqlite3_value_nochange(sqlite3_value*); SQLITE_API int sqlite3_value_frombind(sqlite3_value*); SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*); SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*); SQLITE_API void sqlite3_value_free(sqlite3_value*); SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes); SQLITE_API void *sqlite3_user_data(sqlite3_context*); SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*); SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N); SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*)); typedef void (*sqlite3_destructor_type)(void*);
#define SQLITE_STATIC ((sqlite3_destructor_type)0)
#define SQLITE_TRANSIENT  ((sqlite3_destructor_type)-1)
SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*)); SQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,   sqlite3_uint64,void(*)(void*)); SQLITE_API void sqlite3_result_double(sqlite3_context*, double); SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int); SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int); SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*); SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*); SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int); SQLITE_API void sqlite3_result_int(sqlite3_context*, int); SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64); SQLITE_API void sqlite3_result_null(sqlite3_context*); SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*)); SQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,   void(*)(void*), unsigned char encoding); SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*)); SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*)); SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*)); SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*); SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*)); SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n); SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n); SQLITE_API void sqlite3_result_subtype(sqlite3_context*,unsigned int); SQLITE_API int sqlite3_create_collation(  sqlite3*,  const char *zName,  int eTextRep,  void *pArg,  int(*xCompare)(void*,int,const void*,int,const void*) ); SQLITE_API int sqlite3_create_collation_v2(  sqlite3*,  const char *zName,  int eTextRep,  void *pArg,  int(*xCompare)(void*,int,const void*,int,const void*),  void(*xDestroy)(void*) ); SQLITE_API int sqlite3_create_collation16(  sqlite3*,  const void *zName,  int eTextRep,  void *pArg,  int(*xCompare)(void*,int,const void*,int,const void*) ); SQLITE_API int sqlite3_collation_needed(  sqlite3*,  void*,  void(*)(void*,sqlite3*,int eTextRep,const char*) ); SQLITE_API int sqlite3_collation_needed16(  sqlite3*,  void*,  void(*)(void*,sqlite3*,int eTextRep,const void*) );
#ifdef SQLITE_ENABLE_CEROD
SQLITE_API void sqlite3_activate_cerod(  const char *zPassPhrase );
#endif
SQLITE_API int sqlite3_sleep(int); SQLITE_API char *sqlite3_temp_directory; SQLITE_API char *sqlite3_data_directory; SQLITE_API int sqlite3_win32_set_directory(  unsigned long type,  void *zValue ); SQLITE_API int sqlite3_win32_set_directory8(unsigned long type, const char *zValue); SQLITE_API int sqlite3_win32_set_directory16(unsigned long type, const void *zValue);
#define SQLITE_WIN32_DATA_DIRECTORY_TYPE 1
#define SQLITE_WIN32_TEMP_DIRECTORY_TYPE 2
SQLITE_API int sqlite3_get_autocommit(sqlite3*); SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*); SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName); SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName); SQLITE_API int sqlite3_txn_state(sqlite3*,const char *zSchema);
#define SQLITE_TXN_NONE 0
#define SQLITE_TXN_READ 1
#define SQLITE_TXN_WRITE 2
SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt); SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*); SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*); SQLITE_API int sqlite3_autovacuum_pages(  sqlite3 *db,  unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),  void*,  void(*)(void*) ); SQLITE_API void *sqlite3_update_hook(  sqlite3*,  void(*)(void *,int ,char const *,char const *,sqlite3_int64),  void* ); SQLITE_API int sqlite3_enable_shared_cache(int); SQLITE_API int sqlite3_release_memory(int); SQLITE_API int sqlite3_db_release_memory(sqlite3*); SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N); SQLITE_API sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 N); SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N); SQLITE_API int sqlite3_table_column_metadata(  sqlite3 *db,  const char *zDbName,  const char *zTableName,  const char *zColumnName,  char const **pzDataType,  char const **pzCollSeq,  int *pNotNull,  int *pPrimaryKey,  int *pAutoinc ); SQLITE_API int sqlite3_load_extension(  sqlite3 *db,  const char *zFile,  const char *zProc,  char **pzErrMsg ); SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff); SQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void)); SQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void)); SQLITE_API void sqlite3_reset_auto_extension(void); typedef struct sqlite3_vtab sqlite3_vtab; typedef struct sqlite3_index_info sqlite3_index_info; typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor; typedef struct sqlite3_module sqlite3_module; struct sqlite3_module {  int iVersion;  int (*xCreate)(sqlite3*, void *pAux,   int argc, const char *const*argv,   sqlite3_vtab **ppVTab, char**);  int (*xConnect)(sqlite3*, void *pAux,   int argc, const char *const*argv,   sqlite3_vtab **ppVTab, char**);  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);  int (*xDisconnect)(sqlite3_vtab *pVTab);  int (*xDestroy)(sqlite3_vtab *pVTab);  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);  int (*xClose)(sqlite3_vtab_cursor*);  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,  int argc, sqlite3_value **argv);  int (*xNext)(sqlite3_vtab_cursor*);  int (*xEof)(sqlite3_vtab_cursor*);  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);  int (*xBegin)(sqlite3_vtab *pVTab);  int (*xSync)(sqlite3_vtab *pVTab);  int (*xCommit)(sqlite3_vtab *pVTab);  int (*xRollback)(sqlite3_vtab *pVTab);  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,   void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),   void **ppArg);  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);  int (*xSavepoint)(sqlite3_vtab *pVTab, int);  int (*xRelease)(sqlite3_vtab *pVTab, int);  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);  int (*xShadowName)(const char*); }; struct sqlite3_index_info {  int nConstraint;  struct sqlite3_index_constraint {   int iColumn;   unsigned char op;   unsigned char usable;   int iTermOffset;  } *aConstraint;  int nOrderBy;  struct sqlite3_index_orderby {   int iColumn;   unsigned char desc;  } *aOrderBy;  struct sqlite3_index_constraint_usage {  int argvIndex;  unsigned char omit;  } *aConstraintUsage;  int idxNum;  char *idxStr;  int needToFreeIdxStr;  int orderByConsumed;  double estimatedCost;  sqlite3_int64 estimatedRows;  int idxFlags;  sqlite3_uint64 colUsed; };
#define SQLITE_INDEX_SCAN_UNIQUE 1
#define SQLITE_INDEX_CONSTRAINT_EQ  2
#define SQLITE_INDEX_CONSTRAINT_GT  4
#define SQLITE_INDEX_CONSTRAINT_LE  8
#define SQLITE_INDEX_CONSTRAINT_LT 16
#define SQLITE_INDEX_CONSTRAINT_GE 32
#define SQLITE_INDEX_CONSTRAINT_MATCH  64
#define SQLITE_INDEX_CONSTRAINT_LIKE 65
#define SQLITE_INDEX_CONSTRAINT_GLOB 66
#define SQLITE_INDEX_CONSTRAINT_REGEXP 67
#define SQLITE_INDEX_CONSTRAINT_NE 68
#define SQLITE_INDEX_CONSTRAINT_ISNOT  69
#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70
#define SQLITE_INDEX_CONSTRAINT_ISNULL 71
#define SQLITE_INDEX_CONSTRAINT_IS 72
#define SQLITE_INDEX_CONSTRAINT_FUNCTION 150
SQLITE_API int sqlite3_create_module(  sqlite3 *db,  const char *zName,  const sqlite3_module *p,  void *pClientData ); SQLITE_API int sqlite3_create_module_v2(  sqlite3 *db,  const char *zName,  const sqlite3_module *p,  void *pClientData,  void(*xDestroy)(void*) ); SQLITE_API int sqlite3_drop_modules(  sqlite3 *db,  const char **azKeep ); struct sqlite3_vtab {  const sqlite3_module *pModule;  int nRef;  char *zErrMsg; }; struct sqlite3_vtab_cursor {  sqlite3_vtab *pVtab; }; SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL); SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg); typedef struct sqlite3_blob sqlite3_blob; SQLITE_API int sqlite3_blob_open(  sqlite3*,  const char *zDb,  const char *zTable,  const char *zColumn,  sqlite3_int64 iRow,  int flags,  sqlite3_blob **ppBlob ); SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64); SQLITE_API int sqlite3_blob_close(sqlite3_blob *); SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *); SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset); SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset); SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName); SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt); SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*); SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int); SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*); SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*); SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*); SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*); typedef struct sqlite3_mutex_methods sqlite3_mutex_methods; struct sqlite3_mutex_methods {  int (*xMutexInit)(void);  int (*xMutexEnd)(void);  sqlite3_mutex *(*xMutexAlloc)(int);  void (*xMutexFree)(sqlite3_mutex *);  void (*xMutexEnter)(sqlite3_mutex *);  int (*xMutexTry)(sqlite3_mutex *);  void (*xMutexLeave)(sqlite3_mutex *);  int (*xMutexHeld)(sqlite3_mutex *);  int (*xMutexNotheld)(sqlite3_mutex *); };
#ifndef NDEBUG
SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*); SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
#endif
#define SQLITE_MUTEX_FAST  0
#define SQLITE_MUTEX_RECURSIVE 1
#define SQLITE_MUTEX_STATIC_MAIN 2
#define SQLITE_MUTEX_STATIC_MEM  3
#define SQLITE_MUTEX_STATIC_MEM2 4
#define SQLITE_MUTEX_STATIC_OPEN 4
#define SQLITE_MUTEX_STATIC_PRNG 5
#define SQLITE_MUTEX_STATIC_LRU  6
#define SQLITE_MUTEX_STATIC_LRU2 7
#define SQLITE_MUTEX_STATIC_PMEM 7
#define SQLITE_MUTEX_STATIC_APP1 8
#define SQLITE_MUTEX_STATIC_APP2 9
#define SQLITE_MUTEX_STATIC_APP3  10
#define SQLITE_MUTEX_STATIC_VFS1  11
#define SQLITE_MUTEX_STATIC_VFS2  12
#define SQLITE_MUTEX_STATIC_VFS3  13
#define SQLITE_MUTEX_STATIC_MASTER 2
SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*); SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*); SQLITE_API int sqlite3_test_control(int op, ...);
#define SQLITE_TESTCTRL_FIRST 5
#define SQLITE_TESTCTRL_PRNG_SAVE 5
#define SQLITE_TESTCTRL_PRNG_RESTORE  6
#define SQLITE_TESTCTRL_PRNG_RESET  7
#define SQLITE_TESTCTRL_BITVEC_TEST 8
#define SQLITE_TESTCTRL_FAULT_INSTALL 9
#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS  10
#define SQLITE_TESTCTRL_PENDING_BYTE 11
#define SQLITE_TESTCTRL_ASSERT 12
#define SQLITE_TESTCTRL_ALWAYS 13
#define SQLITE_TESTCTRL_RESERVE  14
#define SQLITE_TESTCTRL_OPTIMIZATIONS  15
#define SQLITE_TESTCTRL_ISKEYWORD  16
#define SQLITE_TESTCTRL_SCRATCHMALLOC  17
#define SQLITE_TESTCTRL_INTERNAL_FUNCTIONS 17
#define SQLITE_TESTCTRL_LOCALTIME_FAULT  18
#define SQLITE_TESTCTRL_EXPLAIN_STMT 19
#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD 19
#define SQLITE_TESTCTRL_NEVER_CORRUPT  20
#define SQLITE_TESTCTRL_VDBE_COVERAGE  21
#define SQLITE_TESTCTRL_BYTEORDER  22
#define SQLITE_TESTCTRL_ISINIT 23
#define SQLITE_TESTCTRL_SORTER_MMAP  24
#define SQLITE_TESTCTRL_IMPOSTER 25
#define SQLITE_TESTCTRL_PARSER_COVERAGE  26
#define SQLITE_TESTCTRL_RESULT_INTREAL 27
#define SQLITE_TESTCTRL_PRNG_SEED  28
#define SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS  29
#define SQLITE_TESTCTRL_SEEK_COUNT 30
#define SQLITE_TESTCTRL_TRACEFLAGS 31
#define SQLITE_TESTCTRL_TUNE 32
#define SQLITE_TESTCTRL_LAST 32
SQLITE_API int sqlite3_keyword_count(void); SQLITE_API int sqlite3_keyword_name(int,const char**,int*); SQLITE_API int sqlite3_keyword_check(const char*,int); typedef struct sqlite3_str sqlite3_str; SQLITE_API sqlite3_str *sqlite3_str_new(sqlite3*); SQLITE_API char *sqlite3_str_finish(sqlite3_str*); SQLITE_API void sqlite3_str_appendf(sqlite3_str*, const char *zFormat, ...); SQLITE_API void sqlite3_str_vappendf(sqlite3_str*, const char *zFormat, va_list); SQLITE_API void sqlite3_str_append(sqlite3_str*, const char *zIn, int N); SQLITE_API void sqlite3_str_appendall(sqlite3_str*, const char *zIn); SQLITE_API void sqlite3_str_appendchar(sqlite3_str*, int N, char C); SQLITE_API void sqlite3_str_reset(sqlite3_str*); SQLITE_API int sqlite3_str_errcode(sqlite3_str*); SQLITE_API int sqlite3_str_length(sqlite3_str*); SQLITE_API char *sqlite3_str_value(sqlite3_str*); SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag); SQLITE_API int sqlite3_status64(  int op,  sqlite3_int64 *pCurrent,  sqlite3_int64 *pHighwater,  int resetFlag );
#define SQLITE_STATUS_MEMORY_USED 0
#define SQLITE_STATUS_PAGECACHE_USED  1
#define SQLITE_STATUS_PAGECACHE_OVERFLOW  2
#define SQLITE_STATUS_SCRATCH_USED  3
#define SQLITE_STATUS_SCRATCH_OVERFLOW  4
#define SQLITE_STATUS_MALLOC_SIZE 5
#define SQLITE_STATUS_PARSER_STACK  6
#define SQLITE_STATUS_PAGECACHE_SIZE  7
#define SQLITE_STATUS_SCRATCH_SIZE  8
#define SQLITE_STATUS_MALLOC_COUNT  9
SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
#define SQLITE_DBSTATUS_LOOKASIDE_USED  0
#define SQLITE_DBSTATUS_CACHE_USED  1
#define SQLITE_DBSTATUS_SCHEMA_USED 2
#define SQLITE_DBSTATUS_STMT_USED 3
#define SQLITE_DBSTATUS_LOOKASIDE_HIT 4
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE 5
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL 6
#define SQLITE_DBSTATUS_CACHE_HIT 7
#define SQLITE_DBSTATUS_CACHE_MISS  8
#define SQLITE_DBSTATUS_CACHE_WRITE 9
#define SQLITE_DBSTATUS_DEFERRED_FKS 10
#define SQLITE_DBSTATUS_CACHE_USED_SHARED  11
#define SQLITE_DBSTATUS_CACHE_SPILL  12
#define SQLITE_DBSTATUS_MAX  12
SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
#define SQLITE_STMTSTATUS_FULLSCAN_STEP  1
#define SQLITE_STMTSTATUS_SORT 2
#define SQLITE_STMTSTATUS_AUTOINDEX  3
#define SQLITE_STMTSTATUS_VM_STEP  4
#define SQLITE_STMTSTATUS_REPREPARE  5
#define SQLITE_STMTSTATUS_RUN  6
#define SQLITE_STMTSTATUS_MEMUSED  99
typedef struct sqlite3_pcache sqlite3_pcache; typedef struct sqlite3_pcache_page sqlite3_pcache_page; struct sqlite3_pcache_page {  void *pBuf;  void *pExtra; }; typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2; struct sqlite3_pcache_methods2 {  int iVersion;  void *pArg;  int (*xInit)(void*);  void (*xShutdown)(void*);  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);  void (*xCachesize)(sqlite3_pcache*, int nCachesize);  int (*xPagecount)(sqlite3_pcache*);  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,  unsigned oldKey, unsigned newKey);  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);  void (*xDestroy)(sqlite3_pcache*);  void (*xShrink)(sqlite3_pcache*); }; typedef struct sqlite3_pcache_methods sqlite3_pcache_methods; struct sqlite3_pcache_methods {  void *pArg;  int (*xInit)(void*);  void (*xShutdown)(void*);  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);  void (*xCachesize)(sqlite3_pcache*, int nCachesize);  int (*xPagecount)(sqlite3_pcache*);  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);  void (*xUnpin)(sqlite3_pcache*, void*, int discard);  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);  void (*xDestroy)(sqlite3_pcache*); }; typedef struct sqlite3_backup sqlite3_backup; SQLITE_API sqlite3_backup *sqlite3_backup_init(  sqlite3 *pDest,  const char *zDestName,  sqlite3 *pSource,  const char *zSourceName ); SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage); SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p); SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p); SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p); SQLITE_API int sqlite3_unlock_notify(  sqlite3 *pBlocked,  void (*xNotify)(void **apArg, int nArg),  void *pNotifyArg ); SQLITE_API int sqlite3_stricmp(const char *, const char *); SQLITE_API int sqlite3_strnicmp(const char *, const char *, int); SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr); SQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc); SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...); SQLITE_API void *sqlite3_wal_hook(  sqlite3*,  int(*)(void *,sqlite3*,const char*,int),  void* ); SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N); SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb); SQLITE_API int sqlite3_wal_checkpoint_v2(  sqlite3 *db,  const char *zDb,  int eMode,  int *pnLog,  int *pnCkpt );
#define SQLITE_CHECKPOINT_PASSIVE 0
#define SQLITE_CHECKPOINT_FULL  1
#define SQLITE_CHECKPOINT_RESTART 2
#define SQLITE_CHECKPOINT_TRUNCATE 3
SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);
#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1
#define SQLITE_VTAB_INNOCUOUS 2
#define SQLITE_VTAB_DIRECTONLY  3
SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *); SQLITE_API int sqlite3_vtab_nochange(sqlite3_context*); SQLITE_API SQLITE_EXPERIMENTAL const char *sqlite3_vtab_collation(sqlite3_index_info*,int);
#define SQLITE_ROLLBACK 1
#define SQLITE_FAIL  3
#define SQLITE_REPLACE 5
#define SQLITE_SCANSTAT_NLOOP 0
#define SQLITE_SCANSTAT_NVISIT  1
#define SQLITE_SCANSTAT_EST 2
#define SQLITE_SCANSTAT_NAME  3
#define SQLITE_SCANSTAT_EXPLAIN 4
#define SQLITE_SCANSTAT_SELECTID 5
SQLITE_API int sqlite3_stmt_scanstatus(  sqlite3_stmt *pStmt,  int idx,  int iScanStatusOp,  void *pOut ); SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*); SQLITE_API int sqlite3_db_cacheflush(sqlite3*);
#if defined(SQLITE_ENABLE_PREUPDATE_HOOK)
SQLITE_API void *sqlite3_preupdate_hook(  sqlite3 *db,  void(*xPreUpdate)(  void *pCtx,  sqlite3 *db,  int op,  char const *zDb,  char const *zName,  sqlite3_int64 iKey1,  sqlite3_int64 iKey2  ),  void* ); SQLITE_API int sqlite3_preupdate_old(sqlite3 *, int, sqlite3_value **); SQLITE_API int sqlite3_preupdate_count(sqlite3 *); SQLITE_API int sqlite3_preupdate_depth(sqlite3 *); SQLITE_API int sqlite3_preupdate_new(sqlite3 *, int, sqlite3_value **); SQLITE_API int sqlite3_preupdate_blobwrite(sqlite3 *);
#endif
SQLITE_API int sqlite3_system_errno(sqlite3*); typedef struct sqlite3_snapshot {  unsigned char hidden[48]; } sqlite3_snapshot; SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_get(  sqlite3 *db,  const char *zSchema,  sqlite3_snapshot **ppSnapshot ); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_open(  sqlite3 *db,  const char *zSchema,  sqlite3_snapshot *pSnapshot ); SQLITE_API SQLITE_EXPERIMENTAL void sqlite3_snapshot_free(sqlite3_snapshot*); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_cmp(  sqlite3_snapshot *p1,  sqlite3_snapshot *p2 ); SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb); SQLITE_API unsigned char *sqlite3_serialize(  sqlite3 *db,  const char *zSchema,  sqlite3_int64 *piSize,  unsigned int mFlags );
#define SQLITE_SERIALIZE_NOCOPY 0x001
SQLITE_API int sqlite3_deserialize(  sqlite3 *db,  const char *zSchema,  unsigned char *pData,  sqlite3_int64 szDb,  sqlite3_int64 szBuf,  unsigned mFlags );
#define SQLITE_DESERIALIZE_FREEONCLOSE 1
#define SQLITE_DESERIALIZE_RESIZEABLE 2
#define SQLITE_DESERIALIZE_READONLY 4
#ifdef SQLITE_OMIT_FLOATING_POINT
# undef double
#endif
#if 0
}
#endif
#endif
#ifndef _SQLITE3RTREE_H_
#define _SQLITE3RTREE_H_
#if 0
extern "C" {
#endif
typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry; typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;
#ifdef SQLITE_RTREE_INT_ONLY
 typedef sqlite3_int64 sqlite3_rtree_dbl;
#else
 typedef double sqlite3_rtree_dbl;
#endif
SQLITE_API int sqlite3_rtree_geometry_callback(  sqlite3 *db,  const char *zGeom,  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),  void *pContext ); struct sqlite3_rtree_geometry {  void *pContext;  int nParam;  sqlite3_rtree_dbl *aParam;  void *pUser;  void (*xDelUser)(void *); }; SQLITE_API int sqlite3_rtree_query_callback(  sqlite3 *db,  const char *zQueryFunc,  int (*xQueryFunc)(sqlite3_rtree_query_info*),  void *pContext,  void (*xDestructor)(void*) ); struct sqlite3_rtree_query_info {  void *pContext;  int nParam;  sqlite3_rtree_dbl *aParam;  void *pUser;  void (*xDelUser)(void*);  sqlite3_rtree_dbl *aCoord;  unsigned int *anQueue;  int nCoord;  int iLevel;  int mxLevel;  sqlite3_int64 iRowid;  sqlite3_rtree_dbl rParentScore;  int eParentWithin;  int eWithin;  sqlite3_rtree_dbl rScore;  sqlite3_value **apSqlParam; };
#define NOT_WITHIN  0
#define PARTLY_WITHIN 1
#define FULLY_WITHIN  2
#if 0
}
#endif
#endif
#if !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION)
#define __SQLITESESSION_H_ 1
#if 0
extern "C" {
#endif
typedef struct sqlite3_session sqlite3_session; typedef struct sqlite3_changeset_iter sqlite3_changeset_iter; SQLITE_API int sqlite3session_create(  sqlite3 *db,  const char *zDb,  sqlite3_session **ppSession ); SQLITE_API void sqlite3session_delete(sqlite3_session *pSession); SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);
#define SQLITE_SESSION_OBJCONFIG_SIZE 1
SQLITE_API int sqlite3session_enable(sqlite3_session *pSession, int bEnable); SQLITE_API int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect); SQLITE_API int sqlite3session_attach(  sqlite3_session *pSession,  const char *zTab ); SQLITE_API void sqlite3session_table_filter(  sqlite3_session *pSession,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  void *pCtx ); SQLITE_API int sqlite3session_changeset(  sqlite3_session *pSession,  int *pnChangeset,  void **ppChangeset ); SQLITE_API sqlite3_int64 sqlite3session_changeset_size(sqlite3_session *pSession); SQLITE_API int sqlite3session_diff(  sqlite3_session *pSession,  const char *zFromDb,  const char *zTbl,  char **pzErrMsg ); SQLITE_API int sqlite3session_patchset(  sqlite3_session *pSession,  int *pnPatchset,  void **ppPatchset ); SQLITE_API int sqlite3session_isempty(sqlite3_session *pSession); SQLITE_API sqlite3_int64 sqlite3session_memory_used(sqlite3_session *pSession); SQLITE_API int sqlite3changeset_start(  sqlite3_changeset_iter **pp,  int nChangeset,  void *pChangeset ); SQLITE_API int sqlite3changeset_start_v2(  sqlite3_changeset_iter **pp,  int nChangeset,  void *pChangeset,  int flags );
#define SQLITE_CHANGESETSTART_INVERT 0x0002
SQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *pIter); SQLITE_API int sqlite3changeset_op(  sqlite3_changeset_iter *pIter,  const char **pzTab,  int *pnCol,  int *pOp,  int *pbIndirect ); SQLITE_API int sqlite3changeset_pk(  sqlite3_changeset_iter *pIter,  unsigned char **pabPK,  int *pnCol ); SQLITE_API int sqlite3changeset_old(  sqlite3_changeset_iter *pIter,  int iVal,  sqlite3_value **ppValue ); SQLITE_API int sqlite3changeset_new(  sqlite3_changeset_iter *pIter,  int iVal,  sqlite3_value **ppValue ); SQLITE_API int sqlite3changeset_conflict(  sqlite3_changeset_iter *pIter,  int iVal,  sqlite3_value **ppValue ); SQLITE_API int sqlite3changeset_fk_conflicts(  sqlite3_changeset_iter *pIter,  int *pnOut ); SQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter); SQLITE_API int sqlite3changeset_invert(  int nIn, const void *pIn,  int *pnOut, void **ppOut ); SQLITE_API int sqlite3changeset_concat(  int nA,  void *pA,  int nB,  void *pB,  int *pnOut,  void **ppOut ); typedef struct sqlite3_changegroup sqlite3_changegroup; SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp); SQLITE_API int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData); SQLITE_API int sqlite3changegroup_output(  sqlite3_changegroup*,  int *pnData,  void **ppData ); SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*); SQLITE_API int sqlite3changeset_apply(  sqlite3 *db,  int nChangeset,  void *pChangeset,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx ); SQLITE_API int sqlite3changeset_apply_v2(  sqlite3 *db,  int nChangeset,  void *pChangeset,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx,  void **ppRebase, int *pnRebase,  int flags );
#define SQLITE_CHANGESETAPPLY_NOSAVEPOINT  0x0001
#define SQLITE_CHANGESETAPPLY_INVERT 0x0002
#define SQLITE_CHANGESET_DATA 1
#define SQLITE_CHANGESET_NOTFOUND 2
#define SQLITE_CHANGESET_CONFLICT 3
#define SQLITE_CHANGESET_CONSTRAINT 4
#define SQLITE_CHANGESET_FOREIGN_KEY 5
#define SQLITE_CHANGESET_OMIT  0
#define SQLITE_CHANGESET_REPLACE 1
#define SQLITE_CHANGESET_ABORT 2
typedef struct sqlite3_rebaser sqlite3_rebaser; SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew); SQLITE_API int sqlite3rebaser_configure(  sqlite3_rebaser*,  int nRebase, const void *pRebase ); SQLITE_API int sqlite3rebaser_rebase(  sqlite3_rebaser*,  int nIn, const void *pIn,  int *pnOut, void **ppOut ); SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p); SQLITE_API int sqlite3changeset_apply_strm(  sqlite3 *db,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx ); SQLITE_API int sqlite3changeset_apply_v2_strm(  sqlite3 *db,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx,  void **ppRebase, int *pnRebase,  int flags ); SQLITE_API int sqlite3changeset_concat_strm(  int (*xInputA)(void *pIn, void *pData, int *pnData),  void *pInA,  int (*xInputB)(void *pIn, void *pData, int *pnData),  void *pInB,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ); SQLITE_API int sqlite3changeset_invert_strm(  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ); SQLITE_API int sqlite3changeset_start_strm(  sqlite3_changeset_iter **pp,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn ); SQLITE_API int sqlite3changeset_start_v2_strm(  sqlite3_changeset_iter **pp,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int flags ); SQLITE_API int sqlite3session_changeset_strm(  sqlite3_session *pSession,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ); SQLITE_API int sqlite3session_patchset_strm(  sqlite3_session *pSession,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ); SQLITE_API int sqlite3changegroup_add_strm(sqlite3_changegroup*,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn ); SQLITE_API int sqlite3changegroup_output_strm(sqlite3_changegroup*,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ); SQLITE_API int sqlite3rebaser_rebase_strm(  sqlite3_rebaser *pRebaser,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ); SQLITE_API int sqlite3session_config(int op, void *pArg);
#define SQLITE_SESSION_CONFIG_STRMSIZE 1
#if 0
}
#endif
#endif
#ifndef _FTS5_H
#define _FTS5_H
#if 0
extern "C" {
#endif
typedef struct Fts5ExtensionApi Fts5ExtensionApi; typedef struct Fts5Context Fts5Context; typedef struct Fts5PhraseIter Fts5PhraseIter; typedef void (*fts5_extension_function)(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ); struct Fts5PhraseIter {  const unsigned char *a;  const unsigned char *b; }; struct Fts5ExtensionApi {  int iVersion;  void *(*xUserData)(Fts5Context*);  int (*xColumnCount)(Fts5Context*);  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);  int (*xTokenize)(Fts5Context*,  const char *pText, int nText,  void *pCtx,  int (*xToken)(void*, int, const char*, int, int, int)  );  int (*xPhraseCount)(Fts5Context*);  int (*xPhraseSize)(Fts5Context*, int iPhrase);  int (*xInstCount)(Fts5Context*, int *pnInst);  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);  sqlite3_int64 (*xRowid)(Fts5Context*);  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,  int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)  );  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));  void *(*xGetAuxdata)(Fts5Context*, int bClear);  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol); }; typedef struct Fts5Tokenizer Fts5Tokenizer; typedef struct fts5_tokenizer fts5_tokenizer; struct fts5_tokenizer {  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);  void (*xDelete)(Fts5Tokenizer*);  int (*xTokenize)(Fts5Tokenizer*,  void *pCtx,  int flags,  const char *pText, int nText,  int (*xToken)(  void *pCtx,  int tflags,  const char *pToken,  int nToken,  int iStart,  int iEnd  )  ); };
#define FTS5_TOKENIZE_QUERY  0x0001
#define FTS5_TOKENIZE_PREFIX 0x0002
#define FTS5_TOKENIZE_DOCUMENT 0x0004
#define FTS5_TOKENIZE_AUX  0x0008
#define FTS5_TOKEN_COLOCATED 0x0001
typedef struct fts5_api fts5_api; struct fts5_api {  int iVersion;  int (*xCreateTokenizer)(  fts5_api *pApi,  const char *zName,  void *pContext,  fts5_tokenizer *pTokenizer,  void (*xDestroy)(void*)  );  int (*xFindTokenizer)(  fts5_api *pApi,  const char *zName,  void **ppContext,  fts5_tokenizer *pTokenizer  );  int (*xCreateFunction)(  fts5_api *pApi,  const char *zName,  void *pContext,  fts5_extension_function xFunction,  void (*xDestroy)(void*)  ); };
#if 0
}
#endif
#endif
#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)
#include "config.h"
#define SQLITECONFIG_H 1
#endif
#ifndef SQLITE_MAX_LENGTH
# define SQLITE_MAX_LENGTH 1000000000
#endif
#ifndef SQLITE_MAX_COLUMN
# define SQLITE_MAX_COLUMN 2000
#endif
#ifndef SQLITE_MAX_SQL_LENGTH
# define SQLITE_MAX_SQL_LENGTH 1000000000
#endif
#ifndef SQLITE_MAX_EXPR_DEPTH
# define SQLITE_MAX_EXPR_DEPTH 1000
#endif
#ifndef SQLITE_MAX_COMPOUND_SELECT
# define SQLITE_MAX_COMPOUND_SELECT 500
#endif
#ifndef SQLITE_MAX_VDBE_OP
# define SQLITE_MAX_VDBE_OP 250000000
#endif
#ifndef SQLITE_MAX_FUNCTION_ARG
# define SQLITE_MAX_FUNCTION_ARG 127
#endif
#ifndef SQLITE_DEFAULT_CACHE_SIZE
# define SQLITE_DEFAULT_CACHE_SIZE -2000
#endif
#ifndef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT
# define SQLITE_DEFAULT_WAL_AUTOCHECKPOINT 1000
#endif
#ifndef SQLITE_MAX_ATTACHED
# define SQLITE_MAX_ATTACHED 10
#endif
#ifndef SQLITE_MAX_VARIABLE_NUMBER
# define SQLITE_MAX_VARIABLE_NUMBER 32766
#endif
#ifdef SQLITE_MAX_PAGE_SIZE
# undef SQLITE_MAX_PAGE_SIZE
#endif
#define SQLITE_MAX_PAGE_SIZE 65536
#ifndef SQLITE_DEFAULT_PAGE_SIZE
# define SQLITE_DEFAULT_PAGE_SIZE 4096
#endif
#if SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE
# undef SQLITE_DEFAULT_PAGE_SIZE
# define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE
#endif
#ifndef SQLITE_MAX_DEFAULT_PAGE_SIZE
# define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192
#endif
#if SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE
# undef SQLITE_MAX_DEFAULT_PAGE_SIZE
# define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE
#endif
#ifndef SQLITE_MAX_PAGE_COUNT
# define SQLITE_MAX_PAGE_COUNT 1073741823
#endif
#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH
# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000
#endif
#ifndef SQLITE_MAX_TRIGGER_DEPTH
# define SQLITE_MAX_TRIGGER_DEPTH 1000
#endif
#if defined(__BORLANDC__)
#pragma warn -rch
#pragma warn -ccc
#pragma warn -aus
#pragma warn -csu
#pragma warn -spa
#endif
#ifndef __has_extension
# define __has_extension(x) 0
#endif
#if GCC_VERSION>=4007000 || __has_extension(c_atomic)
# define SQLITE_ATOMIC_INTRINSICS 1
# define AtomicLoad(PTR)  __atomic_load_n((PTR),__ATOMIC_RELAXED)
# define AtomicStore(PTR,VAL) __atomic_store_n((PTR),(VAL),__ATOMIC_RELAXED)
#else
# define SQLITE_ATOMIC_INTRINSICS 0
# define AtomicLoad(PTR)  (*(PTR))
# define AtomicStore(PTR,VAL) (*(PTR) = (VAL))
#endif
#ifdef HAVE_STDINT_H
#include <stdint.h>
#endif
#ifdef HAVE_INTTYPES_H
#include <inttypes.h>
#endif
#if defined(HAVE_STDINT_H)
# define SQLITE_INT_TO_PTR(X) ((void*)(intptr_t)(X))
# define SQLITE_PTR_TO_INT(X) ((int)(intptr_t)(X))
#elif defined(__PTRDIFF_TYPE__)
# define SQLITE_INT_TO_PTR(X) ((void*)(__PTRDIFF_TYPE__)(X))
# define SQLITE_PTR_TO_INT(X) ((int)(__PTRDIFF_TYPE__)(X))
#elif !defined(__GNUC__)
# define SQLITE_INT_TO_PTR(X) ((void*)&((char*)0)[X])
# define SQLITE_PTR_TO_INT(X) ((int)(((char*)X)-(char*)0))
#else
# define SQLITE_INT_TO_PTR(X) ((void*)(X))
# define SQLITE_PTR_TO_INT(X) ((int)(X))
#endif
#if defined(__GNUC__)
# define SQLITE_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER) && _MSC_VER>=1310
# define SQLITE_NOINLINE __declspec(noinline)
#else
# define SQLITE_NOINLINE
#endif
#if !defined(SQLITE_DISABLE_INTRINSIC)
# if defined(_MSC_VER) && _MSC_VER>=1400
# if !defined(_WIN32_WCE)
# include <intrin.h>
# pragma intrinsic(_byteswap_ushort)
# pragma intrinsic(_byteswap_ulong)
# pragma intrinsic(_byteswap_uint64)
# pragma intrinsic(_ReadWriteBarrier)
# else
# include <cmnintrin.h>
# endif
# endif
#endif
#if !defined(SQLITE_THREADSAFE)
# if defined(THREADSAFE)
#  define SQLITE_THREADSAFE THREADSAFE
# else
#  define SQLITE_THREADSAFE 1
# endif
#endif
#ifndef SQLITE_POWERSAFE_OVERWRITE
# define SQLITE_POWERSAFE_OVERWRITE 1
#endif
#if !defined(SQLITE_DEFAULT_MEMSTATUS)
# define SQLITE_DEFAULT_MEMSTATUS 1
#endif
#if defined(SQLITE_SYSTEM_MALLOC)  + defined(SQLITE_WIN32_MALLOC)  + defined(SQLITE_ZERO_MALLOC)  + defined(SQLITE_MEMDEBUG)>1

# error "Two or more of the following compile-time configuration options are defined but at most one is allowed: SQLITE_SYSTEM_MALLOC, SQLITE_WIN32_MALLOC, SQLITE_MEMDEBUG, SQLITE_ZERO_MALLOC"

#endif
#if defined(SQLITE_SYSTEM_MALLOC)  + defined(SQLITE_WIN32_MALLOC)  + defined(SQLITE_ZERO_MALLOC)  + defined(SQLITE_MEMDEBUG)==0

# define SQLITE_SYSTEM_MALLOC 1
#endif
#if !defined(SQLITE_MALLOC_SOFT_LIMIT)
# define SQLITE_MALLOC_SOFT_LIMIT 1024
#endif
#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__)
# define _XOPEN_SOURCE 600
#endif
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
# define NDEBUG 1
#endif
#if defined(NDEBUG) && defined(SQLITE_DEBUG)
# undef NDEBUG
#endif
#if !defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) && defined(SQLITE_DEBUG)
# define SQLITE_ENABLE_EXPLAIN_COMMENTS 1
#endif
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)
# ifndef SQLITE_AMALGAMATION
 extern unsigned int sqlite3CoverageCounter;
# endif
# define testcase(X) if( X ){ sqlite3CoverageCounter += (unsigned)__LINE__; }
#else
# define testcase(X)
#endif
#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)
# define TESTONLY(X) X
#else
# define TESTONLY(X)
#endif
#ifndef NDEBUG
# define VVA_ONLY(X) X
#else
# define VVA_ONLY(X)
#endif
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1
#endif
#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)
# define ALWAYS(X) (1)
# define NEVER(X)  (0)
#elif !defined(NDEBUG)
# define ALWAYS(X) ((X)?1:(assert(0),0))
# define NEVER(X)  ((X)?(assert(0),1):0)
#else
# define ALWAYS(X) (X)
# define NEVER(X)  (X)
#endif
#if defined(SQLITE_MUTATION_TEST)
# define OK_IF_ALWAYS_TRUE(X) (1)
# define OK_IF_ALWAYS_FALSE(X) (0)
#else
# define OK_IF_ALWAYS_TRUE(X) (X)
# define OK_IF_ALWAYS_FALSE(X) (X)
#endif
#if defined(SQLITE_TEST_REALLOC_STRESS)
# define ONLY_IF_REALLOC_STRESS(X) (X)
#elif !defined(NDEBUG)
# define ONLY_IF_REALLOC_STRESS(X) ((X)?(assert(0),1):0)
#else
# define ONLY_IF_REALLOC_STRESS(X) (0)
#endif
#if defined(SQLITE_FORCE_OS_TRACE) || defined(SQLITE_TEST) ||  (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)

 extern int sqlite3OSTrace;
# define OSTRACE(X) if( sqlite3OSTrace ) sqlite3DebugPrintf X
# define SQLITE_HAVE_OS_TRACE
#else
# define OSTRACE(X)
# undef SQLITE_HAVE_OS_TRACE
#endif
#if defined(SQLITE_HAVE_OS_TRACE) || defined(SQLITE_TEST) ||  (defined(SQLITE_DEBUG) && SQLITE_OS_WIN)

# define SQLITE_NEED_ERR_NAME
#else
# undef SQLITE_NEED_ERR_NAME
#endif
#ifdef SQLITE_OMIT_EXPLAIN
# undef SQLITE_ENABLE_EXPLAIN_COMMENTS
#endif
#if defined(SQLITE_OMIT_VIRTUALTABLE) && !defined(SQLITE_OMIT_ALTERTABLE)
# define SQLITE_OMIT_ALTERTABLE
#endif
#define IS_BIG_INT(X) (((X)&~(i64)0xffffffff)!=0)
#define likely(X) (X)
#define unlikely(X) (X)
#ifndef SQLITE_HASH_H
#define SQLITE_HASH_H
typedef struct Hash Hash; typedef struct HashElem HashElem; struct Hash {  unsigned int htsize;  unsigned int count;  HashElem *first;  struct _ht {  unsigned int count;  HashElem *chain;  } *ht; }; struct HashElem {  HashElem *next, *prev;  void *data;  const char *pKey; }; SQLITE_PRIVATE void sqlite3HashInit(Hash*); SQLITE_PRIVATE void *sqlite3HashInsert(Hash*, const char *pKey, void *pData); SQLITE_PRIVATE void *sqlite3HashFind(const Hash*, const char *pKey); SQLITE_PRIVATE void sqlite3HashClear(Hash*);
#define sqliteHashFirst(H) ((H)->first)
#define sqliteHashNext(E)  ((E)->next)
#define sqliteHashData(E)  ((E)->data)
#define sqliteHashCount(H) ((H)->count)
#endif
#define TK_SEMI  1
#define TK_EXPLAIN 2
#define TK_QUERY 3
#define TK_PLAN  4
#define TK_BEGIN 5
#define TK_TRANSACTION 6
#define TK_DEFERRED  7
#define TK_IMMEDIATE 8
#define TK_EXCLUSIVE 9
#define TK_COMMIT 10
#define TK_END  11
#define TK_ROLLBACK 12
#define TK_SAVEPOINT  13
#define TK_RELEASE  14
#define TK_TO 15
#define TK_TABLE  16
#define TK_CREATE 17
#define TK_IF 18
#define TK_NOT  19
#define TK_EXISTS 20
#define TK_TEMP 21
#define TK_LP 22
#define TK_RP 23
#define TK_AS 24
#define TK_COMMA  25
#define TK_WITHOUT  26
#define TK_ABORT  27
#define TK_ACTION 28
#define TK_AFTER  29
#define TK_ANALYZE  30
#define TK_ASC  31
#define TK_ATTACH 32
#define TK_BEFORE 33
#define TK_BY 34
#define TK_CASCADE  35
#define TK_CAST 36
#define TK_CONFLICT 37
#define TK_DATABASE 38
#define TK_DESC 39
#define TK_DETACH 40
#define TK_EACH 41
#define TK_FAIL 42
#define TK_OR 43
#define TK_AND  44
#define TK_IS 45
#define TK_MATCH  46
#define TK_LIKE_KW  47
#define TK_BETWEEN  48
#define TK_IN 49
#define TK_ISNULL 50
#define TK_NOTNULL  51
#define TK_NE 52
#define TK_EQ 53
#define TK_GT 54
#define TK_LE 55
#define TK_LT 56
#define TK_GE 57
#define TK_ESCAPE 58
#define TK_ID 59
#define TK_COLUMNKW 60
#define TK_DO 61
#define TK_FOR  62
#define TK_IGNORE 63
#define TK_INITIALLY  64
#define TK_INSTEAD  65
#define TK_NO 66
#define TK_KEY  67
#define TK_OF 68
#define TK_OFFSET 69
#define TK_PRAGMA 70
#define TK_RAISE  71
#define TK_RECURSIVE  72
#define TK_REPLACE  73
#define TK_RESTRICT 74
#define TK_ROW  75
#define TK_ROWS 76
#define TK_TRIGGER  77
#define TK_VACUUM 78
#define TK_VIEW 79
#define TK_VIRTUAL  80
#define TK_WITH 81
#define TK_NULLS  82
#define TK_FIRST  83
#define TK_LAST 84
#define TK_CURRENT  85
#define TK_FOLLOWING  86
#define TK_PARTITION  87
#define TK_PRECEDING  88
#define TK_RANGE  89
#define TK_UNBOUNDED  90
#define TK_EXCLUDE  91
#define TK_GROUPS 92
#define TK_OTHERS 93
#define TK_TIES 94
#define TK_GENERATED  95
#define TK_ALWAYS 96
#define TK_MATERIALIZED 97
#define TK_REINDEX  98
#define TK_RENAME 99
#define TK_CTIME_KW  100
#define TK_ANY 101
#define TK_BITAND  102
#define TK_BITOR 103
#define TK_LSHIFT  104
#define TK_RSHIFT  105
#define TK_PLUS  106
#define TK_MINUS 107
#define TK_STAR  108
#define TK_SLASH 109
#define TK_REM 110
#define TK_CONCAT  111
#define TK_COLLATE 112
#define TK_BITNOT  113
#define TK_ON  114
#define TK_INDEXED 115
#define TK_STRING  116
#define TK_JOIN_KW 117
#define TK_CONSTRAINT  118
#define TK_DEFAULT 119
#define TK_NULL  120
#define TK_PRIMARY 121
#define TK_UNIQUE  122
#define TK_CHECK 123
#define TK_REFERENCES  124
#define TK_AUTOINCR  125
#define TK_INSERT  126
#define TK_DELETE  127
#define TK_UPDATE  128
#define TK_SET 129
#define TK_DEFERRABLE  130
#define TK_FOREIGN 131
#define TK_DROP  132
#define TK_UNION 133
#define TK_ALL 134
#define TK_EXCEPT  135
#define TK_INTERSECT 136
#define TK_SELECT  137
#define TK_VALUES  138
#define TK_DISTINCT  139
#define TK_DOT 140
#define TK_FROM  141
#define TK_JOIN  142
#define TK_USING 143
#define TK_ORDER 144
#define TK_GROUP 145
#define TK_HAVING  146
#define TK_LIMIT 147
#define TK_WHERE 148
#define TK_RETURNING 149
#define TK_INTO  150
#define TK_NOTHING 151
#define TK_FLOAT 152
#define TK_BLOB  153
#define TK_INTEGER 154
#define TK_VARIABLE  155
#define TK_CASE  156
#define TK_WHEN  157
#define TK_THEN  158
#define TK_ELSE  159
#define TK_INDEX 160
#define TK_ALTER 161
#define TK_ADD 162
#define TK_WINDOW  163
#define TK_OVER  164
#define TK_FILTER  165
#define TK_COLUMN  166
#define TK_AGG_FUNCTION  167
#define TK_AGG_COLUMN  168
#define TK_TRUEFALSE 169
#define TK_ISNOT 170
#define TK_FUNCTION  171
#define TK_UMINUS  172
#define TK_UPLUS 173
#define TK_TRUTH 174
#define TK_REGISTER  175
#define TK_VECTOR  176
#define TK_SELECT_COLUMN 177
#define TK_IF_NULL_ROW 178
#define TK_ASTERISK  179
#define TK_SPAN  180
#define TK_ERROR 181
#define TK_SPACE 182
#define TK_ILLEGAL 183
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stddef.h>
#ifdef SQLITE_INLINE_MEMCPY
# define memcpy(D,S,N) {char*xxd=(char*)(D);const char*xxs=(const char*)(S); int xxn=(N);while(xxn-->0)*(xxd++)=*(xxs++);}

#endif
#ifdef SQLITE_OMIT_FLOATING_POINT
# define double sqlite_int64
# define float sqlite_int64
# define LONGDOUBLE_TYPE sqlite_int64
# ifndef SQLITE_BIG_DBL
#  define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)
# endif
# define SQLITE_OMIT_DATETIME_FUNCS 1
# define SQLITE_OMIT_TRACE 1
# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
# undef SQLITE_HAVE_ISNAN
#endif
#ifndef SQLITE_BIG_DBL
# define SQLITE_BIG_DBL (1e99)
#endif
#ifdef SQLITE_OMIT_TEMPDB
#define OMIT_TEMPDB 1
#else
#define OMIT_TEMPDB 0
#endif
#define SQLITE_MAX_FILE_FORMAT 4
#ifndef SQLITE_DEFAULT_FILE_FORMAT
# define SQLITE_DEFAULT_FILE_FORMAT 4
#endif
#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERS
# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0
#endif
#ifndef SQLITE_TEMP_STORE
# define SQLITE_TEMP_STORE 1
#endif
#if SQLITE_TEMP_STORE==3 || SQLITE_THREADSAFE==0
# undef SQLITE_MAX_WORKER_THREADS
# define SQLITE_MAX_WORKER_THREADS 0
#endif
#ifndef SQLITE_MAX_WORKER_THREADS
# define SQLITE_MAX_WORKER_THREADS 8
#endif
#ifndef SQLITE_DEFAULT_WORKER_THREADS
# define SQLITE_DEFAULT_WORKER_THREADS 0
#endif
#if SQLITE_DEFAULT_WORKER_THREADS>SQLITE_MAX_WORKER_THREADS
# undef SQLITE_MAX_WORKER_THREADS
# define SQLITE_MAX_WORKER_THREADS SQLITE_DEFAULT_WORKER_THREADS
#endif
#ifndef SQLITE_DEFAULT_PCACHE_INITSZ
# define SQLITE_DEFAULT_PCACHE_INITSZ 20
#endif
#ifndef SQLITE_DEFAULT_SORTERREF_SIZE
# define SQLITE_DEFAULT_SORTERREF_SIZE 0x7fffffff
#endif
#if defined(SQLITE_MMAP_READWRITE) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
#error Cannot use both SQLITE_MMAP_READWRITE and SQLITE_ENABLE_BATCH_ATOMIC_WRITE
#endif
#ifndef offsetof
#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))
#endif
#ifndef MIN
# define MIN(A,B) ((A)<(B)?(A):(B))
#endif
#ifndef MAX
# define MAX(A,B) ((A)>(B)?(A):(B))
#endif
#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}
#if 'A' == '\301'
# define SQLITE_EBCDIC 1
#else
# define SQLITE_ASCII 1
#endif
#ifndef UINT32_TYPE
# ifdef HAVE_UINT32_T
# define UINT32_TYPE uint32_t
# else
# define UINT32_TYPE unsigned int
# endif
#endif
#ifndef UINT16_TYPE
# ifdef HAVE_UINT16_T
# define UINT16_TYPE uint16_t
# else
# define UINT16_TYPE unsigned short int
# endif
#endif
#ifndef INT16_TYPE
# ifdef HAVE_INT16_T
# define INT16_TYPE int16_t
# else
# define INT16_TYPE short int
# endif
#endif
#ifndef UINT8_TYPE
# ifdef HAVE_UINT8_T
# define UINT8_TYPE uint8_t
# else
# define UINT8_TYPE unsigned char
# endif
#endif
#ifndef INT8_TYPE
# ifdef HAVE_INT8_T
# define INT8_TYPE int8_t
# else
# define INT8_TYPE signed char
# endif
#endif
#ifndef LONGDOUBLE_TYPE
# define LONGDOUBLE_TYPE long double
#endif
typedef sqlite_int64 i64; typedef sqlite_uint64 u64; typedef UINT32_TYPE u32; typedef UINT16_TYPE u16; typedef INT16_TYPE i16; typedef UINT8_TYPE u8; typedef INT8_TYPE i8;
#define SQLITE_MAX_U32 ((((u64)1)<<32)-1)
#ifdef SQLITE_64BIT_STATS
 typedef u64 tRowcnt;
#else
 typedef u32 tRowcnt;
#endif
typedef INT16_TYPE LogEst;
#ifndef SQLITE_PTRSIZE
# if defined(__SIZEOF_POINTER__)
#  define SQLITE_PTRSIZE __SIZEOF_POINTER__
# elif defined(i386)  || defined(__i386__)  || defined(_M_IX86) ||   defined(_M_ARM)  || defined(__arm__) || defined(__x86)  ||  (defined(__APPLE__) && defined(__POWERPC__)) ||   (defined(__TOS_AIX__) && !defined(__64BIT__))

#  define SQLITE_PTRSIZE 4
# else
#  define SQLITE_PTRSIZE 8
# endif
#endif
#if defined(HAVE_STDINT_H)
 typedef uintptr_t uptr;
#elif SQLITE_PTRSIZE==4
 typedef u32 uptr;
#else
 typedef u64 uptr;
#endif
#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))
#ifndef SQLITE_BYTEORDER
# if defined(i386) || defined(__i386__) || defined(_M_IX86) ||   defined(__x86_64) || defined(__x86_64__) || defined(_M_X64) ||   defined(_M_AMD64) || defined(_M_ARM) || defined(__x86)  ||   defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)

#  define SQLITE_BYTEORDER 1234
# elif defined(sparc)  || defined(__ppc__) ||   defined(__ARMEB__) || defined(__AARCH64EB__)

#  define SQLITE_BYTEORDER 4321
# else
#  define SQLITE_BYTEORDER 0
# endif
#endif
#if SQLITE_BYTEORDER==4321
# define SQLITE_BIGENDIAN 1
# define SQLITE_LITTLEENDIAN 0
# define SQLITE_UTF16NATIVE SQLITE_UTF16BE
#elif SQLITE_BYTEORDER==1234
# define SQLITE_BIGENDIAN 0
# define SQLITE_LITTLEENDIAN 1
# define SQLITE_UTF16NATIVE SQLITE_UTF16LE
#else
# ifdef SQLITE_AMALGAMATION
 const int sqlite3one = 1;
# else
 extern const int sqlite3one;
# endif
# define SQLITE_BIGENDIAN (*(char *)(&sqlite3one)==0)
# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)
# define SQLITE_UTF16NATIVE (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)
#endif
#define LARGEST_INT64 (0xffffffff|(((i64)0x7fffffff)<<32))
#define LARGEST_UINT64 (0xffffffff|(((u64)0xffffffff)<<32))
#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
#define ROUND8(x)  (((x)+7)&~7)
#define ROUNDDOWN8(x) ((x)&~7)
#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC
# define EIGHT_BYTE_ALIGNMENT(X)  ((((char*)(X) - (char*)0)&3)==0)
#else
# define EIGHT_BYTE_ALIGNMENT(X)  ((((char*)(X) - (char*)0)&7)==0)
#endif
#if defined(__OpenBSD__) || defined(__QNXNTO__)
# undef SQLITE_MAX_MMAP_SIZE
# define SQLITE_MAX_MMAP_SIZE 0
#endif
#ifdef __APPLE__
# include <TargetConditionals.h>
#endif
#ifndef SQLITE_MAX_MMAP_SIZE
# if defined(__linux__)  || defined(_WIN32)  || (defined(__APPLE__) && defined(__MACH__))  || defined(__sun)  || defined(__FreeBSD__)  || defined(__DragonFly__)

#  define SQLITE_MAX_MMAP_SIZE 0x7fff0000
# else
#  define SQLITE_MAX_MMAP_SIZE 0
# endif
#endif
#ifndef SQLITE_DEFAULT_MMAP_SIZE
# define SQLITE_DEFAULT_MMAP_SIZE 0
#endif
#if SQLITE_DEFAULT_MMAP_SIZE>SQLITE_MAX_MMAP_SIZE
# undef SQLITE_DEFAULT_MMAP_SIZE
# define SQLITE_DEFAULT_MMAP_SIZE SQLITE_MAX_MMAP_SIZE
#endif
#if !defined(SQLITE_AMALGAMATION)
SQLITE_PRIVATE u32 sqlite3SelectTrace;
#endif
#if defined(SQLITE_DEBUG)  && (defined(SQLITE_TEST) || defined(SQLITE_ENABLE_SELECTTRACE))

# define SELECTTRACE_ENABLED 1
# define SELECTTRACE(K,P,S,X)  if(sqlite3SelectTrace&(K))   sqlite3DebugPrintf("%u/%d/%p: ",(S)->selId,(P)->addrExplain,(S)), sqlite3DebugPrintf X

#else
# define SELECTTRACE(K,P,S,X)
# define SELECTTRACE_ENABLED 0
#endif
SQLITE_PRIVATE u32 sqlite3WhereTrace;
#if defined(SQLITE_DEBUG)  && (defined(SQLITE_TEST) || defined(SQLITE_ENABLE_WHERETRACE))

# define WHERETRACE(K,X) if(sqlite3WhereTrace&(K)) sqlite3DebugPrintf X
# define WHERETRACE_ENABLED 1
#else
# define WHERETRACE(K,X)
#endif
typedef struct BusyHandler BusyHandler; struct BusyHandler {  int (*xBusyHandler)(void *,int);  void *pBusyArg;  int nBusy; };
#define LEGACY_SCHEMA_TABLE "sqlite_master"
#define LEGACY_TEMP_SCHEMA_TABLE  "sqlite_temp_master"
#define PREFERRED_SCHEMA_TABLE  "sqlite_schema"
#define PREFERRED_TEMP_SCHEMA_TABLE "sqlite_temp_schema"
#define SCHEMA_ROOT 1
#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?LEGACY_TEMP_SCHEMA_TABLE:LEGACY_SCHEMA_TABLE)

#define ArraySize(X) ((int)(sizeof(X)/sizeof(X[0])))
#define IsPowerOfTwo(X) (((X)&((X)-1))==0)
#define SQLITE_DYNAMIC  ((sqlite3_destructor_type)sqlite3OomFault)
#ifdef SQLITE_OMIT_WSD
 #define SQLITE_WSD const
 #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))
 #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)
SQLITE_API int sqlite3_wsd_init(int N, int J); SQLITE_API void *sqlite3_wsd_find(void *K, int L);
#else
 #define SQLITE_WSD
 #define GLOBAL(t,v) v
 #define sqlite3GlobalConfig sqlite3Config
#endif
#define UNUSED_PARAMETER(x) (void)(x)
#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)
typedef struct AggInfo AggInfo; typedef struct AuthContext AuthContext; typedef struct AutoincInfo AutoincInfo; typedef struct Bitvec Bitvec; typedef struct CollSeq CollSeq; typedef struct Column Column; typedef struct Cte Cte; typedef struct CteUse CteUse; typedef struct Db Db; typedef struct DbFixer DbFixer; typedef struct Schema Schema; typedef struct Expr Expr; typedef struct ExprList ExprList; typedef struct FKey FKey; typedef struct FuncDestructor FuncDestructor; typedef struct FuncDef FuncDef; typedef struct FuncDefHash FuncDefHash; typedef struct IdList IdList; typedef struct Index Index; typedef struct IndexSample IndexSample; typedef struct KeyClass KeyClass; typedef struct KeyInfo KeyInfo; typedef struct Lookaside Lookaside; typedef struct LookasideSlot LookasideSlot; typedef struct Module Module; typedef struct NameContext NameContext; typedef struct Parse Parse; typedef struct ParseCleanup ParseCleanup; typedef struct PreUpdate PreUpdate; typedef struct PrintfArguments PrintfArguments; typedef struct RenameToken RenameToken; typedef struct Returning Returning; typedef struct RowSet RowSet; typedef struct Savepoint Savepoint; typedef struct Select Select; typedef struct SQLiteThread SQLiteThread; typedef struct SelectDest SelectDest; typedef struct SrcItem SrcItem; typedef struct SrcList SrcList; typedef struct sqlite3_str StrAccum; typedef struct Table Table; typedef struct TableLock TableLock; typedef struct Token Token; typedef struct TreeView TreeView; typedef struct Trigger Trigger; typedef struct TriggerPrg TriggerPrg; typedef struct TriggerStep TriggerStep; typedef struct UnpackedRecord UnpackedRecord; typedef struct Upsert Upsert; typedef struct VTable VTable; typedef struct VtabCtx VtabCtx; typedef struct Walker Walker; typedef struct WhereInfo WhereInfo; typedef struct Window Window; typedef struct With With;
#ifdef SQLITE_BITMASK_TYPE
 typedef SQLITE_BITMASK_TYPE Bitmask;
#else
 typedef u64 Bitmask;
#endif
#define BMS ((int)(sizeof(Bitmask)*8))
#define MASKBIT(n)  (((Bitmask)1)<<(n))
#define MASKBIT64(n) (((u64)1)<<(n))
#define MASKBIT32(n) (((unsigned int)1)<<(n))
#define ALLBITS ((Bitmask)-1)
typedef int VList;
#ifndef SQLITE_PAGER_H
#define SQLITE_PAGER_H
#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT
 #define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1
#endif
typedef u32 Pgno; typedef struct Pager Pager; typedef struct PgHdr DbPage;
#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1))
#define PAGER_OMIT_JOURNAL 0x0001
#define PAGER_MEMORY 0x0002
#define PAGER_LOCKINGMODE_QUERY -1
#define PAGER_LOCKINGMODE_NORMAL 0
#define PAGER_LOCKINGMODE_EXCLUSIVE  1
#define PAGER_JOURNALMODE_QUERY  (-1)
#define PAGER_JOURNALMODE_DELETE 0
#define PAGER_JOURNALMODE_PERSIST  1
#define PAGER_JOURNALMODE_OFF  2
#define PAGER_JOURNALMODE_TRUNCATE 3
#define PAGER_JOURNALMODE_MEMORY 4
#define PAGER_JOURNALMODE_WAL  5
#define PAGER_GET_NOCONTENT  0x01
#define PAGER_GET_READONLY 0x02
#define PAGER_SYNCHRONOUS_OFF  0x01
#define PAGER_SYNCHRONOUS_NORMAL 0x02
#define PAGER_SYNCHRONOUS_FULL 0x03
#define PAGER_SYNCHRONOUS_EXTRA  0x04
#define PAGER_SYNCHRONOUS_MASK 0x07
#define PAGER_FULLFSYNC  0x08
#define PAGER_CKPT_FULLFSYNC 0x10
#define PAGER_CACHESPILL 0x20
#define PAGER_FLAGS_MASK 0x38
SQLITE_PRIVATE int sqlite3PagerOpen(  sqlite3_vfs*,  Pager **ppPager,  const char*,  int,  int,  int,  void(*)(DbPage*) ); SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3*); SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*); SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *); SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int); SQLITE_PRIVATE Pgno sqlite3PagerMaxPageCount(Pager*, Pgno); SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int); SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager*, int); SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64); SQLITE_PRIVATE void sqlite3PagerShrink(Pager*); SQLITE_PRIVATE void sqlite3PagerSetFlags(Pager*,unsigned); SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int); SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int); SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*); SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*); SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64); SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*); SQLITE_PRIVATE int sqlite3PagerFlush(Pager*); SQLITE_PRIVATE int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag); SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno); SQLITE_PRIVATE void sqlite3PagerRef(DbPage*); SQLITE_PRIVATE void sqlite3PagerUnref(DbPage*); SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage*); SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage*); SQLITE_PRIVATE int sqlite3PagerWrite(DbPage*); SQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*); SQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int); SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*); SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *); SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *); SQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*); SQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int); SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zSuper, int); SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*); SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zSuper); SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*); SQLITE_PRIVATE int sqlite3PagerRollback(Pager*); SQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n); SQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint); SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager);
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE  int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*); SQLITE_PRIVATE  int sqlite3PagerWalSupported(Pager *pPager); SQLITE_PRIVATE  int sqlite3PagerWalCallback(Pager *pPager); SQLITE_PRIVATE  int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen); SQLITE_PRIVATE  int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);
# ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE  int sqlite3PagerSnapshotGet(Pager*, sqlite3_snapshot **ppSnapshot); SQLITE_PRIVATE  int sqlite3PagerSnapshotOpen(Pager*, sqlite3_snapshot *pSnapshot); SQLITE_PRIVATE  int sqlite3PagerSnapshotRecover(Pager *pPager); SQLITE_PRIVATE  int sqlite3PagerSnapshotCheck(Pager *pPager, sqlite3_snapshot *pSnapshot); SQLITE_PRIVATE  void sqlite3PagerSnapshotUnlock(Pager *pPager);
# endif
#endif
#if !defined(SQLITE_OMIT_WAL) && defined(SQLITE_ENABLE_SETLK_TIMEOUT)
SQLITE_PRIVATE  int sqlite3PagerWalWriteLock(Pager*, int); SQLITE_PRIVATE  void sqlite3PagerWalDb(Pager*, sqlite3*);
#else
# define sqlite3PagerWalWriteLock(y,z) SQLITE_OK
# define sqlite3PagerWalDb(x,y)
#endif
#ifdef SQLITE_DIRECT_OVERFLOW_READ
SQLITE_PRIVATE  int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno);
#endif
#ifdef SQLITE_ENABLE_ZIPVFS
SQLITE_PRIVATE  int sqlite3PagerWalFramesize(Pager *pPager);
#endif
SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*); SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  int sqlite3PagerRefcount(Pager*);
#endif
SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*); SQLITE_PRIVATE const char *sqlite3PagerFilename(const Pager*, int); SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager*); SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*); SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager*); SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*); SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*); SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*); SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *); SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*); SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *); SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno); SQLITE_PRIVATE void sqlite3PagerRekey(DbPage*, Pgno, u16);
#if !defined(NDEBUG) || defined(SQLITE_TEST)
SQLITE_PRIVATE  Pgno sqlite3PagerPagenumber(DbPage*); SQLITE_PRIVATE  int sqlite3PagerIswriteable(DbPage*);
#endif
#ifdef SQLITE_TEST
SQLITE_PRIVATE  int *sqlite3PagerStats(Pager*); SQLITE_PRIVATE  void sqlite3PagerRefdump(Pager*);  void disable_simulated_io_errors(void);  void enable_simulated_io_errors(void);
#else
# define disable_simulated_io_errors()
# define enable_simulated_io_errors()
#endif
#endif
#ifndef SQLITE_BTREE_H
#define SQLITE_BTREE_H
#define SQLITE_N_BTREE_META 16
#ifndef SQLITE_DEFAULT_AUTOVACUUM
 #define SQLITE_DEFAULT_AUTOVACUUM 0
#endif
#define BTREE_AUTOVACUUM_NONE 0
#define BTREE_AUTOVACUUM_FULL 1
#define BTREE_AUTOVACUUM_INCR 2
typedef struct Btree Btree; typedef struct BtCursor BtCursor; typedef struct BtShared BtShared; typedef struct BtreePayload BtreePayload; SQLITE_PRIVATE int sqlite3BtreeOpen(  sqlite3_vfs *pVfs,  const char *zFilename,  sqlite3 *db,  Btree **ppBtree,  int flags,  int vfsFlags );
#define BTREE_OMIT_JOURNAL 1
#define BTREE_MEMORY 2
#define BTREE_SINGLE 4
#define BTREE_UNORDERED  8
SQLITE_PRIVATE int sqlite3BtreeClose(Btree*); SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree*,int); SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree*,int);
#if SQLITE_MAX_MMAP_SIZE>0
SQLITE_PRIVATE  int sqlite3BtreeSetMmapLimit(Btree*,sqlite3_int64);
#endif
SQLITE_PRIVATE int sqlite3BtreeSetPagerFlags(Btree*,unsigned); SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix); SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*); SQLITE_PRIVATE Pgno sqlite3BtreeMaxPageCount(Btree*,Pgno); SQLITE_PRIVATE Pgno sqlite3BtreeLastPage(Btree*); SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*,int); SQLITE_PRIVATE int sqlite3BtreeGetRequestedReserve(Btree*); SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p); SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int); SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *); SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int,int*); SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char*); SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree*, int); SQLITE_PRIVATE int sqlite3BtreeCommit(Btree*); SQLITE_PRIVATE int sqlite3BtreeRollback(Btree*,int,int); SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree*,int); SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, Pgno*, int flags); SQLITE_PRIVATE int sqlite3BtreeTxnState(Btree*); SQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree*); SQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *, int, void(*)(void *)); SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *pBtree);
#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);
#endif
SQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *, int, int);
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE  int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);
#endif
SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *); SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *); SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *, Btree *); SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *);
#define BTREE_INTKEY  1
#define BTREE_BLOBKEY 2
SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree*, int, int*); SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, i64*); SQLITE_PRIVATE int sqlite3BtreeClearTableOfCursor(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree*, int, int); SQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue); SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value); SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p);
#define BTREE_FREE_PAGE_COUNT  0
#define BTREE_SCHEMA_VERSION 1
#define BTREE_FILE_FORMAT  2
#define BTREE_DEFAULT_CACHE_SIZE 3
#define BTREE_LARGEST_ROOT_PAGE  4
#define BTREE_TEXT_ENCODING  5
#define BTREE_USER_VERSION 6
#define BTREE_INCR_VACUUM  7
#define BTREE_APPLICATION_ID 8
#define BTREE_DATA_VERSION 15
#define BTREE_HINT_RANGE 0
#define BTREE_BULKLOAD 0x00000001
#define BTREE_SEEK_EQ 0x00000002
#define BTREE_WRCSR  0x00000004
#define BTREE_FORDELETE 0x00000008
SQLITE_PRIVATE int sqlite3BtreeCursor(  Btree*,  Pgno iTable,  int wrFlag,  struct KeyInfo*,  BtCursor *pCursor ); SQLITE_PRIVATE BtCursor *sqlite3BtreeFakeValidCursor(void); SQLITE_PRIVATE int sqlite3BtreeCursorSize(void); SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor*); SQLITE_PRIVATE void sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);
#ifdef SQLITE_ENABLE_CURSOR_HINTS
SQLITE_PRIVATE void sqlite3BtreeCursorHint(BtCursor*, int, ...);
#endif
SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeTableMoveto(  BtCursor*,  i64 intKey,  int bias,  int *pRes ); SQLITE_PRIVATE int sqlite3BtreeIndexMoveto(  BtCursor*,  UnpackedRecord *pUnKey,  int *pRes ); SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor*, int*); SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*, u8 flags);
#define BTREE_SAVEPOSITION 0x02
#define BTREE_AUXDELETE 0x04
#define BTREE_APPEND  0x08
#define BTREE_PREFORMAT 0x80
struct BtreePayload {  const void *pKey;  sqlite3_int64 nKey;  const void *pData;  sqlite3_value *aMem;  u16 nMem;  int nData;  int nZero; }; SQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,   int flags, int seekResult); SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes); SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes); SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int flags); SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*); SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int flags); SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor*); SQLITE_PRIVATE void sqlite3BtreeCursorPin(BtCursor*); SQLITE_PRIVATE void sqlite3BtreeCursorUnpin(BtCursor*);
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
SQLITE_PRIVATE i64 sqlite3BtreeOffset(BtCursor*);
#endif
SQLITE_PRIVATE int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*); SQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt); SQLITE_PRIVATE u32 sqlite3BtreePayloadSize(BtCursor*); SQLITE_PRIVATE sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor*); SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(sqlite3*,Btree*,Pgno*aRoot,int nRoot,int,int*); SQLITE_PRIVATE struct Pager *sqlite3BtreePager(Btree*); SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor*);
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE int sqlite3BtreePayloadChecked(BtCursor*, u32 offset, u32 amt, void*); SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*); SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *);
#endif
SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *); SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBt, int iVersion); SQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask); SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *pBt); SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE sqlite3_uint64 sqlite3BtreeSeekCount(Btree*);
#else
# define sqlite3BtreeSeekCount(X) 0
#endif
#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor*);
#endif
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor*); SQLITE_PRIVATE int sqlite3BtreeCount(sqlite3*, BtCursor*, i64*);
#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int); SQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*);
#endif
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE  int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);
#endif
SQLITE_PRIVATE int sqlite3BtreeTransferRow(BtCursor*, BtCursor*, i64);
#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE  void sqlite3BtreeEnter(Btree*); SQLITE_PRIVATE  void sqlite3BtreeEnterAll(sqlite3*); SQLITE_PRIVATE  int sqlite3BtreeSharable(Btree*); SQLITE_PRIVATE  void sqlite3BtreeEnterCursor(BtCursor*); SQLITE_PRIVATE  int sqlite3BtreeConnectionCount(Btree*);
#else
# define sqlite3BtreeEnter(X)
# define sqlite3BtreeEnterAll(X)
# define sqlite3BtreeSharable(X) 0
# define sqlite3BtreeEnterCursor(X)
# define sqlite3BtreeConnectionCount(X) 1
#endif
#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE
SQLITE_PRIVATE  void sqlite3BtreeLeave(Btree*); SQLITE_PRIVATE  void sqlite3BtreeLeaveCursor(BtCursor*); SQLITE_PRIVATE  void sqlite3BtreeLeaveAll(sqlite3*);
#ifndef NDEBUG
SQLITE_PRIVATE  int sqlite3BtreeHoldsMutex(Btree*); SQLITE_PRIVATE  int sqlite3BtreeHoldsAllMutexes(sqlite3*); SQLITE_PRIVATE  int sqlite3SchemaMutexHeld(sqlite3*,int,Schema*);
#endif
#else
# define sqlite3BtreeLeave(X)
# define sqlite3BtreeLeaveCursor(X)
# define sqlite3BtreeLeaveAll(X)
# define sqlite3BtreeHoldsMutex(X) 1
# define sqlite3BtreeHoldsAllMutexes(X) 1
# define sqlite3SchemaMutexHeld(X,Y,Z) 1
#endif
#endif
#ifndef SQLITE_VDBE_H
#define SQLITE_VDBE_H
typedef struct Vdbe Vdbe; typedef struct sqlite3_value Mem; typedef struct SubProgram SubProgram; struct VdbeOp {  u8 opcode;  signed char p4type;  u16 p5;  int p1;  int p2;  int p3;  union p4union {  int i;  void *p;  char *z;  i64 *pI64;  double *pReal;  FuncDef *pFunc;  sqlite3_context *pCtx;  CollSeq *pColl;  Mem *pMem;  VTable *pVtab;  KeyInfo *pKeyInfo;  u32 *ai;  SubProgram *pProgram;  Table *pTab;
#ifdef SQLITE_ENABLE_CURSOR_HINTS
 Expr *pExpr;
#endif
 int (*xAdvance)(BtCursor *, int);  } p4;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 char *zComment;
#endif
#ifdef VDBE_PROFILE
 u32 cnt;  u64 cycles;
#endif
#ifdef SQLITE_VDBE_COVERAGE
 u32 iSrcLine;
#endif
}; typedef struct VdbeOp VdbeOp; struct SubProgram {  VdbeOp *aOp;  int nOp;  int nMem;  int nCsr;  u8 *aOnce;  void *token;  SubProgram *pNext; }; struct VdbeOpList {  u8 opcode;  signed char p1;  signed char p2;  signed char p3; }; typedef struct VdbeOpList VdbeOpList;
#define P4_NOTUSED 0
#define P4_TRANSIENT 0
#define P4_STATIC  (-1)
#define P4_COLLSEQ (-2)
#define P4_INT32 (-3)
#define P4_SUBPROGRAM (-4)
#define P4_ADVANCE (-5)
#define P4_TABLE (-6)
#define P4_FREE_IF_LE (-7)
#define P4_DYNAMIC (-7)
#define P4_FUNCDEF (-8)
#define P4_KEYINFO (-9)
#define P4_EXPR  (-10)
#define P4_MEM (-11)
#define P4_VTAB  (-12)
#define P4_REAL  (-13)
#define P4_INT64 (-14)
#define P4_INTARRAY  (-15)
#define P4_FUNCCTX (-16)
#define P4_DYNBLOB (-17)
#define P5_ConstraintNotNull 1
#define P5_ConstraintUnique 2
#define P5_ConstraintCheck  3
#define P5_ConstraintFK 4
#define COLNAME_NAME  0
#define COLNAME_DECLTYPE 1
#define COLNAME_DATABASE 2
#define COLNAME_TABLE 3
#define COLNAME_COLUMN  4
#ifdef SQLITE_ENABLE_COLUMN_METADATA
# define COLNAME_N 5
#else
# ifdef SQLITE_OMIT_DECLTYPE
#  define COLNAME_N 1
# else
#  define COLNAME_N 2
# endif
#endif
#define ADDR(X) (~(X))
#define OP_Savepoint  0
#define OP_AutoCommit 1
#define OP_Transaction  2
#define OP_SorterNext 3
#define OP_Prev 4
#define OP_Next 5
#define OP_Checkpoint 6
#define OP_JournalMode  7
#define OP_Vacuum 8
#define OP_VFilter  9
#define OP_VUpdate 10
#define OP_Goto  11
#define OP_Gosub 12
#define OP_InitCoroutine 13
#define OP_Yield 14
#define OP_MustBeInt 15
#define OP_Jump  16
#define OP_Once  17
#define OP_If  18
#define OP_Not 19
#define OP_IfNot 20
#define OP_IsNullOrType  21
#define OP_IfNullRow 22
#define OP_SeekLT  23
#define OP_SeekLE  24
#define OP_SeekGE  25
#define OP_SeekGT  26
#define OP_IfNotOpen 27
#define OP_IfNoHope  28
#define OP_NoConflict  29
#define OP_NotFound  30
#define OP_Found 31
#define OP_SeekRowid 32
#define OP_NotExists 33
#define OP_Last  34
#define OP_IfSmaller 35
#define OP_SorterSort  36
#define OP_Sort  37
#define OP_Rewind  38
#define OP_IdxLE 39
#define OP_IdxGT 40
#define OP_IdxLT 41
#define OP_IdxGE 42
#define OP_Or  43
#define OP_And 44
#define OP_RowSetRead  45
#define OP_RowSetTest  46
#define OP_Program 47
#define OP_FkIfZero  48
#define OP_IfPos 49
#define OP_IsNull  50
#define OP_NotNull 51
#define OP_Ne  52
#define OP_Eq  53
#define OP_Gt  54
#define OP_Le  55
#define OP_Lt  56
#define OP_Ge  57
#define OP_ElseEq  58
#define OP_IfNotZero 59
#define OP_DecrJumpZero  60
#define OP_IncrVacuum  61
#define OP_VNext 62
#define OP_Init  63
#define OP_PureFunc  64
#define OP_Function  65
#define OP_Return  66
#define OP_EndCoroutine  67
#define OP_HaltIfNull  68
#define OP_Halt  69
#define OP_Integer 70
#define OP_Int64 71
#define OP_String  72
#define OP_Null  73
#define OP_SoftNull  74
#define OP_Blob  75
#define OP_Variable  76
#define OP_Move  77
#define OP_Copy  78
#define OP_SCopy 79
#define OP_IntCopy 80
#define OP_ChngCntRow  81
#define OP_ResultRow 82
#define OP_CollSeq 83
#define OP_AddImm  84
#define OP_RealAffinity  85
#define OP_Cast  86
#define OP_Permutation 87
#define OP_Compare 88
#define OP_IsTrue  89
#define OP_ZeroOrNull  90
#define OP_Offset  91
#define OP_Column  92
#define OP_TypeCheck 93
#define OP_Affinity  94
#define OP_MakeRecord  95
#define OP_Count 96
#define OP_ReadCookie  97
#define OP_SetCookie 98
#define OP_ReopenIdx 99
#define OP_OpenRead 100
#define OP_OpenWrite  101
#define OP_BitAnd 102
#define OP_BitOr  103
#define OP_ShiftLeft  104
#define OP_ShiftRight 105
#define OP_Add  106
#define OP_Subtract 107
#define OP_Multiply 108
#define OP_Divide 109
#define OP_Remainder  110
#define OP_Concat 111
#define OP_OpenDup  112
#define OP_BitNot 113
#define OP_OpenAutoindex 114
#define OP_OpenEphemeral 115
#define OP_String8  116
#define OP_SorterOpen 117
#define OP_SequenceTest 118
#define OP_OpenPseudo 119
#define OP_Close  120
#define OP_ColumnsUsed  121
#define OP_SeekScan 122
#define OP_SeekHit  123
#define OP_Sequence 124
#define OP_NewRowid 125
#define OP_Insert 126
#define OP_RowCell  127
#define OP_Delete 128
#define OP_ResetCount 129
#define OP_SorterCompare 130
#define OP_SorterData 131
#define OP_RowData  132
#define OP_Rowid  133
#define OP_NullRow  134
#define OP_SeekEnd  135
#define OP_IdxInsert  136
#define OP_SorterInsert 137
#define OP_IdxDelete  138
#define OP_DeferredSeek 139
#define OP_IdxRowid 140
#define OP_FinishSeek 141
#define OP_Destroy  142
#define OP_Clear  143
#define OP_ResetSorter  144
#define OP_CreateBtree  145
#define OP_SqlExec  146
#define OP_ParseSchema  147
#define OP_LoadAnalysis 148
#define OP_DropTable  149
#define OP_DropIndex  150
#define OP_DropTrigger  151
#define OP_Real 152
#define OP_IntegrityCk  153
#define OP_RowSetAdd  154
#define OP_Param  155
#define OP_FkCounter  156
#define OP_MemMax 157
#define OP_OffsetLimit  158
#define OP_AggInverse 159
#define OP_AggStep  160
#define OP_AggStep1 161
#define OP_AggValue 162
#define OP_AggFinal 163
#define OP_Expire 164
#define OP_CursorLock 165
#define OP_CursorUnlock 166
#define OP_TableLock  167
#define OP_VBegin 168
#define OP_VCreate  169
#define OP_VDestroy 170
#define OP_VOpen  171
#define OP_VColumn  172
#define OP_VRename  173
#define OP_Pagecount  174
#define OP_MaxPgcnt 175
#define OP_Trace  176
#define OP_CursorHint 177
#define OP_ReleaseReg 178
#define OP_Noop 179
#define OP_Explain  180
#define OP_Abortable  181
#define OPFLG_JUMP 0x01
#define OPFLG_IN1  0x02
#define OPFLG_IN2  0x04
#define OPFLG_IN3  0x08
#define OPFLG_OUT2 0x10
#define OPFLG_OUT3 0x20
#define OPFLG_INITIALIZER { 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x03, 0x12, 0x03, 0x03, 0x01, 0x09, 0x09, 0x09, 0x09, 0x01, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x26, 0x26, 0x23, 0x0b, 0x01, 0x01, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00, 0x12, 0x1e, 0x20, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,}

#define SQLITE_MX_JUMP_OPCODE 63
#define SQLITE_PREPARE_SAVESQL 0x80
#define SQLITE_PREPARE_MASK  0x0f
SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse*); SQLITE_PRIVATE Parse *sqlite3VdbeParser(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*,int); SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*,int,int); SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*,int,int,int); SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe*,int); SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe*,int,const char*); SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...); SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int); SQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int); SQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int); SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int); SQLITE_PRIVATE int sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int); SQLITE_PRIVATE void sqlite3VdbeEndCoroutine(Vdbe*,int);
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
SQLITE_PRIVATE  void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N); SQLITE_PRIVATE  void sqlite3VdbeVerifyNoResultRow(Vdbe *p);
#else
# define sqlite3VdbeVerifyNoMallocRequired(A,B)
# define sqlite3VdbeVerifyNoResultRow(A)
#endif
#if defined(SQLITE_DEBUG)
SQLITE_PRIVATE  void sqlite3VdbeVerifyAbortable(Vdbe *p, int);
#else
# define sqlite3VdbeVerifyAbortable(A,B)
#endif
SQLITE_PRIVATE VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp,int iLineno);
#ifndef SQLITE_OMIT_EXPLAIN
SQLITE_PRIVATE  void sqlite3VdbeExplain(Parse*,u8,const char*,...); SQLITE_PRIVATE  void sqlite3VdbeExplainPop(Parse*); SQLITE_PRIVATE  int sqlite3VdbeExplainParent(Parse*);
# define ExplainQueryPlan(P) sqlite3VdbeExplain P
# define ExplainQueryPlanPop(P)  sqlite3VdbeExplainPop(P)
# define ExplainQueryPlanParent(P) sqlite3VdbeExplainParent(P)
#else
# define ExplainQueryPlan(P)
# define ExplainQueryPlanPop(P)
# define ExplainQueryPlanParent(P) 0
# define sqlite3ExplainBreakpoint(A,B)
#endif
#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_EXPLAIN)
SQLITE_PRIVATE  void sqlite3ExplainBreakpoint(const char*,const char*);
#else
# define sqlite3ExplainBreakpoint(A,B)
#endif
SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe*, int, char*, u16); SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe*, int addr, u8); SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1); SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2); SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3); SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u16 P5); SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr); SQLITE_PRIVATE void sqlite3VdbeJumpHereOrPopInst(Vdbe*, int addr); SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe*, int addr); SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  void sqlite3VdbeReleaseRegisters(Parse*,int addr, int n, u32 mask, int);
#else
# define sqlite3VdbeReleaseRegisters(P,A,N,M,F)
#endif
SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N); SQLITE_PRIVATE void sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type); SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse*, Index*); SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe*, int); SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe*, int); SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Parse*); SQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeReusable(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3*,Vdbe*); SQLITE_PRIVATE void sqlite3VdbeMakeReady(Vdbe*,Parse*); SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe*, int); SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  int sqlite3VdbeAssertMayAbort(Vdbe *, int);
#endif
SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeRewind(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*,int); SQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*)); SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*); SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*); SQLITE_PRIVATE u8 sqlite3VdbePrepareFlags(Vdbe*); SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);
#ifdef SQLITE_ENABLE_NORMALIZE
SQLITE_PRIVATE void sqlite3VdbeAddDblquoteStr(sqlite3*,Vdbe*,const char*); SQLITE_PRIVATE int sqlite3VdbeUsesDoubleQuotedString(Vdbe*,const char*);
#endif
SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*,Vdbe*); SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*); SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8); SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe*, int);
#ifndef SQLITE_OMIT_TRACE
SQLITE_PRIVATE  char *sqlite3VdbeExpandSql(Vdbe*, const char*);
#endif
SQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*); SQLITE_PRIVATE int sqlite3BlobCompare(const Mem*, const Mem*); SQLITE_PRIVATE void sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,UnpackedRecord*); SQLITE_PRIVATE int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*); SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int); SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*); typedef int (*RecordCompare)(int,const void*,UnpackedRecord*); SQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*); SQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *); SQLITE_PRIVATE int sqlite3VdbeHasSubProgram(Vdbe*); SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context*);
#ifdef SQLITE_ENABLE_BYTECODE_VTAB
SQLITE_PRIVATE int sqlite3VdbeBytecodeVtabInit(sqlite3*);
#endif
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
SQLITE_PRIVATE  void sqlite3VdbeComment(Vdbe*, const char*, ...);
# define VdbeComment(X) sqlite3VdbeComment X
SQLITE_PRIVATE  void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);
# define VdbeNoopComment(X) sqlite3VdbeNoopComment X
# ifdef SQLITE_ENABLE_MODULE_COMMENTS
#  define VdbeModuleComment(X) sqlite3VdbeNoopComment X
# else
#  define VdbeModuleComment(X)
# endif
#else
# define VdbeComment(X)
# define VdbeNoopComment(X)
# define VdbeModuleComment(X)
#endif
#ifdef SQLITE_VDBE_COVERAGE
SQLITE_PRIVATE  void sqlite3VdbeSetLineNumber(Vdbe*,int);
# define VdbeCoverage(v) sqlite3VdbeSetLineNumber(v,__LINE__)
# define VdbeCoverageIf(v,x) if(x)sqlite3VdbeSetLineNumber(v,__LINE__)
# define VdbeCoverageAlwaysTaken(v)   sqlite3VdbeSetLineNumber(v,__LINE__|0x5000000);

# define VdbeCoverageNeverTaken(v)   sqlite3VdbeSetLineNumber(v,__LINE__|0x6000000);

# define VdbeCoverageNeverNull(v)   sqlite3VdbeSetLineNumber(v,__LINE__|0x4000000);

# define VdbeCoverageNeverNullIf(v,x)   if(x)sqlite3VdbeSetLineNumber(v,__LINE__|0x4000000);

# define VdbeCoverageEqNe(v)   sqlite3VdbeSetLineNumber(v,__LINE__|0x8000000);

# define VDBE_OFFSET_LINENO(x) (__LINE__+x)
#else
# define VdbeCoverage(v)
# define VdbeCoverageIf(v,x)
# define VdbeCoverageAlwaysTaken(v)
# define VdbeCoverageNeverTaken(v)
# define VdbeCoverageNeverNull(v)
# define VdbeCoverageNeverNullIf(v,x)
# define VdbeCoverageEqNe(v)
# define VDBE_OFFSET_LINENO(x) 0
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
SQLITE_PRIVATE void sqlite3VdbeScanStatus(Vdbe*, int, int, int, LogEst, const char*);
#else
# define sqlite3VdbeScanStatus(a,b,c,d,e)
#endif
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE*, int, VdbeOp*);
#endif
#endif
#ifndef _PCACHE_H_
typedef struct PgHdr PgHdr; typedef struct PCache PCache; struct PgHdr {  sqlite3_pcache_page *pPage;  void *pData;  void *pExtra;  PCache *pCache;  PgHdr *pDirty;  Pager *pPager;  Pgno pgno;
#ifdef SQLITE_CHECK_PAGES
 u32 pageHash;
#endif
 u16 flags;  i16 nRef;  PgHdr *pDirtyNext;  PgHdr *pDirtyPrev; };
#define PGHDR_CLEAN  0x001
#define PGHDR_DIRTY  0x002
#define PGHDR_WRITEABLE  0x004
#define PGHDR_NEED_SYNC  0x008
#define PGHDR_DONT_WRITE 0x010
#define PGHDR_MMAP 0x020
#define PGHDR_WAL_APPEND 0x040
SQLITE_PRIVATE int sqlite3PcacheInitialize(void); SQLITE_PRIVATE void sqlite3PcacheShutdown(void); SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *, int sz, int n); SQLITE_PRIVATE int sqlite3PcacheOpen(  int szPage,  int szExtra,  int bPurgeable,  int (*xStress)(void*, PgHdr*),  void *pStress,  PCache *pToInit ); SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *, int); SQLITE_PRIVATE int sqlite3PcacheSize(void); SQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(PCache*, Pgno, int createFlag); SQLITE_PRIVATE int sqlite3PcacheFetchStress(PCache*, Pgno, sqlite3_pcache_page**); SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(PCache*, Pgno, sqlite3_pcache_page *pPage); SQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr*); SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache*); SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache*); SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr*, Pgno); SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache*, Pgno x); SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache*); SQLITE_PRIVATE void sqlite3PcacheClose(PCache*); SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *); SQLITE_PRIVATE void sqlite3PcacheClear(PCache*); SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*); SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr*); SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*); SQLITE_PRIVATE int sqlite3PcachePagecount(PCache*);
#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)
SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *));
#endif
#if defined(SQLITE_DEBUG)
SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr*);
#endif
SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *, int);
#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *);
#endif
SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *, int); SQLITE_PRIVATE void sqlite3PcacheShrink(PCache*);
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int);
#endif
#ifdef SQLITE_TEST
SQLITE_PRIVATE void sqlite3PcacheStats(int*,int*,int*,int*);
#endif
SQLITE_PRIVATE void sqlite3PCacheSetDefault(void); SQLITE_PRIVATE int sqlite3HeaderSizePcache(void); SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void); SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache*);
#ifdef SQLITE_DIRECT_OVERFLOW_READ
SQLITE_PRIVATE int sqlite3PCacheIsDirty(PCache *pCache);
#endif
#endif
#ifndef _SQLITE_OS_H_
#define _SQLITE_OS_H_
#ifndef SQLITE_OS_SETUP_H
#define SQLITE_OS_SETUP_H
#if defined(SQLITE_OS_OTHER)
# if SQLITE_OS_OTHER==1
# undef SQLITE_OS_UNIX
# define SQLITE_OS_UNIX 0
# undef SQLITE_OS_WIN
# define SQLITE_OS_WIN 0
# else
# undef SQLITE_OS_OTHER
# endif
#endif
#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)
# define SQLITE_OS_OTHER 0
# ifndef SQLITE_OS_WIN
# if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) ||  defined(__MINGW32__) || defined(__BORLANDC__)

# define SQLITE_OS_WIN 1
# define SQLITE_OS_UNIX 0
# else
# define SQLITE_OS_WIN 0
# define SQLITE_OS_UNIX 1
# endif
# else
# define SQLITE_OS_UNIX 0
# endif
#else
# ifndef SQLITE_OS_WIN
# define SQLITE_OS_WIN 0
# endif
#endif
#endif
#ifndef SET_FULLSYNC
# define SET_FULLSYNC(x,y)
#endif
#ifndef SQLITE_MAX_PATHLEN
# define SQLITE_MAX_PATHLEN FILENAME_MAX
#endif
#ifndef SQLITE_DEFAULT_SECTOR_SIZE
# define SQLITE_DEFAULT_SECTOR_SIZE 4096
#endif
#ifndef SQLITE_TEMP_FILE_PREFIX
# define SQLITE_TEMP_FILE_PREFIX "etilqs_"
#endif
#define NO_LOCK  0
#define SHARED_LOCK  1
#define RESERVED_LOCK  2
#define PENDING_LOCK 3
#define EXCLUSIVE_LOCK 4
#ifdef SQLITE_OMIT_WSD
# define PENDING_BYTE  (0x40000000)
#else
# define PENDING_BYTE sqlite3PendingByte
#endif
#define RESERVED_BYTE  (PENDING_BYTE+1)
#define SHARED_FIRST (PENDING_BYTE+2)
#define SHARED_SIZE  510
SQLITE_PRIVATE int sqlite3OsInit(void); SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file*); SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset); SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset); SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size); SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int); SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize); SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int); SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int); SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut); SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*); SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file*,int,void*);
#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0
SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id); SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **); SQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int); SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id); SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);
#endif
SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64, int, void **); SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *, i64, void *); SQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *); SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int); SQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut); SQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);
#ifndef SQLITE_OMIT_LOAD_EXTENSION
SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *); SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *); SQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void); SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);
#endif
SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *); SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int); SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs*); SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*); SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*); SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *);
#endif
#if !SQLITE_THREADSAFE
# define SQLITE_MUTEX_OMIT
#endif
#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)
# if SQLITE_OS_UNIX
# define SQLITE_MUTEX_PTHREADS
# elif SQLITE_OS_WIN
# define SQLITE_MUTEX_W32
# else
# define SQLITE_MUTEX_NOOP
# endif
#endif
#ifdef SQLITE_MUTEX_OMIT
#define sqlite3_mutex_alloc(X) ((sqlite3_mutex*)8)
#define sqlite3_mutex_free(X)
#define sqlite3_mutex_enter(X)
#define sqlite3_mutex_try(X) SQLITE_OK
#define sqlite3_mutex_leave(X)
#define sqlite3_mutex_held(X)  ((void)(X),1)
#define sqlite3_mutex_notheld(X) ((void)(X),1)
#define sqlite3MutexAlloc(X) ((sqlite3_mutex*)8)
#define sqlite3MutexInit() SQLITE_OK
#define sqlite3MutexEnd()
#define MUTEX_LOGIC(X)
#else
#define MUTEX_LOGIC(X) X
SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);
#endif
#ifdef SQLITE_EXTRA_DURABLE
# warning Use SQLITE_DEFAULT_SYNCHRONOUS=3 instead of SQLITE_EXTRA_DURABLE
# define SQLITE_DEFAULT_SYNCHRONOUS 3
#endif
#ifndef SQLITE_DEFAULT_SYNCHRONOUS
# define SQLITE_DEFAULT_SYNCHRONOUS 2
#endif
#ifndef SQLITE_DEFAULT_WAL_SYNCHRONOUS
# define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS
#endif
struct Db {  char *zDbSName;  Btree *pBt;  u8 safety_level;  u8 bSyncSet;  Schema *pSchema; }; struct Schema {  int schema_cookie;  int iGeneration;  Hash tblHash;  Hash idxHash;  Hash trigHash;  Hash fkeyHash;  Table *pSeqTab;  u8 file_format;  u8 enc;  u16 schemaFlags;  int cache_size; };
#define DbHasProperty(D,I,P)  (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))
#define DbHasAnyProperty(D,I,P) (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)
#define DbSetProperty(D,I,P)  (D)->aDb[I].pSchema->schemaFlags|=(P)
#define DbClearProperty(D,I,P)  (D)->aDb[I].pSchema->schemaFlags&=~(P)
#define DB_SchemaLoaded 0x0001
#define DB_UnresetViews 0x0002
#define DB_ResetWanted  0x0008
#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1)
struct Lookaside {  u32 bDisable;  u16 sz;  u16 szTrue;  u8 bMalloced;  u32 nSlot;  u32 anStat[3];  LookasideSlot *pInit;  LookasideSlot *pFree;
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 LookasideSlot *pSmallInit;  LookasideSlot *pSmallFree;  void *pMiddle;
#endif
 void *pStart;  void *pEnd; }; struct LookasideSlot {  LookasideSlot *pNext; };
#define DisableLookaside db->lookaside.bDisable++;db->lookaside.sz=0
#define EnableLookaside  db->lookaside.bDisable--;  db->lookaside.sz=db->lookaside.bDisable?0:db->lookaside.szTrue

#ifdef SQLITE_OMIT_TWOSIZE_LOOKASIDE
# define LOOKASIDE_SMALL  0
#else
# define LOOKASIDE_SMALL  128
#endif
#define SQLITE_FUNC_HASH_SZ 23
struct FuncDefHash {  FuncDef *a[SQLITE_FUNC_HASH_SZ]; };
#define SQLITE_FUNC_HASH(C,L) (((C)+(L))%SQLITE_FUNC_HASH_SZ)
#ifdef SQLITE_USER_AUTHENTICATION
typedef struct sqlite3_userauth sqlite3_userauth; struct sqlite3_userauth {  u8 authLevel;  int nAuthPW;  char *zAuthPW;  char *zAuthUser; };
#define UAUTH_Unknown  0
#define UAUTH_Fail 1
#define UAUTH_User 2
#define UAUTH_Admin  3
SQLITE_PRIVATE int sqlite3UserAuthTable(const char*); SQLITE_PRIVATE int sqlite3UserAuthCheckLogin(sqlite3*,const char*,u8*); SQLITE_PRIVATE void sqlite3UserAuthInit(sqlite3*); SQLITE_PRIVATE void sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**);
#endif
#ifdef SQLITE_USER_AUTHENTICATION
 typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,   const char*, const char*);
#else
 typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,   const char*);
#endif
#ifndef SQLITE_OMIT_DEPRECATED
#define SQLITE_TRACE_LEGACY 0x40
#define SQLITE_TRACE_XPROFILE 0x80
#else
#define SQLITE_TRACE_LEGACY 0
#define SQLITE_TRACE_XPROFILE 0
#endif
#define SQLITE_TRACE_NONLEGACY_MASK 0x0f
#define SQLITE_MAX_DB (SQLITE_MAX_ATTACHED+2)
struct sqlite3 {  sqlite3_vfs *pVfs;  struct Vdbe *pVdbe;  CollSeq *pDfltColl;  sqlite3_mutex *mutex;  Db *aDb;  int nDb;  u32 mDbFlags;  u64 flags;  i64 lastRowid;  i64 szMmap;  u32 nSchemaLock;  unsigned int openFlags;  int errCode;  int errMask;  int iSysErrno;  u32 dbOptFlags;  u8 enc;  u8 autoCommit;  u8 temp_store;  u8 mallocFailed;  u8 bBenignMalloc;  u8 dfltLockMode;  signed char nextAutovac;  u8 suppressErr;  u8 vtabOnConflict;  u8 isTransactionSavepoint;  u8 mTrace;  u8 noSharedCache;  u8 nSqlExec;  u8 eOpenState;  int nextPagesize;  i64 nChange;  i64 nTotalChange;  int aLimit[SQLITE_N_LIMIT];  int nMaxSorterMmap;  struct sqlite3InitInfo {  Pgno newTnum;  u8 iDb;  u8 busy;  unsigned orphanTrigger : 1;  unsigned imposterTable : 1;  unsigned reopenMemdb : 1;  const char **azInit;  } init;  int nVdbeActive;  int nVdbeRead;  int nVdbeWrite;  int nVdbeExec;  int nVDestroy;  int nExtension;  void **aExtension;  union {  void (*xLegacy)(void*,const char*);  int (*xV2)(u32,void*,void*,void*);  } trace;  void *pTraceArg;
#ifndef SQLITE_OMIT_DEPRECATED
 void (*xProfile)(void*,const char*,u64);  void *pProfileArg;
#endif
 void *pCommitArg;  int (*xCommitCallback)(void*);  void *pRollbackArg;  void (*xRollbackCallback)(void*);  void *pUpdateArg;  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);  void *pAutovacPagesArg;  void (*xAutovacDestr)(void*);  unsigned int (*xAutovacPages)(void*,const char*,u32,u32,u32);  Parse *pParse;
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 void *pPreUpdateArg;  void (*xPreUpdateCallback)(  void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64  );  PreUpdate *pPreUpdate;
#endif
#ifndef SQLITE_OMIT_WAL
 int (*xWalCallback)(void *, sqlite3 *, const char *, int);  void *pWalArg;
#endif
 void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);  void *pCollNeededArg;  sqlite3_value *pErr;  union {  volatile int isInterrupted;  double notUsed1;  } u1;  Lookaside lookaside;
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth;  void *pAuthArg;
#endif
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
 int (*xProgress)(void *);  void *pProgressArg;  unsigned nProgressOps;
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 int nVTrans;  Hash aModule;  VtabCtx *pVtabCtx;  VTable **aVTrans;  VTable *pDisconnect;
#endif
 Hash aFunc;  Hash aCollSeq;  BusyHandler busyHandler;  Db aDbStatic[2];  Savepoint *pSavepoint;  int nAnalysisLimit;  int busyTimeout;  int nSavepoint;  int nStatement;  i64 nDeferredCons;  i64 nDeferredImmCons;  int *pnBytesFreed;
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
 sqlite3 *pBlockingConnection;  sqlite3 *pUnlockConnection;  void *pUnlockArg;  void (*xUnlockNotify)(void **, int);  sqlite3 *pNextBlocked;
#endif
#ifdef SQLITE_USER_AUTHENTICATION
 sqlite3_userauth auth;
#endif
};
#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)
#define ENC(db) ((db)->enc)
#define HI(X) ((u64)(X)<<32)
#define SQLITE_WriteSchema 0x00000001
#define SQLITE_LegacyFileFmt 0x00000002
#define SQLITE_FullColNames  0x00000004
#define SQLITE_FullFSync 0x00000008
#define SQLITE_CkptFullFSync 0x00000010
#define SQLITE_CacheSpill  0x00000020
#define SQLITE_ShortColNames 0x00000040
#define SQLITE_TrustedSchema 0x00000080
#define SQLITE_NullCallback  0x00000100
#define SQLITE_IgnoreChecks  0x00000200
#define SQLITE_ReadUncommit  0x00000400
#define SQLITE_NoCkptOnClose 0x00000800
#define SQLITE_ReverseOrder  0x00001000
#define SQLITE_RecTriggers 0x00002000
#define SQLITE_ForeignKeys 0x00004000
#define SQLITE_AutoIndex 0x00008000
#define SQLITE_LoadExtension 0x00010000
#define SQLITE_LoadExtFunc 0x00020000
#define SQLITE_EnableTrigger 0x00040000
#define SQLITE_DeferFKs  0x00080000
#define SQLITE_QueryOnly 0x00100000
#define SQLITE_CellSizeCk  0x00200000
#define SQLITE_Fts3Tokenizer 0x00400000
#define SQLITE_EnableQPSG  0x00800000
#define SQLITE_TriggerEQP  0x01000000
#define SQLITE_ResetDatabase 0x02000000
#define SQLITE_LegacyAlter 0x04000000
#define SQLITE_NoSchemaError 0x08000000
#define SQLITE_Defensive 0x10000000
#define SQLITE_DqsDDL  0x20000000
#define SQLITE_DqsDML  0x40000000
#define SQLITE_EnableView  0x80000000
#define SQLITE_CountRows HI(0x00001)
#define SQLITE_CorruptRdOnly HI(0x00002)
#ifdef SQLITE_DEBUG
#define SQLITE_SqlTrace  HI(0x0100000)
#define SQLITE_VdbeListing HI(0x0200000)
#define SQLITE_VdbeTrace HI(0x0400000)
#define SQLITE_VdbeAddopTrace HI(0x0800000)
#define SQLITE_VdbeEQP HI(0x1000000)
#define SQLITE_ParserTrace HI(0x2000000)
#endif
#define DBFLAG_SchemaChange  0x0001
#define DBFLAG_PreferBuiltin 0x0002
#define DBFLAG_Vacuum  0x0004
#define DBFLAG_VacuumInto  0x0008
#define DBFLAG_SchemaKnownOk 0x0010
#define DBFLAG_InternalFunc  0x0020
#define DBFLAG_EncodingFixed 0x0040
#define SQLITE_QueryFlattener 0x00000001
#define SQLITE_WindowFunc  0x00000002
#define SQLITE_GroupByOrder  0x00000004
#define SQLITE_FactorOutConst 0x00000008
#define SQLITE_DistinctOpt 0x00000010
#define SQLITE_CoverIdxScan  0x00000020
#define SQLITE_OrderByIdxJoin 0x00000040
#define SQLITE_Transitive  0x00000080
#define SQLITE_OmitNoopJoin  0x00000100
#define SQLITE_CountOfView 0x00000200
#define SQLITE_CursorHints 0x00000400
#define SQLITE_Stat4 0x00000800
#define SQLITE_PushDown  0x00001000
#define SQLITE_SimplifyJoin  0x00002000
#define SQLITE_SkipScan  0x00004000
#define SQLITE_PropagateConst 0x00008000
#define SQLITE_MinMaxOpt 0x00010000
#define SQLITE_SeekScan  0x00020000
#define SQLITE_OmitOrderBy 0x00040000
#define SQLITE_AllOpts 0xffffffff
#define OptimizationDisabled(db, mask) (((db)->dbOptFlags&(mask))!=0)
#define OptimizationEnabled(db, mask)  (((db)->dbOptFlags&(mask))==0)
#define ConstFactorOk(P) ((P)->okConstFactor)
#define SQLITE_STATE_OPEN  0x76
#define SQLITE_STATE_CLOSED  0xce
#define SQLITE_STATE_SICK  0xba
#define SQLITE_STATE_BUSY  0x6d
#define SQLITE_STATE_ERROR 0xd5
#define SQLITE_STATE_ZOMBIE  0xa7
struct FuncDef {  i8 nArg;  u32 funcFlags;  void *pUserData;  FuncDef *pNext;  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**);  void (*xFinalize)(sqlite3_context*);  void (*xValue)(sqlite3_context*);  void (*xInverse)(sqlite3_context*,int,sqlite3_value**);  const char *zName;  union {  FuncDef *pHash;  FuncDestructor *pDestructor;  } u; }; struct FuncDestructor {  int nRef;  void (*xDestroy)(void *);  void *pUserData; };
#define SQLITE_FUNC_ENCMASK 0x0003
#define SQLITE_FUNC_LIKE  0x0004
#define SQLITE_FUNC_CASE  0x0008
#define SQLITE_FUNC_EPHEM 0x0010
#define SQLITE_FUNC_NEEDCOLL 0x0020
#define SQLITE_FUNC_LENGTH  0x0040
#define SQLITE_FUNC_TYPEOF  0x0080
#define SQLITE_FUNC_COUNT 0x0100
#define SQLITE_FUNC_UNLIKELY 0x0400
#define SQLITE_FUNC_CONSTANT 0x0800
#define SQLITE_FUNC_MINMAX  0x1000
#define SQLITE_FUNC_SLOCHNG 0x2000
#define SQLITE_FUNC_TEST  0x4000
#define SQLITE_FUNC_OFFSET  0x8000
#define SQLITE_FUNC_WINDOW  0x00010000
#define SQLITE_FUNC_INTERNAL 0x00040000
#define SQLITE_FUNC_DIRECT  0x00080000
#define SQLITE_FUNC_SUBTYPE 0x00100000
#define SQLITE_FUNC_UNSAFE  0x00200000
#define SQLITE_FUNC_INLINE  0x00400000
#define SQLITE_FUNC_BUILTIN 0x00800000
#define SQLITE_FUNC_ANYORDER 0x08000000
#define INLINEFUNC_coalesce  0
#define INLINEFUNC_implies_nonnull_row 1
#define INLINEFUNC_expr_implies_expr 2
#define INLINEFUNC_expr_compare  3
#define INLINEFUNC_affinity  4
#define INLINEFUNC_iif 5
#define INLINEFUNC_unlikely 99
#define FUNCTION(zName, nArg, iArg, bNC, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL),   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }

#define VFUNCTION(zName, nArg, iArg, bNC, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL),   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }

#define SFUNCTION(zName, nArg, iArg, bNC, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_DIRECTONLY|SQLITE_FUNC_UNSAFE,   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }

#define MFUNCTION(zName, nArg, xPtr, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_FUNC_CONSTANT|SQLITE_UTF8,   xPtr, 0, xFunc, 0, 0, 0, #zName, {0} }

#define INLINE_FUNC(zName, nArg, iArg, mFlags)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_UTF8|SQLITE_FUNC_INLINE|SQLITE_FUNC_CONSTANT|(mFlags),   SQLITE_INT_TO_PTR(iArg), 0, noopFunc, 0, 0, 0, #zName, {0} }

#define TEST_FUNC(zName, nArg, iArg, mFlags)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_UTF8|SQLITE_FUNC_INTERNAL|SQLITE_FUNC_TEST|   SQLITE_FUNC_INLINE|SQLITE_FUNC_CONSTANT|(mFlags),   SQLITE_INT_TO_PTR(iArg), 0, noopFunc, 0, 0, 0, #zName, {0} }

#define DFUNCTION(zName, nArg, iArg, bNC, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_FUNC_SLOCHNG|SQLITE_UTF8,   0, 0, xFunc, 0, 0, 0, #zName, {0} }

#define PURE_DATE(zName, nArg, iArg, bNC, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT,   (void*)&sqlite3Config, 0, xFunc, 0, 0, 0, #zName, {0} }

#define FUNCTION2(zName, nArg, iArg, bNC, xFunc, extraFlags)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags,  SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }

#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL),   pArg, 0, xFunc, 0, 0, 0, #zName, }

#define LIKEFUNC(zName, nArg, arg, flags)  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags,   (void *)arg, 0, likeFunc, 0, 0, 0, #zName, {0} }

#define WAGGREGATE(zName, nArg, arg, nc, xStep, xFinal, xValue, xInverse, f)  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|f,   SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,xInverse,#zName, {0}}

#define INTERNAL_FUNCTION(zName, nArg, xFunc)  {nArg, SQLITE_FUNC_BUILTIN|  SQLITE_FUNC_INTERNAL|SQLITE_UTF8|SQLITE_FUNC_CONSTANT,   0, 0, xFunc, 0, 0, 0, #zName, {0} }

struct Savepoint {  char *zName;  i64 nDeferredCons;  i64 nDeferredImmCons;  Savepoint *pNext; };
#define SAVEPOINT_BEGIN 0
#define SAVEPOINT_RELEASE 1
#define SAVEPOINT_ROLLBACK  2
struct Module {  const sqlite3_module *pModule;  const char *zName;  int nRefModule;  void *pAux;  void (*xDestroy)(void *);  Table *pEpoTab; }; struct Column {  char *zCnName;  unsigned notNull :4;  unsigned eCType :4;  char affinity;  u8 szEst;  u8 hName;  u16 iDflt;  u16 colFlags; };
#define COLTYPE_CUSTOM 0
#define COLTYPE_ANY  1
#define COLTYPE_BLOB 2
#define COLTYPE_INT  3
#define COLTYPE_INTEGER  4
#define COLTYPE_REAL 5
#define COLTYPE_TEXT 6
#define SQLITE_N_STDTYPE 6
#define COLFLAG_PRIMKEY  0x0001
#define COLFLAG_HIDDEN 0x0002
#define COLFLAG_HASTYPE  0x0004
#define COLFLAG_UNIQUE 0x0008
#define COLFLAG_SORTERREF 0x0010
#define COLFLAG_VIRTUAL  0x0020
#define COLFLAG_STORED 0x0040
#define COLFLAG_NOTAVAIL 0x0080
#define COLFLAG_BUSY 0x0100
#define COLFLAG_HASCOLL  0x0200
#define COLFLAG_GENERATED 0x0060
#define COLFLAG_NOINSERT 0x0062
struct CollSeq {  char *zName;  u8 enc;  void *pUser;  int (*xCmp)(void*,int, const void*, int, const void*);  void (*xDel)(void*); };
#define SQLITE_SO_ASC  0
#define SQLITE_SO_DESC 1
#define SQLITE_SO_UNDEFINED -1
#define SQLITE_AFF_NONE  0x40
#define SQLITE_AFF_BLOB  0x41
#define SQLITE_AFF_TEXT  0x42
#define SQLITE_AFF_NUMERIC 0x43
#define SQLITE_AFF_INTEGER 0x44
#define SQLITE_AFF_REAL  0x45
#define sqlite3IsNumericAffinity(X) ((X)>=SQLITE_AFF_NUMERIC)
#define SQLITE_AFF_MASK  0x47
#define SQLITE_JUMPIFNULL  0x10
#define SQLITE_NULLEQ  0x80
#define SQLITE_NOTNULL 0x90
struct VTable {  sqlite3 *db;  Module *pMod;  sqlite3_vtab *pVtab;  int nRef;  u8 bConstraint;  u8 eVtabRisk;  int iSavepoint;  VTable *pNext; };
#define SQLITE_VTABRISK_Low 0
#define SQLITE_VTABRISK_Normal  1
#define SQLITE_VTABRISK_High  2
struct Table {  char *zName;  Column *aCol;  Index *pIndex;  char *zColAff;  ExprList *pCheck;  Pgno tnum;  u32 nTabRef;  u32 tabFlags;  i16 iPKey;  i16 nCol;  i16 nNVCol;  LogEst nRowLogEst;  LogEst szTabRow;
#ifdef SQLITE_ENABLE_COSTMULT
 LogEst costMult;
#endif
 u8 keyConf;  u8 eTabType;  union {  struct {  int addColOffset;  FKey *pFKey;  ExprList *pDfltList;  } tab;  struct {  Select *pSelect;  } view;  struct {  int nArg;  char **azArg;  VTable *p;  } vtab;  } u;  Trigger *pTrigger;  Schema *pSchema; };
#define TF_Readonly  0x00000001
#define TF_HasHidden 0x00000002
#define TF_HasPrimaryKey 0x00000004
#define TF_Autoincrement 0x00000008
#define TF_HasStat1  0x00000010
#define TF_HasVirtual  0x00000020
#define TF_HasStored 0x00000040
#define TF_HasGenerated  0x00000060
#define TF_WithoutRowid  0x00000080
#define TF_StatsUsed 0x00000100
#define TF_NoVisibleRowid 0x00000200
#define TF_OOOHidden 0x00000400
#define TF_HasNotNull  0x00000800
#define TF_Shadow  0x00001000
#define TF_HasStat4  0x00002000
#define TF_Ephemeral 0x00004000
#define TF_Eponymous 0x00008000
#define TF_Strict  0x00010000
#define TABTYP_NORM 0
#define TABTYP_VTAB 1
#define TABTYP_VIEW 2
#define IsView(X)  ((X)->eTabType==TABTYP_VIEW)
#define IsOrdinaryTable(X) ((X)->eTabType==TABTYP_NORM)
#ifndef SQLITE_OMIT_VIRTUALTABLE
# define IsVirtual(X) ((X)->eTabType==TABTYP_VTAB)
# define ExprIsVtab(X)  ((X)->op==TK_COLUMN && (X)->y.pTab!=0 && (X)->y.pTab->eTabType==TABTYP_VTAB)

#else
# define IsVirtual(X) 0
# define ExprIsVtab(X)  0
#endif
#if defined(SQLITE_ENABLE_HIDDEN_COLUMNS)
# define IsHiddenColumn(X)  (((X)->colFlags & COLFLAG_HIDDEN)!=0)
# define IsOrdinaryHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)
#elif !defined(SQLITE_OMIT_VIRTUALTABLE)
# define IsHiddenColumn(X)  (((X)->colFlags & COLFLAG_HIDDEN)!=0)
# define IsOrdinaryHiddenColumn(X) 0
#else
# define IsHiddenColumn(X)  0
# define IsOrdinaryHiddenColumn(X) 0
#endif
#define HasRowid(X)  (((X)->tabFlags & TF_WithoutRowid)==0)
#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0)
struct FKey {  Table *pFrom;  FKey *pNextFrom;  char *zTo;  FKey *pNextTo;  FKey *pPrevTo;  int nCol;  u8 isDeferred;  u8 aAction[2];  Trigger *apTrigger[2];  struct sColMap {  int iFrom;  char *zCol;  } aCol[1]; };
#define OE_None  0
#define OE_Rollback 1
#define OE_Abort 2
#define OE_Fail  3
#define OE_Ignore  4
#define OE_Replace 5
#define OE_Update  6
#define OE_Restrict 7
#define OE_SetNull 8
#define OE_SetDflt 9
#define OE_Cascade 10
#define OE_Default 11
struct KeyInfo {  u32 nRef;  u8 enc;  u16 nKeyField;  u16 nAllField;  sqlite3 *db;  u8 *aSortFlags;  CollSeq *aColl[1]; };
#define KEYINFO_ORDER_DESC 0x01
#define KEYINFO_ORDER_BIGNULL 0x02
struct UnpackedRecord {  KeyInfo *pKeyInfo;  Mem *aMem;  u16 nField;  i8 default_rc;  u8 errCode;  i8 r1;  i8 r2;  u8 eqSeen; }; struct Index {  char *zName;  i16 *aiColumn;  LogEst *aiRowLogEst;  Table *pTable;  char *zColAff;  Index *pNext;  Schema *pSchema;  u8 *aSortOrder;  const char **azColl;  Expr *pPartIdxWhere;  ExprList *aColExpr;  Pgno tnum;  LogEst szIdxRow;  u16 nKeyCol;  u16 nColumn;  u8 onError;  unsigned idxType:2;  unsigned bUnordered:1;  unsigned uniqNotNull:1;  unsigned isResized:1;  unsigned isCovering:1;  unsigned noSkipScan:1;  unsigned hasStat1:1;  unsigned bNoQuery:1;  unsigned bAscKeyBug:1;  unsigned bHasVCol:1;
#ifdef SQLITE_ENABLE_STAT4
 int nSample;  int nSampleCol;  tRowcnt *aAvgEq;  IndexSample *aSample;  tRowcnt *aiRowEst;  tRowcnt nRowEst0;
#endif
 Bitmask colNotIdxed; };
#define SQLITE_IDXTYPE_APPDEF 0
#define SQLITE_IDXTYPE_UNIQUE 1
#define SQLITE_IDXTYPE_PRIMARYKEY 2
#define SQLITE_IDXTYPE_IPK  3
#define IsPrimaryKeyIndex(X) ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY)
#define IsUniqueIndex(X) ((X)->onError!=OE_None)
#define XN_ROWID  (-1)
#define XN_EXPR (-2)
struct IndexSample {  void *p;  int n;  tRowcnt *anEq;  tRowcnt *anLt;  tRowcnt *anDLt; };
#define SQLITE_TOKEN_QUOTED 0x1
#define SQLITE_TOKEN_KEYWORD  0x2
struct Token {  const char *z;  unsigned int n; }; struct AggInfo {  u8 directMode;  u8 useSortingIdx;  int sortingIdx;  int sortingIdxPTab;  int nSortingColumn;  int mnReg, mxReg;  ExprList *pGroupBy;  struct AggInfo_col {  Table *pTab;  Expr *pCExpr;  int iTable;  int iMem;  i16 iColumn;  i16 iSorterColumn;  } *aCol;  int nColumn;  int nAccumulator;  struct AggInfo_func {  Expr *pFExpr;  FuncDef *pFunc;  int iMem;  int iDistinct;  int iDistAddr;  } *aFunc;  int nFunc;  u32 selId; };
#if SQLITE_MAX_VARIABLE_NUMBER<32767
typedef i16 ynVar;
#else
typedef int ynVar;
#endif
struct Expr {  u8 op;  char affExpr;  u8 op2;
#ifdef SQLITE_DEBUG
 u8 vvaFlags;
#endif
 u32 flags;  union {  char *zToken;  int iValue;  } u;  Expr *pLeft;  Expr *pRight;  union {  ExprList *pList;  Select *pSelect;  } x;
#if SQLITE_MAX_EXPR_DEPTH>0
 int nHeight;
#endif
 int iTable;  ynVar iColumn;  i16 iAgg;  int iRightJoinTable;  AggInfo *pAggInfo;  union {  Table *pTab;  Window *pWin;  struct {  int iAddr;  int regReturn;  } sub;  } y; };
#define EP_FromJoin  0x000001
#define EP_Distinct  0x000002
#define EP_HasFunc 0x000004
#define EP_FixedCol  0x000008
#define EP_Agg 0x000010
#define EP_VarSelect 0x000020
#define EP_DblQuoted 0x000040
#define EP_InfixFunc 0x000080
#define EP_Collate 0x000100
#define EP_Commuted  0x000200
#define EP_IntValue  0x000400
#define EP_xIsSelect 0x000800
#define EP_Skip  0x001000
#define EP_Reduced 0x002000
#define EP_TokenOnly 0x004000
#define EP_Win 0x008000
#define EP_MemToken  0x010000
#define EP_IfNullRow 0x020000
#define EP_Unlikely  0x040000
#define EP_ConstFunc 0x080000
#define EP_CanBeNull 0x100000
#define EP_Subquery  0x200000
#define EP_Leaf  0x800000
#define EP_WinFunc  0x1000000
#define EP_Subrtn 0x2000000
#define EP_Quoted 0x4000000
#define EP_Static 0x8000000
#define EP_IsTrue  0x10000000
#define EP_IsFalse 0x20000000
#define EP_FromDDL 0x40000000
#define EP_Propagate (EP_Collate|EP_Subquery|EP_HasFunc)
#define ExprHasProperty(E,P)  (((E)->flags&(P))!=0)
#define ExprHasAllProperty(E,P) (((E)->flags&(P))==(P))
#define ExprSetProperty(E,P)  (E)->flags|=(P)
#define ExprClearProperty(E,P)  (E)->flags&=~(P)
#define ExprAlwaysTrue(E)  (((E)->flags&(EP_FromJoin|EP_IsTrue))==EP_IsTrue)
#define ExprAlwaysFalse(E) (((E)->flags&(EP_FromJoin|EP_IsFalse))==EP_IsFalse)
#define ExprUseUToken(E) (((E)->flags&EP_IntValue)==0)
#define ExprUseUValue(E) (((E)->flags&EP_IntValue)!=0)
#define ExprUseXList(E)  (((E)->flags&EP_xIsSelect)==0)
#define ExprUseXSelect(E)  (((E)->flags&EP_xIsSelect)!=0)
#define ExprUseYTab(E) (((E)->flags&(EP_WinFunc|EP_Subrtn))==0)
#define ExprUseYWin(E) (((E)->flags&EP_WinFunc)!=0)
#define ExprUseYSub(E) (((E)->flags&EP_Subrtn)!=0)
#define EP_NoReduce  0x01
#define EP_Immutable 0x02
#ifdef SQLITE_DEBUG
# define ExprSetVVAProperty(E,P)  (E)->vvaFlags|=(P)
# define ExprHasVVAProperty(E,P)  (((E)->vvaFlags&(P))!=0)
# define ExprClearVVAProperties(E) (E)->vvaFlags = 0
#else
# define ExprSetVVAProperty(E,P)
# define ExprHasVVAProperty(E,P)  0
# define ExprClearVVAProperties(E)
#endif
#define EXPR_FULLSIZE  sizeof(Expr)
#define EXPR_REDUCEDSIZE offsetof(Expr,iTable)
#define EXPR_TOKENONLYSIZE offsetof(Expr,pLeft)
#define EXPRDUP_REDUCE  0x0001
#ifdef SQLITE_OMIT_WINDOWFUNC
# define IsWindowFunc(p) 0
#else
# define IsWindowFunc(p) (  ExprHasProperty((p), EP_WinFunc) && p->y.pWin->eFrmType!=TK_FILTER  )

#endif
struct ExprList {  int nExpr;  int nAlloc;  struct ExprList_item {  Expr *pExpr;  char *zEName;  u8 sortFlags;  unsigned eEName :2;  unsigned done :1;  unsigned reusable :1;  unsigned bSorterRef :1;  unsigned bNulls: 1;  union {  struct {  u16 iOrderByCol;  u16 iAlias;  } x;  int iConstExprReg;  } u;  } a[1]; };
#define ENAME_NAME 0
#define ENAME_SPAN 1
#define ENAME_TAB  2
struct IdList {  struct IdList_item {  char *zName;  int idx;  } *a;  int nId; }; struct SrcItem {  Schema *pSchema;  char *zDatabase;  char *zName;  char *zAlias;  Table *pTab;  Select *pSelect;  int addrFillSub;  int regReturn;  int regResult;  struct {  u8 jointype;  unsigned notIndexed :1;  unsigned isIndexedBy :1;  unsigned isTabFunc :1;  unsigned isCorrelated :1;  unsigned viaCoroutine :1;  unsigned isRecursive :1;  unsigned fromDDL :1;  unsigned isCte :1;  unsigned notCte :1;  } fg;  int iCursor;  Expr *pOn;  IdList *pUsing;  Bitmask colUsed;  union {  char *zIndexedBy;  ExprList *pFuncArg;  } u1;  union {  Index *pIBIndex;  CteUse *pCteUse;  } u2; }; struct SrcList {  int nSrc;  u32 nAlloc;  SrcItem a[1]; };
#define JT_INNER  0x0001
#define JT_CROSS  0x0002
#define JT_NATURAL  0x0004
#define JT_LEFT 0x0008
#define JT_RIGHT  0x0010
#define JT_OUTER  0x0020
#define JT_ERROR  0x0040
#define WHERE_ORDERBY_NORMAL  0x0000
#define WHERE_ORDERBY_MIN 0x0001
#define WHERE_ORDERBY_MAX 0x0002
#define WHERE_ONEPASS_DESIRED 0x0004
#define WHERE_ONEPASS_MULTIROW 0x0008
#define WHERE_DUPLICATES_OK 0x0010
#define WHERE_OR_SUBCLAUSE  0x0020
#define WHERE_GROUPBY 0x0040
#define WHERE_DISTINCTBY  0x0080
#define WHERE_WANT_DISTINCT 0x0100
#define WHERE_SORTBYGROUP 0x0200
#define WHERE_AGG_DISTINCT  0x0400
#define WHERE_ORDERBY_LIMIT 0x0800
#define WHERE_USE_LIMIT 0x4000
#define WHERE_DISTINCT_NOOP 0
#define WHERE_DISTINCT_UNIQUE 1
#define WHERE_DISTINCT_ORDERED  2
#define WHERE_DISTINCT_UNORDERED 3
struct NameContext {  Parse *pParse;  SrcList *pSrcList;  union {  ExprList *pEList;  AggInfo *pAggInfo;  Upsert *pUpsert;  int iBaseReg;  } uNC;  NameContext *pNext;  int nRef;  int nNcErr;  int ncFlags;  Select *pWinSelect; };
#define NC_AllowAgg 0x000001
#define NC_PartIdx  0x000002
#define NC_IsCheck  0x000004
#define NC_GenCol 0x000008
#define NC_HasAgg 0x000010
#define NC_IdxExpr  0x000020
#define NC_SelfRef  0x00002e
#define NC_VarSelect 0x000040
#define NC_UEList 0x000080
#define NC_UAggInfo 0x000100
#define NC_UUpsert  0x000200
#define NC_UBaseReg 0x000400
#define NC_MinMaxAgg 0x001000
#define NC_Complex  0x002000
#define NC_AllowWin 0x004000
#define NC_HasWin 0x008000
#define NC_IsDDL  0x010000
#define NC_InAggFunc 0x020000
#define NC_FromDDL  0x040000
#define NC_NoSelect 0x080000
#define NC_OrderAgg 0x8000000
struct Upsert {  ExprList *pUpsertTarget;  Expr *pUpsertTargetWhere;  ExprList *pUpsertSet;  Expr *pUpsertWhere;  Upsert *pNextUpsert;  u8 isDoUpdate;  void *pToFree;  Index *pUpsertIdx;  SrcList *pUpsertSrc;  int regData;  int iDataCur;  int iIdxCur; }; struct Select {  u8 op;  LogEst nSelectRow;  u32 selFlags;  int iLimit, iOffset;  u32 selId;  int addrOpenEphm[2];  ExprList *pEList;  SrcList *pSrc;  Expr *pWhere;  ExprList *pGroupBy;  Expr *pHaving;  ExprList *pOrderBy;  Select *pPrior;  Select *pNext;  Expr *pLimit;  With *pWith;
#ifndef SQLITE_OMIT_WINDOWFUNC
 Window *pWin;  Window *pWinDefn;
#endif
};
#define SF_Distinct 0x0000001
#define SF_All  0x0000002
#define SF_Resolved 0x0000004
#define SF_Aggregate  0x0000008
#define SF_HasAgg 0x0000010
#define SF_UsesEphemeral 0x0000020
#define SF_Expanded 0x0000040
#define SF_HasTypeInfo  0x0000080
#define SF_Compound 0x0000100
#define SF_Values 0x0000200
#define SF_MultiValue 0x0000400
#define SF_NestedFrom 0x0000800
#define SF_MinMaxAgg  0x0001000
#define SF_Recursive  0x0002000
#define SF_FixedLimit 0x0004000
#define SF_MaybeConvert 0x0008000
#define SF_Converted  0x0010000
#define SF_IncludeHidden 0x0020000
#define SF_ComplexResult 0x0040000
#define SF_WhereBegin 0x0080000
#define SF_WinRewrite 0x0100000
#define SF_View 0x0200000
#define SF_NoopOrderBy  0x0400000
#define SF_UFSrcCheck 0x0800000
#define SF_PushDown 0x1000000
#define SF_MultiPart  0x2000000
#define SF_CopyCte  0x4000000
#define SF_OrderByReqd  0x8000000
#define SRT_Union 1
#define SRT_Except  2
#define SRT_Exists  3
#define SRT_Discard 4
#define SRT_DistFifo  5
#define SRT_DistQueue 6
#define IgnorableDistinct(X) ((X->eDest)<=SRT_DistQueue)
#define SRT_Queue 7
#define SRT_Fifo  8
#define IgnorableOrderby(X) ((X->eDest)<=SRT_Fifo)
#define SRT_Output  9
#define SRT_Mem  10
#define SRT_Set  11
#define SRT_EphemTab 12
#define SRT_Coroutine  13
#define SRT_Table  14
#define SRT_Upfrom 15
struct SelectDest {  u8 eDest;  int iSDParm;  int iSDParm2;  int iSdst;  int nSdst;  char *zAffSdst;  ExprList *pOrderBy; }; struct AutoincInfo {  AutoincInfo *pNext;  Table *pTab;  int iDb;  int regCtr; }; struct TriggerPrg {  Trigger *pTrigger;  TriggerPrg *pNext;  SubProgram *pProgram;  int orconf;  u32 aColmask[2]; };
#if SQLITE_MAX_ATTACHED>30
 typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)/8];
# define DbMaskTest(M,I) (((M)[(I)/8]&(1<<((I)&7)))!=0)
# define DbMaskZero(M) memset((M),0,sizeof(M))
# define DbMaskSet(M,I)  (M)[(I)/8]|=(1<<((I)&7))
# define DbMaskAllZero(M)  sqlite3DbMaskAllZero(M)
# define DbMaskNonZero(M)  (sqlite3DbMaskAllZero(M)==0)
#else
 typedef unsigned int yDbMask;
# define DbMaskTest(M,I) (((M)&(((yDbMask)1)<<(I)))!=0)
# define DbMaskZero(M) (M)=0
# define DbMaskSet(M,I)  (M)|=(((yDbMask)1)<<(I))
# define DbMaskAllZero(M)  (M)==0
# define DbMaskNonZero(M)  (M)!=0
#endif
struct ParseCleanup {  ParseCleanup *pNext;  void *pPtr;  void (*xCleanup)(sqlite3*,void*); }; struct Parse {  sqlite3 *db;  char *zErrMsg;  Vdbe *pVdbe;  int rc;  u8 colNamesSet;  u8 checkSchema;  u8 nested;  u8 nTempReg;  u8 isMultiWrite;  u8 mayAbort;  u8 hasCompound;  u8 okConstFactor;  u8 disableLookaside;  u8 disableVtab;
#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
 u8 earlyCleanup;
#endif
 int nRangeReg;  int iRangeReg;  int nErr;  int nTab;  int nMem;  int szOpAlloc;  int iSelfTab;  int nLabel;  int nLabelAlloc;  int *aLabel;  ExprList *pConstExpr;  Token constraintName;  yDbMask writeMask;  yDbMask cookieMask;  int regRowid;  int regRoot;  int nMaxArg;  int nSelect;
#ifndef SQLITE_OMIT_SHARED_CACHE
 int nTableLock;  TableLock *aTableLock;
#endif
 AutoincInfo *pAinc;  Parse *pToplevel;  Table *pTriggerTab;  TriggerPrg *pTriggerPrg;  ParseCleanup *pCleanup;  union {  int addrCrTab;  Returning *pReturning;  } u1;  u32 nQueryLoop;  u32 oldmask;  u32 newmask;  u8 eTriggerOp;  u8 bReturning;  u8 eOrconf;  u8 disableTriggers;  int aTempReg[8];  Token sNameToken;  Token sLastToken;  ynVar nVar;  u8 iPkSortOrder;  u8 explain;  u8 eParseMode;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 int nVtabLock;
#endif
 int nHeight;
#ifndef SQLITE_OMIT_EXPLAIN
 int addrExplain;
#endif
 VList *pVList;  Vdbe *pReprepare;  const char *zTail;  Table *pNewTable;  Index *pNewIndex;  Trigger *pNewTrigger;  const char *zAuthContext;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 Token sArg;  Table **apVtabLock;
#endif
 With *pWith;
#ifndef SQLITE_OMIT_ALTERTABLE
 RenameToken *pRename;
#endif
};
#define PARSE_MODE_NORMAL 0
#define PARSE_MODE_DECLARE_VTAB 1
#define PARSE_MODE_RENAME 2
#define PARSE_MODE_UNMAP  3
#define PARSE_HDR_SZ offsetof(Parse,aTempReg)
#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)
#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ)
#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)
#ifdef SQLITE_OMIT_VIRTUALTABLE
 #define IN_DECLARE_VTAB 0
#else
 #define IN_DECLARE_VTAB (pParse->eParseMode==PARSE_MODE_DECLARE_VTAB)
#endif
#if defined(SQLITE_OMIT_ALTERTABLE)
 #define IN_RENAME_OBJECT 0
#else
 #define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME)
#endif
#if defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_OMIT_ALTERTABLE)
 #define IN_SPECIAL_PARSE 0
#else
 #define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)
#endif
struct AuthContext {  const char *zAuthContext;  Parse *pParse; };
#define OPFLAG_NCHANGE  0x01
#define OPFLAG_NOCHNG 0x01
#define OPFLAG_EPHEM  0x01
#define OPFLAG_LASTROWID  0x20
#define OPFLAG_ISUPDATE 0x04
#define OPFLAG_APPEND 0x08
#define OPFLAG_USESEEKRESULT 0x10
#define OPFLAG_ISNOOP 0x40
#define OPFLAG_LENGTHARG  0x40
#define OPFLAG_TYPEOFARG  0x80
#define OPFLAG_BULKCSR  0x01
#define OPFLAG_SEEKEQ 0x02
#define OPFLAG_FORDELETE  0x08
#define OPFLAG_P2ISREG  0x10
#define OPFLAG_PERMUTE  0x01
#define OPFLAG_SAVEPOSITION 0x02
#define OPFLAG_AUXDELETE  0x04
#define OPFLAG_NOCHNG_MAGIC 0x6d
#define OPFLAG_PREFORMAT  0x80
struct Trigger {  char *zName;  char *table;  u8 op;  u8 tr_tm;  u8 bReturning;  Expr *pWhen;  IdList *pColumns;    Schema *pSchema;  Schema *pTabSchema;  TriggerStep *step_list;  Trigger *pNext; };
#define TRIGGER_BEFORE 1
#define TRIGGER_AFTER  2
struct TriggerStep {  u8 op;  u8 orconf;  Trigger *pTrig;  Select *pSelect;  char *zTarget;  SrcList *pFrom;  Expr *pWhere;  ExprList *pExprList;  IdList *pIdList;  Upsert *pUpsert;  char *zSpan;  TriggerStep *pNext;  TriggerStep *pLast; }; struct Returning {  Parse *pParse;  ExprList *pReturnEL;  Trigger retTrig;  TriggerStep retTStep;  int iRetCur;  int nRetCol;  int iRetReg; }; struct sqlite3_str {  sqlite3 *db;  char *zText;  u32 nAlloc;  u32 mxAlloc;  u32 nChar;  u8  accError;  u8  printfFlags; };
#define SQLITE_PRINTF_INTERNAL 0x01
#define SQLITE_PRINTF_SQLFUNC 0x02
#define SQLITE_PRINTF_MALLOCED 0x04
#define isMalloced(X) (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)
typedef struct {  sqlite3 *db;  char **pzErrMsg;  int iDb;  int rc;  u32 mInitFlags;  u32 nInitRow;  Pgno mxPage; } InitData;
#define INITFLAG_AlterMask  0x0003
#define INITFLAG_AlterRename  0x0001
#define INITFLAG_AlterDrop  0x0002
#define INITFLAG_AlterAdd 0x0003
#define SQLITE_NTUNE 6
#ifdef SQLITE_DEBUG
# define Tuning(X) (sqlite3Config.aTune[(X)-1])
#else
# define Tuning(X) 0
#endif
struct Sqlite3Config {  int bMemstat;  u8 bCoreMutex;  u8 bFullMutex;  u8 bOpenUri;  u8 bUseCis;  u8 bSmallMalloc;  u8 bExtraSchemaChecks;  int mxStrlen;  int neverCorrupt;  int szLookaside;  int nLookaside;  int nStmtSpill;  sqlite3_mem_methods m;  sqlite3_mutex_methods mutex;  sqlite3_pcache_methods2 pcache2;  void *pHeap;  int nHeap;  int mnReq, mxReq;  sqlite3_int64 szMmap;  sqlite3_int64 mxMmap;  void *pPage;  int szPage;  int nPage;  int mxParserStack;  int sharedCacheEnabled;  u32 szPma;  int isInit;  int inProgress;  int isMutexInit;  int isMallocInit;  int isPCacheInit;  int nRefInitMutex;  sqlite3_mutex *pInitMutex;  void (*xLog)(void*,int,const char*);  void *pLogArg;
#ifdef SQLITE_ENABLE_SQLLOG
 void(*xSqllog)(void*,sqlite3*,const char*, int);  void *pSqllogArg;
#endif
#ifdef SQLITE_VDBE_COVERAGE
 void (*xVdbeBranch)(void*,unsigned iSrcLine,u8 eThis,u8 eMx);  void *pVdbeBranchArg;
#endif
#ifndef SQLITE_OMIT_DESERIALIZE
 sqlite3_int64 mxMemdbSize;
#endif
#ifndef SQLITE_UNTESTABLE
 int (*xTestCallback)(int);
#endif
 int bLocaltimeFault;  int iOnceResetThreshold;  u32 szSorterRef;  unsigned int iPrngSeed;
#ifdef SQLITE_DEBUG
 sqlite3_int64 aTune[SQLITE_NTUNE];
#endif
};
#define CORRUPT_DB (sqlite3Config.neverCorrupt==0)
struct Walker {  Parse *pParse;  int (*xExprCallback)(Walker*, Expr*);  int (*xSelectCallback)(Walker*,Select*);  void (*xSelectCallback2)(Walker*,Select*);  int walkerDepth;  u16 eCode;  union {  NameContext *pNC;  int n;  int iCur;  SrcList *pSrcList;  struct CCurHint *pCCurHint;  struct RefSrcList *pRefSrcList;  int *aiCol;  struct IdxCover *pIdxCover;  struct IdxExprTrans *pIdxTrans;  ExprList *pGroupBy;  Select *pSelect;  struct WindowRewrite *pRewrite;  struct WhereConst *pConst;  struct RenameCtx *pRename;  struct Table *pTab;  SrcItem *pSrcItem;  DbFixer *pFix;  } u; }; struct DbFixer {  Parse *pParse;  Walker w;  Schema *pSchema;  u8 bTemp;  const char *zDb;  const char *zType;  const Token *pName; }; SQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*); SQLITE_PRIVATE int sqlite3WalkExprList(Walker*, ExprList*); SQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*); SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*); SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*); SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker*, Expr*); SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker*, Select*); SQLITE_PRIVATE int sqlite3SelectWalkFail(Walker*, Select*); SQLITE_PRIVATE int sqlite3WalkerDepthIncrease(Walker*,Select*); SQLITE_PRIVATE void sqlite3WalkerDepthDecrease(Walker*,Select*); SQLITE_PRIVATE void sqlite3WalkWinDefnDummyCallback(Walker*,Select*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker*, Select*);
#endif
#ifndef SQLITE_OMIT_CTE
SQLITE_PRIVATE void sqlite3SelectPopWith(Walker*, Select*);
#else
# define sqlite3SelectPopWith 0
#endif
#define WRC_Continue 0
#define WRC_Prune  1
#define WRC_Abort  2
struct Cte {  char *zName;  ExprList *pCols;  Select *pSelect;  const char *zCteErr;  CteUse *pUse;  u8 eM10d; };
#define M10d_Yes  0
#define M10d_Any  1
#define M10d_No 2
struct With {  int nCte;  int bView;  With *pOuter;  Cte a[1]; }; struct CteUse {  int nUse;  int addrM9e;  int regRtn;  int iCur;  LogEst nRowEst;  u8 eM10d; };
#ifdef SQLITE_DEBUG
struct TreeView {  int iLevel;  u8 bLine[100]; };
#endif
struct Window {  char *zName;  char *zBase;  ExprList *pPartition;  ExprList *pOrderBy;  u8 eFrmType;  u8 eStart;  u8 eEnd;  u8 bImplicitFrame;  u8 eExclude;  Expr *pStart;  Expr *pEnd;  Window **ppThis;  Window *pNextWin;  Expr *pFilter;  FuncDef *pFunc;  int iEphCsr;  int regAccum;  int regResult;  int csrApp;  int regApp;  int regPart;  Expr *pOwner;  int nBufferCol;  int iArgCol;  int regOne;  int regStartRowid;  int regEndRowid;  u8 bExprArgs; };
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE void sqlite3WindowDelete(sqlite3*, Window*); SQLITE_PRIVATE void sqlite3WindowUnlinkFromSelect(Window*); SQLITE_PRIVATE void sqlite3WindowListDelete(sqlite3 *db, Window *p); SQLITE_PRIVATE Window *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8); SQLITE_PRIVATE void sqlite3WindowAttach(Parse*, Expr*, Window*); SQLITE_PRIVATE void sqlite3WindowLink(Select *pSel, Window *pWin); SQLITE_PRIVATE int sqlite3WindowCompare(const Parse*, const Window*, const Window*, int); SQLITE_PRIVATE void sqlite3WindowCodeInit(Parse*, Select*); SQLITE_PRIVATE void sqlite3WindowCodeStep(Parse*, Select*, WhereInfo*, int, int); SQLITE_PRIVATE int sqlite3WindowRewrite(Parse*, Select*); SQLITE_PRIVATE void sqlite3WindowUpdate(Parse*, Window*, Window*, FuncDef*); SQLITE_PRIVATE Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p); SQLITE_PRIVATE Window *sqlite3WindowListDup(sqlite3 *db, Window *p); SQLITE_PRIVATE void sqlite3WindowFunctions(void); SQLITE_PRIVATE void sqlite3WindowChain(Parse*, Window*, Window*); SQLITE_PRIVATE Window *sqlite3WindowAssemble(Parse*, Window*, ExprList*, ExprList*, Token*);
#else
# define sqlite3WindowDelete(a,b)
# define sqlite3WindowFunctions()
# define sqlite3WindowAttach(a,b,c)
#endif
#define SQLITE_SKIP_UTF8(zIn) {  if( (*(zIn++))>=0xc0 ){  while( (*zIn & 0xc0)==0x80 ){ zIn++; }   } }

SQLITE_PRIVATE int sqlite3ReportError(int iErr, int lineno, const char *zType); SQLITE_PRIVATE int sqlite3CorruptError(int); SQLITE_PRIVATE int sqlite3MisuseError(int); SQLITE_PRIVATE int sqlite3CantopenError(int);
#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)
#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)
#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  int sqlite3NomemError(int); SQLITE_PRIVATE  int sqlite3IoerrnomemError(int);
# define SQLITE_NOMEM_BKPT sqlite3NomemError(__LINE__)
# define SQLITE_IOERR_NOMEM_BKPT sqlite3IoerrnomemError(__LINE__)
#else
# define SQLITE_NOMEM_BKPT SQLITE_NOMEM
# define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM
#endif
#if defined(SQLITE_DEBUG) || defined(SQLITE_ENABLE_CORRUPT_PGNO)
SQLITE_PRIVATE  int sqlite3CorruptPgnoError(int,Pgno);
# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptPgnoError(__LINE__,(P))
#else
# define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)
#endif
#if defined(SQLITE_OMIT_VIRTUALTABLE)
# undef SQLITE_ENABLE_FTS3
# undef SQLITE_ENABLE_FTS4
#endif
#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)
# define SQLITE_ENABLE_FTS3 1
#endif
#if !defined(SQLITE_ASCII) ||  (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))

# include <ctype.h>
#endif
#ifdef SQLITE_ASCII
# define sqlite3Toupper(x) ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))
# define sqlite3Isspace(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x01)
# define sqlite3Isalnum(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x06)
# define sqlite3Isalpha(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x02)
# define sqlite3Isdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x04)
# define sqlite3Isxdigit(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x08)
# define sqlite3Tolower(x)  (sqlite3UpperToLower[(unsigned char)(x)])
# define sqlite3Isquote(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x80)
#else
# define sqlite3Toupper(x)  toupper((unsigned char)(x))
# define sqlite3Isspace(x)  isspace((unsigned char)(x))
# define sqlite3Isalnum(x)  isalnum((unsigned char)(x))
# define sqlite3Isalpha(x)  isalpha((unsigned char)(x))
# define sqlite3Isdigit(x)  isdigit((unsigned char)(x))
# define sqlite3Isxdigit(x) isxdigit((unsigned char)(x))
# define sqlite3Tolower(x)  tolower((unsigned char)(x))
# define sqlite3Isquote(x)  ((x)=='"'||(x)=='\''||(x)=='['||(x)=='`')
#endif
SQLITE_PRIVATE int sqlite3IsIdChar(u8); SQLITE_PRIVATE int sqlite3StrICmp(const char*,const char*); SQLITE_PRIVATE int sqlite3Strlen30(const char*);
#define sqlite3Strlen30NN(C) (strlen(C)&0x3fffffff)
SQLITE_PRIVATE char *sqlite3ColumnType(Column*,char*);
#define sqlite3StrNICmp sqlite3_strnicmp
SQLITE_PRIVATE int sqlite3MallocInit(void); SQLITE_PRIVATE void sqlite3MallocEnd(void); SQLITE_PRIVATE void *sqlite3Malloc(u64); SQLITE_PRIVATE void *sqlite3MallocZero(u64); SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, u64); SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, u64); SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3*, u64); SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*,const char*); SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, u64); SQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3*,const char*,const char*); SQLITE_PRIVATE void *sqlite3Realloc(void*, u64); SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64); SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, u64); SQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*); SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3*, void*); SQLITE_PRIVATE int sqlite3MallocSize(const void*); SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, const void*); SQLITE_PRIVATE void *sqlite3PageMalloc(int); SQLITE_PRIVATE void sqlite3PageFree(void*); SQLITE_PRIVATE void sqlite3MemSetDefault(void);
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));
#endif
SQLITE_PRIVATE int sqlite3HeapNearlyFull(void);
#ifdef SQLITE_USE_ALLOCA
# define sqlite3StackAllocRaw(D,N)  alloca(N)
# define sqlite3StackAllocZero(D,N) memset(alloca(N), 0, N)
# define sqlite3StackFree(D,P)
#else
# define sqlite3StackAllocRaw(D,N)  sqlite3DbMallocRaw(D,N)
# define sqlite3StackAllocZero(D,N) sqlite3DbMallocZero(D,N)
# define sqlite3StackFree(D,P)  sqlite3DbFree(D,P)
#endif
#ifdef SQLITE_ENABLE_MEMSYS5
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void);
#undef SQLITE_ENABLE_MEMSYS3
#endif
#ifdef SQLITE_ENABLE_MEMSYS3
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void);
#endif
#ifndef SQLITE_MUTEX_OMIT
SQLITE_PRIVATE  sqlite3_mutex_methods const *sqlite3DefaultMutex(void); SQLITE_PRIVATE  sqlite3_mutex_methods const *sqlite3NoopMutex(void); SQLITE_PRIVATE  sqlite3_mutex *sqlite3MutexAlloc(int); SQLITE_PRIVATE  int sqlite3MutexInit(void); SQLITE_PRIVATE  int sqlite3MutexEnd(void);
#endif
#if !defined(SQLITE_MUTEX_OMIT) && !defined(SQLITE_MUTEX_NOOP)
SQLITE_PRIVATE  void sqlite3MemoryBarrier(void);
#else
# define sqlite3MemoryBarrier()
#endif
SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int); SQLITE_PRIVATE void sqlite3StatusUp(int, int); SQLITE_PRIVATE void sqlite3StatusDown(int, int); SQLITE_PRIVATE void sqlite3StatusHighwater(int, int); SQLITE_PRIVATE int sqlite3LookasideUsed(sqlite3*,int*); SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void); SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void);
#if defined(SQLITE_ENABLE_MULTITHREADED_CHECKS) && !defined(SQLITE_MUTEX_OMIT)
SQLITE_PRIVATE void sqlite3MutexWarnOnContention(sqlite3_mutex*);
#else
# define sqlite3MutexWarnOnContention(x)
#endif
#ifndef SQLITE_OMIT_FLOATING_POINT
# define EXP754 (((u64)0x7ff)<<52)
# define MAN754 ((((u64)1)<<52)-1)
# define IsNaN(X) (((X)&EXP754)==EXP754 && ((X)&MAN754)!=0)
SQLITE_PRIVATE  int sqlite3IsNaN(double);
#else
# define IsNaN(X)  0
# define sqlite3IsNaN(X) 0
#endif
struct PrintfArguments {  int nArg;  int nUsed;  sqlite3_value **apArg; }; SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*,const char*, ...); SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*,const char*, va_list);
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
SQLITE_PRIVATE  void sqlite3DebugPrintf(const char*, ...);
#endif
#if defined(SQLITE_TEST)
SQLITE_PRIVATE  void *sqlite3TestTextToPtr(const char*);
#endif
#if defined(SQLITE_DEBUG)
SQLITE_PRIVATE  void sqlite3TreeViewExpr(TreeView*, const Expr*, u8); SQLITE_PRIVATE  void sqlite3TreeViewBareExprList(TreeView*, const ExprList*, const char*); SQLITE_PRIVATE  void sqlite3TreeViewExprList(TreeView*, const ExprList*, u8, const char*); SQLITE_PRIVATE  void sqlite3TreeViewSrcList(TreeView*, const SrcList*); SQLITE_PRIVATE  void sqlite3TreeViewSelect(TreeView*, const Select*, u8); SQLITE_PRIVATE  void sqlite3TreeViewWith(TreeView*, const With*, u8);
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE  void sqlite3TreeViewWindow(TreeView*, const Window*, u8); SQLITE_PRIVATE  void sqlite3TreeViewWinFunc(TreeView*, const Window*, u8);
#endif
#endif
SQLITE_PRIVATE void sqlite3SetString(char **, sqlite3*, const char*); SQLITE_PRIVATE void sqlite3ErrorMsg(Parse*, const char*, ...); SQLITE_PRIVATE int sqlite3ErrorToParser(sqlite3*,int); SQLITE_PRIVATE void sqlite3Dequote(char*); SQLITE_PRIVATE void sqlite3DequoteExpr(Expr*); SQLITE_PRIVATE void sqlite3DequoteToken(Token*); SQLITE_PRIVATE void sqlite3TokenInit(Token*,char*); SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char*, int); SQLITE_PRIVATE int sqlite3RunParser(Parse*, const char*, char **); SQLITE_PRIVATE void sqlite3FinishCoding(Parse*); SQLITE_PRIVATE int sqlite3GetTempReg(Parse*); SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse*,int); SQLITE_PRIVATE int sqlite3GetTempRange(Parse*,int); SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse*,int,int); SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse*,int,int);
#endif
SQLITE_PRIVATE Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int); SQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*,int,const char*); SQLITE_PRIVATE void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*); SQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*); SQLITE_PRIVATE void sqlite3PExprAddSelect(Parse*, Expr*, Select*); SQLITE_PRIVATE Expr *sqlite3ExprAnd(Parse*,Expr*, Expr*); SQLITE_PRIVATE Expr *sqlite3ExprSimplifiedAndOr(Expr*); SQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, const Token*, int); SQLITE_PRIVATE void sqlite3ExprFunctionUsable(Parse*,const Expr*,const FuncDef*); SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32); SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*); SQLITE_PRIVATE void sqlite3ExprDeferredDelete(Parse*, Expr*); SQLITE_PRIVATE void sqlite3ExprUnmapAndDelete(Parse*, Expr*); SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*); SQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*); SQLITE_PRIVATE Select *sqlite3ExprListToValues(Parse*, int, ExprList*); SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList*,int,int); SQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,const Token*,int); SQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*); SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*); SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList*); SQLITE_PRIVATE int sqlite3IndexHasDuplicateRootPage(Index*); SQLITE_PRIVATE int sqlite3Init(sqlite3*, char**); SQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**); SQLITE_PRIVATE int sqlite3InitOne(sqlite3*, int, char**, u32); SQLITE_PRIVATE void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE Module *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);
#endif
SQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3*); SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3*,int); SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3*); SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*); SQLITE_PRIVATE void sqlite3ColumnSetExpr(Parse*,Table*,Column*,Expr*); SQLITE_PRIVATE Expr *sqlite3ColumnExpr(Table*,Column*); SQLITE_PRIVATE void sqlite3ColumnSetColl(sqlite3*,Column*,const char*zColl); SQLITE_PRIVATE const char *sqlite3ColumnColl(Column*); SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3*,Table*); SQLITE_PRIVATE void sqlite3GenerateColumnNames(Parse *pParse, Select *pSelect); SQLITE_PRIVATE int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**); SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*,char); SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*,char); SQLITE_PRIVATE void sqlite3OpenSchemaTable(Parse *, int); SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table*); SQLITE_PRIVATE i16 sqlite3TableColumnToIndex(Index*, i16);
#ifdef SQLITE_OMIT_GENERATED_COLUMNS
# define sqlite3TableColumnToStorage(T,X) (X)
# define sqlite3StorageColumnToTable(T,X) (X)
#else
SQLITE_PRIVATE  i16 sqlite3TableColumnToStorage(Table*, i16); SQLITE_PRIVATE  i16 sqlite3StorageColumnToTable(Table*, i16);
#endif
SQLITE_PRIVATE void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);
#if SQLITE_ENABLE_HIDDEN_COLUMNS
SQLITE_PRIVATE  void sqlite3ColumnPropertiesFromName(Table*, Column*);
#else
# define sqlite3ColumnPropertiesFromName(T,C)
#endif
SQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token,Token); SQLITE_PRIVATE void sqlite3AddNotNull(Parse*, int); SQLITE_PRIVATE void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int); SQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*, const char*, const char*); SQLITE_PRIVATE void sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*); SQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*); SQLITE_PRIVATE void sqlite3AddGenerated(Parse*,Expr*,Token*); SQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,u32,Select*); SQLITE_PRIVATE void sqlite3AddReturning(Parse*,ExprList*); SQLITE_PRIVATE int sqlite3ParseUri(const char*,const char*,unsigned int*,  sqlite3_vfs**,char**,char **);
#define sqlite3CodecQueryParameters(A,B,C) 0
SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3*,const char*);
#ifdef SQLITE_UNTESTABLE
# define sqlite3FaultSim(X) SQLITE_OK
#else
SQLITE_PRIVATE  int sqlite3FaultSim(int);
#endif
SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32); SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec*, u32); SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec*, u32); SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec*, u32); SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec*, u32, void*); SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec*); SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec*);
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int,int*);
#endif
SQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3*); SQLITE_PRIVATE void sqlite3RowSetDelete(void*); SQLITE_PRIVATE void sqlite3RowSetClear(void*); SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet*, i64); SQLITE_PRIVATE int sqlite3RowSetTest(RowSet*, int iBatch, i64); SQLITE_PRIVATE int sqlite3RowSetNext(RowSet*, i64*); SQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
SQLITE_PRIVATE  int sqlite3ViewGetColumnNames(Parse*,Table*);
#else
# define sqlite3ViewGetColumnNames(A,B) 0
#endif
#if SQLITE_MAX_ATTACHED>30
SQLITE_PRIVATE  int sqlite3DbMaskAllZero(yDbMask);
#endif
SQLITE_PRIVATE void sqlite3DropTable(Parse*, SrcList*, int, int); SQLITE_PRIVATE void sqlite3CodeDropTable(Parse*, Table*, int, int); SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3*, Table*); SQLITE_PRIVATE void sqlite3FreeIndex(sqlite3*, Index*);
#ifndef SQLITE_OMIT_AUTOINCREMENT
SQLITE_PRIVATE  void sqlite3AutoincrementBegin(Parse *pParse); SQLITE_PRIVATE  void sqlite3AutoincrementEnd(Parse *pParse);
#else
# define sqlite3AutoincrementBegin(X)
# define sqlite3AutoincrementEnd(X)
#endif
SQLITE_PRIVATE void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int, Upsert*);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
SQLITE_PRIVATE  void sqlite3ComputeGeneratedColumns(Parse*, int, Table*);
#endif
SQLITE_PRIVATE void *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*); SQLITE_PRIVATE IdList *sqlite3IdListAppend(Parse*, IdList*, Token*); SQLITE_PRIVATE int sqlite3IdListIndex(IdList*,const char*); SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int); SQLITE_PRIVATE SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2); SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*); SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,  Token*, Select*, Expr*, IdList*); SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *); SQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*); SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, SrcItem *); SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*); SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*); SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3*, IdList*); SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3*, SrcList*); SQLITE_PRIVATE Index *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**); SQLITE_PRIVATE void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,  Expr*, int, int, u8); SQLITE_PRIVATE void sqlite3DropIndex(Parse*, SrcList*, int); SQLITE_PRIVATE int sqlite3Select(Parse*, Select*, SelectDest*); SQLITE_PRIVATE Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,   Expr*,ExprList*,u32,Expr*); SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3*, Select*); SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse*, SrcList*); SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int); SQLITE_PRIVATE void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)
SQLITE_PRIVATE Expr *sqlite3LimitWhere(Parse*,SrcList*,Expr*,ExprList*,Expr*,char*);
#endif
SQLITE_PRIVATE void sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*); SQLITE_PRIVATE void sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*,   Upsert*); SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,ExprList*,u16,int); SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo*); SQLITE_PRIVATE LogEst sqlite3WhereOutputRowCount(WhereInfo*); SQLITE_PRIVATE int sqlite3WhereIsDistinct(WhereInfo*); SQLITE_PRIVATE int sqlite3WhereIsOrdered(WhereInfo*); SQLITE_PRIVATE int sqlite3WhereOrderByLimitOptLabel(WhereInfo*); SQLITE_PRIVATE void sqlite3WhereMinMaxOptEarlyOut(Vdbe*,WhereInfo*); SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo*); SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo*); SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo*); SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo*, int*);
#define ONEPASS_OFF 0
#define ONEPASS_SINGLE  1
#define ONEPASS_MULTI 2
SQLITE_PRIVATE int sqlite3WhereUsesDeferredSeek(WhereInfo*); SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int); SQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8); SQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int); SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int); SQLITE_PRIVATE void sqlite3ExprCode(Parse*, Expr*, int);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
SQLITE_PRIVATE void sqlite3ExprCodeGeneratedColumn(Parse*, Table*, Column*, int);
#endif
SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, Expr*, int); SQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse*, Expr*, int); SQLITE_PRIVATE int sqlite3ExprCodeRunJustOnce(Parse*, Expr*, int); SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*); SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int); SQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);
#define SQLITE_ECEL_DUP 0x01
#define SQLITE_ECEL_FACTOR  0x02
#define SQLITE_ECEL_REF 0x04
#define SQLITE_ECEL_OMITREF 0x08
SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int); SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int); SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int); SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3*,const char*, const char*);
#define LOCATE_VIEW 0x01
#define LOCATE_NOERR  0x02
SQLITE_PRIVATE Table *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*); SQLITE_PRIVATE const char *sqlite3PreferredTableName(const char*); SQLITE_PRIVATE Table *sqlite3LocateTableItem(Parse*,u32 flags,SrcItem *); SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3*,const char*, const char*); SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*); SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*); SQLITE_PRIVATE void sqlite3Vacuum(Parse*,Token*,Expr*); SQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*, int, sqlite3_value*); SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, const Token*); SQLITE_PRIVATE int sqlite3ExprCompare(const Parse*,const Expr*,const Expr*, int); SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*,Expr*,int); SQLITE_PRIVATE int sqlite3ExprListCompare(const ExprList*,const ExprList*, int); SQLITE_PRIVATE int sqlite3ExprImpliesExpr(const Parse*,const Expr*,const Expr*, int); SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int); SQLITE_PRIVATE void sqlite3AggInfoPersistWalkerInit(Walker*,Parse*); SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*); SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*); SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx); SQLITE_PRIVATE int sqlite3ReferencesSrcList(Parse*, Expr*, SrcList*); SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*);
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE void sqlite3PrngSaveState(void); SQLITE_PRIVATE void sqlite3PrngRestoreState(void);
#endif
SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*,int); SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int); SQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb); SQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int); SQLITE_PRIVATE void sqlite3EndTransaction(Parse*,int); SQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*); SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *); SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3*); SQLITE_PRIVATE u32 sqlite3IsTrueOrFalse(const char*); SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr*); SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr*); SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*); SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*); SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*, u8); SQLITE_PRIVATE int sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*); SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr*,int);
#ifdef SQLITE_ENABLE_CURSOR_HINTS
SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr*);
#endif
SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr*, int*); SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr*); SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr*, char); SQLITE_PRIVATE int sqlite3IsRowid(const char*); SQLITE_PRIVATE void sqlite3GenerateRowDelete(  Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int); SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int); SQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int); SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse*,int); SQLITE_PRIVATE int sqlite3ExprReferencesUpdatedColumn(Expr*,int*,int); SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,   u8,u8,int,int*,int*,Upsert*);
#ifdef SQLITE_ENABLE_NULL_TRIM
SQLITE_PRIVATE  void sqlite3SetMakeRecordP5(Vdbe*,Table*);
#else
# define sqlite3SetMakeRecordP5(A,B)
#endif
SQLITE_PRIVATE void sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int); SQLITE_PRIVATE int sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*); SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse*, int, int); SQLITE_PRIVATE void sqlite3MultiWrite(Parse*); SQLITE_PRIVATE void sqlite3MayAbort(Parse*); SQLITE_PRIVATE void sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8); SQLITE_PRIVATE void sqlite3UniqueConstraint(Parse*, int, Index*); SQLITE_PRIVATE void sqlite3RowidConstraint(Parse*, int, Table*); SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,const Expr*,int); SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,const ExprList*,int); SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,const SrcList*,int); SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,const IdList*); SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,const Select*,int); SQLITE_PRIVATE FuncDef *sqlite3FunctionSearch(int,const char*); SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(FuncDef*,int); SQLITE_PRIVATE FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8); SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(void); SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void); SQLITE_PRIVATE void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*); SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3*); SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3*); SQLITE_PRIVATE void sqlite3ChangeCookie(Parse*, int); SQLITE_PRIVATE With *sqlite3WithDup(sqlite3 *db, With *p);
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE void sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);
#endif
#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE  void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,   Expr*,int, int); SQLITE_PRIVATE  void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*); SQLITE_PRIVATE  void sqlite3DropTrigger(Parse*, SrcList*, int); SQLITE_PRIVATE  void sqlite3DropTriggerPtr(Parse*, Trigger*); SQLITE_PRIVATE  Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask); SQLITE_PRIVATE  Trigger *sqlite3TriggerList(Parse *, Table *); SQLITE_PRIVATE  void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,  int, int, int); SQLITE_PRIVATE  void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*); SQLITE_PRIVATE  void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*); SQLITE_PRIVATE  TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,  const char*,const char*); SQLITE_PRIVATE  TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,  Select*,u8,Upsert*,  const char*,const char*); SQLITE_PRIVATE  TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,SrcList*,ExprList*,  Expr*, u8, const char*,const char*); SQLITE_PRIVATE  TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,  const char*,const char*); SQLITE_PRIVATE  void sqlite3DeleteTrigger(sqlite3*, Trigger*); SQLITE_PRIVATE  void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*); SQLITE_PRIVATE  u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int); SQLITE_PRIVATE  SrcList *sqlite3TriggerStepSrc(Parse*, TriggerStep*);
# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))
# define sqlite3IsToplevel(p) ((p)->pToplevel==0)
#else
# define sqlite3TriggersExist(B,C,D,E,F) 0
# define sqlite3DeleteTrigger(A,B)
# define sqlite3DropTriggerPtr(A,B)
# define sqlite3UnlinkAndDeleteTrigger(A,B,C)
# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)
# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)
# define sqlite3TriggerList(X, Y) 0
# define sqlite3ParseToplevel(p) p
# define sqlite3IsToplevel(p) 1
# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0
# define sqlite3TriggerStepSrc(A,B) 0
#endif
SQLITE_PRIVATE int sqlite3JoinType(Parse*, Token*, Token*, Token*); SQLITE_PRIVATE int sqlite3ColumnIndex(Table *pTab, const char *zCol); SQLITE_PRIVATE void sqlite3SetJoinExpr(Expr*,int); SQLITE_PRIVATE void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int); SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse*, int);
#ifndef SQLITE_OMIT_AUTHORIZATION
SQLITE_PRIVATE  void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*); SQLITE_PRIVATE  int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*); SQLITE_PRIVATE  void sqlite3AuthContextPush(Parse*, AuthContext*, const char*); SQLITE_PRIVATE  void sqlite3AuthContextPop(AuthContext*); SQLITE_PRIVATE  int sqlite3AuthReadCol(Parse*, const char *, const char *, int);
#else
# define sqlite3AuthRead(a,b,c,d)
# define sqlite3AuthCheck(a,b,c,d,e) SQLITE_OK
# define sqlite3AuthContextPush(a,b,c)
# define sqlite3AuthContextPop(a) ((void)(a))
#endif
SQLITE_PRIVATE int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName); SQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*); SQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*); SQLITE_PRIVATE void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*); SQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*); SQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*); SQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*); SQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*); SQLITE_PRIVATE int sqlite3RealSameAsInt(double,sqlite3_int64); SQLITE_PRIVATE void sqlite3Int64ToText(i64,char*); SQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8); SQLITE_PRIVATE int sqlite3GetInt32(const char *, int*); SQLITE_PRIVATE int sqlite3GetUInt32(const char*, u32*); SQLITE_PRIVATE int sqlite3Atoi(const char*);
#ifndef SQLITE_OMIT_UTF16
SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);
#endif
SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte); SQLITE_PRIVATE u32 sqlite3Utf8Read(const u8**); SQLITE_PRIVATE LogEst sqlite3LogEst(u64); SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst,LogEst);
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double);
#endif
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) ||  defined(SQLITE_ENABLE_STAT4) ||  defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)

SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst);
#endif
SQLITE_PRIVATE VList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int); SQLITE_PRIVATE const char *sqlite3VListNumToName(VList*,int); SQLITE_PRIVATE int sqlite3VListNameToNum(VList*,const char*,int); SQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64); SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, u64 *); SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *, u32 *); SQLITE_PRIVATE int sqlite3VarintLen(u64 v);
#define getVarint32(A,B)  (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))

#define getVarint32NR(A,B)  B=(u32)*(A);if(B>=0x80)sqlite3GetVarint32((A),(u32*)&(B))

#define putVarint32(A,B)  (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1: sqlite3PutVarint((A),(B)))

#define getVarint sqlite3GetVarint
#define putVarint sqlite3PutVarint
SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3*, Index*); SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe*, Table*, int); SQLITE_PRIVATE char sqlite3CompareAffinity(const Expr *pExpr, char aff2); SQLITE_PRIVATE int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity); SQLITE_PRIVATE char sqlite3TableColumnAffinity(const Table*,int); SQLITE_PRIVATE char sqlite3ExprAffinity(const Expr *pExpr); SQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*, int, u8); SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char*, i64*); SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...); SQLITE_PRIVATE void sqlite3Error(sqlite3*,int); SQLITE_PRIVATE void sqlite3ErrorClear(sqlite3*); SQLITE_PRIVATE void sqlite3SystemError(sqlite3*,int); SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n); SQLITE_PRIVATE u8 sqlite3HexToInt(int h); SQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);
#if defined(SQLITE_NEED_ERR_NAME)
SQLITE_PRIVATE const char *sqlite3ErrName(int);
#endif
#ifndef SQLITE_OMIT_DESERIALIZE
SQLITE_PRIVATE int sqlite3MemdbInit(void);
#endif
SQLITE_PRIVATE const char *sqlite3ErrStr(int); SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse); SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int); SQLITE_PRIVATE int sqlite3IsBinary(const CollSeq*); SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName); SQLITE_PRIVATE void sqlite3SetTextEncoding(sqlite3 *db, u8); SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr); SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr); SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse*,const Expr*,const Expr*); SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(const Parse *pParse, Expr*, const Token*, int); SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(const Parse*,Expr*,const char*); SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr*); SQLITE_PRIVATE Expr *sqlite3ExprSkipCollateAndLikely(Expr*); SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *); SQLITE_PRIVATE int sqlite3WritableSchema(sqlite3*); SQLITE_PRIVATE int sqlite3CheckObjectName(Parse*, const char*,const char*,const char*); SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, i64); SQLITE_PRIVATE int sqlite3AddInt64(i64*,i64); SQLITE_PRIVATE int sqlite3SubInt64(i64*,i64); SQLITE_PRIVATE int sqlite3MulInt64(i64*,i64); SQLITE_PRIVATE int sqlite3AbsInt32(int);
#ifdef SQLITE_ENABLE_8_3_NAMES
SQLITE_PRIVATE void sqlite3FileSuffix3(const char*, char*);
#else
# define sqlite3FileSuffix3(X,Y)
#endif
SQLITE_PRIVATE u8 sqlite3GetBoolean(const char *z,u8); SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8); SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8); SQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,  void(*)(void*)); SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value*); SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE void sqlite3ResultIntReal(sqlite3_context*);
#endif
SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);
#ifndef SQLITE_OMIT_UTF16
SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);
#endif
SQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, const Expr *, u8, u8, sqlite3_value **); SQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
#ifndef SQLITE_AMALGAMATION
SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[]; SQLITE_PRIVATE const char sqlite3StrBINARY[]; SQLITE_PRIVATE const unsigned char sqlite3StdTypeLen[]; SQLITE_PRIVATE const char sqlite3StdTypeAffinity[]; SQLITE_PRIVATE const char sqlite3StdTypeMap[]; SQLITE_PRIVATE const char *sqlite3StdType[]; SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[]; SQLITE_PRIVATE const unsigned char *sqlite3aLTb; SQLITE_PRIVATE const unsigned char *sqlite3aEQb; SQLITE_PRIVATE const unsigned char *sqlite3aGTb; SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[]; SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config; SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;
#ifndef SQLITE_OMIT_WSD
SQLITE_PRIVATE int sqlite3PendingByte;
#endif
#endif
#ifdef VDBE_PROFILE
SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt;
#endif
SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, Pgno, Pgno); SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*); SQLITE_PRIVATE void sqlite3AlterFunctions(void); SQLITE_PRIVATE void sqlite3AlterRenameTable(Parse*, SrcList*, Token*); SQLITE_PRIVATE void sqlite3AlterRenameColumn(Parse*, SrcList*, Token*, Token*); SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *, int *); SQLITE_PRIVATE void sqlite3NestedParse(Parse*, const char*, ...); SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3*, int); SQLITE_PRIVATE void sqlite3CodeRhsOfIN(Parse*, Expr*, int); SQLITE_PRIVATE int sqlite3CodeSubselect(Parse*, Expr*); SQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*); SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse*, SrcItem*); SQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p); SQLITE_PRIVATE int sqlite3MatchEName(  const struct ExprList_item*,  const char*,  const char*,  const char* ); SQLITE_PRIVATE Bitmask sqlite3ExprColUsed(Expr*); SQLITE_PRIVATE u8 sqlite3StrIHash(const char*); SQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*); SQLITE_PRIVATE int sqlite3ResolveExprListNames(NameContext*, ExprList*); SQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*); SQLITE_PRIVATE int sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*); SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*); SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *, Table *, int, int); SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *, Token *); SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *, SrcList *); SQLITE_PRIVATE void sqlite3AlterDropColumn(Parse*, SrcList*, const Token*); SQLITE_PRIVATE const void *sqlite3RenameTokenMap(Parse*, const void*, const Token*); SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse*, const void *pTo, const void *pFrom); SQLITE_PRIVATE void sqlite3RenameExprUnmap(Parse*, Expr*); SQLITE_PRIVATE void sqlite3RenameExprlistUnmap(Parse*, ExprList*); SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*); SQLITE_PRIVATE char sqlite3AffinityType(const char*, Column*); SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*); SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*); SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*); SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *); SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB); SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3*,Index*); SQLITE_PRIVATE void sqlite3DefaultRowEst(Index*); SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3*, int); SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*); SQLITE_PRIVATE void sqlite3SchemaClear(void *); SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *, Btree *); SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *); SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int); SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo*); SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo*); SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*); SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int); SQLITE_PRIVATE const char *sqlite3SelectOpName(int); SQLITE_PRIVATE int sqlite3HasExplicitNulls(Parse*, ExprList*);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo*);
#endif
SQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,  void (*)(sqlite3_context*,int,sqlite3_value **),  void (*)(sqlite3_context*,int,sqlite3_value **),  void (*)(sqlite3_context*),  void (*)(sqlite3_context*),  void (*)(sqlite3_context*,int,sqlite3_value **),  FuncDestructor *pDestructor ); SQLITE_PRIVATE void sqlite3NoopDestructor(void*); SQLITE_PRIVATE void sqlite3OomFault(sqlite3*); SQLITE_PRIVATE void sqlite3OomClear(sqlite3*); SQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int); SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *); SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int); SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum*); SQLITE_PRIVATE void sqlite3StrAccumSetError(StrAccum*, u8); SQLITE_PRIVATE void sqlite3ResultStrAccum(sqlite3_context*,StrAccum*); SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest*,int,int); SQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int); SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *); SQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);
#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse*, Expr*);
#else
# define sqlite3ExprCheckIN(x,y) SQLITE_OK
#endif
#ifdef SQLITE_ENABLE_STAT4
SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(  Parse*,Index*,UnpackedRecord**,Expr*,int,int,int*); SQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(Parse*, Expr*, u8, sqlite3_value**); SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord*); SQLITE_PRIVATE int sqlite3Stat4Column(sqlite3*, const void*, int, int, sqlite3_value**); SQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3*, Index*, int);
#endif
#ifndef SQLITE_AMALGAMATION
SQLITE_PRIVATE  void *sqlite3ParserAlloc(void*(*)(u64), Parse*); SQLITE_PRIVATE  void sqlite3ParserFree(void*, void(*)(void*));
#endif
SQLITE_PRIVATE void sqlite3Parser(void*, int, Token); SQLITE_PRIVATE int sqlite3ParserFallback(int);
#ifdef YYTRACKMAXSTACKDEPTH
SQLITE_PRIVATE  int sqlite3ParserStackPeak(void*);
#endif
SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3*);
#ifndef SQLITE_OMIT_LOAD_EXTENSION
SQLITE_PRIVATE  void sqlite3CloseExtensions(sqlite3*);
#else
# define sqlite3CloseExtensions(X)
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE  void sqlite3TableLock(Parse *, int, Pgno, u8, const char *);
#else
 #define sqlite3TableLock(v,w,x,y,z)
#endif
#ifdef SQLITE_TEST
SQLITE_PRIVATE  int sqlite3Utf8To8(unsigned char*);
#endif
#ifdef SQLITE_OMIT_VIRTUALTABLE
# define sqlite3VtabClear(D,T)
# define sqlite3VtabSync(X,Y) SQLITE_OK
# define sqlite3VtabRollback(X)
# define sqlite3VtabCommit(X)
# define sqlite3VtabInSync(db) 0
# define sqlite3VtabLock(X)
# define sqlite3VtabUnlock(X)
# define sqlite3VtabModuleUnref(D,X)
# define sqlite3VtabUnlockList(X)
# define sqlite3VtabSavepoint(X, Y, Z) SQLITE_OK
# define sqlite3GetVTable(X,Y) ((VTable*)0)
#else
SQLITE_PRIVATE void sqlite3VtabClear(sqlite3 *db, Table*); SQLITE_PRIVATE void sqlite3VtabDisconnect(sqlite3 *db, Table *p); SQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, Vdbe*); SQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db); SQLITE_PRIVATE int sqlite3VtabCommit(sqlite3 *db); SQLITE_PRIVATE void sqlite3VtabLock(VTable *); SQLITE_PRIVATE void sqlite3VtabUnlock(VTable *); SQLITE_PRIVATE void sqlite3VtabModuleUnref(sqlite3*,Module*); SQLITE_PRIVATE void sqlite3VtabUnlockList(sqlite3*); SQLITE_PRIVATE int sqlite3VtabSavepoint(sqlite3 *, int, int); SQLITE_PRIVATE void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*); SQLITE_PRIVATE VTable *sqlite3GetVTable(sqlite3*, Table*); SQLITE_PRIVATE Module *sqlite3VtabCreateModule(   sqlite3*,   const char*,   const sqlite3_module*,   void*,   void(*)(void*)   );
# define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)
#endif
SQLITE_PRIVATE int sqlite3ReadOnlyShadowTables(sqlite3 *db);
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE  int sqlite3ShadowTableName(sqlite3 *db, const char *zName); SQLITE_PRIVATE  int sqlite3IsShadowTableOf(sqlite3*,Table*,const char*); SQLITE_PRIVATE  void sqlite3MarkAllShadowTablesOf(sqlite3*, Table*);
#else
# define sqlite3ShadowTableName(A,B) 0
# define sqlite3IsShadowTableOf(A,B,C) 0
# define sqlite3MarkAllShadowTablesOf(A,B)
#endif
SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse*,Module*); SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3*,Module*); SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*); SQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int); SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*); SQLITE_PRIVATE void sqlite3VtabArgInit(Parse*); SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse*, Token*); SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **); SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse*, Table*); SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3*, int, const char *); SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *, VTable *); SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*); SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*); SQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe*, const char*, int); SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *); SQLITE_PRIVATE void sqlite3ParserReset(Parse*); SQLITE_PRIVATE void *sqlite3ParserAddCleanup(Parse*,void(*)(sqlite3*,void*),void*);
#ifdef SQLITE_ENABLE_NORMALIZE
SQLITE_PRIVATE char *sqlite3Normalize(Vdbe*, const char*);
#endif
SQLITE_PRIVATE int sqlite3Reprepare(Vdbe*); SQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*); SQLITE_PRIVATE CollSeq *sqlite3ExprCompareCollSeq(Parse*,const Expr*); SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, const Expr*, const Expr*); SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3*); SQLITE_PRIVATE const char *sqlite3JournalModename(int);
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE  int sqlite3Checkpoint(sqlite3*, int, int, int*, int*); SQLITE_PRIVATE  int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);
#endif
#ifndef SQLITE_OMIT_CTE
SQLITE_PRIVATE  Cte *sqlite3CteNew(Parse*,Token*,ExprList*,Select*,u8); SQLITE_PRIVATE  void sqlite3CteDelete(sqlite3*,Cte*); SQLITE_PRIVATE  With *sqlite3WithAdd(Parse*,With*,Cte*); SQLITE_PRIVATE  void sqlite3WithDelete(sqlite3*,With*); SQLITE_PRIVATE  With *sqlite3WithPush(Parse*, With*, u8);
#else
# define sqlite3CteNew(P,T,E,S)  ((void*)0)
# define sqlite3CteDelete(D,C)
# define sqlite3CteWithAdd(P,W,C) ((void*)0)
# define sqlite3WithDelete(x,y)
# define sqlite3WithPush(x,y,z) ((void*)0)
#endif
#ifndef SQLITE_OMIT_UPSERT
SQLITE_PRIVATE  Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*,Upsert*); SQLITE_PRIVATE  void sqlite3UpsertDelete(sqlite3*,Upsert*); SQLITE_PRIVATE  Upsert *sqlite3UpsertDup(sqlite3*,Upsert*); SQLITE_PRIVATE  int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*); SQLITE_PRIVATE  void sqlite3UpsertDoUpdate(Parse*,Upsert*,Table*,Index*,int); SQLITE_PRIVATE  Upsert *sqlite3UpsertOfIndex(Upsert*,Index*); SQLITE_PRIVATE  int sqlite3UpsertNextIsIPK(Upsert*);
#else
#define sqlite3UpsertNew(u,v,w,x,y,z) ((Upsert*)0)
#define sqlite3UpsertDelete(x,y)
#define sqlite3UpsertDup(x,y)  ((Upsert*)0)
#define sqlite3UpsertOfIndex(x,y)  ((Upsert*)0)
#define sqlite3UpsertNextIsIPK(x)  0
#endif
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE  void sqlite3FkCheck(Parse*, Table*, int, int, int*, int); SQLITE_PRIVATE  void sqlite3FkDropTable(Parse*, SrcList *, Table*); SQLITE_PRIVATE  void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int); SQLITE_PRIVATE  int sqlite3FkRequired(Parse*, Table*, int*, int); SQLITE_PRIVATE  u32 sqlite3FkOldmask(Parse*, Table*); SQLITE_PRIVATE  FKey *sqlite3FkReferences(Table *); SQLITE_PRIVATE  void sqlite3FkClearTriggerCache(sqlite3*,int);
#else
 #define sqlite3FkActions(a,b,c,d,e,f)
 #define sqlite3FkCheck(a,b,c,d,e,f)
 #define sqlite3FkDropTable(a,b,c)
 #define sqlite3FkOldmask(a,b)  0
 #define sqlite3FkRequired(a,b,c,d) 0
 #define sqlite3FkReferences(a) 0
 #define sqlite3FkClearTriggerCache(a,b)
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
SQLITE_PRIVATE  void sqlite3FkDelete(sqlite3 *, Table*); SQLITE_PRIVATE  int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);
#else
 #define sqlite3FkDelete(a,b)
 #define sqlite3FkLocateIndex(a,b,c,d,e)
#endif
#define SQLITE_FAULTINJECTOR_MALLOC  0
#define SQLITE_FAULTINJECTOR_COUNT 1
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE  void sqlite3BeginBenignMalloc(void); SQLITE_PRIVATE  void sqlite3EndBenignMalloc(void);
#else
 #define sqlite3BeginBenignMalloc()
 #define sqlite3EndBenignMalloc()
#endif
#define IN_INDEX_ROWID 1
#define IN_INDEX_EPH 2
#define IN_INDEX_INDEX_ASC 3
#define IN_INDEX_INDEX_DESC  4
#define IN_INDEX_NOOP  5
#define IN_INDEX_NOOP_OK  0x0001
#define IN_INDEX_MEMBERSHIP 0x0002
#define IN_INDEX_LOOP 0x0004
SQLITE_PRIVATE int sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*, int*); SQLITE_PRIVATE int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int); SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *);
#if defined(SQLITE_ENABLE_ATOMIC_WRITE)  || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)

SQLITE_PRIVATE  int sqlite3JournalCreate(sqlite3_file *);
#endif
SQLITE_PRIVATE int sqlite3JournalIsInMemory(sqlite3_file *p); SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *); SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);
#if SQLITE_MAX_EXPR_DEPTH>0
SQLITE_PRIVATE  int sqlite3SelectExprHeight(const Select *); SQLITE_PRIVATE  int sqlite3ExprCheckHeight(Parse*, int);
#else
 #define sqlite3SelectExprHeight(x) 0
 #define sqlite3ExprCheckHeight(x,y)
#endif
SQLITE_PRIVATE u32 sqlite3Get4byte(const u8*); SQLITE_PRIVATE void sqlite3Put4byte(u8*, u32);
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
SQLITE_PRIVATE  void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *); SQLITE_PRIVATE  void sqlite3ConnectionUnlocked(sqlite3 *db); SQLITE_PRIVATE  void sqlite3ConnectionClosed(sqlite3 *db);
#else
 #define sqlite3ConnectionBlocked(x,y)
 #define sqlite3ConnectionUnlocked(x)
 #define sqlite3ConnectionClosed(x)
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  void sqlite3ParserTrace(FILE*, char *);
#endif
#if defined(YYCOVERAGE)
SQLITE_PRIVATE  int sqlite3ParserCoverage(FILE*);
#endif
#ifdef SQLITE_ENABLE_IOTRACE
# define IOTRACE(A) if( sqlite3IoTrace ){ sqlite3IoTrace A; }
SQLITE_PRIVATE  void sqlite3VdbeIOTraceSql(Vdbe*); SQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);
#else
# define IOTRACE(A)
# define sqlite3VdbeIOTraceSql(X)
#endif
#ifdef SQLITE_MEMDEBUG
SQLITE_PRIVATE  void sqlite3MemdebugSetType(void*,u8); SQLITE_PRIVATE  int sqlite3MemdebugHasType(const void*,u8); SQLITE_PRIVATE  int sqlite3MemdebugNoType(const void*,u8);
#else
# define sqlite3MemdebugSetType(X,Y)
# define sqlite3MemdebugHasType(X,Y) 1
# define sqlite3MemdebugNoType(X,Y)  1
#endif
#define MEMTYPE_HEAP  0x01
#define MEMTYPE_LOOKASIDE 0x02
#define MEMTYPE_PCACHE  0x04
#if SQLITE_MAX_WORKER_THREADS>0
SQLITE_PRIVATE int sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*); SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread*, void**);
#endif
#if defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)
SQLITE_PRIVATE int sqlite3DbpageRegister(sqlite3*);
#endif
#if defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST)
SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3*);
#endif
SQLITE_PRIVATE int sqlite3ExprVectorSize(const Expr *pExpr); SQLITE_PRIVATE int sqlite3ExprIsVector(const Expr *pExpr); SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr*, int); SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(Parse*,Expr*,int,int); SQLITE_PRIVATE void sqlite3VectorErrorMsg(Parse*, Expr*);
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt);
#endif
#endif
#ifndef _OS_COMMON_H_
#define _OS_COMMON_H_
#ifdef MEMORY_DEBUG
# error "The MEMORY_DEBUG macro is obsolete. Use SQLITE_DEBUG instead."
#endif
#ifdef SQLITE_PERFORMANCE_TRACE
#ifndef SQLITE_HWTIME_H
#define SQLITE_HWTIME_H
#if !defined(__STRICT_ANSI__) &&  (defined(__GNUC__) || defined(_MSC_VER)) &&  (defined(i386) || defined(__i386__) || defined(_M_IX86))

 #if defined(__GNUC__)
 __inline__ sqlite_uint64 sqlite3Hwtime(void){   unsigned int lo, hi;   __asm__ __volatile__ ("rdtsc" : "=a" (lo), "=d" (hi));   return (sqlite_uint64)hi << 32 | lo;  }
 #elif defined(_MSC_VER)
 __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){   __asm {  rdtsc  ret  ; return value at EDX:EAX   }  }
 #endif
#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))
 __inline__ sqlite_uint64 sqlite3Hwtime(void){  unsigned long val;  __asm__ __volatile__ ("rdtsc" : "=A" (val));  return val;  }
#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))
 __inline__ sqlite_uint64 sqlite3Hwtime(void){  unsigned long long retval;  unsigned long junk;  __asm__ __volatile__ ("\n  1: mftbu  %1\n  mftb %L0\n  mftbu  %0\n  cmpw %0,%1\n  bne  1b"  : "=r" (retval), "=r" (junk));  return retval;  }
#else
SQLITE_PRIVATE  sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }
#endif
#endif
static sqlite_uint64 g_start; static sqlite_uint64 g_elapsed;
#define TIMER_START  g_start=sqlite3Hwtime()
#define TIMER_END  g_elapsed=sqlite3Hwtime()-g_start
#define TIMER_ELAPSED  g_elapsed
#else
#define TIMER_START
#define TIMER_END
#define TIMER_ELAPSED  ((sqlite_uint64)0)
#endif
#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_io_error_hit; SQLITE_API extern int sqlite3_io_error_hardhit; SQLITE_API extern int sqlite3_io_error_pending; SQLITE_API extern int sqlite3_io_error_persist; SQLITE_API extern int sqlite3_io_error_benign; SQLITE_API extern int sqlite3_diskfull_pending; SQLITE_API extern int sqlite3_diskfull;
#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)
#define SimulateIOError(CODE)  if( (sqlite3_io_error_persist && sqlite3_io_error_hit)   || sqlite3_io_error_pending-- == 1 )  { local_ioerr(); CODE; }

static void local_ioerr(){  IOTRACE(("IOERR\n"));  sqlite3_io_error_hit++;  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++; }
#define SimulateDiskfullError(CODE)   if( sqlite3_diskfull_pending ){   if( sqlite3_diskfull_pending == 1 ){   local_ioerr();   sqlite3_diskfull = 1;   sqlite3_io_error_hit = 1;   CODE;   }else{   sqlite3_diskfull_pending--;   }   }

#else
#define SimulateIOErrorBenign(X)
#define SimulateIOError(A)
#define SimulateDiskfullError(A)
#endif
#if defined(SQLITE_TEST)
SQLITE_API extern int sqlite3_open_file_count;
#define OpenCounter(X) sqlite3_open_file_count+=(X)
#else
#define OpenCounter(X)
#endif
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
#if defined(_HAVE_SQLITE_CONFIG_H) && !defined(SQLITECONFIG_H)
#define SQLITECONFIG_H 1
#endif
#define CTIMEOPT_VAL_(opt) #opt
#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)
#define CTIMEOPT_VAL2_(opt1,opt2) #opt1 "," #opt2
#define CTIMEOPT_VAL2(opt) CTIMEOPT_VAL2_(opt)
static const char * const sqlite3azCompileOpt[] = {
#ifdef SQLITE_32BIT_ROWID
 "32BIT_ROWID",
#endif
#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC
 "4_BYTE_ALIGNED_MALLOC",
#endif
#ifdef SQLITE_64BIT_STATS
 "64BIT_STATS",
#endif
#ifdef SQLITE_ALLOW_COVERING_INDEX_SCAN
# if SQLITE_ALLOW_COVERING_INDEX_SCAN != 1
 "ALLOW_COVERING_INDEX_SCAN=" CTIMEOPT_VAL(SQLITE_ALLOW_COVERING_INDEX_SCAN),
# endif
#endif
#ifdef SQLITE_ALLOW_URI_AUTHORITY
 "ALLOW_URI_AUTHORITY",
#endif
#ifdef SQLITE_ATOMIC_INTRINSICS
 "ATOMIC_INTRINSICS=" CTIMEOPT_VAL(SQLITE_ATOMIC_INTRINSICS),
#endif
#ifdef SQLITE_BITMASK_TYPE
 "BITMASK_TYPE=" CTIMEOPT_VAL(SQLITE_BITMASK_TYPE),
#endif
#ifdef SQLITE_BUG_COMPATIBLE_20160819
 "BUG_COMPATIBLE_20160819",
#endif
#ifdef SQLITE_CASE_SENSITIVE_LIKE
 "CASE_SENSITIVE_LIKE",
#endif
#ifdef SQLITE_CHECK_PAGES
 "CHECK_PAGES",
#endif
#if defined(__clang__) && defined(__clang_major__)
 "COMPILER=clang-" CTIMEOPT_VAL(__clang_major__) "."  CTIMEOPT_VAL(__clang_minor__) "."  CTIMEOPT_VAL(__clang_patchlevel__),
#elif defined(_MSC_VER)
 "COMPILER=msvc-" CTIMEOPT_VAL(_MSC_VER),
#elif defined(__GNUC__) && defined(__VERSION__)
 "COMPILER=gcc-" __VERSION__,
#endif
#ifdef SQLITE_COVERAGE_TEST
 "COVERAGE_TEST",
#endif
#ifdef SQLITE_DEBUG
 "DEBUG",
#endif
#ifdef SQLITE_DEFAULT_AUTOMATIC_INDEX
 "DEFAULT_AUTOMATIC_INDEX",
#endif
#ifdef SQLITE_DEFAULT_AUTOVACUUM
 "DEFAULT_AUTOVACUUM",
#endif
#ifdef SQLITE_DEFAULT_CACHE_SIZE
 "DEFAULT_CACHE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_CACHE_SIZE),
#endif
#ifdef SQLITE_DEFAULT_CKPTFULLFSYNC
 "DEFAULT_CKPTFULLFSYNC",
#endif
#ifdef SQLITE_DEFAULT_FILE_FORMAT
 "DEFAULT_FILE_FORMAT=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_FORMAT),
#endif
#ifdef SQLITE_DEFAULT_FILE_PERMISSIONS
 "DEFAULT_FILE_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_FILE_PERMISSIONS),
#endif
#ifdef SQLITE_DEFAULT_FOREIGN_KEYS
 "DEFAULT_FOREIGN_KEYS",
#endif
#ifdef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT
 "DEFAULT_JOURNAL_SIZE_LIMIT=" CTIMEOPT_VAL(SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT),
#endif
#ifdef SQLITE_DEFAULT_LOCKING_MODE
 "DEFAULT_LOCKING_MODE=" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),
#endif
#ifdef SQLITE_DEFAULT_LOOKASIDE
 "DEFAULT_LOOKASIDE=" CTIMEOPT_VAL2(SQLITE_DEFAULT_LOOKASIDE),
#endif
#ifdef SQLITE_DEFAULT_MEMSTATUS
# if SQLITE_DEFAULT_MEMSTATUS != 1
 "DEFAULT_MEMSTATUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_MEMSTATUS),
# endif
#endif
#ifdef SQLITE_DEFAULT_MMAP_SIZE
 "DEFAULT_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_MMAP_SIZE),
#endif
#ifdef SQLITE_DEFAULT_PAGE_SIZE
 "DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_PAGE_SIZE),
#endif
#ifdef SQLITE_DEFAULT_PCACHE_INITSZ
 "DEFAULT_PCACHE_INITSZ=" CTIMEOPT_VAL(SQLITE_DEFAULT_PCACHE_INITSZ),
#endif
#ifdef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
 "DEFAULT_PROXYDIR_PERMISSIONS=" CTIMEOPT_VAL(SQLITE_DEFAULT_PROXYDIR_PERMISSIONS),
#endif
#ifdef SQLITE_DEFAULT_RECURSIVE_TRIGGERS
 "DEFAULT_RECURSIVE_TRIGGERS",
#endif
#ifdef SQLITE_DEFAULT_ROWEST
 "DEFAULT_ROWEST=" CTIMEOPT_VAL(SQLITE_DEFAULT_ROWEST),
#endif
#ifdef SQLITE_DEFAULT_SECTOR_SIZE
 "DEFAULT_SECTOR_SIZE=" CTIMEOPT_VAL(SQLITE_DEFAULT_SECTOR_SIZE),
#endif
#ifdef SQLITE_DEFAULT_SYNCHRONOUS
 "DEFAULT_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_SYNCHRONOUS),
#endif
#ifdef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT
 "DEFAULT_WAL_AUTOCHECKPOINT=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_AUTOCHECKPOINT),
#endif
#ifdef SQLITE_DEFAULT_WAL_SYNCHRONOUS
 "DEFAULT_WAL_SYNCHRONOUS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WAL_SYNCHRONOUS),
#endif
#ifdef SQLITE_DEFAULT_WORKER_THREADS
 "DEFAULT_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_DEFAULT_WORKER_THREADS),
#endif
#ifdef SQLITE_DIRECT_OVERFLOW_READ
 "DIRECT_OVERFLOW_READ",
#endif
#ifdef SQLITE_DISABLE_DIRSYNC
 "DISABLE_DIRSYNC",
#endif
#ifdef SQLITE_DISABLE_FTS3_UNICODE
 "DISABLE_FTS3_UNICODE",
#endif
#ifdef SQLITE_DISABLE_FTS4_DEFERRED
 "DISABLE_FTS4_DEFERRED",
#endif
#ifdef SQLITE_DISABLE_INTRINSIC
 "DISABLE_INTRINSIC",
#endif
#ifdef SQLITE_DISABLE_LFS
 "DISABLE_LFS",
#endif
#ifdef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
 "DISABLE_PAGECACHE_OVERFLOW_STATS",
#endif
#ifdef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
 "DISABLE_SKIPAHEAD_DISTINCT",
#endif
#ifdef SQLITE_ENABLE_8_3_NAMES
 "ENABLE_8_3_NAMES=" CTIMEOPT_VAL(SQLITE_ENABLE_8_3_NAMES),
#endif
#ifdef SQLITE_ENABLE_API_ARMOR
 "ENABLE_API_ARMOR",
#endif
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
 "ENABLE_ATOMIC_WRITE",
#endif
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
 "ENABLE_BATCH_ATOMIC_WRITE",
#endif
#ifdef SQLITE_ENABLE_BYTECODE_VTAB
 "ENABLE_BYTECODE_VTAB",
#endif
#ifdef SQLITE_ENABLE_CEROD
 "ENABLE_CEROD=" CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),
#endif
#ifdef SQLITE_ENABLE_COLUMN_METADATA
 "ENABLE_COLUMN_METADATA",
#endif
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
 "ENABLE_COLUMN_USED_MASK",
#endif
#ifdef SQLITE_ENABLE_COSTMULT
 "ENABLE_COSTMULT",
#endif
#ifdef SQLITE_ENABLE_CURSOR_HINTS
 "ENABLE_CURSOR_HINTS",
#endif
#ifdef SQLITE_ENABLE_DBPAGE_VTAB
 "ENABLE_DBPAGE_VTAB",
#endif
#ifdef SQLITE_ENABLE_DBSTAT_VTAB
 "ENABLE_DBSTAT_VTAB",
#endif
#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
 "ENABLE_EXPENSIVE_ASSERT",
#endif
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 "ENABLE_EXPLAIN_COMMENTS",
#endif
#ifdef SQLITE_ENABLE_FTS3
 "ENABLE_FTS3",
#endif
#ifdef SQLITE_ENABLE_FTS3_PARENTHESIS
 "ENABLE_FTS3_PARENTHESIS",
#endif
#ifdef SQLITE_ENABLE_FTS3_TOKENIZER
 "ENABLE_FTS3_TOKENIZER",
#endif
#ifdef SQLITE_ENABLE_FTS4
 "ENABLE_FTS4",
#endif
#ifdef SQLITE_ENABLE_FTS5
 "ENABLE_FTS5",
#endif
#ifdef SQLITE_ENABLE_GEOPOLY
 "ENABLE_GEOPOLY",
#endif
#ifdef SQLITE_ENABLE_HIDDEN_COLUMNS
 "ENABLE_HIDDEN_COLUMNS",
#endif
#ifdef SQLITE_ENABLE_ICU
 "ENABLE_ICU",
#endif
#ifdef SQLITE_ENABLE_IOTRACE
 "ENABLE_IOTRACE",
#endif
#ifdef SQLITE_ENABLE_JSON1
 "ENABLE_JSON1",
#endif
#ifdef SQLITE_ENABLE_LOAD_EXTENSION
 "ENABLE_LOAD_EXTENSION",
#endif
#ifdef SQLITE_ENABLE_LOCKING_STYLE
 "ENABLE_LOCKING_STYLE=" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),
#endif
#ifdef SQLITE_ENABLE_MATH_FUNCTIONS
 "ENABLE_MATH_FUNCTIONS",
#endif
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 "ENABLE_MEMORY_MANAGEMENT",
#endif
#ifdef SQLITE_ENABLE_MEMSYS3
 "ENABLE_MEMSYS3",
#endif
#ifdef SQLITE_ENABLE_MEMSYS5
 "ENABLE_MEMSYS5",
#endif
#ifdef SQLITE_ENABLE_MULTIPLEX
 "ENABLE_MULTIPLEX",
#endif
#ifdef SQLITE_ENABLE_NORMALIZE
 "ENABLE_NORMALIZE",
#endif
#ifdef SQLITE_ENABLE_NULL_TRIM
 "ENABLE_NULL_TRIM",
#endif
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
 "ENABLE_OFFSET_SQL_FUNC",
#endif
#ifdef SQLITE_ENABLE_OVERSIZE_CELL_CHECK
 "ENABLE_OVERSIZE_CELL_CHECK",
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 "ENABLE_PREUPDATE_HOOK",
#endif
#ifdef SQLITE_ENABLE_QPSG
 "ENABLE_QPSG",
#endif
#ifdef SQLITE_ENABLE_RBU
 "ENABLE_RBU",
#endif
#ifdef SQLITE_ENABLE_RTREE
 "ENABLE_RTREE",
#endif
#ifdef SQLITE_ENABLE_SELECTTRACE
 "ENABLE_SELECTTRACE",
#endif
#ifdef SQLITE_ENABLE_SESSION
 "ENABLE_SESSION",
#endif
#ifdef SQLITE_ENABLE_SNAPSHOT
 "ENABLE_SNAPSHOT",
#endif
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 "ENABLE_SORTER_REFERENCES",
#endif
#ifdef SQLITE_ENABLE_SQLLOG
 "ENABLE_SQLLOG",
#endif
#ifdef SQLITE_ENABLE_STAT4
 "ENABLE_STAT4",
#endif
#ifdef SQLITE_ENABLE_STMTVTAB
 "ENABLE_STMTVTAB",
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 "ENABLE_STMT_SCANSTATUS",
#endif
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
 "ENABLE_UNKNOWN_SQL_FUNCTION",
#endif
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
 "ENABLE_UNLOCK_NOTIFY",
#endif
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 "ENABLE_UPDATE_DELETE_LIMIT",
#endif
#ifdef SQLITE_ENABLE_URI_00_ERROR
 "ENABLE_URI_00_ERROR",
#endif
#ifdef SQLITE_ENABLE_VFSTRACE
 "ENABLE_VFSTRACE",
#endif
#ifdef SQLITE_ENABLE_WHERETRACE
 "ENABLE_WHERETRACE",
#endif
#ifdef SQLITE_ENABLE_ZIPVFS
 "ENABLE_ZIPVFS",
#endif
#ifdef SQLITE_EXPLAIN_ESTIMATED_ROWS
 "EXPLAIN_ESTIMATED_ROWS",
#endif
#ifdef SQLITE_EXTRA_IFNULLROW
 "EXTRA_IFNULLROW",
#endif
#ifdef SQLITE_EXTRA_INIT
 "EXTRA_INIT=" CTIMEOPT_VAL(SQLITE_EXTRA_INIT),
#endif
#ifdef SQLITE_EXTRA_SHUTDOWN
 "EXTRA_SHUTDOWN=" CTIMEOPT_VAL(SQLITE_EXTRA_SHUTDOWN),
#endif
#ifdef SQLITE_FTS3_MAX_EXPR_DEPTH
 "FTS3_MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_FTS3_MAX_EXPR_DEPTH),
#endif
#ifdef SQLITE_FTS5_ENABLE_TEST_MI
 "FTS5_ENABLE_TEST_MI",
#endif
#ifdef SQLITE_FTS5_NO_WITHOUT_ROWID
 "FTS5_NO_WITHOUT_ROWID",
#endif
#if HAVE_ISNAN || SQLITE_HAVE_ISNAN
 "HAVE_ISNAN",
#endif
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
# if SQLITE_HOMEGROWN_RECURSIVE_MUTEX != 1
 "HOMEGROWN_RECURSIVE_MUTEX=" CTIMEOPT_VAL(SQLITE_HOMEGROWN_RECURSIVE_MUTEX),
# endif
#endif
#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS
 "IGNORE_AFP_LOCK_ERRORS",
#endif
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
 "IGNORE_FLOCK_LOCK_ERRORS",
#endif
#ifdef SQLITE_INLINE_MEMCPY
 "INLINE_MEMCPY",
#endif
#ifdef SQLITE_INT64_TYPE
 "INT64_TYPE",
#endif
#ifdef SQLITE_INTEGRITY_CHECK_ERROR_MAX
 "INTEGRITY_CHECK_ERROR_MAX=" CTIMEOPT_VAL(SQLITE_INTEGRITY_CHECK_ERROR_MAX),
#endif
#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 "LIKE_DOESNT_MATCH_BLOBS",
#endif
#ifdef SQLITE_LOCK_TRACE
 "LOCK_TRACE",
#endif
#ifdef SQLITE_LOG_CACHE_SPILL
 "LOG_CACHE_SPILL",
#endif
#ifdef SQLITE_MALLOC_SOFT_LIMIT
 "MALLOC_SOFT_LIMIT=" CTIMEOPT_VAL(SQLITE_MALLOC_SOFT_LIMIT),
#endif
#ifdef SQLITE_MAX_ATTACHED
 "MAX_ATTACHED=" CTIMEOPT_VAL(SQLITE_MAX_ATTACHED),
#endif
#ifdef SQLITE_MAX_COLUMN
 "MAX_COLUMN=" CTIMEOPT_VAL(SQLITE_MAX_COLUMN),
#endif
#ifdef SQLITE_MAX_COMPOUND_SELECT
 "MAX_COMPOUND_SELECT=" CTIMEOPT_VAL(SQLITE_MAX_COMPOUND_SELECT),
#endif
#ifdef SQLITE_MAX_DEFAULT_PAGE_SIZE
 "MAX_DEFAULT_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_DEFAULT_PAGE_SIZE),
#endif
#ifdef SQLITE_MAX_EXPR_DEPTH
 "MAX_EXPR_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_EXPR_DEPTH),
#endif
#ifdef SQLITE_MAX_FUNCTION_ARG
 "MAX_FUNCTION_ARG=" CTIMEOPT_VAL(SQLITE_MAX_FUNCTION_ARG),
#endif
#ifdef SQLITE_MAX_LENGTH
 "MAX_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LENGTH),
#endif
#ifdef SQLITE_MAX_LIKE_PATTERN_LENGTH
 "MAX_LIKE_PATTERN_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_LIKE_PATTERN_LENGTH),
#endif
#ifdef SQLITE_MAX_MEMORY
 "MAX_MEMORY=" CTIMEOPT_VAL(SQLITE_MAX_MEMORY),
#endif
#ifdef SQLITE_MAX_MMAP_SIZE
 "MAX_MMAP_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE),
#endif
#ifdef SQLITE_MAX_MMAP_SIZE_
 "MAX_MMAP_SIZE_=" CTIMEOPT_VAL(SQLITE_MAX_MMAP_SIZE_),
#endif
#ifdef SQLITE_MAX_PAGE_COUNT
 "MAX_PAGE_COUNT=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_COUNT),
#endif
#ifdef SQLITE_MAX_PAGE_SIZE
 "MAX_PAGE_SIZE=" CTIMEOPT_VAL(SQLITE_MAX_PAGE_SIZE),
#endif
#ifdef SQLITE_MAX_SCHEMA_RETRY
 "MAX_SCHEMA_RETRY=" CTIMEOPT_VAL(SQLITE_MAX_SCHEMA_RETRY),
#endif
#ifdef SQLITE_MAX_SQL_LENGTH
 "MAX_SQL_LENGTH=" CTIMEOPT_VAL(SQLITE_MAX_SQL_LENGTH),
#endif
#ifdef SQLITE_MAX_TRIGGER_DEPTH
 "MAX_TRIGGER_DEPTH=" CTIMEOPT_VAL(SQLITE_MAX_TRIGGER_DEPTH),
#endif
#ifdef SQLITE_MAX_VARIABLE_NUMBER
 "MAX_VARIABLE_NUMBER=" CTIMEOPT_VAL(SQLITE_MAX_VARIABLE_NUMBER),
#endif
#ifdef SQLITE_MAX_VDBE_OP
 "MAX_VDBE_OP=" CTIMEOPT_VAL(SQLITE_MAX_VDBE_OP),
#endif
#ifdef SQLITE_MAX_WORKER_THREADS
 "MAX_WORKER_THREADS=" CTIMEOPT_VAL(SQLITE_MAX_WORKER_THREADS),
#endif
#ifdef SQLITE_MEMDEBUG
 "MEMDEBUG",
#endif
#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
 "MIXED_ENDIAN_64BIT_FLOAT",
#endif
#ifdef SQLITE_MMAP_READWRITE
 "MMAP_READWRITE",
#endif
#ifdef SQLITE_MUTEX_NOOP
 "MUTEX_NOOP",
#endif
#ifdef SQLITE_MUTEX_OMIT
 "MUTEX_OMIT",
#endif
#ifdef SQLITE_MUTEX_PTHREADS
 "MUTEX_PTHREADS",
#endif
#ifdef SQLITE_MUTEX_W32
 "MUTEX_W32",
#endif
#ifdef SQLITE_NEED_ERR_NAME
 "NEED_ERR_NAME",
#endif
#ifdef SQLITE_NO_SYNC
 "NO_SYNC",
#endif
#ifdef SQLITE_OMIT_ALTERTABLE
 "OMIT_ALTERTABLE",
#endif
#ifdef SQLITE_OMIT_ANALYZE
 "OMIT_ANALYZE",
#endif
#ifdef SQLITE_OMIT_ATTACH
 "OMIT_ATTACH",
#endif
#ifdef SQLITE_OMIT_AUTHORIZATION
 "OMIT_AUTHORIZATION",
#endif
#ifdef SQLITE_OMIT_AUTOINCREMENT
 "OMIT_AUTOINCREMENT",
#endif
#ifdef SQLITE_OMIT_AUTOINIT
 "OMIT_AUTOINIT",
#endif
#ifdef SQLITE_OMIT_AUTOMATIC_INDEX
 "OMIT_AUTOMATIC_INDEX",
#endif
#ifdef SQLITE_OMIT_AUTORESET
 "OMIT_AUTORESET",
#endif
#ifdef SQLITE_OMIT_AUTOVACUUM
 "OMIT_AUTOVACUUM",
#endif
#ifdef SQLITE_OMIT_BETWEEN_OPTIMIZATION
 "OMIT_BETWEEN_OPTIMIZATION",
#endif
#ifdef SQLITE_OMIT_BLOB_LITERAL
 "OMIT_BLOB_LITERAL",
#endif
#ifdef SQLITE_OMIT_CAST
 "OMIT_CAST",
#endif
#ifdef SQLITE_OMIT_CHECK
 "OMIT_CHECK",
#endif
#ifdef SQLITE_OMIT_COMPLETE
 "OMIT_COMPLETE",
#endif
#ifdef SQLITE_OMIT_COMPOUND_SELECT
 "OMIT_COMPOUND_SELECT",
#endif
#ifdef SQLITE_OMIT_CONFLICT_CLAUSE
 "OMIT_CONFLICT_CLAUSE",
#endif
#ifdef SQLITE_OMIT_CTE
 "OMIT_CTE",
#endif
#if defined(SQLITE_OMIT_DATETIME_FUNCS) || defined(SQLITE_OMIT_FLOATING_POINT)
 "OMIT_DATETIME_FUNCS",
#endif
#ifdef SQLITE_OMIT_DECLTYPE
 "OMIT_DECLTYPE",
#endif
#ifdef SQLITE_OMIT_DEPRECATED
 "OMIT_DEPRECATED",
#endif
#ifdef SQLITE_OMIT_DESERIALIZE
 "OMIT_DESERIALIZE",
#endif
#ifdef SQLITE_OMIT_DISKIO
 "OMIT_DISKIO",
#endif
#ifdef SQLITE_OMIT_EXPLAIN
 "OMIT_EXPLAIN",
#endif
#ifdef SQLITE_OMIT_FLAG_PRAGMAS
 "OMIT_FLAG_PRAGMAS",
#endif
#ifdef SQLITE_OMIT_FLOATING_POINT
 "OMIT_FLOATING_POINT",
#endif
#ifdef SQLITE_OMIT_FOREIGN_KEY
 "OMIT_FOREIGN_KEY",
#endif
#ifdef SQLITE_OMIT_GET_TABLE
 "OMIT_GET_TABLE",
#endif
#ifdef SQLITE_OMIT_HEX_INTEGER
 "OMIT_HEX_INTEGER",
#endif
#ifdef SQLITE_OMIT_INCRBLOB
 "OMIT_INCRBLOB",
#endif
#ifdef SQLITE_OMIT_INTEGRITY_CHECK
 "OMIT_INTEGRITY_CHECK",
#endif
#ifdef SQLITE_OMIT_INTROSPECTION_PRAGMAS
 "OMIT_INTROSPECTION_PRAGMAS",
#endif
#ifdef SQLITE_OMIT_LIKE_OPTIMIZATION
 "OMIT_LIKE_OPTIMIZATION",
#endif
#ifdef SQLITE_OMIT_LOAD_EXTENSION
 "OMIT_LOAD_EXTENSION",
#endif
#ifdef SQLITE_OMIT_LOCALTIME
 "OMIT_LOCALTIME",
#endif
#ifdef SQLITE_OMIT_LOOKASIDE
 "OMIT_LOOKASIDE",
#endif
#ifdef SQLITE_OMIT_MEMORYDB
 "OMIT_MEMORYDB",
#endif
#ifdef SQLITE_OMIT_OR_OPTIMIZATION
 "OMIT_OR_OPTIMIZATION",
#endif
#ifdef SQLITE_OMIT_PAGER_PRAGMAS
 "OMIT_PAGER_PRAGMAS",
#endif
#ifdef SQLITE_OMIT_PARSER_TRACE
 "OMIT_PARSER_TRACE",
#endif
#ifdef SQLITE_OMIT_POPEN
 "OMIT_POPEN",
#endif
#ifdef SQLITE_OMIT_PRAGMA
 "OMIT_PRAGMA",
#endif
#ifdef SQLITE_OMIT_PROGRESS_CALLBACK
 "OMIT_PROGRESS_CALLBACK",
#endif
#ifdef SQLITE_OMIT_QUICKBALANCE
 "OMIT_QUICKBALANCE",
#endif
#ifdef SQLITE_OMIT_REINDEX
 "OMIT_REINDEX",
#endif
#ifdef SQLITE_OMIT_SCHEMA_PRAGMAS
 "OMIT_SCHEMA_PRAGMAS",
#endif
#ifdef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
 "OMIT_SCHEMA_VERSION_PRAGMAS",
#endif
#ifdef SQLITE_OMIT_SHARED_CACHE
 "OMIT_SHARED_CACHE",
#endif
#ifdef SQLITE_OMIT_SHUTDOWN_DIRECTORIES
 "OMIT_SHUTDOWN_DIRECTORIES",
#endif
#ifdef SQLITE_OMIT_SUBQUERY
 "OMIT_SUBQUERY",
#endif
#ifdef SQLITE_OMIT_TCL_VARIABLE
 "OMIT_TCL_VARIABLE",
#endif
#ifdef SQLITE_OMIT_TEMPDB
 "OMIT_TEMPDB",
#endif
#ifdef SQLITE_OMIT_TEST_CONTROL
 "OMIT_TEST_CONTROL",
#endif
#ifdef SQLITE_OMIT_TRACE
# if SQLITE_OMIT_TRACE != 1
 "OMIT_TRACE=" CTIMEOPT_VAL(SQLITE_OMIT_TRACE),
# endif
#endif
#ifdef SQLITE_OMIT_TRIGGER
 "OMIT_TRIGGER",
#endif
#ifdef SQLITE_OMIT_TRUNCATE_OPTIMIZATION
 "OMIT_TRUNCATE_OPTIMIZATION",
#endif
#ifdef SQLITE_OMIT_UTF16
 "OMIT_UTF16",
#endif
#ifdef SQLITE_OMIT_VACUUM
 "OMIT_VACUUM",
#endif
#ifdef SQLITE_OMIT_VIEW
 "OMIT_VIEW",
#endif
#ifdef SQLITE_OMIT_VIRTUALTABLE
 "OMIT_VIRTUALTABLE",
#endif
#ifdef SQLITE_OMIT_WAL
 "OMIT_WAL",
#endif
#ifdef SQLITE_OMIT_WSD
 "OMIT_WSD",
#endif
#ifdef SQLITE_OMIT_XFER_OPT
 "OMIT_XFER_OPT",
#endif
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
 "PCACHE_SEPARATE_HEADER",
#endif
#ifdef SQLITE_PERFORMANCE_TRACE
 "PERFORMANCE_TRACE",
#endif
#ifdef SQLITE_POWERSAFE_OVERWRITE
# if SQLITE_POWERSAFE_OVERWRITE != 1
 "POWERSAFE_OVERWRITE=" CTIMEOPT_VAL(SQLITE_POWERSAFE_OVERWRITE),
# endif
#endif
#ifdef SQLITE_PREFER_PROXY_LOCKING
 "PREFER_PROXY_LOCKING",
#endif
#ifdef SQLITE_PROXY_DEBUG
 "PROXY_DEBUG",
#endif
#ifdef SQLITE_REVERSE_UNORDERED_SELECTS
 "REVERSE_UNORDERED_SELECTS",
#endif
#ifdef SQLITE_RTREE_INT_ONLY
 "RTREE_INT_ONLY",
#endif
#ifdef SQLITE_SECURE_DELETE
 "SECURE_DELETE",
#endif
#ifdef SQLITE_SMALL_STACK
 "SMALL_STACK",
#endif
#ifdef SQLITE_SORTER_PMASZ
 "SORTER_PMASZ=" CTIMEOPT_VAL(SQLITE_SORTER_PMASZ),
#endif
#ifdef SQLITE_SOUNDEX
 "SOUNDEX",
#endif
#ifdef SQLITE_STAT4_SAMPLES
 "STAT4_SAMPLES=" CTIMEOPT_VAL(SQLITE_STAT4_SAMPLES),
#endif
#ifdef SQLITE_STMTJRNL_SPILL
 "STMTJRNL_SPILL=" CTIMEOPT_VAL(SQLITE_STMTJRNL_SPILL),
#endif
#ifdef SQLITE_SUBSTR_COMPATIBILITY
 "SUBSTR_COMPATIBILITY",
#endif
#if (!defined(SQLITE_WIN32_MALLOC)   && !defined(SQLITE_ZERO_MALLOC)   && !defined(SQLITE_MEMDEBUG)  ) || defined(SQLITE_SYSTEM_MALLOC)

 "SYSTEM_MALLOC",
#endif
#ifdef SQLITE_TCL
 "TCL",
#endif
#ifdef SQLITE_TEMP_STORE
 "TEMP_STORE=" CTIMEOPT_VAL(SQLITE_TEMP_STORE),
#endif
#ifdef SQLITE_TEST
 "TEST",
#endif
#if defined(SQLITE_THREADSAFE)
 "THREADSAFE=" CTIMEOPT_VAL(SQLITE_THREADSAFE),
#elif defined(THREADSAFE)
 "THREADSAFE=" CTIMEOPT_VAL(THREADSAFE),
#else
 "THREADSAFE=1",
#endif
#ifdef SQLITE_UNLINK_AFTER_CLOSE
 "UNLINK_AFTER_CLOSE",
#endif
#ifdef SQLITE_UNTESTABLE
 "UNTESTABLE",
#endif
#ifdef SQLITE_USER_AUTHENTICATION
 "USER_AUTHENTICATION",
#endif
#ifdef SQLITE_USE_ALLOCA
 "USE_ALLOCA",
#endif
#ifdef SQLITE_USE_FCNTL_TRACE
 "USE_FCNTL_TRACE",
#endif
#ifdef SQLITE_USE_URI
 "USE_URI",
#endif
#ifdef SQLITE_VDBE_COVERAGE
 "VDBE_COVERAGE",
#endif
#ifdef SQLITE_WIN32_MALLOC
 "WIN32_MALLOC",
#endif
#ifdef SQLITE_ZERO_MALLOC
 "ZERO_MALLOC",
#endif
}; SQLITE_PRIVATE const char **sqlite3CompileOptions(int *pnOpt){  *pnOpt = sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]);  return (const char**)sqlite3azCompileOpt; }
#endif
SQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {
#ifdef SQLITE_ASCII
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,   18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,   36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,   54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,  104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,  122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,  108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,  126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,  162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,  180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,  198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,  216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,  234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,  252,253,254,255,
#endif
#ifdef SQLITE_EBCDIC
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175,  176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207,  208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223,  224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239,  240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,
#endif
  1, 0, 0, 1, 1, 0,   0, 1, 0, 1, 0, 1,   1, 0, 1, 0, 0, 1 }; SQLITE_PRIVATE const unsigned char *sqlite3aLTb = &sqlite3UpperToLower[256-OP_Ne]; SQLITE_PRIVATE const unsigned char *sqlite3aEQb = &sqlite3UpperToLower[256+6-OP_Ne]; SQLITE_PRIVATE const unsigned char *sqlite3aGTb = &sqlite3UpperToLower[256+12-OP_Ne]; SQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40 };
#ifndef SQLITE_USE_URI
# define SQLITE_USE_URI 0
#endif
#if !defined(SQLITE_ALLOW_COVERING_INDEX_SCAN)
# define SQLITE_ALLOW_COVERING_INDEX_SCAN 1
#else
# if !SQLITE_ALLOW_COVERING_INDEX_SCAN
#  error "Compile-time disabling of covering index scan using the -DSQLITE_ALLOW_COVERING_INDEX_SCAN=0 option is deprecated. Contact SQLite developers if this is a problem for you, and delete this #error macro to continue with your build."

# endif
#endif
#ifndef SQLITE_SORTER_PMASZ
# define SQLITE_SORTER_PMASZ 250
#endif
#ifndef SQLITE_STMTJRNL_SPILL
# define SQLITE_STMTJRNL_SPILL (64*1024)
#endif
#ifndef SQLITE_DEFAULT_LOOKASIDE
# ifdef SQLITE_OMIT_TWOSIZE_LOOKASIDE
#  define SQLITE_DEFAULT_LOOKASIDE 1200,100
# else
#  define SQLITE_DEFAULT_LOOKASIDE 1200,40
# endif
#endif
#ifndef SQLITE_MEMDB_DEFAULT_MAXSIZE
# define SQLITE_MEMDB_DEFAULT_MAXSIZE 1073741824
#endif
SQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {   SQLITE_DEFAULT_MEMSTATUS,   1,   SQLITE_THREADSAFE==1,   SQLITE_USE_URI,   SQLITE_ALLOW_COVERING_INDEX_SCAN,   0,   1,   0x7ffffffe,   0,   SQLITE_DEFAULT_LOOKASIDE,   SQLITE_STMTJRNL_SPILL,   {0,0,0,0,0,0,0,0},   {0,0,0,0,0,0,0,0,0},   {0,0,0,0,0,0,0,0,0,0,0,0,0},   (void*)0,   0,   0, 0,   SQLITE_DEFAULT_MMAP_SIZE,   SQLITE_MAX_MMAP_SIZE,   (void*)0,   0,   SQLITE_DEFAULT_PCACHE_INITSZ,   0,   0,   SQLITE_SORTER_PMASZ,   0,   0,   0,   0,   0,   0,   0,   0,   0,
#ifdef SQLITE_ENABLE_SQLLOG
  0,   0,
#endif
#ifdef SQLITE_VDBE_COVERAGE
  0,   0,
#endif
#ifndef SQLITE_OMIT_DESERIALIZE
  SQLITE_MEMDB_DEFAULT_MAXSIZE,
#endif
#ifndef SQLITE_UNTESTABLE
  0,
#endif
  0,   0x7ffffffe,   SQLITE_DEFAULT_SORTERREF_SIZE,   0, }; SQLITE_PRIVATE FuncDefHash sqlite3BuiltinFunctions;
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)
SQLITE_PRIVATE unsigned int sqlite3CoverageCounter;
#endif
#ifdef VDBE_PROFILE
SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt = 0;
#endif
#ifndef SQLITE_OMIT_WSD
SQLITE_PRIVATE int sqlite3PendingByte = 0x40000000;
#endif
SQLITE_PRIVATE u32 sqlite3SelectTrace = 0; SQLITE_PRIVATE u32 sqlite3WhereTrace = 0; SQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER; SQLITE_PRIVATE const char sqlite3StrBINARY[] = "BINARY"; SQLITE_PRIVATE const unsigned char sqlite3StdTypeLen[] = { 3, 4, 3, 7, 4, 4 }; SQLITE_PRIVATE const char sqlite3StdTypeAffinity[] = {  SQLITE_AFF_NUMERIC,  SQLITE_AFF_BLOB,  SQLITE_AFF_INTEGER,  SQLITE_AFF_INTEGER,  SQLITE_AFF_REAL,  SQLITE_AFF_TEXT }; SQLITE_PRIVATE const char sqlite3StdTypeMap[] = {  0,  SQLITE_BLOB,  SQLITE_INTEGER,  SQLITE_INTEGER,  SQLITE_FLOAT,  SQLITE_TEXT }; SQLITE_PRIVATE const char *sqlite3StdType[] = {  "ANY",  "BLOB",  "INT",  "INTEGER",  "REAL",  "TEXT" };
#ifndef SQLITE_VDBEINT_H
#define SQLITE_VDBEINT_H
#ifndef SQLITE_MAX_SCHEMA_RETRY
# define SQLITE_MAX_SCHEMA_RETRY 50
#endif
#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG)   || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)   || defined(SQLITE_ENABLE_BYTECODE_VTAB)

# define VDBE_DISPLAY_P4 1
#else
# define VDBE_DISPLAY_P4 0
#endif
typedef struct VdbeOp Op; typedef unsigned Bool; typedef struct VdbeSorter VdbeSorter; typedef struct AuxData AuxData;
#define CURTYPE_BTREE  0
#define CURTYPE_SORTER 1
#define CURTYPE_VTAB 2
#define CURTYPE_PSEUDO 3
typedef struct VdbeCursor VdbeCursor; struct VdbeCursor {  u8 eCurType;  i8 iDb;  u8 nullRow;  u8 deferredMoveto;  u8 isTable;
#ifdef SQLITE_DEBUG
 u8 seekOp;  u8 wrFlag;
#endif
 Bool isEphemeral:1;  Bool useRandomRowid:1;  Bool isOrdered:1;  Bool hasBeenDuped:1;  u16 seekHit;  Btree *pBtx;  i64 seqCount;  u32 *aAltMap;  u32 cacheStatus;  int seekResult;  VdbeCursor *pAltCursor;  union {  BtCursor *pCursor;  sqlite3_vtab_cursor *pVCur;  VdbeSorter *pSorter;  } uc;  KeyInfo *pKeyInfo;  u32 iHdrOffset;  Pgno pgnoRoot;  i16 nField;  u16 nHdrParsed;  i64 movetoTarget;  u32 *aOffset;  const u8 *aRow;  u32 payloadSize;  u32 szRow;
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
 u64 maskUsed;
#endif
 u32 aType[1]; };
#define CACHE_STALE 0
typedef struct VdbeFrame VdbeFrame; struct VdbeFrame {  Vdbe *v;  VdbeFrame *pParent;  Op *aOp;  i64 *anExec;  Mem *aMem;  VdbeCursor **apCsr;  u8 *aOnce;  void *token;  i64 lastRowid;  AuxData *pAuxData;
#if SQLITE_DEBUG
 u32 iFrameMagic;
#endif
 int nCursor;  int pc;  int nOp;  int nMem;  int nChildMem;  int nChildCsr;  i64 nChange;  i64 nDbChange; };
#define SQLITE_FRAME_MAGIC 0x879fb71e
#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))])
struct sqlite3_value {  union MemValue {  double r;  i64 i;  int nZero;  const char *zPType;  FuncDef *pDef;  } u;  u16 flags;  u8 enc;  u8 eSubtype;  int n;  char *z;  char *zMalloc;  int szMalloc;  u32 uTemp;  sqlite3 *db;  void (*xDel)(void*);
#ifdef SQLITE_DEBUG
 Mem *pScopyFrom;  u16 mScopyFlags;
#endif
};
#define MEMCELLSIZE offsetof(Mem,zMalloc)
#define MEM_Null 0x0001
#define MEM_Str  0x0002
#define MEM_Int  0x0004
#define MEM_Real 0x0008
#define MEM_Blob 0x0010
#define MEM_IntReal  0x0020
#define MEM_AffMask  0x003f
#define MEM_FromBind 0x0040
#define MEM_Undefined 0x0080
#define MEM_Cleared  0x0100
#define MEM_TypeMask 0xc1bf
#define MEM_Term 0x0200
#define MEM_Dyn  0x0400
#define MEM_Static 0x0800
#define MEM_Ephem  0x1000
#define MEM_Agg  0x2000
#define MEM_Zero 0x4000
#define MEM_Subtype  0x8000
#ifdef SQLITE_OMIT_INCRBLOB
 #undef MEM_Zero
 #define MEM_Zero 0x0000
#endif
#define VdbeMemDynamic(X)  (((X)->flags&(MEM_Agg|MEM_Dyn))!=0)

#define MemSetTypeFlag(p, f)   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)

#define MemNullNochng(X)  (((X)->flags&MEM_TypeMask)==(MEM_Null|MEM_Zero)  && (X)->n==0 && (X)->u.nZero==0)

#ifdef SQLITE_DEBUG
#define memIsValid(M) ((M)->flags & MEM_Undefined)==0
#endif
struct AuxData {  int iAuxOp;  int iAuxArg;  void *pAux;  void (*xDeleteAux)(void*);  AuxData *pNextAux; }; struct sqlite3_context {  Mem *pOut;  FuncDef *pFunc;  Mem *pMem;  Vdbe *pVdbe;  int iOp;  int isError;  u8 skipFlag;  u8 argc;  sqlite3_value *argv[1]; }; typedef unsigned bft; typedef struct ScanStatus ScanStatus; struct ScanStatus {  int addrExplain;  int addrLoop;  int addrVisit;  int iSelectID;  LogEst nEst;  char *zName; }; typedef struct DblquoteStr DblquoteStr; struct DblquoteStr {  DblquoteStr *pNextStr;  char z[8]; }; struct Vdbe {  sqlite3 *db;  Vdbe *pPrev,*pNext;  Parse *pParse;  ynVar nVar;  u32 iVdbeMagic;  int nMem;  int nCursor;  u32 cacheCtr;  int pc;  int rc;  i64 nChange;  int iStatement;  i64 iCurrentTime;  i64 nFkConstraint;  i64 nStmtDefCons;  i64 nStmtDefImmCons;  Mem *aMem;  Mem **apArg;  VdbeCursor **apCsr;  Mem *aVar;  Op *aOp;  int nOp;  int nOpAlloc;  Mem *aColName;  Mem *pResultSet;  char *zErrMsg;  VList *pVList;
#ifndef SQLITE_OMIT_TRACE
 i64 startTime;
#endif
#ifdef SQLITE_DEBUG
 int rcApp;  u32 nWrite;
#endif
 u16 nResColumn;  u8 errorAction;  u8 minWriteFileFormat;  u8 prepFlags;  u8 doingRerun;  bft expired:2;  bft explain:2;  bft changeCntOn:1;  bft runOnlyOnce:1;  bft usesStmtJournal:1;  bft readOnly:1;  bft bIsReader:1;  yDbMask btreeMask;  yDbMask lockMask;  u32 aCounter[7];  char *zSql;
#ifdef SQLITE_ENABLE_NORMALIZE
 char *zNormSql;  DblquoteStr *pDblStr;
#endif
 void *pFree;  VdbeFrame *pFrame;  VdbeFrame *pDelFrame;  int nFrame;  u32 expmask;  SubProgram *pProgram;  AuxData *pAuxData;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 i64 *anExec;  int nScan;  ScanStatus *aScan;
#endif
};
#define VDBE_MAGIC_INIT  0x16bceaa5
#define VDBE_MAGIC_RUN 0x2df20da3
#define VDBE_MAGIC_HALT  0x319c2973
#define VDBE_MAGIC_RESET 0x48fa9f76
#define VDBE_MAGIC_DEAD  0x5606c3c8
struct PreUpdate {  Vdbe *v;  VdbeCursor *pCsr;  int op;  u8 *aRecord;  KeyInfo keyinfo;  UnpackedRecord *pUnpacked;  UnpackedRecord *pNewUnpacked;  int iNewReg;  int iBlobWrite;  i64 iKey1;  i64 iKey2;  Mem *aNew;  Table *pTab;  Index *pPk; }; SQLITE_PRIVATE void sqlite3VdbeError(Vdbe*, const char *, ...); SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*); void sqliteVdbePopStack(Vdbe*,int); SQLITE_PRIVATE int SQLITE_NOINLINE sqlite3VdbeFinishMoveto(VdbeCursor*); SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor**, u32*); SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor*); SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32); SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8); SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(unsigned char*, Mem*, u32); SQLITE_PRIVATE u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*); SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int); int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *); SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*); SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*); SQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*);
#if !defined(SQLITE_OMIT_EXPLAIN) || defined(SQLITE_ENABLE_BYTECODE_VTAB)
SQLITE_PRIVATE int sqlite3VdbeNextOpcode(Vdbe*,Mem*,int,int*,int*,Op**); SQLITE_PRIVATE char *sqlite3VdbeDisplayP4(sqlite3*,Op*);
#endif
#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)
SQLITE_PRIVATE char *sqlite3VdbeDisplayComment(sqlite3*,const Op*,const char*);
#endif
#if !defined(SQLITE_OMIT_EXPLAIN)
SQLITE_PRIVATE int sqlite3VdbeList(Vdbe*);
#endif
SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*); SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int); SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem*, const Mem*); SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int); SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem*, Mem*); SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, i64, u8, void(*)(void*)); SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64);
#ifdef SQLITE_OMIT_FLOATING_POINT
# define sqlite3VdbeMemSetDouble sqlite3VdbeMemSetInt64
#else
SQLITE_PRIVATE  void sqlite3VdbeMemSetDouble(Mem*, double);
#endif
SQLITE_PRIVATE void sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*)); SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem*,sqlite3*,u16); SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*);
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*,int);
#else
SQLITE_PRIVATE int sqlite3VdbeMemSetZeroBlob(Mem*,int);
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3VdbeMemIsRowSet(const Mem*);
#endif
SQLITE_PRIVATE int sqlite3VdbeMemSetRowSet(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem*, u8, u8); SQLITE_PRIVATE int sqlite3IntFloatCompare(i64,double); SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*); SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*); SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem*, int ifNull); SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*); SQLITE_PRIVATE int sqlite3VdbeMemCast(Mem*,u8,u8); SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*); SQLITE_PRIVATE int sqlite3VdbeMemFromBtreeZeroOffset(BtCursor*,u32,Mem*); SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p); SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*);
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE int sqlite3VdbeMemAggValue(Mem*, Mem*, FuncDef*);
#endif
#if !defined(SQLITE_OMIT_EXPLAIN) || defined(SQLITE_ENABLE_BYTECODE_VTAB)
SQLITE_PRIVATE const char *sqlite3OpcodeName(int);
#endif
SQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve); SQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int n); SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *, int);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3VdbeFrameIsValid(VdbeFrame*);
#endif
SQLITE_PRIVATE void sqlite3VdbeFrameMemDel(void*); SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame*); SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(  Vdbe*,VdbeCursor*,int,const char*,Table*,i64,int,int);
#endif
SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p); SQLITE_PRIVATE int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *); SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *); SQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *); SQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *); SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *); SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *, int *); SQLITE_PRIVATE int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *); SQLITE_PRIVATE int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  void sqlite3VdbeIncrWriteCounter(Vdbe*, VdbeCursor*); SQLITE_PRIVATE  void sqlite3VdbeAssertAbortable(Vdbe*);
#else
# define sqlite3VdbeIncrWriteCounter(V,C)
# define sqlite3VdbeAssertAbortable(V)
#endif
#if !defined(SQLITE_OMIT_SHARED_CACHE)
SQLITE_PRIVATE  void sqlite3VdbeEnter(Vdbe*);
#else
# define sqlite3VdbeEnter(X)
#endif
#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0
SQLITE_PRIVATE  void sqlite3VdbeLeave(Vdbe*);
#else
# define sqlite3VdbeLeave(X)
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeMemAboutToChange(Vdbe*,Mem*); SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem*);
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *, int);
#else
# define sqlite3VdbeCheckFk(p,i) 0
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE  void sqlite3VdbePrintSql(Vdbe*); SQLITE_PRIVATE  void sqlite3VdbeMemPrettyPrint(Mem *pMem, StrAccum *pStr);
#endif
#ifndef SQLITE_OMIT_UTF16
SQLITE_PRIVATE  int sqlite3VdbeMemTranslate(Mem*, u8); SQLITE_PRIVATE  int sqlite3VdbeMemHandleBom(Mem *pMem);
#endif
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE  int sqlite3VdbeMemExpandBlob(Mem *);
 #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
#else
 #define sqlite3VdbeMemExpandBlob(x) SQLITE_OK
 #define ExpandBlob(P) SQLITE_OK
#endif
#endif
#if SQLITE_PTRSIZE>4
typedef sqlite3_int64 sqlite3StatValueType;
#else
typedef u32 sqlite3StatValueType;
#endif
typedef struct sqlite3StatType sqlite3StatType; static SQLITE_WSD struct sqlite3StatType {  sqlite3StatValueType nowValue[10];  sqlite3StatValueType mxValue[10]; } sqlite3Stat = { {0,}, {0,} }; static const char statMutex[] = {  0,  1,  1,  0,  0,  0,  0,  1,  0,  0, };
#ifdef SQLITE_OMIT_WSD
# define wsdStatInit sqlite3StatType *x = &GLOBAL(sqlite3StatType,sqlite3Stat)
# define wsdStat x[0]
#else
# define wsdStatInit
# define wsdStat sqlite3Stat
#endif
SQLITE_PRIVATE sqlite3_int64 sqlite3StatusValue(int op){  wsdStatInit;  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );  assert( op>=0 && op<ArraySize(statMutex) );  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()   : sqlite3MallocMutex()) );  return wsdStat.nowValue[op]; } SQLITE_PRIVATE void sqlite3StatusUp(int op, int N){  wsdStatInit;  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );  assert( op>=0 && op<ArraySize(statMutex) );  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()   : sqlite3MallocMutex()) );  wsdStat.nowValue[op] += N;  if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){  wsdStat.mxValue[op] = wsdStat.nowValue[op];  } } SQLITE_PRIVATE void sqlite3StatusDown(int op, int N){  wsdStatInit;  assert( N>=0 );  assert( op>=0 && op<ArraySize(statMutex) );  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()   : sqlite3MallocMutex()) );  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );  wsdStat.nowValue[op] -= N; } SQLITE_PRIVATE void sqlite3StatusHighwater(int op, int X){  sqlite3StatValueType newValue;  wsdStatInit;  assert( X>=0 );  newValue = (sqlite3StatValueType)X;  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );  assert( op>=0 && op<ArraySize(statMutex) );  assert( sqlite3_mutex_held(statMutex[op] ? sqlite3Pcache1Mutex()   : sqlite3MallocMutex()) );  assert( op==SQLITE_STATUS_MALLOC_SIZE  || op==SQLITE_STATUS_PAGECACHE_SIZE  || op==SQLITE_STATUS_PARSER_STACK );  if( newValue>wsdStat.mxValue[op] ){  wsdStat.mxValue[op] = newValue;  } } SQLITE_API int sqlite3_status64(  int op,  sqlite3_int64 *pCurrent,  sqlite3_int64 *pHighwater,  int resetFlag ){  sqlite3_mutex *pMutex;  wsdStatInit;  if( op<0 || op>=ArraySize(wsdStat.nowValue) ){  return SQLITE_MISUSE_BKPT;  }
#ifdef SQLITE_ENABLE_API_ARMOR
 if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;
#endif
 pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();  sqlite3_mutex_enter(pMutex);  *pCurrent = wsdStat.nowValue[op];  *pHighwater = wsdStat.mxValue[op];  if( resetFlag ){  wsdStat.mxValue[op] = wsdStat.nowValue[op];  }  sqlite3_mutex_leave(pMutex);  (void)pMutex;  return SQLITE_OK; } SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){  sqlite3_int64 iCur = 0, iHwtr = 0;  int rc;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( pCurrent==0 || pHighwater==0 ) return SQLITE_MISUSE_BKPT;
#endif
 rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);  if( rc==0 ){  *pCurrent = (int)iCur;  *pHighwater = (int)iHwtr;  }  return rc; } static u32 countLookasideSlots(LookasideSlot *p){  u32 cnt = 0;  while( p ){  p = p->pNext;  cnt++;  }  return cnt; } SQLITE_PRIVATE int sqlite3LookasideUsed(sqlite3 *db, int *pHighwater){  u32 nInit = countLookasideSlots(db->lookaside.pInit);  u32 nFree = countLookasideSlots(db->lookaside.pFree);
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 nInit += countLookasideSlots(db->lookaside.pSmallInit);  nFree += countLookasideSlots(db->lookaside.pSmallFree);
#endif
 if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;  return db->lookaside.nSlot - (nInit+nFree); } SQLITE_API int sqlite3_db_status(  sqlite3 *db,  int op,  int *pCurrent,  int *pHighwater,  int resetFlag ){  int rc = SQLITE_OK;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || pCurrent==0|| pHighwater==0 ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  switch( op ){  case SQLITE_DBSTATUS_LOOKASIDE_USED: {  *pCurrent = sqlite3LookasideUsed(db, pHighwater);  if( resetFlag ){  LookasideSlot *p = db->lookaside.pFree;  if( p ){  while( p->pNext ) p = p->pNext;  p->pNext = db->lookaside.pInit;  db->lookaside.pInit = db->lookaside.pFree;  db->lookaside.pFree = 0;  }
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 p = db->lookaside.pSmallFree;  if( p ){  while( p->pNext ) p = p->pNext;  p->pNext = db->lookaside.pSmallInit;  db->lookaside.pSmallInit = db->lookaside.pSmallFree;  db->lookaside.pSmallFree = 0;  }
#endif
 }  break;  }  case SQLITE_DBSTATUS_LOOKASIDE_HIT:  case SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE:  case SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: {  testcase( op==SQLITE_DBSTATUS_LOOKASIDE_HIT );  testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE );  testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL );  assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 );  assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 );  *pCurrent = 0;  *pHighwater = db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT];  if( resetFlag ){  db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT] = 0;  }  break;  }  case SQLITE_DBSTATUS_CACHE_USED_SHARED:  case SQLITE_DBSTATUS_CACHE_USED: {  int totalUsed = 0;  int i;  sqlite3BtreeEnterAll(db);  for(i=0; i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  Pager *pPager = sqlite3BtreePager(pBt);  int nByte = sqlite3PagerMemUsed(pPager);  if( op==SQLITE_DBSTATUS_CACHE_USED_SHARED ){  nByte = nByte / sqlite3BtreeConnectionCount(pBt);  }  totalUsed += nByte;  }  }  sqlite3BtreeLeaveAll(db);  *pCurrent = totalUsed;  *pHighwater = 0;  break;  }  case SQLITE_DBSTATUS_SCHEMA_USED: {  int i;  int nByte = 0;  sqlite3BtreeEnterAll(db);  db->pnBytesFreed = &nByte;  for(i=0; i<db->nDb; i++){  Schema *pSchema = db->aDb[i].pSchema;  if( ALWAYS(pSchema!=0) ){  HashElem *p;  nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (  pSchema->tblHash.count  + pSchema->trigHash.count  + pSchema->idxHash.count  + pSchema->fkeyHash.count  );  nByte += sqlite3_msize(pSchema->tblHash.ht);  nByte += sqlite3_msize(pSchema->trigHash.ht);  nByte += sqlite3_msize(pSchema->idxHash.ht);  nByte += sqlite3_msize(pSchema->fkeyHash.ht);  for(p=sqliteHashFirst(&pSchema->trigHash); p; p=sqliteHashNext(p)){  sqlite3DeleteTrigger(db, (Trigger*)sqliteHashData(p));  }  for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){  sqlite3DeleteTable(db, (Table *)sqliteHashData(p));  }  }  }  db->pnBytesFreed = 0;  sqlite3BtreeLeaveAll(db);  *pHighwater = 0;  *pCurrent = nByte;  break;  }  case SQLITE_DBSTATUS_STMT_USED: {  struct Vdbe *pVdbe;  int nByte = 0;  db->pnBytesFreed = &nByte;  for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){  sqlite3VdbeClearObject(db, pVdbe);  sqlite3DbFree(db, pVdbe);  }  db->pnBytesFreed = 0;  *pHighwater = 0;  *pCurrent = nByte;  break;  }  case SQLITE_DBSTATUS_CACHE_SPILL:  op = SQLITE_DBSTATUS_CACHE_WRITE+1;  deliberate_fall_through  case SQLITE_DBSTATUS_CACHE_HIT:  case SQLITE_DBSTATUS_CACHE_MISS:  case SQLITE_DBSTATUS_CACHE_WRITE:{  int i;  int nRet = 0;  assert( SQLITE_DBSTATUS_CACHE_MISS==SQLITE_DBSTATUS_CACHE_HIT+1 );  assert( SQLITE_DBSTATUS_CACHE_WRITE==SQLITE_DBSTATUS_CACHE_HIT+2 );  for(i=0; i<db->nDb; i++){  if( db->aDb[i].pBt ){  Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);  sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);  }  }  *pHighwater = 0;  *pCurrent = nRet;  break;  }  case SQLITE_DBSTATUS_DEFERRED_FKS: {  *pHighwater = 0;  *pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;  break;  }  default: {  rc = SQLITE_ERROR;  }  }  sqlite3_mutex_leave(db->mutex);  return rc; }
#include <time.h>
#ifndef SQLITE_OMIT_DATETIME_FUNCS
#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) &&  (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)

struct tm *__cdecl localtime(const time_t *);
#endif
typedef struct DateTime DateTime; struct DateTime {  sqlite3_int64 iJD;  int Y, M, D;  int h, m;  int tz;  double s;  char validJD;  char rawS;  char validYMD;  char validHMS;  char validTZ;  char tzSet;  char isError; }; static int getDigits(const char *zDate, const char *zFormat, ...){  static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };  va_list ap;  int cnt = 0;  char nextC;  va_start(ap, zFormat);  do{  char N = zFormat[0] - '0';  char min = zFormat[1] - '0';  int val = 0;  u16 max;  assert( zFormat[2]>='a' && zFormat[2]<='f' );  max = aMx[zFormat[2] - 'a'];  nextC = zFormat[3];  val = 0;  while( N-- ){  if( !sqlite3Isdigit(*zDate) ){  goto end_getDigits;  }  val = val*10 + *zDate - '0';  zDate++;  }  if( val<(int)min || val>(int)max || (nextC!=0 && nextC!=*zDate) ){  goto end_getDigits;  }  *va_arg(ap,int*) = val;  zDate++;  cnt++;  zFormat += 4;  }while( nextC ); end_getDigits:  va_end(ap);  return cnt; } static int parseTimezone(const char *zDate, DateTime *p){  int sgn = 0;  int nHr, nMn;  int c;  while( sqlite3Isspace(*zDate) ){ zDate++; }  p->tz = 0;  c = *zDate;  if( c=='-' ){  sgn = -1;  }else if( c=='+' ){  sgn = +1;  }else if( c=='Z' || c=='z' ){  zDate++;  goto zulu_time;  }else{  return c!=0;  }  zDate++;  if( getDigits(zDate, "20b:20e", &nHr, &nMn)!=2 ){  return 1;  }  zDate += 5;  p->tz = sgn*(nMn + nHr*60); zulu_time:  while( sqlite3Isspace(*zDate) ){ zDate++; }  p->tzSet = 1;  return *zDate!=0; } static int parseHhMmSs(const char *zDate, DateTime *p){  int h, m, s;  double ms = 0.0;  if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){  return 1;  }  zDate += 5;  if( *zDate==':' ){  zDate++;  if( getDigits(zDate, "20e", &s)!=1 ){  return 1;  }  zDate += 2;  if( *zDate=='.' && sqlite3Isdigit(zDate[1]) ){  double rScale = 1.0;  zDate++;  while( sqlite3Isdigit(*zDate) ){  ms = ms*10.0 + *zDate - '0';  rScale *= 10.0;  zDate++;  }  ms /= rScale;  }  }else{  s = 0;  }  p->validJD = 0;  p->rawS = 0;  p->validHMS = 1;  p->h = h;  p->m = m;  p->s = s + ms;  if( parseTimezone(zDate, p) ) return 1;  p->validTZ = (p->tz!=0)?1:0;  return 0; } static void datetimeError(DateTime *p){  memset(p, 0, sizeof(*p));  p->isError = 1; } static void computeJD(DateTime *p){  int Y, M, D, A, B, X1, X2;  if( p->validJD ) return;  if( p->validYMD ){  Y = p->Y;  M = p->M;  D = p->D;  }else{  Y = 2000;  M = 1;  D = 1;  }  if( Y<-4713 || Y>9999 || p->rawS ){  datetimeError(p);  return;  }  if( M<=2 ){  Y--;  M += 12;  }  A = Y/100;  B = 2 - A + (A/4);  X1 = 36525*(Y+4716)/100;  X2 = 306001*(M+1)/10000;  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);  p->validJD = 1;  if( p->validHMS ){  p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);  if( p->validTZ ){  p->iJD -= p->tz*60000;  p->validYMD = 0;  p->validHMS = 0;  p->validTZ = 0;  }  } } static int parseYyyyMmDd(const char *zDate, DateTime *p){  int Y, M, D, neg;  if( zDate[0]=='-' ){  zDate++;  neg = 1;  }else{  neg = 0;  }  if( getDigits(zDate, "40f-21a-21d", &Y, &M, &D)!=3 ){  return 1;  }  zDate += 10;  while( sqlite3Isspace(*zDate) || 'T'==*(u8*)zDate ){ zDate++; }  if( parseHhMmSs(zDate, p)==0 ){  }else if( *zDate==0 ){  p->validHMS = 0;  }else{  return 1;  }  p->validJD = 0;  p->validYMD = 1;  p->Y = neg ? -Y : Y;  p->M = M;  p->D = D;  if( p->validTZ ){  computeJD(p);  }  return 0; } static int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){  p->iJD = sqlite3StmtCurrentTime(context);  if( p->iJD>0 ){  p->validJD = 1;  return 0;  }else{  return 1;  } } static void setRawDateNumber(DateTime *p, double r){  p->s = r;  p->rawS = 1;  if( r>=0.0 && r<5373484.5 ){  p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);  p->validJD = 1;  } } static int parseDateOrTime(  sqlite3_context *context,  const char *zDate,  DateTime *p ){  double r;  if( parseYyyyMmDd(zDate,p)==0 ){  return 0;  }else if( parseHhMmSs(zDate, p)==0 ){  return 0;  }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){  return setDateTimeToCurrent(context, p);  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8)>0 ){  setRawDateNumber(p, r);  return 0;  }  return 1; }
#define INT_464269060799999 ((((i64)0x1a640)<<32)|0x1072fdff)
static int validJulianDay(sqlite3_int64 iJD){  return iJD>=0 && iJD<=INT_464269060799999; } static void computeYMD(DateTime *p){  int Z, A, B, C, D, E, X1;  if( p->validYMD ) return;  if( !p->validJD ){  p->Y = 2000;  p->M = 1;  p->D = 1;  }else if( !validJulianDay(p->iJD) ){  datetimeError(p);  return;  }else{  Z = (int)((p->iJD + 43200000)/86400000);  A = (int)((Z - 1867216.25)/36524.25);  A = Z + 1 + A - (A/4);  B = A + 1524;  C = (int)((B - 122.1)/365.25);  D = (36525*(C&32767))/100;  E = (int)((B-D)/30.6001);  X1 = (int)(30.6001*E);  p->D = B - D - X1;  p->M = E<14 ? E-1 : E-13;  p->Y = p->M>2 ? C - 4716 : C - 4715;  }  p->validYMD = 1; } static void computeHMS(DateTime *p){  int s;  if( p->validHMS ) return;  computeJD(p);  s = (int)((p->iJD + 43200000) % 86400000);  p->s = s/1000.0;  s = (int)p->s;  p->s -= s;  p->h = s/3600;  s -= p->h*3600;  p->m = s/60;  p->s += s - p->m*60;  p->rawS = 0;  p->validHMS = 1; } static void computeYMD_HMS(DateTime *p){  computeYMD(p);  computeHMS(p); } static void clearYMD_HMS_TZ(DateTime *p){  p->validYMD = 0;  p->validHMS = 0;  p->validTZ = 0; }
#ifndef SQLITE_OMIT_LOCALTIME
#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S  && defined(_MSC_VER) && defined(_CRT_INSECURE_DEPRECATE)

#undef HAVE_LOCALTIME_S
#define HAVE_LOCALTIME_S 1
#endif
static int osLocaltime(time_t *t, struct tm *pTm){  int rc;
#if !HAVE_LOCALTIME_R && !HAVE_LOCALTIME_S
 struct tm *pX;
#if SQLITE_THREADSAFE>0
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
 sqlite3_mutex_enter(mutex);  pX = localtime(t);
#ifndef SQLITE_UNTESTABLE
 if( sqlite3GlobalConfig.bLocaltimeFault ) pX = 0;
#endif
 if( pX ) *pTm = *pX;  sqlite3_mutex_leave(mutex);  rc = pX==0;
#else
#ifndef SQLITE_UNTESTABLE
 if( sqlite3GlobalConfig.bLocaltimeFault ) return 1;
#endif
#if HAVE_LOCALTIME_R
 rc = localtime_r(t, pTm)==0;
#else
 rc = localtime_s(pTm, t);
#endif
#endif
 return rc; }
#endif
#ifndef SQLITE_OMIT_LOCALTIME
static sqlite3_int64 localtimeOffset(  DateTime *p,  sqlite3_context *pCtx,  int *pRc ){  DateTime x, y;  time_t t;  struct tm sLocal;  memset(&sLocal, 0, sizeof(sLocal));  x = *p;  computeYMD_HMS(&x);  if( x.Y<1971 || x.Y>=2038 ){  x.Y = 2000;  x.M = 1;  x.D = 1;  x.h = 0;  x.m = 0;  x.s = 0.0;  } else {  int s = (int)(x.s + 0.5);  x.s = s;  }  x.tz = 0;  x.validJD = 0;  computeJD(&x);  t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);  if( osLocaltime(&t, &sLocal) ){  sqlite3_result_error(pCtx, "local time unavailable", -1);  *pRc = SQLITE_ERROR;  return 0;  }  y.Y = sLocal.tm_year + 1900;  y.M = sLocal.tm_mon + 1;  y.D = sLocal.tm_mday;  y.h = sLocal.tm_hour;  y.m = sLocal.tm_min;  y.s = sLocal.tm_sec;  y.validYMD = 1;  y.validHMS = 1;  y.validJD = 0;  y.rawS = 0;  y.validTZ = 0;  y.isError = 0;  computeJD(&y);  *pRc = SQLITE_OK;  return y.iJD - x.iJD; }
#endif
static const struct {  u8 eType;  u8 nName;  char *zName;  double rLimit;  double rXform; } aXformType[] = {  { 0, 6, "second", 464269060800.0, 1000.0  },  { 0, 6, "minute", 7737817680.0, 60000.0 },  { 0, 4, "hour", 128963628.0, 3600000.0 },  { 0, 3, "day", 5373485.0, 86400000.0  },  { 1, 5, "month", 176546.0, 2592000000.0  },  { 2, 4, "year", 14713.0, 31536000000.0 }, }; static int parseModifier(  sqlite3_context *pCtx,  const char *z,  int n,  DateTime *p ){  int rc = 1;  double r;  switch(sqlite3UpperToLower[(u8)z[0]] ){
#ifndef SQLITE_OMIT_LOCALTIME
 case 'l': {  if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){  computeJD(p);  p->iJD += localtimeOffset(p, pCtx, &rc);  clearYMD_HMS_TZ(p);  }  break;  }
#endif
 case 'u': {  if( sqlite3_stricmp(z, "unixepoch")==0 && p->rawS ){  r = p->s*1000.0 + 210866760000000.0;  if( r>=0.0 && r<464269060800000.0 ){  clearYMD_HMS_TZ(p);  p->iJD = (sqlite3_int64)(r + 0.5);  p->validJD = 1;  p->rawS = 0;  rc = 0;  }  }
#ifndef SQLITE_OMIT_LOCALTIME
 else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){  if( p->tzSet==0 ){  sqlite3_int64 c1;  computeJD(p);  c1 = localtimeOffset(p, pCtx, &rc);  if( rc==SQLITE_OK ){  p->iJD -= c1;  clearYMD_HMS_TZ(p);  p->iJD += c1 - localtimeOffset(p, pCtx, &rc);  }  p->tzSet = 1;  }else{  rc = SQLITE_OK;  }  }
#endif
 break;  }  case 'w': {  if( sqlite3_strnicmp(z, "weekday ", 8)==0   && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)>0   && (n=(int)r)==r && n>=0 && r<7 ){  sqlite3_int64 Z;  computeYMD_HMS(p);  p->validTZ = 0;  p->validJD = 0;  computeJD(p);  Z = ((p->iJD + 129600000)/86400000) % 7;  if( Z>n ) Z -= 7;  p->iJD += (n - Z)*86400000;  clearYMD_HMS_TZ(p);  rc = 0;  }  break;  }  case 's': {  if( sqlite3_strnicmp(z, "start of ", 9)!=0 ) break;  if( !p->validJD && !p->validYMD && !p->validHMS ) break;  z += 9;  computeYMD(p);  p->validHMS = 1;  p->h = p->m = 0;  p->s = 0.0;  p->rawS = 0;  p->validTZ = 0;  p->validJD = 0;  if( sqlite3_stricmp(z,"month")==0 ){  p->D = 1;  rc = 0;  }else if( sqlite3_stricmp(z,"year")==0 ){  p->M = 1;  p->D = 1;  rc = 0;  }else if( sqlite3_stricmp(z,"day")==0 ){  rc = 0;  }  break;  }  case '+':  case '-':  case '0':  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9': {  double rRounder;  int i;  for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}  if( sqlite3AtoF(z, &r, n, SQLITE_UTF8)<=0 ){  rc = 1;  break;  }  if( z[n]==':' ){  const char *z2 = z;  DateTime tx;  sqlite3_int64 day;  if( !sqlite3Isdigit(*z2) ) z2++;  memset(&tx, 0, sizeof(tx));  if( parseHhMmSs(z2, &tx) ) break;  computeJD(&tx);  tx.iJD -= 43200000;  day = tx.iJD/86400000;  tx.iJD -= day*86400000;  if( z[0]=='-' ) tx.iJD = -tx.iJD;  computeJD(p);  clearYMD_HMS_TZ(p);  p->iJD += tx.iJD;  rc = 0;  break;  }  z += n;  while( sqlite3Isspace(*z) ) z++;  n = sqlite3Strlen30(z);  if( n>10 || n<3 ) break;  if( sqlite3UpperToLower[(u8)z[n-1]]=='s' ) n--;  computeJD(p);  rc = 1;  rRounder = r<0 ? -0.5 : +0.5;  for(i=0; i<ArraySize(aXformType); i++){  if( aXformType[i].nName==n   && sqlite3_strnicmp(aXformType[i].zName, z, n)==0   && r>-aXformType[i].rLimit && r<aXformType[i].rLimit  ){  switch( aXformType[i].eType ){  case 1: {  int x;  computeYMD_HMS(p);  p->M += (int)r;  x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;  p->Y += x;  p->M -= x*12;  p->validJD = 0;  r -= (int)r;  break;  }  case 2: {  int y = (int)r;  computeYMD_HMS(p);  p->Y += y;  p->validJD = 0;  r -= (int)r;  break;  }  }  computeJD(p);  p->iJD += (sqlite3_int64)(r*aXformType[i].rXform + rRounder);  rc = 0;  break;  }  }  clearYMD_HMS_TZ(p);  break;  }  default: {  break;  }  }  return rc; } static int isDate(  sqlite3_context *context,  int argc,  sqlite3_value **argv,  DateTime *p ){  int i, n;  const unsigned char *z;  int eType;  memset(p, 0, sizeof(*p));  if( argc==0 ){  if( !sqlite3NotPureFunc(context) ) return 1;  return setDateTimeToCurrent(context, p);  }  if( (eType = sqlite3_value_type(argv[0]))==SQLITE_FLOAT   || eType==SQLITE_INTEGER ){  setRawDateNumber(p, sqlite3_value_double(argv[0]));  }else{  z = sqlite3_value_text(argv[0]);  if( !z || parseDateOrTime(context, (char*)z, p) ){  return 1;  }  }  for(i=1; i<argc; i++){  z = sqlite3_value_text(argv[i]);  n = sqlite3_value_bytes(argv[i]);  if( z==0 || parseModifier(context, (char*)z, n, p) ) return 1;  }  computeJD(p);  if( p->isError || !validJulianDay(p->iJD) ) return 1;  return 0; } static void juliandayFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  DateTime x;  if( isDate(context, argc, argv, &x)==0 ){  computeJD(&x);  sqlite3_result_double(context, x.iJD/86400000.0);  } } static void datetimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  DateTime x;  if( isDate(context, argc, argv, &x)==0 ){  char zBuf[100];  computeYMD_HMS(&x);  sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",   x.Y, x.M, x.D, x.h, x.m, (int)(x.s));  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  } } static void timeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  DateTime x;  if( isDate(context, argc, argv, &x)==0 ){  char zBuf[100];  computeHMS(&x);  sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  } } static void dateFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  DateTime x;  if( isDate(context, argc, argv, &x)==0 ){  char zBuf[100];  computeYMD(&x);  sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  } } static void strftimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  DateTime x;  size_t i,j;  sqlite3 *db;  const char *zFmt;  sqlite3_str sRes;  if( argc==0 ) return;  zFmt = (const char*)sqlite3_value_text(argv[0]);  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;  db = sqlite3_context_db_handle(context);  sqlite3StrAccumInit(&sRes, 0, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);  computeJD(&x);  computeYMD_HMS(&x);  for(i=j=0; zFmt[i]; i++){  if( zFmt[i]!='%' ) continue;  if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));  i++;  j = i + 1;  switch( zFmt[i] ){  case 'd': {  sqlite3_str_appendf(&sRes, "%02d", x.D);  break;  }  case 'f': {  double s = x.s;  if( s>59.999 ) s = 59.999;  sqlite3_str_appendf(&sRes, "%06.3f", s);  break;  }  case 'H': {  sqlite3_str_appendf(&sRes, "%02d", x.h);  break;  }  case 'W':  case 'j': {  int nDay;  DateTime y = x;  y.validJD = 0;  y.M = 1;  y.D = 1;  computeJD(&y);  nDay = (int)((x.iJD-y.iJD+43200000)/86400000);  if( zFmt[i]=='W' ){  int wd;  wd = (int)(((x.iJD+43200000)/86400000)%7);  sqlite3_str_appendf(&sRes,"%02d",(nDay+7-wd)/7);  }else{  sqlite3_str_appendf(&sRes,"%03d",nDay+1);  }  break;  }  case 'J': {  sqlite3_str_appendf(&sRes,"%.16g",x.iJD/86400000.0);  break;  }  case 'm': {  sqlite3_str_appendf(&sRes,"%02d",x.M);  break;  }  case 'M': {  sqlite3_str_appendf(&sRes,"%02d",x.m);  break;  }  case 's': {  i64 iS = (i64)(x.iJD/1000 - 21086676*(i64)10000);  sqlite3_str_appendf(&sRes,"%lld",iS);  break;  }  case 'S': {  sqlite3_str_appendf(&sRes,"%02d",(int)x.s);  break;  }  case 'w': {  sqlite3_str_appendchar(&sRes, 1,   (char)(((x.iJD+129600000)/86400000) % 7) + '0');  break;  }  case 'Y': {  sqlite3_str_appendf(&sRes,"%04d",x.Y);  break;  }  case '%': {  sqlite3_str_appendchar(&sRes, 1, '%');  break;  }  default: {  sqlite3_str_reset(&sRes);  return;  }  }  }  if( j<i ) sqlite3_str_append(&sRes, zFmt+j, (int)(i-j));  sqlite3ResultStrAccum(context, &sRes); } static void ctimeFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  timeFunc(context, 0, 0); } static void cdateFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  dateFunc(context, 0, 0); } static void ctimestampFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  datetimeFunc(context, 0, 0); }
#endif
#ifdef SQLITE_OMIT_DATETIME_FUNCS
static void currentTimeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  time_t t;  char *zFormat = (char *)sqlite3_user_data(context);  sqlite3_int64 iT;  struct tm *pTm;  struct tm sNow;  char zBuf[20];  UNUSED_PARAMETER(argc);  UNUSED_PARAMETER(argv);  iT = sqlite3StmtCurrentTime(context);  if( iT<=0 ) return;  t = iT/1000 - 10000*(sqlite3_int64)21086676;
#if HAVE_GMTIME_R
 pTm = gmtime_r(&t, &sNow);
#else
 sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));  pTm = gmtime(&t);  if( pTm ) memcpy(&sNow, pTm, sizeof(sNow));  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));
#endif
 if( pTm ){  strftime(zBuf, 20, zFormat, &sNow);  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  } }
#endif
SQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){  static FuncDef aDateTimeFuncs[] = {
#ifndef SQLITE_OMIT_DATETIME_FUNCS
 PURE_DATE(julianday, -1, 0, 0, juliandayFunc ),  PURE_DATE(date, -1, 0, 0, dateFunc ),  PURE_DATE(time, -1, 0, 0, timeFunc ),  PURE_DATE(datetime, -1, 0, 0, datetimeFunc ),  PURE_DATE(strftime, -1, 0, 0, strftimeFunc ),  DFUNCTION(current_time, 0, 0, 0, ctimeFunc  ),  DFUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),  DFUNCTION(current_date, 0, 0, 0, cdateFunc  ),
#else
 STR_FUNCTION(current_time, 0, "%H:%M:%S", 0, currentTimeFunc),  STR_FUNCTION(current_date, 0, "%Y-%m-%d", 0, currentTimeFunc),  STR_FUNCTION(current_timestamp, 0, "%Y-%m-%d %H:%M:%S", 0, currentTimeFunc),
#endif
 };  sqlite3InsertBuiltinFuncs(aDateTimeFuncs, ArraySize(aDateTimeFuncs)); }
#if defined(SQLITE_TEST)
SQLITE_API int sqlite3_io_error_hit = 0; SQLITE_API int sqlite3_io_error_hardhit = 0; SQLITE_API int sqlite3_io_error_pending = 0; SQLITE_API int sqlite3_io_error_persist = 0; SQLITE_API int sqlite3_io_error_benign = 0; SQLITE_API int sqlite3_diskfull_pending = 0; SQLITE_API int sqlite3_diskfull = 0;
#endif
#if defined(SQLITE_TEST)
SQLITE_API int sqlite3_open_file_count = 0;
#endif
#if defined(SQLITE_TEST)
SQLITE_API int sqlite3_memdebug_vfs_oom_test = 1;
 #define DO_OS_MALLOC_TEST(x)   if (sqlite3_memdebug_vfs_oom_test && (!x || !sqlite3JournalIsInMemory(x))) {  void *pTstAlloc = sqlite3Malloc(10);   if (!pTstAlloc) return SQLITE_IOERR_NOMEM_BKPT;  sqlite3_free(pTstAlloc);   }

#else
 #define DO_OS_MALLOC_TEST(x)
#endif
SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file *pId){  if( pId->pMethods ){  pId->pMethods->xClose(pId);  pId->pMethods = 0;  } } SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xRead(id, pBuf, amt, offset); } SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xWrite(id, pBuf, amt, offset); } SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file *id, i64 size){  return id->pMethods->xTruncate(id, size); } SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file *id, int flags){  DO_OS_MALLOC_TEST(id);  return flags ? id->pMethods->xSync(id, flags) : SQLITE_OK; } SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xFileSize(id, pSize); } SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file *id, int lockType){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xLock(id, lockType); } SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file *id, int lockType){  return id->pMethods->xUnlock(id, lockType); } SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xCheckReservedLock(id, pResOut); } SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){  if( id->pMethods==0 ) return SQLITE_NOTFOUND;
#ifdef SQLITE_TEST
 if( op!=SQLITE_FCNTL_COMMIT_PHASETWO   && op!=SQLITE_FCNTL_LOCK_TIMEOUT   && op!=SQLITE_FCNTL_CKPT_DONE   && op!=SQLITE_FCNTL_CKPT_START  ){  DO_OS_MALLOC_TEST(id);  }
#endif
 return id->pMethods->xFileControl(id, op, pArg); } SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){  if( id->pMethods ) (void)id->pMethods->xFileControl(id, op, pArg); } SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id){  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;  return (xSectorSize ? xSectorSize(id) : SQLITE_DEFAULT_SECTOR_SIZE); } SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id){  if( NEVER(id->pMethods==0) ) return 0;  return id->pMethods->xDeviceCharacteristics(id); }
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){  return id->pMethods->xShmLock(id, offset, n, flags); } SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id){  id->pMethods->xShmBarrier(id); } SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){  return id->pMethods->xShmUnmap(id, deleteFlag); } SQLITE_PRIVATE int sqlite3OsShmMap(  sqlite3_file *id,  int iPage,  int pgsz,  int bExtend,  void volatile **pp ){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp); }
#endif
#if SQLITE_MAX_MMAP_SIZE>0
SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){  DO_OS_MALLOC_TEST(id);  return id->pMethods->xFetch(id, iOff, iAmt, pp); } SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){  return id->pMethods->xUnfetch(id, iOff, p); }
#else
SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){  *pp = 0;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){  return SQLITE_OK; }
#endif
SQLITE_PRIVATE int sqlite3OsOpen(  sqlite3_vfs *pVfs,  const char *zPath,  sqlite3_file *pFile,  int flags,  int *pFlagsOut ){  int rc;  DO_OS_MALLOC_TEST(0);  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x1087f7f, pFlagsOut);  assert( rc==SQLITE_OK || pFile->pMethods==0 );  return rc; } SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){  DO_OS_MALLOC_TEST(0);  assert( dirSync==0 || dirSync==1 );  return pVfs->xDelete!=0 ? pVfs->xDelete(pVfs, zPath, dirSync) : SQLITE_OK; } SQLITE_PRIVATE int sqlite3OsAccess(  sqlite3_vfs *pVfs,  const char *zPath,  int flags,  int *pResOut ){  DO_OS_MALLOC_TEST(0);  return pVfs->xAccess(pVfs, zPath, flags, pResOut); } SQLITE_PRIVATE int sqlite3OsFullPathname(  sqlite3_vfs *pVfs,  const char *zPath,  int nPathOut,  char *zPathOut ){  DO_OS_MALLOC_TEST(0);  zPathOut[0] = 0;  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut); }
#ifndef SQLITE_OMIT_LOAD_EXTENSION
SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){  assert( zPath!=0 );  assert( strlen(zPath)<=SQLITE_MAX_PATHLEN );  return pVfs->xDlOpen(pVfs, zPath); } SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){  pVfs->xDlError(pVfs, nByte, zBufOut); } SQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){  return pVfs->xDlSym(pVfs, pHdle, zSym); } SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){  pVfs->xDlClose(pVfs, pHandle); }
#endif
SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){  if( sqlite3Config.iPrngSeed ){  memset(zBufOut, 0, nByte);  if( ALWAYS(nByte>(signed)sizeof(unsigned)) ) nByte = sizeof(unsigned int);  memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);  return SQLITE_OK;  }else{  return pVfs->xRandomness(pVfs, nByte, zBufOut);  } } SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){  return pVfs->xSleep(pVfs, nMicro); } SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs *pVfs){  return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0; } SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){  int rc;  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){  rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);  }else{  double r;  rc = pVfs->xCurrentTime(pVfs, &r);  *pTimeOut = (sqlite3_int64)(r*86400000.0);  }  return rc; } SQLITE_PRIVATE int sqlite3OsOpenMalloc(  sqlite3_vfs *pVfs,  const char *zFile,  sqlite3_file **ppFile,  int flags,  int *pOutFlags ){  int rc;  sqlite3_file *pFile;  pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);  if( pFile ){  rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);  if( rc!=SQLITE_OK ){  sqlite3_free(pFile);  *ppFile = 0;  }else{  *ppFile = pFile;  }  }else{  *ppFile = 0;  rc = SQLITE_NOMEM_BKPT;  }  assert( *ppFile!=0 || rc!=SQLITE_OK );  return rc; } SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *pFile){  assert( pFile );  sqlite3OsClose(pFile);  sqlite3_free(pFile); } SQLITE_PRIVATE int sqlite3OsInit(void){  void *p = sqlite3_malloc(10);  if( p==0 ) return SQLITE_NOMEM_BKPT;  sqlite3_free(p);  return sqlite3_os_init(); } static sqlite3_vfs * SQLITE_WSD vfsList = 0;
#define vfsList GLOBAL(sqlite3_vfs *, vfsList)
SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){  sqlite3_vfs *pVfs = 0;
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex;
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 int rc = sqlite3_initialize();  if( rc ) return 0;
#endif
#if SQLITE_THREADSAFE
 mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
 sqlite3_mutex_enter(mutex);  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){  if( zVfs==0 ) break;  if( strcmp(zVfs, pVfs->zName)==0 ) break;  }  sqlite3_mutex_leave(mutex);  return pVfs; } static void vfsUnlink(sqlite3_vfs *pVfs){  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN)) );  if( pVfs==0 ){  }else if( vfsList==pVfs ){  vfsList = pVfs->pNext;  }else if( vfsList ){  sqlite3_vfs *p = vfsList;  while( p->pNext && p->pNext!=pVfs ){  p = p->pNext;  }  if( p->pNext==pVfs ){  p->pNext = pVfs->pNext;  }  } } SQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){  MUTEX_LOGIC(sqlite3_mutex *mutex;)
#ifndef SQLITE_OMIT_AUTOINIT
 int rc = sqlite3_initialize();  if( rc ) return rc;
#endif
#ifdef SQLITE_ENABLE_API_ARMOR
 if( pVfs==0 ) return SQLITE_MISUSE_BKPT;
#endif
 MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )  sqlite3_mutex_enter(mutex);  vfsUnlink(pVfs);  if( makeDflt || vfsList==0 ){  pVfs->pNext = vfsList;  vfsList = pVfs;  }else{  pVfs->pNext = vfsList->pNext;  vfsList->pNext = pVfs;  }  assert(vfsList);  sqlite3_mutex_leave(mutex);  return SQLITE_OK; } SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){  MUTEX_LOGIC(sqlite3_mutex *mutex;)
#ifndef SQLITE_OMIT_AUTOINIT
 int rc = sqlite3_initialize();  if( rc ) return rc;
#endif
 MUTEX_LOGIC( mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )  sqlite3_mutex_enter(mutex);  vfsUnlink(pVfs);  sqlite3_mutex_leave(mutex);  return SQLITE_OK; }
#ifndef SQLITE_UNTESTABLE
typedef struct BenignMallocHooks BenignMallocHooks; static SQLITE_WSD struct BenignMallocHooks {  void (*xBenignBegin)(void);  void (*xBenignEnd)(void); } sqlite3Hooks = { 0, 0 };
#ifdef SQLITE_OMIT_WSD
# define wsdHooksInit  BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)

# define wsdHooks x[0]
#else
# define wsdHooksInit
# define wsdHooks sqlite3Hooks
#endif
SQLITE_PRIVATE void sqlite3BenignMallocHooks(  void (*xBenignBegin)(void),  void (*xBenignEnd)(void) ){  wsdHooksInit;  wsdHooks.xBenignBegin = xBenignBegin;  wsdHooks.xBenignEnd = xBenignEnd; } SQLITE_PRIVATE void sqlite3BeginBenignMalloc(void){  wsdHooksInit;  if( wsdHooks.xBenignBegin ){  wsdHooks.xBenignBegin();  } } SQLITE_PRIVATE void sqlite3EndBenignMalloc(void){  wsdHooksInit;  if( wsdHooks.xBenignEnd ){  wsdHooks.xBenignEnd();  } }
#endif
#ifdef SQLITE_ZERO_MALLOC
static void *sqlite3MemMalloc(int nByte){ return 0; } static void sqlite3MemFree(void *pPrior){ return; } static void *sqlite3MemRealloc(void *pPrior, int nByte){ return 0; } static int sqlite3MemSize(void *pPrior){ return 0; } static int sqlite3MemRoundup(int n){ return n; } static int sqlite3MemInit(void *NotUsed){ return SQLITE_OK; } static void sqlite3MemShutdown(void *NotUsed){ return; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){  static const sqlite3_mem_methods defaultMethods = {   sqlite3MemMalloc,   sqlite3MemFree,   sqlite3MemRealloc,   sqlite3MemSize,   sqlite3MemRoundup,   sqlite3MemInit,   sqlite3MemShutdown,   0  };  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods); }
#endif
#ifdef SQLITE_SYSTEM_MALLOC
#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)
#include <sys/sysctl.h>
#include <malloc/malloc.h>
#ifdef SQLITE_MIGHT_BE_SINGLE_CORE
#include <libkern/OSAtomic.h>
#endif
static malloc_zone_t* _sqliteZone_;
#define SQLITE_MALLOC(x) malloc_zone_malloc(_sqliteZone_, (x))
#define SQLITE_FREE(x) malloc_zone_free(_sqliteZone_, (x));
#define SQLITE_REALLOC(x,y) malloc_zone_realloc(_sqliteZone_, (x), (y))
#define SQLITE_MALLOCSIZE(x)  (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,x) : malloc_size(x))

#else
#define SQLITE_MALLOC(x)  malloc(x)
#define SQLITE_FREE(x)  free(x)
#define SQLITE_REALLOC(x,y) realloc((x),(y))
#if HAVE_MALLOC_H && HAVE_MALLOC_USABLE_SIZE
# define SQLITE_USE_MALLOC_H 1
# define SQLITE_USE_MALLOC_USABLE_SIZE 1
#elif defined(_MSC_VER) && !defined(SQLITE_WITHOUT_MSIZE)
# define SQLITE_USE_MALLOC_H
# define SQLITE_USE_MSIZE
#endif
#if defined(SQLITE_USE_MALLOC_H)
# include <malloc.h>
# if defined(SQLITE_USE_MALLOC_USABLE_SIZE)
# if !defined(SQLITE_MALLOCSIZE)
# define SQLITE_MALLOCSIZE(x)  malloc_usable_size(x)
# endif
# elif defined(SQLITE_USE_MSIZE)
# if !defined(SQLITE_MALLOCSIZE)
# define SQLITE_MALLOCSIZE _msize
# endif
# endif
#endif
#endif
static void *sqlite3MemMalloc(int nByte){
#ifdef SQLITE_MALLOCSIZE
 void *p;  testcase( ROUND8(nByte)==nByte );  p = SQLITE_MALLOC( nByte );  if( p==0 ){  testcase( sqlite3GlobalConfig.xLog!=0 );  sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);  }  return p;
#else
 sqlite3_int64 *p;  assert( nByte>0 );  testcase( ROUND8(nByte)!=nByte );  p = SQLITE_MALLOC( nByte+8 );  if( p ){  p[0] = nByte;  p++;  }else{  testcase( sqlite3GlobalConfig.xLog!=0 );  sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes of memory", nByte);  }  return (void *)p;
#endif
} static void sqlite3MemFree(void *pPrior){
#ifdef SQLITE_MALLOCSIZE
 SQLITE_FREE(pPrior);
#else
 sqlite3_int64 *p = (sqlite3_int64*)pPrior;  assert( pPrior!=0 );  p--;  SQLITE_FREE(p);
#endif
} static int sqlite3MemSize(void *pPrior){
#ifdef SQLITE_MALLOCSIZE
 assert( pPrior!=0 );  return (int)SQLITE_MALLOCSIZE(pPrior);
#else
 sqlite3_int64 *p;  assert( pPrior!=0 );  p = (sqlite3_int64*)pPrior;  p--;  return (int)p[0];
#endif
} static void *sqlite3MemRealloc(void *pPrior, int nByte){
#ifdef SQLITE_MALLOCSIZE
 void *p = SQLITE_REALLOC(pPrior, nByte);  if( p==0 ){  testcase( sqlite3GlobalConfig.xLog!=0 );  sqlite3_log(SQLITE_NOMEM,  "failed memory resize %u to %u bytes",  SQLITE_MALLOCSIZE(pPrior), nByte);  }  return p;
#else
 sqlite3_int64 *p = (sqlite3_int64*)pPrior;  assert( pPrior!=0 && nByte>0 );  assert( nByte==ROUND8(nByte) );  p--;  p = SQLITE_REALLOC(p, nByte+8 );  if( p ){  p[0] = nByte;  p++;  }else{  testcase( sqlite3GlobalConfig.xLog!=0 );  sqlite3_log(SQLITE_NOMEM,  "failed memory resize %u to %u bytes",  sqlite3MemSize(pPrior), nByte);  }  return (void*)p;
#endif
} static int sqlite3MemRoundup(int n){  return ROUND8(n); } static int sqlite3MemInit(void *NotUsed){
#if defined(__APPLE__) && !defined(SQLITE_WITHOUT_ZONEMALLOC)
 int cpuCount;  size_t len;  if( _sqliteZone_ ){  return SQLITE_OK;  }  len = sizeof(cpuCount);  sysctlbyname("hw.ncpu", &cpuCount, &len, NULL, 0);  if( cpuCount>1 ){  _sqliteZone_ = malloc_default_zone();  }else{  _sqliteZone_ = malloc_create_zone(4096, 0);  malloc_set_zone_name(_sqliteZone_, "Sqlite_Heap");  }
#endif
 UNUSED_PARAMETER(NotUsed);  return SQLITE_OK; } static void sqlite3MemShutdown(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  return; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){  static const sqlite3_mem_methods defaultMethods = {   sqlite3MemMalloc,   sqlite3MemFree,   sqlite3MemRealloc,   sqlite3MemSize,   sqlite3MemRoundup,   sqlite3MemInit,   sqlite3MemShutdown,   0  };  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods); }
#endif
#ifdef SQLITE_MEMDEBUG
#ifdef __GLIBC__
 extern int backtrace(void**,int);  extern void backtrace_symbols_fd(void*const*,int,int);
#else
# define backtrace(A,B) 1
# define backtrace_symbols_fd(A,B,C)
#endif
struct MemBlockHdr {  i64 iSize;  struct MemBlockHdr *pNext, *pPrev;  char nBacktrace;  char nBacktraceSlots;  u8 nTitle;  u8 eType;  int iForeGuard; };
#define FOREGUARD 0x80F5E153
#define REARGUARD 0xE4676B53
#define NCSIZE 1000
static struct {  sqlite3_mutex *mutex;  struct MemBlockHdr *pFirst;  struct MemBlockHdr *pLast;  int nBacktrace;  void (*xBacktrace)(int, int, void **);  int nTitle;  char zTitle[100];  int disallow;  int nAlloc[NCSIZE];  int nCurrent[NCSIZE];  int mxCurrent[NCSIZE]; } mem; static void adjustStats(int iSize, int increment){  int i = ROUND8(iSize)/8;  if( i>NCSIZE-1 ){  i = NCSIZE - 1;  }  if( increment>0 ){  mem.nAlloc[i]++;  mem.nCurrent[i]++;  if( mem.nCurrent[i]>mem.mxCurrent[i] ){  mem.mxCurrent[i] = mem.nCurrent[i];  }  }else{  mem.nCurrent[i]--;  assert( mem.nCurrent[i]>=0 );  } } static struct MemBlockHdr *sqlite3MemsysGetHeader(const void *pAllocation){  struct MemBlockHdr *p;  int *pInt;  u8 *pU8;  int nReserve;  p = (struct MemBlockHdr*)pAllocation;  p--;  assert( p->iForeGuard==(int)FOREGUARD );  nReserve = ROUND8(p->iSize);  pInt = (int*)pAllocation;  pU8 = (u8*)pAllocation;  assert( pInt[nReserve/sizeof(int)]==(int)REARGUARD );  while( nReserve-- > p->iSize ) assert( pU8[nReserve]==0x65 );  return p; } static int sqlite3MemSize(void *p){  struct MemBlockHdr *pHdr;  if( !p ){  return 0;  }  pHdr = sqlite3MemsysGetHeader(p);  return (int)pHdr->iSize; } static int sqlite3MemInit(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  assert( (sizeof(struct MemBlockHdr)&7) == 0 );  if( !sqlite3GlobalConfig.bMemstat ){  mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);  }  return SQLITE_OK; } static void sqlite3MemShutdown(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  mem.mutex = 0; } static int sqlite3MemRoundup(int n){  return ROUND8(n); } static void randomFill(char *pBuf, int nByte){  unsigned int x, y, r;  x = SQLITE_PTR_TO_INT(pBuf);  y = nByte | 1;  while( nByte >= 4 ){  x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);  y = y*1103515245 + 12345;  r = x ^ y;  *(int*)pBuf = r;  pBuf += 4;  nByte -= 4;  }  while( nByte-- > 0 ){  x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);  y = y*1103515245 + 12345;  r = x ^ y;  *(pBuf++) = r & 0xff;  } } static void *sqlite3MemMalloc(int nByte){  struct MemBlockHdr *pHdr;  void **pBt;  char *z;  int *pInt;  void *p = 0;  int totalSize;  int nReserve;  sqlite3_mutex_enter(mem.mutex);  assert( mem.disallow==0 );  nReserve = ROUND8(nByte);  totalSize = nReserve + sizeof(*pHdr) + sizeof(int) +   mem.nBacktrace*sizeof(void*) + mem.nTitle;  p = malloc(totalSize);  if( p ){  z = p;  pBt = (void**)&z[mem.nTitle];  pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace];  pHdr->pNext = 0;  pHdr->pPrev = mem.pLast;  if( mem.pLast ){  mem.pLast->pNext = pHdr;  }else{  mem.pFirst = pHdr;  }  mem.pLast = pHdr;  pHdr->iForeGuard = FOREGUARD;  pHdr->eType = MEMTYPE_HEAP;  pHdr->nBacktraceSlots = mem.nBacktrace;  pHdr->nTitle = mem.nTitle;  if( mem.nBacktrace ){  void *aAddr[40];  pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1;  memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));  assert(pBt[0]);  if( mem.xBacktrace ){  mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]);  }  }else{  pHdr->nBacktrace = 0;  }  if( mem.nTitle ){  memcpy(z, mem.zTitle, mem.nTitle);  }  pHdr->iSize = nByte;  adjustStats(nByte, +1);  pInt = (int*)&pHdr[1];  pInt[nReserve/sizeof(int)] = REARGUARD;  randomFill((char*)pInt, nByte);  memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);  p = (void*)pInt;  }  sqlite3_mutex_leave(mem.mutex);  return p; } static void sqlite3MemFree(void *pPrior){  struct MemBlockHdr *pHdr;  void **pBt;  char *z;  assert( sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0   || mem.mutex!=0 );  pHdr = sqlite3MemsysGetHeader(pPrior);  pBt = (void**)pHdr;  pBt -= pHdr->nBacktraceSlots;  sqlite3_mutex_enter(mem.mutex);  if( pHdr->pPrev ){  assert( pHdr->pPrev->pNext==pHdr );  pHdr->pPrev->pNext = pHdr->pNext;  }else{  assert( mem.pFirst==pHdr );  mem.pFirst = pHdr->pNext;  }  if( pHdr->pNext ){  assert( pHdr->pNext->pPrev==pHdr );  pHdr->pNext->pPrev = pHdr->pPrev;  }else{  assert( mem.pLast==pHdr );  mem.pLast = pHdr->pPrev;  }  z = (char*)pBt;  z -= pHdr->nTitle;  adjustStats((int)pHdr->iSize, -1);  randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +  (int)pHdr->iSize + sizeof(int) + pHdr->nTitle);  free(z);  sqlite3_mutex_leave(mem.mutex); } static void *sqlite3MemRealloc(void *pPrior, int nByte){  struct MemBlockHdr *pOldHdr;  void *pNew;  assert( mem.disallow==0 );  assert( (nByte & 7)==0 );  pOldHdr = sqlite3MemsysGetHeader(pPrior);  pNew = sqlite3MemMalloc(nByte);  if( pNew ){  memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));  if( nByte>pOldHdr->iSize ){  randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - (int)pOldHdr->iSize);  }  sqlite3MemFree(pPrior);  }  return pNew; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){  static const sqlite3_mem_methods defaultMethods = {   sqlite3MemMalloc,   sqlite3MemFree,   sqlite3MemRealloc,   sqlite3MemSize,   sqlite3MemRoundup,   sqlite3MemInit,   sqlite3MemShutdown,   0  };  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods); } SQLITE_PRIVATE void sqlite3MemdebugSetType(void *p, u8 eType){  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){  struct MemBlockHdr *pHdr;  pHdr = sqlite3MemsysGetHeader(p);  assert( pHdr->iForeGuard==FOREGUARD );  pHdr->eType = eType;  } } SQLITE_PRIVATE int sqlite3MemdebugHasType(const void *p, u8 eType){  int rc = 1;  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){  struct MemBlockHdr *pHdr;  pHdr = sqlite3MemsysGetHeader(p);  assert( pHdr->iForeGuard==FOREGUARD );  if( (pHdr->eType&eType)==0 ){  rc = 0;  }  }  return rc; } SQLITE_PRIVATE int sqlite3MemdebugNoType(const void *p, u8 eType){  int rc = 1;  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){  struct MemBlockHdr *pHdr;  pHdr = sqlite3MemsysGetHeader(p);  assert( pHdr->iForeGuard==FOREGUARD );  if( (pHdr->eType&eType)!=0 ){  rc = 0;  }  }  return rc; } SQLITE_PRIVATE void sqlite3MemdebugBacktrace(int depth){  if( depth<0 ){ depth = 0; }  if( depth>20 ){ depth = 20; }  depth = (depth+1)&0xfe;  mem.nBacktrace = depth; } SQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){  mem.xBacktrace = xBacktrace; } SQLITE_PRIVATE void sqlite3MemdebugSettitle(const char *zTitle){  unsigned int n = sqlite3Strlen30(zTitle) + 1;  sqlite3_mutex_enter(mem.mutex);  if( n>=sizeof(mem.zTitle) ) n = sizeof(mem.zTitle)-1;  memcpy(mem.zTitle, zTitle, n);  mem.zTitle[n] = 0;  mem.nTitle = ROUND8(n);  sqlite3_mutex_leave(mem.mutex); } SQLITE_PRIVATE void sqlite3MemdebugSync(){  struct MemBlockHdr *pHdr;  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){  void **pBt = (void**)pHdr;  pBt -= pHdr->nBacktraceSlots;  mem.xBacktrace((int)pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]);  } } SQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename){  FILE *out;  struct MemBlockHdr *pHdr;  void **pBt;  int i;  out = fopen(zFilename, "w");  if( out==0 ){  fprintf(stderr, "** Unable to output memory debug output log: %s **\n",  zFilename);  return;  }  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){  char *z = (char*)pHdr;  z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;  fprintf(out, "**** %lld bytes at %p from %s ****\n",  pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : "???");  if( pHdr->nBacktrace ){  fflush(out);  pBt = (void**)pHdr;  pBt -= pHdr->nBacktraceSlots;  backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));  fprintf(out, "\n");  }  }  fprintf(out, "COUNTS:\n");  for(i=0; i<NCSIZE-1; i++){  if( mem.nAlloc[i] ){  fprintf(out, "  %5d: %10d %10d %10d\n",  i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);  }  }  if( mem.nAlloc[NCSIZE-1] ){  fprintf(out, "  %5d: %10d %10d %10d\n",   NCSIZE*8-8, mem.nAlloc[NCSIZE-1],   mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]);  }  fclose(out); } SQLITE_PRIVATE int sqlite3MemdebugMallocCount(){  int i;  int nTotal = 0;  for(i=0; i<NCSIZE; i++){  nTotal += mem.nAlloc[i];  }  return nTotal; }
#endif
#ifdef SQLITE_ENABLE_MEMSYS3
#define MX_SMALL 10
#define N_HASH 61
typedef struct Mem3Block Mem3Block; struct Mem3Block {  union {  struct {  u32 prevSize;  u32 size4x;  } hdr;  struct {  u32 next;  u32 prev;  } list;  } u; }; static SQLITE_WSD struct Mem3Global {  u32 nPool;  Mem3Block *aPool;  int alarmBusy;  sqlite3_mutex *mutex;  u32 mnKeyBlk;  u32 iKeyBlk;  u32 szKeyBlk;  u32 aiSmall[MX_SMALL-1];  u32 aiHash[N_HASH]; } mem3 = { 97535575 };
#define mem3 GLOBAL(struct Mem3Global, mem3)
static void memsys3UnlinkFromList(u32 i, u32 *pRoot){  u32 next = mem3.aPool[i].u.list.next;  u32 prev = mem3.aPool[i].u.list.prev;  assert( sqlite3_mutex_held(mem3.mutex) );  if( prev==0 ){  *pRoot = next;  }else{  mem3.aPool[prev].u.list.next = next;  }  if( next ){  mem3.aPool[next].u.list.prev = prev;  }  mem3.aPool[i].u.list.next = 0;  mem3.aPool[i].u.list.prev = 0; } static void memsys3Unlink(u32 i){  u32 size, hash;  assert( sqlite3_mutex_held(mem3.mutex) );  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );  assert( i>=1 );  size = mem3.aPool[i-1].u.hdr.size4x/4;  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );  assert( size>=2 );  if( size <= MX_SMALL ){  memsys3UnlinkFromList(i, &mem3.aiSmall[size-2]);  }else{  hash = size % N_HASH;  memsys3UnlinkFromList(i, &mem3.aiHash[hash]);  } } static void memsys3LinkIntoList(u32 i, u32 *pRoot){  assert( sqlite3_mutex_held(mem3.mutex) );  mem3.aPool[i].u.list.next = *pRoot;  mem3.aPool[i].u.list.prev = 0;  if( *pRoot ){  mem3.aPool[*pRoot].u.list.prev = i;  }  *pRoot = i; } static void memsys3Link(u32 i){  u32 size, hash;  assert( sqlite3_mutex_held(mem3.mutex) );  assert( i>=1 );  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );  size = mem3.aPool[i-1].u.hdr.size4x/4;  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );  assert( size>=2 );  if( size <= MX_SMALL ){  memsys3LinkIntoList(i, &mem3.aiSmall[size-2]);  }else{  hash = size % N_HASH;  memsys3LinkIntoList(i, &mem3.aiHash[hash]);  } } static void memsys3Enter(void){  if( sqlite3GlobalConfig.bMemstat==0 && mem3.mutex==0 ){  mem3.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);  }  sqlite3_mutex_enter(mem3.mutex); } static void memsys3Leave(void){  sqlite3_mutex_leave(mem3.mutex); } static void memsys3OutOfMemory(int nByte){  if( !mem3.alarmBusy ){  mem3.alarmBusy = 1;  assert( sqlite3_mutex_held(mem3.mutex) );  sqlite3_mutex_leave(mem3.mutex);  sqlite3_release_memory(nByte);  sqlite3_mutex_enter(mem3.mutex);  mem3.alarmBusy = 0;  } } static void *memsys3Checkout(u32 i, u32 nBlock){  u32 x;  assert( sqlite3_mutex_held(mem3.mutex) );  assert( i>=1 );  assert( mem3.aPool[i-1].u.hdr.size4x/4==nBlock );  assert( mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock );  x = mem3.aPool[i-1].u.hdr.size4x;  mem3.aPool[i-1].u.hdr.size4x = nBlock*4 | 1 | (x&2);  mem3.aPool[i+nBlock-1].u.hdr.prevSize = nBlock;  mem3.aPool[i+nBlock-1].u.hdr.size4x |= 2;  return &mem3.aPool[i]; } static void *memsys3FromKeyBlk(u32 nBlock){  assert( sqlite3_mutex_held(mem3.mutex) );  assert( mem3.szKeyBlk>=nBlock );  if( nBlock>=mem3.szKeyBlk-1 ){  void *p = memsys3Checkout(mem3.iKeyBlk, mem3.szKeyBlk);  mem3.iKeyBlk = 0;  mem3.szKeyBlk = 0;  mem3.mnKeyBlk = 0;  return p;  }else{  u32 newi, x;  newi = mem3.iKeyBlk + mem3.szKeyBlk - nBlock;  assert( newi > mem3.iKeyBlk+1 );  mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.prevSize = nBlock;  mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.size4x |= 2;  mem3.aPool[newi-1].u.hdr.size4x = nBlock*4 + 1;  mem3.szKeyBlk -= nBlock;  mem3.aPool[newi-1].u.hdr.prevSize = mem3.szKeyBlk;  x = mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x & 2;  mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x = mem3.szKeyBlk*4 | x;  if( mem3.szKeyBlk < mem3.mnKeyBlk ){  mem3.mnKeyBlk = mem3.szKeyBlk;  }  return (void*)&mem3.aPool[newi];  } } static void memsys3Merge(u32 *pRoot){  u32 iNext, prev, size, i, x;  assert( sqlite3_mutex_held(mem3.mutex) );  for(i=*pRoot; i>0; i=iNext){  iNext = mem3.aPool[i].u.list.next;  size = mem3.aPool[i-1].u.hdr.size4x;  assert( (size&1)==0 );  if( (size&2)==0 ){  memsys3UnlinkFromList(i, pRoot);  assert( i > mem3.aPool[i-1].u.hdr.prevSize );  prev = i - mem3.aPool[i-1].u.hdr.prevSize;  if( prev==iNext ){  iNext = mem3.aPool[prev].u.list.next;  }  memsys3Unlink(prev);  size = i + size/4 - prev;  x = mem3.aPool[prev-1].u.hdr.size4x & 2;  mem3.aPool[prev-1].u.hdr.size4x = size*4 | x;  mem3.aPool[prev+size-1].u.hdr.prevSize = size;  memsys3Link(prev);  i = prev;  }else{  size /= 4;  }  if( size>mem3.szKeyBlk ){  mem3.iKeyBlk = i;  mem3.szKeyBlk = size;  }  } } static void *memsys3MallocUnsafe(int nByte){  u32 i;  u32 nBlock;  u32 toFree;  assert( sqlite3_mutex_held(mem3.mutex) );  assert( sizeof(Mem3Block)==8 );  if( nByte<=12 ){  nBlock = 2;  }else{  nBlock = (nByte + 11)/8;  }  assert( nBlock>=2 );  if( nBlock <= MX_SMALL ){  i = mem3.aiSmall[nBlock-2];  if( i>0 ){  memsys3UnlinkFromList(i, &mem3.aiSmall[nBlock-2]);  return memsys3Checkout(i, nBlock);  }  }else{  int hash = nBlock % N_HASH;  for(i=mem3.aiHash[hash]; i>0; i=mem3.aPool[i].u.list.next){  if( mem3.aPool[i-1].u.hdr.size4x/4==nBlock ){  memsys3UnlinkFromList(i, &mem3.aiHash[hash]);  return memsys3Checkout(i, nBlock);  }  }  }  if( mem3.szKeyBlk>=nBlock ){  return memsys3FromKeyBlk(nBlock);  }  for(toFree=nBlock*16; toFree<(mem3.nPool*16); toFree *= 2){  memsys3OutOfMemory(toFree);  if( mem3.iKeyBlk ){  memsys3Link(mem3.iKeyBlk);  mem3.iKeyBlk = 0;  mem3.szKeyBlk = 0;  }  for(i=0; i<N_HASH; i++){  memsys3Merge(&mem3.aiHash[i]);  }  for(i=0; i<MX_SMALL-1; i++){  memsys3Merge(&mem3.aiSmall[i]);  }  if( mem3.szKeyBlk ){  memsys3Unlink(mem3.iKeyBlk);  if( mem3.szKeyBlk>=nBlock ){  return memsys3FromKeyBlk(nBlock);  }  }  }  return 0; } static void memsys3FreeUnsafe(void *pOld){  Mem3Block *p = (Mem3Block*)pOld;  int i;  u32 size, x;  assert( sqlite3_mutex_held(mem3.mutex) );  assert( p>mem3.aPool && p<&mem3.aPool[mem3.nPool] );  i = p - mem3.aPool;  assert( (mem3.aPool[i-1].u.hdr.size4x&1)==1 );  size = mem3.aPool[i-1].u.hdr.size4x/4;  assert( i+size<=mem3.nPool+1 );  mem3.aPool[i-1].u.hdr.size4x &= ~1;  mem3.aPool[i+size-1].u.hdr.prevSize = size;  mem3.aPool[i+size-1].u.hdr.size4x &= ~2;  memsys3Link(i);  if( mem3.iKeyBlk ){  while( (mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x&2)==0 ){  size = mem3.aPool[mem3.iKeyBlk-1].u.hdr.prevSize;  mem3.iKeyBlk -= size;  mem3.szKeyBlk += size;  memsys3Unlink(mem3.iKeyBlk);  x = mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x & 2;  mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x = mem3.szKeyBlk*4 | x;  mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.prevSize = mem3.szKeyBlk;  }  x = mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x & 2;  while( (mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.size4x&1)==0 ){  memsys3Unlink(mem3.iKeyBlk+mem3.szKeyBlk);  mem3.szKeyBlk += mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.size4x/4;  mem3.aPool[mem3.iKeyBlk-1].u.hdr.size4x = mem3.szKeyBlk*4 | x;  mem3.aPool[mem3.iKeyBlk+mem3.szKeyBlk-1].u.hdr.prevSize = mem3.szKeyBlk;  }  } } static int memsys3Size(void *p){  Mem3Block *pBlock;  assert( p!=0 );  pBlock = (Mem3Block*)p;  assert( (pBlock[-1].u.hdr.size4x&1)!=0 );  return (pBlock[-1].u.hdr.size4x&~3)*2 - 4; } static int memsys3Roundup(int n){  if( n<=12 ){  return 12;  }else{  return ((n+11)&~7) - 4;  } } static void *memsys3Malloc(int nBytes){  sqlite3_int64 *p;  assert( nBytes>0 );  memsys3Enter();  p = memsys3MallocUnsafe(nBytes);  memsys3Leave();  return (void*)p; } static void memsys3Free(void *pPrior){  assert( pPrior );  memsys3Enter();  memsys3FreeUnsafe(pPrior);  memsys3Leave(); } static void *memsys3Realloc(void *pPrior, int nBytes){  int nOld;  void *p;  if( pPrior==0 ){  return sqlite3_malloc(nBytes);  }  if( nBytes<=0 ){  sqlite3_free(pPrior);  return 0;  }  nOld = memsys3Size(pPrior);  if( nBytes<=nOld && nBytes>=nOld-128 ){  return pPrior;  }  memsys3Enter();  p = memsys3MallocUnsafe(nBytes);  if( p ){  if( nOld<nBytes ){  memcpy(p, pPrior, nOld);  }else{  memcpy(p, pPrior, nBytes);  }  memsys3FreeUnsafe(pPrior);  }  memsys3Leave();  return p; } static int memsys3Init(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  if( !sqlite3GlobalConfig.pHeap ){  return SQLITE_ERROR;  }  assert( sizeof(Mem3Block)==8 );  mem3.aPool = (Mem3Block *)sqlite3GlobalConfig.pHeap;  mem3.nPool = (sqlite3GlobalConfig.nHeap / sizeof(Mem3Block)) - 2;  mem3.szKeyBlk = mem3.nPool;  mem3.mnKeyBlk = mem3.szKeyBlk;  mem3.iKeyBlk = 1;  mem3.aPool[0].u.hdr.size4x = (mem3.szKeyBlk<<2) + 2;  mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool;  mem3.aPool[mem3.nPool].u.hdr.size4x = 1;  return SQLITE_OK; } static void memsys3Shutdown(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  mem3.mutex = 0;  return; } SQLITE_PRIVATE void sqlite3Memsys3Dump(const char *zFilename){
#ifdef SQLITE_DEBUG
 FILE *out;  u32 i, j;  u32 size;  if( zFilename==0 || zFilename[0]==0 ){  out = stdout;  }else{  out = fopen(zFilename, "w");  if( out==0 ){  fprintf(stderr, "** Unable to output memory debug output log: %s **\n",  zFilename);  return;  }  }  memsys3Enter();  fprintf(out, "CHUNKS:\n");  for(i=1; i<=mem3.nPool; i+=size/4){  size = mem3.aPool[i-1].u.hdr.size4x;  if( size/4<=1 ){  fprintf(out, "%p size error\n", &mem3.aPool[i]);  assert( 0 );  break;  }  if( (size&1)==0 && mem3.aPool[i+size/4-1].u.hdr.prevSize!=size/4 ){  fprintf(out, "%p tail size does not match\n", &mem3.aPool[i]);  assert( 0 );  break;  }  if( ((mem3.aPool[i+size/4-1].u.hdr.size4x&2)>>1)!=(size&1) ){  fprintf(out, "%p tail checkout bit is incorrect\n", &mem3.aPool[i]);  assert( 0 );  break;  }  if( size&1 ){  fprintf(out, "%p %6d bytes checked out\n", &mem3.aPool[i], (size/4)*8-8);  }else{  fprintf(out, "%p %6d bytes free%s\n", &mem3.aPool[i], (size/4)*8-8,  i==mem3.iKeyBlk ? " **key**" : "");  }  }  for(i=0; i<MX_SMALL-1; i++){  if( mem3.aiSmall[i]==0 ) continue;  fprintf(out, "small(%2d):", i);  for(j = mem3.aiSmall[i]; j>0; j=mem3.aPool[j].u.list.next){  fprintf(out, " %p(%d)", &mem3.aPool[j],  (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);  }  fprintf(out, "\n");  }  for(i=0; i<N_HASH; i++){  if( mem3.aiHash[i]==0 ) continue;  fprintf(out, "hash(%2d):", i);  for(j = mem3.aiHash[i]; j>0; j=mem3.aPool[j].u.list.next){  fprintf(out, " %p(%d)", &mem3.aPool[j],  (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);  }  fprintf(out, "\n");  }  fprintf(out, "key=%d\n", mem3.iKeyBlk);  fprintf(out, "nowUsed=%d\n", mem3.nPool*8 - mem3.szKeyBlk*8);  fprintf(out, "mxUsed=%d\n", mem3.nPool*8 - mem3.mnKeyBlk*8);  sqlite3_mutex_leave(mem3.mutex);  if( out==stdout ){  fflush(stdout);  }else{  fclose(out);  }
#else
 UNUSED_PARAMETER(zFilename);
#endif
} SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void){  static const sqlite3_mem_methods mempoolMethods = {   memsys3Malloc,   memsys3Free,   memsys3Realloc,   memsys3Size,   memsys3Roundup,   memsys3Init,   memsys3Shutdown,   0  };  return &mempoolMethods; }
#endif
#ifdef SQLITE_ENABLE_MEMSYS5
typedef struct Mem5Link Mem5Link; struct Mem5Link {  int next;  int prev; };
#define LOGMAX 30
#define CTRL_LOGSIZE 0x1f
#define CTRL_FREE  0x20
static SQLITE_WSD struct Mem5Global {  int szAtom;  int nBlock;  u8 *zPool;  sqlite3_mutex *mutex;
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 u64 nAlloc;  u64 totalAlloc;  u64 totalExcess;  u32 currentOut;  u32 currentCount;  u32 maxOut;  u32 maxCount;  u32 maxRequest;
#endif
 int aiFreelist[LOGMAX+1];  u8 *aCtrl; } mem5;
#define mem5 GLOBAL(struct Mem5Global, mem5)
#define MEM5LINK(idx) ((Mem5Link *)(&mem5.zPool[(idx)*mem5.szAtom]))
static void memsys5Unlink(int i, int iLogsize){  int next, prev;  assert( i>=0 && i<mem5.nBlock );  assert( iLogsize>=0 && iLogsize<=LOGMAX );  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );  next = MEM5LINK(i)->next;  prev = MEM5LINK(i)->prev;  if( prev<0 ){  mem5.aiFreelist[iLogsize] = next;  }else{  MEM5LINK(prev)->next = next;  }  if( next>=0 ){  MEM5LINK(next)->prev = prev;  } } static void memsys5Link(int i, int iLogsize){  int x;  assert( sqlite3_mutex_held(mem5.mutex) );  assert( i>=0 && i<mem5.nBlock );  assert( iLogsize>=0 && iLogsize<=LOGMAX );  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );  x = MEM5LINK(i)->next = mem5.aiFreelist[iLogsize];  MEM5LINK(i)->prev = -1;  if( x>=0 ){  assert( x<mem5.nBlock );  MEM5LINK(x)->prev = i;  }  mem5.aiFreelist[iLogsize] = i; } static void memsys5Enter(void){  sqlite3_mutex_enter(mem5.mutex); } static void memsys5Leave(void){  sqlite3_mutex_leave(mem5.mutex); } static int memsys5Size(void *p){  int iSize, i;  assert( p!=0 );  i = (int)(((u8 *)p-mem5.zPool)/mem5.szAtom);  assert( i>=0 && i<mem5.nBlock );  iSize = mem5.szAtom * (1 << (mem5.aCtrl[i]&CTRL_LOGSIZE));  return iSize; } static void *memsys5MallocUnsafe(int nByte){  int i;  int iBin;  int iFullSz;  int iLogsize;  assert( nByte>0 );  if( nByte > 0x40000000 ) return 0;
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 if( (u32)nByte>mem5.maxRequest ){  mem5.maxRequest = nByte;  }
#endif
 for(iFullSz=mem5.szAtom,iLogsize=0; iFullSz<nByte; iFullSz*=2,iLogsize++){}  for(iBin=iLogsize; iBin<=LOGMAX && mem5.aiFreelist[iBin]<0; iBin++){}  if( iBin>LOGMAX ){  testcase( sqlite3GlobalConfig.xLog!=0 );  sqlite3_log(SQLITE_NOMEM, "failed to allocate %u bytes", nByte);  return 0;  }  i = mem5.aiFreelist[iBin];  memsys5Unlink(i, iBin);  while( iBin>iLogsize ){  int newSize;  iBin--;  newSize = 1 << iBin;  mem5.aCtrl[i+newSize] = CTRL_FREE | iBin;  memsys5Link(i+newSize, iBin);  }  mem5.aCtrl[i] = iLogsize;
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 mem5.nAlloc++;  mem5.totalAlloc += iFullSz;  mem5.totalExcess += iFullSz - nByte;  mem5.currentCount++;  mem5.currentOut += iFullSz;  if( mem5.maxCount<mem5.currentCount ) mem5.maxCount = mem5.currentCount;  if( mem5.maxOut<mem5.currentOut ) mem5.maxOut = mem5.currentOut;
#endif
#ifdef SQLITE_DEBUG
 memset(&mem5.zPool[i*mem5.szAtom], 0xAA, iFullSz);
#endif
 return (void*)&mem5.zPool[i*mem5.szAtom]; } static void memsys5FreeUnsafe(void *pOld){  u32 size, iLogsize;  int iBlock;  iBlock = (int)(((u8 *)pOld-mem5.zPool)/mem5.szAtom);  assert( iBlock>=0 && iBlock<mem5.nBlock );  assert( ((u8 *)pOld-mem5.zPool)%mem5.szAtom==0 );  assert( (mem5.aCtrl[iBlock] & CTRL_FREE)==0 );  iLogsize = mem5.aCtrl[iBlock] & CTRL_LOGSIZE;  size = 1<<iLogsize;  assert( iBlock+size-1<(u32)mem5.nBlock );  mem5.aCtrl[iBlock] |= CTRL_FREE;  mem5.aCtrl[iBlock+size-1] |= CTRL_FREE;
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 assert( mem5.currentCount>0 );  assert( mem5.currentOut>=(size*mem5.szAtom) );  mem5.currentCount--;  mem5.currentOut -= size*mem5.szAtom;  assert( mem5.currentOut>0 || mem5.currentCount==0 );  assert( mem5.currentCount>0 || mem5.currentOut==0 );
#endif
 mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;  while( ALWAYS(iLogsize<LOGMAX) ){  int iBuddy;  if( (iBlock>>iLogsize) & 1 ){  iBuddy = iBlock - size;  assert( iBuddy>=0 );  }else{  iBuddy = iBlock + size;  if( iBuddy>=mem5.nBlock ) break;  }  if( mem5.aCtrl[iBuddy]!=(CTRL_FREE | iLogsize) ) break;  memsys5Unlink(iBuddy, iLogsize);  iLogsize++;  if( iBuddy<iBlock ){  mem5.aCtrl[iBuddy] = CTRL_FREE | iLogsize;  mem5.aCtrl[iBlock] = 0;  iBlock = iBuddy;  }else{  mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;  mem5.aCtrl[iBuddy] = 0;  }  size *= 2;  }
#ifdef SQLITE_DEBUG
 memset(&mem5.zPool[iBlock*mem5.szAtom], 0x55, size);
#endif
 memsys5Link(iBlock, iLogsize); } static void *memsys5Malloc(int nBytes){  sqlite3_int64 *p = 0;  if( nBytes>0 ){  memsys5Enter();  p = memsys5MallocUnsafe(nBytes);  memsys5Leave();  }  return (void*)p; } static void memsys5Free(void *pPrior){  assert( pPrior!=0 );  memsys5Enter();  memsys5FreeUnsafe(pPrior);  memsys5Leave(); } static void *memsys5Realloc(void *pPrior, int nBytes){  int nOld;  void *p;  assert( pPrior!=0 );  assert( (nBytes&(nBytes-1))==0 );  assert( nBytes>=0 );  if( nBytes==0 ){  return 0;  }  nOld = memsys5Size(pPrior);  if( nBytes<=nOld ){  return pPrior;  }  p = memsys5Malloc(nBytes);  if( p ){  memcpy(p, pPrior, nOld);  memsys5Free(pPrior);  }  return p; } static int memsys5Roundup(int n){  int iFullSz;  if( n > 0x40000000 ) return 0;  for(iFullSz=mem5.szAtom; iFullSz<n; iFullSz *= 2);  return iFullSz; } static int memsys5Log(int iValue){  int iLog;  for(iLog=0; (iLog<(int)((sizeof(int)*8)-1)) && (1<<iLog)<iValue; iLog++);  return iLog; } static int memsys5Init(void *NotUsed){  int ii;  int nByte;  u8 *zByte;  int nMinLog;  int iOffset;  UNUSED_PARAMETER(NotUsed);  mem5.mutex = 0;  assert( (sizeof(Mem5Link)&(sizeof(Mem5Link)-1))==0 );  nByte = sqlite3GlobalConfig.nHeap;  zByte = (u8*)sqlite3GlobalConfig.pHeap;  assert( zByte!=0 );  nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq);  mem5.szAtom = (1<<nMinLog);  while( (int)sizeof(Mem5Link)>mem5.szAtom ){  mem5.szAtom = mem5.szAtom << 1;  }  mem5.nBlock = (nByte / (mem5.szAtom+sizeof(u8)));  mem5.zPool = zByte;  mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.szAtom];  for(ii=0; ii<=LOGMAX; ii++){  mem5.aiFreelist[ii] = -1;  }  iOffset = 0;  for(ii=LOGMAX; ii>=0; ii--){  int nAlloc = (1<<ii);  if( (iOffset+nAlloc)<=mem5.nBlock ){  mem5.aCtrl[iOffset] = ii | CTRL_FREE;  memsys5Link(iOffset, ii);  iOffset += nAlloc;  }  assert((iOffset+nAlloc)>mem5.nBlock);  }  if( sqlite3GlobalConfig.bMemstat==0 ){  mem5.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);  }  return SQLITE_OK; } static void memsys5Shutdown(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  mem5.mutex = 0;  return; }
#ifdef SQLITE_TEST
SQLITE_PRIVATE void sqlite3Memsys5Dump(const char *zFilename){  FILE *out;  int i, j, n;  int nMinLog;  if( zFilename==0 || zFilename[0]==0 ){  out = stdout;  }else{  out = fopen(zFilename, "w");  if( out==0 ){  fprintf(stderr, "** Unable to output memory debug output log: %s **\n",  zFilename);  return;  }  }  memsys5Enter();  nMinLog = memsys5Log(mem5.szAtom);  for(i=0; i<=LOGMAX && i+nMinLog<32; i++){  for(n=0, j=mem5.aiFreelist[i]; j>=0; j = MEM5LINK(j)->next, n++){}  fprintf(out, "freelist items of size %d: %d\n", mem5.szAtom << i, n);  }  fprintf(out, "mem5.nAlloc  = %llu\n", mem5.nAlloc);  fprintf(out, "mem5.totalAlloc  = %llu\n", mem5.totalAlloc);  fprintf(out, "mem5.totalExcess = %llu\n", mem5.totalExcess);  fprintf(out, "mem5.currentOut  = %u\n", mem5.currentOut);  fprintf(out, "mem5.currentCount = %u\n", mem5.currentCount);  fprintf(out, "mem5.maxOut  = %u\n", mem5.maxOut);  fprintf(out, "mem5.maxCount  = %u\n", mem5.maxCount);  fprintf(out, "mem5.maxRequest  = %u\n", mem5.maxRequest);  memsys5Leave();  if( out==stdout ){  fflush(stdout);  }else{  fclose(out);  } }
#endif
SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){  static const sqlite3_mem_methods memsys5Methods = {   memsys5Malloc,   memsys5Free,   memsys5Realloc,   memsys5Size,   memsys5Roundup,   memsys5Init,   memsys5Shutdown,   0  };  return &memsys5Methods; }
#endif
#if defined(SQLITE_DEBUG) && !defined(SQLITE_MUTEX_OMIT)
static SQLITE_WSD int mutexIsInit = 0;
#endif
#ifndef SQLITE_MUTEX_OMIT
#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS
typedef struct CheckMutex CheckMutex; struct CheckMutex {  int iType;  sqlite3_mutex *mutex; };
#define SQLITE_MUTEX_WARNONCONTENTION (-1)
static SQLITE_WSD const sqlite3_mutex_methods *pGlobalMutexMethods;
#ifdef SQLITE_DEBUG
static int checkMutexHeld(sqlite3_mutex *p){  return pGlobalMutexMethods->xMutexHeld(((CheckMutex*)p)->mutex); } static int checkMutexNotheld(sqlite3_mutex *p){  return pGlobalMutexMethods->xMutexNotheld(((CheckMutex*)p)->mutex); }
#endif
static int checkMutexInit(void){  pGlobalMutexMethods = sqlite3DefaultMutex();  return SQLITE_OK; } static int checkMutexEnd(void){  pGlobalMutexMethods = 0;  return SQLITE_OK; } static sqlite3_mutex *checkMutexAlloc(int iType){  static CheckMutex staticMutexes[] = {  {2, 0}, {3, 0}, {4, 0}, {5, 0},  {6, 0}, {7, 0}, {8, 0}, {9, 0},  {10, 0}, {11, 0}, {12, 0}, {13, 0}  };  CheckMutex *p = 0;  assert( SQLITE_MUTEX_RECURSIVE==1 && SQLITE_MUTEX_FAST==0 );  if( iType<2 ){  p = sqlite3MallocZero(sizeof(CheckMutex));  if( p==0 ) return 0;  p->iType = iType;  }else{
#ifdef SQLITE_ENABLE_API_ARMOR
 if( iType-2>=ArraySize(staticMutexes) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 p = &staticMutexes[iType-2];  }  if( p->mutex==0 ){  p->mutex = pGlobalMutexMethods->xMutexAlloc(iType);  if( p->mutex==0 ){  if( iType<2 ){  sqlite3_free(p);  }  p = 0;  }  }  return (sqlite3_mutex*)p; } static void checkMutexFree(sqlite3_mutex *p){  assert( SQLITE_MUTEX_RECURSIVE<2 );  assert( SQLITE_MUTEX_FAST<2 );  assert( SQLITE_MUTEX_WARNONCONTENTION<2 );
#if SQLITE_ENABLE_API_ARMOR
 if( ((CheckMutex*)p)->iType<2 )
#endif
 {  CheckMutex *pCheck = (CheckMutex*)p;  pGlobalMutexMethods->xMutexFree(pCheck->mutex);  sqlite3_free(pCheck);  }
#ifdef SQLITE_ENABLE_API_ARMOR
 else{  (void)SQLITE_MISUSE_BKPT;  }
#endif
} static void checkMutexEnter(sqlite3_mutex *p){  CheckMutex *pCheck = (CheckMutex*)p;  if( pCheck->iType==SQLITE_MUTEX_WARNONCONTENTION ){  if( SQLITE_OK==pGlobalMutexMethods->xMutexTry(pCheck->mutex) ){  return;  }  sqlite3_log(SQLITE_MISUSE,  "illegal multi-threaded access to database connection"  );  }  pGlobalMutexMethods->xMutexEnter(pCheck->mutex); } static int checkMutexTry(sqlite3_mutex *p){  CheckMutex *pCheck = (CheckMutex*)p;  return pGlobalMutexMethods->xMutexTry(pCheck->mutex); } static void checkMutexLeave(sqlite3_mutex *p){  CheckMutex *pCheck = (CheckMutex*)p;  pGlobalMutexMethods->xMutexLeave(pCheck->mutex); } sqlite3_mutex_methods const *multiThreadedCheckMutex(void){  static const sqlite3_mutex_methods sMutex = {  checkMutexInit,  checkMutexEnd,  checkMutexAlloc,  checkMutexFree,  checkMutexEnter,  checkMutexTry,  checkMutexLeave,
#ifdef SQLITE_DEBUG
 checkMutexHeld,  checkMutexNotheld
#else
 0,  0
#endif
 };  return &sMutex; } SQLITE_PRIVATE void sqlite3MutexWarnOnContention(sqlite3_mutex *p){  if( sqlite3GlobalConfig.mutex.xMutexAlloc==checkMutexAlloc ){  CheckMutex *pCheck = (CheckMutex*)p;  assert( pCheck->iType==SQLITE_MUTEX_RECURSIVE );  pCheck->iType = SQLITE_MUTEX_WARNONCONTENTION;  } }
#endif
SQLITE_PRIVATE int sqlite3MutexInit(void){  int rc = SQLITE_OK;  if( !sqlite3GlobalConfig.mutex.xMutexAlloc ){  sqlite3_mutex_methods const *pFrom;  sqlite3_mutex_methods *pTo = &sqlite3GlobalConfig.mutex;  if( sqlite3GlobalConfig.bCoreMutex ){
#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS
 pFrom = multiThreadedCheckMutex();
#else
 pFrom = sqlite3DefaultMutex();
#endif
 }else{  pFrom = sqlite3NoopMutex();  }  pTo->xMutexInit = pFrom->xMutexInit;  pTo->xMutexEnd = pFrom->xMutexEnd;  pTo->xMutexFree = pFrom->xMutexFree;  pTo->xMutexEnter = pFrom->xMutexEnter;  pTo->xMutexTry = pFrom->xMutexTry;  pTo->xMutexLeave = pFrom->xMutexLeave;  pTo->xMutexHeld = pFrom->xMutexHeld;  pTo->xMutexNotheld = pFrom->xMutexNotheld;  sqlite3MemoryBarrier();  pTo->xMutexAlloc = pFrom->xMutexAlloc;  }  assert( sqlite3GlobalConfig.mutex.xMutexInit );  rc = sqlite3GlobalConfig.mutex.xMutexInit();
#ifdef SQLITE_DEBUG
 GLOBAL(int, mutexIsInit) = 1;
#endif
 sqlite3MemoryBarrier();  return rc; } SQLITE_PRIVATE int sqlite3MutexEnd(void){  int rc = SQLITE_OK;  if( sqlite3GlobalConfig.mutex.xMutexEnd ){  rc = sqlite3GlobalConfig.mutex.xMutexEnd();  }
#ifdef SQLITE_DEBUG
 GLOBAL(int, mutexIsInit) = 0;
#endif
 return rc; } SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){
#ifndef SQLITE_OMIT_AUTOINIT
 if( id<=SQLITE_MUTEX_RECURSIVE && sqlite3_initialize() ) return 0;  if( id>SQLITE_MUTEX_RECURSIVE && sqlite3MutexInit() ) return 0;
#endif
 assert( sqlite3GlobalConfig.mutex.xMutexAlloc );  return sqlite3GlobalConfig.mutex.xMutexAlloc(id); } SQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){  if( !sqlite3GlobalConfig.bCoreMutex ){  return 0;  }  assert( GLOBAL(int, mutexIsInit) );  assert( sqlite3GlobalConfig.mutex.xMutexAlloc );  return sqlite3GlobalConfig.mutex.xMutexAlloc(id); } SQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){  if( p ){  assert( sqlite3GlobalConfig.mutex.xMutexFree );  sqlite3GlobalConfig.mutex.xMutexFree(p);  } } SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){  if( p ){  assert( sqlite3GlobalConfig.mutex.xMutexEnter );  sqlite3GlobalConfig.mutex.xMutexEnter(p);  } } SQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){  int rc = SQLITE_OK;  if( p ){  assert( sqlite3GlobalConfig.mutex.xMutexTry );  return sqlite3GlobalConfig.mutex.xMutexTry(p);  }  return rc; } SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){  if( p ){  assert( sqlite3GlobalConfig.mutex.xMutexLeave );  sqlite3GlobalConfig.mutex.xMutexLeave(p);  } }
#ifndef NDEBUG
SQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p){  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexHeld );  return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p); } SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p){  assert( p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld );  return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p); }
#endif
#endif
#ifndef SQLITE_MUTEX_OMIT
#ifndef SQLITE_DEBUG
static int noopMutexInit(void){ return SQLITE_OK; } static int noopMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *noopMutexAlloc(int id){  UNUSED_PARAMETER(id);  return (sqlite3_mutex*)8; } static void noopMutexFree(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; } static void noopMutexEnter(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; } static int noopMutexTry(sqlite3_mutex *p){  UNUSED_PARAMETER(p);  return SQLITE_OK; } static void noopMutexLeave(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; } SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){  static const sqlite3_mutex_methods sMutex = {  noopMutexInit,  noopMutexEnd,  noopMutexAlloc,  noopMutexFree,  noopMutexEnter,  noopMutexTry,  noopMutexLeave,  0,  0,  };  return &sMutex; }
#endif
#ifdef SQLITE_DEBUG
typedef struct sqlite3_debug_mutex {  int id;  int cnt; } sqlite3_debug_mutex; static int debugMutexHeld(sqlite3_mutex *pX){  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;  return p==0 || p->cnt>0; } static int debugMutexNotheld(sqlite3_mutex *pX){  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;  return p==0 || p->cnt==0; } static int debugMutexInit(void){ return SQLITE_OK; } static int debugMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *debugMutexAlloc(int id){  static sqlite3_debug_mutex aStatic[SQLITE_MUTEX_STATIC_VFS3 - 1];  sqlite3_debug_mutex *pNew = 0;  switch( id ){  case SQLITE_MUTEX_FAST:  case SQLITE_MUTEX_RECURSIVE: {  pNew = sqlite3Malloc(sizeof(*pNew));  if( pNew ){  pNew->id = id;  pNew->cnt = 0;  }  break;  }  default: {
#ifdef SQLITE_ENABLE_API_ARMOR
 if( id-2<0 || id-2>=ArraySize(aStatic) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 pNew = &aStatic[id-2];  pNew->id = id;  break;  }  }  return (sqlite3_mutex*)pNew; } static void debugMutexFree(sqlite3_mutex *pX){  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;  assert( p->cnt==0 );  if( p->id==SQLITE_MUTEX_RECURSIVE || p->id==SQLITE_MUTEX_FAST ){  sqlite3_free(p);  }else{
#ifdef SQLITE_ENABLE_API_ARMOR
 (void)SQLITE_MISUSE_BKPT;
#endif
 } } static void debugMutexEnter(sqlite3_mutex *pX){  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );  p->cnt++; } static int debugMutexTry(sqlite3_mutex *pX){  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );  p->cnt++;  return SQLITE_OK; } static void debugMutexLeave(sqlite3_mutex *pX){  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;  assert( debugMutexHeld(pX) );  p->cnt--;  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) ); } SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){  static const sqlite3_mutex_methods sMutex = {  debugMutexInit,  debugMutexEnd,  debugMutexAlloc,  debugMutexFree,  debugMutexEnter,  debugMutexTry,  debugMutexLeave,  debugMutexHeld,  debugMutexNotheld  };  return &sMutex; }
#endif
#ifdef SQLITE_MUTEX_NOOP
SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){  return sqlite3NoopMutex(); }
#endif
#endif
#ifdef SQLITE_MUTEX_PTHREADS
#include <pthread.h>
#if defined(SQLITE_DEBUG) || defined(SQLITE_HOMEGROWN_RECURSIVE_MUTEX)
# define SQLITE_MUTEX_NREF 1
#else
# define SQLITE_MUTEX_NREF 0
#endif
struct sqlite3_mutex {  pthread_mutex_t mutex;
#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
 int id;
#endif
#if SQLITE_MUTEX_NREF
 volatile int nRef;  volatile pthread_t owner;  int trace;
#endif
};
#if SQLITE_MUTEX_NREF
# define SQLITE3_MUTEX_INITIALIZER(id)   {PTHREAD_MUTEX_INITIALIZER,id,0,(pthread_t)0,0}

#elif defined(SQLITE_ENABLE_API_ARMOR)
# define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER, id }
#else
#define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER }
#endif
#if !defined(NDEBUG) || defined(SQLITE_DEBUG)
static int pthreadMutexHeld(sqlite3_mutex *p){  return (p->nRef!=0 && pthread_equal(p->owner, pthread_self())); } static int pthreadMutexNotheld(sqlite3_mutex *p){  return p->nRef==0 || pthread_equal(p->owner, pthread_self())==0; }
#endif
SQLITE_PRIVATE void sqlite3MemoryBarrier(void){
#if defined(SQLITE_MEMORY_BARRIER)
 SQLITE_MEMORY_BARRIER;
#elif defined(__GNUC__) && GCC_VERSION>=4001000
 __sync_synchronize();
#endif
} static int pthreadMutexInit(void){ return SQLITE_OK; } static int pthreadMutexEnd(void){ return SQLITE_OK; } static sqlite3_mutex *pthreadMutexAlloc(int iType){  static sqlite3_mutex staticMutexes[] = {  SQLITE3_MUTEX_INITIALIZER(2),  SQLITE3_MUTEX_INITIALIZER(3),  SQLITE3_MUTEX_INITIALIZER(4),  SQLITE3_MUTEX_INITIALIZER(5),  SQLITE3_MUTEX_INITIALIZER(6),  SQLITE3_MUTEX_INITIALIZER(7),  SQLITE3_MUTEX_INITIALIZER(8),  SQLITE3_MUTEX_INITIALIZER(9),  SQLITE3_MUTEX_INITIALIZER(10),  SQLITE3_MUTEX_INITIALIZER(11),  SQLITE3_MUTEX_INITIALIZER(12),  SQLITE3_MUTEX_INITIALIZER(13)  };  sqlite3_mutex *p;  switch( iType ){  case SQLITE_MUTEX_RECURSIVE: {  p = sqlite3MallocZero( sizeof(*p) );  if( p ){
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
 pthread_mutex_init(&p->mutex, 0);
#else
 pthread_mutexattr_t recursiveAttr;  pthread_mutexattr_init(&recursiveAttr);  pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);  pthread_mutex_init(&p->mutex, &recursiveAttr);  pthread_mutexattr_destroy(&recursiveAttr);
#endif
#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
 p->id = SQLITE_MUTEX_RECURSIVE;
#endif
 }  break;  }  case SQLITE_MUTEX_FAST: {  p = sqlite3MallocZero( sizeof(*p) );  if( p ){  pthread_mutex_init(&p->mutex, 0);
#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
 p->id = SQLITE_MUTEX_FAST;
#endif
 }  break;  }  default: {
#ifdef SQLITE_ENABLE_API_ARMOR
 if( iType-2<0 || iType-2>=ArraySize(staticMutexes) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 p = &staticMutexes[iType-2];  break;  }  }
#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
 assert( p==0 || p->id==iType );
#endif
 return p; } static void pthreadMutexFree(sqlite3_mutex *p){  assert( p->nRef==0 );
#if SQLITE_ENABLE_API_ARMOR
 if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE )
#endif
 {  pthread_mutex_destroy(&p->mutex);  sqlite3_free(p);  }
#ifdef SQLITE_ENABLE_API_ARMOR
 else{  (void)SQLITE_MISUSE_BKPT;  }
#endif
} static void pthreadMutexEnter(sqlite3_mutex *p){  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
 {  pthread_t self = pthread_self();  if( p->nRef>0 && pthread_equal(p->owner, self) ){  p->nRef++;  }else{  pthread_mutex_lock(&p->mutex);  assert( p->nRef==0 );  p->owner = self;  p->nRef = 1;  }  }
#else
 pthread_mutex_lock(&p->mutex);
#if SQLITE_MUTEX_NREF
 assert( p->nRef>0 || p->owner==0 );  p->owner = pthread_self();  p->nRef++;
#endif
#endif
#ifdef SQLITE_DEBUG
 if( p->trace ){  printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);  }
#endif
} static int pthreadMutexTry(sqlite3_mutex *p){  int rc;  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
 {  pthread_t self = pthread_self();  if( p->nRef>0 && pthread_equal(p->owner, self) ){  p->nRef++;  rc = SQLITE_OK;  }else if( pthread_mutex_trylock(&p->mutex)==0 ){  assert( p->nRef==0 );  p->owner = self;  p->nRef = 1;  rc = SQLITE_OK;  }else{  rc = SQLITE_BUSY;  }  }
#else
 if( pthread_mutex_trylock(&p->mutex)==0 ){
#if SQLITE_MUTEX_NREF
 p->owner = pthread_self();  p->nRef++;
#endif
 rc = SQLITE_OK;  }else{  rc = SQLITE_BUSY;  }
#endif
#ifdef SQLITE_DEBUG
 if( rc==SQLITE_OK && p->trace ){  printf("enter mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);  }
#endif
 return rc; } static void pthreadMutexLeave(sqlite3_mutex *p){  assert( pthreadMutexHeld(p) );
#if SQLITE_MUTEX_NREF
 p->nRef--;  if( p->nRef==0 ) p->owner = 0;
#endif
 assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );
#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX
 if( p->nRef==0 ){  pthread_mutex_unlock(&p->mutex);  }
#else
 pthread_mutex_unlock(&p->mutex);
#endif
#ifdef SQLITE_DEBUG
 if( p->trace ){  printf("leave mutex %p (%d) with nRef=%d\n", p, p->trace, p->nRef);  }
#endif
} SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){  static const sqlite3_mutex_methods sMutex = {  pthreadMutexInit,  pthreadMutexEnd,  pthreadMutexAlloc,  pthreadMutexFree,  pthreadMutexEnter,  pthreadMutexTry,  pthreadMutexLeave,
#ifdef SQLITE_DEBUG
 pthreadMutexHeld,  pthreadMutexNotheld
#else
 0,  0
#endif
 };  return &sMutex; }
#endif
#if SQLITE_OS_WIN
#ifndef SQLITE_OS_WIN_H
#define SQLITE_OS_WIN_H
#include "h/windows.h"
#ifdef __CYGWIN__
# include <sys/cygwin.h>
# include <errno.h>
#endif
#if SQLITE_OS_WIN && !defined(SQLITE_OS_WINNT)
# define SQLITE_OS_WINNT 1
#endif
#if defined(_WIN32_WCE)
# define SQLITE_OS_WINCE 1
#else
# define SQLITE_OS_WINCE 0
#endif
#if !defined(SQLITE_OS_WINRT)
# define SQLITE_OS_WINRT 0
#endif
#if SQLITE_OS_WINCE
# define SQLITE_WIN32_VOLATILE
#else
# define SQLITE_WIN32_VOLATILE volatile
#endif
#if SQLITE_OS_WIN && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT &&  SQLITE_THREADSAFE>0 && !defined(__CYGWIN__)

# define SQLITE_OS_WIN_THREADS 1
#else
# define SQLITE_OS_WIN_THREADS 0
#endif
#endif
#endif
#ifdef SQLITE_MUTEX_W32
struct sqlite3_mutex {  CRITICAL_SECTION mutex;  int id;
#ifdef SQLITE_DEBUG
 volatile int nRef;  volatile DWORD owner;  volatile LONG trace;
#endif
};
#define SQLITE_W32_MUTEX_INITIALIZER { 0 }
#ifdef SQLITE_DEBUG
#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id,  0L, (DWORD)0, 0 }

#else
#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id }
#endif
#ifdef SQLITE_DEBUG
static int winMutexHeld(sqlite3_mutex *p){  return p->nRef!=0 && p->owner==GetCurrentThreadId(); } static int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){  return p->nRef==0 || p->owner!=tid; } static int winMutexNotheld(sqlite3_mutex *p){  DWORD tid = GetCurrentThreadId();  return winMutexNotheld2(p, tid); }
#endif
SQLITE_PRIVATE void sqlite3MemoryBarrier(void){
#if defined(SQLITE_MEMORY_BARRIER)
 SQLITE_MEMORY_BARRIER;
#elif defined(__GNUC__)
 __sync_synchronize();
#elif MSVC_VERSION>=1300
 _ReadWriteBarrier();
#elif defined(MemoryBarrier)
 MemoryBarrier();
#endif
} static sqlite3_mutex winMutex_staticMutexes[] = {  SQLITE3_MUTEX_INITIALIZER(2),  SQLITE3_MUTEX_INITIALIZER(3),  SQLITE3_MUTEX_INITIALIZER(4),  SQLITE3_MUTEX_INITIALIZER(5),  SQLITE3_MUTEX_INITIALIZER(6),  SQLITE3_MUTEX_INITIALIZER(7),  SQLITE3_MUTEX_INITIALIZER(8),  SQLITE3_MUTEX_INITIALIZER(9),  SQLITE3_MUTEX_INITIALIZER(10),  SQLITE3_MUTEX_INITIALIZER(11),  SQLITE3_MUTEX_INITIALIZER(12),  SQLITE3_MUTEX_INITIALIZER(13) }; static int winMutex_isInit = 0; static int winMutex_isNt = -1; static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0; SQLITE_API int sqlite3_win32_is_nt(void); SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds); static int winMutexInit(void){  if( InterlockedCompareExchange(&winMutex_lock, 1, 0)==0 ){  int i;  for(i=0; i<ArraySize(winMutex_staticMutexes); i++){
#if SQLITE_OS_WINRT
 InitializeCriticalSectionEx(&winMutex_staticMutexes[i].mutex, 0, 0);
#else
 InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);
#endif
 }  winMutex_isInit = 1;  }else{  while( !winMutex_isInit ){  sqlite3_win32_sleep(1);  }  }  return SQLITE_OK; } static int winMutexEnd(void){  if( InterlockedCompareExchange(&winMutex_lock, 0, 1)==1 ){  if( winMutex_isInit==1 ){  int i;  for(i=0; i<ArraySize(winMutex_staticMutexes); i++){  DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);  }  winMutex_isInit = 0;  }  }  return SQLITE_OK; } static sqlite3_mutex *winMutexAlloc(int iType){  sqlite3_mutex *p;  switch( iType ){  case SQLITE_MUTEX_FAST:  case SQLITE_MUTEX_RECURSIVE: {  p = sqlite3MallocZero( sizeof(*p) );  if( p ){  p->id = iType;
#ifdef SQLITE_DEBUG
#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMIC
 p->trace = 1;
#endif
#endif
#if SQLITE_OS_WINRT
 InitializeCriticalSectionEx(&p->mutex, 0, 0);
#else
 InitializeCriticalSection(&p->mutex);
#endif
 }  break;  }  default: {
#ifdef SQLITE_ENABLE_API_ARMOR
 if( iType-2<0 || iType-2>=ArraySize(winMutex_staticMutexes) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 p = &winMutex_staticMutexes[iType-2];
#ifdef SQLITE_DEBUG
#ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC
 InterlockedCompareExchange(&p->trace, 1, 0);
#endif
#endif
 break;  }  }  assert( p==0 || p->id==iType );  return p; } static void winMutexFree(sqlite3_mutex *p){  assert( p );  assert( p->nRef==0 && p->owner==0 );  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){  DeleteCriticalSection(&p->mutex);  sqlite3_free(p);  }else{
#ifdef SQLITE_ENABLE_API_ARMOR
 (void)SQLITE_MISUSE_BKPT;
#endif
 } } static void winMutexEnter(sqlite3_mutex *p){
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 DWORD tid = GetCurrentThreadId();
#endif
#ifdef SQLITE_DEBUG
 assert( p );  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );
#else
 assert( p );
#endif
 assert( winMutex_isInit==1 );  EnterCriticalSection(&p->mutex);
#ifdef SQLITE_DEBUG
 assert( p->nRef>0 || p->owner==0 );  p->owner = tid;  p->nRef++;  if( p->trace ){  OSTRACE(("ENTER-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",   tid, p->id, p, p->trace, p->nRef));  }
#endif
} static int winMutexTry(sqlite3_mutex *p){
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 DWORD tid = GetCurrentThreadId();
#endif
 int rc = SQLITE_BUSY;  assert( p );  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );
#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400
 assert( winMutex_isInit==1 );  assert( winMutex_isNt>=-1 && winMutex_isNt<=1 );  if( winMutex_isNt<0 ){  winMutex_isNt = sqlite3_win32_is_nt();  }  assert( winMutex_isNt==0 || winMutex_isNt==1 );  if( winMutex_isNt && TryEnterCriticalSection(&p->mutex) ){
#ifdef SQLITE_DEBUG
 p->owner = tid;  p->nRef++;
#endif
 rc = SQLITE_OK;  }
#else
 UNUSED_PARAMETER(p);
#endif
#ifdef SQLITE_DEBUG
 if( p->trace ){  OSTRACE(("TRY-MUTEX tid=%lu, mutex(%d)=%p (%d), owner=%lu, nRef=%d, rc=%s\n",   tid, p->id, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));  }
#endif
 return rc; } static void winMutexLeave(sqlite3_mutex *p){
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 DWORD tid = GetCurrentThreadId();
#endif
 assert( p );
#ifdef SQLITE_DEBUG
 assert( p->nRef>0 );  assert( p->owner==tid );  p->nRef--;  if( p->nRef==0 ) p->owner = 0;  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );
#endif
 assert( winMutex_isInit==1 );  LeaveCriticalSection(&p->mutex);
#ifdef SQLITE_DEBUG
 if( p->trace ){  OSTRACE(("LEAVE-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\n",   tid, p->id, p, p->trace, p->nRef));  }
#endif
} SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){  static const sqlite3_mutex_methods sMutex = {  winMutexInit,  winMutexEnd,  winMutexAlloc,  winMutexFree,  winMutexEnter,  winMutexTry,  winMutexLeave,
#ifdef SQLITE_DEBUG
 winMutexHeld,  winMutexNotheld
#else
 0,  0
#endif
 };  return &sMutex; }
#endif
SQLITE_API int sqlite3_release_memory(int n){
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 return sqlite3PcacheReleaseMemory(n);
#else
 UNUSED_PARAMETER(n);  return 0;
#endif
}
#ifndef SQLITE_MAX_MEMORY
# define SQLITE_MAX_MEMORY 0
#endif
static SQLITE_WSD struct Mem0Global {  sqlite3_mutex *mutex;  sqlite3_int64 alarmThreshold;  sqlite3_int64 hardLimit;  int nearlyFull; } mem0 = { 0, SQLITE_MAX_MEMORY, SQLITE_MAX_MEMORY, 0 };
#define mem0 GLOBAL(struct Mem0Global, mem0)
SQLITE_PRIVATE sqlite3_mutex *sqlite3MallocMutex(void){  return mem0.mutex; }
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API int sqlite3_memory_alarm(  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),  void *pArg,  sqlite3_int64 iThreshold ){  (void)xCallback;  (void)pArg;  (void)iThreshold;  return SQLITE_OK; }
#endif
SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){  sqlite3_int64 priorLimit;  sqlite3_int64 excess;  sqlite3_int64 nUsed;
#ifndef SQLITE_OMIT_AUTOINIT
 int rc = sqlite3_initialize();  if( rc ) return -1;
#endif
 sqlite3_mutex_enter(mem0.mutex);  priorLimit = mem0.alarmThreshold;  if( n<0 ){  sqlite3_mutex_leave(mem0.mutex);  return priorLimit;  }  if( mem0.hardLimit>0 && (n>mem0.hardLimit || n==0) ){  n = mem0.hardLimit;  }  mem0.alarmThreshold = n;  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);  AtomicStore(&mem0.nearlyFull, n>0 && n<=nUsed);  sqlite3_mutex_leave(mem0.mutex);  excess = sqlite3_memory_used() - n;  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));  return priorLimit; } SQLITE_API void sqlite3_soft_heap_limit(int n){  if( n<0 ) n = 0;  sqlite3_soft_heap_limit64(n); } SQLITE_API sqlite3_int64 sqlite3_hard_heap_limit64(sqlite3_int64 n){  sqlite3_int64 priorLimit;
#ifndef SQLITE_OMIT_AUTOINIT
 int rc = sqlite3_initialize();  if( rc ) return -1;
#endif
 sqlite3_mutex_enter(mem0.mutex);  priorLimit = mem0.hardLimit;  if( n>=0 ){  mem0.hardLimit = n;  if( n<mem0.alarmThreshold || mem0.alarmThreshold==0 ){  mem0.alarmThreshold = n;  }  }  sqlite3_mutex_leave(mem0.mutex);  return priorLimit; } SQLITE_PRIVATE int sqlite3MallocInit(void){  int rc;  if( sqlite3GlobalConfig.m.xMalloc==0 ){  sqlite3MemSetDefault();  }  mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);  if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512  || sqlite3GlobalConfig.nPage<=0 ){  sqlite3GlobalConfig.pPage = 0;  sqlite3GlobalConfig.szPage = 0;  }  rc = sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);  if( rc!=SQLITE_OK ) memset(&mem0, 0, sizeof(mem0));  return rc; } SQLITE_PRIVATE int sqlite3HeapNearlyFull(void){  return AtomicLoad(&mem0.nearlyFull); } SQLITE_PRIVATE void sqlite3MallocEnd(void){  if( sqlite3GlobalConfig.m.xShutdown ){  sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData);  }  memset(&mem0, 0, sizeof(mem0)); } SQLITE_API sqlite3_int64 sqlite3_memory_used(void){  sqlite3_int64 res, mx;  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, 0);  return res; } SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){  sqlite3_int64 res, mx;  sqlite3_status64(SQLITE_STATUS_MEMORY_USED, &res, &mx, resetFlag);  return mx; } static void sqlite3MallocAlarm(int nByte){  if( mem0.alarmThreshold<=0 ) return;  sqlite3_mutex_leave(mem0.mutex);  sqlite3_release_memory(nByte);  sqlite3_mutex_enter(mem0.mutex); } static void mallocWithAlarm(int n, void **pp){  void *p;  int nFull;  assert( sqlite3_mutex_held(mem0.mutex) );  assert( n>0 );  nFull = sqlite3GlobalConfig.m.xRoundup(n);  sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, n);  if( mem0.alarmThreshold>0 ){  sqlite3_int64 nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);  if( nUsed >= mem0.alarmThreshold - nFull ){  AtomicStore(&mem0.nearlyFull, 1);  sqlite3MallocAlarm(nFull);  if( mem0.hardLimit ){  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);  if( nUsed >= mem0.hardLimit - nFull ){  *pp = 0;  return;  }  }  }else{  AtomicStore(&mem0.nearlyFull, 0);  }  }  p = sqlite3GlobalConfig.m.xMalloc(nFull);
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 if( p==0 && mem0.alarmThreshold>0 ){  sqlite3MallocAlarm(nFull);  p = sqlite3GlobalConfig.m.xMalloc(nFull);  }
#endif
 if( p ){  nFull = sqlite3MallocSize(p);  sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nFull);  sqlite3StatusUp(SQLITE_STATUS_MALLOC_COUNT, 1);  }  *pp = p; } SQLITE_PRIVATE void *sqlite3Malloc(u64 n){  void *p;  if( n==0 || n>=0x7fffff00 ){  p = 0;  }else if( sqlite3GlobalConfig.bMemstat ){  sqlite3_mutex_enter(mem0.mutex);  mallocWithAlarm((int)n, &p);  sqlite3_mutex_leave(mem0.mutex);  }else{  p = sqlite3GlobalConfig.m.xMalloc((int)n);  }  assert( EIGHT_BYTE_ALIGNMENT(p) );  return p; } SQLITE_API void *sqlite3_malloc(int n){
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return n<=0 ? 0 : sqlite3Malloc(n); } SQLITE_API void *sqlite3_malloc64(sqlite3_uint64 n){
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return sqlite3Malloc(n); }
#ifndef SQLITE_OMIT_LOOKASIDE
static int isLookaside(sqlite3 *db, const void *p){  return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pEnd); }
#else
#define isLookaside(A,B) 0
#endif
SQLITE_PRIVATE int sqlite3MallocSize(const void *p){  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );  return sqlite3GlobalConfig.m.xSize((void*)p); } static int lookasideMallocSize(sqlite3 *db, const void *p){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 return p<db->lookaside.pMiddle ? db->lookaside.szTrue : LOOKASIDE_SMALL;
#else
 return db->lookaside.szTrue;
#endif
} SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, const void *p){  assert( p!=0 );
#ifdef SQLITE_DEBUG
 if( db==0 || !isLookaside(db,p) ){  if( db==0 ){  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );  }else{  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );  }  }
#endif
 if( db ){  if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){  assert( sqlite3_mutex_held(db->mutex) );  return LOOKASIDE_SMALL;  }
#endif
 if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){  assert( sqlite3_mutex_held(db->mutex) );  return db->lookaside.szTrue;  }  }  }  return sqlite3GlobalConfig.m.xSize((void*)p); } SQLITE_API sqlite3_uint64 sqlite3_msize(void *p){  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );  return p ? sqlite3GlobalConfig.m.xSize(p) : 0; } SQLITE_API void sqlite3_free(void *p){  if( p==0 ) return;  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );  assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );  if( sqlite3GlobalConfig.bMemstat ){  sqlite3_mutex_enter(mem0.mutex);  sqlite3StatusDown(SQLITE_STATUS_MEMORY_USED, sqlite3MallocSize(p));  sqlite3StatusDown(SQLITE_STATUS_MALLOC_COUNT, 1);  sqlite3GlobalConfig.m.xFree(p);  sqlite3_mutex_leave(mem0.mutex);  }else{  sqlite3GlobalConfig.m.xFree(p);  } } static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){  *db->pnBytesFreed += sqlite3DbMallocSize(db,p); } SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3 *db, void *p){  assert( db==0 || sqlite3_mutex_held(db->mutex) );  assert( p!=0 );  if( db ){  if( db->pnBytesFreed ){  measureAllocationSize(db, p);  return;  }  if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){  LookasideSlot *pBuf = (LookasideSlot*)p;
#ifdef SQLITE_DEBUG
 memset(p, 0xaa, LOOKASIDE_SMALL);
#endif
 pBuf->pNext = db->lookaside.pSmallFree;  db->lookaside.pSmallFree = pBuf;  return;  }
#endif
 if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){  LookasideSlot *pBuf = (LookasideSlot*)p;
#ifdef SQLITE_DEBUG
 memset(p, 0xaa, db->lookaside.szTrue);
#endif
 pBuf->pNext = db->lookaside.pFree;  db->lookaside.pFree = pBuf;  return;  }  }  }  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);  sqlite3_free(p); } SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){  assert( db==0 || sqlite3_mutex_held(db->mutex) );  if( p ) sqlite3DbFreeNN(db, p); } SQLITE_PRIVATE void *sqlite3Realloc(void *pOld, u64 nBytes){  int nOld, nNew, nDiff;  void *pNew;  assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );  assert( sqlite3MemdebugNoType(pOld, (u8)~MEMTYPE_HEAP) );  if( pOld==0 ){  return sqlite3Malloc(nBytes);  }  if( nBytes==0 ){  sqlite3_free(pOld);  return 0;  }  if( nBytes>=0x7fffff00 ){  return 0;  }  nOld = sqlite3MallocSize(pOld);  nNew = sqlite3GlobalConfig.m.xRoundup((int)nBytes);  if( nOld==nNew ){  pNew = pOld;  }else if( sqlite3GlobalConfig.bMemstat ){  sqlite3_int64 nUsed;  sqlite3_mutex_enter(mem0.mutex);  sqlite3StatusHighwater(SQLITE_STATUS_MALLOC_SIZE, (int)nBytes);  nDiff = nNew - nOld;  if( nDiff>0 && (nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)) >=  mem0.alarmThreshold-nDiff ){  sqlite3MallocAlarm(nDiff);  if( mem0.hardLimit>0 && nUsed >= mem0.hardLimit - nDiff ){  sqlite3_mutex_leave(mem0.mutex);  return 0;  }  }  pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 if( pNew==0 && mem0.alarmThreshold>0 ){  sqlite3MallocAlarm((int)nBytes);  pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);  }
#endif
 if( pNew ){  nNew = sqlite3MallocSize(pNew);  sqlite3StatusUp(SQLITE_STATUS_MEMORY_USED, nNew-nOld);  }  sqlite3_mutex_leave(mem0.mutex);  }else{  pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);  }  assert( EIGHT_BYTE_ALIGNMENT(pNew) );  return pNew; } SQLITE_API void *sqlite3_realloc(void *pOld, int n){
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 if( n<0 ) n = 0;  return sqlite3Realloc(pOld, n); } SQLITE_API void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return sqlite3Realloc(pOld, n); } SQLITE_PRIVATE void *sqlite3MallocZero(u64 n){  void *p = sqlite3Malloc(n);  if( p ){  memset(p, 0, (size_t)n);  }  return p; } SQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, u64 n){  void *p;  testcase( db==0 );  p = sqlite3DbMallocRaw(db, n);  if( p ) memset(p, 0, (size_t)n);  return p; } static SQLITE_NOINLINE void *dbMallocRawFinish(sqlite3 *db, u64 n){  void *p;  assert( db!=0 );  p = sqlite3Malloc(n);  if( !p ) sqlite3OomFault(db);  sqlite3MemdebugSetType(p,   (db->lookaside.bDisable==0) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP);  return p; } SQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){  void *p;  if( db ) return sqlite3DbMallocRawNN(db, n);  p = sqlite3Malloc(n);  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);  return p; } SQLITE_PRIVATE void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){
#ifndef SQLITE_OMIT_LOOKASIDE
 LookasideSlot *pBuf;  assert( db!=0 );  assert( sqlite3_mutex_held(db->mutex) );  assert( db->pnBytesFreed==0 );  if( n>db->lookaside.sz ){  if( !db->lookaside.bDisable ){  db->lookaside.anStat[1]++;  }else if( db->mallocFailed ){  return 0;  }  return dbMallocRawFinish(db, n);  }
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 if( n<=LOOKASIDE_SMALL ){  if( (pBuf = db->lookaside.pSmallFree)!=0 ){  db->lookaside.pSmallFree = pBuf->pNext;  db->lookaside.anStat[0]++;  return (void*)pBuf;  }else if( (pBuf = db->lookaside.pSmallInit)!=0 ){  db->lookaside.pSmallInit = pBuf->pNext;  db->lookaside.anStat[0]++;  return (void*)pBuf;  }  }
#endif
 if( (pBuf = db->lookaside.pFree)!=0 ){  db->lookaside.pFree = pBuf->pNext;  db->lookaside.anStat[0]++;  return (void*)pBuf;  }else if( (pBuf = db->lookaside.pInit)!=0 ){  db->lookaside.pInit = pBuf->pNext;  db->lookaside.anStat[0]++;  return (void*)pBuf;  }else{  db->lookaside.anStat[2]++;  }
#else
 assert( db!=0 );  assert( sqlite3_mutex_held(db->mutex) );  assert( db->pnBytesFreed==0 );  if( db->mallocFailed ){  return 0;  }
#endif
 return dbMallocRawFinish(db, n); } static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n); SQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){  assert( db!=0 );  if( p==0 ) return sqlite3DbMallocRawNN(db, n);  assert( sqlite3_mutex_held(db->mutex) );  if( ((uptr)p)<(uptr)db->lookaside.pEnd ){
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 if( ((uptr)p)>=(uptr)db->lookaside.pMiddle ){  if( n<=LOOKASIDE_SMALL ) return p;  }else
#endif
 if( ((uptr)p)>=(uptr)db->lookaside.pStart ){  if( n<=db->lookaside.szTrue ) return p;  }  }  return dbReallocFinish(db, p, n); } static SQLITE_NOINLINE void *dbReallocFinish(sqlite3 *db, void *p, u64 n){  void *pNew = 0;  assert( db!=0 );  assert( p!=0 );  if( db->mallocFailed==0 ){  if( isLookaside(db, p) ){  pNew = sqlite3DbMallocRawNN(db, n);  if( pNew ){  memcpy(pNew, p, lookasideMallocSize(db, p));  sqlite3DbFree(db, p);  }  }else{  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);  pNew = sqlite3Realloc(p, n);  if( !pNew ){  sqlite3OomFault(db);  }  sqlite3MemdebugSetType(pNew,  (db->lookaside.bDisable==0 ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));  }  }  return pNew; } SQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){  void *pNew;  pNew = sqlite3DbRealloc(db, p, n);  if( !pNew ){  sqlite3DbFree(db, p);  }  return pNew; } SQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){  char *zNew;  size_t n;  if( z==0 ){  return 0;  }  n = strlen(z) + 1;  zNew = sqlite3DbMallocRaw(db, n);  if( zNew ){  memcpy(zNew, z, n);  }  return zNew; } SQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){  char *zNew;  assert( db!=0 );  assert( z!=0 || n==0 );  assert( (n&0x7fffffff)==n );  zNew = z ? sqlite3DbMallocRawNN(db, n+1) : 0;  if( zNew ){  memcpy(zNew, z, (size_t)n);  zNew[n] = 0;  }  return zNew; } SQLITE_PRIVATE char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){  int n;  while( sqlite3Isspace(zStart[0]) ) zStart++;  n = (int)(zEnd - zStart);  while( ALWAYS(n>0) && sqlite3Isspace(zStart[n-1]) ) n--;  return sqlite3DbStrNDup(db, zStart, n); } SQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){  sqlite3DbFree(db, *pz);  *pz = sqlite3DbStrDup(db, zNew); } SQLITE_PRIVATE void sqlite3OomFault(sqlite3 *db){  if( db->mallocFailed==0 && db->bBenignMalloc==0 ){  db->mallocFailed = 1;  if( db->nVdbeExec>0 ){  AtomicStore(&db->u1.isInterrupted, 1);  }  DisableLookaside;  if( db->pParse ){  db->pParse->rc = SQLITE_NOMEM_BKPT;  }  } } SQLITE_PRIVATE void sqlite3OomClear(sqlite3 *db){  if( db->mallocFailed && db->nVdbeExec==0 ){  db->mallocFailed = 0;  AtomicStore(&db->u1.isInterrupted, 0);  assert( db->lookaside.bDisable>0 );  EnableLookaside;  } } static SQLITE_NOINLINE int apiHandleError(sqlite3 *db, int rc){  if( db->mallocFailed || rc==SQLITE_IOERR_NOMEM ){  sqlite3OomClear(db);  sqlite3Error(db, SQLITE_NOMEM);  return SQLITE_NOMEM_BKPT;  }  return rc & db->errMask; } SQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){  assert( db!=0 );  assert( sqlite3_mutex_held(db->mutex) );  if( db->mallocFailed || rc ){  return apiHandleError(db, rc);  }  return rc & db->errMask; }
#define etRADIX  0
#define etFLOAT  1
#define etEXP  2
#define etGENERIC  3
#define etSIZE 4
#define etSTRING 5
#define etDYNSTRING  6
#define etPERCENT  7
#define etCHARX  8
#define etSQLESCAPE  9
#define etSQLESCAPE2 10 /* Strings with '\'' doubled and enclosed in '',
 NULL pointers replaced by SQL NULL. %Q */
#define etTOKEN 11
#define etSRCITEM 12
#define etPOINTER 13
#define etSQLESCAPE3 14
#define etORDINAL 15
#define etDECIMAL 16
#define etINVALID 17
typedef unsigned char etByte; typedef struct et_info {  char fmttype;  etByte base;  etByte flags;  etByte type;  etByte charset;  etByte prefix; } et_info;
#define FLAG_SIGNED 1
#define FLAG_STRING 4
static const char aDigits[] = "0123456789ABCDEF0123456789abcdef"; static const char aPrefix[] = "-x0\000X0"; static const et_info fmtinfo[] = {  { 'd', 10, 1, etDECIMAL, 0, 0 },  { 's', 0, 4, etSTRING, 0, 0 },  { 'g', 0, 1, etGENERIC, 30, 0 },  { 'z', 0, 4, etDYNSTRING, 0, 0 },  { 'q', 0, 4, etSQLESCAPE, 0, 0 },  { 'Q', 0, 4, etSQLESCAPE2, 0, 0 },  { 'w', 0, 4, etSQLESCAPE3, 0, 0 },  { 'c', 0, 0, etCHARX, 0, 0 },  { 'o', 8, 0, etRADIX, 0, 2 },  { 'u', 10, 0, etDECIMAL, 0, 0 },  { 'x', 16, 0, etRADIX, 16, 1 },  { 'X', 16, 0, etRADIX, 0, 4 },
#ifndef SQLITE_OMIT_FLOATING_POINT
 { 'f', 0, 1, etFLOAT, 0, 0 },  { 'e', 0, 1, etEXP, 30, 0 },  { 'E', 0, 1, etEXP, 14, 0 },  { 'G', 0, 1, etGENERIC, 14, 0 },
#endif
 { 'i', 10, 1, etDECIMAL, 0, 0 },  { 'n', 0, 0, etSIZE, 0, 0 },  { '%', 0, 0, etPERCENT, 0, 0 },  { 'p', 16, 0, etPOINTER, 0, 1 },  { 'T', 0, 0, etTOKEN, 0, 0 },  { 'S', 0, 0, etSRCITEM, 0, 0 },  { 'r', 10, 1, etORDINAL, 0, 0 }, }; static const double arRound[] = {  5.0e-01, 5.0e-02, 5.0e-03, 5.0e-04, 5.0e-05,  5.0e-06, 5.0e-07, 5.0e-08, 5.0e-09, 5.0e-10, };
#ifndef SQLITE_OMIT_FLOATING_POINT
static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){  int digit;  LONGDOUBLE_TYPE d;  if( (*cnt)<=0 ) return '0';  (*cnt)--;  digit = (int)*val;  d = digit;  digit += '0';  *val = (*val - d)*10.0;  return (char)digit; }
#endif
SQLITE_PRIVATE void sqlite3StrAccumSetError(StrAccum *p, u8 eError){  assert( eError==SQLITE_NOMEM || eError==SQLITE_TOOBIG );  p->accError = eError;  if( p->mxAlloc ) sqlite3_str_reset(p);  if( eError==SQLITE_TOOBIG ) sqlite3ErrorToParser(p->db, eError); } static sqlite3_int64 getIntArg(PrintfArguments *p){  if( p->nArg<=p->nUsed ) return 0;  return sqlite3_value_int64(p->apArg[p->nUsed++]); } static double getDoubleArg(PrintfArguments *p){  if( p->nArg<=p->nUsed ) return 0.0;  return sqlite3_value_double(p->apArg[p->nUsed++]); } static char *getTextArg(PrintfArguments *p){  if( p->nArg<=p->nUsed ) return 0;  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]); } static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){  char *z;  if( pAccum->accError ) return 0;  if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){  sqlite3StrAccumSetError(pAccum, SQLITE_TOOBIG);  return 0;  }  z = sqlite3DbMallocRaw(pAccum->db, n);  if( z==0 ){  sqlite3StrAccumSetError(pAccum, SQLITE_NOMEM);  }  return z; }
#ifndef SQLITE_PRINT_BUF_SIZE
# define SQLITE_PRINT_BUF_SIZE 70
#endif
#define etBUFSIZE SQLITE_PRINT_BUF_SIZE
#ifndef SQLITE_PRINTF_PRECISION_LIMIT
# define SQLITE_FP_PRECISION_LIMIT 100000000
#endif
SQLITE_API void sqlite3_str_vappendf(  sqlite3_str *pAccum,  const char *fmt,  va_list ap ){  int c;  char *bufpt;  int precision;  int length;  int idx;  int width;  etByte flag_leftjustify;  etByte flag_prefix;  etByte flag_alternateform;  etByte flag_altform2;  etByte flag_zeropad;  etByte flag_long;  etByte done;  etByte cThousand;  etByte xtype = etINVALID;  u8 bArgList;  char prefix;  sqlite_uint64 longvalue;  LONGDOUBLE_TYPE realvalue;  const et_info *infop;  char *zOut;  int nOut;  char *zExtra = 0;
#ifndef SQLITE_OMIT_FLOATING_POINT
 int exp, e2;  int nsd;  double rounder;  etByte flag_dp;  etByte flag_rtz;
#endif
 PrintfArguments *pArgList = 0;  char buf[etBUFSIZE];  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );  bufpt = 0;  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){  pArgList = va_arg(ap, PrintfArguments*);  bArgList = 1;  }else{  bArgList = 0;  }  for(; (c=(*fmt))!=0; ++fmt){  if( c!='%' ){  bufpt = (char *)fmt;
#if HAVE_STRCHRNUL
 fmt = strchrnul(fmt, '%');
#else
 do{ fmt++; }while( *fmt && *fmt != '%' );
#endif
 sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));  if( *fmt==0 ) break;  }  if( (c=(*++fmt))==0 ){  sqlite3_str_append(pAccum, "%", 1);  break;  }  flag_leftjustify = flag_prefix = cThousand =   flag_alternateform = flag_altform2 = flag_zeropad = 0;  done = 0;  width = 0;  flag_long = 0;  precision = -1;  do{  switch( c ){  case '-':  flag_leftjustify = 1;  break;  case '+':  flag_prefix = '+'; break;  case ' ':  flag_prefix = ' '; break;  case '#':  flag_alternateform = 1;  break;  case '!':  flag_altform2 = 1; break;  case '0':  flag_zeropad = 1;  break;  case ',':  cThousand = ','; break;  default: done = 1;  break;  case 'l': {  flag_long = 1;  c = *++fmt;  if( c=='l' ){  c = *++fmt;  flag_long = 2;  }  done = 1;  break;  }  case '1': case '2': case '3': case '4': case '5':  case '6': case '7': case '8': case '9': {  unsigned wx = c - '0';  while( (c = *++fmt)>='0' && c<='9' ){  wx = wx*10 + c - '0';  }  testcase( wx>0x7fffffff );  width = wx & 0x7fffffff;
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
 if( width>SQLITE_PRINTF_PRECISION_LIMIT ){  width = SQLITE_PRINTF_PRECISION_LIMIT;  }
#endif
 if( c!='.' && c!='l' ){  done = 1;  }else{  fmt--;  }  break;  }  case '*': {  if( bArgList ){  width = (int)getIntArg(pArgList);  }else{  width = va_arg(ap,int);  }  if( width<0 ){  flag_leftjustify = 1;  width = width >= -2147483647 ? -width : 0;  }
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
 if( width>SQLITE_PRINTF_PRECISION_LIMIT ){  width = SQLITE_PRINTF_PRECISION_LIMIT;  }
#endif
 if( (c = fmt[1])!='.' && c!='l' ){  c = *++fmt;  done = 1;  }  break;  }  case '.': {  c = *++fmt;  if( c=='*' ){  if( bArgList ){  precision = (int)getIntArg(pArgList);  }else{  precision = va_arg(ap,int);  }  if( precision<0 ){  precision = precision >= -2147483647 ? -precision : -1;  }  c = *++fmt;  }else{  unsigned px = 0;  while( c>='0' && c<='9' ){  px = px*10 + c - '0';  c = *++fmt;  }  testcase( px>0x7fffffff );  precision = px & 0x7fffffff;  }
#ifdef SQLITE_PRINTF_PRECISION_LIMIT
 if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){  precision = SQLITE_PRINTF_PRECISION_LIMIT;  }
#endif
 if( c=='l' ){  --fmt;  }else{  done = 1;  }  break;  }  }  }while( !done && (c=(*++fmt))!=0 );  infop = &fmtinfo[0];  xtype = etINVALID;  for(idx=0; idx<ArraySize(fmtinfo); idx++){  if( c==fmtinfo[idx].fmttype ){  infop = &fmtinfo[idx];  xtype = infop->type;  break;  }  }  assert( width>=0 );  assert( precision>=(-1) );  switch( xtype ){  case etPOINTER:  flag_long = sizeof(char*)==sizeof(i64) ? 2 :   sizeof(char*)==sizeof(long int) ? 1 : 0;   deliberate_fall_through  case etORDINAL:  case etRADIX:  cThousand = 0;   deliberate_fall_through  case etDECIMAL:  if( infop->flags & FLAG_SIGNED ){  i64 v;  if( bArgList ){  v = getIntArg(pArgList);  }else if( flag_long ){  if( flag_long==2 ){  v = va_arg(ap,i64) ;  }else{  v = va_arg(ap,long int);  }  }else{  v = va_arg(ap,int);  }  if( v<0 ){  testcase( v==SMALLEST_INT64 );  testcase( v==(-1) );  longvalue = ~v;  longvalue++;  prefix = '-';  }else{  longvalue = v;  prefix = flag_prefix;  }  }else{  if( bArgList ){  longvalue = (u64)getIntArg(pArgList);  }else if( flag_long ){  if( flag_long==2 ){  longvalue = va_arg(ap,u64);  }else{  longvalue = va_arg(ap,unsigned long int);  }  }else{  longvalue = va_arg(ap,unsigned int);  }  prefix = 0;  }  if( longvalue==0 ) flag_alternateform = 0;  if( flag_zeropad && precision<width-(prefix!=0) ){  precision = width-(prefix!=0);  }  if( precision<etBUFSIZE-10-etBUFSIZE/3 ){  nOut = etBUFSIZE;  zOut = buf;  }else{  u64 n;  n = (u64)precision + 10;  if( cThousand ) n += precision/3;  zOut = zExtra = printfTempBuf(pAccum, n);  if( zOut==0 ) return;  nOut = (int)n;  }  bufpt = &zOut[nOut-1];  if( xtype==etORDINAL ){  static const char zOrd[] = "thstndrd";  int x = (int)(longvalue % 10);  if( x>=4 || (longvalue/10)%10==1 ){  x = 0;  }  *(--bufpt) = zOrd[x*2+1];  *(--bufpt) = zOrd[x*2];  }  {  const char *cset = &aDigits[infop->charset];  u8 base = infop->base;  do{  *(--bufpt) = cset[longvalue%base];  longvalue = longvalue/base;  }while( longvalue>0 );  }  length = (int)(&zOut[nOut-1]-bufpt);  while( precision>length ){  *(--bufpt) = '0';  length++;  }  if( cThousand ){  int nn = (length - 1)/3;  int ix = (length - 1)%3 + 1;  bufpt -= nn;  for(idx=0; nn>0; idx++){  bufpt[idx] = bufpt[idx+nn];  ix--;  if( ix==0 ){  bufpt[++idx] = cThousand;  nn--;  ix = 3;  }  }  }  if( prefix ) *(--bufpt) = prefix;  if( flag_alternateform && infop->prefix ){  const char *pre;  char x;  pre = &aPrefix[infop->prefix];  for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;  }  length = (int)(&zOut[nOut-1]-bufpt);  break;  case etFLOAT:  case etEXP:  case etGENERIC:  if( bArgList ){  realvalue = getDoubleArg(pArgList);  }else{  realvalue = va_arg(ap,double);  }
#ifdef SQLITE_OMIT_FLOATING_POINT
 length = 0;
#else
 if( precision<0 ) precision = 6;
#ifdef SQLITE_FP_PRECISION_LIMIT
 if( precision>SQLITE_FP_PRECISION_LIMIT ){  precision = SQLITE_FP_PRECISION_LIMIT;  }
#endif
 if( realvalue<0.0 ){  realvalue = -realvalue;  prefix = '-';  }else{  prefix = flag_prefix;  }  if( xtype==etGENERIC && precision>0 ) precision--;  testcase( precision>0xfff );  idx = precision & 0xfff;  rounder = arRound[idx%10];  while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; }  if( xtype==etFLOAT ){  double rx = (double)realvalue;  sqlite3_uint64 u;  int ex;  memcpy(&u, &rx, sizeof(u));  ex = -1023 + (int)((u>>52)&0x7ff);  if( precision+(ex/3) < 15 ) rounder += realvalue*3e-16;  realvalue += rounder;  }  exp = 0;  if( sqlite3IsNaN((double)realvalue) ){  bufpt = "NaN";  length = 3;  break;  }  if( realvalue>0.0 ){  LONGDOUBLE_TYPE scale = 1.0;  while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}  while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }  while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }  realvalue /= scale;  while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }  while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }  if( exp>350 ){  bufpt = buf;  buf[0] = prefix;  memcpy(buf+(prefix!=0),"Inf",4);  length = 3+(prefix!=0);  break;  }  }  bufpt = buf;  if( xtype!=etFLOAT ){  realvalue += rounder;  if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }  }  if( xtype==etGENERIC ){  flag_rtz = !flag_alternateform;  if( exp<-4 || exp>precision ){  xtype = etEXP;  }else{  precision = precision - exp;  xtype = etFLOAT;  }  }else{  flag_rtz = flag_altform2;  }  if( xtype==etEXP ){  e2 = 0;  }else{  e2 = exp;  }  {  i64 szBufNeeded;  szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;  if( szBufNeeded > etBUFSIZE ){  bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);  if( bufpt==0 ) return;  }  }  zOut = bufpt;  nsd = 16 + flag_altform2*10;  flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;  if( prefix ){  *(bufpt++) = prefix;  }  if( e2<0 ){  *(bufpt++) = '0';  }else{  for(; e2>=0; e2--){  *(bufpt++) = et_getdigit(&realvalue,&nsd);  }  }  if( flag_dp ){  *(bufpt++) = '.';  }  for(e2++; e2<0; precision--, e2++){  assert( precision>0 );  *(bufpt++) = '0';  }  while( (precision--)>0 ){  *(bufpt++) = et_getdigit(&realvalue,&nsd);  }  if( flag_rtz && flag_dp ){  while( bufpt[-1]=='0' ) *(--bufpt) = 0;  assert( bufpt>zOut );  if( bufpt[-1]=='.' ){  if( flag_altform2 ){  *(bufpt++) = '0';  }else{  *(--bufpt) = 0;  }  }  }  if( xtype==etEXP ){  *(bufpt++) = aDigits[infop->charset];  if( exp<0 ){  *(bufpt++) = '-'; exp = -exp;  }else{  *(bufpt++) = '+';  }  if( exp>=100 ){  *(bufpt++) = (char)((exp/100)+'0');  exp %= 100;  }  *(bufpt++) = (char)(exp/10+'0');  }  *bufpt = 0;  length = (int)(bufpt-zOut);  bufpt = zOut;  if( flag_zeropad && !flag_leftjustify && length < width){  int i;  int nPad = width - length;  for(i=width; i>=nPad; i--){  bufpt[i] = bufpt[i-nPad];  }  i = prefix!=0;  while( nPad-- ) bufpt[i++] = '0';  length = width;  }
#endif
 break;  case etSIZE:  if( !bArgList ){  *(va_arg(ap,int*)) = pAccum->nChar;  }  length = width = 0;  break;  case etPERCENT:  buf[0] = '%';  bufpt = buf;  length = 1;  break;  case etCHARX:  if( bArgList ){  bufpt = getTextArg(pArgList);  length = 1;  if( bufpt ){  buf[0] = c = *(bufpt++);  if( (c&0xc0)==0xc0 ){  while( length<4 && (bufpt[0]&0xc0)==0x80 ){  buf[length++] = *(bufpt++);  }  }  }else{  buf[0] = 0;  }  }else{  unsigned int ch = va_arg(ap,unsigned int);  if( ch<0x00080 ){  buf[0] = ch & 0xff;  length = 1;  }else if( ch<0x00800 ){  buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);  buf[1] = 0x80 + (u8)(ch & 0x3f);  length = 2;  }else if( ch<0x10000 ){  buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);  buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);  buf[2] = 0x80 + (u8)(ch & 0x3f);  length = 3;  }else{  buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);  buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);  buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);  buf[3] = 0x80 + (u8)(ch & 0x3f);  length = 4;  }  }  if( precision>1 ){  width -= precision-1;  if( width>1 && !flag_leftjustify ){  sqlite3_str_appendchar(pAccum, width-1, ' ');  width = 0;  }  while( precision-- > 1 ){  sqlite3_str_append(pAccum, buf, length);  }  }  bufpt = buf;  flag_altform2 = 1;  goto adjust_width_for_utf8;  case etSTRING:  case etDYNSTRING:  if( bArgList ){  bufpt = getTextArg(pArgList);  xtype = etSTRING;  }else{  bufpt = va_arg(ap,char*);  }  if( bufpt==0 ){  bufpt = "";  }else if( xtype==etDYNSTRING ){  if( pAccum->nChar==0   && pAccum->mxAlloc   && width==0   && precision<0   && pAccum->accError==0  ){  assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );  pAccum->zText = bufpt;  pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);  pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);  pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;  length = 0;  break;  }  zExtra = bufpt;  }  if( precision>=0 ){  if( flag_altform2 ){  unsigned char *z = (unsigned char*)bufpt;  while( precision-- > 0 && z[0] ){  SQLITE_SKIP_UTF8(z);  }  length = (int)(z - (unsigned char*)bufpt);  }else{  for(length=0; length<precision && bufpt[length]; length++){}  }  }else{  length = 0x7fffffff & (int)strlen(bufpt);  }  adjust_width_for_utf8:  if( flag_altform2 && width>0 ){  int ii = length - 1;  while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;  }  break;  case etSQLESCAPE:  case etSQLESCAPE2:  case etSQLESCAPE3: {  int i, j, k, n, isnull;  int needQuote;  char ch;  char q = ((xtype==etSQLESCAPE3)?'"':'\'');  char *escarg;  if( bArgList ){  escarg = getTextArg(pArgList);  }else{  escarg = va_arg(ap,char*);  }  isnull = escarg==0;  if( isnull ) escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");  k = precision;  for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){  if( ch==q ) n++;  if( flag_altform2 && (ch&0xc0)==0xc0 ){  while( (escarg[i+1]&0xc0)==0x80 ){ i++; }  }  }  needQuote = !isnull && xtype==etSQLESCAPE2;  n += i + 3;  if( n>etBUFSIZE ){  bufpt = zExtra = printfTempBuf(pAccum, n);  if( bufpt==0 ) return;  }else{  bufpt = buf;  }  j = 0;  if( needQuote ) bufpt[j++] = q;  k = i;  for(i=0; i<k; i++){  bufpt[j++] = ch = escarg[i];  if( ch==q ) bufpt[j++] = ch;  }  if( needQuote ) bufpt[j++] = q;  bufpt[j] = 0;  length = j;  goto adjust_width_for_utf8;  }  case etTOKEN: {  Token *pToken;  if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;  pToken = va_arg(ap, Token*);  assert( bArgList==0 );  if( pToken && pToken->n ){  sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);  }  length = width = 0;  break;  }  case etSRCITEM: {  SrcItem *pItem;  if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;  pItem = va_arg(ap, SrcItem*);  assert( bArgList==0 );  if( pItem->zAlias && !flag_altform2 ){  sqlite3_str_appendall(pAccum, pItem->zAlias);  }else if( pItem->zName ){  if( pItem->zDatabase ){  sqlite3_str_appendall(pAccum, pItem->zDatabase);  sqlite3_str_append(pAccum, ".", 1);  }  sqlite3_str_appendall(pAccum, pItem->zName);  }else if( pItem->zAlias ){  sqlite3_str_appendall(pAccum, pItem->zAlias);  }else if( ALWAYS(pItem->pSelect) ){  sqlite3_str_appendf(pAccum, "SUBQUERY %u", pItem->pSelect->selId);  }  length = width = 0;  break;  }  default: {  assert( xtype==etINVALID );  return;  }  }  width -= length;  if( width>0 ){  if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');  sqlite3_str_append(pAccum, bufpt, length);  if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');  }else{  sqlite3_str_append(pAccum, bufpt, length);  }  if( zExtra ){  sqlite3DbFree(pAccum->db, zExtra);  zExtra = 0;  }  } } static int sqlite3StrAccumEnlarge(StrAccum *p, int N){  char *zNew;  assert( p->nChar+(i64)N >= p->nAlloc );  if( p->accError ){  testcase(p->accError==SQLITE_TOOBIG);  testcase(p->accError==SQLITE_NOMEM);  return 0;  }  if( p->mxAlloc==0 ){  sqlite3StrAccumSetError(p, SQLITE_TOOBIG);  return p->nAlloc - p->nChar - 1;  }else{  char *zOld = isMalloced(p) ? p->zText : 0;  i64 szNew = p->nChar;  szNew += (sqlite3_int64)N + 1;  if( szNew+p->nChar<=p->mxAlloc ){  szNew += p->nChar;  }  if( szNew > p->mxAlloc ){  sqlite3_str_reset(p);  sqlite3StrAccumSetError(p, SQLITE_TOOBIG);  return 0;  }else{  p->nAlloc = (int)szNew;  }  if( p->db ){  zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);  }else{  zNew = sqlite3Realloc(zOld, p->nAlloc);  }  if( zNew ){  assert( p->zText!=0 || p->nChar==0 );  if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);  p->zText = zNew;  p->nAlloc = sqlite3DbMallocSize(p->db, zNew);  p->printfFlags |= SQLITE_PRINTF_MALLOCED;  }else{  sqlite3_str_reset(p);  sqlite3StrAccumSetError(p, SQLITE_NOMEM);  return 0;  }  }  return N; } SQLITE_API void sqlite3_str_appendchar(sqlite3_str *p, int N, char c){  testcase( p->nChar + (i64)N > 0x7fffffff );  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){  return;  }  while( (N--)>0 ) p->zText[p->nChar++] = c; } static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){  N = sqlite3StrAccumEnlarge(p, N);  if( N>0 ){  memcpy(&p->zText[p->nChar], z, N);  p->nChar += N;  } } SQLITE_API void sqlite3_str_append(sqlite3_str *p, const char *z, int N){  assert( z!=0 || N==0 );  assert( p->zText!=0 || p->nChar==0 || p->accError );  assert( N>=0 );  assert( p->accError==0 || p->nAlloc==0 || p->mxAlloc==0 );  if( p->nChar+N >= p->nAlloc ){  enlargeAndAppend(p,z,N);  }else if( N ){  assert( p->zText );  p->nChar += N;  memcpy(&p->zText[p->nChar-N], z, N);  } } SQLITE_API void sqlite3_str_appendall(sqlite3_str *p, const char *z){  sqlite3_str_append(p, z, sqlite3Strlen30(z)); } static SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){  char *zText;  assert( p->mxAlloc>0 && !isMalloced(p) );  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );  if( zText ){  memcpy(zText, p->zText, p->nChar+1);  p->printfFlags |= SQLITE_PRINTF_MALLOCED;  }else{  sqlite3StrAccumSetError(p, SQLITE_NOMEM);  }  p->zText = zText;  return zText; } SQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){  if( p->zText ){  p->zText[p->nChar] = 0;  if( p->mxAlloc>0 && !isMalloced(p) ){  return strAccumFinishRealloc(p);  }  }  return p->zText; } SQLITE_PRIVATE void sqlite3ResultStrAccum(sqlite3_context *pCtx, StrAccum *p){  if( p->accError ){  sqlite3_result_error_code(pCtx, p->accError);  sqlite3_str_reset(p);  }else if( isMalloced(p) ){  sqlite3_result_text(pCtx, p->zText, p->nChar, SQLITE_DYNAMIC);  }else{  sqlite3_result_text(pCtx, "", 0, SQLITE_STATIC);  sqlite3_str_reset(p);  } } static sqlite3_str sqlite3OomStr = {   0, 0, 0, 0, 0, SQLITE_NOMEM, 0 }; SQLITE_API char *sqlite3_str_finish(sqlite3_str *p){  char *z;  if( p!=0 && p!=&sqlite3OomStr ){  z = sqlite3StrAccumFinish(p);  sqlite3_free(p);  }else{  z = 0;  }  return z; } SQLITE_API int sqlite3_str_errcode(sqlite3_str *p){  return p ? p->accError : SQLITE_NOMEM; } SQLITE_API int sqlite3_str_length(sqlite3_str *p){  return p ? p->nChar : 0; } SQLITE_API char *sqlite3_str_value(sqlite3_str *p){  if( p==0 || p->nChar==0 ) return 0;  p->zText[p->nChar] = 0;  return p->zText; } SQLITE_API void sqlite3_str_reset(StrAccum *p){  if( isMalloced(p) ){  sqlite3DbFree(p->db, p->zText);  p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;  }  p->nAlloc = 0;  p->nChar = 0;  p->zText = 0; } SQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){  p->zText = zBase;  p->db = db;  p->nAlloc = n;  p->mxAlloc = mx;  p->nChar = 0;  p->accError = 0;  p->printfFlags = 0; } SQLITE_API sqlite3_str *sqlite3_str_new(sqlite3 *db){  sqlite3_str *p = sqlite3_malloc64(sizeof(*p));  if( p ){  sqlite3StrAccumInit(p, 0, 0, 0,  db ? db->aLimit[SQLITE_LIMIT_LENGTH] : SQLITE_MAX_LENGTH);  }else{  p = &sqlite3OomStr;  }  return p; } SQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){  char *z;  char zBase[SQLITE_PRINT_BUF_SIZE];  StrAccum acc;  assert( db!=0 );  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),  db->aLimit[SQLITE_LIMIT_LENGTH]);  acc.printfFlags = SQLITE_PRINTF_INTERNAL;  sqlite3_str_vappendf(&acc, zFormat, ap);  z = sqlite3StrAccumFinish(&acc);  if( acc.accError==SQLITE_NOMEM ){  sqlite3OomFault(db);  }  return z; } SQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){  va_list ap;  char *z;  va_start(ap, zFormat);  z = sqlite3VMPrintf(db, zFormat, ap);  va_end(ap);  return z; } SQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){  char *z;  char zBase[SQLITE_PRINT_BUF_SIZE];  StrAccum acc;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( zFormat==0 ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);  sqlite3_str_vappendf(&acc, zFormat, ap);  z = sqlite3StrAccumFinish(&acc);  return z; } SQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){  va_list ap;  char *z;
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 va_start(ap, zFormat);  z = sqlite3_vmprintf(zFormat, ap);  va_end(ap);  return z; } SQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){  StrAccum acc;  if( n<=0 ) return zBuf;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( zBuf==0 || zFormat==0 ) {  (void)SQLITE_MISUSE_BKPT;  if( zBuf ) zBuf[0] = 0;  return zBuf;  }
#endif
 sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);  sqlite3_str_vappendf(&acc, zFormat, ap);  zBuf[acc.nChar] = 0;  return zBuf; } SQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){  char *z;  va_list ap;  va_start(ap,zFormat);  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);  va_end(ap);  return z; } static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){  StrAccum acc;  char zMsg[SQLITE_PRINT_BUF_SIZE*3];  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);  sqlite3_str_vappendf(&acc, zFormat, ap);  sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,   sqlite3StrAccumFinish(&acc)); } SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){  va_list ap;  if( sqlite3GlobalConfig.xLog ){  va_start(ap, zFormat);  renderLogMsg(iErrCode, zFormat, ap);  va_end(ap);  } }
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
SQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){  va_list ap;  StrAccum acc;  char zBuf[SQLITE_PRINT_BUF_SIZE*10];  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  va_start(ap,zFormat);  sqlite3_str_vappendf(&acc, zFormat, ap);  va_end(ap);  sqlite3StrAccumFinish(&acc);
#ifdef SQLITE_OS_TRACE_PROC
 {  extern void SQLITE_OS_TRACE_PROC(const char *zBuf, int nBuf);  SQLITE_OS_TRACE_PROC(zBuf, sizeof(zBuf));  }
#else
 fprintf(stdout,"%s", zBuf);  fflush(stdout);
#endif
}
#endif
SQLITE_API void sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){  va_list ap;  va_start(ap,zFormat);  sqlite3_str_vappendf(p, zFormat, ap);  va_end(ap); }
#ifdef SQLITE_DEBUG
static TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow){  if( p==0 ){  p = sqlite3_malloc64( sizeof(*p) );  if( p==0 ) return 0;  memset(p, 0, sizeof(*p));  }else{  p->iLevel++;  }  assert( moreToFollow==0 || moreToFollow==1 );  if( p->iLevel<sizeof(p->bLine) ) p->bLine[p->iLevel] = moreToFollow;  return p; } static void sqlite3TreeViewPop(TreeView *p){  if( p==0 ) return;  p->iLevel--;  if( p->iLevel<0 ) sqlite3_free(p); } static void sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...){  va_list ap;  int i;  StrAccum acc;  char zBuf[500];  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  if( p ){  for(i=0; i<p->iLevel && i<sizeof(p->bLine)-1; i++){  sqlite3_str_append(&acc, p->bLine[i] ? "|  " : " ", 4);  }  sqlite3_str_append(&acc, p->bLine[i] ? "|-- " : "'-- ", 4);  }  if( zFormat!=0 ){  va_start(ap, zFormat);  sqlite3_str_vappendf(&acc, zFormat, ap);  va_end(ap);  assert( acc.nChar>0 || acc.accError );  sqlite3_str_append(&acc, "\n", 1);  }  sqlite3StrAccumFinish(&acc);  fprintf(stdout,"%s", zBuf);  fflush(stdout); } static void sqlite3TreeViewItem(TreeView *p, const char *zLabel,u8 moreFollows){  p = sqlite3TreeViewPush(p, moreFollows);  sqlite3TreeViewLine(p, "%s", zLabel); } SQLITE_PRIVATE void sqlite3TreeViewWith(TreeView *pView, const With *pWith, u8 moreToFollow){  int i;  if( pWith==0 ) return;  if( pWith->nCte==0 ) return;  if( pWith->pOuter ){  sqlite3TreeViewLine(pView, "WITH (0x%p, pOuter=0x%p)",pWith,pWith->pOuter);  }else{  sqlite3TreeViewLine(pView, "WITH (0x%p)", pWith);  }  if( pWith->nCte>0 ){  pView = sqlite3TreeViewPush(pView, 1);  for(i=0; i<pWith->nCte; i++){  StrAccum x;  char zLine[1000];  const struct Cte *pCte = &pWith->a[i];  sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);  sqlite3_str_appendf(&x, "%s", pCte->zName);  if( pCte->pCols && pCte->pCols->nExpr>0 ){  char cSep = '(';  int j;  for(j=0; j<pCte->pCols->nExpr; j++){  sqlite3_str_appendf(&x, "%c%s", cSep, pCte->pCols->a[j].zEName);  cSep = ',';  }  sqlite3_str_appendf(&x, ")");  }  if( pCte->pUse ){  sqlite3_str_appendf(&x, " (pUse=0x%p, nUse=%d)", pCte->pUse,   pCte->pUse->nUse);  }  sqlite3StrAccumFinish(&x);  sqlite3TreeViewItem(pView, zLine, i<pWith->nCte-1);  sqlite3TreeViewSelect(pView, pCte->pSelect, 0);  sqlite3TreeViewPop(pView);  }  sqlite3TreeViewPop(pView);  } } SQLITE_PRIVATE void sqlite3TreeViewSrcList(TreeView *pView, const SrcList *pSrc){  int i;  for(i=0; i<pSrc->nSrc; i++){  const SrcItem *pItem = &pSrc->a[i];  StrAccum x;  char zLine[100];  sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);  x.printfFlags |= SQLITE_PRINTF_INTERNAL;  sqlite3_str_appendf(&x, "{%d:*} %!S", pItem->iCursor, pItem);  if( pItem->pTab ){  sqlite3_str_appendf(&x, " tab=%Q nCol=%d ptr=%p used=%llx",   pItem->pTab->zName, pItem->pTab->nCol, pItem->pTab, pItem->colUsed);  }  if( pItem->fg.jointype & JT_LEFT ){  sqlite3_str_appendf(&x, " LEFT-JOIN");  }else if( pItem->fg.jointype & JT_CROSS ){  sqlite3_str_appendf(&x, " CROSS-JOIN");  }  if( pItem->fg.fromDDL ){  sqlite3_str_appendf(&x, " DDL");  }  if( pItem->fg.isCte ){  sqlite3_str_appendf(&x, " CteUse=0x%p", pItem->u2.pCteUse);  }  sqlite3StrAccumFinish(&x);  sqlite3TreeViewItem(pView, zLine, i<pSrc->nSrc-1);  if( pItem->pSelect ){  sqlite3TreeViewSelect(pView, pItem->pSelect, 0);  }  if( pItem->fg.isTabFunc ){  sqlite3TreeViewExprList(pView, pItem->u1.pFuncArg, 0, "func-args:");  }  sqlite3TreeViewPop(pView);  } } SQLITE_PRIVATE void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){  int n = 0;  int cnt = 0;  if( p==0 ){  sqlite3TreeViewLine(pView, "nil-SELECT");  return;  }  pView = sqlite3TreeViewPush(pView, moreToFollow);  if( p->pWith ){  sqlite3TreeViewWith(pView, p->pWith, 1);  cnt = 1;  sqlite3TreeViewPush(pView, 1);  }  do{  if( p->selFlags & SF_WhereBegin ){  sqlite3TreeViewLine(pView, "sqlite3WhereBegin()");  }else{  sqlite3TreeViewLine(pView,  "SELECT%s%s (%u/%p) selFlags=0x%x nSelectRow=%d",  ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),  ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""),  p->selId, p, p->selFlags,  (int)p->nSelectRow  );  }  if( cnt++ ) sqlite3TreeViewPop(pView);  if( p->pPrior ){  n = 1000;  }else{  n = 0;  if( p->pSrc && p->pSrc->nSrc ) n++;  if( p->pWhere ) n++;  if( p->pGroupBy ) n++;  if( p->pHaving ) n++;  if( p->pOrderBy ) n++;  if( p->pLimit ) n++;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( p->pWin ) n++;  if( p->pWinDefn ) n++;
#endif
 }  if( p->pEList ){  sqlite3TreeViewExprList(pView, p->pEList, n>0, "result-set");  }  n--;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( p->pWin ){  Window *pX;  pView = sqlite3TreeViewPush(pView, (n--)>0);  sqlite3TreeViewLine(pView, "window-functions");  for(pX=p->pWin; pX; pX=pX->pNextWin){  sqlite3TreeViewWinFunc(pView, pX, pX->pNextWin!=0);  }  sqlite3TreeViewPop(pView);  }
#endif
 if( p->pSrc && p->pSrc->nSrc ){  pView = sqlite3TreeViewPush(pView, (n--)>0);  sqlite3TreeViewLine(pView, "FROM");  sqlite3TreeViewSrcList(pView, p->pSrc);  sqlite3TreeViewPop(pView);  }  if( p->pWhere ){  sqlite3TreeViewItem(pView, "WHERE", (n--)>0);  sqlite3TreeViewExpr(pView, p->pWhere, 0);  sqlite3TreeViewPop(pView);  }  if( p->pGroupBy ){  sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, "GROUPBY");  }  if( p->pHaving ){  sqlite3TreeViewItem(pView, "HAVING", (n--)>0);  sqlite3TreeViewExpr(pView, p->pHaving, 0);  sqlite3TreeViewPop(pView);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( p->pWinDefn ){  Window *pX;  sqlite3TreeViewItem(pView, "WINDOW", (n--)>0);  for(pX=p->pWinDefn; pX; pX=pX->pNextWin){  sqlite3TreeViewWindow(pView, pX, pX->pNextWin!=0);  }  sqlite3TreeViewPop(pView);  }
#endif
 if( p->pOrderBy ){  sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, "ORDERBY");  }  if( p->pLimit ){  sqlite3TreeViewItem(pView, "LIMIT", (n--)>0);  sqlite3TreeViewExpr(pView, p->pLimit->pLeft, p->pLimit->pRight!=0);  if( p->pLimit->pRight ){  sqlite3TreeViewItem(pView, "OFFSET", (n--)>0);  sqlite3TreeViewExpr(pView, p->pLimit->pRight, 0);  sqlite3TreeViewPop(pView);  }  sqlite3TreeViewPop(pView);  }  if( p->pPrior ){  const char *zOp = "UNION";  switch( p->op ){  case TK_ALL:  zOp = "UNION ALL"; break;  case TK_INTERSECT:  zOp = "INTERSECT"; break;  case TK_EXCEPT: zOp = "EXCEPT";  break;  }  sqlite3TreeViewItem(pView, zOp, 1);  }  p = p->pPrior;  }while( p!=0 );  sqlite3TreeViewPop(pView); }
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE void sqlite3TreeViewBound(  TreeView *pView,  u8 eBound,  Expr *pExpr,  u8 moreToFollow ){  switch( eBound ){  case TK_UNBOUNDED: {  sqlite3TreeViewItem(pView, "UNBOUNDED", moreToFollow);  sqlite3TreeViewPop(pView);  break;  }  case TK_CURRENT: {  sqlite3TreeViewItem(pView, "CURRENT", moreToFollow);  sqlite3TreeViewPop(pView);  break;  }  case TK_PRECEDING: {  sqlite3TreeViewItem(pView, "PRECEDING", moreToFollow);  sqlite3TreeViewExpr(pView, pExpr, 0);  sqlite3TreeViewPop(pView);  break;  }  case TK_FOLLOWING: {  sqlite3TreeViewItem(pView, "FOLLOWING", moreToFollow);  sqlite3TreeViewExpr(pView, pExpr, 0);  sqlite3TreeViewPop(pView);  break;  }  } }
#endif
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE void sqlite3TreeViewWindow(TreeView *pView, const Window *pWin, u8 more){  int nElement = 0;  if( pWin->pFilter ){  sqlite3TreeViewItem(pView, "FILTER", 1);  sqlite3TreeViewExpr(pView, pWin->pFilter, 0);  sqlite3TreeViewPop(pView);  }  pView = sqlite3TreeViewPush(pView, more);  if( pWin->zName ){  sqlite3TreeViewLine(pView, "OVER %s (%p)", pWin->zName, pWin);  }else{  sqlite3TreeViewLine(pView, "OVER (%p)", pWin);  }  if( pWin->zBase ) nElement++;  if( pWin->pOrderBy ) nElement++;  if( pWin->eFrmType ) nElement++;  if( pWin->eExclude ) nElement++;  if( pWin->zBase ){  sqlite3TreeViewPush(pView, (--nElement)>0);  sqlite3TreeViewLine(pView, "window: %s", pWin->zBase);  sqlite3TreeViewPop(pView);  }  if( pWin->pPartition ){  sqlite3TreeViewExprList(pView, pWin->pPartition, nElement>0,"PARTITION-BY");  }  if( pWin->pOrderBy ){  sqlite3TreeViewExprList(pView, pWin->pOrderBy, (--nElement)>0, "ORDER-BY");  }  if( pWin->eFrmType ){  char zBuf[30];  const char *zFrmType = "ROWS";  if( pWin->eFrmType==TK_RANGE ) zFrmType = "RANGE";  if( pWin->eFrmType==TK_GROUPS ) zFrmType = "GROUPS";  sqlite3_snprintf(sizeof(zBuf),zBuf,"%s%s",zFrmType,  pWin->bImplicitFrame ? " (implied)" : "");  sqlite3TreeViewItem(pView, zBuf, (--nElement)>0);  sqlite3TreeViewBound(pView, pWin->eStart, pWin->pStart, 1);  sqlite3TreeViewBound(pView, pWin->eEnd, pWin->pEnd, 0);  sqlite3TreeViewPop(pView);  }  if( pWin->eExclude ){  char zBuf[30];  const char *zExclude;  switch( pWin->eExclude ){  case TK_NO: zExclude = "NO OTHERS";  break;  case TK_CURRENT: zExclude = "CURRENT ROW"; break;  case TK_GROUP:  zExclude = "GROUP";  break;  case TK_TIES: zExclude = "TIES"; break;  default:  sqlite3_snprintf(sizeof(zBuf),zBuf,"invalid(%d)", pWin->eExclude);  zExclude = zBuf;  break;  }  sqlite3TreeViewPush(pView, 0);  sqlite3TreeViewLine(pView, "EXCLUDE %s", zExclude);  sqlite3TreeViewPop(pView);  }  sqlite3TreeViewPop(pView); }
#endif
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE void sqlite3TreeViewWinFunc(TreeView *pView, const Window *pWin, u8 more){  pView = sqlite3TreeViewPush(pView, more);  sqlite3TreeViewLine(pView, "WINFUNC %s(%d)",   pWin->pFunc->zName, pWin->pFunc->nArg);  sqlite3TreeViewWindow(pView, pWin, 0);  sqlite3TreeViewPop(pView); }
#endif
SQLITE_PRIVATE void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){  const char *zBinOp = 0;  const char *zUniOp = 0;  char zFlgs[200];  pView = sqlite3TreeViewPush(pView, moreToFollow);  if( pExpr==0 ){  sqlite3TreeViewLine(pView, "nil");  sqlite3TreeViewPop(pView);  return;  }  if( pExpr->flags || pExpr->affExpr || pExpr->vvaFlags ){  StrAccum x;  sqlite3StrAccumInit(&x, 0, zFlgs, sizeof(zFlgs), 0);  sqlite3_str_appendf(&x, " fg.af=%x.%c",  pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n');  if( ExprHasProperty(pExpr, EP_FromJoin) ){  sqlite3_str_appendf(&x, " iRJT=%d", pExpr->iRightJoinTable);  }  if( ExprHasProperty(pExpr, EP_FromDDL) ){  sqlite3_str_appendf(&x, " DDL");  }  if( ExprHasVVAProperty(pExpr, EP_Immutable) ){  sqlite3_str_appendf(&x, " IMMUTABLE");  }  sqlite3StrAccumFinish(&x);  }else{  zFlgs[0] = 0;  }  switch( pExpr->op ){  case TK_AGG_COLUMN: {  sqlite3TreeViewLine(pView, "AGG{%d:%d}%s",  pExpr->iTable, pExpr->iColumn, zFlgs);  break;  }  case TK_COLUMN: {  if( pExpr->iTable<0 ){  char zOp2[16];  if( pExpr->op2 ){  sqlite3_snprintf(sizeof(zOp2),zOp2," op2=0x%02x",pExpr->op2);  }else{  zOp2[0] = 0;  }  sqlite3TreeViewLine(pView, "COLUMN(%d)%s%s",  pExpr->iColumn, zFlgs, zOp2);  }else{  assert( ExprUseYTab(pExpr) );  sqlite3TreeViewLine(pView, "{%d:%d} pTab=%p%s",  pExpr->iTable, pExpr->iColumn,  pExpr->y.pTab, zFlgs);  }  if( ExprHasProperty(pExpr, EP_FixedCol) ){  sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);  }  break;  }  case TK_INTEGER: {  if( pExpr->flags & EP_IntValue ){  sqlite3TreeViewLine(pView, "%d", pExpr->u.iValue);  }else{  sqlite3TreeViewLine(pView, "%s", pExpr->u.zToken);  }  break;  }
#ifndef SQLITE_OMIT_FLOATING_POINT
 case TK_FLOAT: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);  break;  }
#endif
 case TK_STRING: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView,"%Q", pExpr->u.zToken);  break;  }  case TK_NULL: {  sqlite3TreeViewLine(pView,"NULL");  break;  }  case TK_TRUEFALSE: {  sqlite3TreeViewLine(pView,"%s%s",   sqlite3ExprTruthValue(pExpr) ? "TRUE" : "FALSE", zFlgs);  break;  }
#ifndef SQLITE_OMIT_BLOB_LITERAL
 case TK_BLOB: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);  break;  }
#endif
 case TK_VARIABLE: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView,"VARIABLE(%s,%d)",  pExpr->u.zToken, pExpr->iColumn);  break;  }  case TK_REGISTER: {  sqlite3TreeViewLine(pView,"REGISTER(%d)", pExpr->iTable);  break;  }  case TK_ID: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView,"ID \"%w\"", pExpr->u.zToken);  break;  }
#ifndef SQLITE_OMIT_CAST
 case TK_CAST: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView,"CAST %Q", pExpr->u.zToken);  sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);  break;  }
#endif
 case TK_LT: zBinOp = "LT";  break;  case TK_LE: zBinOp = "LE";  break;  case TK_GT: zBinOp = "GT";  break;  case TK_GE: zBinOp = "GE";  break;  case TK_NE: zBinOp = "NE";  break;  case TK_EQ: zBinOp = "EQ";  break;  case TK_IS: zBinOp = "IS";  break;  case TK_ISNOT:  zBinOp = "ISNOT"; break;  case TK_AND:  zBinOp = "AND"; break;  case TK_OR: zBinOp = "OR";  break;  case TK_PLUS: zBinOp = "ADD"; break;  case TK_STAR: zBinOp = "MUL"; break;  case TK_MINUS:  zBinOp = "SUB"; break;  case TK_REM:  zBinOp = "REM"; break;  case TK_BITAND: zBinOp = "BITAND"; break;  case TK_BITOR:  zBinOp = "BITOR"; break;  case TK_SLASH:  zBinOp = "DIV"; break;  case TK_LSHIFT: zBinOp = "LSHIFT"; break;  case TK_RSHIFT: zBinOp = "RSHIFT"; break;  case TK_CONCAT: zBinOp = "CONCAT"; break;  case TK_DOT:  zBinOp = "DOT"; break;  case TK_LIMIT:  zBinOp = "LIMIT"; break;  case TK_UMINUS: zUniOp = "UMINUS"; break;  case TK_UPLUS:  zUniOp = "UPLUS"; break;  case TK_BITNOT: zUniOp = "BITNOT"; break;  case TK_NOT:  zUniOp = "NOT"; break;  case TK_ISNULL: zUniOp = "ISNULL"; break;  case TK_NOTNULL: zUniOp = "NOTNULL"; break;  case TK_TRUTH: {  int x;  const char *azOp[] = {   "IS-FALSE", "IS-TRUE", "IS-NOT-FALSE", "IS-NOT-TRUE"  };  assert( pExpr->op2==TK_IS || pExpr->op2==TK_ISNOT );  assert( pExpr->pRight );  assert( sqlite3ExprSkipCollate(pExpr->pRight)->op==TK_TRUEFALSE );  x = (pExpr->op2==TK_ISNOT)*2 + sqlite3ExprTruthValue(pExpr->pRight);  zUniOp = azOp[x];  break;  }  case TK_SPAN: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView, "SPAN %Q", pExpr->u.zToken);  sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);  break;  }  case TK_COLLATE: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView, "%sCOLLATE %Q%s",  !ExprHasProperty(pExpr, EP_Collate) ? "SOFT-" : "",  pExpr->u.zToken, zFlgs);  sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);  break;  }  case TK_AGG_FUNCTION:  case TK_FUNCTION: {  ExprList *pFarg;  Window *pWin;  if( ExprHasProperty(pExpr, EP_TokenOnly) ){  pFarg = 0;  pWin = 0;  }else{  assert( ExprUseXList(pExpr) );  pFarg = pExpr->x.pList;
#ifndef SQLITE_OMIT_WINDOWFUNC
 pWin = ExprHasProperty(pExpr, EP_WinFunc) ? pExpr->y.pWin : 0;
#else
 pWin = 0;
#endif
 }  assert( !ExprHasProperty(pExpr, EP_IntValue) );  if( pExpr->op==TK_AGG_FUNCTION ){  sqlite3TreeViewLine(pView, "AGG_FUNCTION%d %Q%s agg=%d[%d]/%p",   pExpr->op2, pExpr->u.zToken, zFlgs,   pExpr->pAggInfo ? pExpr->pAggInfo->selId : 0,   pExpr->iAgg, pExpr->pAggInfo);  }else if( pExpr->op2!=0 ){  const char *zOp2;  char zBuf[8];  sqlite3_snprintf(sizeof(zBuf),zBuf,"0x%02x",pExpr->op2);  zOp2 = zBuf;  if( pExpr->op2==NC_IsCheck ) zOp2 = "NC_IsCheck";  if( pExpr->op2==NC_IdxExpr ) zOp2 = "NC_IdxExpr";  if( pExpr->op2==NC_PartIdx ) zOp2 = "NC_PartIdx";  if( pExpr->op2==NC_GenCol ) zOp2 = "NC_GenCol";  sqlite3TreeViewLine(pView, "FUNCTION %Q%s op2=%s",  pExpr->u.zToken, zFlgs, zOp2);  }else{  sqlite3TreeViewLine(pView, "FUNCTION %Q%s", pExpr->u.zToken, zFlgs);  }  if( pFarg ){  sqlite3TreeViewExprList(pView, pFarg, pWin!=0, 0);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pWin ){  sqlite3TreeViewWindow(pView, pWin, 0);  }
#endif
 break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case TK_EXISTS: {  assert( ExprUseXSelect(pExpr) );  sqlite3TreeViewLine(pView, "EXISTS-expr flags=0x%x", pExpr->flags);  sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);  break;  }  case TK_SELECT: {  assert( ExprUseXSelect(pExpr) );  sqlite3TreeViewLine(pView, "subquery-expr flags=0x%x", pExpr->flags);  sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);  break;  }  case TK_IN: {  sqlite3TreeViewLine(pView, "IN flags=0x%x", pExpr->flags);  sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);  if( ExprUseXSelect(pExpr) ){  sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);  }else{  sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);  }  break;  }
#endif
 case TK_BETWEEN: {  const Expr *pX, *pY, *pZ;  pX = pExpr->pLeft;  assert( ExprUseXList(pExpr) );  assert( pExpr->x.pList->nExpr==2 );  pY = pExpr->x.pList->a[0].pExpr;  pZ = pExpr->x.pList->a[1].pExpr;  sqlite3TreeViewLine(pView, "BETWEEN");  sqlite3TreeViewExpr(pView, pX, 1);  sqlite3TreeViewExpr(pView, pY, 1);  sqlite3TreeViewExpr(pView, pZ, 0);  break;  }  case TK_TRIGGER: {  sqlite3TreeViewLine(pView, "%s(%d)",  pExpr->iTable ? "NEW" : "OLD", pExpr->iColumn);  break;  }  case TK_CASE: {  sqlite3TreeViewLine(pView, "CASE");  sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);  assert( ExprUseXList(pExpr) );  sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);  break;  }
#ifndef SQLITE_OMIT_TRIGGER
 case TK_RAISE: {  const char *zType = "unk";  switch( pExpr->affExpr ){  case OE_Rollback:  zType = "rollback"; break;  case OE_Abort: zType = "abort";  break;  case OE_Fail:  zType = "fail"; break;  case OE_Ignore:  zType = "ignore"; break;  }  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3TreeViewLine(pView, "RAISE %s(%Q)", zType, pExpr->u.zToken);  break;  }
#endif
 case TK_MATCH: {  sqlite3TreeViewLine(pView, "MATCH {%d:%d}%s",  pExpr->iTable, pExpr->iColumn, zFlgs);  sqlite3TreeViewExpr(pView, pExpr->pRight, 0);  break;  }  case TK_VECTOR: {  char *z = sqlite3_mprintf("VECTOR%s",zFlgs);  assert( ExprUseXList(pExpr) );  sqlite3TreeViewBareExprList(pView, pExpr->x.pList, z);  sqlite3_free(z);  break;  }  case TK_SELECT_COLUMN: {  sqlite3TreeViewLine(pView, "SELECT-COLUMN %d of [0..%d]%s",  pExpr->iColumn, pExpr->iTable-1,  pExpr->pRight==pExpr->pLeft ? " (SELECT-owner)" : "");  assert( ExprUseXSelect(pExpr->pLeft) );  sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);  break;  }  case TK_IF_NULL_ROW: {  sqlite3TreeViewLine(pView, "IF-NULL-ROW %d", pExpr->iTable);  sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);  break;  }  case TK_ERROR: {  Expr tmp;  sqlite3TreeViewLine(pView, "ERROR");  tmp = *pExpr;  tmp.op = pExpr->op2;  sqlite3TreeViewExpr(pView, &tmp, 0);  break;  }  case TK_ROW: {  if( pExpr->iColumn<=0 ){  sqlite3TreeViewLine(pView, "First FROM table rowid");  }else{  sqlite3TreeViewLine(pView, "First FROM table column %d",  pExpr->iColumn-1);  }  break;  }  default: {  sqlite3TreeViewLine(pView, "op=%d", pExpr->op);  break;  }  }  if( zBinOp ){  sqlite3TreeViewLine(pView, "%s%s", zBinOp, zFlgs);  sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);  sqlite3TreeViewExpr(pView, pExpr->pRight, 0);  }else if( zUniOp ){  sqlite3TreeViewLine(pView, "%s%s", zUniOp, zFlgs);   sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);  }  sqlite3TreeViewPop(pView); } SQLITE_PRIVATE void sqlite3TreeViewBareExprList(  TreeView *pView,  const ExprList *pList,  const char *zLabel ){  if( zLabel==0 || zLabel[0]==0 ) zLabel = "LIST";  if( pList==0 ){  sqlite3TreeViewLine(pView, "%s (empty)", zLabel);  }else{  int i;  sqlite3TreeViewLine(pView, "%s", zLabel);  for(i=0; i<pList->nExpr; i++){  int j = pList->a[i].u.x.iOrderByCol;  char *zName = pList->a[i].zEName;  int moreToFollow = i<pList->nExpr - 1;  if( pList->a[i].eEName!=ENAME_NAME ) zName = 0;  if( j || zName ){  sqlite3TreeViewPush(pView, moreToFollow);  moreToFollow = 0;  sqlite3TreeViewLine(pView, 0);  if( zName ){  fprintf(stdout, "AS %s ", zName);  }  if( j ){  fprintf(stdout, "iOrderByCol=%d", j);  }  fprintf(stdout, "\n");  fflush(stdout);  }  sqlite3TreeViewExpr(pView, pList->a[i].pExpr, moreToFollow);  if( j || zName ){  sqlite3TreeViewPop(pView);  }  }  } } SQLITE_PRIVATE void sqlite3TreeViewExprList(  TreeView *pView,  const ExprList *pList,  u8 moreToFollow,  const char *zLabel ){  pView = sqlite3TreeViewPush(pView, moreToFollow);  sqlite3TreeViewBareExprList(pView, pList, zLabel);  sqlite3TreeViewPop(pView); }
#endif
static SQLITE_WSD struct sqlite3PrngType {  unsigned char isInit;  unsigned char i, j;  unsigned char s[256]; } sqlite3Prng; SQLITE_API void sqlite3_randomness(int N, void *pBuf){  unsigned char t;  unsigned char *zBuf = pBuf;
#ifdef SQLITE_OMIT_WSD
 struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);
# define wsdPrng p[0]
#else
# define wsdPrng sqlite3Prng
#endif
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex;
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return;
#endif
#if SQLITE_THREADSAFE
 mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);
#endif
 sqlite3_mutex_enter(mutex);  if( N<=0 || pBuf==0 ){  wsdPrng.isInit = 0;  sqlite3_mutex_leave(mutex);  return;  }  if( !wsdPrng.isInit ){  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);  int i;  char k[256];  wsdPrng.j = 0;  wsdPrng.i = 0;  if( NEVER(pVfs==0) ){  memset(k, 0, sizeof(k));  }else{  sqlite3OsRandomness(pVfs, 256, k);  }  for(i=0; i<256; i++){  wsdPrng.s[i] = (u8)i;  }  for(i=0; i<256; i++){  wsdPrng.j += wsdPrng.s[i] + k[i];  t = wsdPrng.s[wsdPrng.j];  wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];  wsdPrng.s[i] = t;  }  wsdPrng.isInit = 1;  }  assert( N>0 );  do{  wsdPrng.i++;  t = wsdPrng.s[wsdPrng.i];  wsdPrng.j += t;  wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];  wsdPrng.s[wsdPrng.j] = t;  t += wsdPrng.s[wsdPrng.i];  *(zBuf++) = wsdPrng.s[t];  }while( --N );  sqlite3_mutex_leave(mutex); }
#ifndef SQLITE_UNTESTABLE
static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng; SQLITE_PRIVATE void sqlite3PrngSaveState(void){  memcpy(  &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),  &GLOBAL(struct sqlite3PrngType, sqlite3Prng),  sizeof(sqlite3Prng)  ); } SQLITE_PRIVATE void sqlite3PrngRestoreState(void){  memcpy(  &GLOBAL(struct sqlite3PrngType, sqlite3Prng),  &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),  sizeof(sqlite3Prng)  ); }
#endif
#if SQLITE_OS_WIN
#endif
#if SQLITE_MAX_WORKER_THREADS>0
#if SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) && SQLITE_THREADSAFE>0
#define SQLITE_THREADS_IMPLEMENTED 1
struct SQLiteThread {  pthread_t tid;  int done;  void *pOut;  void *(*xTask)(void*);  void *pIn; }; SQLITE_PRIVATE int sqlite3ThreadCreate(  SQLiteThread **ppThread,  void *(*xTask)(void*),  void *pIn ){  SQLiteThread *p;  int rc;  assert( ppThread!=0 );  assert( xTask!=0 );  assert( sqlite3GlobalConfig.bCoreMutex!=0 );  *ppThread = 0;  p = sqlite3Malloc(sizeof(*p));  if( p==0 ) return SQLITE_NOMEM_BKPT;  memset(p, 0, sizeof(*p));  p->xTask = xTask;  p->pIn = pIn;  if( sqlite3FaultSim(200) ){  rc = 1;  }else{  rc = pthread_create(&p->tid, 0, xTask, pIn);  }  if( rc ){  p->done = 1;  p->pOut = xTask(pIn);  }  *ppThread = p;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){  int rc;  assert( ppOut!=0 );  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;  if( p->done ){  *ppOut = p->pOut;  rc = SQLITE_OK;  }else{  rc = pthread_join(p->tid, ppOut) ? SQLITE_ERROR : SQLITE_OK;  }  sqlite3_free(p);  return rc; }
#endif
#if SQLITE_OS_WIN_THREADS
#define SQLITE_THREADS_IMPLEMENTED 1
#include <process.h>
struct SQLiteThread {  void *tid;  unsigned id;  void *(*xTask)(void*);  void *pIn;  void *pResult; }; static unsigned __stdcall sqlite3ThreadProc(  void *pArg ){  SQLiteThread *p = (SQLiteThread *)pArg;  assert( p!=0 );
#if 0
 assert( p->id==GetCurrentThreadId() );
#endif
 assert( p->xTask!=0 );  p->pResult = p->xTask(p->pIn);  _endthreadex(0);  return 0; } SQLITE_PRIVATE int sqlite3ThreadCreate(  SQLiteThread **ppThread,  void *(*xTask)(void*),  void *pIn ){  SQLiteThread *p;  assert( ppThread!=0 );  assert( xTask!=0 );  *ppThread = 0;  p = sqlite3Malloc(sizeof(*p));  if( p==0 ) return SQLITE_NOMEM_BKPT;  if( sqlite3GlobalConfig.bCoreMutex==0 || sqlite3FaultSim(200) ){  memset(p, 0, sizeof(*p));  }else{  p->xTask = xTask;  p->pIn = pIn;  p->tid = (void*)_beginthreadex(0, 0, sqlite3ThreadProc, p, 0, &p->id);  if( p->tid==0 ){  memset(p, 0, sizeof(*p));  }  }  if( p->xTask==0 ){  p->id = GetCurrentThreadId();  p->pResult = xTask(pIn);  }  *ppThread = p;  return SQLITE_OK; } SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject); SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){  DWORD rc;  BOOL bRc;  assert( ppOut!=0 );  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;  if( p->xTask==0 ){  rc = WAIT_OBJECT_0;  assert( p->tid==0 );  }else{  assert( p->id!=0 && p->id!=GetCurrentThreadId() );  rc = sqlite3Win32Wait((HANDLE)p->tid);  assert( rc!=WAIT_IO_COMPLETION );  bRc = CloseHandle((HANDLE)p->tid);  assert( bRc );  }  if( rc==WAIT_OBJECT_0 ) *ppOut = p->pResult;  sqlite3_free(p);  return (rc==WAIT_OBJECT_0) ? SQLITE_OK : SQLITE_ERROR; }
#endif
#ifndef SQLITE_THREADS_IMPLEMENTED
struct SQLiteThread {  void *(*xTask)(void*);  void *pIn;  void *pResult; }; SQLITE_PRIVATE int sqlite3ThreadCreate(  SQLiteThread **ppThread,  void *(*xTask)(void*),  void *pIn ){  SQLiteThread *p;  assert( ppThread!=0 );  assert( xTask!=0 );  *ppThread = 0;  p = sqlite3Malloc(sizeof(*p));  if( p==0 ) return SQLITE_NOMEM_BKPT;  if( (SQLITE_PTR_TO_INT(p)/17)&1 ){  p->xTask = xTask;  p->pIn = pIn;  }else{  p->xTask = 0;  p->pResult = xTask(pIn);  }  *ppThread = p;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){  assert( ppOut!=0 );  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;  if( p->xTask ){  *ppOut = p->xTask(p->pIn);  }else{  *ppOut = p->pResult;  }  sqlite3_free(p);
#if defined(SQLITE_TEST)
 {  void *pTstAlloc = sqlite3Malloc(10);  if (!pTstAlloc) return SQLITE_NOMEM_BKPT;  sqlite3_free(pTstAlloc);  }
#endif
 return SQLITE_OK; }
#endif
#endif
#if !defined(SQLITE_AMALGAMATION) && SQLITE_BYTEORDER==0
SQLITE_PRIVATE const int sqlite3one = 1;
#endif
static const unsigned char sqlite3Utf8Trans1[] = {  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, };
#define WRITE_UTF8(zOut, c) {  if( c<0x00080 ){   *zOut++ = (u8)(c&0xFF);  }  else if( c<0x00800 ){  *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);  *zOut++ = 0x80 + (u8)(c & 0x3F);   }  else if( c<0x10000 ){  *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);   *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);  *zOut++ = 0x80 + (u8)(c & 0x3F);   }else{   *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);   *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);   *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);  *zOut++ = 0x80 + (u8)(c & 0x3F);   } }

#define WRITE_UTF16LE(zOut, c) {  if( c<=0xFFFF ){  *zOut++ = (u8)(c&0x00FF);   *zOut++ = (u8)((c>>8)&0x00FF);  }else{  *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));  *zOut++ = (u8)(c&0x00FF);   *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));   }  }

#define WRITE_UTF16BE(zOut, c) {  if( c<=0xFFFF ){  *zOut++ = (u8)((c>>8)&0x00FF);  *zOut++ = (u8)(c&0x00FF);   }else{  *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));  *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));   *zOut++ = (u8)(c&0x00FF);   }  }

#define READ_UTF8(zIn, zTerm, c)   c = *(zIn++);  if( c>=0xc0 ){   c = sqlite3Utf8Trans1[c-0xc0];   while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){  c = (c<<6) + (0x3f & *(zIn++));  }  if( c<0x80   || (c&0xFFFFF800)==0xD800  || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }  }

SQLITE_PRIVATE u32 sqlite3Utf8Read(  const unsigned char **pz ){  unsigned int c;  c = *((*pz)++);  if( c>=0xc0 ){  c = sqlite3Utf8Trans1[c-0xc0];  while( (*(*pz) & 0xc0)==0x80 ){  c = (c<<6) + (0x3f & *((*pz)++));  }  if( c<0x80  || (c&0xFFFFF800)==0xD800  || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }  }  return c; }
#ifndef SQLITE_OMIT_UTF16
SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){  sqlite3_int64 len;  unsigned char *zOut;  unsigned char *zIn;  unsigned char *zTerm;  unsigned char *z;  unsigned int c;  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( pMem->flags&MEM_Str );  assert( pMem->enc!=desiredEnc );  assert( pMem->enc!=0 );  assert( pMem->n>=0 );
#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)
 {  StrAccum acc;  char zBuf[1000];  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  sqlite3VdbeMemPrettyPrint(pMem, &acc);  fprintf(stderr, "INPUT: %s\n", sqlite3StrAccumFinish(&acc));  }
#endif
 if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){  u8 temp;  int rc;  rc = sqlite3VdbeMemMakeWriteable(pMem);  if( rc!=SQLITE_OK ){  assert( rc==SQLITE_NOMEM );  return SQLITE_NOMEM_BKPT;  }  zIn = (u8*)pMem->z;  zTerm = &zIn[pMem->n&~1];  while( zIn<zTerm ){  temp = *zIn;  *zIn = *(zIn+1);  zIn++;  *zIn++ = temp;  }  pMem->enc = desiredEnc;  goto translate_out;  }  if( desiredEnc==SQLITE_UTF8 ){  pMem->n &= ~1;  len = 2 * (sqlite3_int64)pMem->n + 1;  }else{  len = 2 * (sqlite3_int64)pMem->n + 2;  }  zIn = (u8*)pMem->z;  zTerm = &zIn[pMem->n];  zOut = sqlite3DbMallocRaw(pMem->db, len);  if( !zOut ){  return SQLITE_NOMEM_BKPT;  }  z = zOut;  if( pMem->enc==SQLITE_UTF8 ){  if( desiredEnc==SQLITE_UTF16LE ){  while( zIn<zTerm ){  READ_UTF8(zIn, zTerm, c);  WRITE_UTF16LE(z, c);  }  }else{  assert( desiredEnc==SQLITE_UTF16BE );  while( zIn<zTerm ){  READ_UTF8(zIn, zTerm, c);  WRITE_UTF16BE(z, c);  }  }  pMem->n = (int)(z - zOut);  *z++ = 0;  }else{  assert( desiredEnc==SQLITE_UTF8 );  if( pMem->enc==SQLITE_UTF16LE ){  while( zIn<zTerm ){  c = *(zIn++);  c += (*(zIn++))<<8;  if( c>=0xd800 && c<0xe000 ){
#ifdef SQLITE_REPLACE_INVALID_UTF
 if( c>=0xdc00 || zIn>=zTerm ){  c = 0xfffd;  }else{  int c2 = *(zIn++);  c2 += (*(zIn++))<<8;  if( c2<0xdc00 || c2>=0xe000 ){  zIn -= 2;  c = 0xfffd;  }else{  c = ((c&0x3ff)<<10) + (c2&0x3ff) + 0x10000;  }  }
#else
 if( zIn<zTerm ){  int c2 = (*zIn++);  c2 += ((*zIn++)<<8);  c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);  }
#endif
 }  WRITE_UTF8(z, c);  }  }else{  while( zIn<zTerm ){  c = (*(zIn++))<<8;  c += *(zIn++);  if( c>=0xd800 && c<0xe000 ){
#ifdef SQLITE_REPLACE_INVALID_UTF
 if( c>=0xdc00 || zIn>=zTerm ){  c = 0xfffd;  }else{  int c2 = (*(zIn++))<<8;  c2 += *(zIn++);  if( c2<0xdc00 || c2>=0xe000 ){  zIn -= 2;  c = 0xfffd;  }else{  c = ((c&0x3ff)<<10) + (c2&0x3ff) + 0x10000;  }  }
#else
 if( zIn<zTerm ){  int c2 = ((*zIn++)<<8);  c2 += (*zIn++);  c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);  }
#endif
 }  WRITE_UTF8(z, c);  }  }  pMem->n = (int)(z - zOut);  }  *z = 0;  assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len );  c = MEM_Str|MEM_Term|(pMem->flags&(MEM_AffMask|MEM_Subtype));  sqlite3VdbeMemRelease(pMem);  pMem->flags = c;  pMem->enc = desiredEnc;  pMem->z = (char*)zOut;  pMem->zMalloc = pMem->z;  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z); translate_out:
#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)
 {  StrAccum acc;  char zBuf[1000];  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  sqlite3VdbeMemPrettyPrint(pMem, &acc);  fprintf(stderr, "OUTPUT: %s\n", sqlite3StrAccumFinish(&acc));  }
#endif
 return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_UTF16
SQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem){  int rc = SQLITE_OK;  u8 bom = 0;  assert( pMem->n>=0 );  if( pMem->n>1 ){  u8 b1 = *(u8 *)pMem->z;  u8 b2 = *(((u8 *)pMem->z) + 1);  if( b1==0xFE && b2==0xFF ){  bom = SQLITE_UTF16BE;  }  if( b1==0xFF && b2==0xFE ){  bom = SQLITE_UTF16LE;  }  }  if( bom ){  rc = sqlite3VdbeMemMakeWriteable(pMem);  if( rc==SQLITE_OK ){  pMem->n -= 2;  memmove(pMem->z, &pMem->z[2], pMem->n);  pMem->z[pMem->n] = '\0';  pMem->z[pMem->n+1] = '\0';  pMem->flags |= MEM_Term;  pMem->enc = bom;  }  }  return rc; }
#endif
SQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){  int r = 0;  const u8 *z = (const u8*)zIn;  const u8 *zTerm;  if( nByte>=0 ){  zTerm = &z[nByte];  }else{  zTerm = (const u8*)(-1);  }  assert( z<=zTerm );  while( *z!=0 && z<zTerm ){  SQLITE_SKIP_UTF8(z);  r++;  }  return r; }
#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
SQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn){  unsigned char *zOut = zIn;  unsigned char *zStart = zIn;  u32 c;  while( zIn[0] && zOut<=zIn ){  c = sqlite3Utf8Read((const u8**)&zIn);  if( c!=0xfffd ){  WRITE_UTF8(zOut, c);  }  }  *zOut = 0;  return (int)(zOut - zStart); }
#endif
#ifndef SQLITE_OMIT_UTF16
SQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){  Mem m;  memset(&m, 0, sizeof(m));  m.db = db;  sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);  if( db->mallocFailed ){  sqlite3VdbeMemRelease(&m);  m.z = 0;  }  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );  assert( m.z || db->mallocFailed );  return m.z; } SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){  int c;  unsigned char const *z = zIn;  int n = 0;  if( SQLITE_UTF16NATIVE==SQLITE_UTF16LE ) z++;  while( n<nChar ){  c = z[0];  z += 2;  if( c>=0xd8 && c<0xdc && z[0]>=0xdc && z[0]<0xe0 ) z += 2;  n++;  }  return (int)(z-(unsigned char const *)zIn)  - (SQLITE_UTF16NATIVE==SQLITE_UTF16LE); }
#if defined(SQLITE_TEST)
SQLITE_PRIVATE void sqlite3UtfSelfTest(void){  unsigned int i, t;  unsigned char zBuf[20];  unsigned char *z;  int n;  unsigned int c;  for(i=0; i<0x00110000; i++){  z = zBuf;  WRITE_UTF8(z, i);  n = (int)(z-zBuf);  assert( n>0 && n<=4 );  z[0] = 0;  z = zBuf;  c = sqlite3Utf8Read((const u8**)&z);  t = i;  if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;  if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;  assert( c==t );  assert( (z-zBuf)==n );  } }
#endif
#endif
#ifndef SQLITE_OMIT_FLOATING_POINT
#include <math.h>
#endif
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE int sqlite3FaultSim(int iTest){  int (*xCallback)(int) = sqlite3GlobalConfig.xTestCallback;  return xCallback ? xCallback(iTest) : SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_FLOATING_POINT
SQLITE_PRIVATE int sqlite3IsNaN(double x){  int rc;
#if !SQLITE_HAVE_ISNAN && !HAVE_ISNAN
 u64 y;  memcpy(&y,&x,sizeof(y));  rc = IsNaN(y);
#else
 rc = isnan(x);
#endif
 testcase( rc );  return rc; }
#endif
SQLITE_PRIVATE int sqlite3Strlen30(const char *z){  if( z==0 ) return 0;  return 0x3fffffff & (int)strlen(z); } SQLITE_PRIVATE char *sqlite3ColumnType(Column *pCol, char *zDflt){  if( pCol->colFlags & COLFLAG_HASTYPE ){  return pCol->zCnName + strlen(pCol->zCnName) + 1;  }else if( pCol->eCType ){  assert( pCol->eCType<=SQLITE_N_STDTYPE );  return (char*)sqlite3StdType[pCol->eCType-1];  }else{  return zDflt;  } } static SQLITE_NOINLINE void sqlite3ErrorFinish(sqlite3 *db, int err_code){  if( db->pErr ) sqlite3ValueSetNull(db->pErr);  sqlite3SystemError(db, err_code); } SQLITE_PRIVATE void sqlite3Error(sqlite3 *db, int err_code){  assert( db!=0 );  db->errCode = err_code;  if( err_code || db->pErr ) sqlite3ErrorFinish(db, err_code); } SQLITE_PRIVATE void sqlite3ErrorClear(sqlite3 *db){  assert( db!=0 );  db->errCode = SQLITE_OK;  if( db->pErr ) sqlite3ValueSetNull(db->pErr); } SQLITE_PRIVATE void sqlite3SystemError(sqlite3 *db, int rc){  if( rc==SQLITE_IOERR_NOMEM ) return;  rc &= 0xff;  if( rc==SQLITE_CANTOPEN || rc==SQLITE_IOERR ){  db->iSysErrno = sqlite3OsGetLastError(db->pVfs);  } } SQLITE_PRIVATE void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){  assert( db!=0 );  db->errCode = err_code;  sqlite3SystemError(db, err_code);  if( zFormat==0 ){  sqlite3Error(db, err_code);  }else if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){  char *z;  va_list ap;  va_start(ap, zFormat);  z = sqlite3VMPrintf(db, zFormat, ap);  va_end(ap);  sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC);  } } SQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){  char *zMsg;  va_list ap;  sqlite3 *db = pParse->db;  va_start(ap, zFormat);  zMsg = sqlite3VMPrintf(db, zFormat, ap);  va_end(ap);  if( db->suppressErr ){  sqlite3DbFree(db, zMsg);  }else{  pParse->nErr++;  sqlite3DbFree(db, pParse->zErrMsg);  pParse->zErrMsg = zMsg;  pParse->rc = SQLITE_ERROR;  pParse->pWith = 0;  } } SQLITE_PRIVATE int sqlite3ErrorToParser(sqlite3 *db, int errCode){  Parse *pParse;  if( db==0 || (pParse = db->pParse)==0 ) return errCode;  pParse->rc = errCode;  pParse->nErr++;  return errCode; } SQLITE_PRIVATE void sqlite3Dequote(char *z){  char quote;  int i, j;  if( z==0 ) return;  quote = z[0];  if( !sqlite3Isquote(quote) ) return;  if( quote=='[' ) quote = ']';  for(i=1, j=0;; i++){  assert( z[i] );  if( z[i]==quote ){  if( z[i+1]==quote ){  z[j++] = quote;  i++;  }else{  break;  }  }else{  z[j++] = z[i];  }  }  z[j] = 0; } SQLITE_PRIVATE void sqlite3DequoteExpr(Expr *p){  assert( !ExprHasProperty(p, EP_IntValue) );  assert( sqlite3Isquote(p->u.zToken[0]) );  p->flags |= p->u.zToken[0]=='"' ? EP_Quoted|EP_DblQuoted : EP_Quoted;  sqlite3Dequote(p->u.zToken); } SQLITE_PRIVATE void sqlite3DequoteToken(Token *p){  unsigned int i;  if( p->n<2 ) return;  if( !sqlite3Isquote(p->z[0]) ) return;  for(i=1; i<p->n-1; i++){  if( sqlite3Isquote(p->z[i]) ) return;  }  p->n -= 2;  p->z++; } SQLITE_PRIVATE void sqlite3TokenInit(Token *p, char *z){  p->z = z;  p->n = sqlite3Strlen30(z); }
#define UpperToLower sqlite3UpperToLower
SQLITE_API int sqlite3_stricmp(const char *zLeft, const char *zRight){  if( zLeft==0 ){  return zRight ? -1 : 0;  }else if( zRight==0 ){  return 1;  }  return sqlite3StrICmp(zLeft, zRight); } SQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){  unsigned char *a, *b;  int c, x;  a = (unsigned char *)zLeft;  b = (unsigned char *)zRight;  for(;;){  c = *a;  x = *b;  if( c==x ){  if( c==0 ) break;  }else{  c = (int)UpperToLower[c] - (int)UpperToLower[x];  if( c ) break;  }  a++;  b++;  }  return c; } SQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){  register unsigned char *a, *b;  if( zLeft==0 ){  return zRight ? -1 : 0;  }else if( zRight==0 ){  return 1;  }  a = (unsigned char *)zLeft;  b = (unsigned char *)zRight;  while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }  return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b]; } SQLITE_PRIVATE u8 sqlite3StrIHash(const char *z){  u8 h = 0;  if( z==0 ) return 0;  while( z[0] ){  h += UpperToLower[(unsigned char)z[0]];  z++;  }  return h; } static LONGDOUBLE_TYPE sqlite3Pow10(int E){
#if defined(_MSC_VER)
 static const LONGDOUBLE_TYPE x[] = {  1.0e+001L,  1.0e+002L,  1.0e+004L,  1.0e+008L,  1.0e+016L,  1.0e+032L,  1.0e+064L,  1.0e+128L,  1.0e+256L  };  LONGDOUBLE_TYPE r = 1.0;  int i;  assert( E>=0 && E<=307 );  for(i=0; E!=0; i++, E >>=1){  if( E & 1 ) r *= x[i];  }  return r;
#else
 LONGDOUBLE_TYPE x = 10.0;  LONGDOUBLE_TYPE r = 1.0;  while(1){  if( E & 1 ) r *= x;  E >>= 1;  if( E==0 ) break;  x *= x;  }  return r;
#endif
}
#if defined(_MSC_VER)
#pragma warning(disable : 4756)
#endif
SQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){
#ifndef SQLITE_OMIT_FLOATING_POINT
 int incr;  const char *zEnd;  int sign = 1;  i64 s = 0;  int d = 0;  int esign = 1;  int e = 0;  int eValid = 1;  double result;  int nDigit = 0;  int eType = 1;  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );  *pResult = 0.0;  if( length==0 ) return 0;  if( enc==SQLITE_UTF8 ){  incr = 1;  zEnd = z + length;  }else{  int i;  incr = 2;  length &= ~1;  assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );  testcase( enc==SQLITE_UTF16LE );  testcase( enc==SQLITE_UTF16BE );  for(i=3-enc; i<length && z[i]==0; i+=2){}  if( i<length ) eType = -100;  zEnd = &z[i^1];  z += (enc&1);  }  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;  if( z>=zEnd ) return 0;  if( *z=='-' ){  sign = -1;  z+=incr;  }else if( *z=='+' ){  z+=incr;  }  while( z<zEnd && sqlite3Isdigit(*z) ){  s = s*10 + (*z - '0');  z+=incr; nDigit++;  if( s>=((LARGEST_INT64-9)/10) ){  while( z<zEnd && sqlite3Isdigit(*z) ){ z+=incr; d++; }  }  }  if( z>=zEnd ) goto do_atof_calc;  if( *z=='.' ){  z+=incr;  eType++;  while( z<zEnd && sqlite3Isdigit(*z) ){  if( s<((LARGEST_INT64-9)/10) ){  s = s*10 + (*z - '0');  d--;  nDigit++;  }  z+=incr;  }  }  if( z>=zEnd ) goto do_atof_calc;  if( *z=='e' || *z=='E' ){  z+=incr;  eValid = 0;  eType++;  if( z>=zEnd ) goto do_atof_calc;  if( *z=='-' ){  esign = -1;  z+=incr;  }else if( *z=='+' ){  z+=incr;  }  while( z<zEnd && sqlite3Isdigit(*z) ){  e = e<10000 ? (e*10 + (*z - '0')) : 10000;  z+=incr;  eValid = 1;  }  }  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr; do_atof_calc:  e = (e*esign) + d;  if( e<0 ) {  esign = -1;  e *= -1;  } else {  esign = 1;  }  if( s==0 ) {  result = sign<0 ? -(double)0 : (double)0;  } else {  while( e>0 ){  if( esign>0 ){  if( s>=(LARGEST_INT64/10) ) break;  s *= 10;  }else{  if( s%10!=0 ) break;  s /= 10;  }  e--;  }  s = sign<0 ? -s : s;  if( e==0 ){  result = (double)s;  }else{  if( e>307 ){  if( e<342 ){  LONGDOUBLE_TYPE scale = sqlite3Pow10(e-308);  if( esign<0 ){  result = s / scale;  result /= 1.0e+308;  }else{  result = s * scale;  result *= 1.0e+308;  }  }else{ assert( e>=342 );  if( esign<0 ){  result = 0.0*s;  }else{
#ifdef INFINITY
 result = INFINITY*s;
#else
 result = 1e308*1e308*s;
#endif
 }  }  }else{  LONGDOUBLE_TYPE scale = sqlite3Pow10(e);  if( esign<0 ){  result = s / scale;  }else{  result = s * scale;  }  }  }  }  *pResult = result;  if( z==zEnd && nDigit>0 && eValid && eType>0 ){  return eType;  }else if( eType>=2 && (eType==3 || eValid) && nDigit>0 ){  return -1;  }else{  return 0;  }
#else
 return !sqlite3Atoi64(z, pResult, length, enc);
#endif
}
#if defined(_MSC_VER)
#pragma warning(default : 4756)
#endif
SQLITE_PRIVATE void sqlite3Int64ToText(i64 v, char *zOut){  int i;  u64 x;  char zTemp[22];  if( v<0 ){  x = (v==SMALLEST_INT64) ? ((u64)1)<<63 : (u64)-v;  }else{  x = v;  }  i = sizeof(zTemp)-2;  zTemp[sizeof(zTemp)-1] = 0;  do{  zTemp[i--] = (x%10) + '0';  x = x/10;  }while( x );  if( v<0 ) zTemp[i--] = '-';  memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i); } static int compare2pow63(const char *zNum, int incr){  int c = 0;  int i;  const char *pow63 = "922337203685477580";  for(i=0; c==0 && i<18; i++){  c = (zNum[i*incr]-pow63[i])*10;  }  if( c==0 ){  c = zNum[18*incr] - '8';  testcase( c==(-1) );  testcase( c==0 );  testcase( c==(+1) );  }  return c; } SQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){  int incr;  u64 u = 0;  int neg = 0;  int i;  int c = 0;  int nonNum = 0;  int rc;  const char *zStart;  const char *zEnd = zNum + length;  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );  if( enc==SQLITE_UTF8 ){  incr = 1;  }else{  incr = 2;  length &= ~1;  assert( SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );  for(i=3-enc; i<length && zNum[i]==0; i+=2){}  nonNum = i<length;  zEnd = &zNum[i^1];  zNum += (enc&1);  }  while( zNum<zEnd && sqlite3Isspace(*zNum) ) zNum+=incr;  if( zNum<zEnd ){  if( *zNum=='-' ){  neg = 1;  zNum+=incr;  }else if( *zNum=='+' ){  zNum+=incr;  }  }  zStart = zNum;  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; }  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){  u = u*10 + c - '0';  }  testcase( i==18*incr );  testcase( i==19*incr );  testcase( i==20*incr );  if( u>LARGEST_INT64 ){  *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;  }else if( neg ){  *pNum = -(i64)u;  }else{  *pNum = (i64)u;  }  rc = 0;  if( i==0 && zStart==zNum ){  rc = -1;  }else if( nonNum ){  rc = 1;  }else if( &zNum[i]<zEnd ){  int jj = i;  do{  if( !sqlite3Isspace(zNum[jj]) ){  rc = 1;  break;  }  jj += incr;  }while( &zNum[jj]<zEnd );  }  if( i<19*incr ){  assert( u<=LARGEST_INT64 );  return rc;  }else{  c = i>19*incr ? 1 : compare2pow63(zNum, incr);  if( c<0 ){  assert( u<=LARGEST_INT64 );  return rc;  }else{  *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;  if( c>0 ){  return 2;  }else{  assert( u-1==LARGEST_INT64 );  return neg ? rc : 3;  }  }  } } SQLITE_PRIVATE int sqlite3DecOrHexToI64(const char *z, i64 *pOut){
#ifndef SQLITE_OMIT_HEX_INTEGER
 if( z[0]=='0'   && (z[1]=='x' || z[1]=='X')  ){  u64 u = 0;  int i, k;  for(i=2; z[i]=='0'; i++){}  for(k=i; sqlite3Isxdigit(z[k]); k++){  u = u*16 + sqlite3HexToInt(z[k]);  }  memcpy(pOut, &u, 8);  return (z[k]==0 && k-i<=16) ? 0 : 2;  }else
#endif
 {  return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), SQLITE_UTF8);  } } SQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){  sqlite_int64 v = 0;  int i, c;  int neg = 0;  if( zNum[0]=='-' ){  neg = 1;  zNum++;  }else if( zNum[0]=='+' ){  zNum++;  }
#ifndef SQLITE_OMIT_HEX_INTEGER
 else if( zNum[0]=='0'  && (zNum[1]=='x' || zNum[1]=='X')  && sqlite3Isxdigit(zNum[2])  ){  u32 u = 0;  zNum += 2;  while( zNum[0]=='0' ) zNum++;  for(i=0; sqlite3Isxdigit(zNum[i]) && i<8; i++){  u = u*16 + sqlite3HexToInt(zNum[i]);  }  if( (u&0x80000000)==0 && sqlite3Isxdigit(zNum[i])==0 ){  memcpy(pValue, &u, 4);  return 1;  }else{  return 0;  }  }
#endif
 if( !sqlite3Isdigit(zNum[0]) ) return 0;  while( zNum[0]=='0' ) zNum++;  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){  v = v*10 + c;  }  testcase( i==10 );  if( i>10 ){  return 0;  }  testcase( v-neg==2147483647 );  if( v-neg>2147483647 ){  return 0;  }  if( neg ){  v = -v;  }  *pValue = (int)v;  return 1; } SQLITE_PRIVATE int sqlite3Atoi(const char *z){  int x = 0;  sqlite3GetInt32(z, &x);  return x; } SQLITE_PRIVATE int sqlite3GetUInt32(const char *z, u32 *pI){  u64 v = 0;  int i;  for(i=0; sqlite3Isdigit(z[i]); i++){  v = v*10 + z[i] - '0';  if( v>4294967296LL ){ *pI = 0; return 0; }  }  if( i==0 || z[i]!=0 ){ *pI = 0; return 0; }  *pI = (u32)v;  return 1; } static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){  int i, j, n;  u8 buf[10];  if( v & (((u64)0xff000000)<<32) ){  p[8] = (u8)v;  v >>= 8;  for(i=7; i>=0; i--){  p[i] = (u8)((v & 0x7f) | 0x80);  v >>= 7;  }  return 9;  }  n = 0;  do{  buf[n++] = (u8)((v & 0x7f) | 0x80);  v >>= 7;  }while( v!=0 );  buf[0] &= 0x7f;  assert( n<=9 );  for(i=0, j=n-1; j>=0; j--, i++){  p[i] = buf[j];  }  return n; } SQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){  if( v<=0x7f ){  p[0] = v&0x7f;  return 1;  }  if( v<=0x3fff ){  p[0] = ((v>>7)&0x7f)|0x80;  p[1] = v&0x7f;  return 2;  }  return putVarint64(p,v); }
#define SLOT_2_0  0x001fc07f
#define SLOT_4_2_0  0xf01fc07f
SQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){  u32 a,b,s;  if( ((signed char*)p)[0]>=0 ){  *v = *p;  return 1;  }  if( ((signed char*)p)[1]>=0 ){  *v = ((u32)(p[0]&0x7f)<<7) | p[1];  return 2;  }  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );  a = ((u32)p[0])<<14;  b = p[1];  p += 2;  a |= *p;  if (!(a&0x80))  {  a &= SLOT_2_0;  b &= 0x7f;  b = b<<7;  a |= b;  *v = a;  return 3;  }  a &= SLOT_2_0;  p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  b &= SLOT_2_0;  a = a<<7;  a |= b;  *v = a;  return 4;  }  b &= SLOT_2_0;  s = a;  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  b = b<<7;  a |= b;  s = s>>18;  *v = ((u64)s)<<32 | a;  return 5;  }  s = s<<7;  s |= b;  p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  a &= SLOT_2_0;  a = a<<7;  a |= b;  s = s>>18;  *v = ((u64)s)<<32 | a;  return 6;  }  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  a &= SLOT_4_2_0;  b &= SLOT_2_0;  b = b<<7;  a |= b;  s = s>>11;  *v = ((u64)s)<<32 | a;  return 7;  }  a &= SLOT_2_0;  p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  b &= SLOT_4_2_0;  a = a<<7;  a |= b;  s = s>>4;  *v = ((u64)s)<<32 | a;  return 8;  }  p++;  a = a<<15;  a |= *p;  b &= SLOT_2_0;  b = b<<8;  a |= b;  s = s<<4;  b = p[-4];  b &= 0x7f;  b = b>>3;  s |= b;  *v = ((u64)s)<<32 | a;  return 9; } SQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){  u32 a,b;  a = *p;
#ifndef getVarint32
 if (!(a&0x80))  {  *v = a;  return 1;  }
#endif
 p++;  b = *p;  if (!(b&0x80))  {  a &= 0x7f;  a = a<<7;  *v = a | b;  return 2;  }  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  a &= (0x7f<<14)|(0x7f);  b &= 0x7f;  b = b<<7;  *v = a | b;  return 3;  }
#if 1
 {  u64 v64;  u8 n;  n = sqlite3GetVarint(p-2, &v64);  assert( n>3 && n<=9 );  if( (v64 & SQLITE_MAX_U32)!=v64 ){  *v = 0xffffffff;  }else{  *v = (u32)v64;  }  return n;  }
#else
 p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  b &= (0x7f<<14)|(0x7f);  a &= (0x7f<<14)|(0x7f);  a = a<<7;  *v = a | b;  return 4;  }  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  a &= SLOT_4_2_0;  b &= SLOT_4_2_0;  b = b<<7;  *v = a | b;  return 5;  }  {  u64 v64;  u8 n;  p -= 4;  n = sqlite3GetVarint(p, &v64);  assert( n>5 && n<=9 );  *v = (u32)v64;  return n;  }
#endif
} SQLITE_PRIVATE int sqlite3VarintLen(u64 v){  int i;  for(i=1; (v >>= 7)!=0; i++){ assert( i<10 ); }  return i; } SQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p){
#if SQLITE_BYTEORDER==4321
 u32 x;  memcpy(&x,p,4);  return x;
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
 u32 x;  memcpy(&x,p,4);  return __builtin_bswap32(x);
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
 u32 x;  memcpy(&x,p,4);  return _byteswap_ulong(x);
#else
 testcase( p[0]&0x80 );  return ((unsigned)p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];
#endif
} SQLITE_PRIVATE void sqlite3Put4byte(unsigned char *p, u32 v){
#if SQLITE_BYTEORDER==4321
 memcpy(p,&v,4);
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
 u32 x = __builtin_bswap32(v);  memcpy(p,&x,4);
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
 u32 x = _byteswap_ulong(v);  memcpy(p,&x,4);
#else
 p[0] = (u8)(v>>24);  p[1] = (u8)(v>>16);  p[2] = (u8)(v>>8);  p[3] = (u8)v;
#endif
} SQLITE_PRIVATE u8 sqlite3HexToInt(int h){  assert( (h>='0' && h<='9') || (h>='a' && h<='f') || (h>='A' && h<='F') );
#ifdef SQLITE_ASCII
 h += 9*(1&(h>>6));
#endif
#ifdef SQLITE_EBCDIC
 h += 9*(1&~(h>>4));
#endif
 return (u8)(h & 0xf); }
#if !defined(SQLITE_OMIT_BLOB_LITERAL)
SQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){  char *zBlob;  int i;  zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);  n--;  if( zBlob ){  for(i=0; i<n; i+=2){  zBlob[i/2] = (sqlite3HexToInt(z[i])<<4) | sqlite3HexToInt(z[i+1]);  }  zBlob[i/2] = 0;  }  return zBlob; }
#endif
static void logBadConnection(const char *zType){  sqlite3_log(SQLITE_MISUSE,   "API call with %s database connection pointer",   zType  ); } SQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db){  u8 eOpenState;  if( db==0 ){  logBadConnection("NULL");  return 0;  }  eOpenState = db->eOpenState;  if( eOpenState!=SQLITE_STATE_OPEN ){  if( sqlite3SafetyCheckSickOrOk(db) ){  testcase( sqlite3GlobalConfig.xLog!=0 );  logBadConnection("unopened");  }  return 0;  }else{  return 1;  } } SQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db){  u8 eOpenState;  eOpenState = db->eOpenState;  if( eOpenState!=SQLITE_STATE_SICK &&  eOpenState!=SQLITE_STATE_OPEN &&  eOpenState!=SQLITE_STATE_BUSY ){  testcase( sqlite3GlobalConfig.xLog!=0 );  logBadConnection("invalid");  return 0;  }else{  return 1;  } } SQLITE_PRIVATE int sqlite3AddInt64(i64 *pA, i64 iB){
#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)
 return __builtin_add_overflow(*pA, iB, pA);
#else
 i64 iA = *pA;  testcase( iA==0 ); testcase( iA==1 );  testcase( iB==-1 ); testcase( iB==0 );  if( iB>=0 ){  testcase( iA>0 && LARGEST_INT64 - iA == iB );  testcase( iA>0 && LARGEST_INT64 - iA == iB - 1 );  if( iA>0 && LARGEST_INT64 - iA < iB ) return 1;  }else{  testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 1 );  testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 2 );  if( iA<0 && -(iA + LARGEST_INT64) > iB + 1 ) return 1;  }  *pA += iB;  return 0;
#endif
} SQLITE_PRIVATE int sqlite3SubInt64(i64 *pA, i64 iB){
#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)
 return __builtin_sub_overflow(*pA, iB, pA);
#else
 testcase( iB==SMALLEST_INT64+1 );  if( iB==SMALLEST_INT64 ){  testcase( (*pA)==(-1) ); testcase( (*pA)==0 );  if( (*pA)>=0 ) return 1;  *pA -= iB;  return 0;  }else{  return sqlite3AddInt64(pA, -iB);  }
#endif
} SQLITE_PRIVATE int sqlite3MulInt64(i64 *pA, i64 iB){
#if GCC_VERSION>=5004000 && !defined(__INTEL_COMPILER)
 return __builtin_mul_overflow(*pA, iB, pA);
#else
 i64 iA = *pA;  if( iB>0 ){  if( iA>LARGEST_INT64/iB ) return 1;  if( iA<SMALLEST_INT64/iB ) return 1;  }else if( iB<0 ){  if( iA>0 ){  if( iB<SMALLEST_INT64/iA ) return 1;  }else if( iA<0 ){  if( iB==SMALLEST_INT64 ) return 1;  if( iA==SMALLEST_INT64 ) return 1;  if( -iA>LARGEST_INT64/-iB ) return 1;  }  }  *pA = iA*iB;  return 0;
#endif
} SQLITE_PRIVATE int sqlite3AbsInt32(int x){  if( x>=0 ) return x;  if( x==(int)0x80000000 ) return 0x7fffffff;  return -x; }
#ifdef SQLITE_ENABLE_8_3_NAMES
SQLITE_PRIVATE void sqlite3FileSuffix3(const char *zBaseFilename, char *z){
#if SQLITE_ENABLE_8_3_NAMES<2
 if( sqlite3_uri_boolean(zBaseFilename, "8_3_names", 0) )
#endif
 {  int i, sz;  sz = sqlite3Strlen30(z);  for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}  if( z[i]=='.' && ALWAYS(sz>i+4) ) memmove(&z[i+1], &z[sz-3], 4);  } }
#endif
SQLITE_PRIVATE LogEst sqlite3LogEstAdd(LogEst a, LogEst b){  static const unsigned char x[] = {   10, 10,  9, 9,  8, 8,  7, 7, 7,  6, 6, 6,  5, 5, 5,  4, 4, 4, 4,  3, 3, 3, 3, 3, 3,  2, 2, 2, 2, 2, 2, 2,  };  if( a>=b ){  if( a>b+49 ) return a;  if( a>b+31 ) return a+1;  return a+x[a-b];  }else{  if( b>a+49 ) return b;  if( b>a+31 ) return b+1;  return b+x[b-a];  } } SQLITE_PRIVATE LogEst sqlite3LogEst(u64 x){  static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };  LogEst y = 40;  if( x<8 ){  if( x<2 ) return 0;  while( x<8 ){ y -= 10; x <<= 1; }  }else{
#if GCC_VERSION>=5004000
 int i = 60 - __builtin_clzll(x);  y += i*10;  x >>= i;
#else
 while( x>255 ){ y += 40; x >>= 4; }  while( x>15 ){ y += 10; x >>= 1; }
#endif
 }  return a[x&7] + y - 10; }
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE LogEst sqlite3LogEstFromDouble(double x){  u64 a;  LogEst e;  assert( sizeof(x)==8 && sizeof(a)==8 );  if( x<=1 ) return 0;  if( x<=2000000000 ) return sqlite3LogEst((u64)x);  memcpy(&a, &x, 8);  e = (a>>52) - 1022;  return e*10; }
#endif
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) ||  defined(SQLITE_ENABLE_STAT4) ||  defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)

SQLITE_PRIVATE u64 sqlite3LogEstToInt(LogEst x){  u64 n;  n = x%10;  x /= 10;  if( n>=5 ) n -= 2;  else if( n>=1 ) n -= 1;
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) ||  defined(SQLITE_EXPLAIN_ESTIMATED_ROWS)

 if( x>60 ) return (u64)LARGEST_INT64;
#else
 assert( x<=60 );
#endif
 return x>=3 ? (n+8)<<(x-3) : (n+8)>>(3-x); }
#endif
SQLITE_PRIVATE VList *sqlite3VListAdd(  sqlite3 *db,  VList *pIn,  const char *zName,  int nName,  int iVal ){  int nInt;  char *z;  int i;  nInt = nName/4 + 3;  assert( pIn==0 || pIn[0]>=3 );  if( pIn==0 || pIn[1]+nInt > pIn[0] ){  sqlite3_int64 nAlloc = (pIn ? 2*(sqlite3_int64)pIn[0] : 10) + nInt;  VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));  if( pOut==0 ) return pIn;  if( pIn==0 ) pOut[1] = 2;  pIn = pOut;  pIn[0] = nAlloc;  }  i = pIn[1];  pIn[i] = iVal;  pIn[i+1] = nInt;  z = (char*)&pIn[i+2];  pIn[1] = i+nInt;  assert( pIn[1]<=pIn[0] );  memcpy(z, zName, nName);  z[nName] = 0;  return pIn; } SQLITE_PRIVATE const char *sqlite3VListNumToName(VList *pIn, int iVal){  int i, mx;  if( pIn==0 ) return 0;  mx = pIn[1];  i = 2;  do{  if( pIn[i]==iVal ) return (char*)&pIn[i+2];  i += pIn[i+1];  }while( i<mx );  return 0; } SQLITE_PRIVATE int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){  int i, mx;  if( pIn==0 ) return 0;  mx = pIn[1];  i = 2;  do{  const char *z = (const char*)&pIn[i+2];  if( strncmp(z,zName,nName)==0 && z[nName]==0 ) return pIn[i];  i += pIn[i+1];  }while( i<mx );  return 0; } SQLITE_PRIVATE void sqlite3HashInit(Hash *pNew){  assert( pNew!=0 );  pNew->first = 0;  pNew->count = 0;  pNew->htsize = 0;  pNew->ht = 0; } SQLITE_PRIVATE void sqlite3HashClear(Hash *pH){  HashElem *elem;  assert( pH!=0 );  elem = pH->first;  pH->first = 0;  sqlite3_free(pH->ht);  pH->ht = 0;  pH->htsize = 0;  while( elem ){  HashElem *next_elem = elem->next;  sqlite3_free(elem);  elem = next_elem;  }  pH->count = 0; } static unsigned int strHash(const char *z){  unsigned int h = 0;  unsigned char c;  while( (c = (unsigned char)*z++)!=0 ){  h += sqlite3UpperToLower[c];  h *= 0x9e3779b1;  }  return h; } static void insertElement(  Hash *pH,  struct _ht *pEntry,  HashElem *pNew ){  HashElem *pHead;  if( pEntry ){  pHead = pEntry->count ? pEntry->chain : 0;  pEntry->count++;  pEntry->chain = pNew;  }else{  pHead = 0;  }  if( pHead ){  pNew->next = pHead;  pNew->prev = pHead->prev;  if( pHead->prev ){ pHead->prev->next = pNew; }  else  { pH->first = pNew; }  pHead->prev = pNew;  }else{  pNew->next = pH->first;  if( pH->first ){ pH->first->prev = pNew; }  pNew->prev = 0;  pH->first = pNew;  } } static int rehash(Hash *pH, unsigned int new_size){  struct _ht *new_ht;  HashElem *elem, *next_elem;
#if SQLITE_MALLOC_SOFT_LIMIT>0
 if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){  new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht);  }  if( new_size==pH->htsize ) return 0;
#endif
 sqlite3BeginBenignMalloc();  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );  sqlite3EndBenignMalloc();  if( new_ht==0 ) return 0;  sqlite3_free(pH->ht);  pH->ht = new_ht;  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);  memset(new_ht, 0, new_size*sizeof(struct _ht));  for(elem=pH->first, pH->first=0; elem; elem = next_elem){  unsigned int h = strHash(elem->pKey) % new_size;  next_elem = elem->next;  insertElement(pH, &new_ht[h], elem);  }  return 1; } static HashElem *findElementWithHash(  const Hash *pH,  const char *pKey,  unsigned int *pHash ){  HashElem *elem;  unsigned int count;  unsigned int h;  static HashElem nullElement = { 0, 0, 0, 0 };  if( pH->ht ){  struct _ht *pEntry;  h = strHash(pKey) % pH->htsize;  pEntry = &pH->ht[h];  elem = pEntry->chain;  count = pEntry->count;  }else{  h = 0;  elem = pH->first;  count = pH->count;  }  if( pHash ) *pHash = h;  while( count-- ){  assert( elem!=0 );  if( sqlite3StrICmp(elem->pKey,pKey)==0 ){  return elem;  }  elem = elem->next;  }  return &nullElement; } static void removeElementGivenHash(  Hash *pH,  HashElem* elem,  unsigned int h ){  struct _ht *pEntry;  if( elem->prev ){  elem->prev->next = elem->next;  }else{  pH->first = elem->next;  }  if( elem->next ){  elem->next->prev = elem->prev;  }  if( pH->ht ){  pEntry = &pH->ht[h];  if( pEntry->chain==elem ){  pEntry->chain = elem->next;  }  assert( pEntry->count>0 );  pEntry->count--;  }  sqlite3_free( elem );  pH->count--;  if( pH->count==0 ){  assert( pH->first==0 );  assert( pH->count==0 );  sqlite3HashClear(pH);  } } SQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey){  assert( pH!=0 );  assert( pKey!=0 );  return findElementWithHash(pH, pKey, 0)->data; } SQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){  unsigned int h;  HashElem *elem;  HashElem *new_elem;  assert( pH!=0 );  assert( pKey!=0 );  elem = findElementWithHash(pH,pKey,&h);  if( elem->data ){  void *old_data = elem->data;  if( data==0 ){  removeElementGivenHash(pH,elem,h);  }else{  elem->data = data;  elem->pKey = pKey;  }  return old_data;  }  if( data==0 ) return 0;  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );  if( new_elem==0 ) return data;  new_elem->pKey = pKey;  new_elem->data = data;  pH->count++;  if( pH->count>=10 && pH->count > 2*pH->htsize ){  if( rehash(pH, pH->count*2) ){  assert( pH->htsize>0 );  h = strHash(pKey) % pH->htsize;  }  }  insertElement(pH, pH->ht ? &pH->ht[h] : 0, new_elem);  return 0; }
#if !defined(SQLITE_OMIT_EXPLAIN)  || defined(VDBE_PROFILE)  || defined(SQLITE_DEBUG)

#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS) || defined(SQLITE_DEBUG)
# define OpHelp(X) "\0" X
#else
# define OpHelp(X)
#endif
SQLITE_PRIVATE const char *sqlite3OpcodeName(int i){  static const char *const azName[] = {  "Savepoint" OpHelp(""),  "AutoCommit"  OpHelp(""),  "Transaction" OpHelp(""),  "SorterNext"  OpHelp(""),  "Prev"  OpHelp(""),  "Next"  OpHelp(""),  "Checkpoint"  OpHelp(""),  "JournalMode" OpHelp(""),  "Vacuum"  OpHelp(""),  "VFilter" OpHelp("iplan=r[P3] zplan='P4'"),  "VUpdate" OpHelp("data=r[P3@P2]"),  "Goto"  OpHelp(""),  "Gosub" OpHelp(""),  "InitCoroutine" OpHelp(""),  "Yield" OpHelp(""),  "MustBeInt" OpHelp(""),  "Jump"  OpHelp(""),  "Once"  OpHelp(""),  "If"  OpHelp(""),  "Not" OpHelp("r[P2]= !r[P1]"),  "IfNot" OpHelp(""),  "IsNullOrType"  OpHelp("if typeof(r[P1]) IN (P3,5) goto P2"),  "IfNullRow" OpHelp("if P1.nullRow then r[P3]=NULL, goto P2"),  "SeekLT"  OpHelp("key=r[P3@P4]"),  "SeekLE"  OpHelp("key=r[P3@P4]"),  "SeekGE"  OpHelp("key=r[P3@P4]"),  "SeekGT"  OpHelp("key=r[P3@P4]"),  "IfNotOpen" OpHelp("if( !csr[P1] ) goto P2"),  "IfNoHope"  OpHelp("key=r[P3@P4]"),  "NoConflict"  OpHelp("key=r[P3@P4]"),  "NotFound"  OpHelp("key=r[P3@P4]"),  "Found" OpHelp("key=r[P3@P4]"),  "SeekRowid" OpHelp("intkey=r[P3]"),  "NotExists" OpHelp("intkey=r[P3]"),  "Last"  OpHelp(""),  "IfSmaller" OpHelp(""),  "SorterSort"  OpHelp(""),  "Sort"  OpHelp(""),  "Rewind"  OpHelp(""),  "IdxLE" OpHelp("key=r[P3@P4]"),  "IdxGT" OpHelp("key=r[P3@P4]"),  "IdxLT" OpHelp("key=r[P3@P4]"),  "IdxGE" OpHelp("key=r[P3@P4]"),  "Or"  OpHelp("r[P3]=(r[P1] || r[P2])"),  "And" OpHelp("r[P3]=(r[P1] && r[P2])"),  "RowSetRead"  OpHelp("r[P3]=rowset(P1)"),  "RowSetTest"  OpHelp("if r[P3] in rowset(P1) goto P2"),  "Program" OpHelp(""),  "FkIfZero"  OpHelp("if fkctr[P1]==0 goto P2"),  "IfPos" OpHelp("if r[P1]>0 then r[P1]-=P3, goto P2"),  "IsNull"  OpHelp("if r[P1]==NULL goto P2"),  "NotNull" OpHelp("if r[P1]!=NULL goto P2"),  "Ne"  OpHelp("IF r[P3]!=r[P1]"),  "Eq"  OpHelp("IF r[P3]==r[P1]"),  "Gt"  OpHelp("IF r[P3]>r[P1]"),  "Le"  OpHelp("IF r[P3]<=r[P1]"),  "Lt"  OpHelp("IF r[P3]<r[P1]"),  "Ge"  OpHelp("IF r[P3]>=r[P1]"),  "ElseEq"  OpHelp(""),  "IfNotZero" OpHelp("if r[P1]!=0 then r[P1]--, goto P2"),  "DecrJumpZero"  OpHelp("if (--r[P1])==0 goto P2"),  "IncrVacuum"  OpHelp(""),  "VNext" OpHelp(""),  "Init"  OpHelp("Start at P2"),  "PureFunc"  OpHelp("r[P3]=func(r[P2@NP])"),  "Function"  OpHelp("r[P3]=func(r[P2@NP])"),  "Return"  OpHelp(""),  "EndCoroutine"  OpHelp(""),  "HaltIfNull"  OpHelp("if r[P3]=null halt"),  "Halt"  OpHelp(""),  "Integer" OpHelp("r[P2]=P1"),  "Int64" OpHelp("r[P2]=P4"),  "String"  OpHelp("r[P2]='P4' (len=P1)"),  "Null"  OpHelp("r[P2..P3]=NULL"),  "SoftNull"  OpHelp("r[P1]=NULL"),  "Blob"  OpHelp("r[P2]=P4 (len=P1)"),  "Variable"  OpHelp("r[P2]=parameter(P1,P4)"),  "Move"  OpHelp("r[P2@P3]=r[P1@P3]"),  "Copy"  OpHelp("r[P2@P3+1]=r[P1@P3+1]"),  "SCopy" OpHelp("r[P2]=r[P1]"),  "IntCopy" OpHelp("r[P2]=r[P1]"),  "ChngCntRow"  OpHelp("output=r[P1]"),  "ResultRow" OpHelp("output=r[P1@P2]"),  "CollSeq" OpHelp(""),  "AddImm"  OpHelp("r[P1]=r[P1]+P2"),  "RealAffinity"  OpHelp(""),  "Cast"  OpHelp("affinity(r[P1])"),  "Permutation" OpHelp(""),  "Compare" OpHelp("r[P1@P3] <-> r[P2@P3]"),  "IsTrue"  OpHelp("r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4"),  "ZeroOrNull"  OpHelp("r[P2] = 0 OR NULL"),  "Offset"  OpHelp("r[P3] = sqlite_offset(P1)"),  "Column"  OpHelp("r[P3]=PX"),  "TypeCheck" OpHelp("typecheck(r[P1@P2])"),  "Affinity"  OpHelp("affinity(r[P1@P2])"),  "MakeRecord"  OpHelp("r[P3]=mkrec(r[P1@P2])"),  "Count" OpHelp("r[P2]=count()"),  "ReadCookie"  OpHelp(""),  "SetCookie" OpHelp(""),  "ReopenIdx" OpHelp("root=P2 iDb=P3"),  "OpenRead"  OpHelp("root=P2 iDb=P3"),  "OpenWrite" OpHelp("root=P2 iDb=P3"),  "BitAnd"  OpHelp("r[P3]=r[P1]&r[P2]"),  "BitOr" OpHelp("r[P3]=r[P1]|r[P2]"),  "ShiftLeft" OpHelp("r[P3]=r[P2]<<r[P1]"),  "ShiftRight"  OpHelp("r[P3]=r[P2]>>r[P1]"),  "Add" OpHelp("r[P3]=r[P1]+r[P2]"),  "Subtract"  OpHelp("r[P3]=r[P2]-r[P1]"),  "Multiply"  OpHelp("r[P3]=r[P1]*r[P2]"),  "Divide"  OpHelp("r[P3]=r[P2]/r[P1]"),  "Remainder" OpHelp("r[P3]=r[P2]%r[P1]"),  "Concat"  OpHelp("r[P3]=r[P2]+r[P1]"),  "OpenDup" OpHelp(""),  "BitNot"  OpHelp("r[P2]= ~r[P1]"),  "OpenAutoindex" OpHelp("nColumn=P2"),  "OpenEphemeral" OpHelp("nColumn=P2"),  "String8" OpHelp("r[P2]='P4'"),  "SorterOpen"  OpHelp(""),  "SequenceTest"  OpHelp("if( cursor[P1].ctr++ ) pc = P2"),  "OpenPseudo"  OpHelp("P3 columns in r[P2]"),  "Close" OpHelp(""),  "ColumnsUsed" OpHelp(""),  "SeekScan"  OpHelp("Scan-ahead up to P1 rows"),  "SeekHit" OpHelp("set P2<=seekHit<=P3"),  "Sequence"  OpHelp("r[P2]=cursor[P1].ctr++"),  "NewRowid"  OpHelp("r[P2]=rowid"),  "Insert"  OpHelp("intkey=r[P3] data=r[P2]"),  "RowCell" OpHelp(""),  "Delete"  OpHelp(""),  "ResetCount"  OpHelp(""),  "SorterCompare" OpHelp("if key(P1)!=trim(r[P3],P4) goto P2"),  "SorterData"  OpHelp("r[P2]=data"),  "RowData" OpHelp("r[P2]=data"),  "Rowid" OpHelp("r[P2]=rowid"),  "NullRow" OpHelp(""),  "SeekEnd" OpHelp(""),  "IdxInsert" OpHelp("key=r[P2]"),  "SorterInsert"  OpHelp("key=r[P2]"),  "IdxDelete" OpHelp("key=r[P2@P3]"),  "DeferredSeek"  OpHelp("Move P3 to P1.rowid if needed"),  "IdxRowid"  OpHelp("r[P2]=rowid"),  "FinishSeek"  OpHelp(""),  "Destroy" OpHelp(""),  "Clear" OpHelp(""),  "ResetSorter" OpHelp(""),  "CreateBtree" OpHelp("r[P2]=root iDb=P1 flags=P3"),  "SqlExec" OpHelp(""),  "ParseSchema" OpHelp(""),  "LoadAnalysis"  OpHelp(""),  "DropTable" OpHelp(""),  "DropIndex" OpHelp(""),  "DropTrigger" OpHelp(""),  "Real"  OpHelp("r[P2]=P4"),  "IntegrityCk" OpHelp(""),  "RowSetAdd" OpHelp("rowset(P1)=r[P2]"),  "Param" OpHelp(""),  "FkCounter" OpHelp("fkctr[P1]+=P2"),  "MemMax"  OpHelp("r[P1]=max(r[P1],r[P2])"),  "OffsetLimit" OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),  "AggInverse"  OpHelp("accum=r[P3] inverse(r[P2@P5])"),  "AggStep" OpHelp("accum=r[P3] step(r[P2@P5])"),  "AggStep1"  OpHelp("accum=r[P3] step(r[P2@P5])"),  "AggValue"  OpHelp("r[P3]=value N=P2"),  "AggFinal"  OpHelp("accum=r[P1] N=P2"),  "Expire"  OpHelp(""),  "CursorLock"  OpHelp(""),  "CursorUnlock"  OpHelp(""),  "TableLock" OpHelp("iDb=P1 root=P2 write=P3"),  "VBegin"  OpHelp(""),  "VCreate" OpHelp(""),  "VDestroy"  OpHelp(""),  "VOpen" OpHelp(""),  "VColumn" OpHelp("r[P3]=vcolumn(P2)"),  "VRename" OpHelp(""),  "Pagecount" OpHelp(""),  "MaxPgcnt"  OpHelp(""),  "Trace" OpHelp(""),  "CursorHint"  OpHelp(""),  "ReleaseReg"  OpHelp("release r[P1@P2] mask P3"),  "Noop"  OpHelp(""),  "Explain" OpHelp(""),  "Abortable" OpHelp(""),  };  return azName[i]; }
#endif
#if SQLITE_OS_UNIX
#if !defined(SQLITE_ENABLE_LOCKING_STYLE)
# if defined(__APPLE__)
# define SQLITE_ENABLE_LOCKING_STYLE 1
# else
# define SQLITE_ENABLE_LOCKING_STYLE 0
# endif
#endif
#if defined(__APPLE__)
# define HAVE_PREAD 1
# define HAVE_PWRITE 1
#endif
#if defined(HAVE_PREAD64) && defined(HAVE_PWRITE64)
# undef USE_PREAD
# define USE_PREAD64 1
#elif defined(HAVE_PREAD) && defined(HAVE_PWRITE)
# undef USE_PREAD64
# define USE_PREAD 1
#endif
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/time.h>
#include <errno.h>
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
# include <sys/mman.h>
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
# include <sys/file.h>
# include <sys/param.h>
#endif
#ifndef HAVE_GETHOSTUUID
# define HAVE_GETHOSTUUID 0
# if defined(__APPLE__) && ((__MAC_OS_X_VERSION_MIN_REQUIRED > 1050) ||  (__IPHONE_OS_VERSION_MIN_REQUIRED > 2000))

# if (!defined(TARGET_OS_EMBEDDED) || (TARGET_OS_EMBEDDED==0))  && (!defined(TARGET_IPHONE_SIMULATOR) || (TARGET_IPHONE_SIMULATOR==0)) && (!defined(TARGET_OS_MACCATALYST) || (TARGET_OS_MACCATALYST==0))

# undef HAVE_GETHOSTUUID
# define HAVE_GETHOSTUUID 1
# else
# warning "gethostuuid() is disabled."
# endif
# endif
#endif
#if OS_VXWORKS
# include <semaphore.h>
# include <limits.h>
#endif
#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
# include <sys/mount.h>
#endif
#ifdef HAVE_UTIME
# include <utime.h>
#endif
#define SQLITE_FSFLAGS_IS_MSDOS  0x1
#if SQLITE_THREADSAFE
#endif
#ifndef SQLITE_DEFAULT_FILE_PERMISSIONS
# define SQLITE_DEFAULT_FILE_PERMISSIONS 0644
#endif
#ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS
# define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755
#endif
#define MAX_PATHNAME 512
#define SQLITE_MAX_SYMLINKS 100
#define osGetpid(X) (pid_t)getpid()
#define IS_LOCK_ERROR(x) ((x != SQLITE_OK) && (x != SQLITE_BUSY))
typedef struct unixShm unixShm; typedef struct unixShmNode unixShmNode; typedef struct unixInodeInfo unixInodeInfo; typedef struct UnixUnusedFd UnixUnusedFd; struct UnixUnusedFd {  int fd;  int flags;  UnixUnusedFd *pNext; }; typedef struct unixFile unixFile; struct unixFile {  sqlite3_io_methods const *pMethod;  sqlite3_vfs *pVfs;  unixInodeInfo *pInode;  int h;  unsigned char eFileLock;  unsigned short int ctrlFlags;  int lastErrno;  void *lockingContext;  UnixUnusedFd *pPreallocatedUnused;  const char *zPath;  unixShm *pShm;  int szChunk;
#if SQLITE_MAX_MMAP_SIZE>0
 int nFetchOut;  sqlite3_int64 mmapSize;  sqlite3_int64 mmapSizeActual;  sqlite3_int64 mmapSizeMax;  void *pMapRegion;
#endif
 int sectorSize;  int deviceCharacteristics;
#if SQLITE_ENABLE_LOCKING_STYLE
 int openFlags;
#endif
#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
 unsigned fsFlags;
#endif
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 unsigned iBusyTimeout;
#endif
#if OS_VXWORKS
 struct vxworksFileId *pId;
#endif
#ifdef SQLITE_DEBUG
 unsigned char transCntrChng;  unsigned char dbUpdate;  unsigned char inNormalWrite;
#endif
#ifdef SQLITE_TEST
 char aPadding[32];
#endif
}; static pid_t randomnessPid = 0;
#define UNIXFILE_EXCL 0x01
#define UNIXFILE_RDONLY 0x02
#define UNIXFILE_PERSIST_WAL 0x04
#ifndef SQLITE_DISABLE_DIRSYNC
# define UNIXFILE_DIRSYNC 0x08
#else
# define UNIXFILE_DIRSYNC 0x00
#endif
#define UNIXFILE_PSOW 0x10
#define UNIXFILE_DELETE 0x20
#define UNIXFILE_URI  0x40
#define UNIXFILE_NOLOCK 0x80
#ifndef O_LARGEFILE
# define O_LARGEFILE 0
#endif
#ifdef SQLITE_DISABLE_LFS
# undef O_LARGEFILE
# define O_LARGEFILE 0
#endif
#ifndef O_NOFOLLOW
# define O_NOFOLLOW 0
#endif
#ifndef O_BINARY
# define O_BINARY 0
#endif
#if SQLITE_THREADSAFE
#define threadid pthread_self()
#else
#define threadid 0
#endif
#if !defined(HAVE_MREMAP)
# if defined(__linux__) && defined(_GNU_SOURCE)
# define HAVE_MREMAP 1
# else
# define HAVE_MREMAP 0
# endif
#endif
#ifdef __ANDROID__
# define lseek lseek64
#endif
#ifdef __linux__
#define F2FS_IOCTL_MAGIC 0xf5
#define F2FS_IOC_START_ATOMIC_WRITE  _IO(F2FS_IOCTL_MAGIC, 1)
#define F2FS_IOC_COMMIT_ATOMIC_WRITE _IO(F2FS_IOCTL_MAGIC, 2)
#define F2FS_IOC_START_VOLATILE_WRITE  _IO(F2FS_IOCTL_MAGIC, 3)
#define F2FS_IOC_ABORT_VOLATILE_WRITE  _IO(F2FS_IOCTL_MAGIC, 5)
#define F2FS_IOC_GET_FEATURES  _IOR(F2FS_IOCTL_MAGIC, 12, u32)
#define F2FS_FEATURE_ATOMIC_WRITE 0x0004
#endif
static int posixOpen(const char *zFile, int flags, int mode){  return open(zFile, flags, mode); } static int openDirectory(const char*, int*); static int unixGetpagesize(void); static struct unix_syscall {  const char *zName;  sqlite3_syscall_ptr pCurrent;  sqlite3_syscall_ptr pDefault; } aSyscall[] = {  { "open", (sqlite3_syscall_ptr)posixOpen, 0 },
#define osOpen ((int(*)(const char*,int,int))aSyscall[0].pCurrent)
 { "close", (sqlite3_syscall_ptr)close, 0 },
#define osClose  ((int(*)(int))aSyscall[1].pCurrent)
 { "access", (sqlite3_syscall_ptr)access, 0 },
#define osAccess ((int(*)(const char*,int))aSyscall[2].pCurrent)
 { "getcwd", (sqlite3_syscall_ptr)getcwd, 0 },
#define osGetcwd ((char*(*)(char*,size_t))aSyscall[3].pCurrent)
 { "stat", (sqlite3_syscall_ptr)stat, 0 },
#define osStat ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)
#ifdef __DJGPP__
 { "fstat", 0, 0 },
#define osFstat(a,b,c) 0
#else
 { "fstat", (sqlite3_syscall_ptr)fstat, 0 },
#define osFstat  ((int(*)(int,struct stat*))aSyscall[5].pCurrent)
#endif
 { "ftruncate", (sqlite3_syscall_ptr)ftruncate, 0 },
#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent)
 { "fcntl", (sqlite3_syscall_ptr)fcntl, 0 },
#define osFcntl  ((int(*)(int,int,...))aSyscall[7].pCurrent)
 { "read", (sqlite3_syscall_ptr)read, 0 },
#define osRead ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)
#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
 { "pread", (sqlite3_syscall_ptr)pread, 0 },
#else
 { "pread", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osPread  ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)
#if defined(USE_PREAD64)
 { "pread64", (sqlite3_syscall_ptr)pread64, 0 },
#else
 { "pread64", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osPread64 ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent)
 { "write", (sqlite3_syscall_ptr)write, 0 },
#define osWrite  ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)
#if defined(USE_PREAD) || SQLITE_ENABLE_LOCKING_STYLE
 { "pwrite", (sqlite3_syscall_ptr)pwrite, 0 },
#else
 { "pwrite", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osPwrite ((ssize_t(*)(int,const void*,size_t,off_t)) aSyscall[12].pCurrent)

#if defined(USE_PREAD64)
 { "pwrite64", (sqlite3_syscall_ptr)pwrite64, 0 },
#else
 { "pwrite64", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osPwrite64 ((ssize_t(*)(int,const void*,size_t,off64_t)) aSyscall[13].pCurrent)

 { "fchmod", (sqlite3_syscall_ptr)fchmod, 0 },
#define osFchmod ((int(*)(int,mode_t))aSyscall[14].pCurrent)
#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
 { "fallocate", (sqlite3_syscall_ptr)posix_fallocate, 0 },
#else
 { "fallocate", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osFallocate ((int(*)(int,off_t,off_t))aSyscall[15].pCurrent)
 { "unlink", (sqlite3_syscall_ptr)unlink, 0 },
#define osUnlink ((int(*)(const char*))aSyscall[16].pCurrent)
 { "openDirectory", (sqlite3_syscall_ptr)openDirectory, 0 },
#define osOpenDirectory ((int(*)(const char*,int*))aSyscall[17].pCurrent)
 { "mkdir", (sqlite3_syscall_ptr)mkdir, 0 },
#define osMkdir  ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)
 { "rmdir", (sqlite3_syscall_ptr)rmdir, 0 },
#define osRmdir  ((int(*)(const char*))aSyscall[19].pCurrent)
#if defined(HAVE_FCHOWN)
 { "fchown", (sqlite3_syscall_ptr)fchown, 0 },
#else
 { "fchown", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osFchown ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)
#if defined(HAVE_FCHOWN)
 { "geteuid", (sqlite3_syscall_ptr)geteuid, 0 },
#else
 { "geteuid", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osGeteuid  ((uid_t(*)(void))aSyscall[21].pCurrent)
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
 { "mmap", (sqlite3_syscall_ptr)mmap, 0 },
#else
 { "mmap", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osMmap ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
 { "munmap", (sqlite3_syscall_ptr)munmap, 0 },
#else
 { "munmap", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osMunmap ((int(*)(void*,size_t))aSyscall[23].pCurrent)
#if HAVE_MREMAP && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
 { "mremap", (sqlite3_syscall_ptr)mremap, 0 },
#else
 { "mremap", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osMremap ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
 { "getpagesize", (sqlite3_syscall_ptr)unixGetpagesize, 0 },
#else
 { "getpagesize", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osGetpagesize ((int(*)(void))aSyscall[25].pCurrent)
#if defined(HAVE_READLINK)
 { "readlink", (sqlite3_syscall_ptr)readlink, 0 },
#else
 { "readlink", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)
#if defined(HAVE_LSTAT)
 { "lstat", (sqlite3_syscall_ptr)lstat, 0 },
#else
 { "lstat", (sqlite3_syscall_ptr)0, 0 },
#endif
#define osLstat ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)
#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
# ifdef __ANDROID__
 { "ioctl", (sqlite3_syscall_ptr)(int(*)(int, int, ...))ioctl, 0 },
#define osIoctl ((int(*)(int,int,...))aSyscall[28].pCurrent)
# else
 { "ioctl", (sqlite3_syscall_ptr)ioctl, 0 },
#define osIoctl ((int(*)(int,unsigned long,...))aSyscall[28].pCurrent)
# endif
#else
 { "ioctl", (sqlite3_syscall_ptr)0, 0 },
#endif
}; static int robustFchown(int fd, uid_t uid, gid_t gid){
#if defined(HAVE_FCHOWN)
 return osGeteuid() ? 0 : osFchown(fd,uid,gid);
#else
 return 0;
#endif
} static int unixSetSystemCall(  sqlite3_vfs *pNotUsed,  const char *zName,  sqlite3_syscall_ptr pNewFunc ){  unsigned int i;  int rc = SQLITE_NOTFOUND;  UNUSED_PARAMETER(pNotUsed);  if( zName==0 ){  rc = SQLITE_OK;  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){  if( aSyscall[i].pDefault ){  aSyscall[i].pCurrent = aSyscall[i].pDefault;  }  }  }else{  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){  if( strcmp(zName, aSyscall[i].zName)==0 ){  if( aSyscall[i].pDefault==0 ){  aSyscall[i].pDefault = aSyscall[i].pCurrent;  }  rc = SQLITE_OK;  if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;  aSyscall[i].pCurrent = pNewFunc;  break;  }  }  }  return rc; } static sqlite3_syscall_ptr unixGetSystemCall(  sqlite3_vfs *pNotUsed,  const char *zName ){  unsigned int i;  UNUSED_PARAMETER(pNotUsed);  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){  if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;  }  return 0; } static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){  int i = -1;  UNUSED_PARAMETER(p);  if( zName ){  for(i=0; i<ArraySize(aSyscall)-1; i++){  if( strcmp(zName, aSyscall[i].zName)==0 ) break;  }  }  for(i++; i<ArraySize(aSyscall); i++){  if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;  }  return 0; }
#ifndef SQLITE_MINIMUM_FILE_DESCRIPTOR
# define SQLITE_MINIMUM_FILE_DESCRIPTOR 3
#endif
static int robust_open(const char *z, int f, mode_t m){  int fd;  mode_t m2 = m ? m : SQLITE_DEFAULT_FILE_PERMISSIONS;  while(1){
#if defined(O_CLOEXEC)
 fd = osOpen(z,f|O_CLOEXEC,m2);
#else
 fd = osOpen(z,f,m2);
#endif
 if( fd<0 ){  if( errno==EINTR ) continue;  break;  }  if( fd>=SQLITE_MINIMUM_FILE_DESCRIPTOR ) break;  osClose(fd);  sqlite3_log(SQLITE_WARNING,  "attempt to open \"%s\" as file descriptor %d", z, fd);  fd = -1;  if( osOpen("/dev/null", O_RDONLY, m)<0 ) break;  }  if( fd>=0 ){  if( m!=0 ){  struct stat statbuf;  if( osFstat(fd, &statbuf)==0   && statbuf.st_size==0   && (statbuf.st_mode&0777)!=m  ){  osFchmod(fd, m);  }  }
#if defined(FD_CLOEXEC) && (!defined(O_CLOEXEC) || O_CLOEXEC==0)
 osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);
#endif
 }  return fd; } static sqlite3_mutex *unixBigLock = 0; static void unixEnterMutex(void){  assert( sqlite3_mutex_notheld(unixBigLock) );  sqlite3_mutex_enter(unixBigLock); } static void unixLeaveMutex(void){  assert( sqlite3_mutex_held(unixBigLock) );  sqlite3_mutex_leave(unixBigLock); }
#ifdef SQLITE_DEBUG
static int unixMutexHeld(void) {  return sqlite3_mutex_held(unixBigLock); }
#endif
#ifdef SQLITE_HAVE_OS_TRACE
static const char *azFileLock(int eFileLock){  switch( eFileLock ){  case NO_LOCK: return "NONE";  case SHARED_LOCK: return "SHARED";  case RESERVED_LOCK: return "RESERVED";  case PENDING_LOCK: return "PENDING";  case EXCLUSIVE_LOCK: return "EXCLUSIVE";  }  return "ERROR"; }
#endif
#ifdef SQLITE_LOCK_TRACE
static int lockTrace(int fd, int op, struct flock *p){  char *zOpName, *zType;  int s;  int savedErrno;  if( op==F_GETLK ){  zOpName = "GETLK";  }else if( op==F_SETLK ){  zOpName = "SETLK";  }else{  s = osFcntl(fd, op, p);  sqlite3DebugPrintf("fcntl unknown %d %d %d\n", fd, op, s);  return s;  }  if( p->l_type==F_RDLCK ){  zType = "RDLCK";  }else if( p->l_type==F_WRLCK ){  zType = "WRLCK";  }else if( p->l_type==F_UNLCK ){  zType = "UNLCK";  }else{  assert( 0 );  }  assert( p->l_whence==SEEK_SET );  s = osFcntl(fd, op, p);  savedErrno = errno;  sqlite3DebugPrintf("fcntl %d %d %s %s %d %d %d %d\n",   threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,   (int)p->l_pid, s);  if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){  struct flock l2;  l2 = *p;  osFcntl(fd, F_GETLK, &l2);  if( l2.l_type==F_RDLCK ){  zType = "RDLCK";  }else if( l2.l_type==F_WRLCK ){  zType = "WRLCK";  }else if( l2.l_type==F_UNLCK ){  zType = "UNLCK";  }else{  assert( 0 );  }  sqlite3DebugPrintf("fcntl-failure-reason: %s %d %d %d\n",   zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);  }  errno = savedErrno;  return s; }
#undef osFcntl
#define osFcntl lockTrace
#endif
static int robust_ftruncate(int h, sqlite3_int64 sz){  int rc;
#ifdef __ANDROID__
 if( sz>(sqlite3_int64)0x7FFFFFFF ){  rc = SQLITE_OK;  }else
#endif
 do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );  return rc; } static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {  assert( (sqliteIOErr == SQLITE_IOERR_LOCK) ||  (sqliteIOErr == SQLITE_IOERR_UNLOCK) ||  (sqliteIOErr == SQLITE_IOERR_RDLOCK) ||  (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) );  switch (posixError) {  case EACCES:  case EAGAIN:  case ETIMEDOUT:  case EBUSY:  case EINTR:  case ENOLCK:  return SQLITE_BUSY;  case EPERM:  return SQLITE_PERM;  default:  return sqliteIOErr;  } } struct vxworksFileId {  struct vxworksFileId *pNext;  int nRef;  int nName;  char *zCanonicalName; };
#if OS_VXWORKS
static struct vxworksFileId *vxworksFileList = 0; static int vxworksSimplifyName(char *z, int n){  int i, j;  while( n>1 && z[n-1]=='/' ){ n--; }  for(i=j=0; i<n; i++){  if( z[i]=='/' ){  if( z[i+1]=='/' ) continue;  if( z[i+1]=='.' && i+2<n && z[i+2]=='/' ){  i += 1;  continue;  }  if( z[i+1]=='.' && i+3<n && z[i+2]=='.' && z[i+3]=='/' ){  while( j>0 && z[j-1]!='/' ){ j--; }  if( j>0 ){ j--; }  i += 2;  continue;  }  }  z[j++] = z[i];  }  z[j] = 0;  return j; } static struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){  struct vxworksFileId *pNew;  struct vxworksFileId *pCandidate;  int n;  assert( zAbsoluteName[0]=='/' );  n = (int)strlen(zAbsoluteName);  pNew = sqlite3_malloc64( sizeof(*pNew) + (n+1) );  if( pNew==0 ) return 0;  pNew->zCanonicalName = (char*)&pNew[1];  memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);  n = vxworksSimplifyName(pNew->zCanonicalName, n);  unixEnterMutex();  for(pCandidate=vxworksFileList; pCandidate; pCandidate=pCandidate->pNext){  if( pCandidate->nName==n   && memcmp(pCandidate->zCanonicalName, pNew->zCanonicalName, n)==0  ){   sqlite3_free(pNew);   pCandidate->nRef++;   unixLeaveMutex();   return pCandidate;  }  }  pNew->nRef = 1;  pNew->nName = n;  pNew->pNext = vxworksFileList;  vxworksFileList = pNew;  unixLeaveMutex();  return pNew; } static void vxworksReleaseFileId(struct vxworksFileId *pId){  unixEnterMutex();  assert( pId->nRef>0 );  pId->nRef--;  if( pId->nRef==0 ){  struct vxworksFileId **pp;  for(pp=&vxworksFileList; *pp && *pp!=pId; pp = &((*pp)->pNext)){}  assert( *pp==pId );  *pp = pId->pNext;  sqlite3_free(pId);  }  unixLeaveMutex(); }
#endif
struct unixFileId {  dev_t dev;
#if OS_VXWORKS
 struct vxworksFileId *pId;
#else
 u64 ino;
#endif
}; struct unixInodeInfo {  struct unixFileId fileId;  sqlite3_mutex *pLockMutex;  int nShared;  int nLock;  unsigned char eFileLock;  unsigned char bProcessLock;  UnixUnusedFd *pUnused;  int nRef;  unixShmNode *pShmNode;  unixInodeInfo *pNext;  unixInodeInfo *pPrev;
#if SQLITE_ENABLE_LOCKING_STYLE
 unsigned long long sharedByte;
#endif
#if OS_VXWORKS
 sem_t *pSem;  char aSemName[MAX_PATHNAME+2];
#endif
}; static unixInodeInfo *inodeList = 0;
#ifdef SQLITE_DEBUG
int unixFileMutexHeld(unixFile *pFile){  assert( pFile->pInode );  return sqlite3_mutex_held(pFile->pInode->pLockMutex); } int unixFileMutexNotheld(unixFile *pFile){  assert( pFile->pInode );  return sqlite3_mutex_notheld(pFile->pInode->pLockMutex); }
#endif
#define unixLogError(a,b,c)  unixLogErrorAtLine(a,b,c,__LINE__)
static int unixLogErrorAtLine(  int errcode,  const char *zFunc,  const char *zPath,  int iLine ){  char *zErr;  int iErrno = errno;
#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)
 char aErr[80];  memset(aErr, 0, sizeof(aErr));  zErr = aErr;
#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)
 zErr =
# endif
 strerror_r(iErrno, aErr, sizeof(aErr)-1);
#elif SQLITE_THREADSAFE
 zErr = "";
#else
 zErr = strerror(iErrno);
#endif
 if( zPath==0 ) zPath = "";  sqlite3_log(errcode,  "os_unix.c:%d: (%d) %s(%s) - %s",  iLine, iErrno, zFunc, zPath, zErr  );  return errcode; } static void robust_close(unixFile *pFile, int h, int lineno){  if( osClose(h) ){  unixLogErrorAtLine(SQLITE_IOERR_CLOSE, "close",   pFile ? pFile->zPath : 0, lineno);  } } static void storeLastErrno(unixFile *pFile, int error){  pFile->lastErrno = error; } static void closePendingFds(unixFile *pFile){  unixInodeInfo *pInode = pFile->pInode;  UnixUnusedFd *p;  UnixUnusedFd *pNext;  assert( unixFileMutexHeld(pFile) );  for(p=pInode->pUnused; p; p=pNext){  pNext = p->pNext;  robust_close(pFile, p->fd, __LINE__);  sqlite3_free(p);  }  pInode->pUnused = 0; } static void releaseInodeInfo(unixFile *pFile){  unixInodeInfo *pInode = pFile->pInode;  assert( unixMutexHeld() );  assert( unixFileMutexNotheld(pFile) );  if( ALWAYS(pInode) ){  pInode->nRef--;  if( pInode->nRef==0 ){  assert( pInode->pShmNode==0 );  sqlite3_mutex_enter(pInode->pLockMutex);  closePendingFds(pFile);  sqlite3_mutex_leave(pInode->pLockMutex);  if( pInode->pPrev ){  assert( pInode->pPrev->pNext==pInode );  pInode->pPrev->pNext = pInode->pNext;  }else{  assert( inodeList==pInode );  inodeList = pInode->pNext;  }  if( pInode->pNext ){  assert( pInode->pNext->pPrev==pInode );  pInode->pNext->pPrev = pInode->pPrev;  }  sqlite3_mutex_free(pInode->pLockMutex);  sqlite3_free(pInode);  }  } } static int findInodeInfo(  unixFile *pFile,  unixInodeInfo **ppInode ){  int rc;  int fd;  struct unixFileId fileId;  struct stat statbuf;  unixInodeInfo *pInode = 0;  assert( unixMutexHeld() );  fd = pFile->h;  rc = osFstat(fd, &statbuf);  if( rc!=0 ){  storeLastErrno(pFile, errno);
#if defined(EOVERFLOW) && defined(SQLITE_DISABLE_LFS)
 if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;
#endif
 return SQLITE_IOERR;  }
#ifdef __APPLE__
 if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){  do{ rc = osWrite(fd, "S", 1); }while( rc<0 && errno==EINTR );  if( rc!=1 ){  storeLastErrno(pFile, errno);  return SQLITE_IOERR;  }  rc = osFstat(fd, &statbuf);  if( rc!=0 ){  storeLastErrno(pFile, errno);  return SQLITE_IOERR;  }  }
#endif
 memset(&fileId, 0, sizeof(fileId));  fileId.dev = statbuf.st_dev;
#if OS_VXWORKS
 fileId.pId = pFile->pId;
#else
 fileId.ino = (u64)statbuf.st_ino;
#endif
 assert( unixMutexHeld() );  pInode = inodeList;  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){  pInode = pInode->pNext;  }  if( pInode==0 ){  pInode = sqlite3_malloc64( sizeof(*pInode) );  if( pInode==0 ){  return SQLITE_NOMEM_BKPT;  }  memset(pInode, 0, sizeof(*pInode));  memcpy(&pInode->fileId, &fileId, sizeof(fileId));  if( sqlite3GlobalConfig.bCoreMutex ){  pInode->pLockMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);  if( pInode->pLockMutex==0 ){  sqlite3_free(pInode);  return SQLITE_NOMEM_BKPT;  }  }  pInode->nRef = 1;  assert( unixMutexHeld() );  pInode->pNext = inodeList;  pInode->pPrev = 0;  if( inodeList ) inodeList->pPrev = pInode;  inodeList = pInode;  }else{  pInode->nRef++;  }  *ppInode = pInode;  return SQLITE_OK; } static int fileHasMoved(unixFile *pFile){
#if OS_VXWORKS
 return pFile->pInode!=0 && pFile->pId!=pFile->pInode->fileId.pId;
#else
 struct stat buf;  return pFile->pInode!=0 &&  (osStat(pFile->zPath, &buf)!=0   || (u64)buf.st_ino!=pFile->pInode->fileId.ino);
#endif
} static void verifyDbFile(unixFile *pFile){  struct stat buf;  int rc;  if( pFile->ctrlFlags & UNIXFILE_NOLOCK ) return;  rc = osFstat(pFile->h, &buf);  if( rc!=0 ){  sqlite3_log(SQLITE_WARNING, "cannot fstat db file %s", pFile->zPath);  return;  }  if( buf.st_nlink==0 ){  sqlite3_log(SQLITE_WARNING, "file unlinked while open: %s", pFile->zPath);  return;  }  if( buf.st_nlink>1 ){  sqlite3_log(SQLITE_WARNING, "multiple links to file: %s", pFile->zPath);  return;  }  if( fileHasMoved(pFile) ){  sqlite3_log(SQLITE_WARNING, "file renamed while open: %s", pFile->zPath);  return;  } } static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){  int rc = SQLITE_OK;  int reserved = 0;  unixFile *pFile = (unixFile*)id;  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );  assert( pFile );  assert( pFile->eFileLock<=SHARED_LOCK );  sqlite3_mutex_enter(pFile->pInode->pLockMutex);  if( pFile->pInode->eFileLock>SHARED_LOCK ){  reserved = 1;  }
#ifndef __DJGPP__
 if( !reserved && !pFile->pInode->bProcessLock ){  struct flock lock;  lock.l_whence = SEEK_SET;  lock.l_start = RESERVED_BYTE;  lock.l_len = 1;  lock.l_type = F_WRLCK;  if( osFcntl(pFile->h, F_GETLK, &lock) ){  rc = SQLITE_IOERR_CHECKRESERVEDLOCK;  storeLastErrno(pFile, errno);  } else if( lock.l_type!=F_UNLCK ){  reserved = 1;  }  }
#endif
 sqlite3_mutex_leave(pFile->pInode->pLockMutex);  OSTRACE(("TEST WR-LOCK %d %d %d (unix)\n", pFile->h, rc, reserved));  *pResOut = reserved;  return rc; } static int unixSleep(sqlite3_vfs*,int);
#ifndef SQLITE_ENABLE_SETLK_TIMEOUT
# define osSetPosixAdvisoryLock(h,x,t) osFcntl(h,F_SETLK,x)
#else
static int osSetPosixAdvisoryLock(  int h,  struct flock *pLock,  unixFile *pFile ){  int tm = pFile->iBusyTimeout;  int rc = osFcntl(h,F_SETLK,pLock);  while( rc<0 && tm>0 ){  unixSleep(0,1000);  rc = osFcntl(h,F_SETLK,pLock);  tm--;  }  return rc; }
#endif
static int unixFileLock(unixFile *pFile, struct flock *pLock){  int rc;  unixInodeInfo *pInode = pFile->pInode;  assert( pInode!=0 );  assert( sqlite3_mutex_held(pInode->pLockMutex) );  if( (pFile->ctrlFlags & (UNIXFILE_EXCL|UNIXFILE_RDONLY))==UNIXFILE_EXCL ){  if( pInode->bProcessLock==0 ){  struct flock lock;  assert( pInode->nLock==0 );  lock.l_whence = SEEK_SET;  lock.l_start = SHARED_FIRST;  lock.l_len = SHARED_SIZE;  lock.l_type = F_WRLCK;  rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);  if( rc<0 ) return rc;  pInode->bProcessLock = 1;  pInode->nLock++;  }else{  rc = 0;  }  }else{  rc = osSetPosixAdvisoryLock(pFile->h, pLock, pFile);  }  return rc; } static int unixLock(sqlite3_file *id, int eFileLock){  int rc = SQLITE_OK;  unixFile *pFile = (unixFile*)id;  unixInodeInfo *pInode;  struct flock lock;  int tErrno = 0;  assert( pFile );  OSTRACE(("LOCK %d %s was %s(%s,%d) pid=%d (unix)\n", pFile->h,  azFileLock(eFileLock), azFileLock(pFile->eFileLock),  azFileLock(pFile->pInode->eFileLock), pFile->pInode->nShared,  osGetpid(0)));  if( pFile->eFileLock>=eFileLock ){  OSTRACE(("LOCK %d %s ok (already held) (unix)\n", pFile->h,  azFileLock(eFileLock)));  return SQLITE_OK;  }  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );  assert( eFileLock!=PENDING_LOCK );  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );  pInode = pFile->pInode;  sqlite3_mutex_enter(pInode->pLockMutex);  if( (pFile->eFileLock!=pInode->eFileLock &&  (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))  ){  rc = SQLITE_BUSY;  goto end_lock;  }  if( eFileLock==SHARED_LOCK &&  (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){  assert( eFileLock==SHARED_LOCK );  assert( pFile->eFileLock==0 );  assert( pInode->nShared>0 );  pFile->eFileLock = SHARED_LOCK;  pInode->nShared++;  pInode->nLock++;  goto end_lock;  }  lock.l_len = 1L;  lock.l_whence = SEEK_SET;  if( eFileLock==SHARED_LOCK  || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)  ){  lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);  lock.l_start = PENDING_BYTE;  if( unixFileLock(pFile, &lock) ){  tErrno = errno;  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);  if( rc!=SQLITE_BUSY ){  storeLastErrno(pFile, tErrno);  }  goto end_lock;  }  }  if( eFileLock==SHARED_LOCK ){  assert( pInode->nShared==0 );  assert( pInode->eFileLock==0 );  assert( rc==SQLITE_OK );  lock.l_start = SHARED_FIRST;  lock.l_len = SHARED_SIZE;  if( unixFileLock(pFile, &lock) ){  tErrno = errno;  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);  }  lock.l_start = PENDING_BYTE;  lock.l_len = 1L;  lock.l_type = F_UNLCK;  if( unixFileLock(pFile, &lock) && rc==SQLITE_OK ){  tErrno = errno;  rc = SQLITE_IOERR_UNLOCK;  }  if( rc ){  if( rc!=SQLITE_BUSY ){  storeLastErrno(pFile, tErrno);  }  goto end_lock;  }else{  pFile->eFileLock = SHARED_LOCK;  pInode->nLock++;  pInode->nShared = 1;  }  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){  rc = SQLITE_BUSY;  }else{  assert( 0!=pFile->eFileLock );  lock.l_type = F_WRLCK;  assert( eFileLock==RESERVED_LOCK || eFileLock==EXCLUSIVE_LOCK );  if( eFileLock==RESERVED_LOCK ){  lock.l_start = RESERVED_BYTE;  lock.l_len = 1L;  }else{  lock.l_start = SHARED_FIRST;  lock.l_len = SHARED_SIZE;  }  if( unixFileLock(pFile, &lock) ){  tErrno = errno;  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);  if( rc!=SQLITE_BUSY ){  storeLastErrno(pFile, tErrno);  }  }  }
#ifdef SQLITE_DEBUG
 if( rc==SQLITE_OK   && pFile->eFileLock<=SHARED_LOCK   && eFileLock==RESERVED_LOCK  ){  pFile->transCntrChng = 0;  pFile->dbUpdate = 0;  pFile->inNormalWrite = 1;  }
#endif
 if( rc==SQLITE_OK ){  pFile->eFileLock = eFileLock;  pInode->eFileLock = eFileLock;  }else if( eFileLock==EXCLUSIVE_LOCK ){  pFile->eFileLock = PENDING_LOCK;  pInode->eFileLock = PENDING_LOCK;  } end_lock:  sqlite3_mutex_leave(pInode->pLockMutex);  OSTRACE(("LOCK %d %s %s (unix)\n", pFile->h, azFileLock(eFileLock),  rc==SQLITE_OK ? "ok" : "failed"));  return rc; } static void setPendingFd(unixFile *pFile){  unixInodeInfo *pInode = pFile->pInode;  UnixUnusedFd *p = pFile->pPreallocatedUnused;  assert( unixFileMutexHeld(pFile) );  p->pNext = pInode->pUnused;  pInode->pUnused = p;  pFile->h = -1;  pFile->pPreallocatedUnused = 0; } static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){  unixFile *pFile = (unixFile*)id;  unixInodeInfo *pInode;  struct flock lock;  int rc = SQLITE_OK;  assert( pFile );  OSTRACE(("UNLOCK %d %d was %d(%d,%d) pid=%d (unix)\n", pFile->h, eFileLock,  pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,  osGetpid(0)));  assert( eFileLock<=SHARED_LOCK );  if( pFile->eFileLock<=eFileLock ){  return SQLITE_OK;  }  pInode = pFile->pInode;  sqlite3_mutex_enter(pInode->pLockMutex);  assert( pInode->nShared!=0 );  if( pFile->eFileLock>SHARED_LOCK ){  assert( pInode->eFileLock==pFile->eFileLock );
#ifdef SQLITE_DEBUG
 pFile->inNormalWrite = 0;
#endif
 if( eFileLock==SHARED_LOCK ){
#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE
 (void)handleNFSUnlock;  assert( handleNFSUnlock==0 );
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
 if( handleNFSUnlock ){  int tErrno;  off_t divSize = SHARED_SIZE - 1;  lock.l_type = F_UNLCK;  lock.l_whence = SEEK_SET;  lock.l_start = SHARED_FIRST;  lock.l_len = divSize;  if( unixFileLock(pFile, &lock)==(-1) ){  tErrno = errno;  rc = SQLITE_IOERR_UNLOCK;  storeLastErrno(pFile, tErrno);  goto end_unlock;  }  lock.l_type = F_RDLCK;  lock.l_whence = SEEK_SET;  lock.l_start = SHARED_FIRST;  lock.l_len = divSize;  if( unixFileLock(pFile, &lock)==(-1) ){  tErrno = errno;  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);  if( IS_LOCK_ERROR(rc) ){  storeLastErrno(pFile, tErrno);  }  goto end_unlock;  }  lock.l_type = F_UNLCK;  lock.l_whence = SEEK_SET;  lock.l_start = SHARED_FIRST+divSize;  lock.l_len = SHARED_SIZE-divSize;  if( unixFileLock(pFile, &lock)==(-1) ){  tErrno = errno;  rc = SQLITE_IOERR_UNLOCK;  storeLastErrno(pFile, tErrno);  goto end_unlock;  }  }else
#endif
 {  lock.l_type = F_RDLCK;  lock.l_whence = SEEK_SET;  lock.l_start = SHARED_FIRST;  lock.l_len = SHARED_SIZE;  if( unixFileLock(pFile, &lock) ){  rc = SQLITE_IOERR_RDLOCK;  storeLastErrno(pFile, errno);  goto end_unlock;  }  }  }  lock.l_type = F_UNLCK;  lock.l_whence = SEEK_SET;  lock.l_start = PENDING_BYTE;  lock.l_len = 2L; assert( PENDING_BYTE+1==RESERVED_BYTE );  if( unixFileLock(pFile, &lock)==0 ){  pInode->eFileLock = SHARED_LOCK;  }else{  rc = SQLITE_IOERR_UNLOCK;  storeLastErrno(pFile, errno);  goto end_unlock;  }  }  if( eFileLock==NO_LOCK ){  pInode->nShared--;  if( pInode->nShared==0 ){  lock.l_type = F_UNLCK;  lock.l_whence = SEEK_SET;  lock.l_start = lock.l_len = 0L;  if( unixFileLock(pFile, &lock)==0 ){  pInode->eFileLock = NO_LOCK;  }else{  rc = SQLITE_IOERR_UNLOCK;  storeLastErrno(pFile, errno);  pInode->eFileLock = NO_LOCK;  pFile->eFileLock = NO_LOCK;  }  }  pInode->nLock--;  assert( pInode->nLock>=0 );  if( pInode->nLock==0 ) closePendingFds(pFile);  } end_unlock:  sqlite3_mutex_leave(pInode->pLockMutex);  if( rc==SQLITE_OK ){  pFile->eFileLock = eFileLock;  }  return rc; } static int unixUnlock(sqlite3_file *id, int eFileLock){
#if SQLITE_MAX_MMAP_SIZE>0
 assert( eFileLock==SHARED_LOCK || ((unixFile *)id)->nFetchOut==0 );
#endif
 return posixUnlock(id, eFileLock, 0); }
#if SQLITE_MAX_MMAP_SIZE>0
static int unixMapfile(unixFile *pFd, i64 nByte); static void unixUnmapfile(unixFile *pFd);
#endif
static int closeUnixFile(sqlite3_file *id){  unixFile *pFile = (unixFile*)id;
#if SQLITE_MAX_MMAP_SIZE>0
 unixUnmapfile(pFile);
#endif
 if( pFile->h>=0 ){  robust_close(pFile, pFile->h, __LINE__);  pFile->h = -1;  }
#if OS_VXWORKS
 if( pFile->pId ){  if( pFile->ctrlFlags & UNIXFILE_DELETE ){  osUnlink(pFile->pId->zCanonicalName);  }  vxworksReleaseFileId(pFile->pId);  pFile->pId = 0;  }
#endif
#ifdef SQLITE_UNLINK_AFTER_CLOSE
 if( pFile->ctrlFlags & UNIXFILE_DELETE ){  osUnlink(pFile->zPath);  sqlite3_free(*(char**)&pFile->zPath);  pFile->zPath = 0;  }
#endif
 OSTRACE(("CLOSE  %-3d\n", pFile->h));  OpenCounter(-1);  sqlite3_free(pFile->pPreallocatedUnused);  memset(pFile, 0, sizeof(unixFile));  return SQLITE_OK; } static int unixClose(sqlite3_file *id){  int rc = SQLITE_OK;  unixFile *pFile = (unixFile *)id;  unixInodeInfo *pInode = pFile->pInode;  assert( pInode!=0 );  verifyDbFile(pFile);  unixUnlock(id, NO_LOCK);  assert( unixFileMutexNotheld(pFile) );  unixEnterMutex();  assert( pFile->pInode->nLock>0 || pFile->pInode->bProcessLock==0 );  sqlite3_mutex_enter(pInode->pLockMutex);  if( pInode->nLock ){  setPendingFd(pFile);  }  sqlite3_mutex_leave(pInode->pLockMutex);  releaseInodeInfo(pFile);  assert( pFile->pShm==0 );  rc = closeUnixFile(id);  unixLeaveMutex();  return rc; } static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){  UNUSED_PARAMETER(NotUsed);  *pResOut = 0;  return SQLITE_OK; } static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  return SQLITE_OK; } static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  return SQLITE_OK; } static int nolockClose(sqlite3_file *id) {  return closeUnixFile(id); }
#define DOTLOCK_SUFFIX ".lock"
static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {  int rc = SQLITE_OK;  int reserved = 0;  unixFile *pFile = (unixFile*)id;  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );  assert( pFile );  reserved = osAccess((const char*)pFile->lockingContext, 0)==0;  OSTRACE(("TEST WR-LOCK %d %d %d (dotlock)\n", pFile->h, rc, reserved));  *pResOut = reserved;  return rc; } static int dotlockLock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  char *zLockFile = (char *)pFile->lockingContext;  int rc = SQLITE_OK;  if( pFile->eFileLock > NO_LOCK ){  pFile->eFileLock = eFileLock;
#ifdef HAVE_UTIME
 utime(zLockFile, NULL);
#else
 utimes(zLockFile, NULL);
#endif
 return SQLITE_OK;  }  rc = osMkdir(zLockFile, 0777);  if( rc<0 ){  int tErrno = errno;  if( EEXIST == tErrno ){  rc = SQLITE_BUSY;  } else {  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);  if( rc!=SQLITE_BUSY ){  storeLastErrno(pFile, tErrno);  }  }  return rc;  }  pFile->eFileLock = eFileLock;  return rc; } static int dotlockUnlock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  char *zLockFile = (char *)pFile->lockingContext;  int rc;  assert( pFile );  OSTRACE(("UNLOCK %d %d was %d pid=%d (dotlock)\n", pFile->h, eFileLock,   pFile->eFileLock, osGetpid(0)));  assert( eFileLock<=SHARED_LOCK );  if( pFile->eFileLock==eFileLock ){  return SQLITE_OK;  }  if( eFileLock==SHARED_LOCK ){  pFile->eFileLock = SHARED_LOCK;  return SQLITE_OK;  }  assert( eFileLock==NO_LOCK );  rc = osRmdir(zLockFile);  if( rc<0 ){  int tErrno = errno;  if( tErrno==ENOENT ){  rc = SQLITE_OK;  }else{  rc = SQLITE_IOERR_UNLOCK;  storeLastErrno(pFile, tErrno);  }  return rc;  }  pFile->eFileLock = NO_LOCK;  return SQLITE_OK; } static int dotlockClose(sqlite3_file *id) {  unixFile *pFile = (unixFile*)id;  assert( id!=0 );  dotlockUnlock(id, NO_LOCK);  sqlite3_free(pFile->lockingContext);  return closeUnixFile(id); }
#if SQLITE_ENABLE_LOCKING_STYLE
#ifdef EINTR
static int robust_flock(int fd, int op){  int rc;  do{ rc = flock(fd,op); }while( rc<0 && errno==EINTR );  return rc; }
#else
# define robust_flock(a,b) flock(a,b)
#endif
static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){  int rc = SQLITE_OK;  int reserved = 0;  unixFile *pFile = (unixFile*)id;  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );  assert( pFile );  if( pFile->eFileLock>SHARED_LOCK ){  reserved = 1;  }  if( !reserved ){  int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);  if( !lrc ){  lrc = robust_flock(pFile->h, LOCK_UN);  if ( lrc ) {  int tErrno = errno;  lrc = SQLITE_IOERR_UNLOCK;  storeLastErrno(pFile, tErrno);  rc = lrc;  }  } else {  int tErrno = errno;  reserved = 1;  lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);  if( IS_LOCK_ERROR(lrc) ){  storeLastErrno(pFile, tErrno);  rc = lrc;  }  }  }  OSTRACE(("TEST WR-LOCK %d %d %d (flock)\n", pFile->h, rc, reserved));
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
 if( (rc & 0xff) == SQLITE_IOERR ){  rc = SQLITE_OK;  reserved=1;  }
#endif
 *pResOut = reserved;  return rc; } static int flockLock(sqlite3_file *id, int eFileLock) {  int rc = SQLITE_OK;  unixFile *pFile = (unixFile*)id;  assert( pFile );  if (pFile->eFileLock > NO_LOCK) {  pFile->eFileLock = eFileLock;  return SQLITE_OK;  }  if (robust_flock(pFile->h, LOCK_EX | LOCK_NB)) {  int tErrno = errno;  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);  if( IS_LOCK_ERROR(rc) ){  storeLastErrno(pFile, tErrno);  }  } else {  pFile->eFileLock = eFileLock;  }  OSTRACE(("LOCK %d %s %s (flock)\n", pFile->h, azFileLock(eFileLock),   rc==SQLITE_OK ? "ok" : "failed"));
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
 if( (rc & 0xff) == SQLITE_IOERR ){  rc = SQLITE_BUSY;  }
#endif
 return rc; } static int flockUnlock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  assert( pFile );  OSTRACE(("UNLOCK %d %d was %d pid=%d (flock)\n", pFile->h, eFileLock,   pFile->eFileLock, osGetpid(0)));  assert( eFileLock<=SHARED_LOCK );  if( pFile->eFileLock==eFileLock ){  return SQLITE_OK;  }  if (eFileLock==SHARED_LOCK) {  pFile->eFileLock = eFileLock;  return SQLITE_OK;  }  if( robust_flock(pFile->h, LOCK_UN) ){
#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS
 return SQLITE_OK;
#endif
 return SQLITE_IOERR_UNLOCK;  }else{  pFile->eFileLock = NO_LOCK;  return SQLITE_OK;  } } static int flockClose(sqlite3_file *id) {  assert( id!=0 );  flockUnlock(id, NO_LOCK);  return closeUnixFile(id); }
#endif
#if OS_VXWORKS
static int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {  int rc = SQLITE_OK;  int reserved = 0;  unixFile *pFile = (unixFile*)id;  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );  assert( pFile );  if( pFile->eFileLock>SHARED_LOCK ){  reserved = 1;  }  if( !reserved ){  sem_t *pSem = pFile->pInode->pSem;  if( sem_trywait(pSem)==-1 ){  int tErrno = errno;  if( EAGAIN != tErrno ){  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);  storeLastErrno(pFile, tErrno);  } else {  reserved = (pFile->eFileLock < SHARED_LOCK);  }  }else{  sem_post(pSem);  }  }  OSTRACE(("TEST WR-LOCK %d %d %d (sem)\n", pFile->h, rc, reserved));  *pResOut = reserved;  return rc; } static int semXLock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  sem_t *pSem = pFile->pInode->pSem;  int rc = SQLITE_OK;  if (pFile->eFileLock > NO_LOCK) {  pFile->eFileLock = eFileLock;  rc = SQLITE_OK;  goto sem_end_lock;  }  if( sem_trywait(pSem)==-1 ){  rc = SQLITE_BUSY;  goto sem_end_lock;  }  pFile->eFileLock = eFileLock;  sem_end_lock:  return rc; } static int semXUnlock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  sem_t *pSem = pFile->pInode->pSem;  assert( pFile );  assert( pSem );  OSTRACE(("UNLOCK %d %d was %d pid=%d (sem)\n", pFile->h, eFileLock,   pFile->eFileLock, osGetpid(0)));  assert( eFileLock<=SHARED_LOCK );  if( pFile->eFileLock==eFileLock ){  return SQLITE_OK;  }  if (eFileLock==SHARED_LOCK) {  pFile->eFileLock = eFileLock;  return SQLITE_OK;  }  if ( sem_post(pSem)==-1 ) {  int rc, tErrno = errno;  rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);  if( IS_LOCK_ERROR(rc) ){  storeLastErrno(pFile, tErrno);  }  return rc;  }  pFile->eFileLock = NO_LOCK;  return SQLITE_OK; } static int semXClose(sqlite3_file *id) {  if( id ){  unixFile *pFile = (unixFile*)id;  semXUnlock(id, NO_LOCK);  assert( pFile );  assert( unixFileMutexNotheld(pFile) );  unixEnterMutex();  releaseInodeInfo(pFile);  unixLeaveMutex();  closeUnixFile(id);  }  return SQLITE_OK; }
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
typedef struct afpLockingContext afpLockingContext; struct afpLockingContext {  int reserved;  const char *dbPath; }; struct ByteRangeLockPB2 {  unsigned long long offset;  unsigned long long length;  unsigned long long retRangeStart;  unsigned char unLockFlag;  unsigned char startEndFlag;  int fd; };
#define afpfsByteRangeLock2FSCTL _IOWR('z', 23, struct ByteRangeLockPB2)
static int afpSetLock(  const char *path,  unixFile *pFile,  unsigned long long offset,  unsigned long long length,  int setLockFlag ){  struct ByteRangeLockPB2 pb;  int err;  pb.unLockFlag = setLockFlag ? 0 : 1;  pb.startEndFlag = 0;  pb.offset = offset;  pb.length = length;  pb.fd = pFile->h;  OSTRACE(("AFPSETLOCK [%s] for %d%s in range %llx:%llx\n",  (setLockFlag?"ON":"OFF"), pFile->h, (pb.fd==-1?"[testval-1]":""),  offset, length));  err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0);  if ( err==-1 ) {  int rc;  int tErrno = errno;  OSTRACE(("AFPSETLOCK failed to fsctl() '%s' %d %s\n",   path, tErrno, strerror(tErrno)));
#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS
 rc = SQLITE_BUSY;
#else
 rc = sqliteErrorFromPosixError(tErrno,  setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);
#endif
 if( IS_LOCK_ERROR(rc) ){  storeLastErrno(pFile, tErrno);  }  return rc;  } else {  return SQLITE_OK;  } } static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){  int rc = SQLITE_OK;  int reserved = 0;  unixFile *pFile = (unixFile*)id;  afpLockingContext *context;  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );  assert( pFile );  context = (afpLockingContext *) pFile->lockingContext;  if( context->reserved ){  *pResOut = 1;  return SQLITE_OK;  }  sqlite3_mutex_enter(pFile->pInode->pLockMutex);  if( pFile->pInode->eFileLock>SHARED_LOCK ){  reserved = 1;  }  if( !reserved ){  int lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);  if( SQLITE_OK==lrc ){  lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);  } else {  reserved = 1;  }  if( IS_LOCK_ERROR(lrc) ){  rc=lrc;  }  }  sqlite3_mutex_leave(pFile->pInode->pLockMutex);  OSTRACE(("TEST WR-LOCK %d %d %d (afp)\n", pFile->h, rc, reserved));  *pResOut = reserved;  return rc; } static int afpLock(sqlite3_file *id, int eFileLock){  int rc = SQLITE_OK;  unixFile *pFile = (unixFile*)id;  unixInodeInfo *pInode = pFile->pInode;  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;  assert( pFile );  OSTRACE(("LOCK %d %s was %s(%s,%d) pid=%d (afp)\n", pFile->h,   azFileLock(eFileLock), azFileLock(pFile->eFileLock),   azFileLock(pInode->eFileLock), pInode->nShared , osGetpid(0)));  if( pFile->eFileLock>=eFileLock ){  OSTRACE(("LOCK %d %s ok (already held) (afp)\n", pFile->h,   azFileLock(eFileLock)));  return SQLITE_OK;  }  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );  assert( eFileLock!=PENDING_LOCK );  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );  pInode = pFile->pInode;  sqlite3_mutex_enter(pInode->pLockMutex);  if( (pFile->eFileLock!=pInode->eFileLock &&   (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))   ){  rc = SQLITE_BUSY;  goto afp_end_lock;  }  if( eFileLock==SHARED_LOCK &&   (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){  assert( eFileLock==SHARED_LOCK );  assert( pFile->eFileLock==0 );  assert( pInode->nShared>0 );  pFile->eFileLock = SHARED_LOCK;  pInode->nShared++;  pInode->nLock++;  goto afp_end_lock;  }  if( eFileLock==SHARED_LOCK  || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)  ){  int failed;  failed = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 1);  if (failed) {  rc = failed;  goto afp_end_lock;  }  }  if( eFileLock==SHARED_LOCK ){  int lrc1, lrc2, lrc1Errno = 0;  long lk, mask;  assert( pInode->nShared==0 );  assert( pInode->eFileLock==0 );  mask = (sizeof(long)==8) ? LARGEST_INT64 : 0x7fffffff;  lk = random();  pInode->sharedByte = (lk & mask)%(SHARED_SIZE - 1);  lrc1 = afpSetLock(context->dbPath, pFile,  SHARED_FIRST+pInode->sharedByte, 1, 1);  if( IS_LOCK_ERROR(lrc1) ){  lrc1Errno = pFile->lastErrno;  }  lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);  if( IS_LOCK_ERROR(lrc1) ) {  storeLastErrno(pFile, lrc1Errno);  rc = lrc1;  goto afp_end_lock;  } else if( IS_LOCK_ERROR(lrc2) ){  rc = lrc2;  goto afp_end_lock;  } else if( lrc1 != SQLITE_OK ) {  rc = lrc1;  } else {  pFile->eFileLock = SHARED_LOCK;  pInode->nLock++;  pInode->nShared = 1;  }  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){  rc = SQLITE_BUSY;  }else{  int failed = 0;  assert( 0!=pFile->eFileLock );  if (eFileLock >= RESERVED_LOCK && pFile->eFileLock < RESERVED_LOCK) {  failed = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);  if( !failed ){  context->reserved = 1;  }  }  if (!failed && eFileLock == EXCLUSIVE_LOCK) {  if( !(failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST +   pInode->sharedByte, 1, 0)) ){  int failed2 = SQLITE_OK;  failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST,   SHARED_SIZE, 1);  if( failed && (failed2 = afpSetLock(context->dbPath, pFile,   SHARED_FIRST + pInode->sharedByte, 1, 1)) ){  rc = ((failed & 0xff) == SQLITE_IOERR) ? failed2 :   SQLITE_IOERR_LOCK;  goto afp_end_lock;  }  }else{  rc = failed;  }  }  if( failed ){  rc = failed;  }  }  if( rc==SQLITE_OK ){  pFile->eFileLock = eFileLock;  pInode->eFileLock = eFileLock;  }else if( eFileLock==EXCLUSIVE_LOCK ){  pFile->eFileLock = PENDING_LOCK;  pInode->eFileLock = PENDING_LOCK;  } afp_end_lock:  sqlite3_mutex_leave(pInode->pLockMutex);  OSTRACE(("LOCK %d %s %s (afp)\n", pFile->h, azFileLock(eFileLock),   rc==SQLITE_OK ? "ok" : "failed"));  return rc; } static int afpUnlock(sqlite3_file *id, int eFileLock) {  int rc = SQLITE_OK;  unixFile *pFile = (unixFile*)id;  unixInodeInfo *pInode;  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;  int skipShared = 0;
#ifdef SQLITE_TEST
 int h = pFile->h;
#endif
 assert( pFile );  OSTRACE(("UNLOCK %d %d was %d(%d,%d) pid=%d (afp)\n", pFile->h, eFileLock,   pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,   osGetpid(0)));  assert( eFileLock<=SHARED_LOCK );  if( pFile->eFileLock<=eFileLock ){  return SQLITE_OK;  }  pInode = pFile->pInode;  sqlite3_mutex_enter(pInode->pLockMutex);  assert( pInode->nShared!=0 );  if( pFile->eFileLock>SHARED_LOCK ){  assert( pInode->eFileLock==pFile->eFileLock );  SimulateIOErrorBenign(1);  SimulateIOError( h=(-1) )  SimulateIOErrorBenign(0);
#ifdef SQLITE_DEBUG
 assert( pFile->inNormalWrite==0   || pFile->dbUpdate==0   || pFile->transCntrChng==1 );  pFile->inNormalWrite = 0;
#endif
 if( pFile->eFileLock==EXCLUSIVE_LOCK ){  rc = afpSetLock(context->dbPath, pFile, SHARED_FIRST, SHARED_SIZE, 0);  if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1) ){  int sharedLockByte = SHARED_FIRST+pInode->sharedByte;  rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);  } else {  skipShared = 1;  }  }  if( rc==SQLITE_OK && pFile->eFileLock>=PENDING_LOCK ){  rc = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);  }  if( rc==SQLITE_OK && pFile->eFileLock>=RESERVED_LOCK && context->reserved ){  rc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);  if( !rc ){  context->reserved = 0;  }  }  if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1)){  pInode->eFileLock = SHARED_LOCK;  }  }  if( rc==SQLITE_OK && eFileLock==NO_LOCK ){  unsigned long long sharedLockByte = SHARED_FIRST+pInode->sharedByte;  pInode->nShared--;  if( pInode->nShared==0 ){  SimulateIOErrorBenign(1);  SimulateIOError( h=(-1) )  SimulateIOErrorBenign(0);  if( !skipShared ){  rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);  }  if( !rc ){  pInode->eFileLock = NO_LOCK;  pFile->eFileLock = NO_LOCK;  }  }  if( rc==SQLITE_OK ){  pInode->nLock--;  assert( pInode->nLock>=0 );  if( pInode->nLock==0 ) closePendingFds(pFile);  }  }  sqlite3_mutex_leave(pInode->pLockMutex);  if( rc==SQLITE_OK ){  pFile->eFileLock = eFileLock;  }  return rc; } static int afpClose(sqlite3_file *id) {  int rc = SQLITE_OK;  unixFile *pFile = (unixFile*)id;  assert( id!=0 );  afpUnlock(id, NO_LOCK);  assert( unixFileMutexNotheld(pFile) );  unixEnterMutex();  if( pFile->pInode ){  unixInodeInfo *pInode = pFile->pInode;  sqlite3_mutex_enter(pInode->pLockMutex);  if( pInode->nLock ){  setPendingFd(pFile);  }  sqlite3_mutex_leave(pInode->pLockMutex);  }  releaseInodeInfo(pFile);  sqlite3_free(pFile->lockingContext);  rc = closeUnixFile(id);  unixLeaveMutex();  return rc; }
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
static int nfsUnlock(sqlite3_file *id, int eFileLock){  return posixUnlock(id, eFileLock, 1); }
#endif
static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){  int got;  int prior = 0;
#if (!defined(USE_PREAD) && !defined(USE_PREAD64))
 i64 newOffset;
#endif
 TIMER_START;  assert( cnt==(cnt&0x1ffff) );  assert( id->h>2 );  do{
#if defined(USE_PREAD)
 got = osPread(id->h, pBuf, cnt, offset);  SimulateIOError( got = -1 );
#elif defined(USE_PREAD64)
 got = osPread64(id->h, pBuf, cnt, offset);  SimulateIOError( got = -1 );
#else
 newOffset = lseek(id->h, offset, SEEK_SET);  SimulateIOError( newOffset = -1 );  if( newOffset<0 ){  storeLastErrno((unixFile*)id, errno);  return -1;  }  got = osRead(id->h, pBuf, cnt);
#endif
 if( got==cnt ) break;  if( got<0 ){  if( errno==EINTR ){ got = 1; continue; }  prior = 0;  storeLastErrno((unixFile*)id, errno);  break;  }else if( got>0 ){  cnt -= got;  offset += got;  prior += got;  pBuf = (void*)(got + (char*)pBuf);  }  }while( got>0 );  TIMER_END;  OSTRACE(("READ %-3d %5d %7lld %llu\n",  id->h, got+prior, offset-prior, TIMER_ELAPSED));  return got+prior; } static int unixRead(  sqlite3_file *id,  void *pBuf,  int amt,  sqlite3_int64 offset ){  unixFile *pFile = (unixFile *)id;  int got;  assert( id );  assert( offset>=0 );  assert( amt>0 );
#if 0
 assert( pFile->pPreallocatedUnused==0   || offset>=PENDING_BYTE+512   || offset+amt<=PENDING_BYTE  );
#endif
#if SQLITE_MAX_MMAP_SIZE>0
 if( offset<pFile->mmapSize ){  if( offset+amt <= pFile->mmapSize ){  memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);  return SQLITE_OK;  }else{  int nCopy = pFile->mmapSize - offset;  memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);  pBuf = &((u8 *)pBuf)[nCopy];  amt -= nCopy;  offset += nCopy;  }  }
#endif
 got = seekAndRead(pFile, offset, pBuf, amt);  if( got==amt ){  return SQLITE_OK;  }else if( got<0 ){  switch( pFile->lastErrno ){  case ERANGE:  case EIO:
#ifdef ENXIO
 case ENXIO:
#endif
#ifdef EDEVERR
 case EDEVERR:
#endif
 return SQLITE_IOERR_CORRUPTFS;  }  return SQLITE_IOERR_READ;  }else{  storeLastErrno(pFile, 0);  memset(&((char*)pBuf)[got], 0, amt-got);  return SQLITE_IOERR_SHORT_READ;  } } static int seekAndWriteFd(  int fd,  i64 iOff,  const void *pBuf,  int nBuf,  int *piErrno ){  int rc = 0;  assert( nBuf==(nBuf&0x1ffff) );  assert( fd>2 );  assert( piErrno!=0 );  nBuf &= 0x1ffff;  TIMER_START;
#if defined(USE_PREAD)
 do{ rc = (int)osPwrite(fd, pBuf, nBuf, iOff); }while( rc<0 && errno==EINTR );
#elif defined(USE_PREAD64)
 do{ rc = (int)osPwrite64(fd, pBuf, nBuf, iOff);}while( rc<0 && errno==EINTR);
#else
 do{  i64 iSeek = lseek(fd, iOff, SEEK_SET);  SimulateIOError( iSeek = -1 );  if( iSeek<0 ){  rc = -1;  break;  }  rc = osWrite(fd, pBuf, nBuf);  }while( rc<0 && errno==EINTR );
#endif
 TIMER_END;  OSTRACE(("WRITE  %-3d %5d %7lld %llu\n", fd, rc, iOff, TIMER_ELAPSED));  if( rc<0 ) *piErrno = errno;  return rc; } static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){  return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno); } static int unixWrite(  sqlite3_file *id,  const void *pBuf,  int amt,  sqlite3_int64 offset ){  unixFile *pFile = (unixFile*)id;  int wrote = 0;  assert( id );  assert( amt>0 );
#if 0
 assert( pFile->pPreallocatedUnused==0   || offset>=PENDING_BYTE+512   || offset+amt<=PENDING_BYTE  );
#endif
#ifdef SQLITE_DEBUG
 if( pFile->inNormalWrite ){  pFile->dbUpdate = 1;  if( offset<=24 && offset+amt>=27 ){  int rc;  char oldCntr[4];  SimulateIOErrorBenign(1);  rc = seekAndRead(pFile, 24, oldCntr, 4);  SimulateIOErrorBenign(0);  if( rc!=4 || memcmp(oldCntr, &((char*)pBuf)[24-offset], 4)!=0 ){  pFile->transCntrChng = 1;  }  }  }
#endif
#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0
 if( offset<pFile->mmapSize ){  if( offset+amt <= pFile->mmapSize ){  memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);  return SQLITE_OK;  }else{  int nCopy = pFile->mmapSize - offset;  memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);  pBuf = &((u8 *)pBuf)[nCopy];  amt -= nCopy;  offset += nCopy;  }  }
#endif
 while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){  amt -= wrote;  offset += wrote;  pBuf = &((char*)pBuf)[wrote];  }  SimulateIOError(( wrote=(-1), amt=1 ));  SimulateDiskfullError(( wrote=0, amt=1 ));  if( amt>wrote ){  if( wrote<0 && pFile->lastErrno!=ENOSPC ){  return SQLITE_IOERR_WRITE;  }else{  storeLastErrno(pFile, 0);  return SQLITE_FULL;  }  }  return SQLITE_OK; }
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_sync_count = 0; SQLITE_API int sqlite3_fullsync_count = 0;
#endif
#if !defined(fdatasync) && !HAVE_FDATASYNC
# define fdatasync fsync
#endif
#ifdef F_FULLFSYNC
# define HAVE_FULLFSYNC 1
#else
# define HAVE_FULLFSYNC 0
#endif
static int full_fsync(int fd, int fullSync, int dataOnly){  int rc;
#ifdef SQLITE_NO_SYNC
 UNUSED_PARAMETER(fd);  UNUSED_PARAMETER(fullSync);  UNUSED_PARAMETER(dataOnly);
#elif HAVE_FULLFSYNC
 UNUSED_PARAMETER(dataOnly);
#else
 UNUSED_PARAMETER(fullSync);  UNUSED_PARAMETER(dataOnly);
#endif
#ifdef SQLITE_TEST
 if( fullSync ) sqlite3_fullsync_count++;  sqlite3_sync_count++;
#endif
#ifdef SQLITE_NO_SYNC
 {  struct stat buf;  rc = osFstat(fd, &buf);  }
#elif HAVE_FULLFSYNC
 if( fullSync ){  rc = osFcntl(fd, F_FULLFSYNC, 0);  }else{  rc = 1;  }  if( rc ) rc = fsync(fd);
#elif defined(__APPLE__)
 rc = fsync(fd);
#else
 rc = fdatasync(fd);
#if OS_VXWORKS
 if( rc==-1 && errno==ENOTSUP ){  rc = fsync(fd);  }
#endif
#endif
 if( OS_VXWORKS && rc!= -1 ){  rc = 0;  }  return rc; } static int openDirectory(const char *zFilename, int *pFd){  int ii;  int fd = -1;  char zDirname[MAX_PATHNAME+1];  sqlite3_snprintf(MAX_PATHNAME, zDirname, "%s", zFilename);  for(ii=(int)strlen(zDirname); ii>0 && zDirname[ii]!='/'; ii--);  if( ii>0 ){  zDirname[ii] = '\0';  }else{  if( zDirname[0]!='/' ) zDirname[0] = '.';  zDirname[1] = 0;  }  fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);  if( fd>=0 ){  OSTRACE(("OPENDIR %-3d %s\n", fd, zDirname));  }  *pFd = fd;  if( fd>=0 ) return SQLITE_OK;  return unixLogError(SQLITE_CANTOPEN_BKPT, "openDirectory", zDirname); } static int unixSync(sqlite3_file *id, int flags){  int rc;  unixFile *pFile = (unixFile*)id;  int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);  int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL;  assert((flags&0x0F)==SQLITE_SYNC_NORMAL  || (flags&0x0F)==SQLITE_SYNC_FULL  );  SimulateDiskfullError( return SQLITE_FULL );  assert( pFile );  OSTRACE(("SYNC %-3d\n", pFile->h));  rc = full_fsync(pFile->h, isFullsync, isDataOnly);  SimulateIOError( rc=1 );  if( rc ){  storeLastErrno(pFile, errno);  return unixLogError(SQLITE_IOERR_FSYNC, "full_fsync", pFile->zPath);  }  if( pFile->ctrlFlags & UNIXFILE_DIRSYNC ){  int dirfd;  OSTRACE(("DIRSYNC %s (have_fullfsync=%d fullsync=%d)\n", pFile->zPath,  HAVE_FULLFSYNC, isFullsync));  rc = osOpenDirectory(pFile->zPath, &dirfd);  if( rc==SQLITE_OK ){  full_fsync(dirfd, 0, 0);  robust_close(pFile, dirfd, __LINE__);  }else{  assert( rc==SQLITE_CANTOPEN );  rc = SQLITE_OK;  }  pFile->ctrlFlags &= ~UNIXFILE_DIRSYNC;  }  return rc; } static int unixTruncate(sqlite3_file *id, i64 nByte){  unixFile *pFile = (unixFile *)id;  int rc;  assert( pFile );  SimulateIOError( return SQLITE_IOERR_TRUNCATE );  if( pFile->szChunk>0 ){  nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;  }  rc = robust_ftruncate(pFile->h, nByte);  if( rc ){  storeLastErrno(pFile, errno);  return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);  }else{
#ifdef SQLITE_DEBUG
 if( pFile->inNormalWrite && nByte==0 ){  pFile->transCntrChng = 1;  }
#endif
#if SQLITE_MAX_MMAP_SIZE>0
 if( nByte<pFile->mmapSize ){  pFile->mmapSize = nByte;  }
#endif
 return SQLITE_OK;  } } static int unixFileSize(sqlite3_file *id, i64 *pSize){  int rc;  struct stat buf;  assert( id );  rc = osFstat(((unixFile*)id)->h, &buf);  SimulateIOError( rc=1 );  if( rc!=0 ){  storeLastErrno((unixFile*)id, errno);  return SQLITE_IOERR_FSTAT;  }  *pSize = buf.st_size;  if( *pSize==1 ) *pSize = 0;  return SQLITE_OK; }
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
static int proxyFileControl(sqlite3_file*,int,void*);
#endif
static int fcntlSizeHint(unixFile *pFile, i64 nByte){  if( pFile->szChunk>0 ){  i64 nSize;  struct stat buf;  if( osFstat(pFile->h, &buf) ){  return SQLITE_IOERR_FSTAT;  }  nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;  if( nSize>(i64)buf.st_size ){
#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE
 int err;  do{  err = osFallocate(pFile->h, buf.st_size, nSize-buf.st_size);  }while( err==EINTR );  if( err && err!=EINVAL ) return SQLITE_IOERR_WRITE;
#else
 int nBlk = buf.st_blksize;  int nWrite = 0;  i64 iWrite;  iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;  assert( iWrite>=buf.st_size );  assert( ((iWrite+1)%nBlk)==0 );  for(; iWrite<nSize+nBlk-1; iWrite+=nBlk ){  if( iWrite>=nSize ) iWrite = nSize - 1;  nWrite = seekAndWrite(pFile, iWrite, "", 1);  if( nWrite!=1 ) return SQLITE_IOERR_WRITE;  }
#endif
 }  }
#if SQLITE_MAX_MMAP_SIZE>0
 if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){  int rc;  if( pFile->szChunk<=0 ){  if( robust_ftruncate(pFile->h, nByte) ){  storeLastErrno(pFile, errno);  return unixLogError(SQLITE_IOERR_TRUNCATE, "ftruncate", pFile->zPath);  }  }  rc = unixMapfile(pFile, nByte);  return rc;  }
#endif
 return SQLITE_OK; } static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){  if( *pArg<0 ){  *pArg = (pFile->ctrlFlags & mask)!=0;  }else if( (*pArg)==0 ){  pFile->ctrlFlags &= ~mask;  }else{  pFile->ctrlFlags |= mask;  } } static int unixGetTempname(int nBuf, char *zBuf);
#ifndef SQLITE_OMIT_WAL
 static int unixFcntlExternalReader(unixFile*, int*);
#endif
static int unixFileControl(sqlite3_file *id, int op, void *pArg){  unixFile *pFile = (unixFile*)id;  switch( op ){
#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
 case SQLITE_FCNTL_BEGIN_ATOMIC_WRITE: {  int rc = osIoctl(pFile->h, F2FS_IOC_START_ATOMIC_WRITE);  return rc ? SQLITE_IOERR_BEGIN_ATOMIC : SQLITE_OK;  }  case SQLITE_FCNTL_COMMIT_ATOMIC_WRITE: {  int rc = osIoctl(pFile->h, F2FS_IOC_COMMIT_ATOMIC_WRITE);  return rc ? SQLITE_IOERR_COMMIT_ATOMIC : SQLITE_OK;  }  case SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE: {  int rc = osIoctl(pFile->h, F2FS_IOC_ABORT_VOLATILE_WRITE);  return rc ? SQLITE_IOERR_ROLLBACK_ATOMIC : SQLITE_OK;  }
#endif
 case SQLITE_FCNTL_LOCKSTATE: {  *(int*)pArg = pFile->eFileLock;  return SQLITE_OK;  }  case SQLITE_FCNTL_LAST_ERRNO: {  *(int*)pArg = pFile->lastErrno;  return SQLITE_OK;  }  case SQLITE_FCNTL_CHUNK_SIZE: {  pFile->szChunk = *(int *)pArg;  return SQLITE_OK;  }  case SQLITE_FCNTL_SIZE_HINT: {  int rc;  SimulateIOErrorBenign(1);  rc = fcntlSizeHint(pFile, *(i64 *)pArg);  SimulateIOErrorBenign(0);  return rc;  }  case SQLITE_FCNTL_PERSIST_WAL: {  unixModeBit(pFile, UNIXFILE_PERSIST_WAL, (int*)pArg);  return SQLITE_OK;  }  case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {  unixModeBit(pFile, UNIXFILE_PSOW, (int*)pArg);  return SQLITE_OK;  }  case SQLITE_FCNTL_VFSNAME: {  *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);  return SQLITE_OK;  }  case SQLITE_FCNTL_TEMPFILENAME: {  char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );  if( zTFile ){  unixGetTempname(pFile->pVfs->mxPathname, zTFile);  *(char**)pArg = zTFile;  }  return SQLITE_OK;  }  case SQLITE_FCNTL_HAS_MOVED: {  *(int*)pArg = fileHasMoved(pFile);  return SQLITE_OK;  }
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 case SQLITE_FCNTL_LOCK_TIMEOUT: {  int iOld = pFile->iBusyTimeout;  pFile->iBusyTimeout = *(int*)pArg;  *(int*)pArg = iOld;  return SQLITE_OK;  }
#endif
#if SQLITE_MAX_MMAP_SIZE>0
 case SQLITE_FCNTL_MMAP_SIZE: {  i64 newLimit = *(i64*)pArg;  int rc = SQLITE_OK;  if( newLimit>sqlite3GlobalConfig.mxMmap ){  newLimit = sqlite3GlobalConfig.mxMmap;  }  if( newLimit>0 && sizeof(size_t)<8 ){  newLimit = (newLimit & 0x7FFFFFFF);  }  *(i64*)pArg = pFile->mmapSizeMax;  if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){  pFile->mmapSizeMax = newLimit;  if( pFile->mmapSize>0 ){  unixUnmapfile(pFile);  rc = unixMapfile(pFile, -1);  }  }  return rc;  }
#endif
#ifdef SQLITE_DEBUG
 case SQLITE_FCNTL_DB_UNCHANGED: {  ((unixFile*)id)->dbUpdate = 0;  return SQLITE_OK;  }
#endif
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
 case SQLITE_FCNTL_SET_LOCKPROXYFILE:  case SQLITE_FCNTL_GET_LOCKPROXYFILE: {  return proxyFileControl(id,op,pArg);  }
#endif
 case SQLITE_FCNTL_EXTERNAL_READER: {
#ifndef SQLITE_OMIT_WAL
 return unixFcntlExternalReader((unixFile*)id, (int*)pArg);
#else
 *(int*)pArg = 0;  return SQLITE_OK;
#endif
 }  }  return SQLITE_NOTFOUND; }
#ifndef __QNXNTO__
static void setDeviceCharacteristics(unixFile *pFd){  assert( pFd->deviceCharacteristics==0 || pFd->sectorSize!=0 );  if( pFd->sectorSize==0 ){
#if defined(__linux__) && defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)
 int res;  u32 f = 0;  res = osIoctl(pFd->h, F2FS_IOC_GET_FEATURES, &f);  if( res==0 && (f & F2FS_FEATURE_ATOMIC_WRITE) ){  pFd->deviceCharacteristics = SQLITE_IOCAP_BATCH_ATOMIC;  }
#endif
 if( pFd->ctrlFlags & UNIXFILE_PSOW ){  pFd->deviceCharacteristics |= SQLITE_IOCAP_POWERSAFE_OVERWRITE;  }  pFd->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;  } }
#else
#include <sys/dcmd_blk.h>
#include <sys/statvfs.h>
static void setDeviceCharacteristics(unixFile *pFile){  if( pFile->sectorSize == 0 ){  struct statvfs fsInfo;  pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;  pFile->deviceCharacteristics = 0;  if( fstatvfs(pFile->h, &fsInfo) == -1 ) {  return;  }  if( !strcmp(fsInfo.f_basetype, "tmp") ) {  pFile->sectorSize = fsInfo.f_bsize;  pFile->deviceCharacteristics =  SQLITE_IOCAP_ATOMIC4K |  SQLITE_IOCAP_SAFE_APPEND |  SQLITE_IOCAP_SEQUENTIAL |  0;  }else if( strstr(fsInfo.f_basetype, "etfs") ){  pFile->sectorSize = fsInfo.f_bsize;  pFile->deviceCharacteristics =  (pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) |  SQLITE_IOCAP_SAFE_APPEND |  SQLITE_IOCAP_SEQUENTIAL |  0;  }else if( !strcmp(fsInfo.f_basetype, "qnx6") ){  pFile->sectorSize = fsInfo.f_bsize;  pFile->deviceCharacteristics =  SQLITE_IOCAP_ATOMIC |  SQLITE_IOCAP_SAFE_APPEND |  SQLITE_IOCAP_SEQUENTIAL |  0;  }else if( !strcmp(fsInfo.f_basetype, "qnx4") ){  pFile->sectorSize = fsInfo.f_bsize;  pFile->deviceCharacteristics =  ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |  SQLITE_IOCAP_SEQUENTIAL |  0;  }else if( strstr(fsInfo.f_basetype, "dos") ){  pFile->sectorSize = fsInfo.f_bsize;  pFile->deviceCharacteristics =  ((pFile->sectorSize / 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |  SQLITE_IOCAP_SEQUENTIAL |  0;  }else{  pFile->deviceCharacteristics =  SQLITE_IOCAP_ATOMIC512 |  SQLITE_IOCAP_SAFE_APPEND |  0;  }  }  if( pFile->sectorSize % 512 != 0 ){  pFile->deviceCharacteristics = 0;  pFile->sectorSize = SQLITE_DEFAULT_SECTOR_SIZE;  } }
#endif
static int unixSectorSize(sqlite3_file *id){  unixFile *pFd = (unixFile*)id;  setDeviceCharacteristics(pFd);  return pFd->sectorSize; } static int unixDeviceCharacteristics(sqlite3_file *id){  unixFile *pFd = (unixFile*)id;  setDeviceCharacteristics(pFd);  return pFd->deviceCharacteristics; }
#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
static int unixGetpagesize(void){
#if OS_VXWORKS
 return 1024;
#elif defined(_BSD_SOURCE)
 return getpagesize();
#else
 return (int)sysconf(_SC_PAGESIZE);
#endif
}
#endif
#ifndef SQLITE_OMIT_WAL
struct unixShmNode {  unixInodeInfo *pInode;  sqlite3_mutex *pShmMutex;  char *zFilename;  int hShm;  int szRegion;  u16 nRegion;  u8 isReadonly;  u8 isUnlocked;  char **apRegion;  int nRef;  unixShm *pFirst;  int aLock[SQLITE_SHM_NLOCK];
#ifdef SQLITE_DEBUG
 u8 exclMask;  u8 sharedMask;  u8 nextShmId;
#endif
}; struct unixShm {  unixShmNode *pShmNode;  unixShm *pNext;  u8 hasMutex;  u8 id;  u16 sharedMask;  u16 exclMask; };
#define UNIX_SHM_BASE  ((22+SQLITE_SHM_NLOCK)*4)
#define UNIX_SHM_DMS (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)
static int unixFcntlExternalReader(unixFile *pFile, int *piOut){  int rc = SQLITE_OK;  *piOut = 0;  if( pFile->pShm){  unixShmNode *pShmNode = pFile->pShm->pShmNode;  struct flock f;  memset(&f, 0, sizeof(f));  f.l_type = F_WRLCK;  f.l_whence = SEEK_SET;  f.l_start = UNIX_SHM_BASE + 3;  f.l_len = SQLITE_SHM_NLOCK - 3;  sqlite3_mutex_enter(pShmNode->pShmMutex);  if( osFcntl(pShmNode->hShm, F_GETLK, &f)<0 ){  rc = SQLITE_IOERR_LOCK;  }else{  *piOut = (f.l_type!=F_UNLCK);  }  sqlite3_mutex_leave(pShmNode->pShmMutex);  }  return rc; } static int unixShmSystemLock(  unixFile *pFile,  int lockType,  int ofst,  int n ){  unixShmNode *pShmNode;  struct flock f;  int rc = SQLITE_OK;  pShmNode = pFile->pInode->pShmNode;  assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->pShmMutex) );  assert( pShmNode->nRef>0 || unixMutexHeld() );  assert( n==1 || lockType!=F_RDLCK );  assert( n>=1 && n<=SQLITE_SHM_NLOCK );  if( pShmNode->hShm>=0 ){  int res;  f.l_type = lockType;  f.l_whence = SEEK_SET;  f.l_start = ofst;  f.l_len = n;  res = osSetPosixAdvisoryLock(pShmNode->hShm, &f, pFile);  if( res==-1 ){
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 rc = (pFile->iBusyTimeout ? SQLITE_BUSY_TIMEOUT : SQLITE_BUSY);
#else
 rc = SQLITE_BUSY;
#endif
 }  }
#ifdef SQLITE_DEBUG
 { u16 mask;  OSTRACE(("SHM-LOCK "));  mask = ofst>31 ? 0xffff : (1<<(ofst+n)) - (1<<ofst);  if( rc==SQLITE_OK ){  if( lockType==F_UNLCK ){  OSTRACE(("unlock %d ok", ofst));  pShmNode->exclMask &= ~mask;  pShmNode->sharedMask &= ~mask;  }else if( lockType==F_RDLCK ){  OSTRACE(("read-lock %d ok", ofst));  pShmNode->exclMask &= ~mask;  pShmNode->sharedMask |= mask;  }else{  assert( lockType==F_WRLCK );  OSTRACE(("write-lock %d ok", ofst));  pShmNode->exclMask |= mask;  pShmNode->sharedMask &= ~mask;  }  }else{  if( lockType==F_UNLCK ){  OSTRACE(("unlock %d failed", ofst));  }else if( lockType==F_RDLCK ){  OSTRACE(("read-lock failed"));  }else{  assert( lockType==F_WRLCK );  OSTRACE(("write-lock %d failed", ofst));  }  }  OSTRACE((" - afterwards %03x,%03x\n",   pShmNode->sharedMask, pShmNode->exclMask));  }
#endif
 return rc; } static int unixShmRegionPerMap(void){  int shmsz = 32*1024;  int pgsz = osGetpagesize();  assert( ((pgsz-1)&pgsz)==0 );  if( pgsz<shmsz ) return 1;  return pgsz/shmsz; } static void unixShmPurge(unixFile *pFd){  unixShmNode *p = pFd->pInode->pShmNode;  assert( unixMutexHeld() );  if( p && ALWAYS(p->nRef==0) ){  int nShmPerMap = unixShmRegionPerMap();  int i;  assert( p->pInode==pFd->pInode );  sqlite3_mutex_free(p->pShmMutex);  for(i=0; i<p->nRegion; i+=nShmPerMap){  if( p->hShm>=0 ){  osMunmap(p->apRegion[i], p->szRegion);  }else{  sqlite3_free(p->apRegion[i]);  }  }  sqlite3_free(p->apRegion);  if( p->hShm>=0 ){  robust_close(pFd, p->hShm, __LINE__);  p->hShm = -1;  }  p->pInode->pShmNode = 0;  sqlite3_free(p);  } } static int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){  struct flock lock;  int rc = SQLITE_OK;  lock.l_whence = SEEK_SET;  lock.l_start = UNIX_SHM_DMS;  lock.l_len = 1;  lock.l_type = F_WRLCK;  if( osFcntl(pShmNode->hShm, F_GETLK, &lock)!=0 ) {  rc = SQLITE_IOERR_LOCK;  }else if( lock.l_type==F_UNLCK ){  if( pShmNode->isReadonly ){  pShmNode->isUnlocked = 1;  rc = SQLITE_READONLY_CANTINIT;  }else{  rc = unixShmSystemLock(pDbFd, F_WRLCK, UNIX_SHM_DMS, 1);  if( rc==SQLITE_OK && robust_ftruncate(pShmNode->hShm, 3) ){  rc = unixLogError(SQLITE_IOERR_SHMOPEN,"ftruncate",pShmNode->zFilename);  }  }  }else if( lock.l_type==F_WRLCK ){  rc = SQLITE_BUSY;  }  if( rc==SQLITE_OK ){  assert( lock.l_type==F_UNLCK || lock.l_type==F_RDLCK );  rc = unixShmSystemLock(pDbFd, F_RDLCK, UNIX_SHM_DMS, 1);  }  return rc; } static int unixOpenSharedMemory(unixFile *pDbFd){  struct unixShm *p = 0;  struct unixShmNode *pShmNode;  int rc = SQLITE_OK;  unixInodeInfo *pInode;  char *zShm;  int nShmFilename;  p = sqlite3_malloc64( sizeof(*p) );  if( p==0 ) return SQLITE_NOMEM_BKPT;  memset(p, 0, sizeof(*p));  assert( pDbFd->pShm==0 );  assert( unixFileMutexNotheld(pDbFd) );  unixEnterMutex();  pInode = pDbFd->pInode;  pShmNode = pInode->pShmNode;  if( pShmNode==0 ){  struct stat sStat;
#ifndef SQLITE_SHM_DIRECTORY
 const char *zBasePath = pDbFd->zPath;
#endif
 if( osFstat(pDbFd->h, &sStat) ){  rc = SQLITE_IOERR_FSTAT;  goto shm_open_err;  }
#ifdef SQLITE_SHM_DIRECTORY
 nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 31;
#else
 nShmFilename = 6 + (int)strlen(zBasePath);
#endif
 pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );  if( pShmNode==0 ){  rc = SQLITE_NOMEM_BKPT;  goto shm_open_err;  }  memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);  zShm = pShmNode->zFilename = (char*)&pShmNode[1];
#ifdef SQLITE_SHM_DIRECTORY
 sqlite3_snprintf(nShmFilename, zShm,   SQLITE_SHM_DIRECTORY "/sqlite-shm-%x-%x",   (u32)sStat.st_ino, (u32)sStat.st_dev);
#else
 sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);  sqlite3FileSuffix3(pDbFd->zPath, zShm);
#endif
 pShmNode->hShm = -1;  pDbFd->pInode->pShmNode = pShmNode;  pShmNode->pInode = pDbFd->pInode;  if( sqlite3GlobalConfig.bCoreMutex ){  pShmNode->pShmMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);  if( pShmNode->pShmMutex==0 ){  rc = SQLITE_NOMEM_BKPT;  goto shm_open_err;  }  }  if( pInode->bProcessLock==0 ){  if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){  pShmNode->hShm = robust_open(zShm, O_RDWR|O_CREAT|O_NOFOLLOW,   (sStat.st_mode&0777));  }  if( pShmNode->hShm<0 ){  pShmNode->hShm = robust_open(zShm, O_RDONLY|O_NOFOLLOW,   (sStat.st_mode&0777));  if( pShmNode->hShm<0 ){  rc = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zShm);  goto shm_open_err;  }  pShmNode->isReadonly = 1;  }  robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);  rc = unixLockSharedMemory(pDbFd, pShmNode);  if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;  }  }  p->pShmNode = pShmNode;
#ifdef SQLITE_DEBUG
 p->id = pShmNode->nextShmId++;
#endif
 pShmNode->nRef++;  pDbFd->pShm = p;  unixLeaveMutex();  sqlite3_mutex_enter(pShmNode->pShmMutex);  p->pNext = pShmNode->pFirst;  pShmNode->pFirst = p;  sqlite3_mutex_leave(pShmNode->pShmMutex);  return rc; shm_open_err:  unixShmPurge(pDbFd);  sqlite3_free(p);  unixLeaveMutex();  return rc; } static int unixShmMap(  sqlite3_file *fd,  int iRegion,  int szRegion,  int bExtend,  void volatile **pp ){  unixFile *pDbFd = (unixFile*)fd;  unixShm *p;  unixShmNode *pShmNode;  int rc = SQLITE_OK;  int nShmPerMap = unixShmRegionPerMap();  int nReqRegion;  if( pDbFd->pShm==0 ){  rc = unixOpenSharedMemory(pDbFd);  if( rc!=SQLITE_OK ) return rc;  }  p = pDbFd->pShm;  pShmNode = p->pShmNode;  sqlite3_mutex_enter(pShmNode->pShmMutex);  if( pShmNode->isUnlocked ){  rc = unixLockSharedMemory(pDbFd, pShmNode);  if( rc!=SQLITE_OK ) goto shmpage_out;  pShmNode->isUnlocked = 0;  }  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );  assert( pShmNode->pInode==pDbFd->pInode );  assert( pShmNode->hShm>=0 || pDbFd->pInode->bProcessLock==1 );  assert( pShmNode->hShm<0 || pDbFd->pInode->bProcessLock==0 );  nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;  if( pShmNode->nRegion<nReqRegion ){  char **apNew;  int nByte = nReqRegion*szRegion;  struct stat sStat;  pShmNode->szRegion = szRegion;  if( pShmNode->hShm>=0 ){  if( osFstat(pShmNode->hShm, &sStat) ){  rc = SQLITE_IOERR_SHMSIZE;  goto shmpage_out;  }  if( sStat.st_size<nByte ){  if( !bExtend ){  goto shmpage_out;  }  else{  static const int pgsz = 4096;  int iPg;  assert( (nByte % pgsz)==0 );  for(iPg=(sStat.st_size/pgsz); iPg<(nByte/pgsz); iPg++){  int x = 0;  if( seekAndWriteFd(pShmNode->hShm, iPg*pgsz + pgsz-1,"",1,&x)!=1 ){  const char *zFile = pShmNode->zFilename;  rc = unixLogError(SQLITE_IOERR_SHMSIZE, "write", zFile);  goto shmpage_out;  }  }  }  }  }  apNew = (char **)sqlite3_realloc(  pShmNode->apRegion, nReqRegion*sizeof(char *)  );  if( !apNew ){  rc = SQLITE_IOERR_NOMEM_BKPT;  goto shmpage_out;  }  pShmNode->apRegion = apNew;  while( pShmNode->nRegion<nReqRegion ){  int nMap = szRegion*nShmPerMap;  int i;  void *pMem;  if( pShmNode->hShm>=0 ){  pMem = osMmap(0, nMap,  pShmNode->isReadonly ? PROT_READ : PROT_READ|PROT_WRITE,  MAP_SHARED, pShmNode->hShm, szRegion*(i64)pShmNode->nRegion  );  if( pMem==MAP_FAILED ){  rc = unixLogError(SQLITE_IOERR_SHMMAP, "mmap", pShmNode->zFilename);  goto shmpage_out;  }  }else{  pMem = sqlite3_malloc64(nMap);  if( pMem==0 ){  rc = SQLITE_NOMEM_BKPT;  goto shmpage_out;  }  memset(pMem, 0, nMap);  }  for(i=0; i<nShmPerMap; i++){  pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];  }  pShmNode->nRegion += nShmPerMap;  }  } shmpage_out:  if( pShmNode->nRegion>iRegion ){  *pp = pShmNode->apRegion[iRegion];  }else{  *pp = 0;  }  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;  sqlite3_mutex_leave(pShmNode->pShmMutex);  return rc; }
#ifdef SQLITE_DEBUG
static int assertLockingArrayOk(unixShmNode *pShmNode){  unixShm *pX;  int aLock[SQLITE_SHM_NLOCK];  assert( sqlite3_mutex_held(pShmNode->pShmMutex) );  memset(aLock, 0, sizeof(aLock));  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){  int i;  for(i=0; i<SQLITE_SHM_NLOCK; i++){  if( pX->exclMask & (1<<i) ){  assert( aLock[i]==0 );  aLock[i] = -1;  }else if( pX->sharedMask & (1<<i) ){  assert( aLock[i]>=0 );  aLock[i]++;  }  }  }  assert( 0==memcmp(pShmNode->aLock, aLock, sizeof(aLock)) );  return (memcmp(pShmNode->aLock, aLock, sizeof(aLock))==0); }
#endif
static int unixShmLock(  sqlite3_file *fd,  int ofst,  int n,  int flags ){  unixFile *pDbFd = (unixFile*)fd;  unixShm *p = pDbFd->pShm;  unixShmNode *pShmNode = p->pShmNode;  int rc = SQLITE_OK;  u16 mask;  int *aLock = pShmNode->aLock;  assert( pShmNode==pDbFd->pInode->pShmNode );  assert( pShmNode->pInode==pDbFd->pInode );  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );  assert( n>=1 );  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)   || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)   || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)   || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );  assert( pShmNode->hShm>=0 || pDbFd->pInode->bProcessLock==1 );  assert( pShmNode->hShm<0 || pDbFd->pInode->bProcessLock==0 );
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 assert( (flags & SQLITE_SHM_UNLOCK) || pDbFd->iBusyTimeout==0 || (   (ofst!=2)  && (ofst!=1 || (p->exclMask|p->sharedMask)==0)  && (ofst!=0 || (p->exclMask|p->sharedMask)<3)  && (ofst<3 || (p->exclMask|p->sharedMask)<(1<<ofst))  ));
#endif
 mask = (1<<(ofst+n)) - (1<<ofst);  assert( n>1 || mask==(1<<ofst) );  sqlite3_mutex_enter(pShmNode->pShmMutex);  assert( assertLockingArrayOk(pShmNode) );  if( flags & SQLITE_SHM_UNLOCK ){  if( (p->exclMask|p->sharedMask) & mask ){  int ii;  int bUnlock = 1;  for(ii=ofst; ii<ofst+n; ii++){  if( aLock[ii]>((p->sharedMask & (1<<ii)) ? 1 : 0) ){  bUnlock = 0;  }  }  if( bUnlock ){  rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);  if( rc==SQLITE_OK ){  memset(&aLock[ofst], 0, sizeof(int)*n);  }  }else if( ALWAYS(p->sharedMask & (1<<ofst)) ){  assert( n==1 && aLock[ofst]>1 );  aLock[ofst]--;  }  if( rc==SQLITE_OK ){  p->exclMask &= ~mask;  p->sharedMask &= ~mask;  }  }  }else if( flags & SQLITE_SHM_SHARED ){  assert( n==1 );  assert( (p->exclMask & (1<<ofst))==0 );  if( (p->sharedMask & mask)==0 ){  if( aLock[ofst]<0 ){  rc = SQLITE_BUSY;  }else if( aLock[ofst]==0 ){  rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);  }  if( rc==SQLITE_OK ){  p->sharedMask |= mask;  aLock[ofst]++;  }  }  }else{  int ii;  for(ii=ofst; ii<ofst+n; ii++){  assert( (p->sharedMask & mask)==0 );  if( ALWAYS((p->exclMask & (1<<ii))==0) && aLock[ii] ){  rc = SQLITE_BUSY;  break;  }  }  if( rc==SQLITE_OK ){  rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);  if( rc==SQLITE_OK ){  assert( (p->sharedMask & mask)==0 );  p->exclMask |= mask;  for(ii=ofst; ii<ofst+n; ii++){  aLock[ii] = -1;  }  }  }  }  assert( assertLockingArrayOk(pShmNode) );  sqlite3_mutex_leave(pShmNode->pShmMutex);  OSTRACE(("SHM-LOCK shmid-%d, pid-%d got %03x,%03x\n",   p->id, osGetpid(0), p->sharedMask, p->exclMask));  return rc; } static void unixShmBarrier(  sqlite3_file *fd ){  UNUSED_PARAMETER(fd);  sqlite3MemoryBarrier();  assert( fd->pMethods->xLock==nolockLock   || unixFileMutexNotheld((unixFile*)fd)  );  unixEnterMutex();  unixLeaveMutex(); } static int unixShmUnmap(  sqlite3_file *fd,  int deleteFlag ){  unixShm *p;  unixShmNode *pShmNode;  unixShm **pp;  unixFile *pDbFd;  pDbFd = (unixFile*)fd;  p = pDbFd->pShm;  if( p==0 ) return SQLITE_OK;  pShmNode = p->pShmNode;  assert( pShmNode==pDbFd->pInode->pShmNode );  assert( pShmNode->pInode==pDbFd->pInode );  sqlite3_mutex_enter(pShmNode->pShmMutex);  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}  *pp = p->pNext;  sqlite3_free(p);  pDbFd->pShm = 0;  sqlite3_mutex_leave(pShmNode->pShmMutex);  assert( unixFileMutexNotheld(pDbFd) );  unixEnterMutex();  assert( pShmNode->nRef>0 );  pShmNode->nRef--;  if( pShmNode->nRef==0 ){  if( deleteFlag && pShmNode->hShm>=0 ){  osUnlink(pShmNode->zFilename);  }  unixShmPurge(pDbFd);  }  unixLeaveMutex();  return SQLITE_OK; }
#else
# define unixShmMap  0
# define unixShmLock 0
# define unixShmBarrier 0
# define unixShmUnmap  0
#endif
#if SQLITE_MAX_MMAP_SIZE>0
static void unixUnmapfile(unixFile *pFd){  assert( pFd->nFetchOut==0 );  if( pFd->pMapRegion ){  osMunmap(pFd->pMapRegion, pFd->mmapSizeActual);  pFd->pMapRegion = 0;  pFd->mmapSize = 0;  pFd->mmapSizeActual = 0;  } } static void unixRemapfile(  unixFile *pFd,  i64 nNew ){  const char *zErr = "mmap";  int h = pFd->h;  u8 *pOrig = (u8 *)pFd->pMapRegion;  i64 nOrig = pFd->mmapSizeActual;  u8 *pNew = 0;  int flags = PROT_READ;  assert( pFd->nFetchOut==0 );  assert( nNew>pFd->mmapSize );  assert( nNew<=pFd->mmapSizeMax );  assert( nNew>0 );  assert( pFd->mmapSizeActual>=pFd->mmapSize );  assert( MAP_FAILED!=0 );
#ifdef SQLITE_MMAP_READWRITE
 if( (pFd->ctrlFlags & UNIXFILE_RDONLY)==0 ) flags |= PROT_WRITE;
#endif
 if( pOrig ){
#if HAVE_MREMAP
 i64 nReuse = pFd->mmapSize;
#else
 const int szSyspage = osGetpagesize();  i64 nReuse = (pFd->mmapSize & ~(szSyspage-1));
#endif
 u8 *pReq = &pOrig[nReuse];  if( nReuse!=nOrig ){  osMunmap(pReq, nOrig-nReuse);  }
#if HAVE_MREMAP
 pNew = osMremap(pOrig, nReuse, nNew, MREMAP_MAYMOVE);  zErr = "mremap";
#else
 pNew = osMmap(pReq, nNew-nReuse, flags, MAP_SHARED, h, nReuse);  if( pNew!=MAP_FAILED ){  if( pNew!=pReq ){  osMunmap(pNew, nNew - nReuse);  pNew = 0;  }else{  pNew = pOrig;  }  }
#endif
 if( pNew==MAP_FAILED || pNew==0 ){  osMunmap(pOrig, nReuse);  }  }  if( pNew==0 ){  pNew = osMmap(0, nNew, flags, MAP_SHARED, h, 0);  }  if( pNew==MAP_FAILED ){  pNew = 0;  nNew = 0;  unixLogError(SQLITE_OK, zErr, pFd->zPath);  pFd->mmapSizeMax = 0;  }  pFd->pMapRegion = (void *)pNew;  pFd->mmapSize = pFd->mmapSizeActual = nNew; } static int unixMapfile(unixFile *pFd, i64 nMap){  assert( nMap>=0 || pFd->nFetchOut==0 );  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );  if( pFd->nFetchOut>0 ) return SQLITE_OK;  if( nMap<0 ){  struct stat statbuf;  if( osFstat(pFd->h, &statbuf) ){  return SQLITE_IOERR_FSTAT;  }  nMap = statbuf.st_size;  }  if( nMap>pFd->mmapSizeMax ){  nMap = pFd->mmapSizeMax;  }  assert( nMap>0 || (pFd->mmapSize==0 && pFd->pMapRegion==0) );  if( nMap!=pFd->mmapSize ){  unixRemapfile(pFd, nMap);  }  return SQLITE_OK; }
#endif
static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){
#if SQLITE_MAX_MMAP_SIZE>0
 unixFile *pFd = (unixFile *)fd;
#endif
 *pp = 0;
#if SQLITE_MAX_MMAP_SIZE>0
 if( pFd->mmapSizeMax>0 ){  if( pFd->pMapRegion==0 ){  int rc = unixMapfile(pFd, -1);  if( rc!=SQLITE_OK ) return rc;  }  if( pFd->mmapSize >= iOff+nAmt ){  *pp = &((u8 *)pFd->pMapRegion)[iOff];  pFd->nFetchOut++;  }  }
#endif
 return SQLITE_OK; } static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){
#if SQLITE_MAX_MMAP_SIZE>0
 unixFile *pFd = (unixFile *)fd;  UNUSED_PARAMETER(iOff);  assert( (p==0)==(pFd->nFetchOut==0) );  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] );  if( p ){  pFd->nFetchOut--;  }else{  unixUnmapfile(pFd);  }  assert( pFd->nFetchOut>=0 );
#else
 UNUSED_PARAMETER(fd);  UNUSED_PARAMETER(p);  UNUSED_PARAMETER(iOff);
#endif
 return SQLITE_OK; }
#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP)  static const sqlite3_io_methods METHOD = {    VERSION,   CLOSE,   unixRead,   unixWrite,   unixTruncate,   unixSync,   unixFileSize,   LOCK,   UNLOCK,   CKLOCK,   unixFileControl,   unixSectorSize,   unixDeviceCharacteristics,   SHMMAP,   unixShmLock,   unixShmBarrier,   unixShmUnmap,   unixFetch,   unixUnfetch, };  static const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);  return &METHOD; } static const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)  = FINDER##Impl;

IOMETHODS(  posixIoFinder,  posixIoMethods,  3,  unixClose,  unixLock,  unixUnlock,  unixCheckReservedLock,  unixShmMap ) IOMETHODS(  nolockIoFinder,  nolockIoMethods,  3,  nolockClose,  nolockLock,  nolockUnlock,  nolockCheckReservedLock,  0 ) IOMETHODS(  dotlockIoFinder,  dotlockIoMethods,  1,  dotlockClose,  dotlockLock,  dotlockUnlock,  dotlockCheckReservedLock,  0 )
#if SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(  flockIoFinder,  flockIoMethods,  1,  flockClose,  flockLock,  flockUnlock,  flockCheckReservedLock,  0 )
#endif
#if OS_VXWORKS
IOMETHODS(  semIoFinder,  semIoMethods,  1,  semXClose,  semXLock,  semXUnlock,  semXCheckReservedLock,  0 )
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(  afpIoFinder,  afpIoMethods,  1,  afpClose,  afpLock,  afpUnlock,  afpCheckReservedLock,  0 )
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
static int proxyClose(sqlite3_file*); static int proxyLock(sqlite3_file*, int); static int proxyUnlock(sqlite3_file*, int); static int proxyCheckReservedLock(sqlite3_file*, int*); IOMETHODS(  proxyIoFinder,  proxyIoMethods,  1,  proxyClose,  proxyLock,  proxyUnlock,  proxyCheckReservedLock,  0 )
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
IOMETHODS(  nfsIoFinder,  nfsIoMethods,  1,  unixClose,  unixLock,  nfsUnlock,  unixCheckReservedLock,  0 )
#endif
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
static const sqlite3_io_methods *autolockIoFinderImpl(  const char *filePath,  unixFile *pNew ){  static const struct Mapping {  const char *zFilesystem;  const sqlite3_io_methods *pMethods;  } aMap[] = {  { "hfs", &posixIoMethods },  { "ufs", &posixIoMethods },  { "afpfs", &afpIoMethods },  { "smbfs", &afpIoMethods },  { "webdav", &nolockIoMethods },  { 0, 0 }  };  int i;  struct statfs fsInfo;  struct flock lockInfo;  if( !filePath ){  return &nolockIoMethods;  }  if( statfs(filePath, &fsInfo) != -1 ){  if( fsInfo.f_flags & MNT_RDONLY ){  return &nolockIoMethods;  }  for(i=0; aMap[i].zFilesystem; i++){  if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){  return aMap[i].pMethods;  }  }  }  lockInfo.l_len = 1;  lockInfo.l_start = 0;  lockInfo.l_whence = SEEK_SET;  lockInfo.l_type = F_RDLCK;  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {  if( strcmp(fsInfo.f_fstypename, "nfs")==0 ){  return &nfsIoMethods;  } else {  return &posixIoMethods;  }  }else{  return &dotlockIoMethods;  } } static const sqlite3_io_methods  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;
#endif
#if OS_VXWORKS
static const sqlite3_io_methods *vxworksIoFinderImpl(  const char *filePath,  unixFile *pNew ){  struct flock lockInfo;  if( !filePath ){  return &nolockIoMethods;  }  lockInfo.l_len = 1;  lockInfo.l_start = 0;  lockInfo.l_whence = SEEK_SET;  lockInfo.l_type = F_RDLCK;  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {  return &posixIoMethods;  }else{  return &semIoMethods;  } } static const sqlite3_io_methods  *(*const vxworksIoFinder)(const char*,unixFile*) = vxworksIoFinderImpl;
#endif
typedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*); static int fillInUnixFile(  sqlite3_vfs *pVfs,  int h,  sqlite3_file *pId,  const char *zFilename,  int ctrlFlags ){  const sqlite3_io_methods *pLockingStyle;  unixFile *pNew = (unixFile *)pId;  int rc = SQLITE_OK;  assert( pNew->pInode==NULL );  assert( zFilename!=0 || (ctrlFlags & UNIXFILE_NOLOCK)!=0 );  OSTRACE(("OPEN %-3d %s\n", h, zFilename));  pNew->h = h;  pNew->pVfs = pVfs;  pNew->zPath = zFilename;  pNew->ctrlFlags = (u8)ctrlFlags;
#if SQLITE_MAX_MMAP_SIZE>0
 pNew->mmapSizeMax = sqlite3GlobalConfig.szMmap;
#endif
 if( sqlite3_uri_boolean(((ctrlFlags & UNIXFILE_URI) ? zFilename : 0),   "psow", SQLITE_POWERSAFE_OVERWRITE) ){  pNew->ctrlFlags |= UNIXFILE_PSOW;  }  if( strcmp(pVfs->zName,"unix-excl")==0 ){  pNew->ctrlFlags |= UNIXFILE_EXCL;  }
#if OS_VXWORKS
 pNew->pId = vxworksFindFileId(zFilename);  if( pNew->pId==0 ){  ctrlFlags |= UNIXFILE_NOLOCK;  rc = SQLITE_NOMEM_BKPT;  }
#endif
 if( ctrlFlags & UNIXFILE_NOLOCK ){  pLockingStyle = &nolockIoMethods;  }else{  pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);
#if SQLITE_ENABLE_LOCKING_STYLE
 pNew->lockingContext = (void*)zFilename;
#endif
 }  if( pLockingStyle == &posixIoMethods
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
 || pLockingStyle == &nfsIoMethods
#endif
 ){  unixEnterMutex();  rc = findInodeInfo(pNew, &pNew->pInode);  if( rc!=SQLITE_OK ){  robust_close(pNew, h, __LINE__);  h = -1;  }  unixLeaveMutex();  }
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
 else if( pLockingStyle == &afpIoMethods ){  afpLockingContext *pCtx;  pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );  if( pCtx==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  pCtx->dbPath = zFilename;  pCtx->reserved = 0;  srandomdev();  unixEnterMutex();  rc = findInodeInfo(pNew, &pNew->pInode);  if( rc!=SQLITE_OK ){  sqlite3_free(pNew->lockingContext);  robust_close(pNew, h, __LINE__);  h = -1;  }  unixLeaveMutex();  }  }
#endif
 else if( pLockingStyle == &dotlockIoMethods ){  char *zLockFile;  int nFilename;  assert( zFilename!=0 );  nFilename = (int)strlen(zFilename) + 6;  zLockFile = (char *)sqlite3_malloc64(nFilename);  if( zLockFile==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  sqlite3_snprintf(nFilename, zLockFile, "%s" DOTLOCK_SUFFIX, zFilename);  }  pNew->lockingContext = zLockFile;  }
#if OS_VXWORKS
 else if( pLockingStyle == &semIoMethods ){  unixEnterMutex();  rc = findInodeInfo(pNew, &pNew->pInode);  if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){  char *zSemName = pNew->pInode->aSemName;  int n;  sqlite3_snprintf(MAX_PATHNAME, zSemName, "/%s.sem",   pNew->pId->zCanonicalName);  for( n=1; zSemName[n]; n++ )  if( zSemName[n]=='/' ) zSemName[n] = '_';  pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);  if( pNew->pInode->pSem == SEM_FAILED ){  rc = SQLITE_NOMEM_BKPT;  pNew->pInode->aSemName[0] = '\0';  }  }  unixLeaveMutex();  }
#endif
 storeLastErrno(pNew, 0);
#if OS_VXWORKS
 if( rc!=SQLITE_OK ){  if( h>=0 ) robust_close(pNew, h, __LINE__);  h = -1;  osUnlink(zFilename);  pNew->ctrlFlags |= UNIXFILE_DELETE;  }
#endif
 if( rc!=SQLITE_OK ){  if( h>=0 ) robust_close(pNew, h, __LINE__);  }else{  pId->pMethods = pLockingStyle;  OpenCounter(+1);  verifyDbFile(pNew);  }  return rc; } static const char *azTempDirs[] = {  0,  0,  "/var/tmp",  "/usr/tmp",  "/tmp",  "." }; static void unixTempFileInit(void){  azTempDirs[0] = getenv("SQLITE_TMPDIR");  azTempDirs[1] = getenv("TMPDIR"); } static const char *unixTempFileDir(void){  unsigned int i = 0;  struct stat buf;  const char *zDir = sqlite3_temp_directory;  while(1){  if( zDir!=0   && osStat(zDir, &buf)==0   && S_ISDIR(buf.st_mode)   && osAccess(zDir, 03)==0  ){  return zDir;  }  if( i>=sizeof(azTempDirs)/sizeof(azTempDirs[0]) ) break;  zDir = azTempDirs[i++];  }  return 0; } static int unixGetTempname(int nBuf, char *zBuf){  const char *zDir;  int iLimit = 0;  zBuf[0] = 0;  SimulateIOError( return SQLITE_IOERR );  zDir = unixTempFileDir();  if( zDir==0 ) return SQLITE_IOERR_GETTEMPPATH;  do{  u64 r;  sqlite3_randomness(sizeof(r), &r);  assert( nBuf>2 );  zBuf[nBuf-2] = 0;  sqlite3_snprintf(nBuf, zBuf, "%s/"SQLITE_TEMP_FILE_PREFIX"%llx%c",   zDir, r, 0);  if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ) return SQLITE_ERROR;  }while( osAccess(zBuf,0)==0 );  return SQLITE_OK; }
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
static int proxyTransformUnixFile(unixFile*, const char*);
#endif
static UnixUnusedFd *findReusableFd(const char *zPath, int flags){  UnixUnusedFd *pUnused = 0;
#if !OS_VXWORKS
 struct stat sStat;  unixEnterMutex();  if( inodeList!=0 && 0==osStat(zPath, &sStat) ){  unixInodeInfo *pInode;  pInode = inodeList;  while( pInode && (pInode->fileId.dev!=sStat.st_dev   || pInode->fileId.ino!=(u64)sStat.st_ino) ){   pInode = pInode->pNext;  }  if( pInode ){  UnixUnusedFd **pp;  assert( sqlite3_mutex_notheld(pInode->pLockMutex) );  sqlite3_mutex_enter(pInode->pLockMutex);  flags &= (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);  for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));  pUnused = *pp;  if( pUnused ){  *pp = pUnused->pNext;  }  sqlite3_mutex_leave(pInode->pLockMutex);  }  }  unixLeaveMutex();
#endif
 return pUnused; } static int getFileMode(  const char *zFile,  mode_t *pMode,  uid_t *pUid,  gid_t *pGid ){  struct stat sStat;  int rc = SQLITE_OK;  if( 0==osStat(zFile, &sStat) ){  *pMode = sStat.st_mode & 0777;  *pUid = sStat.st_uid;  *pGid = sStat.st_gid;  }else{  rc = SQLITE_IOERR_FSTAT;  }  return rc; } static int findCreateFileMode(  const char *zPath,  int flags,  mode_t *pMode,  uid_t *pUid,  gid_t *pGid ){  int rc = SQLITE_OK;  *pMode = 0;  *pUid = 0;  *pGid = 0;  if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){  char zDb[MAX_PATHNAME+1];  int nDb;  nDb = sqlite3Strlen30(zPath) - 1;  while( zPath[nDb]!='-' ){  if( nDb==0 || zPath[nDb]=='.' ) return SQLITE_OK;  nDb--;  }  memcpy(zDb, zPath, nDb);  zDb[nDb] = '\0';  rc = getFileMode(zDb, pMode, pUid, pGid);  }else if( flags & SQLITE_OPEN_DELETEONCLOSE ){  *pMode = 0600;  }else if( flags & SQLITE_OPEN_URI ){  const char *z = sqlite3_uri_parameter(zPath, "modeof");  if( z ){  rc = getFileMode(z, pMode, pUid, pGid);  }  }  return rc; } static int unixOpen(  sqlite3_vfs *pVfs,  const char *zPath,  sqlite3_file *pFile,  int flags,  int *pOutFlags ){  unixFile *p = (unixFile *)pFile;  int fd = -1;  int openFlags = 0;  int eType = flags&0x0FFF00;  int noLock;  int rc = SQLITE_OK;  int ctrlFlags = 0;  int isExclusive = (flags & SQLITE_OPEN_EXCLUSIVE);  int isDelete  = (flags & SQLITE_OPEN_DELETEONCLOSE);  int isCreate  = (flags & SQLITE_OPEN_CREATE);  int isReadonly  = (flags & SQLITE_OPEN_READONLY);  int isReadWrite = (flags & SQLITE_OPEN_READWRITE);
#if SQLITE_ENABLE_LOCKING_STYLE
 int isAutoProxy = (flags & SQLITE_OPEN_AUTOPROXY);
#endif
#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
 struct statfs fsInfo;
#endif
 int isNewJrnl = (isCreate && (  eType==SQLITE_OPEN_SUPER_JOURNAL   || eType==SQLITE_OPEN_MAIN_JOURNAL   || eType==SQLITE_OPEN_WAL  ));  char zTmpname[MAX_PATHNAME+2];  const char *zName = zPath;  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));  assert(isCreate==0 || isReadWrite);  assert(isExclusive==0 || isCreate);  assert(isDelete==0 || isCreate);  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_SUPER_JOURNAL );  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );  assert( eType==SQLITE_OPEN_MAIN_DB || eType==SQLITE_OPEN_TEMP_DB   || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL   || eType==SQLITE_OPEN_SUBJOURNAL  || eType==SQLITE_OPEN_SUPER_JOURNAL   || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL  );  if( randomnessPid!=osGetpid(0) ){  randomnessPid = osGetpid(0);  sqlite3_randomness(0,0);  }  memset(p, 0, sizeof(unixFile));
#ifdef SQLITE_ASSERT_NO_FILES
 assert( zName==0 );
#endif
 if( eType==SQLITE_OPEN_MAIN_DB ){  UnixUnusedFd *pUnused;  pUnused = findReusableFd(zName, flags);  if( pUnused ){  fd = pUnused->fd;  }else{  pUnused = sqlite3_malloc64(sizeof(*pUnused));  if( !pUnused ){  return SQLITE_NOMEM_BKPT;  }  }  p->pPreallocatedUnused = pUnused;  assert( (flags & SQLITE_OPEN_URI) || zName[strlen(zName)+1]==0 );  }else if( !zName ){  assert(isDelete && !isNewJrnl);  rc = unixGetTempname(pVfs->mxPathname, zTmpname);  if( rc!=SQLITE_OK ){  return rc;  }  zName = zTmpname;  assert( zName[strlen(zName)+1]==0 );  }  if( isReadonly ) openFlags |= O_RDONLY;  if( isReadWrite ) openFlags |= O_RDWR;  if( isCreate ) openFlags |= O_CREAT;  if( isExclusive ) openFlags |= (O_EXCL|O_NOFOLLOW);  openFlags |= (O_LARGEFILE|O_BINARY|O_NOFOLLOW);  if( fd<0 ){  mode_t openMode;  uid_t uid;  gid_t gid;  rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);  if( rc!=SQLITE_OK ){  assert( !p->pPreallocatedUnused );  assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );  return rc;  }  fd = robust_open(zName, openFlags, openMode);  OSTRACE(("OPENX  %-3d %s 0%o\n", fd, zName, openFlags));  assert( !isExclusive || (openFlags & O_CREAT)!=0 );  if( fd<0 ){  if( isNewJrnl && errno==EACCES && osAccess(zName, F_OK) ){  rc = SQLITE_READONLY_DIRECTORY;  }else if( errno!=EISDIR && isReadWrite ){  flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);  openFlags &= ~(O_RDWR|O_CREAT);  flags |= SQLITE_OPEN_READONLY;  openFlags |= O_RDONLY;  isReadonly = 1;  fd = robust_open(zName, openFlags, openMode);  }  }  if( fd<0 ){  int rc2 = unixLogError(SQLITE_CANTOPEN_BKPT, "open", zName);  if( rc==SQLITE_OK ) rc = rc2;  goto open_finished;  }  if( openMode && (flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL))!=0 ){  robustFchown(fd, uid, gid);  }  }  assert( fd>=0 );  if( pOutFlags ){  *pOutFlags = flags;  }  if( p->pPreallocatedUnused ){  p->pPreallocatedUnused->fd = fd;  p->pPreallocatedUnused->flags =  flags & (SQLITE_OPEN_READONLY|SQLITE_OPEN_READWRITE);  }  if( isDelete ){
#if OS_VXWORKS
 zPath = zName;
#elif defined(SQLITE_UNLINK_AFTER_CLOSE)
 zPath = sqlite3_mprintf("%s", zName);  if( zPath==0 ){  robust_close(p, fd, __LINE__);  return SQLITE_NOMEM_BKPT;  }
#else
 osUnlink(zName);
#endif
 }
#if SQLITE_ENABLE_LOCKING_STYLE
 else{  p->openFlags = openFlags;  }
#endif
#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE
 if( fstatfs(fd, &fsInfo) == -1 ){  storeLastErrno(p, errno);  robust_close(p, fd, __LINE__);  return SQLITE_IOERR_ACCESS;  }  if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {  ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;  }  if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {  ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;  }
#endif
 if( isDelete ) ctrlFlags |= UNIXFILE_DELETE;  if( isReadonly ) ctrlFlags |= UNIXFILE_RDONLY;  noLock = eType!=SQLITE_OPEN_MAIN_DB;  if( noLock ) ctrlFlags |= UNIXFILE_NOLOCK;  if( isNewJrnl )  ctrlFlags |= UNIXFILE_DIRSYNC;  if( flags & SQLITE_OPEN_URI ) ctrlFlags |= UNIXFILE_URI;
#if SQLITE_ENABLE_LOCKING_STYLE
#if SQLITE_PREFER_PROXY_LOCKING
 isAutoProxy = 1;
#endif
 if( isAutoProxy && (zPath!=NULL) && (!noLock) && pVfs->xOpen ){  char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");  int useProxy = 0;  if( envforce!=NULL ){  useProxy = atoi(envforce)>0;  }else{  useProxy = !(fsInfo.f_flags&MNT_LOCAL);  }  if( useProxy ){  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);  if( rc==SQLITE_OK ){  rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");  if( rc!=SQLITE_OK ){  unixClose(pFile);  return rc;  }  }  goto open_finished;  }  }
#endif
 assert( zPath==0 || zPath[0]=='/'  || eType==SQLITE_OPEN_SUPER_JOURNAL || eType==SQLITE_OPEN_MAIN_JOURNAL  );  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags); open_finished:  if( rc!=SQLITE_OK ){  sqlite3_free(p->pPreallocatedUnused);  }  return rc; } static int unixDelete(  sqlite3_vfs *NotUsed,  const char *zPath,  int dirSync ){  int rc = SQLITE_OK;  UNUSED_PARAMETER(NotUsed);  SimulateIOError(return SQLITE_IOERR_DELETE);  if( osUnlink(zPath)==(-1) ){  if( errno==ENOENT
#if OS_VXWORKS
 || osAccess(zPath,0)!=0
#endif
 ){  rc = SQLITE_IOERR_DELETE_NOENT;  }else{  rc = unixLogError(SQLITE_IOERR_DELETE, "unlink", zPath);  }  return rc;  }
#ifndef SQLITE_DISABLE_DIRSYNC
 if( (dirSync & 1)!=0 ){  int fd;  rc = osOpenDirectory(zPath, &fd);  if( rc==SQLITE_OK ){  if( full_fsync(fd,0,0) ){  rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, "fsync", zPath);  }  robust_close(0, fd, __LINE__);  }else{  assert( rc==SQLITE_CANTOPEN );  rc = SQLITE_OK;  }  }
#endif
 return rc; } static int unixAccess(  sqlite3_vfs *NotUsed,  const char *zPath,  int flags,  int *pResOut ){  UNUSED_PARAMETER(NotUsed);  SimulateIOError( return SQLITE_IOERR_ACCESS; );  assert( pResOut!=0 );  assert( flags==SQLITE_ACCESS_EXISTS || flags==SQLITE_ACCESS_READWRITE );  if( flags==SQLITE_ACCESS_EXISTS ){  struct stat buf;  *pResOut = 0==osStat(zPath, &buf) &&  (!S_ISREG(buf.st_mode) || buf.st_size>0);  }else{  *pResOut = osAccess(zPath, W_OK|R_OK)==0;  }  return SQLITE_OK; } static int unixBackupDir(const char *z, int *pJ){  int j = *pJ;  int i;  if( j<=0 ) return 0;  for(i=j-1; i>0 && z[i-1]!='/'; i--){}  if( i==0 ) return 0;  if( z[i]=='.' && i==j-2 && z[i+1]=='.' ) return 0;  *pJ = i-1;  return 1; } static int mkFullPathname(  const char *zPath,  char *zOut,  int nOut ){  int nPath = sqlite3Strlen30(zPath);  int iOff = 0;  int i, j;  if( zPath[0]!='/' ){  if( osGetcwd(zOut, nOut-2)==0 ){  return unixLogError(SQLITE_CANTOPEN_BKPT, "getcwd", zPath);  }  iOff = sqlite3Strlen30(zOut);  zOut[iOff++] = '/';  }  if( (iOff+nPath+1)>nOut ){  zOut[iOff] = '\0';  return SQLITE_CANTOPEN_BKPT;  }  sqlite3_snprintf(nOut-iOff, &zOut[iOff], "%s", zPath);  for(i=j=1; zOut[i]; i++){  zOut[j++] = zOut[i];  while( zOut[i]=='/' && zOut[i+1]=='/' ) i++;  }  zOut[j] = 0;  assert( zOut[0]=='/' );  for(i=j=0; zOut[i]; i++){  if( zOut[i]=='/' ){  if( zOut[i+1]=='.' && zOut[i+2]=='/' ){  i += 1;  continue;  }  if( zOut[i+1]=='.'   && zOut[i+2]=='.'   && zOut[i+3]=='/'   && unixBackupDir(zOut, &j)  ){  i += 2;  continue;  }  }  if( ALWAYS(j>=0) ) zOut[j] = zOut[i];  j++;  }  if( NEVER(j==0) ) zOut[j++] = '/';  zOut[j] = 0;  return SQLITE_OK; } static int unixFullPathname(  sqlite3_vfs *pVfs,  const char *zPath,  int nOut,  char *zOut ){
#if !defined(HAVE_READLINK) || !defined(HAVE_LSTAT)
 return mkFullPathname(zPath, zOut, nOut);
#else
 int rc = SQLITE_OK;  int nByte;  int nLink = 0;  const char *zIn = zPath;  char *zDel = 0;  assert( pVfs->mxPathname==MAX_PATHNAME );  UNUSED_PARAMETER(pVfs);  SimulateIOError( return SQLITE_ERROR );  do {  int bLink = 0;  struct stat buf;  if( osLstat(zIn, &buf)!=0 ){  if( errno!=ENOENT ){  rc = unixLogError(SQLITE_CANTOPEN_BKPT, "lstat", zIn);  }  }else{  bLink = S_ISLNK(buf.st_mode);  }  if( bLink ){  nLink++;  if( zDel==0 ){  zDel = sqlite3_malloc(nOut);  if( zDel==0 ) rc = SQLITE_NOMEM_BKPT;  }else if( nLink>=SQLITE_MAX_SYMLINKS ){  rc = SQLITE_CANTOPEN_BKPT;  }  if( rc==SQLITE_OK ){  nByte = osReadlink(zIn, zDel, nOut-1);  if( nByte<0 ){  rc = unixLogError(SQLITE_CANTOPEN_BKPT, "readlink", zIn);  }else{  if( zDel[0]!='/' ){  int n;  for(n = sqlite3Strlen30(zIn); n>0 && zIn[n-1]!='/'; n--);  if( nByte+n+1>nOut ){  rc = SQLITE_CANTOPEN_BKPT;  }else{  memmove(&zDel[n], zDel, nByte+1);  memcpy(zDel, zIn, n);  nByte += n;  }  }  zDel[nByte] = '\0';  }  }  zIn = zDel;  }  assert( rc!=SQLITE_OK || zIn!=zOut || zIn[0]=='/' );  if( rc==SQLITE_OK && zIn!=zOut ){  rc = mkFullPathname(zIn, zOut, nOut);  }  if( bLink==0 ) break;  zIn = zOut;  }while( rc==SQLITE_OK );  sqlite3_free(zDel);  if( rc==SQLITE_OK && nLink ) rc = SQLITE_OK_SYMLINK;  return rc;
#endif
}
#ifndef SQLITE_OMIT_LOAD_EXTENSION
#include <dlfcn.h>
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){  UNUSED_PARAMETER(NotUsed);  return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL); } static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){  const char *zErr;  UNUSED_PARAMETER(NotUsed);  unixEnterMutex();  zErr = dlerror();  if( zErr ){  sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);  }  unixLeaveMutex(); } static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){  void (*(*x)(void*,const char*))(void);  UNUSED_PARAMETER(NotUsed);  x = (void(*(*)(void*,const char*))(void))dlsym;  return (*x)(p, zSym); } static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){  UNUSED_PARAMETER(NotUsed);  dlclose(pHandle); }
#else
 #define unixDlOpen 0
 #define unixDlError 0
 #define unixDlSym  0
 #define unixDlClose 0
#endif
static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){  UNUSED_PARAMETER(NotUsed);  assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int)));  memset(zBuf, 0, nBuf);  randomnessPid = osGetpid(0);
#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)
 {  int fd, got;  fd = robust_open("/dev/urandom", O_RDONLY, 0);  if( fd<0 ){  time_t t;  time(&t);  memcpy(zBuf, &t, sizeof(t));  memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));  assert( sizeof(t)+sizeof(randomnessPid)<=(size_t)nBuf );  nBuf = sizeof(t) + sizeof(randomnessPid);  }else{  do{ got = osRead(fd, zBuf, nBuf); }while( got<0 && errno==EINTR );  robust_close(0, fd, __LINE__);  }  }
#endif
 return nBuf; } static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){
#if OS_VXWORKS
 struct timespec sp;  sp.tv_sec = microseconds / 1000000;  sp.tv_nsec = (microseconds % 1000000) * 1000;  nanosleep(&sp, NULL);  UNUSED_PARAMETER(NotUsed);  return microseconds;
#elif defined(HAVE_USLEEP) && HAVE_USLEEP
 if( microseconds>=1000000 ) sleep(microseconds/1000000);  if( microseconds%1000000 ) usleep(microseconds%1000000);  UNUSED_PARAMETER(NotUsed);  return microseconds;
#else
 int seconds = (microseconds+999999)/1000000;  sleep(seconds);  UNUSED_PARAMETER(NotUsed);  return seconds*1000000;
#endif
}
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_current_time = 0;
#endif
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;  int rc = SQLITE_OK;
#if defined(NO_GETTOD)
 time_t t;  time(&t);  *piNow = ((sqlite3_int64)t)*1000 + unixEpoch;
#elif OS_VXWORKS
 struct timespec sNow;  clock_gettime(CLOCK_REALTIME, &sNow);  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_nsec/1000000;
#else
 struct timeval sNow;  (void)gettimeofday(&sNow, 0);  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;
#endif
#ifdef SQLITE_TEST
 if( sqlite3_current_time ){  *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;  }
#endif
 UNUSED_PARAMETER(NotUsed);  return rc; }
#ifndef SQLITE_OMIT_DEPRECATED
static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){  sqlite3_int64 i = 0;  int rc;  UNUSED_PARAMETER(NotUsed);  rc = unixCurrentTimeInt64(0, &i);  *prNow = i/86400000.0;  return rc; }
#else
# define unixCurrentTime 0
#endif
static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){  UNUSED_PARAMETER(NotUsed);  UNUSED_PARAMETER(NotUsed2);  UNUSED_PARAMETER(NotUsed3);  return errno; }
#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE
typedef struct proxyLockingContext proxyLockingContext; struct proxyLockingContext {  unixFile *conchFile;  char *conchFilePath;  unixFile *lockProxy;  char *lockProxyPath;  char *dbPath;  int conchHeld;  int nFails;  void *oldLockingContext;  sqlite3_io_methods const *pOldMethod; }; static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){  int len;  int dbLen;  int i;
#ifdef LOCKPROXYDIR
 len = strlcpy(lPath, LOCKPROXYDIR, maxLen);
#else
# ifdef _CS_DARWIN_USER_TEMP_DIR
 {  if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){  OSTRACE(("GETLOCKPATH failed %s errno=%d pid=%d\n",   lPath, errno, osGetpid(0)));  return SQLITE_IOERR_LOCK;  }  len = strlcat(lPath, "sqliteplocks", maxLen);  }
# else
 len = strlcpy(lPath, "/tmp/", maxLen);
# endif
#endif
 if( lPath[len-1]!='/' ){  len = strlcat(lPath, "/", maxLen);  }  dbLen = (int)strlen(dbPath);  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){  char c = dbPath[i];  lPath[i+len] = (c=='/')?'_':c;  }  lPath[i+len]='\0';  strlcat(lPath, ":auto:", maxLen);  OSTRACE(("GETLOCKPATH proxy lock path=%s pid=%d\n", lPath, osGetpid(0)));  return SQLITE_OK; } static int proxyCreateLockPath(const char *lockPath){  int i, len;  char buf[MAXPATHLEN];  int start = 0;  assert(lockPath!=NULL);  len = (int)strlen(lockPath);  buf[0] = lockPath[0];  for( i=1; i<len; i++ ){  if( lockPath[i] == '/' && (i - start > 0) ){  if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/')   || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){  buf[i]='\0';  if( osMkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS) ){  int err=errno;  if( err!=EEXIST ) {  OSTRACE(("CREATELOCKPATH FAILED creating %s, "   "'%s' proxy lock path=%s pid=%d\n",   buf, strerror(err), lockPath, osGetpid(0)));  return err;  }  }  }  start=i+1;  }  buf[i] = lockPath[i];  }  OSTRACE(("CREATELOCKPATH proxy lock path=%s pid=%d\n",lockPath,osGetpid(0)));  return 0; } static int proxyCreateUnixFile(  const char *path,  unixFile **ppFile,  int islockfile ) {  int fd = -1;  unixFile *pNew;  int rc = SQLITE_OK;  int openFlags = O_RDWR | O_CREAT | O_NOFOLLOW;  sqlite3_vfs dummyVfs;  int terrno = 0;  UnixUnusedFd *pUnused = NULL;  pUnused = findReusableFd(path, openFlags);  if( pUnused ){  fd = pUnused->fd;  }else{  pUnused = sqlite3_malloc64(sizeof(*pUnused));  if( !pUnused ){  return SQLITE_NOMEM_BKPT;  }  }  if( fd<0 ){  fd = robust_open(path, openFlags, 0);  terrno = errno;  if( fd<0 && errno==ENOENT && islockfile ){  if( proxyCreateLockPath(path) == SQLITE_OK ){  fd = robust_open(path, openFlags, 0);  }  }  }  if( fd<0 ){  openFlags = O_RDONLY | O_NOFOLLOW;  fd = robust_open(path, openFlags, 0);  terrno = errno;  }  if( fd<0 ){  if( islockfile ){  return SQLITE_BUSY;  }  switch (terrno) {  case EACCES:  return SQLITE_PERM;  case EIO:  return SQLITE_IOERR_LOCK;  default:  return SQLITE_CANTOPEN_BKPT;  }  }  pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));  if( pNew==NULL ){  rc = SQLITE_NOMEM_BKPT;  goto end_create_proxy;  }  memset(pNew, 0, sizeof(unixFile));  pNew->openFlags = openFlags;  memset(&dummyVfs, 0, sizeof(dummyVfs));  dummyVfs.pAppData = (void*)&autolockIoFinder;  dummyVfs.zName = "dummy";  pUnused->fd = fd;  pUnused->flags = openFlags;  pNew->pPreallocatedUnused = pUnused;  rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file*)pNew, path, 0);  if( rc==SQLITE_OK ){  *ppFile = pNew;  return SQLITE_OK;  } end_create_proxy:  robust_close(pNew, fd, __LINE__);  sqlite3_free(pNew);  sqlite3_free(pUnused);  return rc; }
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_hostid_num = 0;
#endif
#define PROXY_HOSTIDLEN 16
#if HAVE_GETHOSTUUID
extern int gethostuuid(uuid_t id, const struct timespec *wait);
#endif
static int proxyGetHostID(unsigned char *pHostID, int *pError){  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));  memset(pHostID, 0, PROXY_HOSTIDLEN);
#if HAVE_GETHOSTUUID
 {  struct timespec timeout = {1, 0};  if( gethostuuid(pHostID, &timeout) ){  int err = errno;  if( pError ){  *pError = err;  }  return SQLITE_IOERR;  }  }
#else
 UNUSED_PARAMETER(pError);
#endif
#ifdef SQLITE_TEST
 if( sqlite3_hostid_num != 0){  pHostID[0] = (char)(pHostID[0] + (char)(sqlite3_hostid_num & 0xFF));  }
#endif
 return SQLITE_OK; }
#define PROXY_CONCHVERSION 2
#define PROXY_HEADERLEN 1
#define PROXY_PATHINDEX (PROXY_HEADERLEN+PROXY_HOSTIDLEN)
#define PROXY_MAXCONCHLEN (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)
static int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  unixFile *conchFile = pCtx->conchFile;  char tPath[MAXPATHLEN];  char buf[PROXY_MAXCONCHLEN];  char *cPath = pCtx->conchFilePath;  size_t readLen = 0;  size_t pathLen = 0;  char errmsg[64] = "";  int fd = -1;  int rc = -1;  UNUSED_PARAMETER(myHostID);  pathLen = strlcpy(tPath, cPath, MAXPATHLEN);  if( pathLen>MAXPATHLEN || pathLen<6 ||   (strlcpy(&tPath[pathLen-5], "break", 6) != 5) ){  sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);  goto end_breaklock;  }  readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);  if( readLen<PROXY_PATHINDEX ){  sqlite3_snprintf(sizeof(errmsg),errmsg,"read error (len %d)",(int)readLen);  goto end_breaklock;  }  fd = robust_open(tPath, (O_RDWR|O_CREAT|O_EXCL|O_NOFOLLOW), 0);  if( fd<0 ){  sqlite3_snprintf(sizeof(errmsg), errmsg, "create failed (%d)", errno);  goto end_breaklock;  }  if( osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen ){  sqlite3_snprintf(sizeof(errmsg), errmsg, "write failed (%d)", errno);  goto end_breaklock;  }  if( rename(tPath, cPath) ){  sqlite3_snprintf(sizeof(errmsg), errmsg, "rename failed (%d)", errno);  goto end_breaklock;  }  rc = 0;  fprintf(stderr, "broke stale lock on %s\n", cPath);  robust_close(pFile, conchFile->h, __LINE__);  conchFile->h = fd;  conchFile->openFlags = O_RDWR | O_CREAT; end_breaklock:  if( rc ){  if( fd>=0 ){  osUnlink(tPath);  robust_close(pFile, fd, __LINE__);  }  fprintf(stderr, "failed to break stale lock on %s, %s\n", cPath, errmsg);  }  return rc; } static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  unixFile *conchFile = pCtx->conchFile;  int rc = SQLITE_OK;  int nTries = 0;  struct timespec conchModTime;  memset(&conchModTime, 0, sizeof(conchModTime));  do {  rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);  nTries ++;  if( rc==SQLITE_BUSY ){  struct stat buf;  if( osFstat(conchFile->h, &buf) ){  storeLastErrno(pFile, errno);  return SQLITE_IOERR_LOCK;  }  if( nTries==1 ){  conchModTime = buf.st_mtimespec;  unixSleep(0,500000);  continue;  }  assert( nTries>1 );  if( conchModTime.tv_sec != buf.st_mtimespec.tv_sec ||   conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec ){  return SQLITE_BUSY;  }  if( nTries==2 ){  char tBuf[PROXY_MAXCONCHLEN];  int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);  if( len<0 ){  storeLastErrno(pFile, errno);  return SQLITE_IOERR_LOCK;  }  if( len>PROXY_PATHINDEX && tBuf[0]==(char)PROXY_CONCHVERSION){  if( 0!=memcmp(&tBuf[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN) ){  return SQLITE_BUSY;  }  }else{  return SQLITE_BUSY;  }  unixSleep(0,10000000);  continue;  }  assert( nTries==3 );  if( 0==proxyBreakConchLock(pFile, myHostID) ){  rc = SQLITE_OK;  if( lockType==EXCLUSIVE_LOCK ){  rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);  }  if( !rc ){  rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);  }  }  }  } while( rc==SQLITE_BUSY && nTries<3 );  return rc; } static int proxyTakeConch(unixFile *pFile){  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  if( pCtx->conchHeld!=0 ){  return SQLITE_OK;  }else{  unixFile *conchFile = pCtx->conchFile;  uuid_t myHostID;  int pError = 0;  char readBuf[PROXY_MAXCONCHLEN];  char lockPath[MAXPATHLEN];  char *tempLockPath = NULL;  int rc = SQLITE_OK;  int createConch = 0;  int hostIdMatch = 0;  int readLen = 0;  int tryOldLockPath = 0;  int forceNewLockPath = 0;  OSTRACE(("TAKECONCH %d for %s pid=%d\n", conchFile->h,   (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),   osGetpid(0)));  rc = proxyGetHostID(myHostID, &pError);  if( (rc&0xff)==SQLITE_IOERR ){  storeLastErrno(pFile, pError);  goto end_takeconch;  }  rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);  if( rc!=SQLITE_OK ){  goto end_takeconch;  }  readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);  if( readLen<0 ){  storeLastErrno(pFile, conchFile->lastErrno);  rc = SQLITE_IOERR_READ;  goto end_takeconch;  }else if( readLen<=(PROXY_HEADERLEN+PROXY_HOSTIDLEN) ||   readBuf[0]!=(char)PROXY_CONCHVERSION ){  createConch = 1;  }  do {  if( !createConch && !forceNewLockPath ){  hostIdMatch = !memcmp(&readBuf[PROXY_HEADERLEN], myHostID,  PROXY_HOSTIDLEN);  if( !pCtx->lockProxyPath ){  if( hostIdMatch ){  size_t pathLen = (readLen - PROXY_PATHINDEX);  if( pathLen>=MAXPATHLEN ){  pathLen=MAXPATHLEN-1;  }  memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);  lockPath[pathLen] = 0;  tempLockPath = lockPath;  tryOldLockPath = 1;  goto end_takeconch;  }  }else if( hostIdMatch   && !strncmp(pCtx->lockProxyPath, &readBuf[PROXY_PATHINDEX],   readLen-PROXY_PATHINDEX)  ){  goto end_takeconch;  }  }  if( (conchFile->openFlags&O_RDWR) == 0 ){  rc = SQLITE_BUSY;  goto end_takeconch;  }  if( !pCtx->lockProxyPath ){  proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);  tempLockPath = lockPath;  }  futimes(conchFile->h, NULL);  if( hostIdMatch && !createConch ){  if( conchFile->pInode && conchFile->pInode->nShared>1 ){  rc = SQLITE_BUSY;  } else {  rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);  }  }else{  rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);  }  if( rc==SQLITE_OK ){  char writeBuffer[PROXY_MAXCONCHLEN];  int writeSize = 0;  writeBuffer[0] = (char)PROXY_CONCHVERSION;  memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);  if( pCtx->lockProxyPath!=NULL ){  strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath,  MAXPATHLEN);  }else{  strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);  }  writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);  robust_ftruncate(conchFile->h, writeSize);  rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);  full_fsync(conchFile->h,0,0);  if( rc==SQLITE_OK && createConch ){  struct stat buf;  int err = osFstat(pFile->h, &buf);  if( err==0 ){  mode_t cmode = buf.st_mode&(S_IRUSR|S_IWUSR | S_IRGRP|S_IWGRP |  S_IROTH|S_IWOTH);
#ifndef SQLITE_PROXY_DEBUG
 osFchmod(conchFile->h, cmode);
#else
 do{  rc = osFchmod(conchFile->h, cmode);  }while( rc==(-1) && errno==EINTR );  if( rc!=0 ){  int code = errno;  fprintf(stderr, "fchmod %o FAILED with %d %s\n",  cmode, code, strerror(code));  } else {  fprintf(stderr, "fchmod %o SUCCEDED\n",cmode);  }  }else{  int code = errno;  fprintf(stderr, "STAT FAILED[%d] with %d %s\n",  err, code, strerror(code));
#endif
 }  }  }  conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, SHARED_LOCK);  end_takeconch:  OSTRACE(("TRANSPROXY: CLOSE %d\n", pFile->h));  if( rc==SQLITE_OK && pFile->openFlags ){  int fd;  if( pFile->h>=0 ){  robust_close(pFile, pFile->h, __LINE__);  }  pFile->h = -1;  fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);  OSTRACE(("TRANSPROXY: OPEN %d\n", fd));  if( fd>=0 ){  pFile->h = fd;  }else{  rc=SQLITE_CANTOPEN_BKPT;   }  }  if( rc==SQLITE_OK && !pCtx->lockProxy ){  char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;  rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);  if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM && tryOldLockPath ){  forceNewLockPath = 1;  tryOldLockPath = 0;  continue;  }  }  if( rc==SQLITE_OK ){  if( tempLockPath ){  pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);  if( !pCtx->lockProxyPath ){  rc = SQLITE_NOMEM_BKPT;  }  }  }  if( rc==SQLITE_OK ){  pCtx->conchHeld = 1;  if( pCtx->lockProxy->pMethod == &afpIoMethods ){  afpLockingContext *afpCtx;  afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;  afpCtx->dbPath = pCtx->lockProxyPath;  }  } else {  conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);  }  OSTRACE(("TAKECONCH %d %s\n", conchFile->h,   rc==SQLITE_OK?"ok":"failed"));  return rc;  } while (1);  } } static int proxyReleaseConch(unixFile *pFile){  int rc = SQLITE_OK;  proxyLockingContext *pCtx;  unixFile *conchFile;  pCtx = (proxyLockingContext *)pFile->lockingContext;  conchFile = pCtx->conchFile;  OSTRACE(("RELEASECONCH %d for %s pid=%d\n", conchFile->h,   (pCtx->lockProxyPath ? pCtx->lockProxyPath : ":auto:"),   osGetpid(0)));  if( pCtx->conchHeld>0 ){  rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);  }  pCtx->conchHeld = 0;  OSTRACE(("RELEASECONCH %d %s\n", conchFile->h,   (rc==SQLITE_OK ? "ok" : "failed")));  return rc; } static int proxyCreateConchPathname(char *dbPath, char **pConchPath){  int i;  int len = (int)strlen(dbPath);  char *conchPath;  *pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);  if( conchPath==0 ){  return SQLITE_NOMEM_BKPT;  }  memcpy(conchPath, dbPath, len+1);  for( i=(len-1); i>=0; i-- ){  if( conchPath[i]=='/' ){  i++;  break;  }  }  conchPath[i]='.';  while ( i<len ){  conchPath[i+1]=dbPath[i];  i++;  }  memcpy(&conchPath[i+1], "-conch", 7);  assert( (int)strlen(conchPath) == len+7 );  return SQLITE_OK; } static int switchLockProxyPath(unixFile *pFile, const char *path) {  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;  char *oldPath = pCtx->lockProxyPath;  int rc = SQLITE_OK;  if( pFile->eFileLock!=NO_LOCK ){  return SQLITE_BUSY;  }  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ||  (oldPath && !strncmp(oldPath, path, MAXPATHLEN)) ){  return SQLITE_OK;  }else{  unixFile *lockProxy = pCtx->lockProxy;  pCtx->lockProxy=NULL;  pCtx->conchHeld = 0;  if( lockProxy!=NULL ){  rc=lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);  if( rc ) return rc;  sqlite3_free(lockProxy);  }  sqlite3_free(oldPath);  pCtx->lockProxyPath = sqlite3DbStrDup(0, path);  }  return rc; } static int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){
#if defined(__APPLE__)
 if( pFile->pMethod == &afpIoMethods ){  assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );  strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,  MAXPATHLEN);  } else
#endif
 if( pFile->pMethod == &dotlockIoMethods ){  int len = strlen((char *)pFile->lockingContext) - strlen(DOTLOCK_SUFFIX);  memcpy(dbPath, (char *)pFile->lockingContext, len + 1);  }else{  assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );  strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);  }  return SQLITE_OK; } static int proxyTransformUnixFile(unixFile *pFile, const char *path) {  proxyLockingContext *pCtx;  char dbPath[MAXPATHLEN+1];  char *lockPath=NULL;  int rc = SQLITE_OK;  if( pFile->eFileLock!=NO_LOCK ){  return SQLITE_BUSY;  }  proxyGetDbPathForUnixFile(pFile, dbPath);  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ){  lockPath=NULL;  }else{  lockPath=(char *)path;  }  OSTRACE(("TRANSPROXY %d for %s pid=%d\n", pFile->h,   (lockPath ? lockPath : ":auto:"), osGetpid(0)));  pCtx = sqlite3_malloc64( sizeof(*pCtx) );  if( pCtx==0 ){  return SQLITE_NOMEM_BKPT;  }  memset(pCtx, 0, sizeof(*pCtx));  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);  if( rc==SQLITE_OK ){  rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);  if( rc==SQLITE_CANTOPEN && ((pFile->openFlags&O_RDWR) == 0) ){  struct statfs fsInfo;  struct stat conchInfo;  int goLockless = 0;  if( osStat(pCtx->conchFilePath, &conchInfo) == -1 ) {  int err = errno;  if( (err==ENOENT) && (statfs(dbPath, &fsInfo) != -1) ){  goLockless = (fsInfo.f_flags&MNT_RDONLY) == MNT_RDONLY;  }  }  if( goLockless ){  pCtx->conchHeld = -1;  rc = SQLITE_OK;  }  }  }  if( rc==SQLITE_OK && lockPath ){  pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);  }  if( rc==SQLITE_OK ){  pCtx->dbPath = sqlite3DbStrDup(0, dbPath);  if( pCtx->dbPath==NULL ){  rc = SQLITE_NOMEM_BKPT;  }  }  if( rc==SQLITE_OK ){  pCtx->oldLockingContext = pFile->lockingContext;  pFile->lockingContext = pCtx;  pCtx->pOldMethod = pFile->pMethod;  pFile->pMethod = &proxyIoMethods;  }else{  if( pCtx->conchFile ){  pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);  sqlite3_free(pCtx->conchFile);  }  sqlite3DbFree(0, pCtx->lockProxyPath);  sqlite3_free(pCtx->conchFilePath);  sqlite3_free(pCtx);  }  OSTRACE(("TRANSPROXY %d %s\n", pFile->h,   (rc==SQLITE_OK ? "ok" : "failed")));  return rc; } static int proxyFileControl(sqlite3_file *id, int op, void *pArg){  switch( op ){  case SQLITE_FCNTL_GET_LOCKPROXYFILE: {  unixFile *pFile = (unixFile*)id;  if( pFile->pMethod == &proxyIoMethods ){  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;  proxyTakeConch(pFile);  if( pCtx->lockProxyPath ){  *(const char **)pArg = pCtx->lockProxyPath;  }else{  *(const char **)pArg = ":auto: (not held)";  }  } else {  *(const char **)pArg = NULL;  }  return SQLITE_OK;  }  case SQLITE_FCNTL_SET_LOCKPROXYFILE: {  unixFile *pFile = (unixFile*)id;  int rc = SQLITE_OK;  int isProxyStyle = (pFile->pMethod == &proxyIoMethods);  if( pArg==NULL || (const char *)pArg==0 ){  if( isProxyStyle ){  rc = SQLITE_ERROR ;  }else{  rc = SQLITE_OK;  }  }else{  const char *proxyPath = (const char *)pArg;  if( isProxyStyle ){  proxyLockingContext *pCtx =  (proxyLockingContext*)pFile->lockingContext;  if( !strcmp(pArg, ":auto:")   || (pCtx->lockProxyPath &&   !strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))  ){  rc = SQLITE_OK;  }else{  rc = switchLockProxyPath(pFile, proxyPath);  }  }else{  rc = proxyTransformUnixFile(pFile, proxyPath);  }  }  return rc;  }  default: {  assert( 0 );  }  }  assert(0);  return SQLITE_ERROR; } static int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {  unixFile *pFile = (unixFile*)id;  int rc = proxyTakeConch(pFile);  if( rc==SQLITE_OK ){  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  if( pCtx->conchHeld>0 ){  unixFile *proxy = pCtx->lockProxy;  return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);  }else{  pResOut=0;  }  }  return rc; } static int proxyLock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  int rc = proxyTakeConch(pFile);  if( rc==SQLITE_OK ){  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  if( pCtx->conchHeld>0 ){  unixFile *proxy = pCtx->lockProxy;  rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);  pFile->eFileLock = proxy->eFileLock;  }else{  }  }  return rc; } static int proxyUnlock(sqlite3_file *id, int eFileLock) {  unixFile *pFile = (unixFile*)id;  int rc = proxyTakeConch(pFile);  if( rc==SQLITE_OK ){  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  if( pCtx->conchHeld>0 ){  unixFile *proxy = pCtx->lockProxy;  rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);  pFile->eFileLock = proxy->eFileLock;  }else{  }  }  return rc; } static int proxyClose(sqlite3_file *id) {  if( ALWAYS(id) ){  unixFile *pFile = (unixFile*)id;  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;  unixFile *lockProxy = pCtx->lockProxy;  unixFile *conchFile = pCtx->conchFile;  int rc = SQLITE_OK;  if( lockProxy ){  rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, NO_LOCK);  if( rc ) return rc;  rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);  if( rc ) return rc;  sqlite3_free(lockProxy);  pCtx->lockProxy = 0;  }  if( conchFile ){  if( pCtx->conchHeld ){  rc = proxyReleaseConch(pFile);  if( rc ) return rc;  }  rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);  if( rc ) return rc;  sqlite3_free(conchFile);  }  sqlite3DbFree(0, pCtx->lockProxyPath);  sqlite3_free(pCtx->conchFilePath);  sqlite3DbFree(0, pCtx->dbPath);  pFile->lockingContext = pCtx->oldLockingContext;  pFile->pMethod = pCtx->pOldMethod;  sqlite3_free(pCtx);  return pFile->pMethod->xClose(id);  }  return SQLITE_OK; }
#endif
SQLITE_API int sqlite3_os_init(void){
 #define UNIXVFS(VFSNAME, FINDER) {  3,  sizeof(unixFile),  MAX_PATHNAME,  0,  VFSNAME,  (void*)&FINDER,  unixOpen,  unixDelete,  unixAccess,  unixFullPathname,  unixDlOpen,  unixDlError,  unixDlSym,  unixDlClose,  unixRandomness,  unixSleep,  unixCurrentTime,  unixGetLastError,  unixCurrentTimeInt64,  unixSetSystemCall,  unixGetSystemCall,  unixNextSystemCall,  }

 static sqlite3_vfs aVfs[] = {
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
 UNIXVFS("unix", autolockIoFinder ),
#elif OS_VXWORKS
 UNIXVFS("unix", vxworksIoFinder ),
#else
 UNIXVFS("unix", posixIoFinder ),
#endif
 UNIXVFS("unix-none", nolockIoFinder ),  UNIXVFS("unix-dotfile", dotlockIoFinder ),  UNIXVFS("unix-excl", posixIoFinder ),
#if OS_VXWORKS
 UNIXVFS("unix-namedsem", semIoFinder ),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE || OS_VXWORKS
 UNIXVFS("unix-posix", posixIoFinder ),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
 UNIXVFS("unix-flock", flockIoFinder ),
#endif
#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)
 UNIXVFS("unix-afp", afpIoFinder ),  UNIXVFS("unix-nfs", nfsIoFinder ),  UNIXVFS("unix-proxy", proxyIoFinder ),
#endif
 };  unsigned int i;  assert( ArraySize(aSyscall)==29 );  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){  sqlite3_vfs_register(&aVfs[i], i==0);  }  unixBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
#ifndef SQLITE_OMIT_WAL
 assert( SQLITE_SHM_NLOCK==8 );  assert( UNIX_SHM_BASE==120 );  assert( UNIX_SHM_DMS==128  );
#endif
 unixTempFileInit();  return SQLITE_OK; } SQLITE_API int sqlite3_os_end(void){  unixBigLock = 0;  return SQLITE_OK; }
#endif
#if SQLITE_OS_WIN
#if !SQLITE_OS_WINNT && !defined(SQLITE_OMIT_WAL)
# error "WAL mode requires support from the Windows NT kernel, compile with SQLITE_OMIT_WAL."

#endif
#if !SQLITE_OS_WINNT && SQLITE_MAX_MMAP_SIZE>0
# error "Memory mapped files require support from the Windows NT kernel, compile with SQLITE_MAX_MMAP_SIZE=0."

#endif
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(SQLITE_WIN32_NO_ANSI)
# define SQLITE_WIN32_HAS_ANSI
#endif
#if (SQLITE_OS_WINCE || SQLITE_OS_WINNT || SQLITE_OS_WINRT) &&  !defined(SQLITE_WIN32_NO_WIDE)

# define SQLITE_WIN32_HAS_WIDE
#endif
#if !defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_WIN32_HAS_WIDE)
# error "At least one of SQLITE_WIN32_HAS_ANSI and SQLITE_WIN32_HAS_WIDE must be defined."

#endif
#ifndef NTDDI_WIN8
# define NTDDI_WIN8 0x06020000
#endif
#ifndef NTDDI_WINBLUE
# define NTDDI_WINBLUE  0x06030000
#endif
#ifndef NTDDI_WINTHRESHOLD
# define NTDDI_WINTHRESHOLD 0x06040000
#endif
#ifndef SQLITE_WIN32_GETVERSIONEX
# if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINBLUE
# define SQLITE_WIN32_GETVERSIONEX  0
# else
# define SQLITE_WIN32_GETVERSIONEX  1
# endif
#endif
#ifndef SQLITE_WIN32_CREATEFILEMAPPINGA
# if defined(NTDDI_VERSION) && NTDDI_VERSION >= NTDDI_WINTHRESHOLD
# define SQLITE_WIN32_CREATEFILEMAPPINGA  0
# else
# define SQLITE_WIN32_CREATEFILEMAPPINGA  1
# endif
#endif
#ifndef MAX_PATH
# define MAX_PATH (260)
#endif
#ifndef SQLITE_WIN32_MAX_PATH_CHARS
# define SQLITE_WIN32_MAX_PATH_CHARS  (MAX_PATH)
#endif
#ifndef UNICODE_STRING_MAX_CHARS
# define UNICODE_STRING_MAX_CHARS (32767)
#endif
#ifndef SQLITE_WINNT_MAX_PATH_CHARS
# define SQLITE_WINNT_MAX_PATH_CHARS  (UNICODE_STRING_MAX_CHARS)
#endif
#ifndef SQLITE_WIN32_MAX_PATH_BYTES
# define SQLITE_WIN32_MAX_PATH_BYTES  (SQLITE_WIN32_MAX_PATH_CHARS*4)
#endif
#ifndef SQLITE_WINNT_MAX_PATH_BYTES
# define SQLITE_WINNT_MAX_PATH_BYTES   (sizeof(WCHAR) * SQLITE_WINNT_MAX_PATH_CHARS)

#endif
#ifndef SQLITE_WIN32_MAX_ERRMSG_CHARS
# define SQLITE_WIN32_MAX_ERRMSG_CHARS (1024)
#endif
#ifndef winIsDirSep
# define winIsDirSep(a) (((a) == '/') || ((a) == '\\'))
#endif
#ifndef UNUSED_VARIABLE_VALUE
# define UNUSED_VARIABLE_VALUE(x) (void)(x)
#endif
#ifndef winGetDirSep
# define winGetDirSep() '\\'
#endif
#if SQLITE_WIN32_FILEMAPPING_API &&  (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)

#if SQLITE_OS_WINRT
WINBASEAPI HANDLE WINAPI CreateFileMappingFromApp(HANDLE, \  LPSECURITY_ATTRIBUTES, ULONG, ULONG64, LPCWSTR); WINBASEAPI LPVOID WINAPI MapViewOfFileFromApp(HANDLE, ULONG, ULONG64, SIZE_T);
#else
#if defined(SQLITE_WIN32_HAS_ANSI)
WINBASEAPI HANDLE WINAPI CreateFileMappingA(HANDLE, LPSECURITY_ATTRIBUTES, \  DWORD, DWORD, DWORD, LPCSTR);
#endif
#if defined(SQLITE_WIN32_HAS_WIDE)
WINBASEAPI HANDLE WINAPI CreateFileMappingW(HANDLE, LPSECURITY_ATTRIBUTES, \  DWORD, DWORD, DWORD, LPCWSTR);
#endif
WINBASEAPI LPVOID WINAPI MapViewOfFile(HANDLE, DWORD, DWORD, DWORD, SIZE_T);
#endif
WINBASEAPI BOOL WINAPI FlushViewOfFile(LPCVOID, SIZE_T); WINBASEAPI BOOL WINAPI UnmapViewOfFile(LPCVOID);
#endif
#ifndef INVALID_FILE_ATTRIBUTES
# define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
#endif
#ifndef FILE_FLAG_MASK
# define FILE_FLAG_MASK (0xFF3C0000)
#endif
#ifndef FILE_ATTRIBUTE_MASK
# define FILE_ATTRIBUTE_MASK  (0x0003FFF7)
#endif
#ifndef SQLITE_OMIT_WAL
typedef struct winShm winShm; typedef struct winShmNode winShmNode;
#endif
#if SQLITE_OS_WINCE
typedef struct winceLock {  int nReaders;  BOOL bPending;  BOOL bReserved;  BOOL bExclusive; } winceLock;
#endif
typedef struct winFile winFile; struct winFile {  const sqlite3_io_methods *pMethod;  sqlite3_vfs *pVfs;  HANDLE h;  u8 locktype;  short sharedLockByte;  u8 ctrlFlags;  DWORD lastErrno;
#ifndef SQLITE_OMIT_WAL
 winShm *pShm;
#endif
 const char *zPath;  int szChunk;
#if SQLITE_OS_WINCE
 LPWSTR zDeleteOnClose;  HANDLE hMutex;  HANDLE hShared;  winceLock local;  winceLock *shared;
#endif
#if SQLITE_MAX_MMAP_SIZE>0
 int nFetchOut;  HANDLE hMap;  void *pMapRegion;  sqlite3_int64 mmapSize;  sqlite3_int64 mmapSizeMax;
#endif
}; typedef struct winVfsAppData winVfsAppData; struct winVfsAppData {  const sqlite3_io_methods *pMethod;  void *pAppData;  BOOL bNoLock; };
#define WINFILE_RDONLY 0x02
#define WINFILE_PERSIST_WAL  0x04
#define WINFILE_PSOW 0x10
#ifndef SQLITE_WIN32_DBG_BUF_SIZE
# define SQLITE_WIN32_DBG_BUF_SIZE  ((int)(4096-sizeof(DWORD)))
#endif
#ifdef SQLITE_WIN32_MALLOC
#ifndef SQLITE_WIN32_HEAP_CREATE
# define SQLITE_WIN32_HEAP_CREATE (TRUE)
#endif
#ifndef SQLITE_WIN32_HEAP_MAX_INIT_SIZE
# define SQLITE_WIN32_HEAP_MAX_INIT_SIZE (4294967295U)
#endif
#ifndef SQLITE_WIN32_HEAP_INIT_EXTRA
# define SQLITE_WIN32_HEAP_INIT_EXTRA (4194304)
#endif
#ifndef SQLITE_WIN32_MAX_CACHE_SIZE
# define SQLITE_WIN32_MAX_CACHE_SIZE  (((SQLITE_WIN32_HEAP_MAX_INIT_SIZE) -  (SQLITE_WIN32_HEAP_INIT_EXTRA)) /   (SQLITE_DEFAULT_PAGE_SIZE))

#endif
#ifndef SQLITE_WIN32_CACHE_SIZE
# if SQLITE_DEFAULT_CACHE_SIZE>=0
# define SQLITE_WIN32_CACHE_SIZE  (SQLITE_DEFAULT_CACHE_SIZE)
# else
# define SQLITE_WIN32_CACHE_SIZE  (-(SQLITE_DEFAULT_CACHE_SIZE))
# endif
#endif
#if SQLITE_WIN32_CACHE_SIZE>SQLITE_WIN32_MAX_CACHE_SIZE
# undef SQLITE_WIN32_CACHE_SIZE
# define SQLITE_WIN32_CACHE_SIZE  (2000)
#endif
#ifndef SQLITE_WIN32_HEAP_INIT_SIZE
# define SQLITE_WIN32_HEAP_INIT_SIZE  ((SQLITE_WIN32_CACHE_SIZE) *   (SQLITE_DEFAULT_PAGE_SIZE) +   (SQLITE_WIN32_HEAP_INIT_EXTRA))

#endif
#ifndef SQLITE_WIN32_HEAP_MAX_SIZE
# define SQLITE_WIN32_HEAP_MAX_SIZE (0)
#endif
#ifndef SQLITE_WIN32_HEAP_FLAGS
# define SQLITE_WIN32_HEAP_FLAGS  (0)
#endif
typedef struct winMemData winMemData; struct winMemData {
#ifndef NDEBUG
 u32 magic1;
#endif
 HANDLE hHeap;  BOOL bOwned;
#ifndef NDEBUG
 u32 magic2;
#endif
};
#ifndef NDEBUG
#define WINMEM_MAGIC1  0x42b2830b
#define WINMEM_MAGIC2  0xbd4d7cf4
#endif
static struct winMemData win_mem_data = {
#ifndef NDEBUG
 WINMEM_MAGIC1,
#endif
 NULL, FALSE
#ifndef NDEBUG
 ,WINMEM_MAGIC2
#endif
};
#ifndef NDEBUG
#define winMemAssertMagic1() assert( win_mem_data.magic1==WINMEM_MAGIC1 )
#define winMemAssertMagic2() assert( win_mem_data.magic2==WINMEM_MAGIC2 )
#define winMemAssertMagic() winMemAssertMagic1(); winMemAssertMagic2();
#else
#define winMemAssertMagic()
#endif
#define winMemGetDataPtr() &win_mem_data
#define winMemGetHeap()  win_mem_data.hHeap
#define winMemGetOwned() win_mem_data.bOwned
static void *winMemMalloc(int nBytes); static void winMemFree(void *pPrior); static void *winMemRealloc(void *pPrior, int nBytes); static int winMemSize(void *p); static int winMemRoundup(int n); static int winMemInit(void *pAppData); static void winMemShutdown(void *pAppData); SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void);
#endif
#ifdef SQLITE_TEST
SQLITE_API LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
#else
static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;
#endif
#ifndef SYSCALL
# define SYSCALL sqlite3_syscall_ptr
#endif
#if SQLITE_OS_WINCE || SQLITE_OS_WINRT
# define osAreFileApisANSI()  1
#endif
static struct win_syscall {  const char *zName;  sqlite3_syscall_ptr pCurrent;  sqlite3_syscall_ptr pDefault; } aSyscall[] = {
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
 { "AreFileApisANSI", (SYSCALL)AreFileApisANSI, 0 },
#else
 { "AreFileApisANSI", (SYSCALL)0, 0 },
#endif
#ifndef osAreFileApisANSI
#define osAreFileApisANSI ((BOOL(WINAPI*)(VOID))aSyscall[0].pCurrent)
#endif
#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)
 { "CharLowerW", (SYSCALL)CharLowerW, 0 },
#else
 { "CharLowerW", (SYSCALL)0, 0 },
#endif
#define osCharLowerW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[1].pCurrent)
#if SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_WIDE)
 { "CharUpperW", (SYSCALL)CharUpperW, 0 },
#else
 { "CharUpperW", (SYSCALL)0, 0 },
#endif
#define osCharUpperW ((LPWSTR(WINAPI*)(LPWSTR))aSyscall[2].pCurrent)
 { "CloseHandle", (SYSCALL)CloseHandle, 0 },
#define osCloseHandle ((BOOL(WINAPI*)(HANDLE))aSyscall[3].pCurrent)
#if defined(SQLITE_WIN32_HAS_ANSI)
 { "CreateFileA", (SYSCALL)CreateFileA, 0 },
#else
 { "CreateFileA", (SYSCALL)0, 0 },
#endif
#define osCreateFileA ((HANDLE(WINAPI*)(LPCSTR,DWORD,DWORD,  LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[4].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
 { "CreateFileW", (SYSCALL)CreateFileW, 0 },
#else
 { "CreateFileW", (SYSCALL)0, 0 },
#endif
#define osCreateFileW ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD,  LPSECURITY_ATTRIBUTES,DWORD,DWORD,HANDLE))aSyscall[5].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_ANSI) &&  (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) &&  SQLITE_WIN32_CREATEFILEMAPPINGA

 { "CreateFileMappingA", (SYSCALL)CreateFileMappingA, 0 },
#else
 { "CreateFileMappingA", (SYSCALL)0, 0 },
#endif
#define osCreateFileMappingA ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES,  DWORD,DWORD,DWORD,LPCSTR))aSyscall[6].pCurrent)

#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) &&  (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))

 { "CreateFileMappingW", (SYSCALL)CreateFileMappingW, 0 },
#else
 { "CreateFileMappingW", (SYSCALL)0, 0 },
#endif
#define osCreateFileMappingW ((HANDLE(WINAPI*)(HANDLE,LPSECURITY_ATTRIBUTES,  DWORD,DWORD,DWORD,LPCWSTR))aSyscall[7].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
 { "CreateMutexW", (SYSCALL)CreateMutexW, 0 },
#else
 { "CreateMutexW", (SYSCALL)0, 0 },
#endif
#define osCreateMutexW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,BOOL,  LPCWSTR))aSyscall[8].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
 { "DeleteFileA", (SYSCALL)DeleteFileA, 0 },
#else
 { "DeleteFileA", (SYSCALL)0, 0 },
#endif
#define osDeleteFileA ((BOOL(WINAPI*)(LPCSTR))aSyscall[9].pCurrent)
#if defined(SQLITE_WIN32_HAS_WIDE)
 { "DeleteFileW", (SYSCALL)DeleteFileW, 0 },
#else
 { "DeleteFileW", (SYSCALL)0, 0 },
#endif
#define osDeleteFileW ((BOOL(WINAPI*)(LPCWSTR))aSyscall[10].pCurrent)
#if SQLITE_OS_WINCE
 { "FileTimeToLocalFileTime", (SYSCALL)FileTimeToLocalFileTime, 0 },
#else
 { "FileTimeToLocalFileTime", (SYSCALL)0, 0 },
#endif
#define osFileTimeToLocalFileTime ((BOOL(WINAPI*)(CONST FILETIME*,  LPFILETIME))aSyscall[11].pCurrent)

#if SQLITE_OS_WINCE
 { "FileTimeToSystemTime", (SYSCALL)FileTimeToSystemTime, 0 },
#else
 { "FileTimeToSystemTime", (SYSCALL)0, 0 },
#endif
#define osFileTimeToSystemTime ((BOOL(WINAPI*)(CONST FILETIME*,  LPSYSTEMTIME))aSyscall[12].pCurrent)

 { "FlushFileBuffers", (SYSCALL)FlushFileBuffers, 0 },
#define osFlushFileBuffers ((BOOL(WINAPI*)(HANDLE))aSyscall[13].pCurrent)
#if defined(SQLITE_WIN32_HAS_ANSI)
 { "FormatMessageA", (SYSCALL)FormatMessageA, 0 },
#else
 { "FormatMessageA", (SYSCALL)0, 0 },
#endif
#define osFormatMessageA ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPSTR,  DWORD,va_list*))aSyscall[14].pCurrent)

#if defined(SQLITE_WIN32_HAS_WIDE)
 { "FormatMessageW", (SYSCALL)FormatMessageW, 0 },
#else
 { "FormatMessageW", (SYSCALL)0, 0 },
#endif
#define osFormatMessageW ((DWORD(WINAPI*)(DWORD,LPCVOID,DWORD,DWORD,LPWSTR,  DWORD,va_list*))aSyscall[15].pCurrent)

#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
 { "FreeLibrary", (SYSCALL)FreeLibrary, 0 },
#else
 { "FreeLibrary", (SYSCALL)0, 0 },
#endif
#define osFreeLibrary ((BOOL(WINAPI*)(HMODULE))aSyscall[16].pCurrent)
 { "GetCurrentProcessId", (SYSCALL)GetCurrentProcessId, 0 },
#define osGetCurrentProcessId ((DWORD(WINAPI*)(VOID))aSyscall[17].pCurrent)
#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)
 { "GetDiskFreeSpaceA", (SYSCALL)GetDiskFreeSpaceA, 0 },
#else
 { "GetDiskFreeSpaceA", (SYSCALL)0, 0 },
#endif
#define osGetDiskFreeSpaceA ((BOOL(WINAPI*)(LPCSTR,LPDWORD,LPDWORD,LPDWORD,  LPDWORD))aSyscall[18].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
 { "GetDiskFreeSpaceW", (SYSCALL)GetDiskFreeSpaceW, 0 },
#else
 { "GetDiskFreeSpaceW", (SYSCALL)0, 0 },
#endif
#define osGetDiskFreeSpaceW ((BOOL(WINAPI*)(LPCWSTR,LPDWORD,LPDWORD,LPDWORD,  LPDWORD))aSyscall[19].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
 { "GetFileAttributesA", (SYSCALL)GetFileAttributesA, 0 },
#else
 { "GetFileAttributesA", (SYSCALL)0, 0 },
#endif
#define osGetFileAttributesA ((DWORD(WINAPI*)(LPCSTR))aSyscall[20].pCurrent)
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
 { "GetFileAttributesW", (SYSCALL)GetFileAttributesW, 0 },
#else
 { "GetFileAttributesW", (SYSCALL)0, 0 },
#endif
#define osGetFileAttributesW ((DWORD(WINAPI*)(LPCWSTR))aSyscall[21].pCurrent)
#if defined(SQLITE_WIN32_HAS_WIDE)
 { "GetFileAttributesExW", (SYSCALL)GetFileAttributesExW, 0 },
#else
 { "GetFileAttributesExW", (SYSCALL)0, 0 },
#endif
#define osGetFileAttributesExW ((BOOL(WINAPI*)(LPCWSTR,GET_FILEEX_INFO_LEVELS,  LPVOID))aSyscall[22].pCurrent)

#if !SQLITE_OS_WINRT
 { "GetFileSize", (SYSCALL)GetFileSize, 0 },
#else
 { "GetFileSize", (SYSCALL)0, 0 },
#endif
#define osGetFileSize ((DWORD(WINAPI*)(HANDLE,LPDWORD))aSyscall[23].pCurrent)
#if !SQLITE_OS_WINCE && defined(SQLITE_WIN32_HAS_ANSI)
 { "GetFullPathNameA", (SYSCALL)GetFullPathNameA, 0 },
#else
 { "GetFullPathNameA", (SYSCALL)0, 0 },
#endif
#define osGetFullPathNameA ((DWORD(WINAPI*)(LPCSTR,DWORD,LPSTR,  LPSTR*))aSyscall[24].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
 { "GetFullPathNameW", (SYSCALL)GetFullPathNameW, 0 },
#else
 { "GetFullPathNameW", (SYSCALL)0, 0 },
#endif
#define osGetFullPathNameW ((DWORD(WINAPI*)(LPCWSTR,DWORD,LPWSTR,  LPWSTR*))aSyscall[25].pCurrent)

 { "GetLastError", (SYSCALL)GetLastError, 0 },
#define osGetLastError ((DWORD(WINAPI*)(VOID))aSyscall[26].pCurrent)
#if !defined(SQLITE_OMIT_LOAD_EXTENSION)
#if SQLITE_OS_WINCE
 { "GetProcAddressA", (SYSCALL)GetProcAddressA, 0 },
#else
 { "GetProcAddressA", (SYSCALL)GetProcAddress, 0 },
#endif
#else
 { "GetProcAddressA", (SYSCALL)0, 0 },
#endif
#define osGetProcAddressA ((FARPROC(WINAPI*)(HMODULE,  LPCSTR))aSyscall[27].pCurrent)

#if !SQLITE_OS_WINRT
 { "GetSystemInfo", (SYSCALL)GetSystemInfo, 0 },
#else
 { "GetSystemInfo", (SYSCALL)0, 0 },
#endif
#define osGetSystemInfo ((VOID(WINAPI*)(LPSYSTEM_INFO))aSyscall[28].pCurrent)
 { "GetSystemTime", (SYSCALL)GetSystemTime, 0 },
#define osGetSystemTime ((VOID(WINAPI*)(LPSYSTEMTIME))aSyscall[29].pCurrent)
#if !SQLITE_OS_WINCE
 { "GetSystemTimeAsFileTime", (SYSCALL)GetSystemTimeAsFileTime, 0 },
#else
 { "GetSystemTimeAsFileTime", (SYSCALL)0, 0 },
#endif
#define osGetSystemTimeAsFileTime ((VOID(WINAPI*)(  LPFILETIME))aSyscall[30].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
 { "GetTempPathA", (SYSCALL)GetTempPathA, 0 },
#else
 { "GetTempPathA", (SYSCALL)0, 0 },
#endif
#define osGetTempPathA ((DWORD(WINAPI*)(DWORD,LPSTR))aSyscall[31].pCurrent)
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE)
 { "GetTempPathW", (SYSCALL)GetTempPathW, 0 },
#else
 { "GetTempPathW", (SYSCALL)0, 0 },
#endif
#define osGetTempPathW ((DWORD(WINAPI*)(DWORD,LPWSTR))aSyscall[32].pCurrent)
#if !SQLITE_OS_WINRT
 { "GetTickCount", (SYSCALL)GetTickCount, 0 },
#else
 { "GetTickCount", (SYSCALL)0, 0 },
#endif
#define osGetTickCount ((DWORD(WINAPI*)(VOID))aSyscall[33].pCurrent)
#if defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_GETVERSIONEX
 { "GetVersionExA", (SYSCALL)GetVersionExA, 0 },
#else
 { "GetVersionExA", (SYSCALL)0, 0 },
#endif
#define osGetVersionExA ((BOOL(WINAPI*)(  LPOSVERSIONINFOA))aSyscall[34].pCurrent)

#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) &&  SQLITE_WIN32_GETVERSIONEX

 { "GetVersionExW", (SYSCALL)GetVersionExW, 0 },
#else
 { "GetVersionExW", (SYSCALL)0, 0 },
#endif
#define osGetVersionExW ((BOOL(WINAPI*)(  LPOSVERSIONINFOW))aSyscall[35].pCurrent)

 { "HeapAlloc", (SYSCALL)HeapAlloc, 0 },
#define osHeapAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD,  SIZE_T))aSyscall[36].pCurrent)

#if !SQLITE_OS_WINRT
 { "HeapCreate", (SYSCALL)HeapCreate, 0 },
#else
 { "HeapCreate", (SYSCALL)0, 0 },
#endif
#define osHeapCreate ((HANDLE(WINAPI*)(DWORD,SIZE_T,  SIZE_T))aSyscall[37].pCurrent)

#if !SQLITE_OS_WINRT
 { "HeapDestroy", (SYSCALL)HeapDestroy, 0 },
#else
 { "HeapDestroy", (SYSCALL)0, 0 },
#endif
#define osHeapDestroy ((BOOL(WINAPI*)(HANDLE))aSyscall[38].pCurrent)
 { "HeapFree", (SYSCALL)HeapFree, 0 },
#define osHeapFree ((BOOL(WINAPI*)(HANDLE,DWORD,LPVOID))aSyscall[39].pCurrent)
 { "HeapReAlloc", (SYSCALL)HeapReAlloc, 0 },
#define osHeapReAlloc ((LPVOID(WINAPI*)(HANDLE,DWORD,LPVOID,  SIZE_T))aSyscall[40].pCurrent)

 { "HeapSize", (SYSCALL)HeapSize, 0 },
#define osHeapSize ((SIZE_T(WINAPI*)(HANDLE,DWORD,  LPCVOID))aSyscall[41].pCurrent)

#if !SQLITE_OS_WINRT
 { "HeapValidate", (SYSCALL)HeapValidate, 0 },
#else
 { "HeapValidate", (SYSCALL)0, 0 },
#endif
#define osHeapValidate ((BOOL(WINAPI*)(HANDLE,DWORD,  LPCVOID))aSyscall[42].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
 { "HeapCompact", (SYSCALL)HeapCompact, 0 },
#else
 { "HeapCompact", (SYSCALL)0, 0 },
#endif
#define osHeapCompact ((UINT(WINAPI*)(HANDLE,DWORD))aSyscall[43].pCurrent)
#if defined(SQLITE_WIN32_HAS_ANSI) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
 { "LoadLibraryA", (SYSCALL)LoadLibraryA, 0 },
#else
 { "LoadLibraryA", (SYSCALL)0, 0 },
#endif
#define osLoadLibraryA ((HMODULE(WINAPI*)(LPCSTR))aSyscall[44].pCurrent)
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_HAS_WIDE) &&  !defined(SQLITE_OMIT_LOAD_EXTENSION)

 { "LoadLibraryW", (SYSCALL)LoadLibraryW, 0 },
#else
 { "LoadLibraryW", (SYSCALL)0, 0 },
#endif
#define osLoadLibraryW ((HMODULE(WINAPI*)(LPCWSTR))aSyscall[45].pCurrent)
#if !SQLITE_OS_WINRT
 { "LocalFree", (SYSCALL)LocalFree, 0 },
#else
 { "LocalFree", (SYSCALL)0, 0 },
#endif
#define osLocalFree ((HLOCAL(WINAPI*)(HLOCAL))aSyscall[46].pCurrent)
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
 { "LockFile", (SYSCALL)LockFile, 0 },
#else
 { "LockFile", (SYSCALL)0, 0 },
#endif
#ifndef osLockFile
#define osLockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,  DWORD))aSyscall[47].pCurrent)

#endif
#if !SQLITE_OS_WINCE
 { "LockFileEx", (SYSCALL)LockFileEx, 0 },
#else
 { "LockFileEx", (SYSCALL)0, 0 },
#endif
#ifndef osLockFileEx
#define osLockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,DWORD,  LPOVERLAPPED))aSyscall[48].pCurrent)

#endif
#if SQLITE_OS_WINCE || (!SQLITE_OS_WINRT &&  (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0))

 { "MapViewOfFile", (SYSCALL)MapViewOfFile, 0 },
#else
 { "MapViewOfFile", (SYSCALL)0, 0 },
#endif
#define osMapViewOfFile ((LPVOID(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,  SIZE_T))aSyscall[49].pCurrent)

 { "MultiByteToWideChar", (SYSCALL)MultiByteToWideChar, 0 },
#define osMultiByteToWideChar ((int(WINAPI*)(UINT,DWORD,LPCSTR,int,LPWSTR,  int))aSyscall[50].pCurrent)

 { "QueryPerformanceCounter", (SYSCALL)QueryPerformanceCounter, 0 },
#define osQueryPerformanceCounter ((BOOL(WINAPI*)(  LARGE_INTEGER*))aSyscall[51].pCurrent)

 { "ReadFile", (SYSCALL)ReadFile, 0 },
#define osReadFile ((BOOL(WINAPI*)(HANDLE,LPVOID,DWORD,LPDWORD,  LPOVERLAPPED))aSyscall[52].pCurrent)

 { "SetEndOfFile", (SYSCALL)SetEndOfFile, 0 },
#define osSetEndOfFile ((BOOL(WINAPI*)(HANDLE))aSyscall[53].pCurrent)
#if !SQLITE_OS_WINRT
 { "SetFilePointer", (SYSCALL)SetFilePointer, 0 },
#else
 { "SetFilePointer", (SYSCALL)0, 0 },
#endif
#define osSetFilePointer ((DWORD(WINAPI*)(HANDLE,LONG,PLONG,  DWORD))aSyscall[54].pCurrent)

#if !SQLITE_OS_WINRT
 { "Sleep", (SYSCALL)Sleep, 0 },
#else
 { "Sleep", (SYSCALL)0, 0 },
#endif
#define osSleep ((VOID(WINAPI*)(DWORD))aSyscall[55].pCurrent)
 { "SystemTimeToFileTime", (SYSCALL)SystemTimeToFileTime, 0 },
#define osSystemTimeToFileTime ((BOOL(WINAPI*)(CONST SYSTEMTIME*,  LPFILETIME))aSyscall[56].pCurrent)

#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
 { "UnlockFile", (SYSCALL)UnlockFile, 0 },
#else
 { "UnlockFile", (SYSCALL)0, 0 },
#endif
#ifndef osUnlockFile
#define osUnlockFile ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,  DWORD))aSyscall[57].pCurrent)

#endif
#if !SQLITE_OS_WINCE
 { "UnlockFileEx", (SYSCALL)UnlockFileEx, 0 },
#else
 { "UnlockFileEx", (SYSCALL)0, 0 },
#endif
#define osUnlockFileEx ((BOOL(WINAPI*)(HANDLE,DWORD,DWORD,DWORD,  LPOVERLAPPED))aSyscall[58].pCurrent)

#if SQLITE_OS_WINCE || !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
 { "UnmapViewOfFile", (SYSCALL)UnmapViewOfFile, 0 },
#else
 { "UnmapViewOfFile", (SYSCALL)0, 0 },
#endif
#define osUnmapViewOfFile ((BOOL(WINAPI*)(LPCVOID))aSyscall[59].pCurrent)
 { "WideCharToMultiByte", (SYSCALL)WideCharToMultiByte, 0 },
#define osWideCharToMultiByte ((int(WINAPI*)(UINT,DWORD,LPCWSTR,int,LPSTR,int,  LPCSTR,LPBOOL))aSyscall[60].pCurrent)

 { "WriteFile", (SYSCALL)WriteFile, 0 },
#define osWriteFile ((BOOL(WINAPI*)(HANDLE,LPCVOID,DWORD,LPDWORD,  LPOVERLAPPED))aSyscall[61].pCurrent)

#if SQLITE_OS_WINRT
 { "CreateEventExW", (SYSCALL)CreateEventExW, 0 },
#else
 { "CreateEventExW", (SYSCALL)0, 0 },
#endif
#define osCreateEventExW ((HANDLE(WINAPI*)(LPSECURITY_ATTRIBUTES,LPCWSTR,  DWORD,DWORD))aSyscall[62].pCurrent)

#if !SQLITE_OS_WINRT
 { "WaitForSingleObject", (SYSCALL)WaitForSingleObject, 0 },
#else
 { "WaitForSingleObject", (SYSCALL)0, 0 },
#endif
#define osWaitForSingleObject ((DWORD(WINAPI*)(HANDLE,  DWORD))aSyscall[63].pCurrent)

#if !SQLITE_OS_WINCE
 { "WaitForSingleObjectEx", (SYSCALL)WaitForSingleObjectEx, 0 },
#else
 { "WaitForSingleObjectEx", (SYSCALL)0, 0 },
#endif
#define osWaitForSingleObjectEx ((DWORD(WINAPI*)(HANDLE,DWORD,  BOOL))aSyscall[64].pCurrent)

#if SQLITE_OS_WINRT
 { "SetFilePointerEx", (SYSCALL)SetFilePointerEx, 0 },
#else
 { "SetFilePointerEx", (SYSCALL)0, 0 },
#endif
#define osSetFilePointerEx ((BOOL(WINAPI*)(HANDLE,LARGE_INTEGER,  PLARGE_INTEGER,DWORD))aSyscall[65].pCurrent)

#if SQLITE_OS_WINRT
 { "GetFileInformationByHandleEx", (SYSCALL)GetFileInformationByHandleEx, 0 },
#else
 { "GetFileInformationByHandleEx", (SYSCALL)0, 0 },
#endif
#define osGetFileInformationByHandleEx ((BOOL(WINAPI*)(HANDLE,  FILE_INFO_BY_HANDLE_CLASS,LPVOID,DWORD))aSyscall[66].pCurrent)

#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
 { "MapViewOfFileFromApp", (SYSCALL)MapViewOfFileFromApp, 0 },
#else
 { "MapViewOfFileFromApp", (SYSCALL)0, 0 },
#endif
#define osMapViewOfFileFromApp ((LPVOID(WINAPI*)(HANDLE,ULONG,ULONG64,  SIZE_T))aSyscall[67].pCurrent)

#if SQLITE_OS_WINRT
 { "CreateFile2", (SYSCALL)CreateFile2, 0 },
#else
 { "CreateFile2", (SYSCALL)0, 0 },
#endif
#define osCreateFile2 ((HANDLE(WINAPI*)(LPCWSTR,DWORD,DWORD,DWORD,  LPCREATEFILE2_EXTENDED_PARAMETERS))aSyscall[68].pCurrent)

#if SQLITE_OS_WINRT && !defined(SQLITE_OMIT_LOAD_EXTENSION)
 { "LoadPackagedLibrary", (SYSCALL)LoadPackagedLibrary, 0 },
#else
 { "LoadPackagedLibrary", (SYSCALL)0, 0 },
#endif
#define osLoadPackagedLibrary ((HMODULE(WINAPI*)(LPCWSTR,  DWORD))aSyscall[69].pCurrent)

#if SQLITE_OS_WINRT
 { "GetTickCount64", (SYSCALL)GetTickCount64, 0 },
#else
 { "GetTickCount64", (SYSCALL)0, 0 },
#endif
#define osGetTickCount64 ((ULONGLONG(WINAPI*)(VOID))aSyscall[70].pCurrent)
#if SQLITE_OS_WINRT
 { "GetNativeSystemInfo", (SYSCALL)GetNativeSystemInfo, 0 },
#else
 { "GetNativeSystemInfo", (SYSCALL)0, 0 },
#endif
#define osGetNativeSystemInfo ((VOID(WINAPI*)(  LPSYSTEM_INFO))aSyscall[71].pCurrent)

#if defined(SQLITE_WIN32_HAS_ANSI)
 { "OutputDebugStringA", (SYSCALL)OutputDebugStringA, 0 },
#else
 { "OutputDebugStringA", (SYSCALL)0, 0 },
#endif
#define osOutputDebugStringA ((VOID(WINAPI*)(LPCSTR))aSyscall[72].pCurrent)
#if defined(SQLITE_WIN32_HAS_WIDE)
 { "OutputDebugStringW", (SYSCALL)OutputDebugStringW, 0 },
#else
 { "OutputDebugStringW", (SYSCALL)0, 0 },
#endif
#define osOutputDebugStringW ((VOID(WINAPI*)(LPCWSTR))aSyscall[73].pCurrent)
 { "GetProcessHeap", (SYSCALL)GetProcessHeap, 0 },
#define osGetProcessHeap ((HANDLE(WINAPI*)(VOID))aSyscall[74].pCurrent)
#if SQLITE_OS_WINRT && (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0)
 { "CreateFileMappingFromApp", (SYSCALL)CreateFileMappingFromApp, 0 },
#else
 { "CreateFileMappingFromApp", (SYSCALL)0, 0 },
#endif
#define osCreateFileMappingFromApp ((HANDLE(WINAPI*)(HANDLE,  LPSECURITY_ATTRIBUTES,ULONG,ULONG64,LPCWSTR))aSyscall[75].pCurrent)

#if defined(InterlockedCompareExchange)
 { "InterlockedCompareExchange", (SYSCALL)0, 0 },
#define osInterlockedCompareExchange InterlockedCompareExchange
#else
 { "InterlockedCompareExchange", (SYSCALL)InterlockedCompareExchange, 0 },
#define osInterlockedCompareExchange ((LONG(WINAPI*)(LONG  SQLITE_WIN32_VOLATILE*, LONG,LONG))aSyscall[76].pCurrent)

#endif
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
 { "UuidCreate", (SYSCALL)UuidCreate, 0 },
#else
 { "UuidCreate", (SYSCALL)0, 0 },
#endif
#define osUuidCreate ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[77].pCurrent)
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
 { "UuidCreateSequential", (SYSCALL)UuidCreateSequential, 0 },
#else
 { "UuidCreateSequential", (SYSCALL)0, 0 },
#endif
#define osUuidCreateSequential  ((RPC_STATUS(RPC_ENTRY*)(UUID*))aSyscall[78].pCurrent)

#if !defined(SQLITE_NO_SYNC) && SQLITE_MAX_MMAP_SIZE>0
 { "FlushViewOfFile", (SYSCALL)FlushViewOfFile, 0 },
#else
 { "FlushViewOfFile", (SYSCALL)0, 0 },
#endif
#define osFlushViewOfFile  ((BOOL(WINAPI*)(LPCVOID,SIZE_T))aSyscall[79].pCurrent)

}; static int winSetSystemCall(  sqlite3_vfs *pNotUsed,  const char *zName,  sqlite3_syscall_ptr pNewFunc ){  unsigned int i;  int rc = SQLITE_NOTFOUND;  UNUSED_PARAMETER(pNotUsed);  if( zName==0 ){  rc = SQLITE_OK;  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){  if( aSyscall[i].pDefault ){  aSyscall[i].pCurrent = aSyscall[i].pDefault;  }  }  }else{  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){  if( strcmp(zName, aSyscall[i].zName)==0 ){  if( aSyscall[i].pDefault==0 ){  aSyscall[i].pDefault = aSyscall[i].pCurrent;  }  rc = SQLITE_OK;  if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;  aSyscall[i].pCurrent = pNewFunc;  break;  }  }  }  return rc; } static sqlite3_syscall_ptr winGetSystemCall(  sqlite3_vfs *pNotUsed,  const char *zName ){  unsigned int i;  UNUSED_PARAMETER(pNotUsed);  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){  if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;  }  return 0; } static const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){  int i = -1;  UNUSED_PARAMETER(p);  if( zName ){  for(i=0; i<ArraySize(aSyscall)-1; i++){  if( strcmp(zName, aSyscall[i].zName)==0 ) break;  }  }  for(i++; i<ArraySize(aSyscall); i++){  if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;  }  return 0; }
#ifdef SQLITE_WIN32_MALLOC
SQLITE_API int sqlite3_win32_compact_heap(LPUINT pnLargest){  int rc = SQLITE_OK;  UINT nLargest = 0;  HANDLE hHeap;  winMemAssertMagic();  hHeap = winMemGetHeap();  assert( hHeap!=0 );  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT
 if( (nLargest=osHeapCompact(hHeap, SQLITE_WIN32_HEAP_FLAGS))==0 ){  DWORD lastErrno = osGetLastError();  if( lastErrno==NO_ERROR ){  sqlite3_log(SQLITE_NOMEM, "failed to HeapCompact (no space), heap=%p",  (void*)hHeap);  rc = SQLITE_NOMEM_BKPT;  }else{  sqlite3_log(SQLITE_ERROR, "failed to HeapCompact (%lu), heap=%p",  osGetLastError(), (void*)hHeap);  rc = SQLITE_ERROR;  }  }
#else
 sqlite3_log(SQLITE_NOTFOUND, "failed to HeapCompact, heap=%p",  (void*)hHeap);  rc = SQLITE_NOTFOUND;
#endif
 if( pnLargest ) *pnLargest = nLargest;  return rc; } SQLITE_API int sqlite3_win32_reset_heap(){  int rc;  MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )  MUTEX_LOGIC( sqlite3_mutex *pMem; )  MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )  MUTEX_LOGIC( pMem = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM); )  sqlite3_mutex_enter(pMainMtx);  sqlite3_mutex_enter(pMem);  winMemAssertMagic();  if( winMemGetHeap()!=NULL && winMemGetOwned() && sqlite3_memory_used()==0 ){  assert( winMemGetHeap()!=NULL );  assert( winMemGetOwned() );  assert( sqlite3_memory_used()==0 );  winMemShutdown(winMemGetDataPtr());  assert( winMemGetHeap()==NULL );  assert( !winMemGetOwned() );  assert( sqlite3_memory_used()==0 );  rc = winMemInit(winMemGetDataPtr());  assert( rc!=SQLITE_OK || winMemGetHeap()!=NULL );  assert( rc!=SQLITE_OK || winMemGetOwned() );  assert( rc!=SQLITE_OK || sqlite3_memory_used()==0 );  }else{  rc = SQLITE_BUSY;  }  sqlite3_mutex_leave(pMem);  sqlite3_mutex_leave(pMainMtx);  return rc; }
#endif
SQLITE_API void sqlite3_win32_write_debug(const char *zBuf, int nBuf){  char zDbgBuf[SQLITE_WIN32_DBG_BUF_SIZE];  int nMin = MIN(nBuf, (SQLITE_WIN32_DBG_BUF_SIZE - 1));  if( nMin<-1 ) nMin = -1;  assert( nMin==-1 || nMin==0 || nMin<SQLITE_WIN32_DBG_BUF_SIZE );
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zBuf ){  (void)SQLITE_MISUSE_BKPT;  return;  }
#endif
#if defined(SQLITE_WIN32_HAS_ANSI)
 if( nMin>0 ){  memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);  memcpy(zDbgBuf, zBuf, nMin);  osOutputDebugStringA(zDbgBuf);  }else{  osOutputDebugStringA(zBuf);  }
#elif defined(SQLITE_WIN32_HAS_WIDE)
 memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);  if ( osMultiByteToWideChar(  osAreFileApisANSI() ? CP_ACP : CP_OEMCP, 0, zBuf,  nMin, (LPWSTR)zDbgBuf, SQLITE_WIN32_DBG_BUF_SIZE/sizeof(WCHAR))<=0 ){  return;  }  osOutputDebugStringW((LPCWSTR)zDbgBuf);
#else
 if( nMin>0 ){  memset(zDbgBuf, 0, SQLITE_WIN32_DBG_BUF_SIZE);  memcpy(zDbgBuf, zBuf, nMin);  fprintf(stderr, "%s", zDbgBuf);  }else{  fprintf(stderr, "%s", zBuf);  }
#endif
}
#if SQLITE_OS_WINRT
static HANDLE sleepObj = NULL;
#endif
SQLITE_API void sqlite3_win32_sleep(DWORD milliseconds){
#if SQLITE_OS_WINRT
 if ( sleepObj==NULL ){  sleepObj = osCreateEventExW(NULL, NULL, CREATE_EVENT_MANUAL_RESET,  SYNCHRONIZE);  }  assert( sleepObj!=NULL );  osWaitForSingleObjectEx(sleepObj, milliseconds, FALSE);
#else
 osSleep(milliseconds);
#endif
}
#if SQLITE_MAX_WORKER_THREADS>0 && !SQLITE_OS_WINCE && !SQLITE_OS_WINRT &&  SQLITE_THREADSAFE>0

SQLITE_PRIVATE DWORD sqlite3Win32Wait(HANDLE hObject){  DWORD rc;  while( (rc = osWaitForSingleObjectEx(hObject, INFINITE,   TRUE))==WAIT_IO_COMPLETION ){}  return rc; }
#endif
#if !SQLITE_WIN32_GETVERSIONEX
# define osIsNT() (1)
#elif SQLITE_OS_WINCE || SQLITE_OS_WINRT || !defined(SQLITE_WIN32_HAS_ANSI)
# define osIsNT() (1)
#elif !defined(SQLITE_WIN32_HAS_WIDE)
# define osIsNT() (0)
#else
# define osIsNT() ((sqlite3_os_type==2) || sqlite3_win32_is_nt())
#endif
SQLITE_API int sqlite3_win32_is_nt(void){
#if SQLITE_OS_WINRT
 return 1;
#elif SQLITE_WIN32_GETVERSIONEX
 if( osInterlockedCompareExchange(&sqlite3_os_type, 0, 0)==0 ){
#if defined(SQLITE_WIN32_HAS_ANSI)
 OSVERSIONINFOA sInfo;  sInfo.dwOSVersionInfoSize = sizeof(sInfo);  osGetVersionExA(&sInfo);  osInterlockedCompareExchange(&sqlite3_os_type,  (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);
#elif defined(SQLITE_WIN32_HAS_WIDE)
 OSVERSIONINFOW sInfo;  sInfo.dwOSVersionInfoSize = sizeof(sInfo);  osGetVersionExW(&sInfo);  osInterlockedCompareExchange(&sqlite3_os_type,  (sInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) ? 2 : 1, 0);
#endif
 }  return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;
#elif SQLITE_TEST
 return osInterlockedCompareExchange(&sqlite3_os_type, 2, 2)==2;
#else
 return 1;
#endif
}
#ifdef SQLITE_WIN32_MALLOC
static void *winMemMalloc(int nBytes){  HANDLE hHeap;  void *p;  winMemAssertMagic();  hHeap = winMemGetHeap();  assert( hHeap!=0 );  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
 assert( nBytes>=0 );  p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);  if( !p ){  sqlite3_log(SQLITE_NOMEM, "failed to HeapAlloc %u bytes (%lu), heap=%p",  nBytes, osGetLastError(), (void*)hHeap);  }  return p; } static void winMemFree(void *pPrior){  HANDLE hHeap;  winMemAssertMagic();  hHeap = winMemGetHeap();  assert( hHeap!=0 );  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
#endif
 if( !pPrior ) return;  if( !osHeapFree(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) ){  sqlite3_log(SQLITE_NOMEM, "failed to HeapFree block %p (%lu), heap=%p",  pPrior, osGetLastError(), (void*)hHeap);  } } static void *winMemRealloc(void *pPrior, int nBytes){  HANDLE hHeap;  void *p;  winMemAssertMagic();  hHeap = winMemGetHeap();  assert( hHeap!=0 );  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior) );
#endif
 assert( nBytes>=0 );  if( !pPrior ){  p = osHeapAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, (SIZE_T)nBytes);  }else{  p = osHeapReAlloc(hHeap, SQLITE_WIN32_HEAP_FLAGS, pPrior, (SIZE_T)nBytes);  }  if( !p ){  sqlite3_log(SQLITE_NOMEM, "failed to %s %u bytes (%lu), heap=%p",  pPrior ? "HeapReAlloc" : "HeapAlloc", nBytes, osGetLastError(),  (void*)hHeap);  }  return p; } static int winMemSize(void *p){  HANDLE hHeap;  SIZE_T n;  winMemAssertMagic();  hHeap = winMemGetHeap();  assert( hHeap!=0 );  assert( hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(hHeap, SQLITE_WIN32_HEAP_FLAGS, p) );
#endif
 if( !p ) return 0;  n = osHeapSize(hHeap, SQLITE_WIN32_HEAP_FLAGS, p);  if( n==(SIZE_T)-1 ){  sqlite3_log(SQLITE_NOMEM, "failed to HeapSize block %p (%lu), heap=%p",  p, osGetLastError(), (void*)hHeap);  return 0;  }  return (int)n; } static int winMemRoundup(int n){  return n; } static int winMemInit(void *pAppData){  winMemData *pWinMemData = (winMemData *)pAppData;  if( !pWinMemData ) return SQLITE_ERROR;  assert( pWinMemData->magic1==WINMEM_MAGIC1 );  assert( pWinMemData->magic2==WINMEM_MAGIC2 );
#if !SQLITE_OS_WINRT && SQLITE_WIN32_HEAP_CREATE
 if( !pWinMemData->hHeap ){  DWORD dwInitialSize = SQLITE_WIN32_HEAP_INIT_SIZE;  DWORD dwMaximumSize = (DWORD)sqlite3GlobalConfig.nHeap;  if( dwMaximumSize==0 ){  dwMaximumSize = SQLITE_WIN32_HEAP_MAX_SIZE;  }else if( dwInitialSize>dwMaximumSize ){  dwInitialSize = dwMaximumSize;  }  pWinMemData->hHeap = osHeapCreate(SQLITE_WIN32_HEAP_FLAGS,  dwInitialSize, dwMaximumSize);  if( !pWinMemData->hHeap ){  sqlite3_log(SQLITE_NOMEM,  "failed to HeapCreate (%lu), flags=%u, initSize=%lu, maxSize=%lu",  osGetLastError(), SQLITE_WIN32_HEAP_FLAGS, dwInitialSize,  dwMaximumSize);  return SQLITE_NOMEM_BKPT;  }  pWinMemData->bOwned = TRUE;  assert( pWinMemData->bOwned );  }
#else
 pWinMemData->hHeap = osGetProcessHeap();  if( !pWinMemData->hHeap ){  sqlite3_log(SQLITE_NOMEM,  "failed to GetProcessHeap (%lu)", osGetLastError());  return SQLITE_NOMEM_BKPT;  }  pWinMemData->bOwned = FALSE;  assert( !pWinMemData->bOwned );
#endif
 assert( pWinMemData->hHeap!=0 );  assert( pWinMemData->hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
 return SQLITE_OK; } static void winMemShutdown(void *pAppData){  winMemData *pWinMemData = (winMemData *)pAppData;  if( !pWinMemData ) return;  assert( pWinMemData->magic1==WINMEM_MAGIC1 );  assert( pWinMemData->magic2==WINMEM_MAGIC2 );  if( pWinMemData->hHeap ){  assert( pWinMemData->hHeap!=INVALID_HANDLE_VALUE );
#if !SQLITE_OS_WINRT && defined(SQLITE_WIN32_MALLOC_VALIDATE)
 assert( osHeapValidate(pWinMemData->hHeap, SQLITE_WIN32_HEAP_FLAGS, NULL) );
#endif
 if( pWinMemData->bOwned ){  if( !osHeapDestroy(pWinMemData->hHeap) ){  sqlite3_log(SQLITE_NOMEM, "failed to HeapDestroy (%lu), heap=%p",  osGetLastError(), (void*)pWinMemData->hHeap);  }  pWinMemData->bOwned = FALSE;  }  pWinMemData->hHeap = NULL;  } } SQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetWin32(void){  static const sqlite3_mem_methods winMemMethods = {  winMemMalloc,  winMemFree,  winMemRealloc,  winMemSize,  winMemRoundup,  winMemInit,  winMemShutdown,  &win_mem_data  };  return &winMemMethods; } SQLITE_PRIVATE void sqlite3MemSetDefault(void){  sqlite3_config(SQLITE_CONFIG_MALLOC, sqlite3MemGetWin32()); }
#endif
static LPWSTR winUtf8ToUnicode(const char *zText){  int nChar;  LPWSTR zWideText;  nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, NULL, 0);  if( nChar==0 ){  return 0;  }  zWideText = sqlite3MallocZero( nChar*sizeof(WCHAR) );  if( zWideText==0 ){  return 0;  }  nChar = osMultiByteToWideChar(CP_UTF8, 0, zText, -1, zWideText,  nChar);  if( nChar==0 ){  sqlite3_free(zWideText);  zWideText = 0;  }  return zWideText; } static char *winUnicodeToUtf8(LPCWSTR zWideText){  int nByte;  char *zText;  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, 0, 0, 0, 0);  if( nByte == 0 ){  return 0;  }  zText = sqlite3MallocZero( nByte );  if( zText==0 ){  return 0;  }  nByte = osWideCharToMultiByte(CP_UTF8, 0, zWideText, -1, zText, nByte,  0, 0);  if( nByte == 0 ){  sqlite3_free(zText);  zText = 0;  }  return zText; } static LPWSTR winMbcsToUnicode(const char *zText, int useAnsi){  int nByte;  LPWSTR zMbcsText;  int codepage = useAnsi ? CP_ACP : CP_OEMCP;  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, NULL,  0)*sizeof(WCHAR);  if( nByte==0 ){  return 0;  }  zMbcsText = sqlite3MallocZero( nByte*sizeof(WCHAR) );  if( zMbcsText==0 ){  return 0;  }  nByte = osMultiByteToWideChar(codepage, 0, zText, -1, zMbcsText,  nByte);  if( nByte==0 ){  sqlite3_free(zMbcsText);  zMbcsText = 0;  }  return zMbcsText; } static char *winUnicodeToMbcs(LPCWSTR zWideText, int useAnsi){  int nByte;  char *zText;  int codepage = useAnsi ? CP_ACP : CP_OEMCP;  nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, 0, 0, 0, 0);  if( nByte == 0 ){  return 0;  }  zText = sqlite3MallocZero( nByte );  if( zText==0 ){  return 0;  }  nByte = osWideCharToMultiByte(codepage, 0, zWideText, -1, zText,  nByte, 0, 0);  if( nByte == 0 ){  sqlite3_free(zText);  zText = 0;  }  return zText; } static char *winMbcsToUtf8(const char *zText, int useAnsi){  char *zTextUtf8;  LPWSTR zTmpWide;  zTmpWide = winMbcsToUnicode(zText, useAnsi);  if( zTmpWide==0 ){  return 0;  }  zTextUtf8 = winUnicodeToUtf8(zTmpWide);  sqlite3_free(zTmpWide);  return zTextUtf8; } static char *winUtf8ToMbcs(const char *zText, int useAnsi){  char *zTextMbcs;  LPWSTR zTmpWide;  zTmpWide = winUtf8ToUnicode(zText);  if( zTmpWide==0 ){  return 0;  }  zTextMbcs = winUnicodeToMbcs(zTmpWide, useAnsi);  sqlite3_free(zTmpWide);  return zTextMbcs; } SQLITE_API LPWSTR sqlite3_win32_utf8_to_unicode(const char *zText){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zText ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return winUtf8ToUnicode(zText); } SQLITE_API char *sqlite3_win32_unicode_to_utf8(LPCWSTR zWideText){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zWideText ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return winUnicodeToUtf8(zWideText); } SQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zText){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zText ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return winMbcsToUtf8(zText, osAreFileApisANSI()); } SQLITE_API char *sqlite3_win32_mbcs_to_utf8_v2(const char *zText, int useAnsi){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zText ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return winMbcsToUtf8(zText, useAnsi); } SQLITE_API char *sqlite3_win32_utf8_to_mbcs(const char *zText){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zText ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return winUtf8ToMbcs(zText, osAreFileApisANSI()); } SQLITE_API char *sqlite3_win32_utf8_to_mbcs_v2(const char *zText, int useAnsi){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !zText ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize() ) return 0;
#endif
 return winUtf8ToMbcs(zText, useAnsi); } SQLITE_API int sqlite3_win32_set_directory8(  unsigned long type,  const char *zValue ){  char **ppDirectory = 0;
#ifndef SQLITE_OMIT_AUTOINIT
 int rc = sqlite3_initialize();  if( rc ) return rc;
#endif
 if( type==SQLITE_WIN32_DATA_DIRECTORY_TYPE ){  ppDirectory = &sqlite3_data_directory;  }else if( type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE ){  ppDirectory = &sqlite3_temp_directory;  }  assert( !ppDirectory || type==SQLITE_WIN32_DATA_DIRECTORY_TYPE  || type==SQLITE_WIN32_TEMP_DIRECTORY_TYPE  );  assert( !ppDirectory || sqlite3MemdebugHasType(*ppDirectory, MEMTYPE_HEAP) );  if( ppDirectory ){  char *zCopy = 0;  if( zValue && zValue[0] ){  zCopy = sqlite3_mprintf("%s", zValue);  if ( zCopy==0 ){  return SQLITE_NOMEM_BKPT;  }  }  sqlite3_free(*ppDirectory);  *ppDirectory = zCopy;  return SQLITE_OK;  }  return SQLITE_ERROR; } SQLITE_API int sqlite3_win32_set_directory16(  unsigned long type,  const void *zValue ){  int rc;  char *zUtf8 = 0;  if( zValue ){  zUtf8 = sqlite3_win32_unicode_to_utf8(zValue);  if( zUtf8==0 ) return SQLITE_NOMEM_BKPT;  }  rc = sqlite3_win32_set_directory8(type, zUtf8);  if( zUtf8 ) sqlite3_free(zUtf8);  return rc; } SQLITE_API int sqlite3_win32_set_directory(  unsigned long type,  void *zValue ){  return sqlite3_win32_set_directory16(type, zValue); } static int winGetLastErrorMsg(DWORD lastErrno, int nBuf, char *zBuf){  DWORD dwLen = 0;  char *zOut = 0;  if( osIsNT() ){
#if SQLITE_OS_WINRT
 WCHAR zTempWide[SQLITE_WIN32_MAX_ERRMSG_CHARS+1];  dwLen = osFormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |   FORMAT_MESSAGE_IGNORE_INSERTS,   NULL,   lastErrno,   0,   zTempWide,   SQLITE_WIN32_MAX_ERRMSG_CHARS,   0);
#else
 LPWSTR zTempWide = NULL;  dwLen = osFormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |   FORMAT_MESSAGE_FROM_SYSTEM |   FORMAT_MESSAGE_IGNORE_INSERTS,   NULL,   lastErrno,   0,   (LPWSTR) &zTempWide,   0,   0);
#endif
 if( dwLen > 0 ){  sqlite3BeginBenignMalloc();  zOut = winUnicodeToUtf8(zTempWide);  sqlite3EndBenignMalloc();
#if !SQLITE_OS_WINRT
 osLocalFree(zTempWide);
#endif
 }  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  char *zTemp = NULL;  dwLen = osFormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |   FORMAT_MESSAGE_FROM_SYSTEM |   FORMAT_MESSAGE_IGNORE_INSERTS,   NULL,   lastErrno,   0,   (LPSTR) &zTemp,   0,   0);  if( dwLen > 0 ){  sqlite3BeginBenignMalloc();  zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());  sqlite3EndBenignMalloc();  osLocalFree(zTemp);  }  }
#endif
 if( 0 == dwLen ){  sqlite3_snprintf(nBuf, zBuf, "OsError 0x%lx (%lu)", lastErrno, lastErrno);  }else{  sqlite3_snprintf(nBuf, zBuf, "%s", zOut);  sqlite3_free(zOut);  }  return 0; }
#define winLogError(a,b,c,d)  winLogErrorAtLine(a,b,c,d,__LINE__)
static int winLogErrorAtLine(  int errcode,  DWORD lastErrno,  const char *zFunc,  const char *zPath,  int iLine ){  char zMsg[500];  int i;  zMsg[0] = 0;  winGetLastErrorMsg(lastErrno, sizeof(zMsg), zMsg);  assert( errcode!=SQLITE_OK );  if( zPath==0 ) zPath = "";  for(i=0; zMsg[i] && zMsg[i]!='\r' && zMsg[i]!='\n'; i++){}  zMsg[i] = 0;  sqlite3_log(errcode,  "os_win.c:%d: (%lu) %s(%s) - %s",  iLine, lastErrno, zFunc, zPath, zMsg  );  return errcode; }
#ifndef SQLITE_WIN32_IOERR_RETRY
# define SQLITE_WIN32_IOERR_RETRY 10
#endif
#ifndef SQLITE_WIN32_IOERR_RETRY_DELAY
# define SQLITE_WIN32_IOERR_RETRY_DELAY 25
#endif
static int winIoerrRetry = SQLITE_WIN32_IOERR_RETRY; static int winIoerrRetryDelay = SQLITE_WIN32_IOERR_RETRY_DELAY;
#if !defined(winIoerrCanRetry1)
#define winIoerrCanRetry1(a) (((a)==ERROR_ACCESS_DENIED) ||  ((a)==ERROR_SHARING_VIOLATION) ||  ((a)==ERROR_LOCK_VIOLATION)  ||  ((a)==ERROR_DEV_NOT_EXIST) ||  ((a)==ERROR_NETNAME_DELETED) ||  ((a)==ERROR_SEM_TIMEOUT) ||  ((a)==ERROR_NETWORK_UNREACHABLE))

#endif
static int winRetryIoerr(int *pnRetry, DWORD *pError){  DWORD e = osGetLastError();  if( *pnRetry>=winIoerrRetry ){  if( pError ){  *pError = e;  }  return 0;  }  if( winIoerrCanRetry1(e) ){  sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));  ++*pnRetry;  return 1;  }
#if defined(winIoerrCanRetry2)
 else if( winIoerrCanRetry2(e) ){  sqlite3_win32_sleep(winIoerrRetryDelay*(1+*pnRetry));  ++*pnRetry;  return 1;  }
#endif
 if( pError ){  *pError = e;  }  return 0; } static void winLogIoerr(int nRetry, int lineno){  if( nRetry ){  sqlite3_log(SQLITE_NOTICE,  "delayed %dms for lock/sharing conflict at line %d",  winIoerrRetryDelay*nRetry*(nRetry+1)/2, lineno  );  } }
#if !defined(SQLITE_OMIT_LOCALTIME) && defined(_WIN32_WCE) &&  (!defined(SQLITE_MSVC_LOCALTIME_API) || !SQLITE_MSVC_LOCALTIME_API)

struct tm *__cdecl localtime(const time_t *t) {  static struct tm y;  FILETIME uTm, lTm;  SYSTEMTIME pTm;  sqlite3_int64 t64;  t64 = *t;  t64 = (t64 + 11644473600)*10000000;  uTm.dwLowDateTime = (DWORD)(t64 & 0xFFFFFFFF);  uTm.dwHighDateTime= (DWORD)(t64 >> 32);  osFileTimeToLocalFileTime(&uTm,&lTm);  osFileTimeToSystemTime(&lTm,&pTm);  y.tm_year = pTm.wYear - 1900;  y.tm_mon = pTm.wMonth - 1;  y.tm_wday = pTm.wDayOfWeek;  y.tm_mday = pTm.wDay;  y.tm_hour = pTm.wHour;  y.tm_min = pTm.wMinute;  y.tm_sec = pTm.wSecond;  return &y; }
#endif
#if SQLITE_OS_WINCE
#define HANDLE_TO_WINFILE(a) (winFile*)&((char*)a)[-(int)offsetof(winFile,h)]
static void winceMutexAcquire(HANDLE h){   DWORD dwErr;   do {   dwErr = osWaitForSingleObject(h, INFINITE);   } while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED); }
#define winceMutexRelease(h) ReleaseMutex(h)
static int winceCreateLock(const char *zFilename, winFile *pFile){  LPWSTR zTok;  LPWSTR zName;  DWORD lastErrno;  BOOL bLogged = FALSE;  BOOL bInit = TRUE;  zName = winUtf8ToUnicode(zFilename);  if( zName==0 ){  return SQLITE_IOERR_NOMEM_BKPT;  }  memset(&pFile->local, 0, sizeof(pFile->local));  zTok = osCharLowerW(zName);  for (;*zTok;zTok++){  if (*zTok == '\\') *zTok = '_';  }  pFile->hMutex = osCreateMutexW(NULL, FALSE, zName);  if (!pFile->hMutex){  pFile->lastErrno = osGetLastError();  sqlite3_free(zName);  return winLogError(SQLITE_IOERR, pFile->lastErrno,   "winceCreateLock1", zFilename);  }  winceMutexAcquire(pFile->hMutex);  osCharUpperW(zName);  pFile->hShared = osCreateFileMappingW(INVALID_HANDLE_VALUE, NULL,  PAGE_READWRITE, 0, sizeof(winceLock),  zName);  lastErrno = osGetLastError();  if (lastErrno == ERROR_ALREADY_EXISTS){  bInit = FALSE;  }  sqlite3_free(zName);  if( pFile->hShared ){  pFile->shared = (winceLock*)osMapViewOfFile(pFile->hShared,   FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, sizeof(winceLock));  if( !pFile->shared ){  pFile->lastErrno = osGetLastError();  winLogError(SQLITE_IOERR, pFile->lastErrno,  "winceCreateLock2", zFilename);  bLogged = TRUE;  osCloseHandle(pFile->hShared);  pFile->hShared = NULL;  }  }  if( pFile->hShared==NULL ){  if( !bLogged ){  pFile->lastErrno = lastErrno;  winLogError(SQLITE_IOERR, pFile->lastErrno,  "winceCreateLock3", zFilename);  bLogged = TRUE;  }  winceMutexRelease(pFile->hMutex);  osCloseHandle(pFile->hMutex);  pFile->hMutex = NULL;  return SQLITE_IOERR;  }  if( bInit ){  memset(pFile->shared, 0, sizeof(winceLock));  }  winceMutexRelease(pFile->hMutex);  return SQLITE_OK; } static void winceDestroyLock(winFile *pFile){  if (pFile->hMutex){  winceMutexAcquire(pFile->hMutex);  if (pFile->local.nReaders){  pFile->shared->nReaders --;  }  if (pFile->local.bReserved){  pFile->shared->bReserved = FALSE;  }  if (pFile->local.bPending){  pFile->shared->bPending = FALSE;  }  if (pFile->local.bExclusive){  pFile->shared->bExclusive = FALSE;  }  osUnmapViewOfFile(pFile->shared);  osCloseHandle(pFile->hShared);  winceMutexRelease(pFile->hMutex);  osCloseHandle(pFile->hMutex);  pFile->hMutex = NULL;  } } static BOOL winceLockFile(  LPHANDLE phFile,  DWORD dwFileOffsetLow,  DWORD dwFileOffsetHigh,  DWORD nNumberOfBytesToLockLow,  DWORD nNumberOfBytesToLockHigh ){  winFile *pFile = HANDLE_TO_WINFILE(phFile);  BOOL bReturn = FALSE;  UNUSED_PARAMETER(dwFileOffsetHigh);  UNUSED_PARAMETER(nNumberOfBytesToLockHigh);  if (!pFile->hMutex) return TRUE;  winceMutexAcquire(pFile->hMutex);  if (dwFileOffsetLow == (DWORD)SHARED_FIRST   && nNumberOfBytesToLockLow == (DWORD)SHARED_SIZE){  if (pFile->shared->nReaders == 0 && pFile->shared->bExclusive == 0){   pFile->shared->bExclusive = TRUE;   pFile->local.bExclusive = TRUE;   bReturn = TRUE;  }  }  else if (dwFileOffsetLow == (DWORD)SHARED_FIRST &&   nNumberOfBytesToLockLow == 1){  if (pFile->shared->bExclusive == 0){  pFile->local.nReaders ++;  if (pFile->local.nReaders == 1){  pFile->shared->nReaders ++;  }  bReturn = TRUE;  }  }  else if (dwFileOffsetLow == (DWORD)PENDING_BYTE   && nNumberOfBytesToLockLow == 1){  if (pFile->shared->bPending == 0) {  pFile->shared->bPending = TRUE;  pFile->local.bPending = TRUE;  bReturn = TRUE;  }  }  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTE   && nNumberOfBytesToLockLow == 1){  if (pFile->shared->bReserved == 0) {  pFile->shared->bReserved = TRUE;  pFile->local.bReserved = TRUE;  bReturn = TRUE;  }  }  winceMutexRelease(pFile->hMutex);  return bReturn; } static BOOL winceUnlockFile(  LPHANDLE phFile,  DWORD dwFileOffsetLow,  DWORD dwFileOffsetHigh,  DWORD nNumberOfBytesToUnlockLow,  DWORD nNumberOfBytesToUnlockHigh ){  winFile *pFile = HANDLE_TO_WINFILE(phFile);  BOOL bReturn = FALSE;  UNUSED_PARAMETER(dwFileOffsetHigh);  UNUSED_PARAMETER(nNumberOfBytesToUnlockHigh);  if (!pFile->hMutex) return TRUE;  winceMutexAcquire(pFile->hMutex);  if (dwFileOffsetLow == (DWORD)SHARED_FIRST){  if (pFile->local.bExclusive){  assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE);  pFile->local.bExclusive = FALSE;  pFile->shared->bExclusive = FALSE;  bReturn = TRUE;  }  else if (pFile->local.nReaders){  assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE   || nNumberOfBytesToUnlockLow == 1);  pFile->local.nReaders --;  if (pFile->local.nReaders == 0)  {  pFile->shared->nReaders --;  }  bReturn = TRUE;  }  }  else if (dwFileOffsetLow == (DWORD)PENDING_BYTE   && nNumberOfBytesToUnlockLow == 1){  if (pFile->local.bPending){  pFile->local.bPending = FALSE;  pFile->shared->bPending = FALSE;  bReturn = TRUE;  }  }  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTE   && nNumberOfBytesToUnlockLow == 1){  if (pFile->local.bReserved) {  pFile->local.bReserved = FALSE;  pFile->shared->bReserved = FALSE;  bReturn = TRUE;  }  }  winceMutexRelease(pFile->hMutex);  return bReturn; }
#endif
static BOOL winLockFile(  LPHANDLE phFile,  DWORD flags,  DWORD offsetLow,  DWORD offsetHigh,  DWORD numBytesLow,  DWORD numBytesHigh ){
#if SQLITE_OS_WINCE
 return winceLockFile(phFile, offsetLow, offsetHigh,   numBytesLow, numBytesHigh);
#else
 if( osIsNT() ){  OVERLAPPED ovlp;  memset(&ovlp, 0, sizeof(OVERLAPPED));  ovlp.Offset = offsetLow;  ovlp.OffsetHigh = offsetHigh;  return osLockFileEx(*phFile, flags, 0, numBytesLow, numBytesHigh, &ovlp);  }else{  return osLockFile(*phFile, offsetLow, offsetHigh, numBytesLow,  numBytesHigh);  }
#endif
} static BOOL winUnlockFile(  LPHANDLE phFile,  DWORD offsetLow,  DWORD offsetHigh,  DWORD numBytesLow,  DWORD numBytesHigh ){
#if SQLITE_OS_WINCE
 return winceUnlockFile(phFile, offsetLow, offsetHigh,   numBytesLow, numBytesHigh);
#else
 if( osIsNT() ){  OVERLAPPED ovlp;  memset(&ovlp, 0, sizeof(OVERLAPPED));  ovlp.Offset = offsetLow;  ovlp.OffsetHigh = offsetHigh;  return osUnlockFileEx(*phFile, 0, numBytesLow, numBytesHigh, &ovlp);  }else{  return osUnlockFile(*phFile, offsetLow, offsetHigh, numBytesLow,  numBytesHigh);  }
#endif
}
#ifndef INVALID_SET_FILE_POINTER
# define INVALID_SET_FILE_POINTER ((DWORD)-1)
#endif
static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset){
#if !SQLITE_OS_WINRT
 LONG upperBits;  LONG lowerBits;  DWORD dwRet;  DWORD lastErrno;  OSTRACE(("SEEK file=%p, offset=%lld\n", pFile->h, iOffset));  upperBits = (LONG)((iOffset>>32) & 0x7fffffff);  lowerBits = (LONG)(iOffset & 0xffffffff);  dwRet = osSetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN);  if( (dwRet==INVALID_SET_FILE_POINTER  && ((lastErrno = osGetLastError())!=NO_ERROR)) ){  pFile->lastErrno = lastErrno;  winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,  "winSeekFile", pFile->zPath);  OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));  return 1;  }  OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));  return 0;
#else
 LARGE_INTEGER x;  BOOL bRet;  x.QuadPart = iOffset;  bRet = osSetFilePointerEx(pFile->h, x, 0, FILE_BEGIN);  if(!bRet){  pFile->lastErrno = osGetLastError();  winLogError(SQLITE_IOERR_SEEK, pFile->lastErrno,  "winSeekFile", pFile->zPath);  OSTRACE(("SEEK file=%p, rc=SQLITE_IOERR_SEEK\n", pFile->h));  return 1;  }  OSTRACE(("SEEK file=%p, rc=SQLITE_OK\n", pFile->h));  return 0;
#endif
}
#if SQLITE_MAX_MMAP_SIZE>0
static int winMapfile(winFile*, sqlite3_int64); static int winUnmapfile(winFile*);
#endif
#define MX_CLOSE_ATTEMPT 3
static int winClose(sqlite3_file *id){  int rc, cnt = 0;  winFile *pFile = (winFile*)id;  assert( id!=0 );
#ifndef SQLITE_OMIT_WAL
 assert( pFile->pShm==0 );
#endif
 assert( pFile->h!=NULL && pFile->h!=INVALID_HANDLE_VALUE );  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p\n",   osGetCurrentProcessId(), pFile, pFile->h));
#if SQLITE_MAX_MMAP_SIZE>0
 winUnmapfile(pFile);
#endif
 do{  rc = osCloseHandle(pFile->h);  }while( rc==0 && ++cnt < MX_CLOSE_ATTEMPT && (sqlite3_win32_sleep(100), 1) );
#if SQLITE_OS_WINCE
#define WINCE_DELETION_ATTEMPTS 3
 {  winVfsAppData *pAppData = (winVfsAppData*)pFile->pVfs->pAppData;  if( pAppData==NULL || !pAppData->bNoLock ){  winceDestroyLock(pFile);  }  }  if( pFile->zDeleteOnClose ){  int cnt = 0;  while(   osDeleteFileW(pFile->zDeleteOnClose)==0  && osGetFileAttributesW(pFile->zDeleteOnClose)!=0xffffffff  && cnt++ < WINCE_DELETION_ATTEMPTS  ){   sqlite3_win32_sleep(100);  }  sqlite3_free(pFile->zDeleteOnClose);  }
#endif
 if( rc ){  pFile->h = NULL;  }  OpenCounter(-1);  OSTRACE(("CLOSE pid=%lu, pFile=%p, file=%p, rc=%s\n",   osGetCurrentProcessId(), pFile, pFile->h, rc ? "ok" : "failed"));  return rc ? SQLITE_OK  : winLogError(SQLITE_IOERR_CLOSE, osGetLastError(),  "winClose", pFile->zPath); } static int winRead(  sqlite3_file *id,  void *pBuf,  int amt,  sqlite3_int64 offset ){
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
 OVERLAPPED overlapped;
#endif
 winFile *pFile = (winFile*)id;  DWORD nRead;  int nRetry = 0;  assert( id!=0 );  assert( amt>0 );  assert( offset>=0 );  SimulateIOError(return SQLITE_IOERR_READ);  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "   "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,   pFile->h, pBuf, amt, offset, pFile->locktype));
#if SQLITE_MAX_MMAP_SIZE>0
 if( offset<pFile->mmapSize ){  if( offset+amt <= pFile->mmapSize ){  memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);  OSTRACE(("READ-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_OK;  }else{  int nCopy = (int)(pFile->mmapSize - offset);  memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);  pBuf = &((u8 *)pBuf)[nCopy];  amt -= nCopy;  offset += nCopy;  }  }
#endif
#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
 if( winSeekFile(pFile, offset) ){  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_FULL;  }  while( !osReadFile(pFile->h, pBuf, amt, &nRead, 0) ){
#else
 memset(&overlapped, 0, sizeof(OVERLAPPED));  overlapped.Offset = (LONG)(offset & 0xffffffff);  overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);  while( !osReadFile(pFile->h, pBuf, amt, &nRead, &overlapped) &&   osGetLastError()!=ERROR_HANDLE_EOF ){
#endif
 DWORD lastErrno;  if( winRetryIoerr(&nRetry, &lastErrno) ) continue;  pFile->lastErrno = lastErrno;  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_READ\n",   osGetCurrentProcessId(), pFile, pFile->h));  return winLogError(SQLITE_IOERR_READ, pFile->lastErrno,   "winRead", pFile->zPath);  }  winLogIoerr(nRetry, __LINE__);  if( nRead<(DWORD)amt ){  memset(&((char*)pBuf)[nRead], 0, amt-nRead);  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_SHORT_READ\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_IOERR_SHORT_READ;  }  OSTRACE(("READ pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_OK; } static int winWrite(  sqlite3_file *id,  const void *pBuf,  int amt,  sqlite3_int64 offset ){  int rc = 0;  winFile *pFile = (winFile*)id;  int nRetry = 0;  assert( amt>0 );  assert( pFile );  SimulateIOError(return SQLITE_IOERR_WRITE);  SimulateDiskfullError(return SQLITE_FULL);  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, buffer=%p, amount=%d, "   "offset=%lld, lock=%d\n", osGetCurrentProcessId(), pFile,   pFile->h, pBuf, amt, offset, pFile->locktype));
#if defined(SQLITE_MMAP_READWRITE) && SQLITE_MAX_MMAP_SIZE>0
 if( offset<pFile->mmapSize ){  if( offset+amt <= pFile->mmapSize ){  memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, amt);  OSTRACE(("WRITE-MMAP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_OK;  }else{  int nCopy = (int)(pFile->mmapSize - offset);  memcpy(&((u8 *)(pFile->pMapRegion))[offset], pBuf, nCopy);  pBuf = &((u8 *)pBuf)[nCopy];  amt -= nCopy;  offset += nCopy;  }  }
#endif
#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
 rc = winSeekFile(pFile, offset);  if( rc==0 ){
#else
 {
#endif
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
 OVERLAPPED overlapped;
#endif
 u8 *aRem = (u8 *)pBuf;  int nRem = amt;  DWORD nWrite;  DWORD lastErrno = NO_ERROR;
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
 memset(&overlapped, 0, sizeof(OVERLAPPED));  overlapped.Offset = (LONG)(offset & 0xffffffff);  overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);
#endif
 while( nRem>0 ){
#if SQLITE_OS_WINCE || defined(SQLITE_WIN32_NO_OVERLAPPED)
 if( !osWriteFile(pFile->h, aRem, nRem, &nWrite, 0) ){
#else
 if( !osWriteFile(pFile->h, aRem, nRem, &nWrite, &overlapped) ){
#endif
 if( winRetryIoerr(&nRetry, &lastErrno) ) continue;  break;  }  assert( nWrite==0 || nWrite<=(DWORD)nRem );  if( nWrite==0 || nWrite>(DWORD)nRem ){  lastErrno = osGetLastError();  break;  }
#if !SQLITE_OS_WINCE && !defined(SQLITE_WIN32_NO_OVERLAPPED)
 offset += nWrite;  overlapped.Offset = (LONG)(offset & 0xffffffff);  overlapped.OffsetHigh = (LONG)((offset>>32) & 0x7fffffff);
#endif
 aRem += nWrite;  nRem -= nWrite;  }  if( nRem>0 ){  pFile->lastErrno = lastErrno;  rc = 1;  }  }  if( rc ){  if(  ( pFile->lastErrno==ERROR_HANDLE_DISK_FULL )   || ( pFile->lastErrno==ERROR_DISK_FULL )){  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_FULL\n",   osGetCurrentProcessId(), pFile, pFile->h));  return winLogError(SQLITE_FULL, pFile->lastErrno,   "winWrite1", pFile->zPath);  }  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_WRITE\n",   osGetCurrentProcessId(), pFile, pFile->h));  return winLogError(SQLITE_IOERR_WRITE, pFile->lastErrno,   "winWrite2", pFile->zPath);  }else{  winLogIoerr(nRetry, __LINE__);  }  OSTRACE(("WRITE pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_OK; } static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){  winFile *pFile = (winFile*)id;  int rc = SQLITE_OK;  DWORD lastErrno;
#if SQLITE_MAX_MMAP_SIZE>0
 sqlite3_int64 oldMmapSize;  if( pFile->nFetchOut>0 ){  return SQLITE_OK;  }
#endif
 assert( pFile );  SimulateIOError(return SQLITE_IOERR_TRUNCATE);  OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, size=%lld, lock=%d\n",   osGetCurrentProcessId(), pFile, pFile->h, nByte, pFile->locktype));  if( pFile->szChunk>0 ){  nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;  }
#if SQLITE_MAX_MMAP_SIZE>0
 if( pFile->pMapRegion ){  oldMmapSize = pFile->mmapSize;  }else{  oldMmapSize = 0;  }  winUnmapfile(pFile);
#endif
 if( winSeekFile(pFile, nByte) ){  rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,   "winTruncate1", pFile->zPath);  }else if( 0==osSetEndOfFile(pFile->h) &&  ((lastErrno = osGetLastError())!=ERROR_USER_MAPPED_FILE) ){  pFile->lastErrno = lastErrno;  rc = winLogError(SQLITE_IOERR_TRUNCATE, pFile->lastErrno,   "winTruncate2", pFile->zPath);  }
#if SQLITE_MAX_MMAP_SIZE>0
 if( rc==SQLITE_OK && oldMmapSize>0 ){  if( oldMmapSize>nByte ){  winMapfile(pFile, -1);  }else{  winMapfile(pFile, oldMmapSize);  }  }
#endif
 OSTRACE(("TRUNCATE pid=%lu, pFile=%p, file=%p, rc=%s\n",   osGetCurrentProcessId(), pFile, pFile->h, sqlite3ErrName(rc)));  return rc; }
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_sync_count = 0; SQLITE_API int sqlite3_fullsync_count = 0;
#endif
static int winSync(sqlite3_file *id, int flags){
#ifndef SQLITE_NO_SYNC
 BOOL rc;
#endif
#if !defined(NDEBUG) || !defined(SQLITE_NO_SYNC) ||  defined(SQLITE_HAVE_OS_TRACE)

 winFile *pFile = (winFile*)id;
#else
 UNUSED_PARAMETER(id);
#endif
 assert( pFile );  assert((flags&0x0F)==SQLITE_SYNC_NORMAL  || (flags&0x0F)==SQLITE_SYNC_FULL  );  SimulateDiskfullError( return SQLITE_FULL );  OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, flags=%x, lock=%d\n",   osGetCurrentProcessId(), pFile, pFile->h, flags,   pFile->locktype));
#ifndef SQLITE_TEST
 UNUSED_PARAMETER(flags);
#else
 if( (flags&0x0F)==SQLITE_SYNC_FULL ){  sqlite3_fullsync_count++;  }  sqlite3_sync_count++;
#endif
#ifdef SQLITE_NO_SYNC
 OSTRACE(("SYNC-NOP pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_OK;
#else
#if SQLITE_MAX_MMAP_SIZE>0
 if( pFile->pMapRegion ){  if( osFlushViewOfFile(pFile->pMapRegion, 0) ){  OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "   "rc=SQLITE_OK\n", osGetCurrentProcessId(),   pFile, pFile->pMapRegion));  }else{  pFile->lastErrno = osGetLastError();  OSTRACE(("SYNC-MMAP pid=%lu, pFile=%p, pMapRegion=%p, "   "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(),   pFile, pFile->pMapRegion));  return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,   "winSync1", pFile->zPath);  }  }
#endif
 rc = osFlushFileBuffers(pFile->h);  SimulateIOError( rc=FALSE );  if( rc ){  OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile, pFile->h));  return SQLITE_OK;  }else{  pFile->lastErrno = osGetLastError();  OSTRACE(("SYNC pid=%lu, pFile=%p, file=%p, rc=SQLITE_IOERR_FSYNC\n",   osGetCurrentProcessId(), pFile, pFile->h));  return winLogError(SQLITE_IOERR_FSYNC, pFile->lastErrno,   "winSync2", pFile->zPath);  }
#endif
} static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){  winFile *pFile = (winFile*)id;  int rc = SQLITE_OK;  assert( id!=0 );  assert( pSize!=0 );  SimulateIOError(return SQLITE_IOERR_FSTAT);  OSTRACE(("SIZE file=%p, pSize=%p\n", pFile->h, pSize));
#if SQLITE_OS_WINRT
 {  FILE_STANDARD_INFO info;  if( osGetFileInformationByHandleEx(pFile->h, FileStandardInfo,   &info, sizeof(info)) ){  *pSize = info.EndOfFile.QuadPart;  }else{  pFile->lastErrno = osGetLastError();  rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,   "winFileSize", pFile->zPath);  }  }
#else
 {  DWORD upperBits;  DWORD lowerBits;  DWORD lastErrno;  lowerBits = osGetFileSize(pFile->h, &upperBits);  *pSize = (((sqlite3_int64)upperBits)<<32) + lowerBits;  if(  (lowerBits == INVALID_FILE_SIZE)   && ((lastErrno = osGetLastError())!=NO_ERROR) ){  pFile->lastErrno = lastErrno;  rc = winLogError(SQLITE_IOERR_FSTAT, pFile->lastErrno,   "winFileSize", pFile->zPath);  }  }
#endif
 OSTRACE(("SIZE file=%p, pSize=%p, *pSize=%lld, rc=%s\n",   pFile->h, pSize, *pSize, sqlite3ErrName(rc)));  return rc; }
#ifndef LOCKFILE_FAIL_IMMEDIATELY
# define LOCKFILE_FAIL_IMMEDIATELY 1
#endif
#ifndef LOCKFILE_EXCLUSIVE_LOCK
# define LOCKFILE_EXCLUSIVE_LOCK 2
#endif
#ifndef SQLITE_LOCKFILE_FLAGS
# define SQLITE_LOCKFILE_FLAGS  (LOCKFILE_FAIL_IMMEDIATELY |  LOCKFILE_EXCLUSIVE_LOCK)

#endif
#ifndef SQLITE_LOCKFILEEX_FLAGS
# define SQLITE_LOCKFILEEX_FLAGS (LOCKFILE_FAIL_IMMEDIATELY)
#endif
static int winGetReadLock(winFile *pFile){  int res;  OSTRACE(("READ-LOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));  if( osIsNT() ){
#if SQLITE_OS_WINCE
 res = winceLockFile(&pFile->h, SHARED_FIRST, 0, 1, 0);
#else
 res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS, SHARED_FIRST, 0,  SHARED_SIZE, 0);
#endif
 }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  int lk;  sqlite3_randomness(sizeof(lk), &lk);  pFile->sharedLockByte = (short)((lk & 0x7fffffff)%(SHARED_SIZE - 1));  res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,  SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);  }
#endif
 if( res == 0 ){  pFile->lastErrno = osGetLastError();  }  OSTRACE(("READ-LOCK file=%p, result=%d\n", pFile->h, res));  return res; } static int winUnlockReadLock(winFile *pFile){  int res;  DWORD lastErrno;  OSTRACE(("READ-UNLOCK file=%p, lock=%d\n", pFile->h, pFile->locktype));  if( osIsNT() ){  res = winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  res = winUnlockFile(&pFile->h, SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);  }
#endif
 if( res==0 && ((lastErrno = osGetLastError())!=ERROR_NOT_LOCKED) ){  pFile->lastErrno = lastErrno;  winLogError(SQLITE_IOERR_UNLOCK, pFile->lastErrno,  "winUnlockReadLock", pFile->zPath);  }  OSTRACE(("READ-UNLOCK file=%p, result=%d\n", pFile->h, res));  return res; } static int winLock(sqlite3_file *id, int locktype){  int rc = SQLITE_OK;  int res = 1;  int newLocktype;  int gotPendingLock = 0;  winFile *pFile = (winFile*)id;  DWORD lastErrno = NO_ERROR;  assert( id!=0 );  OSTRACE(("LOCK file=%p, oldLock=%d(%d), newLock=%d\n",   pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));  if( pFile->locktype>=locktype ){  OSTRACE(("LOCK-HELD file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  if( (pFile->ctrlFlags & WINFILE_RDONLY)!=0 && locktype>=RESERVED_LOCK ){  return SQLITE_IOERR_LOCK;  }  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );  assert( locktype!=PENDING_LOCK );  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );  newLocktype = pFile->locktype;  if( pFile->locktype==NO_LOCK   || (locktype==EXCLUSIVE_LOCK && pFile->locktype<=RESERVED_LOCK)  ){  int cnt = 3;  while( cnt-->0 && (res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS,   PENDING_BYTE, 0, 1, 0))==0 ){  lastErrno = osGetLastError();  OSTRACE(("LOCK-PENDING-FAIL file=%p, count=%d, result=%d\n",   pFile->h, cnt, res));  if( lastErrno==ERROR_INVALID_HANDLE ){  pFile->lastErrno = lastErrno;  rc = SQLITE_IOERR_LOCK;  OSTRACE(("LOCK-FAIL file=%p, count=%d, rc=%s\n",   pFile->h, cnt, sqlite3ErrName(rc)));  return rc;  }  if( cnt ) sqlite3_win32_sleep(1);  }  gotPendingLock = res;  if( !res ){  lastErrno = osGetLastError();  }  }  if( locktype==SHARED_LOCK && res ){  assert( pFile->locktype==NO_LOCK );  res = winGetReadLock(pFile);  if( res ){  newLocktype = SHARED_LOCK;  }else{  lastErrno = osGetLastError();  }  }  if( locktype==RESERVED_LOCK && res ){  assert( pFile->locktype==SHARED_LOCK );  res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, RESERVED_BYTE, 0, 1, 0);  if( res ){  newLocktype = RESERVED_LOCK;  }else{  lastErrno = osGetLastError();  }  }  if( locktype==EXCLUSIVE_LOCK && res ){  newLocktype = PENDING_LOCK;  gotPendingLock = 0;  }  if( locktype==EXCLUSIVE_LOCK && res ){  assert( pFile->locktype>=SHARED_LOCK );  res = winUnlockReadLock(pFile);  res = winLockFile(&pFile->h, SQLITE_LOCKFILE_FLAGS, SHARED_FIRST, 0,  SHARED_SIZE, 0);  if( res ){  newLocktype = EXCLUSIVE_LOCK;  }else{  lastErrno = osGetLastError();  winGetReadLock(pFile);  }  }  if( gotPendingLock && locktype==SHARED_LOCK ){  winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);  }  if( res ){  rc = SQLITE_OK;  }else{  pFile->lastErrno = lastErrno;  rc = SQLITE_BUSY;  OSTRACE(("LOCK-FAIL file=%p, wanted=%d, got=%d\n",   pFile->h, locktype, newLocktype));  }  pFile->locktype = (u8)newLocktype;  OSTRACE(("LOCK file=%p, lock=%d, rc=%s\n",   pFile->h, pFile->locktype, sqlite3ErrName(rc)));  return rc; } static int winCheckReservedLock(sqlite3_file *id, int *pResOut){  int res;  winFile *pFile = (winFile*)id;  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p\n", pFile->h, pResOut));  assert( id!=0 );  if( pFile->locktype>=RESERVED_LOCK ){  res = 1;  OSTRACE(("TEST-WR-LOCK file=%p, result=%d (local)\n", pFile->h, res));  }else{  res = winLockFile(&pFile->h, SQLITE_LOCKFILEEX_FLAGS,RESERVED_BYTE,0,1,0);  if( res ){  winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);  }  res = !res;  OSTRACE(("TEST-WR-LOCK file=%p, result=%d (remote)\n", pFile->h, res));  }  *pResOut = res;  OSTRACE(("TEST-WR-LOCK file=%p, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",   pFile->h, pResOut, *pResOut));  return SQLITE_OK; } static int winUnlock(sqlite3_file *id, int locktype){  int type;  winFile *pFile = (winFile*)id;  int rc = SQLITE_OK;  assert( pFile!=0 );  assert( locktype<=SHARED_LOCK );  OSTRACE(("UNLOCK file=%p, oldLock=%d(%d), newLock=%d\n",   pFile->h, pFile->locktype, pFile->sharedLockByte, locktype));  type = pFile->locktype;  if( type>=EXCLUSIVE_LOCK ){  winUnlockFile(&pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);  if( locktype==SHARED_LOCK && !winGetReadLock(pFile) ){  rc = winLogError(SQLITE_IOERR_UNLOCK, osGetLastError(),   "winUnlock", pFile->zPath);  }  }  if( type>=RESERVED_LOCK ){  winUnlockFile(&pFile->h, RESERVED_BYTE, 0, 1, 0);  }  if( locktype==NO_LOCK && type>=SHARED_LOCK ){  winUnlockReadLock(pFile);  }  if( type>=PENDING_LOCK ){  winUnlockFile(&pFile->h, PENDING_BYTE, 0, 1, 0);  }  pFile->locktype = (u8)locktype;  OSTRACE(("UNLOCK file=%p, lock=%d, rc=%s\n",   pFile->h, pFile->locktype, sqlite3ErrName(rc)));  return rc; } static int winNolockLock(sqlite3_file *id, int locktype){  UNUSED_PARAMETER(id);  UNUSED_PARAMETER(locktype);  return SQLITE_OK; } static int winNolockCheckReservedLock(sqlite3_file *id, int *pResOut){  UNUSED_PARAMETER(id);  UNUSED_PARAMETER(pResOut);  return SQLITE_OK; } static int winNolockUnlock(sqlite3_file *id, int locktype){  UNUSED_PARAMETER(id);  UNUSED_PARAMETER(locktype);  return SQLITE_OK; } static void winModeBit(winFile *pFile, unsigned char mask, int *pArg){  if( *pArg<0 ){  *pArg = (pFile->ctrlFlags & mask)!=0;  }else if( (*pArg)==0 ){  pFile->ctrlFlags &= ~mask;  }else{  pFile->ctrlFlags |= mask;  } } static int winGetTempname(sqlite3_vfs *, char **); static int winIsDir(const void *); static BOOL winIsLongPathPrefix(const char *); static BOOL winIsDriveLetterAndColon(const char *); static int winFileControl(sqlite3_file *id, int op, void *pArg){  winFile *pFile = (winFile*)id;  OSTRACE(("FCNTL file=%p, op=%d, pArg=%p\n", pFile->h, op, pArg));  switch( op ){  case SQLITE_FCNTL_LOCKSTATE: {  *(int*)pArg = pFile->locktype;  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_LAST_ERRNO: {  *(int*)pArg = (int)pFile->lastErrno;  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_CHUNK_SIZE: {  pFile->szChunk = *(int *)pArg;  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_SIZE_HINT: {  if( pFile->szChunk>0 ){  sqlite3_int64 oldSz;  int rc = winFileSize(id, &oldSz);  if( rc==SQLITE_OK ){  sqlite3_int64 newSz = *(sqlite3_int64*)pArg;  if( newSz>oldSz ){  SimulateIOErrorBenign(1);  rc = winTruncate(id, newSz);  SimulateIOErrorBenign(0);  }  }  OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));  return rc;  }  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_PERSIST_WAL: {  winModeBit(pFile, WINFILE_PERSIST_WAL, (int*)pArg);  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_POWERSAFE_OVERWRITE: {  winModeBit(pFile, WINFILE_PSOW, (int*)pArg);  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_VFSNAME: {  *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_WIN32_AV_RETRY: {  int *a = (int*)pArg;  if( a[0]>0 ){  winIoerrRetry = a[0];  }else{  a[0] = winIoerrRetry;  }  if( a[1]>0 ){  winIoerrRetryDelay = a[1];  }else{  a[1] = winIoerrRetryDelay;  }  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }  case SQLITE_FCNTL_WIN32_GET_HANDLE: {  LPHANDLE phFile = (LPHANDLE)pArg;  *phFile = pFile->h;  OSTRACE(("FCNTL file=%p, rc=SQLITE_OK\n", pFile->h));  return SQLITE_OK;  }
#ifdef SQLITE_TEST
 case SQLITE_FCNTL_WIN32_SET_HANDLE: {  LPHANDLE phFile = (LPHANDLE)pArg;  HANDLE hOldFile = pFile->h;  pFile->h = *phFile;  *phFile = hOldFile;  OSTRACE(("FCNTL oldFile=%p, newFile=%p, rc=SQLITE_OK\n",   hOldFile, pFile->h));  return SQLITE_OK;  }
#endif
 case SQLITE_FCNTL_TEMPFILENAME: {  char *zTFile = 0;  int rc = winGetTempname(pFile->pVfs, &zTFile);  if( rc==SQLITE_OK ){  *(char**)pArg = zTFile;  }  OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));  return rc;  }
#if SQLITE_MAX_MMAP_SIZE>0
 case SQLITE_FCNTL_MMAP_SIZE: {  i64 newLimit = *(i64*)pArg;  int rc = SQLITE_OK;  if( newLimit>sqlite3GlobalConfig.mxMmap ){  newLimit = sqlite3GlobalConfig.mxMmap;  }  if( newLimit>0 && sizeof(SIZE_T)<8 ){  newLimit = (newLimit & 0x7FFFFFFF);  }  *(i64*)pArg = pFile->mmapSizeMax;  if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){  pFile->mmapSizeMax = newLimit;  if( pFile->mmapSize>0 ){  winUnmapfile(pFile);  rc = winMapfile(pFile, -1);  }  }  OSTRACE(("FCNTL file=%p, rc=%s\n", pFile->h, sqlite3ErrName(rc)));  return rc;  }
#endif
 }  OSTRACE(("FCNTL file=%p, rc=SQLITE_NOTFOUND\n", pFile->h));  return SQLITE_NOTFOUND; } static int winSectorSize(sqlite3_file *id){  (void)id;  return SQLITE_DEFAULT_SECTOR_SIZE; } static int winDeviceCharacteristics(sqlite3_file *id){  winFile *p = (winFile*)id;  return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN |   ((p->ctrlFlags & WINFILE_PSOW)?SQLITE_IOCAP_POWERSAFE_OVERWRITE:0); } static SYSTEM_INFO winSysInfo;
#ifndef SQLITE_OMIT_WAL
static sqlite3_mutex *winBigLock = 0; static void winShmEnterMutex(void){  sqlite3_mutex_enter(winBigLock); } static void winShmLeaveMutex(void){  sqlite3_mutex_leave(winBigLock); }
#ifndef NDEBUG
static int winShmMutexHeld(void) {  return sqlite3_mutex_held(winBigLock); }
#endif
struct winShmNode {  sqlite3_mutex *mutex;  char *zFilename;  winFile hFile;  int szRegion;  int nRegion;  u8 isReadonly;  u8 isUnlocked;  struct ShmRegion {  HANDLE hMap;  void *pMap;  } *aRegion;  DWORD lastErrno;  int nRef;  winShm *pFirst;  winShmNode *pNext;
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
 u8 nextShmId;
#endif
}; static winShmNode *winShmNodeList = 0; struct winShm {  winShmNode *pShmNode;  winShm *pNext;  u8 hasMutex;  u16 sharedMask;  u16 exclMask;
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
 u8 id;
#endif
};
#define WIN_SHM_BASE  ((22+SQLITE_SHM_NLOCK)*4)
#define WIN_SHM_DMS (WIN_SHM_BASE+SQLITE_SHM_NLOCK)
#define WINSHM_UNLCK 1
#define WINSHM_RDLCK 2
#define WINSHM_WRLCK 3
static int winShmSystemLock(  winShmNode *pFile,  int lockType,  int ofst,  int nByte ){  int rc = 0;  assert( pFile->nRef==0 || sqlite3_mutex_held(pFile->mutex) );  OSTRACE(("SHM-LOCK file=%p, lock=%d, offset=%d, size=%d\n",   pFile->hFile.h, lockType, ofst, nByte));  if( lockType==WINSHM_UNLCK ){  rc = winUnlockFile(&pFile->hFile.h, ofst, 0, nByte, 0);  }else{  DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;  if( lockType == WINSHM_WRLCK ) dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;  rc = winLockFile(&pFile->hFile.h, dwFlags, ofst, 0, nByte, 0);  }  if( rc!= 0 ){  rc = SQLITE_OK;  }else{  pFile->lastErrno = osGetLastError();  rc = SQLITE_BUSY;  }  OSTRACE(("SHM-LOCK file=%p, func=%s, errno=%lu, rc=%s\n",   pFile->hFile.h, (lockType == WINSHM_UNLCK) ? "winUnlockFile" :   "winLockFile", pFile->lastErrno, sqlite3ErrName(rc)));  return rc; } static int winOpen(sqlite3_vfs*,const char*,sqlite3_file*,int,int*); static int winDelete(sqlite3_vfs *,const char*,int); static void winShmPurge(sqlite3_vfs *pVfs, int deleteFlag){  winShmNode **pp;  winShmNode *p;  assert( winShmMutexHeld() );  OSTRACE(("SHM-PURGE pid=%lu, deleteFlag=%d\n",   osGetCurrentProcessId(), deleteFlag));  pp = &winShmNodeList;  while( (p = *pp)!=0 ){  if( p->nRef==0 ){  int i;  if( p->mutex ){ sqlite3_mutex_free(p->mutex); }  for(i=0; i<p->nRegion; i++){  BOOL bRc = osUnmapViewOfFile(p->aRegion[i].pMap);  OSTRACE(("SHM-PURGE-UNMAP pid=%lu, region=%d, rc=%s\n",   osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));  UNUSED_VARIABLE_VALUE(bRc);  bRc = osCloseHandle(p->aRegion[i].hMap);  OSTRACE(("SHM-PURGE-CLOSE pid=%lu, region=%d, rc=%s\n",   osGetCurrentProcessId(), i, bRc ? "ok" : "failed"));  UNUSED_VARIABLE_VALUE(bRc);  }  if( p->hFile.h!=NULL && p->hFile.h!=INVALID_HANDLE_VALUE ){  SimulateIOErrorBenign(1);  winClose((sqlite3_file *)&p->hFile);  SimulateIOErrorBenign(0);  }  if( deleteFlag ){  SimulateIOErrorBenign(1);  sqlite3BeginBenignMalloc();  winDelete(pVfs, p->zFilename, 0);  sqlite3EndBenignMalloc();  SimulateIOErrorBenign(0);  }  *pp = p->pNext;  sqlite3_free(p->aRegion);  sqlite3_free(p);  }else{  pp = &p->pNext;  }  } } static int winLockSharedMemory(winShmNode *pShmNode){  int rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, WIN_SHM_DMS, 1);  if( rc==SQLITE_OK ){  if( pShmNode->isReadonly ){  pShmNode->isUnlocked = 1;  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);  return SQLITE_READONLY_CANTINIT;  }else if( winTruncate((sqlite3_file*)&pShmNode->hFile, 0) ){  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);  return winLogError(SQLITE_IOERR_SHMOPEN, osGetLastError(),   "winLockSharedMemory", pShmNode->zFilename);  }  }  if( rc==SQLITE_OK ){  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);  }  return winShmSystemLock(pShmNode, WINSHM_RDLCK, WIN_SHM_DMS, 1); } static int winOpenSharedMemory(winFile *pDbFd){  struct winShm *p;  winShmNode *pShmNode = 0;  int rc = SQLITE_OK;  winShmNode *pNew;  int nName;  assert( pDbFd->pShm==0 );  p = sqlite3MallocZero( sizeof(*p) );  if( p==0 ) return SQLITE_IOERR_NOMEM_BKPT;  nName = sqlite3Strlen30(pDbFd->zPath);  pNew = sqlite3MallocZero( sizeof(*pShmNode) + nName + 17 );  if( pNew==0 ){  sqlite3_free(p);  return SQLITE_IOERR_NOMEM_BKPT;  }  pNew->zFilename = (char*)&pNew[1];  sqlite3_snprintf(nName+15, pNew->zFilename, "%s-shm", pDbFd->zPath);  sqlite3FileSuffix3(pDbFd->zPath, pNew->zFilename);  winShmEnterMutex();  for(pShmNode = winShmNodeList; pShmNode; pShmNode=pShmNode->pNext){  if( sqlite3StrICmp(pShmNode->zFilename, pNew->zFilename)==0 ) break;  }  if( pShmNode ){  sqlite3_free(pNew);  }else{  int inFlags = SQLITE_OPEN_WAL;  int outFlags = 0;  pShmNode = pNew;  pNew = 0;  ((winFile*)(&pShmNode->hFile))->h = INVALID_HANDLE_VALUE;  pShmNode->pNext = winShmNodeList;  winShmNodeList = pShmNode;  if( sqlite3GlobalConfig.bCoreMutex ){  pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);  if( pShmNode->mutex==0 ){  rc = SQLITE_IOERR_NOMEM_BKPT;  goto shm_open_err;  }  }  if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){  inFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;  }else{  inFlags |= SQLITE_OPEN_READONLY;  }  rc = winOpen(pDbFd->pVfs, pShmNode->zFilename,   (sqlite3_file*)&pShmNode->hFile,   inFlags, &outFlags);  if( rc!=SQLITE_OK ){  rc = winLogError(rc, osGetLastError(), "winOpenShm",   pShmNode->zFilename);  goto shm_open_err;  }  if( outFlags==SQLITE_OPEN_READONLY ) pShmNode->isReadonly = 1;  rc = winLockSharedMemory(pShmNode);  if( rc!=SQLITE_OK && rc!=SQLITE_READONLY_CANTINIT ) goto shm_open_err;  }  p->pShmNode = pShmNode;
#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)
 p->id = pShmNode->nextShmId++;
#endif
 pShmNode->nRef++;  pDbFd->pShm = p;  winShmLeaveMutex();  sqlite3_mutex_enter(pShmNode->mutex);  p->pNext = pShmNode->pFirst;  pShmNode->pFirst = p;  sqlite3_mutex_leave(pShmNode->mutex);  return rc; shm_open_err:  winShmSystemLock(pShmNode, WINSHM_UNLCK, WIN_SHM_DMS, 1);  winShmPurge(pDbFd->pVfs, 0);  sqlite3_free(p);  sqlite3_free(pNew);  winShmLeaveMutex();  return rc; } static int winShmUnmap(  sqlite3_file *fd,  int deleteFlag ){  winFile *pDbFd;  winShm *p;  winShmNode *pShmNode;  winShm **pp;  pDbFd = (winFile*)fd;  p = pDbFd->pShm;  if( p==0 ) return SQLITE_OK;  pShmNode = p->pShmNode;  sqlite3_mutex_enter(pShmNode->mutex);  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}  *pp = p->pNext;  sqlite3_free(p);  pDbFd->pShm = 0;  sqlite3_mutex_leave(pShmNode->mutex);  winShmEnterMutex();  assert( pShmNode->nRef>0 );  pShmNode->nRef--;  if( pShmNode->nRef==0 ){  winShmPurge(pDbFd->pVfs, deleteFlag);  }  winShmLeaveMutex();  return SQLITE_OK; } static int winShmLock(  sqlite3_file *fd,  int ofst,  int n,  int flags ){  winFile *pDbFd = (winFile*)fd;  winShm *p = pDbFd->pShm;  winShm *pX;  winShmNode *pShmNode = p->pShmNode;  int rc = SQLITE_OK;  u16 mask;  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );  assert( n>=1 );  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)   || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)   || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)   || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );  mask = (u16)((1U<<(ofst+n)) - (1U<<ofst));  assert( n>1 || mask==(1<<ofst) );  sqlite3_mutex_enter(pShmNode->mutex);  if( flags & SQLITE_SHM_UNLOCK ){  u16 allMask = 0;  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){  if( pX==p ) continue;  assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );  allMask |= pX->sharedMask;  }  if( (mask & allMask)==0 ){  rc = winShmSystemLock(pShmNode, WINSHM_UNLCK, ofst+WIN_SHM_BASE, n);  }else{  rc = SQLITE_OK;  }  if( rc==SQLITE_OK ){  p->exclMask &= ~mask;  p->sharedMask &= ~mask;  }  }else if( flags & SQLITE_SHM_SHARED ){  u16 allShared = 0;  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){  if( (pX->exclMask & mask)!=0 ){  rc = SQLITE_BUSY;  break;  }  allShared |= pX->sharedMask;  }  if( rc==SQLITE_OK ){  if( (allShared & mask)==0 ){  rc = winShmSystemLock(pShmNode, WINSHM_RDLCK, ofst+WIN_SHM_BASE, n);  }else{  rc = SQLITE_OK;  }  }  if( rc==SQLITE_OK ){  p->sharedMask |= mask;  }  }else{  for(pX=pShmNode->pFirst; pX; pX=pX->pNext){  if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){  rc = SQLITE_BUSY;  break;  }  }  if( rc==SQLITE_OK ){  rc = winShmSystemLock(pShmNode, WINSHM_WRLCK, ofst+WIN_SHM_BASE, n);  if( rc==SQLITE_OK ){  assert( (p->sharedMask & mask)==0 );  p->exclMask |= mask;  }  }  }  sqlite3_mutex_leave(pShmNode->mutex);  OSTRACE(("SHM-LOCK pid=%lu, id=%d, sharedMask=%03x, exclMask=%03x, rc=%s\n",   osGetCurrentProcessId(), p->id, p->sharedMask, p->exclMask,   sqlite3ErrName(rc)));  return rc; } static void winShmBarrier(  sqlite3_file *fd ){  UNUSED_PARAMETER(fd);  sqlite3MemoryBarrier();  winShmEnterMutex();  winShmLeaveMutex(); } static int winShmMap(  sqlite3_file *fd,  int iRegion,  int szRegion,  int isWrite,  void volatile **pp ){  winFile *pDbFd = (winFile*)fd;  winShm *pShm = pDbFd->pShm;  winShmNode *pShmNode;  DWORD protect = PAGE_READWRITE;  DWORD flags = FILE_MAP_WRITE | FILE_MAP_READ;  int rc = SQLITE_OK;  if( !pShm ){  rc = winOpenSharedMemory(pDbFd);  if( rc!=SQLITE_OK ) return rc;  pShm = pDbFd->pShm;  assert( pShm!=0 );  }  pShmNode = pShm->pShmNode;  sqlite3_mutex_enter(pShmNode->mutex);  if( pShmNode->isUnlocked ){  rc = winLockSharedMemory(pShmNode);  if( rc!=SQLITE_OK ) goto shmpage_out;  pShmNode->isUnlocked = 0;  }  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );  if( pShmNode->nRegion<=iRegion ){  struct ShmRegion *apNew;  int nByte = (iRegion+1)*szRegion;  sqlite3_int64 sz;  pShmNode->szRegion = szRegion;  rc = winFileSize((sqlite3_file *)&pShmNode->hFile, &sz);  if( rc!=SQLITE_OK ){  rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),   "winShmMap1", pDbFd->zPath);  goto shmpage_out;  }  if( sz<nByte ){  if( !isWrite ) goto shmpage_out;  rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);  if( rc!=SQLITE_OK ){  rc = winLogError(SQLITE_IOERR_SHMSIZE, osGetLastError(),   "winShmMap2", pDbFd->zPath);  goto shmpage_out;  }  }  apNew = (struct ShmRegion *)sqlite3_realloc64(  pShmNode->aRegion, (iRegion+1)*sizeof(apNew[0])  );  if( !apNew ){  rc = SQLITE_IOERR_NOMEM_BKPT;  goto shmpage_out;  }  pShmNode->aRegion = apNew;  if( pShmNode->isReadonly ){  protect = PAGE_READONLY;  flags = FILE_MAP_READ;  }  while( pShmNode->nRegion<=iRegion ){  HANDLE hMap = NULL;  void *pMap = 0;
#if SQLITE_OS_WINRT
 hMap = osCreateFileMappingFromApp(pShmNode->hFile.h,  NULL, protect, nByte, NULL  );
#elif defined(SQLITE_WIN32_HAS_WIDE)
 hMap = osCreateFileMappingW(pShmNode->hFile.h,  NULL, protect, 0, nByte, NULL  );
#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGA
 hMap = osCreateFileMappingA(pShmNode->hFile.h,  NULL, protect, 0, nByte, NULL  );
#endif
 OSTRACE(("SHM-MAP-CREATE pid=%lu, region=%d, size=%d, rc=%s\n",   osGetCurrentProcessId(), pShmNode->nRegion, nByte,   hMap ? "ok" : "failed"));  if( hMap ){  int iOffset = pShmNode->nRegion*szRegion;  int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;
#if SQLITE_OS_WINRT
 pMap = osMapViewOfFileFromApp(hMap, flags,  iOffset - iOffsetShift, szRegion + iOffsetShift  );
#else
 pMap = osMapViewOfFile(hMap, flags,  0, iOffset - iOffsetShift, szRegion + iOffsetShift  );
#endif
 OSTRACE(("SHM-MAP-MAP pid=%lu, region=%d, offset=%d, size=%d, rc=%s\n",   osGetCurrentProcessId(), pShmNode->nRegion, iOffset,   szRegion, pMap ? "ok" : "failed"));  }  if( !pMap ){  pShmNode->lastErrno = osGetLastError();  rc = winLogError(SQLITE_IOERR_SHMMAP, pShmNode->lastErrno,   "winShmMap3", pDbFd->zPath);  if( hMap ) osCloseHandle(hMap);  goto shmpage_out;  }  pShmNode->aRegion[pShmNode->nRegion].pMap = pMap;  pShmNode->aRegion[pShmNode->nRegion].hMap = hMap;  pShmNode->nRegion++;  }  } shmpage_out:  if( pShmNode->nRegion>iRegion ){  int iOffset = iRegion*szRegion;  int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;  char *p = (char *)pShmNode->aRegion[iRegion].pMap;  *pp = (void *)&p[iOffsetShift];  }else{  *pp = 0;  }  if( pShmNode->isReadonly && rc==SQLITE_OK ) rc = SQLITE_READONLY;  sqlite3_mutex_leave(pShmNode->mutex);  return rc; }
#else
# define winShmMap  0
# define winShmLock 0
# define winShmBarrier 0
# define winShmUnmap  0
#endif
#if SQLITE_MAX_MMAP_SIZE>0
static int winUnmapfile(winFile *pFile){  assert( pFile!=0 );  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, pMapRegion=%p, "   "mmapSize=%lld, mmapSizeMax=%lld\n",   osGetCurrentProcessId(), pFile, pFile->hMap, pFile->pMapRegion,   pFile->mmapSize, pFile->mmapSizeMax));  if( pFile->pMapRegion ){  if( !osUnmapViewOfFile(pFile->pMapRegion) ){  pFile->lastErrno = osGetLastError();  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, pMapRegion=%p, "   "rc=SQLITE_IOERR_MMAP\n", osGetCurrentProcessId(), pFile,   pFile->pMapRegion));  return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,   "winUnmapfile1", pFile->zPath);  }  pFile->pMapRegion = 0;  pFile->mmapSize = 0;  }  if( pFile->hMap!=NULL ){  if( !osCloseHandle(pFile->hMap) ){  pFile->lastErrno = osGetLastError();  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, hMap=%p, rc=SQLITE_IOERR_MMAP\n",   osGetCurrentProcessId(), pFile, pFile->hMap));  return winLogError(SQLITE_IOERR_MMAP, pFile->lastErrno,   "winUnmapfile2", pFile->zPath);  }  pFile->hMap = NULL;  }  OSTRACE(("UNMAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFile));  return SQLITE_OK; } static int winMapfile(winFile *pFd, sqlite3_int64 nByte){  sqlite3_int64 nMap = nByte;  int rc;  assert( nMap>=0 || pFd->nFetchOut==0 );  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, size=%lld\n",   osGetCurrentProcessId(), pFd, nByte));  if( pFd->nFetchOut>0 ) return SQLITE_OK;  if( nMap<0 ){  rc = winFileSize((sqlite3_file*)pFd, &nMap);  if( rc ){  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_IOERR_FSTAT\n",   osGetCurrentProcessId(), pFd));  return SQLITE_IOERR_FSTAT;  }  }  if( nMap>pFd->mmapSizeMax ){  nMap = pFd->mmapSizeMax;  }  nMap &= ~(sqlite3_int64)(winSysInfo.dwPageSize - 1);  if( nMap==0 && pFd->mmapSize>0 ){  winUnmapfile(pFd);  }  if( nMap!=pFd->mmapSize ){  void *pNew = 0;  DWORD protect = PAGE_READONLY;  DWORD flags = FILE_MAP_READ;  winUnmapfile(pFd);
#ifdef SQLITE_MMAP_READWRITE
 if( (pFd->ctrlFlags & WINFILE_RDONLY)==0 ){  protect = PAGE_READWRITE;  flags |= FILE_MAP_WRITE;  }
#endif
#if SQLITE_OS_WINRT
 pFd->hMap = osCreateFileMappingFromApp(pFd->h, NULL, protect, nMap, NULL);
#elif defined(SQLITE_WIN32_HAS_WIDE)
 pFd->hMap = osCreateFileMappingW(pFd->h, NULL, protect,  (DWORD)((nMap>>32) & 0xffffffff),  (DWORD)(nMap & 0xffffffff), NULL);
#elif defined(SQLITE_WIN32_HAS_ANSI) && SQLITE_WIN32_CREATEFILEMAPPINGA
 pFd->hMap = osCreateFileMappingA(pFd->h, NULL, protect,  (DWORD)((nMap>>32) & 0xffffffff),  (DWORD)(nMap & 0xffffffff), NULL);
#endif
 if( pFd->hMap==NULL ){  pFd->lastErrno = osGetLastError();  rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,   "winMapfile1", pFd->zPath);  OSTRACE(("MAP-FILE-CREATE pid=%lu, pFile=%p, rc=%s\n",   osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));  return SQLITE_OK;  }  assert( (nMap % winSysInfo.dwPageSize)==0 );  assert( sizeof(SIZE_T)==sizeof(sqlite3_int64) || nMap<=0xffffffff );
#if SQLITE_OS_WINRT
 pNew = osMapViewOfFileFromApp(pFd->hMap, flags, 0, (SIZE_T)nMap);
#else
 pNew = osMapViewOfFile(pFd->hMap, flags, 0, 0, (SIZE_T)nMap);
#endif
 if( pNew==NULL ){  osCloseHandle(pFd->hMap);  pFd->hMap = NULL;  pFd->lastErrno = osGetLastError();  rc = winLogError(SQLITE_IOERR_MMAP, pFd->lastErrno,   "winMapfile2", pFd->zPath);  OSTRACE(("MAP-FILE-MAP pid=%lu, pFile=%p, rc=%s\n",   osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));  return SQLITE_OK;  }  pFd->pMapRegion = pNew;  pFd->mmapSize = nMap;  }  OSTRACE(("MAP-FILE pid=%lu, pFile=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), pFd));  return SQLITE_OK; }
#endif
static int winFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){
#if SQLITE_MAX_MMAP_SIZE>0
 winFile *pFd = (winFile*)fd;
#endif
 *pp = 0;  OSTRACE(("FETCH pid=%lu, pFile=%p, offset=%lld, amount=%d, pp=%p\n",   osGetCurrentProcessId(), fd, iOff, nAmt, pp));
#if SQLITE_MAX_MMAP_SIZE>0
 if( pFd->mmapSizeMax>0 ){  if( pFd->pMapRegion==0 ){  int rc = winMapfile(pFd, -1);  if( rc!=SQLITE_OK ){  OSTRACE(("FETCH pid=%lu, pFile=%p, rc=%s\n",   osGetCurrentProcessId(), pFd, sqlite3ErrName(rc)));  return rc;  }  }  if( pFd->mmapSize >= iOff+nAmt ){  assert( pFd->pMapRegion!=0 );  *pp = &((u8 *)pFd->pMapRegion)[iOff];  pFd->nFetchOut++;  }  }
#endif
 OSTRACE(("FETCH pid=%lu, pFile=%p, pp=%p, *pp=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), fd, pp, *pp));  return SQLITE_OK; } static int winUnfetch(sqlite3_file *fd, i64 iOff, void *p){
#if SQLITE_MAX_MMAP_SIZE>0
 winFile *pFd = (winFile*)fd;  assert( (p==0)==(pFd->nFetchOut==0) );  assert( p==0 || p==&((u8 *)pFd->pMapRegion)[iOff] );  OSTRACE(("UNFETCH pid=%lu, pFile=%p, offset=%lld, p=%p\n",   osGetCurrentProcessId(), pFd, iOff, p));  if( p ){  pFd->nFetchOut--;  }else{  winUnmapfile(pFd);  }  assert( pFd->nFetchOut>=0 );
#endif
 OSTRACE(("UNFETCH pid=%lu, pFile=%p, rc=SQLITE_OK\n",   osGetCurrentProcessId(), fd));  return SQLITE_OK; } static const sqlite3_io_methods winIoMethod = {  3, winClose, winRead, winWrite, winTruncate, winSync, winFileSize, winLock, winUnlock, winCheckReservedLock, winFileControl, winSectorSize, winDeviceCharacteristics, winShmMap, winShmLock, winShmBarrier, winShmUnmap, winFetch, winUnfetch }; static const sqlite3_io_methods winIoNolockMethod = {  3, winClose,  winRead,  winWrite,  winTruncate,  winSync,  winFileSize,  winNolockLock,  winNolockUnlock,  winNolockCheckReservedLock,  winFileControl,  winSectorSize,  winDeviceCharacteristics,  winShmMap,  winShmLock,  winShmBarrier,  winShmUnmap,  winFetch,  winUnfetch }; static winVfsAppData winAppData = {  &winIoMethod,  0,  0 }; static winVfsAppData winNolockAppData = {  &winIoNolockMethod,  0,  1 };
#if defined(__CYGWIN__)
static char *winConvertToUtf8Filename(const void *zFilename){  char *zConverted = 0;  if( osIsNT() ){  zConverted = winUnicodeToUtf8(zFilename);  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  zConverted = winMbcsToUtf8(zFilename, osAreFileApisANSI());  }
#endif
 return zConverted; }
#endif
static void *winConvertFromUtf8Filename(const char *zFilename){  void *zConverted = 0;  if( osIsNT() ){  zConverted = winUtf8ToUnicode(zFilename);  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  zConverted = winUtf8ToMbcs(zFilename, osAreFileApisANSI());  }
#endif
 return zConverted; } static int winMakeEndInDirSep(int nBuf, char *zBuf){  if( zBuf ){  int nLen = sqlite3Strlen30(zBuf);  if( nLen>0 ){  if( winIsDirSep(zBuf[nLen-1]) ){  return 1;  }else if( nLen+1<nBuf ){  zBuf[nLen] = winGetDirSep();  zBuf[nLen+1] = '\0';  return 1;  }  }  }  return 0; } static int winGetTempname(sqlite3_vfs *pVfs, char **pzBuf){  static char zChars[] =  "abcdefghijklmnopqrstuvwxyz"  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"  "0123456789";  size_t i, j;  int nPre = sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX);  int nMax, nBuf, nDir, nLen;  char *zBuf;  SimulateIOError( return SQLITE_IOERR );  nMax = pVfs->mxPathname; nBuf = nMax + 2;  zBuf = sqlite3MallocZero( nBuf );  if( !zBuf ){  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  nDir = nMax - (nPre + 15);  assert( nDir>0 );  if( sqlite3_temp_directory ){  int nDirLen = sqlite3Strlen30(sqlite3_temp_directory);  if( nDirLen>0 ){  if( !winIsDirSep(sqlite3_temp_directory[nDirLen-1]) ){  nDirLen++;  }  if( nDirLen>nDir ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));  return winLogError(SQLITE_ERROR, 0, "winGetTempname1", 0);  }  sqlite3_snprintf(nMax, zBuf, "%s", sqlite3_temp_directory);  }  }
#if defined(__CYGWIN__)
 else{  static const char *azDirs[] = {   0,   0,   0,   0,   0,   "/var/tmp",   "/usr/tmp",   "/tmp",   ".",   0  };  unsigned int i;  const char *zDir = 0;  if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");  if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");  if( !azDirs[2] ) azDirs[2] = getenv("TMP");  if( !azDirs[3] ) azDirs[3] = getenv("TEMP");  if( !azDirs[4] ) azDirs[4] = getenv("USERPROFILE");  for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){  void *zConverted;  if( zDir==0 ) continue;  if( winIsDriveLetterAndColon(zDir) ){  zConverted = winConvertFromUtf8Filename(zDir);  if( !zConverted ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( winIsDir(zConverted) ){  sqlite3_snprintf(nMax, zBuf, "%s", zDir);  sqlite3_free(zConverted);  break;  }  sqlite3_free(zConverted);  }else{  zConverted = sqlite3MallocZero( nMax+1 );  if( !zConverted ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( cygwin_conv_path(  osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A, zDir,  zConverted, nMax+1)<0 ){  sqlite3_free(zConverted);  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_CONVPATH\n"));  return winLogError(SQLITE_IOERR_CONVPATH, (DWORD)errno,   "winGetTempname2", zDir);  }  if( winIsDir(zConverted) ){  char *zUtf8 = winConvertToUtf8Filename(zConverted);  if( !zUtf8 ){  sqlite3_free(zConverted);  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);  sqlite3_free(zUtf8);  sqlite3_free(zConverted);  break;  }  sqlite3_free(zConverted);  }  }  }
#elif !SQLITE_OS_WINRT && !defined(__CYGWIN__)
 else if( osIsNT() ){  char *zMulti;  LPWSTR zWidePath = sqlite3MallocZero( nMax*sizeof(WCHAR) );  if( !zWidePath ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( osGetTempPathW(nMax, zWidePath)==0 ){  sqlite3_free(zWidePath);  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));  return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),   "winGetTempname2", 0);  }  zMulti = winUnicodeToUtf8(zWidePath);  if( zMulti ){  sqlite3_snprintf(nMax, zBuf, "%s", zMulti);  sqlite3_free(zMulti);  sqlite3_free(zWidePath);  }else{  sqlite3_free(zWidePath);  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  char *zUtf8;  char *zMbcsPath = sqlite3MallocZero( nMax );  if( !zMbcsPath ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( osGetTempPathA(nMax, zMbcsPath)==0 ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_GETTEMPPATH\n"));  return winLogError(SQLITE_IOERR_GETTEMPPATH, osGetLastError(),   "winGetTempname3", 0);  }  zUtf8 = winMbcsToUtf8(zMbcsPath, osAreFileApisANSI());  if( zUtf8 ){  sqlite3_snprintf(nMax, zBuf, "%s", zUtf8);  sqlite3_free(zUtf8);  }else{  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_IOERR_NOMEM\n"));  return SQLITE_IOERR_NOMEM_BKPT;  }  }
#endif
#endif
 if( !winMakeEndInDirSep(nDir+1, zBuf) ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));  return winLogError(SQLITE_ERROR, 0, "winGetTempname4", 0);  }  nLen = sqlite3Strlen30(zBuf);  if( (nLen + nPre + 17) > nBuf ){  sqlite3_free(zBuf);  OSTRACE(("TEMP-FILENAME rc=SQLITE_ERROR\n"));  return winLogError(SQLITE_ERROR, 0, "winGetTempname5", 0);  }  sqlite3_snprintf(nBuf-16-nLen, zBuf+nLen, SQLITE_TEMP_FILE_PREFIX);  j = sqlite3Strlen30(zBuf);  sqlite3_randomness(15, &zBuf[j]);  for(i=0; i<15; i++, j++){  zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];  }  zBuf[j] = 0;  zBuf[j+1] = 0;  *pzBuf = zBuf;  OSTRACE(("TEMP-FILENAME name=%s, rc=SQLITE_OK\n", zBuf));  return SQLITE_OK; } static int winIsDir(const void *zConverted){  DWORD attr;  int rc = 0;  DWORD lastErrno;  if( osIsNT() ){  int cnt = 0;  WIN32_FILE_ATTRIBUTE_DATA sAttrData;  memset(&sAttrData, 0, sizeof(sAttrData));  while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,   GetFileExInfoStandard,   &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}  if( !rc ){  return 0;  }  attr = sAttrData.dwFileAttributes;
#if SQLITE_OS_WINCE==0
 }else{  attr = osGetFileAttributesA((char*)zConverted);
#endif
 }  return (attr!=INVALID_FILE_ATTRIBUTES) && (attr&FILE_ATTRIBUTE_DIRECTORY); } static int winAccess(  sqlite3_vfs *pVfs,  const char *zFilename,  int flags,  int *pResOut ); static int winOpen(  sqlite3_vfs *pVfs,  const char *zName,  sqlite3_file *id,  int flags,  int *pOutFlags ){  HANDLE h;  DWORD lastErrno = 0;  DWORD dwDesiredAccess;  DWORD dwShareMode;  DWORD dwCreationDisposition;  DWORD dwFlagsAndAttributes = 0;
#if SQLITE_OS_WINCE
 int isTemp = 0;
#endif
 winVfsAppData *pAppData;  winFile *pFile = (winFile*)id;  void *zConverted;  const char *zUtf8Name = zName;  int cnt = 0;  char *zTmpname = 0;  int rc = SQLITE_OK;
#if !defined(NDEBUG) || SQLITE_OS_WINCE
 int eType = flags&0xFFFFFF00;
#endif
 int isExclusive = (flags & SQLITE_OPEN_EXCLUSIVE);  int isDelete  = (flags & SQLITE_OPEN_DELETEONCLOSE);  int isCreate  = (flags & SQLITE_OPEN_CREATE);  int isReadonly  = (flags & SQLITE_OPEN_READONLY);  int isReadWrite = (flags & SQLITE_OPEN_READWRITE);
#ifndef NDEBUG
 int isOpenJournal = (isCreate && (  eType==SQLITE_OPEN_SUPER_JOURNAL   || eType==SQLITE_OPEN_MAIN_JOURNAL   || eType==SQLITE_OPEN_WAL  ));
#endif
 OSTRACE(("OPEN name=%s, pFile=%p, flags=%x, pOutFlags=%p\n",   zUtf8Name, id, flags, pOutFlags));  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));  assert(isCreate==0 || isReadWrite);  assert(isExclusive==0 || isCreate);  assert(isDelete==0 || isCreate);  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_SUPER_JOURNAL );  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );  assert( eType==SQLITE_OPEN_MAIN_DB || eType==SQLITE_OPEN_TEMP_DB   || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL   || eType==SQLITE_OPEN_SUBJOURNAL  || eType==SQLITE_OPEN_SUPER_JOURNAL   || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL  );  assert( pFile!=0 );  memset(pFile, 0, sizeof(winFile));  pFile->h = INVALID_HANDLE_VALUE;
#if SQLITE_OS_WINRT
 if( !zUtf8Name && !sqlite3_temp_directory ){  sqlite3_log(SQLITE_ERROR,  "sqlite3_temp_directory variable should be set for WinRT");  }
#endif
 if( !zUtf8Name ){  assert( isDelete && !isOpenJournal );  rc = winGetTempname(pVfs, &zTmpname);  if( rc!=SQLITE_OK ){  OSTRACE(("OPEN name=%s, rc=%s", zUtf8Name, sqlite3ErrName(rc)));  return rc;  }  zUtf8Name = zTmpname;  }  assert( (eType!=SQLITE_OPEN_MAIN_DB) || (flags & SQLITE_OPEN_URI) ||   zUtf8Name[sqlite3Strlen30(zUtf8Name)+1]==0 );  zConverted = winConvertFromUtf8Filename(zUtf8Name);  if( zConverted==0 ){  sqlite3_free(zTmpname);  OSTRACE(("OPEN name=%s, rc=SQLITE_IOERR_NOMEM", zUtf8Name));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( winIsDir(zConverted) ){  sqlite3_free(zConverted);  sqlite3_free(zTmpname);  OSTRACE(("OPEN name=%s, rc=SQLITE_CANTOPEN_ISDIR", zUtf8Name));  return SQLITE_CANTOPEN_ISDIR;  }  if( isReadWrite ){  dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;  }else{  dwDesiredAccess = GENERIC_READ;  }  if( isExclusive ){  dwCreationDisposition = CREATE_NEW;  }else if( isCreate ){  dwCreationDisposition = OPEN_ALWAYS;  }else{  dwCreationDisposition = OPEN_EXISTING;  }  if( 0==sqlite3_uri_boolean(zName, "exclusive", 0) ){  dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;  }else{  dwShareMode = 0;  }  if( isDelete ){
#if SQLITE_OS_WINCE
 dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN;  isTemp = 1;
#else
 dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARY   | FILE_ATTRIBUTE_HIDDEN   | FILE_FLAG_DELETE_ON_CLOSE;
#endif
 }else{  dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;  }
#if SQLITE_OS_WINCE
 dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;
#endif
 if( osIsNT() ){
#if SQLITE_OS_WINRT
 CREATEFILE2_EXTENDED_PARAMETERS extendedParameters;  extendedParameters.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);  extendedParameters.dwFileAttributes =  dwFlagsAndAttributes & FILE_ATTRIBUTE_MASK;  extendedParameters.dwFileFlags = dwFlagsAndAttributes & FILE_FLAG_MASK;  extendedParameters.dwSecurityQosFlags = SECURITY_ANONYMOUS;  extendedParameters.lpSecurityAttributes = NULL;  extendedParameters.hTemplateFile = NULL;  do{  h = osCreateFile2((LPCWSTR)zConverted,  dwDesiredAccess,  dwShareMode,  dwCreationDisposition,  &extendedParameters);  if( h!=INVALID_HANDLE_VALUE ) break;  if( isReadWrite ){  int rc2, isRO = 0;  sqlite3BeginBenignMalloc();  rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);  sqlite3EndBenignMalloc();  if( rc2==SQLITE_OK && isRO ) break;  }  }while( winRetryIoerr(&cnt, &lastErrno) );
#else
 do{  h = osCreateFileW((LPCWSTR)zConverted,  dwDesiredAccess,  dwShareMode, NULL,  dwCreationDisposition,  dwFlagsAndAttributes,  NULL);  if( h!=INVALID_HANDLE_VALUE ) break;  if( isReadWrite ){  int rc2, isRO = 0;  sqlite3BeginBenignMalloc();  rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);  sqlite3EndBenignMalloc();  if( rc2==SQLITE_OK && isRO ) break;  }  }while( winRetryIoerr(&cnt, &lastErrno) );
#endif
 }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  do{  h = osCreateFileA((LPCSTR)zConverted,  dwDesiredAccess,  dwShareMode, NULL,  dwCreationDisposition,  dwFlagsAndAttributes,  NULL);  if( h!=INVALID_HANDLE_VALUE ) break;  if( isReadWrite ){  int rc2, isRO = 0;  sqlite3BeginBenignMalloc();  rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);  sqlite3EndBenignMalloc();  if( rc2==SQLITE_OK && isRO ) break;  }  }while( winRetryIoerr(&cnt, &lastErrno) );  }
#endif
 winLogIoerr(cnt, __LINE__);  OSTRACE(("OPEN file=%p, name=%s, access=%lx, rc=%s\n", h, zUtf8Name,   dwDesiredAccess, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok"));  if( h==INVALID_HANDLE_VALUE ){  sqlite3_free(zConverted);  sqlite3_free(zTmpname);  if( isReadWrite && !isExclusive ){  return winOpen(pVfs, zName, id,   ((flags|SQLITE_OPEN_READONLY) &   ~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE)),   pOutFlags);  }else{  pFile->lastErrno = lastErrno;  winLogError(SQLITE_CANTOPEN, pFile->lastErrno, "winOpen", zUtf8Name);  return SQLITE_CANTOPEN_BKPT;  }  }  if( pOutFlags ){  if( isReadWrite ){  *pOutFlags = SQLITE_OPEN_READWRITE;  }else{  *pOutFlags = SQLITE_OPEN_READONLY;  }  }  OSTRACE(("OPEN file=%p, name=%s, access=%lx, pOutFlags=%p, *pOutFlags=%d, "   "rc=%s\n", h, zUtf8Name, dwDesiredAccess, pOutFlags, pOutFlags ?   *pOutFlags : 0, (h==INVALID_HANDLE_VALUE) ? "failed" : "ok"));  pAppData = (winVfsAppData*)pVfs->pAppData;
#if SQLITE_OS_WINCE
 {  if( isReadWrite && eType==SQLITE_OPEN_MAIN_DB   && ((pAppData==NULL) || !pAppData->bNoLock)   && (rc = winceCreateLock(zName, pFile))!=SQLITE_OK  ){  osCloseHandle(h);  sqlite3_free(zConverted);  sqlite3_free(zTmpname);  OSTRACE(("OPEN-CE-LOCK name=%s, rc=%s\n", zName, sqlite3ErrName(rc)));  return rc;  }  }  if( isTemp ){  pFile->zDeleteOnClose = zConverted;  }else
#endif
 {  sqlite3_free(zConverted);  }  sqlite3_free(zTmpname);  id->pMethods = pAppData ? pAppData->pMethod : &winIoMethod;  pFile->pVfs = pVfs;  pFile->h = h;  if( isReadonly ){  pFile->ctrlFlags |= WINFILE_RDONLY;  }  if( (flags & SQLITE_OPEN_MAIN_DB)   && sqlite3_uri_boolean(zName, "psow", SQLITE_POWERSAFE_OVERWRITE)  ){  pFile->ctrlFlags |= WINFILE_PSOW;  }  pFile->lastErrno = NO_ERROR;  pFile->zPath = zName;
#if SQLITE_MAX_MMAP_SIZE>0
 pFile->hMap = NULL;  pFile->pMapRegion = 0;  pFile->mmapSize = 0;  pFile->mmapSizeMax = sqlite3GlobalConfig.szMmap;
#endif
 OpenCounter(+1);  return rc; } static int winDelete(  sqlite3_vfs *pVfs,  const char *zFilename,  int syncDir ){  int cnt = 0;  int rc;  DWORD attr;  DWORD lastErrno = 0;  void *zConverted;  UNUSED_PARAMETER(pVfs);  UNUSED_PARAMETER(syncDir);  SimulateIOError(return SQLITE_IOERR_DELETE);  OSTRACE(("DELETE name=%s, syncDir=%d\n", zFilename, syncDir));  zConverted = winConvertFromUtf8Filename(zFilename);  if( zConverted==0 ){  OSTRACE(("DELETE name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( osIsNT() ){  do {
#if SQLITE_OS_WINRT
 WIN32_FILE_ATTRIBUTE_DATA sAttrData;  memset(&sAttrData, 0, sizeof(sAttrData));  if ( osGetFileAttributesExW(zConverted, GetFileExInfoStandard,  &sAttrData) ){  attr = sAttrData.dwFileAttributes;  }else{  lastErrno = osGetLastError();  if( lastErrno==ERROR_FILE_NOT_FOUND   || lastErrno==ERROR_PATH_NOT_FOUND ){  rc = SQLITE_IOERR_DELETE_NOENT;  }else{  rc = SQLITE_ERROR;  }  break;  }
#else
 attr = osGetFileAttributesW(zConverted);
#endif
 if ( attr==INVALID_FILE_ATTRIBUTES ){  lastErrno = osGetLastError();  if( lastErrno==ERROR_FILE_NOT_FOUND   || lastErrno==ERROR_PATH_NOT_FOUND ){  rc = SQLITE_IOERR_DELETE_NOENT;  }else{  rc = SQLITE_ERROR;  }  break;  }  if ( attr&FILE_ATTRIBUTE_DIRECTORY ){  rc = SQLITE_ERROR;  break;  }  if ( osDeleteFileW(zConverted) ){  rc = SQLITE_OK;  break;  }  if ( !winRetryIoerr(&cnt, &lastErrno) ){  rc = SQLITE_ERROR;  break;  }  } while(1);  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  do {  attr = osGetFileAttributesA(zConverted);  if ( attr==INVALID_FILE_ATTRIBUTES ){  lastErrno = osGetLastError();  if( lastErrno==ERROR_FILE_NOT_FOUND   || lastErrno==ERROR_PATH_NOT_FOUND ){  rc = SQLITE_IOERR_DELETE_NOENT;  }else{  rc = SQLITE_ERROR;  }  break;  }  if ( attr&FILE_ATTRIBUTE_DIRECTORY ){  rc = SQLITE_ERROR;  break;  }  if ( osDeleteFileA(zConverted) ){  rc = SQLITE_OK;  break;  }  if ( !winRetryIoerr(&cnt, &lastErrno) ){  rc = SQLITE_ERROR;  break;  }  } while(1);  }
#endif
 if( rc && rc!=SQLITE_IOERR_DELETE_NOENT ){  rc = winLogError(SQLITE_IOERR_DELETE, lastErrno, "winDelete", zFilename);  }else{  winLogIoerr(cnt, __LINE__);  }  sqlite3_free(zConverted);  OSTRACE(("DELETE name=%s, rc=%s\n", zFilename, sqlite3ErrName(rc)));  return rc; } static int winAccess(  sqlite3_vfs *pVfs,  const char *zFilename,  int flags,  int *pResOut ){  DWORD attr;  int rc = 0;  DWORD lastErrno = 0;  void *zConverted;  UNUSED_PARAMETER(pVfs);  SimulateIOError( return SQLITE_IOERR_ACCESS; );  OSTRACE(("ACCESS name=%s, flags=%x, pResOut=%p\n",   zFilename, flags, pResOut));  zConverted = winConvertFromUtf8Filename(zFilename);  if( zConverted==0 ){  OSTRACE(("ACCESS name=%s, rc=SQLITE_IOERR_NOMEM\n", zFilename));  return SQLITE_IOERR_NOMEM_BKPT;  }  if( osIsNT() ){  int cnt = 0;  WIN32_FILE_ATTRIBUTE_DATA sAttrData;  memset(&sAttrData, 0, sizeof(sAttrData));  while( !(rc = osGetFileAttributesExW((LPCWSTR)zConverted,   GetFileExInfoStandard,   &sAttrData)) && winRetryIoerr(&cnt, &lastErrno) ){}  if( rc ){  if( flags==SQLITE_ACCESS_EXISTS  && sAttrData.nFileSizeHigh==0  && sAttrData.nFileSizeLow==0 ){  attr = INVALID_FILE_ATTRIBUTES;  }else{  attr = sAttrData.dwFileAttributes;  }  }else{  winLogIoerr(cnt, __LINE__);  if( lastErrno!=ERROR_FILE_NOT_FOUND && lastErrno!=ERROR_PATH_NOT_FOUND ){  sqlite3_free(zConverted);  return winLogError(SQLITE_IOERR_ACCESS, lastErrno, "winAccess",   zFilename);  }else{  attr = INVALID_FILE_ATTRIBUTES;  }  }  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  attr = osGetFileAttributesA((char*)zConverted);  }
#endif
 sqlite3_free(zConverted);  switch( flags ){  case SQLITE_ACCESS_READ:  case SQLITE_ACCESS_EXISTS:  rc = attr!=INVALID_FILE_ATTRIBUTES;  break;  case SQLITE_ACCESS_READWRITE:  rc = attr!=INVALID_FILE_ATTRIBUTES &&   (attr & FILE_ATTRIBUTE_READONLY)==0;  break;  default:  assert(!"Invalid flags argument");  }  *pResOut = rc;  OSTRACE(("ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\n",   zFilename, pResOut, *pResOut));  return SQLITE_OK; } static BOOL winIsLongPathPrefix(  const char *zPathname ){  return ( zPathname[0]=='\\' && zPathname[1]=='\\'  && zPathname[2]=='?' && zPathname[3]=='\\' ); } static BOOL winIsDriveLetterAndColon(  const char *zPathname ){  return ( sqlite3Isalpha(zPathname[0]) && zPathname[1]==':' ); } static BOOL winIsVerbatimPathname(  const char *zPathname ){  if ( winIsDirSep(zPathname[0]) ){  return TRUE;  }  if ( winIsDriveLetterAndColon(zPathname) ){  return TRUE;  }  return FALSE; } static int winFullPathname(  sqlite3_vfs *pVfs,  const char *zRelative,  int nFull,  char *zFull ){
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)
 DWORD nByte;  void *zConverted;  char *zOut;
#endif
 if( zRelative[0]=='/' && (winIsDriveLetterAndColon(zRelative+1)   || winIsLongPathPrefix(zRelative+1)) ){  zRelative++;  }
#if defined(__CYGWIN__)
 SimulateIOError( return SQLITE_ERROR );  UNUSED_PARAMETER(nFull);  assert( nFull>=pVfs->mxPathname );  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){  char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );  if( !zOut ){  return SQLITE_IOERR_NOMEM_BKPT;  }  if( cygwin_conv_path(  (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A) |  CCP_RELATIVE, zRelative, zOut, pVfs->mxPathname+1)<0 ){  sqlite3_free(zOut);  return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,   "winFullPathname1", zRelative);  }else{  char *zUtf8 = winConvertToUtf8Filename(zOut);  if( !zUtf8 ){  sqlite3_free(zOut);  return SQLITE_IOERR_NOMEM_BKPT;  }  sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",   sqlite3_data_directory, winGetDirSep(), zUtf8);  sqlite3_free(zUtf8);  sqlite3_free(zOut);  }  }else{  char *zOut = sqlite3MallocZero( pVfs->mxPathname+1 );  if( !zOut ){  return SQLITE_IOERR_NOMEM_BKPT;  }  if( cygwin_conv_path(  (osIsNT() ? CCP_POSIX_TO_WIN_W : CCP_POSIX_TO_WIN_A),  zRelative, zOut, pVfs->mxPathname+1)<0 ){  sqlite3_free(zOut);  return winLogError(SQLITE_CANTOPEN_CONVPATH, (DWORD)errno,   "winFullPathname2", zRelative);  }else{  char *zUtf8 = winConvertToUtf8Filename(zOut);  if( !zUtf8 ){  sqlite3_free(zOut);  return SQLITE_IOERR_NOMEM_BKPT;  }  sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zUtf8);  sqlite3_free(zUtf8);  sqlite3_free(zOut);  }  }  return SQLITE_OK;
#endif
#if (SQLITE_OS_WINCE || SQLITE_OS_WINRT) && !defined(__CYGWIN__)
 SimulateIOError( return SQLITE_ERROR );  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){  sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",   sqlite3_data_directory, winGetDirSep(), zRelative);  }else{  sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zRelative);  }  return SQLITE_OK;
#endif
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && !defined(__CYGWIN__)
 SimulateIOError( return SQLITE_ERROR );  if ( sqlite3_data_directory && !winIsVerbatimPathname(zRelative) ){  sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s%c%s",   sqlite3_data_directory, winGetDirSep(), zRelative);  return SQLITE_OK;  }  zConverted = winConvertFromUtf8Filename(zRelative);  if( zConverted==0 ){  return SQLITE_IOERR_NOMEM_BKPT;  }  if( osIsNT() ){  LPWSTR zTemp;  nByte = osGetFullPathNameW((LPCWSTR)zConverted, 0, 0, 0);  if( nByte==0 ){  sqlite3_free(zConverted);  return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),   "winFullPathname1", zRelative);  }  nByte += 3;  zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );  if( zTemp==0 ){  sqlite3_free(zConverted);  return SQLITE_IOERR_NOMEM_BKPT;  }  nByte = osGetFullPathNameW((LPCWSTR)zConverted, nByte, zTemp, 0);  if( nByte==0 ){  sqlite3_free(zConverted);  sqlite3_free(zTemp);  return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),   "winFullPathname2", zRelative);  }  sqlite3_free(zConverted);  zOut = winUnicodeToUtf8(zTemp);  sqlite3_free(zTemp);  }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  char *zTemp;  nByte = osGetFullPathNameA((char*)zConverted, 0, 0, 0);  if( nByte==0 ){  sqlite3_free(zConverted);  return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),   "winFullPathname3", zRelative);  }  nByte += 3;  zTemp = sqlite3MallocZero( nByte*sizeof(zTemp[0]) );  if( zTemp==0 ){  sqlite3_free(zConverted);  return SQLITE_IOERR_NOMEM_BKPT;  }  nByte = osGetFullPathNameA((char*)zConverted, nByte, zTemp, 0);  if( nByte==0 ){  sqlite3_free(zConverted);  sqlite3_free(zTemp);  return winLogError(SQLITE_CANTOPEN_FULLPATH, osGetLastError(),   "winFullPathname4", zRelative);  }  sqlite3_free(zConverted);  zOut = winMbcsToUtf8(zTemp, osAreFileApisANSI());  sqlite3_free(zTemp);  }
#endif
 if( zOut ){  sqlite3_snprintf(MIN(nFull, pVfs->mxPathname), zFull, "%s", zOut);  sqlite3_free(zOut);  return SQLITE_OK;  }else{  return SQLITE_IOERR_NOMEM_BKPT;  }
#endif
}
#ifndef SQLITE_OMIT_LOAD_EXTENSION
static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){  HANDLE h;
#if defined(__CYGWIN__)
 int nFull = pVfs->mxPathname+1;  char *zFull = sqlite3MallocZero( nFull );  void *zConverted = 0;  if( zFull==0 ){  OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));  return 0;  }  if( winFullPathname(pVfs, zFilename, nFull, zFull)!=SQLITE_OK ){  sqlite3_free(zFull);  OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));  return 0;  }  zConverted = winConvertFromUtf8Filename(zFull);  sqlite3_free(zFull);
#else
 void *zConverted = winConvertFromUtf8Filename(zFilename);  UNUSED_PARAMETER(pVfs);
#endif
 if( zConverted==0 ){  OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)0));  return 0;  }  if( osIsNT() ){
#if SQLITE_OS_WINRT
 h = osLoadPackagedLibrary((LPCWSTR)zConverted, 0);
#else
 h = osLoadLibraryW((LPCWSTR)zConverted);
#endif
 }
#ifdef SQLITE_WIN32_HAS_ANSI
 else{  h = osLoadLibraryA((char*)zConverted);  }
#endif
 OSTRACE(("DLOPEN name=%s, handle=%p\n", zFilename, (void*)h));  sqlite3_free(zConverted);  return (void*)h; } static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){  UNUSED_PARAMETER(pVfs);  winGetLastErrorMsg(osGetLastError(), nBuf, zBufOut); } static void (*winDlSym(sqlite3_vfs *pVfs,void *pH,const char *zSym))(void){  FARPROC proc;  UNUSED_PARAMETER(pVfs);  proc = osGetProcAddressA((HANDLE)pH, zSym);  OSTRACE(("DLSYM handle=%p, symbol=%s, address=%p\n",   (void*)pH, zSym, (void*)proc));  return (void(*)(void))proc; } static void winDlClose(sqlite3_vfs *pVfs, void *pHandle){  UNUSED_PARAMETER(pVfs);  osFreeLibrary((HANDLE)pHandle);  OSTRACE(("DLCLOSE handle=%p\n", (void*)pHandle)); }
#else
 #define winDlOpen 0
 #define winDlError 0
 #define winDlSym  0
 #define winDlClose 0
#endif
typedef struct EntropyGatherer EntropyGatherer; struct EntropyGatherer {  unsigned char *a;  int na;  int i;  int nXor; };
#if !defined(SQLITE_TEST) && !defined(SQLITE_OMIT_RANDOMNESS)
static void xorMemory(EntropyGatherer *p, unsigned char *x, int sz){  int j, k;  for(j=0, k=p->i; j<sz; j++){  p->a[k++] ^= x[j];  if( k>=p->na ) k = 0;  }  p->i = k;  p->nXor += sz; }
#endif
static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){
#if defined(SQLITE_TEST) || defined(SQLITE_OMIT_RANDOMNESS)
 UNUSED_PARAMETER(pVfs);  memset(zBuf, 0, nBuf);  return nBuf;
#else
 EntropyGatherer e;  UNUSED_PARAMETER(pVfs);  memset(zBuf, 0, nBuf);  e.a = (unsigned char*)zBuf;  e.na = nBuf;  e.nXor = 0;  e.i = 0;  {  SYSTEMTIME x;  osGetSystemTime(&x);  xorMemory(&e, (unsigned char*)&x, sizeof(SYSTEMTIME));  }  {  DWORD pid = osGetCurrentProcessId();  xorMemory(&e, (unsigned char*)&pid, sizeof(DWORD));  }
#if SQLITE_OS_WINRT
 {  ULONGLONG cnt = osGetTickCount64();  xorMemory(&e, (unsigned char*)&cnt, sizeof(ULONGLONG));  }
#else
 {  DWORD cnt = osGetTickCount();  xorMemory(&e, (unsigned char*)&cnt, sizeof(DWORD));  }
#endif
 {  LARGE_INTEGER i;  osQueryPerformanceCounter(&i);  xorMemory(&e, (unsigned char*)&i, sizeof(LARGE_INTEGER));  }
#if !SQLITE_OS_WINCE && !SQLITE_OS_WINRT && SQLITE_WIN32_USE_UUID
 {  UUID id;  memset(&id, 0, sizeof(UUID));  osUuidCreate(&id);  xorMemory(&e, (unsigned char*)&id, sizeof(UUID));  memset(&id, 0, sizeof(UUID));  osUuidCreateSequential(&id);  xorMemory(&e, (unsigned char*)&id, sizeof(UUID));  }
#endif
 return e.nXor>nBuf ? nBuf : e.nXor;
#endif
} static int winSleep(sqlite3_vfs *pVfs, int microsec){  sqlite3_win32_sleep((microsec+999)/1000);  UNUSED_PARAMETER(pVfs);  return ((microsec+999)/1000)*1000; }
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_current_time = 0;
#endif
static int winCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow){  FILETIME ft;  static const sqlite3_int64 winFiletimeEpoch = 23058135*(sqlite3_int64)8640000;
#ifdef SQLITE_TEST
 static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;
#endif
 static const sqlite3_int64 max32BitValue =  (sqlite3_int64)2000000000 + (sqlite3_int64)2000000000 +  (sqlite3_int64)294967296;
#if SQLITE_OS_WINCE
 SYSTEMTIME time;  osGetSystemTime(&time);  if (!osSystemTimeToFileTime(&time,&ft)){  return SQLITE_ERROR;  }
#else
 osGetSystemTimeAsFileTime( &ft );
#endif
 *piNow = winFiletimeEpoch +  ((((sqlite3_int64)ft.dwHighDateTime)*max32BitValue) +   (sqlite3_int64)ft.dwLowDateTime)/(sqlite3_int64)10000;
#ifdef SQLITE_TEST
 if( sqlite3_current_time ){  *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;  }
#endif
 UNUSED_PARAMETER(pVfs);  return SQLITE_OK; } static int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){  int rc;  sqlite3_int64 i;  rc = winCurrentTimeInt64(pVfs, &i);  if( !rc ){  *prNow = i/86400000.0;  }  return rc; } static int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){  DWORD e = osGetLastError();  UNUSED_PARAMETER(pVfs);  if( nBuf>0 ) winGetLastErrorMsg(e, nBuf, zBuf);  return e; } SQLITE_API int sqlite3_os_init(void){  static sqlite3_vfs winVfs = {  3,  sizeof(winFile),  SQLITE_WIN32_MAX_PATH_BYTES,  0,  "win32",  &winAppData,  winOpen,  winDelete,  winAccess,  winFullPathname,  winDlOpen,  winDlError,  winDlSym,  winDlClose,  winRandomness,  winSleep,  winCurrentTime,  winGetLastError,  winCurrentTimeInt64,  winSetSystemCall,  winGetSystemCall,  winNextSystemCall,  };
#if defined(SQLITE_WIN32_HAS_WIDE)
 static sqlite3_vfs winLongPathVfs = {  3,  sizeof(winFile),  SQLITE_WINNT_MAX_PATH_BYTES,  0,  "win32-longpath",  &winAppData,  winOpen,  winDelete,  winAccess,  winFullPathname,  winDlOpen,  winDlError,  winDlSym,  winDlClose,  winRandomness,  winSleep,  winCurrentTime,  winGetLastError,  winCurrentTimeInt64,  winSetSystemCall,  winGetSystemCall,  winNextSystemCall,  };
#endif
 static sqlite3_vfs winNolockVfs = {  3,  sizeof(winFile),  SQLITE_WIN32_MAX_PATH_BYTES,  0,  "win32-none",  &winNolockAppData,  winOpen,  winDelete,  winAccess,  winFullPathname,  winDlOpen,  winDlError,  winDlSym,  winDlClose,  winRandomness,  winSleep,  winCurrentTime,  winGetLastError,  winCurrentTimeInt64,  winSetSystemCall,  winGetSystemCall,  winNextSystemCall,  };
#if defined(SQLITE_WIN32_HAS_WIDE)
 static sqlite3_vfs winLongPathNolockVfs = {  3,  sizeof(winFile),  SQLITE_WINNT_MAX_PATH_BYTES,  0,  "win32-longpath-none",  &winNolockAppData,  winOpen,  winDelete,  winAccess,  winFullPathname,  winDlOpen,  winDlError,  winDlSym,  winDlClose,  winRandomness,  winSleep,  winCurrentTime,  winGetLastError,  winCurrentTimeInt64,  winSetSystemCall,  winGetSystemCall,  winNextSystemCall,  };
#endif
 assert( ArraySize(aSyscall)==80 );  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));
#if SQLITE_OS_WINRT
 osGetNativeSystemInfo(&winSysInfo);
#else
 osGetSystemInfo(&winSysInfo);
#endif
 assert( winSysInfo.dwAllocationGranularity>0 );  assert( winSysInfo.dwPageSize>0 );  sqlite3_vfs_register(&winVfs, 1);
#if defined(SQLITE_WIN32_HAS_WIDE)
 sqlite3_vfs_register(&winLongPathVfs, 0);
#endif
 sqlite3_vfs_register(&winNolockVfs, 0);
#if defined(SQLITE_WIN32_HAS_WIDE)
 sqlite3_vfs_register(&winLongPathNolockVfs, 0);
#endif
#ifndef SQLITE_OMIT_WAL
 winBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
#endif
 return SQLITE_OK; } SQLITE_API int sqlite3_os_end(void){
#if SQLITE_OS_WINRT
 if( sleepObj!=NULL ){  osCloseHandle(sleepObj);  sleepObj = NULL;  }
#endif
#ifndef SQLITE_OMIT_WAL
 winBigLock = 0;
#endif
 return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_DESERIALIZE
typedef struct sqlite3_vfs MemVfs; typedef struct MemFile MemFile; typedef struct MemStore MemStore;
#define ORIGVFS(p) ((sqlite3_vfs*)((p)->pAppData))
struct MemStore {  sqlite3_int64 sz;  sqlite3_int64 szAlloc;  sqlite3_int64 szMax;  unsigned char *aData;  sqlite3_mutex *pMutex;  int nMmap;  unsigned mFlags;  int nRdLock;  int nWrLock;  int nRef;  char *zFName; }; struct MemFile {  sqlite3_file base;  MemStore *pStore;  int eLock; }; static struct MemFS {  int nMemStore;  MemStore **apMemStore; } memdb_g; static int memdbClose(sqlite3_file*); static int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst); static int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst); static int memdbTruncate(sqlite3_file*, sqlite3_int64 size); static int memdbSync(sqlite3_file*, int flags); static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize); static int memdbLock(sqlite3_file*, int); static int memdbFileControl(sqlite3_file*, int op, void *pArg); static int memdbDeviceCharacteristics(sqlite3_file*); static int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp); static int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p); static int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *); static int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *); static int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut); static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename); static void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg); static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void); static void memdbDlClose(sqlite3_vfs*, void*); static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut); static int memdbSleep(sqlite3_vfs*, int microseconds); static int memdbGetLastError(sqlite3_vfs*, int, char *); static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*); static sqlite3_vfs memdb_vfs = {  2,  0,  1024,  0,  "memdb",  0,  memdbOpen,  0,  memdbAccess,  memdbFullPathname,  memdbDlOpen,  memdbDlError,  memdbDlSym,  memdbDlClose,  memdbRandomness,  memdbSleep,  0,  memdbGetLastError,  memdbCurrentTimeInt64,  0,  0,  0, }; static const sqlite3_io_methods memdb_io_methods = {  3,  memdbClose,  memdbRead,  memdbWrite,  memdbTruncate,  memdbSync,  memdbFileSize,  memdbLock,  memdbLock,  0,  memdbFileControl,  0,  memdbDeviceCharacteristics,  0,  0,  0,  0,  memdbFetch,  memdbUnfetch };
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE==0
static void memdbEnter(MemStore *p){  UNUSED_PARAMETER(p); } static void memdbLeave(MemStore *p){  UNUSED_PARAMETER(p); }
#else
static void memdbEnter(MemStore *p){  sqlite3_mutex_enter(p->pMutex); } static void memdbLeave(MemStore *p){  sqlite3_mutex_leave(p->pMutex); }
#endif
static int memdbClose(sqlite3_file *pFile){  MemStore *p = ((MemFile*)pFile)->pStore;  if( p->zFName ){  int i;
#ifndef SQLITE_MUTEX_OMIT
 sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
#endif
 sqlite3_mutex_enter(pVfsMutex);  for(i=0; ALWAYS(i<memdb_g.nMemStore); i++){  if( memdb_g.apMemStore[i]==p ){  memdbEnter(p);  if( p->nRef==1 ){  memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];  if( memdb_g.nMemStore==0 ){  sqlite3_free(memdb_g.apMemStore);  memdb_g.apMemStore = 0;  }  }  break;  }  }  sqlite3_mutex_leave(pVfsMutex);  }else{  memdbEnter(p);  }  p->nRef--;  if( p->nRef<=0 ){  if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ){  sqlite3_free(p->aData);  }  memdbLeave(p);  sqlite3_mutex_free(p->pMutex);  sqlite3_free(p);  }else{  memdbLeave(p);  }  return SQLITE_OK; } static int memdbRead(  sqlite3_file *pFile,  void *zBuf,  int iAmt,  sqlite_int64 iOfst ){  MemStore *p = ((MemFile*)pFile)->pStore;  memdbEnter(p);  if( iOfst+iAmt>p->sz ){  memset(zBuf, 0, iAmt);  if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);  memdbLeave(p);  return SQLITE_IOERR_SHORT_READ;  }  memcpy(zBuf, p->aData+iOfst, iAmt);  memdbLeave(p);  return SQLITE_OK; } static int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){  unsigned char *pNew;  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || NEVER(p->nMmap>0) ){  return SQLITE_FULL;  }  if( newSz>p->szMax ){  return SQLITE_FULL;  }  newSz *= 2;  if( newSz>p->szMax ) newSz = p->szMax;  pNew = sqlite3Realloc(p->aData, newSz);  if( pNew==0 ) return SQLITE_IOERR_NOMEM;  p->aData = pNew;  p->szAlloc = newSz;  return SQLITE_OK; } static int memdbWrite(  sqlite3_file *pFile,  const void *z,  int iAmt,  sqlite_int64 iOfst ){  MemStore *p = ((MemFile*)pFile)->pStore;  memdbEnter(p);  if( NEVER(p->mFlags & SQLITE_DESERIALIZE_READONLY) ){  memdbLeave(p);  return SQLITE_IOERR_WRITE;  }  if( iOfst+iAmt>p->sz ){  int rc;  if( iOfst+iAmt>p->szAlloc   && (rc = memdbEnlarge(p, iOfst+iAmt))!=SQLITE_OK  ){  memdbLeave(p);  return rc;  }  if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);  p->sz = iOfst+iAmt;  }  memcpy(p->aData+iOfst, z, iAmt);  memdbLeave(p);  return SQLITE_OK; } static int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){  MemStore *p = ((MemFile*)pFile)->pStore;  int rc = SQLITE_OK;  memdbEnter(p);  if( size>p->sz ){  rc = SQLITE_CORRUPT;  }else{  p->sz = size;  }  memdbLeave(p);  return rc; } static int memdbSync(sqlite3_file *pFile, int flags){  UNUSED_PARAMETER(pFile);  UNUSED_PARAMETER(flags);  return SQLITE_OK; } static int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){  MemStore *p = ((MemFile*)pFile)->pStore;  memdbEnter(p);  *pSize = p->sz;  memdbLeave(p);  return SQLITE_OK; } static int memdbLock(sqlite3_file *pFile, int eLock){  MemFile *pThis = (MemFile*)pFile;  MemStore *p = pThis->pStore;  int rc = SQLITE_OK;  if( eLock==pThis->eLock ) return SQLITE_OK;  memdbEnter(p);  if( eLock>SQLITE_LOCK_SHARED ){  if( p->mFlags & SQLITE_DESERIALIZE_READONLY ){  rc = SQLITE_READONLY;  }else if( pThis->eLock<=SQLITE_LOCK_SHARED ){  if( p->nWrLock ){  rc = SQLITE_BUSY;  }else{  p->nWrLock = 1;  }  }  }else if( eLock==SQLITE_LOCK_SHARED ){  if( pThis->eLock > SQLITE_LOCK_SHARED ){  assert( p->nWrLock==1 );  p->nWrLock = 0;  }else if( p->nWrLock ){  rc = SQLITE_BUSY;  }else{  p->nRdLock++;  }  }else{  assert( eLock==SQLITE_LOCK_NONE );  if( pThis->eLock>SQLITE_LOCK_SHARED ){  assert( p->nWrLock==1 );  p->nWrLock = 0;  }  assert( p->nRdLock>0 );  p->nRdLock--;  }  if( rc==SQLITE_OK ) pThis->eLock = eLock;  memdbLeave(p);  return rc; }
#if 0
static int memdbCheckReservedLock(sqlite3_file *pFile, int *pResOut){  *pResOut = 0;  return SQLITE_OK; }
#endif
static int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){  MemStore *p = ((MemFile*)pFile)->pStore;  int rc = SQLITE_NOTFOUND;  memdbEnter(p);  if( op==SQLITE_FCNTL_VFSNAME ){  *(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);  rc = SQLITE_OK;  }  if( op==SQLITE_FCNTL_SIZE_LIMIT ){  sqlite3_int64 iLimit = *(sqlite3_int64*)pArg;  if( iLimit<p->sz ){  if( iLimit<0 ){  iLimit = p->szMax;  }else{  iLimit = p->sz;  }  }  p->szMax = iLimit;  *(sqlite3_int64*)pArg = iLimit;  rc = SQLITE_OK;  }  memdbLeave(p);  return rc; }
#if 0
static int memdbSectorSize(sqlite3_file *pFile){  return 1024; }
#endif
static int memdbDeviceCharacteristics(sqlite3_file *pFile){  UNUSED_PARAMETER(pFile);  return SQLITE_IOCAP_ATOMIC |   SQLITE_IOCAP_POWERSAFE_OVERWRITE |   SQLITE_IOCAP_SAFE_APPEND |   SQLITE_IOCAP_SEQUENTIAL; } static int memdbFetch(  sqlite3_file *pFile,  sqlite3_int64 iOfst,  int iAmt,  void **pp ){  MemStore *p = ((MemFile*)pFile)->pStore;  memdbEnter(p);  if( iOfst+iAmt>p->sz || (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)!=0 ){  *pp = 0;  }else{  p->nMmap++;  *pp = (void*)(p->aData + iOfst);  }  memdbLeave(p);  return SQLITE_OK; } static int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){  MemStore *p = ((MemFile*)pFile)->pStore;  UNUSED_PARAMETER(iOfst);  UNUSED_PARAMETER(pPage);  memdbEnter(p);  p->nMmap--;  memdbLeave(p);  return SQLITE_OK; } static int memdbOpen(  sqlite3_vfs *pVfs,  const char *zName,  sqlite3_file *pFd,  int flags,  int *pOutFlags ){  MemFile *pFile = (MemFile*)pFd;  MemStore *p = 0;  int szName;  UNUSED_PARAMETER(pVfs);  memset(pFile, 0, sizeof(*pFile));  szName = sqlite3Strlen30(zName);  if( szName>1 && zName[0]=='/' ){  int i;
#ifndef SQLITE_MUTEX_OMIT
 sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
#endif
 sqlite3_mutex_enter(pVfsMutex);  for(i=0; i<memdb_g.nMemStore; i++){  if( strcmp(memdb_g.apMemStore[i]->zFName,zName)==0 ){  p = memdb_g.apMemStore[i];  break;  }  }  if( p==0 ){  MemStore **apNew;  p = sqlite3Malloc( sizeof(*p) + szName + 3 );  if( p==0 ){  sqlite3_mutex_leave(pVfsMutex);  return SQLITE_NOMEM;  }  apNew = sqlite3Realloc(memdb_g.apMemStore,   sizeof(apNew[0])*(memdb_g.nMemStore+1) );  if( apNew==0 ){  sqlite3_free(p);  sqlite3_mutex_leave(pVfsMutex);  return SQLITE_NOMEM;  }  apNew[memdb_g.nMemStore++] = p;  memdb_g.apMemStore = apNew;  memset(p, 0, sizeof(*p));  p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE|SQLITE_DESERIALIZE_FREEONCLOSE;  p->szMax = sqlite3GlobalConfig.mxMemdbSize;  p->zFName = (char*)&p[1];  memcpy(p->zFName, zName, szName+1);  p->pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);  if( p->pMutex==0 ){  memdb_g.nMemStore--;  sqlite3_free(p);  sqlite3_mutex_leave(pVfsMutex);  return SQLITE_NOMEM;  }  p->nRef = 1;  memdbEnter(p);  }else{  memdbEnter(p);  p->nRef++;  }  sqlite3_mutex_leave(pVfsMutex);  }else{  p = sqlite3Malloc( sizeof(*p) );  if( p==0 ){  return SQLITE_NOMEM;  }  memset(p, 0, sizeof(*p));  p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;  p->szMax = sqlite3GlobalConfig.mxMemdbSize;  }  pFile->pStore = p;  if( pOutFlags!=0 ){  *pOutFlags = flags | SQLITE_OPEN_MEMORY;  }  pFd->pMethods = &memdb_io_methods;  memdbLeave(p);  return SQLITE_OK; }
#if 0
static int memdbDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){  return SQLITE_IOERR_DELETE; }
#endif
static int memdbAccess(  sqlite3_vfs *pVfs,  const char *zPath,  int flags,  int *pResOut ){  UNUSED_PARAMETER(pVfs);  UNUSED_PARAMETER(zPath);  UNUSED_PARAMETER(flags);  *pResOut = 0;  return SQLITE_OK; } static int memdbFullPathname(  sqlite3_vfs *pVfs,  const char *zPath,  int nOut,  char *zOut ){  UNUSED_PARAMETER(pVfs);  sqlite3_snprintf(nOut, zOut, "%s", zPath);  return SQLITE_OK; } static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath); } static void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg); } static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym); } static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle); } static int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut); } static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro); }
#if 0
static int memdbCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut); }
#endif
static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b); } static int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p); } static MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){  MemFile *p = 0;  MemStore *pStore;  int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);  if( rc ) return 0;  if( p->base.pMethods!=&memdb_io_methods ) return 0;  pStore = p->pStore;  memdbEnter(pStore);  if( pStore->zFName!=0 ) p = 0;  memdbLeave(pStore);  return p; } SQLITE_API unsigned char *sqlite3_serialize(  sqlite3 *db,  const char *zSchema,  sqlite3_int64 *piSize,  unsigned int mFlags ){  MemFile *p;  int iDb;  Btree *pBt;  sqlite3_int64 sz;  int szPage = 0;  sqlite3_stmt *pStmt = 0;  unsigned char *pOut;  char *zSql;  int rc;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;  p = memdbFromDbSchema(db, zSchema);  iDb = sqlite3FindDbName(db, zSchema);  if( piSize ) *piSize = -1;  if( iDb<0 ) return 0;  if( p ){  MemStore *pStore = p->pStore;  assert( pStore->pMutex==0 );  if( piSize ) *piSize = pStore->sz;  if( mFlags & SQLITE_SERIALIZE_NOCOPY ){  pOut = pStore->aData;  }else{  pOut = sqlite3_malloc64( pStore->sz );  if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);  }  return pOut;  }  pBt = db->aDb[iDb].pBt;  if( pBt==0 ) return 0;  szPage = sqlite3BtreeGetPageSize(pBt);  zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;  sqlite3_free(zSql);  if( rc ) return 0;  rc = sqlite3_step(pStmt);  if( rc!=SQLITE_ROW ){  pOut = 0;  }else{  sz = sqlite3_column_int64(pStmt, 0)*szPage;  if( piSize ) *piSize = sz;  if( mFlags & SQLITE_SERIALIZE_NOCOPY ){  pOut = 0;  }else{  pOut = sqlite3_malloc64( sz );  if( pOut ){  int nPage = sqlite3_column_int(pStmt, 0);  Pager *pPager = sqlite3BtreePager(pBt);  int pgno;  for(pgno=1; pgno<=nPage; pgno++){  DbPage *pPage = 0;  unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);  rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);  if( rc==SQLITE_OK ){  memcpy(pTo, sqlite3PagerGetData(pPage), szPage);  }else{  memset(pTo, 0, szPage);  }  sqlite3PagerUnref(pPage);  }  }  }  }  sqlite3_finalize(pStmt);  return pOut; } SQLITE_API int sqlite3_deserialize(  sqlite3 *db,  const char *zSchema,  unsigned char *pData,  sqlite3_int64 szDb,  sqlite3_int64 szBuf,  unsigned mFlags ){  MemFile *p;  char *zSql;  sqlite3_stmt *pStmt = 0;  int rc;  int iDb;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  return SQLITE_MISUSE_BKPT;  }  if( szDb<0 ) return SQLITE_MISUSE_BKPT;  if( szBuf<0 ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;  iDb = sqlite3FindDbName(db, zSchema);  testcase( iDb==1 );  if( iDb<2 && iDb!=0 ){  rc = SQLITE_ERROR;  goto end_deserialize;  }  zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);  sqlite3_free(zSql);  }  if( rc ) goto end_deserialize;  db->init.iDb = (u8)iDb;  db->init.reopenMemdb = 1;  rc = sqlite3_step(pStmt);  db->init.reopenMemdb = 0;  if( rc!=SQLITE_DONE ){  rc = SQLITE_ERROR;  goto end_deserialize;  }  p = memdbFromDbSchema(db, zSchema);  if( p==0 ){  rc = SQLITE_ERROR;  }else{  MemStore *pStore = p->pStore;  pStore->aData = pData;  pData = 0;  pStore->sz = szDb;  pStore->szAlloc = szBuf;  pStore->szMax = szBuf;  if( pStore->szMax<sqlite3GlobalConfig.mxMemdbSize ){  pStore->szMax = sqlite3GlobalConfig.mxMemdbSize;  }  pStore->mFlags = mFlags;  rc = SQLITE_OK;  } end_deserialize:  sqlite3_finalize(pStmt);  if( pData && (mFlags & SQLITE_DESERIALIZE_FREEONCLOSE)!=0 ){  sqlite3_free(pData);  }  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_PRIVATE int sqlite3MemdbInit(void){  sqlite3_vfs *pLower = sqlite3_vfs_find(0);  unsigned int sz;  if( NEVER(pLower==0) ) return SQLITE_ERROR;  sz = pLower->szOsFile;  memdb_vfs.pAppData = pLower;  if( sz<sizeof(MemFile) ) sz = sizeof(MemFile);  memdb_vfs.szOsFile = sz;  return sqlite3_vfs_register(&memdb_vfs, 0); }
#endif
#define BITVEC_SZ 512
#define BITVEC_USIZE  (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))

#define BITVEC_TELEM  u8
#define BITVEC_SZELEM 8
#define BITVEC_NELEM  (BITVEC_USIZE/sizeof(BITVEC_TELEM))
#define BITVEC_NBIT (BITVEC_NELEM*BITVEC_SZELEM)
#define BITVEC_NINT (BITVEC_USIZE/sizeof(u32))
#define BITVEC_MXHASH (BITVEC_NINT/2)
#define BITVEC_HASH(X)  (((X)*1)%BITVEC_NINT)
#define BITVEC_NPTR (BITVEC_USIZE/sizeof(Bitvec *))
struct Bitvec {  u32 iSize;  u32 nSet;  u32 iDivisor;  union {  BITVEC_TELEM aBitmap[BITVEC_NELEM];  u32 aHash[BITVEC_NINT];  Bitvec *apSub[BITVEC_NPTR];  } u; }; SQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize){  Bitvec *p;  assert( sizeof(*p)==BITVEC_SZ );  p = sqlite3MallocZero( sizeof(*p) );  if( p ){  p->iSize = iSize;  }  return p; } SQLITE_PRIVATE int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){  assert( p!=0 );  i--;  if( i>=p->iSize ) return 0;  while( p->iDivisor ){  u32 bin = i/p->iDivisor;  i = i%p->iDivisor;  p = p->u.apSub[bin];  if (!p) {  return 0;  }  }  if( p->iSize<=BITVEC_NBIT ){  return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;  } else{  u32 h = BITVEC_HASH(i++);  while( p->u.aHash[h] ){  if( p->u.aHash[h]==i ) return 1;  h = (h+1) % BITVEC_NINT;  }  return 0;  } } SQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i){  return p!=0 && sqlite3BitvecTestNotNull(p,i); } SQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i){  u32 h;  if( p==0 ) return SQLITE_OK;  assert( i>0 );  assert( i<=p->iSize );  i--;  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {  u32 bin = i/p->iDivisor;  i = i%p->iDivisor;  if( p->u.apSub[bin]==0 ){  p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );  if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM_BKPT;  }  p = p->u.apSub[bin];  }  if( p->iSize<=BITVEC_NBIT ){  p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));  return SQLITE_OK;  }  h = BITVEC_HASH(i++);  if( !p->u.aHash[h] ){  if (p->nSet<(BITVEC_NINT-1)) {  goto bitvec_set_end;  } else {  goto bitvec_set_rehash;  }  }  do {  if( p->u.aHash[h]==i ) return SQLITE_OK;  h++;  if( h>=BITVEC_NINT ) h = 0;  } while( p->u.aHash[h] ); bitvec_set_rehash:  if( p->nSet>=BITVEC_MXHASH ){  unsigned int j;  int rc;  u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));  if( aiValues==0 ){  return SQLITE_NOMEM_BKPT;  }else{  memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));  memset(p->u.apSub, 0, sizeof(p->u.apSub));  p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;  rc = sqlite3BitvecSet(p, i);  for(j=0; j<BITVEC_NINT; j++){  if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);  }  sqlite3StackFree(0, aiValues);  return rc;  }  } bitvec_set_end:  p->nSet++;  p->u.aHash[h] = i;  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){  if( p==0 ) return;  assert( i>0 );  i--;  while( p->iDivisor ){  u32 bin = i/p->iDivisor;  i = i%p->iDivisor;  p = p->u.apSub[bin];  if (!p) {  return;  }  }  if( p->iSize<=BITVEC_NBIT ){  p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));  }else{  unsigned int j;  u32 *aiValues = pBuf;  memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));  memset(p->u.aHash, 0, sizeof(p->u.aHash));  p->nSet = 0;  for(j=0; j<BITVEC_NINT; j++){  if( aiValues[j] && aiValues[j]!=(i+1) ){  u32 h = BITVEC_HASH(aiValues[j]-1);  p->nSet++;  while( p->u.aHash[h] ){  h++;  if( h>=BITVEC_NINT ) h = 0;  }  p->u.aHash[h] = aiValues[j];  }  }  } } SQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p){  if( p==0 ) return;  if( p->iDivisor ){  unsigned int i;  for(i=0; i<BITVEC_NPTR; i++){  sqlite3BitvecDestroy(p->u.apSub[i]);  }  }  sqlite3_free(p); } SQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec *p){  return p->iSize; }
#ifndef SQLITE_UNTESTABLE
#define SETBIT(V,I) V[I>>3] |= (1<<(I&7))
#define CLEARBIT(V,I) V[I>>3] &= ~(1<<(I&7))
#define TESTBIT(V,I)  (V[I>>3]&(1<<(I&7)))!=0
SQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){  Bitvec *pBitvec = 0;  unsigned char *pV = 0;  int rc = -1;  int i, nx, pc, op;  void *pTmpSpace;  pBitvec = sqlite3BitvecCreate( sz );  pV = sqlite3MallocZero( (sz+7)/8 + 1 );  pTmpSpace = sqlite3_malloc64(BITVEC_SZ);  if( pBitvec==0 || pV==0 || pTmpSpace==0 ) goto bitvec_end;  sqlite3BitvecSet(0, 1);  sqlite3BitvecClear(0, 1, pTmpSpace);  pc = i = 0;  while( (op = aOp[pc])!=0 ){  switch( op ){  case 1:  case 2:  case 5: {  nx = 4;  i = aOp[pc+2] - 1;  aOp[pc+2] += aOp[pc+3];  break;  }  case 3:  case 4:  default: {  nx = 2;  sqlite3_randomness(sizeof(i), &i);  break;  }  }  if( (--aOp[pc+1]) > 0 ) nx = 0;  pc += nx;  i = (i & 0x7fffffff)%sz;  if( (op & 1)!=0 ){  SETBIT(pV, (i+1));  if( op!=5 ){  if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;  }  }else{  CLEARBIT(pV, (i+1));  sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);  }  }  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)  + sqlite3BitvecTest(pBitvec, 0)  + (sqlite3BitvecSize(pBitvec) - sz);  for(i=1; i<=sz; i++){  if( (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){  rc = i;  break;  }  } bitvec_end:  sqlite3_free(pTmpSpace);  sqlite3_free(pV);  sqlite3BitvecDestroy(pBitvec);  return rc; }
#endif
struct PCache {  PgHdr *pDirty, *pDirtyTail;  PgHdr *pSynced;  int nRefSum;  int szCache;  int szSpill;  int szPage;  int szExtra;  u8 bPurgeable;  u8 eCreate;  int (*xStress)(void*,PgHdr*);  void *pStress;  sqlite3_pcache *pCache; };
#if defined(SQLITE_DEBUG) && 0
 int sqlite3PcacheTrace = 2;  int sqlite3PcacheMxDump = 9999;
# define pcacheTrace(X) if(sqlite3PcacheTrace){sqlite3DebugPrintf X;}
 void pcacheDump(PCache *pCache){  int N;  int i, j;  sqlite3_pcache_page *pLower;  PgHdr *pPg;  unsigned char *a;  if( sqlite3PcacheTrace<2 ) return;  if( pCache->pCache==0 ) return;  N = sqlite3PcachePagecount(pCache);  if( N>sqlite3PcacheMxDump ) N = sqlite3PcacheMxDump;  for(i=1; i<=N; i++){   pLower = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, i, 0);   if( pLower==0 ) continue;   pPg = (PgHdr*)pLower->pExtra;   printf("%3d: nRef %2d flgs %02x data ", i, pPg->nRef, pPg->flags);   a = (unsigned char *)pLower->pBuf;   for(j=0; j<12; j++) printf("%02x", a[j]);   printf("\n");   if( pPg->pPage==0 ){   sqlite3GlobalConfig.pcache2.xUnpin(pCache->pCache, pLower, 0);   }  }  }
 #else
# define pcacheTrace(X)
# define pcacheDump(X)
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3PcachePageSanity(PgHdr *pPg){  PCache *pCache;  assert( pPg!=0 );  assert( pPg->pgno>0 || pPg->pPager==0 );  pCache = pPg->pCache;  assert( pCache!=0 );  if( pPg->flags & PGHDR_CLEAN ){  assert( (pPg->flags & PGHDR_DIRTY)==0 );  assert( pCache->pDirty!=pPg );  assert( pCache->pDirtyTail!=pPg );  }  if( pPg->flags & PGHDR_WRITEABLE ){  assert( pPg->flags & PGHDR_DIRTY );  }  return 1; }
#endif
#define PCACHE_DIRTYLIST_REMOVE  1
#define PCACHE_DIRTYLIST_ADD 2
#define PCACHE_DIRTYLIST_FRONT 3
static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){  PCache *p = pPage->pCache;  pcacheTrace(("%p.DIRTYLIST.%s %d\n", p,  addRemove==1 ? "REMOVE" : addRemove==2 ? "ADD" : "FRONT",  pPage->pgno));  if( addRemove & PCACHE_DIRTYLIST_REMOVE ){  assert( pPage->pDirtyNext || pPage==p->pDirtyTail );  assert( pPage->pDirtyPrev || pPage==p->pDirty );  if( p->pSynced==pPage ){  p->pSynced = pPage->pDirtyPrev;  }  if( pPage->pDirtyNext ){  pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;  }else{  assert( pPage==p->pDirtyTail );  p->pDirtyTail = pPage->pDirtyPrev;  }  if( pPage->pDirtyPrev ){  pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;  }else{  assert( pPage==p->pDirty );  p->pDirty = pPage->pDirtyNext;  assert( p->bPurgeable || p->eCreate==2 );  if( p->pDirty==0 ){  assert( p->bPurgeable==0 || p->eCreate==1 );  p->eCreate = 2;  }  }  }  if( addRemove & PCACHE_DIRTYLIST_ADD ){  pPage->pDirtyPrev = 0;  pPage->pDirtyNext = p->pDirty;  if( pPage->pDirtyNext ){  assert( pPage->pDirtyNext->pDirtyPrev==0 );  pPage->pDirtyNext->pDirtyPrev = pPage;  }else{  p->pDirtyTail = pPage;  if( p->bPurgeable ){  assert( p->eCreate==2 );  p->eCreate = 1;  }  }  p->pDirty = pPage;  if( !p->pSynced   && 0==(pPage->flags&PGHDR_NEED_SYNC)  ){  p->pSynced = pPage;  }  }  pcacheDump(p); } static void pcacheUnpin(PgHdr *p){  if( p->pCache->bPurgeable ){  pcacheTrace(("%p.UNPIN %d\n", p->pCache, p->pgno));  sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);  pcacheDump(p->pCache);  } } static int numberOfCachePages(PCache *p){  if( p->szCache>=0 ){  return p->szCache;  }else{  i64 n;  n = ((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));  if( n>1000000000 ) n = 1000000000;  return (int)n;  } } SQLITE_PRIVATE int sqlite3PcacheInitialize(void){  if( sqlite3GlobalConfig.pcache2.xInit==0 ){  sqlite3PCacheSetDefault();  assert( sqlite3GlobalConfig.pcache2.xInit!=0 );  }  return sqlite3GlobalConfig.pcache2.xInit(sqlite3GlobalConfig.pcache2.pArg); } SQLITE_PRIVATE void sqlite3PcacheShutdown(void){  if( sqlite3GlobalConfig.pcache2.xShutdown ){  sqlite3GlobalConfig.pcache2.xShutdown(sqlite3GlobalConfig.pcache2.pArg);  } } SQLITE_PRIVATE int sqlite3PcacheSize(void){ return sizeof(PCache); } SQLITE_PRIVATE int sqlite3PcacheOpen(  int szPage,  int szExtra,  int bPurgeable,  int (*xStress)(void*,PgHdr*),  void *pStress,  PCache *p ){  memset(p, 0, sizeof(PCache));  p->szPage = 1;  p->szExtra = szExtra;  assert( szExtra>=8 );  p->bPurgeable = bPurgeable;  p->eCreate = 2;  p->xStress = xStress;  p->pStress = pStress;  p->szCache = 100;  p->szSpill = 1;  pcacheTrace(("%p.OPEN szPage %d bPurgeable %d\n",p,szPage,bPurgeable));  return sqlite3PcacheSetPageSize(p, szPage); } SQLITE_PRIVATE int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){  assert( pCache->nRefSum==0 && pCache->pDirty==0 );  if( pCache->szPage ){  sqlite3_pcache *pNew;  pNew = sqlite3GlobalConfig.pcache2.xCreate(  szPage, pCache->szExtra + ROUND8(sizeof(PgHdr)),  pCache->bPurgeable  );  if( pNew==0 ) return SQLITE_NOMEM_BKPT;  sqlite3GlobalConfig.pcache2.xCachesize(pNew, numberOfCachePages(pCache));  if( pCache->pCache ){  sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);  }  pCache->pCache = pNew;  pCache->szPage = szPage;  pcacheTrace(("%p.PAGESIZE %d\n",pCache,szPage));  }  return SQLITE_OK; } SQLITE_PRIVATE sqlite3_pcache_page *sqlite3PcacheFetch(  PCache *pCache,  Pgno pgno,  int createFlag ){  int eCreate;  sqlite3_pcache_page *pRes;  assert( pCache!=0 );  assert( pCache->pCache!=0 );  assert( createFlag==3 || createFlag==0 );  assert( pCache->eCreate==((pCache->bPurgeable && pCache->pDirty) ? 1 : 2) );  eCreate = createFlag & pCache->eCreate;  assert( eCreate==0 || eCreate==1 || eCreate==2 );  assert( createFlag==0 || pCache->eCreate==eCreate );  assert( createFlag==0 || eCreate==1+(!pCache->bPurgeable||!pCache->pDirty) );  pRes = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, eCreate);  pcacheTrace(("%p.FETCH %d%s (result: %p)\n",pCache,pgno,   createFlag?" create":"",pRes));  return pRes; } SQLITE_PRIVATE int sqlite3PcacheFetchStress(  PCache *pCache,  Pgno pgno,  sqlite3_pcache_page **ppPage ){  PgHdr *pPg;  if( pCache->eCreate==2 ) return 0;  if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){  for(pPg=pCache->pSynced;  pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC));  pPg=pPg->pDirtyPrev  );  pCache->pSynced = pPg;  if( !pPg ){  for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);  }  if( pPg ){  int rc;
#ifdef SQLITE_LOG_CACHE_SPILL
 sqlite3_log(SQLITE_FULL,  "spill page %d making room for %d - cache used: %d/%d",  pPg->pgno, pgno,  sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache),  numberOfCachePages(pCache));
#endif
 pcacheTrace(("%p.SPILL %d\n",pCache,pPg->pgno));  rc = pCache->xStress(pCache->pStress, pPg);  pcacheDump(pCache);  if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){  return rc;  }  }  }  *ppPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, 2);  return *ppPage==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK; } static SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit(  PCache *pCache,  Pgno pgno,  sqlite3_pcache_page *pPage ){  PgHdr *pPgHdr;  assert( pPage!=0 );  pPgHdr = (PgHdr*)pPage->pExtra;  assert( pPgHdr->pPage==0 );  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));  pPgHdr->pPage = pPage;  pPgHdr->pData = pPage->pBuf;  pPgHdr->pExtra = (void *)&pPgHdr[1];  memset(pPgHdr->pExtra, 0, 8);  pPgHdr->pCache = pCache;  pPgHdr->pgno = pgno;  pPgHdr->flags = PGHDR_CLEAN;  return sqlite3PcacheFetchFinish(pCache,pgno,pPage); } SQLITE_PRIVATE PgHdr *sqlite3PcacheFetchFinish(  PCache *pCache,  Pgno pgno,  sqlite3_pcache_page *pPage ){  PgHdr *pPgHdr;  assert( pPage!=0 );  pPgHdr = (PgHdr *)pPage->pExtra;  if( !pPgHdr->pPage ){  return pcacheFetchFinishWithInit(pCache, pgno, pPage);  }  pCache->nRefSum++;  pPgHdr->nRef++;  assert( sqlite3PcachePageSanity(pPgHdr) );  return pPgHdr; } SQLITE_PRIVATE void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){  assert( p->nRef>0 );  p->pCache->nRefSum--;  if( (--p->nRef)==0 ){  if( p->flags&PGHDR_CLEAN ){  pcacheUnpin(p);  }else{  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);  }  } } SQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p){  assert(p->nRef>0);  assert( sqlite3PcachePageSanity(p) );  p->nRef++;  p->pCache->nRefSum++; } SQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p){  assert( p->nRef==1 );  assert( sqlite3PcachePageSanity(p) );  if( p->flags&PGHDR_DIRTY ){  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);  }  p->pCache->nRefSum--;  sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1); } SQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr *p){  assert( p->nRef>0 );  assert( sqlite3PcachePageSanity(p) );  if( p->flags & (PGHDR_CLEAN|PGHDR_DONT_WRITE) ){  p->flags &= ~PGHDR_DONT_WRITE;  if( p->flags & PGHDR_CLEAN ){  p->flags ^= (PGHDR_DIRTY|PGHDR_CLEAN);  pcacheTrace(("%p.DIRTY %d\n",p->pCache,p->pgno));  assert( (p->flags & (PGHDR_DIRTY|PGHDR_CLEAN))==PGHDR_DIRTY );  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_ADD);  }  assert( sqlite3PcachePageSanity(p) );  } } SQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr *p){  assert( sqlite3PcachePageSanity(p) );  assert( (p->flags & PGHDR_DIRTY)!=0 );  assert( (p->flags & PGHDR_CLEAN)==0 );  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);  p->flags &= ~(PGHDR_DIRTY|PGHDR_NEED_SYNC|PGHDR_WRITEABLE);  p->flags |= PGHDR_CLEAN;  pcacheTrace(("%p.CLEAN %d\n",p->pCache,p->pgno));  assert( sqlite3PcachePageSanity(p) );  if( p->nRef==0 ){  pcacheUnpin(p);  } } SQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache){  PgHdr *p;  pcacheTrace(("%p.CLEAN-ALL\n",pCache));  while( (p = pCache->pDirty)!=0 ){  sqlite3PcacheMakeClean(p);  } } SQLITE_PRIVATE void sqlite3PcacheClearWritable(PCache *pCache){  PgHdr *p;  pcacheTrace(("%p.CLEAR-WRITEABLE\n",pCache));  for(p=pCache->pDirty; p; p=p->pDirtyNext){  p->flags &= ~(PGHDR_NEED_SYNC|PGHDR_WRITEABLE);  }  pCache->pSynced = pCache->pDirtyTail; } SQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache){  PgHdr *p;  for(p=pCache->pDirty; p; p=p->pDirtyNext){  p->flags &= ~PGHDR_NEED_SYNC;  }  pCache->pSynced = pCache->pDirtyTail; } SQLITE_PRIVATE void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){  PCache *pCache = p->pCache;  assert( p->nRef>0 );  assert( newPgno>0 );  assert( sqlite3PcachePageSanity(p) );  pcacheTrace(("%p.MOVE %d -> %d\n",pCache,p->pgno,newPgno));  sqlite3GlobalConfig.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno,newPgno);  p->pgno = newPgno;  if( (p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC) ){  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);  } } SQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){  if( pCache->pCache ){  PgHdr *p;  PgHdr *pNext;  pcacheTrace(("%p.TRUNCATE %d\n",pCache,pgno));  for(p=pCache->pDirty; p; p=pNext){  pNext = p->pDirtyNext;  assert( p->pgno>0 );  if( p->pgno>pgno ){  assert( p->flags&PGHDR_DIRTY );  sqlite3PcacheMakeClean(p);  }  }  if( pgno==0 && pCache->nRefSum ){  sqlite3_pcache_page *pPage1;  pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache,1,0);  if( ALWAYS(pPage1) ){  memset(pPage1->pBuf, 0, pCache->szPage);  pgno = 1;  }  }  sqlite3GlobalConfig.pcache2.xTruncate(pCache->pCache, pgno+1);  } } SQLITE_PRIVATE void sqlite3PcacheClose(PCache *pCache){  assert( pCache->pCache!=0 );  pcacheTrace(("%p.CLOSE\n",pCache));  sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache); } SQLITE_PRIVATE void sqlite3PcacheClear(PCache *pCache){  sqlite3PcacheTruncate(pCache, 0); } static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){  PgHdr result, *pTail;  pTail = &result;  assert( pA!=0 && pB!=0 );  for(;;){  if( pA->pgno<pB->pgno ){  pTail->pDirty = pA;  pTail = pA;  pA = pA->pDirty;  if( pA==0 ){  pTail->pDirty = pB;  break;  }  }else{  pTail->pDirty = pB;  pTail = pB;  pB = pB->pDirty;  if( pB==0 ){  pTail->pDirty = pA;  break;  }  }  }  return result.pDirty; }
#define N_SORT_BUCKET 32
static PgHdr *pcacheSortDirtyList(PgHdr *pIn){  PgHdr *a[N_SORT_BUCKET], *p;  int i;  memset(a, 0, sizeof(a));  while( pIn ){  p = pIn;  pIn = p->pDirty;  p->pDirty = 0;  for(i=0; ALWAYS(i<N_SORT_BUCKET-1); i++){  if( a[i]==0 ){  a[i] = p;  break;  }else{  p = pcacheMergeDirtyList(a[i], p);  a[i] = 0;  }  }  if( NEVER(i==N_SORT_BUCKET-1) ){  a[i] = pcacheMergeDirtyList(a[i], p);  }  }  p = a[0];  for(i=1; i<N_SORT_BUCKET; i++){  if( a[i]==0 ) continue;  p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];  }  return p; } SQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){  PgHdr *p;  for(p=pCache->pDirty; p; p=p->pDirtyNext){  p->pDirty = p->pDirtyNext;  }  return pcacheSortDirtyList(pCache->pDirty); } SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){  return pCache->nRefSum; } SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p){  return p->nRef; } SQLITE_PRIVATE int sqlite3PcachePagecount(PCache *pCache){  assert( pCache->pCache!=0 );  return sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache); }
#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *pCache){  return numberOfCachePages(pCache); }
#endif
SQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){  assert( pCache->pCache!=0 );  pCache->szCache = mxPage;  sqlite3GlobalConfig.pcache2.xCachesize(pCache->pCache,   numberOfCachePages(pCache)); } SQLITE_PRIVATE int sqlite3PcacheSetSpillsize(PCache *p, int mxPage){  int res;  assert( p->pCache!=0 );  if( mxPage ){  if( mxPage<0 ){  mxPage = (int)((-1024*(i64)mxPage)/(p->szPage+p->szExtra));  }  p->szSpill = mxPage;  }  res = numberOfCachePages(p);  if( res<p->szSpill ) res = p->szSpill;  return res; } SQLITE_PRIVATE void sqlite3PcacheShrink(PCache *pCache){  assert( pCache->pCache!=0 );  sqlite3GlobalConfig.pcache2.xShrink(pCache->pCache); } SQLITE_PRIVATE int sqlite3HeaderSizePcache(void){ return ROUND8(sizeof(PgHdr)); } SQLITE_PRIVATE int sqlite3PCachePercentDirty(PCache *pCache){  PgHdr *pDirty;  int nDirty = 0;  int nCache = numberOfCachePages(pCache);  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;  return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0; }
#ifdef SQLITE_DIRECT_OVERFLOW_READ
SQLITE_PRIVATE int sqlite3PCacheIsDirty(PCache *pCache){  return (pCache->pDirty!=0); }
#endif
#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)
SQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){  PgHdr *pDirty;  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext){  xIter(pDirty);  } }
#endif
typedef struct PCache1 PCache1; typedef struct PgHdr1 PgHdr1; typedef struct PgFreeslot PgFreeslot; typedef struct PGroup PGroup; struct PgHdr1 {  sqlite3_pcache_page page;  unsigned int iKey;  u16 isBulkLocal;  u16 isAnchor;  PgHdr1 *pNext;  PCache1 *pCache;  PgHdr1 *pLruNext;  PgHdr1 *pLruPrev; };
#define PAGE_IS_PINNED(p) ((p)->pLruNext==0)
#define PAGE_IS_UNPINNED(p) ((p)->pLruNext!=0)
struct PGroup {  sqlite3_mutex *mutex;  unsigned int nMaxPage;  unsigned int nMinPage;  unsigned int mxPinned;  unsigned int nPurgeable;  PgHdr1 lru; }; struct PCache1 {  PGroup *pGroup;  unsigned int *pnPurgeable;  int szPage;  int szExtra;  int szAlloc;  int bPurgeable;  unsigned int nMin;  unsigned int nMax;  unsigned int n90pct;  unsigned int iMaxKey;  unsigned int nPurgeableDummy;  unsigned int nRecyclable;  unsigned int nPage;  unsigned int nHash;  PgHdr1 **apHash;  PgHdr1 *pFree;  void *pBulk; }; struct PgFreeslot {  PgFreeslot *pNext; }; static SQLITE_WSD struct PCacheGlobal {  PGroup grp;  int isInit;  int separateCache;  int nInitPage;  int szSlot;  int nSlot;  int nReserve;  void *pStart, *pEnd;  sqlite3_mutex *mutex;  PgFreeslot *pFree;  int nFreeSlot;  int bUnderPressure; } pcache1_g;
#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))
#if !defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) || SQLITE_THREADSAFE==0
# define pcache1EnterMutex(X) assert((X)->mutex==0)
# define pcache1LeaveMutex(X) assert((X)->mutex==0)
# define PCACHE1_MIGHT_USE_GROUP_MUTEX 0
#else
# define pcache1EnterMutex(X) sqlite3_mutex_enter((X)->mutex)
# define pcache1LeaveMutex(X) sqlite3_mutex_leave((X)->mutex)
# define PCACHE1_MIGHT_USE_GROUP_MUTEX 1
#endif
SQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){  if( pcache1.isInit ){  PgFreeslot *p;  if( pBuf==0 ) sz = n = 0;  if( n==0 ) sz = 0;  sz = ROUNDDOWN8(sz);  pcache1.szSlot = sz;  pcache1.nSlot = pcache1.nFreeSlot = n;  pcache1.nReserve = n>90 ? 10 : (n/10 + 1);  pcache1.pStart = pBuf;  pcache1.pFree = 0;  pcache1.bUnderPressure = 0;  while( n-- ){  p = (PgFreeslot*)pBuf;  p->pNext = pcache1.pFree;  pcache1.pFree = p;  pBuf = (void*)&((char*)pBuf)[sz];  }  pcache1.pEnd = pBuf;  } } static int pcache1InitBulk(PCache1 *pCache){  i64 szBulk;  char *zBulk;  if( pcache1.nInitPage==0 ) return 0;  if( pCache->nMax<3 ) return 0;  sqlite3BeginBenignMalloc();  if( pcache1.nInitPage>0 ){  szBulk = pCache->szAlloc * (i64)pcache1.nInitPage;  }else{  szBulk = -1024 * (i64)pcache1.nInitPage;  }  if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){  szBulk = pCache->szAlloc*(i64)pCache->nMax;  }  zBulk = pCache->pBulk = sqlite3Malloc( szBulk );  sqlite3EndBenignMalloc();  if( zBulk ){  int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;  do{  PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];  pX->page.pBuf = zBulk;  pX->page.pExtra = &pX[1];  pX->isBulkLocal = 1;  pX->isAnchor = 0;  pX->pNext = pCache->pFree;  pX->pLruPrev = 0;  pCache->pFree = pX;  zBulk += pCache->szAlloc;  }while( --nBulk );  }  return pCache->pFree!=0; } static void *pcache1Alloc(int nByte){  void *p = 0;  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );  if( nByte<=pcache1.szSlot ){  sqlite3_mutex_enter(pcache1.mutex);  p = (PgHdr1 *)pcache1.pFree;  if( p ){  pcache1.pFree = pcache1.pFree->pNext;  pcache1.nFreeSlot--;  pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;  assert( pcache1.nFreeSlot>=0 );  sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);  sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);  }  sqlite3_mutex_leave(pcache1.mutex);  }  if( p==0 ){  p = sqlite3Malloc(nByte);
#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
 if( p ){  int sz = sqlite3MallocSize(p);  sqlite3_mutex_enter(pcache1.mutex);  sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);  sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);  sqlite3_mutex_leave(pcache1.mutex);  }
#endif
 sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);  }  return p; } static void pcache1Free(void *p){  if( p==0 ) return;  if( SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd) ){  PgFreeslot *pSlot;  sqlite3_mutex_enter(pcache1.mutex);  sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);  pSlot = (PgFreeslot*)p;  pSlot->pNext = pcache1.pFree;  pcache1.pFree = pSlot;  pcache1.nFreeSlot++;  pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;  assert( pcache1.nFreeSlot<=pcache1.nSlot );  sqlite3_mutex_leave(pcache1.mutex);  }else{  assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);
#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS
 {  int nFreed = 0;  nFreed = sqlite3MallocSize(p);  sqlite3_mutex_enter(pcache1.mutex);  sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);  sqlite3_mutex_leave(pcache1.mutex);  }
#endif
 sqlite3_free(p);  } }
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
static int pcache1MemSize(void *p){  if( p>=pcache1.pStart && p<pcache1.pEnd ){  return pcache1.szSlot;  }else{  int iSize;  assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);  iSize = sqlite3MallocSize(p);  sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);  return iSize;  } }
#endif
static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){  PgHdr1 *p = 0;  void *pPg;  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );  if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){  assert( pCache->pFree!=0 );  p = pCache->pFree;  pCache->pFree = p->pNext;  p->pNext = 0;  }else{
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 assert( pcache1.separateCache==0 );  assert( pCache->pGroup==&pcache1.grp );  pcache1LeaveMutex(pCache->pGroup);
#endif
 if( benignMalloc ){ sqlite3BeginBenignMalloc(); }
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
 pPg = pcache1Alloc(pCache->szPage);  p = sqlite3Malloc(sizeof(PgHdr1) + pCache->szExtra);  if( !pPg || !p ){  pcache1Free(pPg);  sqlite3_free(p);  pPg = 0;  }
#else
 pPg = pcache1Alloc(pCache->szAlloc);
#endif
 if( benignMalloc ){ sqlite3EndBenignMalloc(); }
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
 pcache1EnterMutex(pCache->pGroup);
#endif
 if( pPg==0 ) return 0;
#ifndef SQLITE_PCACHE_SEPARATE_HEADER
 p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];
#endif
 p->page.pBuf = pPg;  p->page.pExtra = &p[1];  p->isBulkLocal = 0;  p->isAnchor = 0;  p->pLruPrev = 0;  }  (*pCache->pnPurgeable)++;  return p; } static void pcache1FreePage(PgHdr1 *p){  PCache1 *pCache;  assert( p!=0 );  pCache = p->pCache;  assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );  if( p->isBulkLocal ){  p->pNext = pCache->pFree;  pCache->pFree = p;  }else{  pcache1Free(p->page.pBuf);
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
 sqlite3_free(p);
#endif
 }  (*pCache->pnPurgeable)--; } SQLITE_PRIVATE void *sqlite3PageMalloc(int sz){  assert( sz<=65536+8 );  return pcache1Alloc(sz); } SQLITE_PRIVATE void sqlite3PageFree(void *p){  pcache1Free(p); } static int pcache1UnderMemoryPressure(PCache1 *pCache){  if( pcache1.nSlot && (pCache->szPage+pCache->szExtra)<=pcache1.szSlot ){  return pcache1.bUnderPressure;  }else{  return sqlite3HeapNearlyFull();  } } static void pcache1ResizeHash(PCache1 *p){  PgHdr1 **apNew;  unsigned int nNew;  unsigned int i;  assert( sqlite3_mutex_held(p->pGroup->mutex) );  nNew = p->nHash*2;  if( nNew<256 ){  nNew = 256;  }  pcache1LeaveMutex(p->pGroup);  if( p->nHash ){ sqlite3BeginBenignMalloc(); }  apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);  if( p->nHash ){ sqlite3EndBenignMalloc(); }  pcache1EnterMutex(p->pGroup);  if( apNew ){  for(i=0; i<p->nHash; i++){  PgHdr1 *pPage;  PgHdr1 *pNext = p->apHash[i];  while( (pPage = pNext)!=0 ){  unsigned int h = pPage->iKey % nNew;  pNext = pPage->pNext;  pPage->pNext = apNew[h];  apNew[h] = pPage;  }  }  sqlite3_free(p->apHash);  p->apHash = apNew;  p->nHash = nNew;  } } static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){  assert( pPage!=0 );  assert( PAGE_IS_UNPINNED(pPage) );  assert( pPage->pLruNext );  assert( pPage->pLruPrev );  assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );  pPage->pLruPrev->pLruNext = pPage->pLruNext;  pPage->pLruNext->pLruPrev = pPage->pLruPrev;  pPage->pLruNext = 0;  assert( pPage->isAnchor==0 );  assert( pPage->pCache->pGroup->lru.isAnchor==1 );  pPage->pCache->nRecyclable--;  return pPage; } static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){  unsigned int h;  PCache1 *pCache = pPage->pCache;  PgHdr1 **pp;  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );  h = pPage->iKey % pCache->nHash;  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);  *pp = (*pp)->pNext;  pCache->nPage--;  if( freeFlag ) pcache1FreePage(pPage); } static void pcache1EnforceMaxPage(PCache1 *pCache){  PGroup *pGroup = pCache->pGroup;  PgHdr1 *p;  assert( sqlite3_mutex_held(pGroup->mutex) );  while( pGroup->nPurgeable>pGroup->nMaxPage  && (p=pGroup->lru.pLruPrev)->isAnchor==0  ){  assert( p->pCache->pGroup==pGroup );  assert( PAGE_IS_UNPINNED(p) );  pcache1PinPage(p);  pcache1RemoveFromHash(p, 1);  }  if( pCache->nPage==0 && pCache->pBulk ){  sqlite3_free(pCache->pBulk);  pCache->pBulk = pCache->pFree = 0;  } } static void pcache1TruncateUnsafe(  PCache1 *pCache,  unsigned int iLimit ){  TESTONLY( int nPage = 0; )  unsigned int h, iStop;  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );  assert( pCache->iMaxKey >= iLimit );  assert( pCache->nHash > 0 );  if( pCache->iMaxKey - iLimit < pCache->nHash ){  h = iLimit % pCache->nHash;  iStop = pCache->iMaxKey % pCache->nHash;  TESTONLY( nPage = -10; )  }else{  h = pCache->nHash/2;  iStop = h - 1;  }  for(;;){  PgHdr1 **pp;  PgHdr1 *pPage;  assert( h<pCache->nHash );  pp = &pCache->apHash[h];  while( (pPage = *pp)!=0 ){  if( pPage->iKey>=iLimit ){  pCache->nPage--;  *pp = pPage->pNext;  if( PAGE_IS_UNPINNED(pPage) ) pcache1PinPage(pPage);  pcache1FreePage(pPage);  }else{  pp = &pPage->pNext;  TESTONLY( if( nPage>=0 ) nPage++; )  }  }  if( h==iStop ) break;  h = (h+1) % pCache->nHash;  }  assert( nPage<0 || pCache->nPage==(unsigned)nPage ); } static int pcache1Init(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  assert( pcache1.isInit==0 );  memset(&pcache1, 0, sizeof(pcache1));
#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT)
 pcache1.separateCache = 0;
#elif SQLITE_THREADSAFE
 pcache1.separateCache = sqlite3GlobalConfig.pPage==0  || sqlite3GlobalConfig.bCoreMutex>0;
#else
 pcache1.separateCache = sqlite3GlobalConfig.pPage==0;
#endif
#if SQLITE_THREADSAFE
 if( sqlite3GlobalConfig.bCoreMutex ){  pcache1.grp.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU);  pcache1.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PMEM);  }
#endif
 if( pcache1.separateCache   && sqlite3GlobalConfig.nPage!=0   && sqlite3GlobalConfig.pPage==0  ){  pcache1.nInitPage = sqlite3GlobalConfig.nPage;  }else{  pcache1.nInitPage = 0;  }  pcache1.grp.mxPinned = 10;  pcache1.isInit = 1;  return SQLITE_OK; } static void pcache1Shutdown(void *NotUsed){  UNUSED_PARAMETER(NotUsed);  assert( pcache1.isInit!=0 );  memset(&pcache1, 0, sizeof(pcache1)); } static void pcache1Destroy(sqlite3_pcache *p); static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){  PCache1 *pCache;  PGroup *pGroup;  int sz;  assert( (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 );  assert( szExtra < 300 );  sz = sizeof(PCache1) + sizeof(PGroup)*pcache1.separateCache;  pCache = (PCache1 *)sqlite3MallocZero(sz);  if( pCache ){  if( pcache1.separateCache ){  pGroup = (PGroup*)&pCache[1];  pGroup->mxPinned = 10;  }else{  pGroup = &pcache1.grp;  }  pcache1EnterMutex(pGroup);  if( pGroup->lru.isAnchor==0 ){  pGroup->lru.isAnchor = 1;  pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;  }  pCache->pGroup = pGroup;  pCache->szPage = szPage;  pCache->szExtra = szExtra;  pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));  pCache->bPurgeable = (bPurgeable ? 1 : 0);  pcache1ResizeHash(pCache);  if( bPurgeable ){  pCache->nMin = 10;  pGroup->nMinPage += pCache->nMin;  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;  pCache->pnPurgeable = &pGroup->nPurgeable;  }else{  pCache->pnPurgeable = &pCache->nPurgeableDummy;  }  pcache1LeaveMutex(pGroup);  if( pCache->nHash==0 ){  pcache1Destroy((sqlite3_pcache*)pCache);  pCache = 0;  }  }  return (sqlite3_pcache *)pCache; } static void pcache1Cachesize(sqlite3_pcache *p, int nMax){  PCache1 *pCache = (PCache1 *)p;  u32 n;  assert( nMax>=0 );  if( pCache->bPurgeable ){  PGroup *pGroup = pCache->pGroup;  pcache1EnterMutex(pGroup);  n = (u32)nMax;  if( n > 0x7fff0000 - pGroup->nMaxPage + pCache->nMax ){  n = 0x7fff0000 - pGroup->nMaxPage + pCache->nMax;  }  pGroup->nMaxPage += (n - pCache->nMax);  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;  pCache->nMax = n;  pCache->n90pct = pCache->nMax*9/10;  pcache1EnforceMaxPage(pCache);  pcache1LeaveMutex(pGroup);  } } static void pcache1Shrink(sqlite3_pcache *p){  PCache1 *pCache = (PCache1*)p;  if( pCache->bPurgeable ){  PGroup *pGroup = pCache->pGroup;  unsigned int savedMaxPage;  pcache1EnterMutex(pGroup);  savedMaxPage = pGroup->nMaxPage;  pGroup->nMaxPage = 0;  pcache1EnforceMaxPage(pCache);  pGroup->nMaxPage = savedMaxPage;  pcache1LeaveMutex(pGroup);  } } static int pcache1Pagecount(sqlite3_pcache *p){  int n;  PCache1 *pCache = (PCache1*)p;  pcache1EnterMutex(pCache->pGroup);  n = pCache->nPage;  pcache1LeaveMutex(pCache->pGroup);  return n; } static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(  PCache1 *pCache,  unsigned int iKey,  int createFlag ){  unsigned int nPinned;  PGroup *pGroup = pCache->pGroup;  PgHdr1 *pPage = 0;  assert( pCache->nPage >= pCache->nRecyclable );  nPinned = pCache->nPage - pCache->nRecyclable;  assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );  assert( pCache->n90pct == pCache->nMax*9/10 );  if( createFlag==1 && (  nPinned>=pGroup->mxPinned   || nPinned>=pCache->n90pct   || (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)  )){  return 0;  }  if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);  assert( pCache->nHash>0 && pCache->apHash );  if( pCache->bPurgeable   && !pGroup->lru.pLruPrev->isAnchor   && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))  ){  PCache1 *pOther;  pPage = pGroup->lru.pLruPrev;  assert( PAGE_IS_UNPINNED(pPage) );  pcache1RemoveFromHash(pPage, 0);  pcache1PinPage(pPage);  pOther = pPage->pCache;  if( pOther->szAlloc != pCache->szAlloc ){  pcache1FreePage(pPage);  pPage = 0;  }else{  pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);  }  }  if( !pPage ){  pPage = pcache1AllocPage(pCache, createFlag==1);  }  if( pPage ){  unsigned int h = iKey % pCache->nHash;  pCache->nPage++;  pPage->iKey = iKey;  pPage->pNext = pCache->apHash[h];  pPage->pCache = pCache;  pPage->pLruNext = 0;  *(void **)pPage->page.pExtra = 0;  pCache->apHash[h] = pPage;  if( iKey>pCache->iMaxKey ){  pCache->iMaxKey = iKey;  }  }  return pPage; } static PgHdr1 *pcache1FetchNoMutex(  sqlite3_pcache *p,  unsigned int iKey,  int createFlag ){  PCache1 *pCache = (PCache1 *)p;  PgHdr1 *pPage = 0;  pPage = pCache->apHash[iKey % pCache->nHash];  while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }  if( pPage ){  if( PAGE_IS_UNPINNED(pPage) ){  return pcache1PinPage(pPage);  }else{  return pPage;  }  }else if( createFlag ){  return pcache1FetchStage2(pCache, iKey, createFlag);  }else{  return 0;  } }
#if PCACHE1_MIGHT_USE_GROUP_MUTEX
static PgHdr1 *pcache1FetchWithMutex(  sqlite3_pcache *p,  unsigned int iKey,  int createFlag ){  PCache1 *pCache = (PCache1 *)p;  PgHdr1 *pPage;  pcache1EnterMutex(pCache->pGroup);  pPage = pcache1FetchNoMutex(p, iKey, createFlag);  assert( pPage==0 || pCache->iMaxKey>=iKey );  pcache1LeaveMutex(pCache->pGroup);  return pPage; }
#endif
static sqlite3_pcache_page *pcache1Fetch(  sqlite3_pcache *p,  unsigned int iKey,  int createFlag ){
#if PCACHE1_MIGHT_USE_GROUP_MUTEX || defined(SQLITE_DEBUG)
 PCache1 *pCache = (PCache1 *)p;
#endif
 assert( offsetof(PgHdr1,page)==0 );  assert( pCache->bPurgeable || createFlag!=1 );  assert( pCache->bPurgeable || pCache->nMin==0 );  assert( pCache->bPurgeable==0 || pCache->nMin==10 );  assert( pCache->nMin==0 || pCache->bPurgeable );  assert( pCache->nHash>0 );
#if PCACHE1_MIGHT_USE_GROUP_MUTEX
 if( pCache->pGroup->mutex ){  return (sqlite3_pcache_page*)pcache1FetchWithMutex(p, iKey, createFlag);  }else
#endif
 {  return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);  } } static void pcache1Unpin(  sqlite3_pcache *p,  sqlite3_pcache_page *pPg,  int reuseUnlikely ){  PCache1 *pCache = (PCache1 *)p;  PgHdr1 *pPage = (PgHdr1 *)pPg;  PGroup *pGroup = pCache->pGroup;  assert( pPage->pCache==pCache );  pcache1EnterMutex(pGroup);  assert( pPage->pLruNext==0 );  assert( PAGE_IS_PINNED(pPage) );  if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){  pcache1RemoveFromHash(pPage, 1);  }else{  PgHdr1 **ppFirst = &pGroup->lru.pLruNext;  pPage->pLruPrev = &pGroup->lru;  (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;  *ppFirst = pPage;  pCache->nRecyclable++;  }  pcache1LeaveMutex(pCache->pGroup); } static void pcache1Rekey(  sqlite3_pcache *p,  sqlite3_pcache_page *pPg,  unsigned int iOld,  unsigned int iNew ){  PCache1 *pCache = (PCache1 *)p;  PgHdr1 *pPage = (PgHdr1 *)pPg;  PgHdr1 **pp;  unsigned int h;  assert( pPage->iKey==iOld );  assert( pPage->pCache==pCache );  pcache1EnterMutex(pCache->pGroup);  h = iOld%pCache->nHash;  pp = &pCache->apHash[h];  while( (*pp)!=pPage ){  pp = &(*pp)->pNext;  }  *pp = pPage->pNext;  h = iNew%pCache->nHash;  pPage->iKey = iNew;  pPage->pNext = pCache->apHash[h];  pCache->apHash[h] = pPage;  if( iNew>pCache->iMaxKey ){  pCache->iMaxKey = iNew;  }  pcache1LeaveMutex(pCache->pGroup); } static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){  PCache1 *pCache = (PCache1 *)p;  pcache1EnterMutex(pCache->pGroup);  if( iLimit<=pCache->iMaxKey ){  pcache1TruncateUnsafe(pCache, iLimit);  pCache->iMaxKey = iLimit-1;  }  pcache1LeaveMutex(pCache->pGroup); } static void pcache1Destroy(sqlite3_pcache *p){  PCache1 *pCache = (PCache1 *)p;  PGroup *pGroup = pCache->pGroup;  assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );  pcache1EnterMutex(pGroup);  if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);  assert( pGroup->nMaxPage >= pCache->nMax );  pGroup->nMaxPage -= pCache->nMax;  assert( pGroup->nMinPage >= pCache->nMin );  pGroup->nMinPage -= pCache->nMin;  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;  pcache1EnforceMaxPage(pCache);  pcache1LeaveMutex(pGroup);  sqlite3_free(pCache->pBulk);  sqlite3_free(pCache->apHash);  sqlite3_free(pCache); } SQLITE_PRIVATE void sqlite3PCacheSetDefault(void){  static const sqlite3_pcache_methods2 defaultMethods = {  1,  0,  pcache1Init,  pcache1Shutdown,  pcache1Create,  pcache1Cachesize,  pcache1Pagecount,  pcache1Fetch,  pcache1Unpin,  pcache1Rekey,  pcache1Truncate,  pcache1Destroy,  pcache1Shrink  };  sqlite3_config(SQLITE_CONFIG_PCACHE2, &defaultMethods); } SQLITE_PRIVATE int sqlite3HeaderSizePcache1(void){ return ROUND8(sizeof(PgHdr1)); } SQLITE_PRIVATE sqlite3_mutex *sqlite3Pcache1Mutex(void){  return pcache1.mutex; }
#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT
SQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){  int nFree = 0;  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );  assert( sqlite3_mutex_notheld(pcache1.mutex) );  if( sqlite3GlobalConfig.pPage==0 ){  PgHdr1 *p;  pcache1EnterMutex(&pcache1.grp);  while( (nReq<0 || nFree<nReq)   && (p=pcache1.grp.lru.pLruPrev)!=0   && p->isAnchor==0  ){  nFree += pcache1MemSize(p->page.pBuf);
#ifdef SQLITE_PCACHE_SEPARATE_HEADER
 nFree += sqlite3MemSize(p);
#endif
 assert( PAGE_IS_UNPINNED(p) );  pcache1PinPage(p);  pcache1RemoveFromHash(p, 1);  }  pcache1LeaveMutex(&pcache1.grp);  }  return nFree; }
#endif
#ifdef SQLITE_TEST
SQLITE_PRIVATE void sqlite3PcacheStats(  int *pnCurrent,  int *pnMax,  int *pnMin,  int *pnRecyclable ){  PgHdr1 *p;  int nRecyclable = 0;  for(p=pcache1.grp.lru.pLruNext; p && !p->isAnchor; p=p->pLruNext){  assert( PAGE_IS_UNPINNED(p) );  nRecyclable++;  }  *pnCurrent = pcache1.grp.nPurgeable;  *pnMax = (int)pcache1.grp.nMaxPage;  *pnMin = (int)pcache1.grp.nMinPage;  *pnRecyclable = nRecyclable; }
#endif
#define ROWSET_ALLOCATION_SIZE 1024
#define ROWSET_ENTRY_PER_CHUNK   ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))

struct RowSetEntry {  i64 v;  struct RowSetEntry *pRight;  struct RowSetEntry *pLeft; }; struct RowSetChunk {  struct RowSetChunk *pNextChunk;  struct RowSetEntry aEntry[ROWSET_ENTRY_PER_CHUNK]; }; struct RowSet {  struct RowSetChunk *pChunk;  sqlite3 *db;  struct RowSetEntry *pEntry;  struct RowSetEntry *pLast;  struct RowSetEntry *pFresh;  struct RowSetEntry *pForest;  u16 nFresh;  u16 rsFlags;  int iBatch; };
#define ROWSET_SORTED 0x01
#define ROWSET_NEXT 0x02
SQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3 *db){  RowSet *p = sqlite3DbMallocRawNN(db, sizeof(*p));  if( p ){  int N = sqlite3DbMallocSize(db, p);  p->pChunk = 0;  p->db = db;  p->pEntry = 0;  p->pLast = 0;  p->pForest = 0;  p->pFresh = (struct RowSetEntry*)(ROUND8(sizeof(*p)) + (char*)p);  p->nFresh = (u16)((N - ROUND8(sizeof(*p)))/sizeof(struct RowSetEntry));  p->rsFlags = ROWSET_SORTED;  p->iBatch = 0;  }  return p; } SQLITE_PRIVATE void sqlite3RowSetClear(void *pArg){  RowSet *p = (RowSet*)pArg;  struct RowSetChunk *pChunk, *pNextChunk;  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){  pNextChunk = pChunk->pNextChunk;  sqlite3DbFree(p->db, pChunk);  }  p->pChunk = 0;  p->nFresh = 0;  p->pEntry = 0;  p->pLast = 0;  p->pForest = 0;  p->rsFlags = ROWSET_SORTED; } SQLITE_PRIVATE void sqlite3RowSetDelete(void *pArg){  sqlite3RowSetClear(pArg);  sqlite3DbFree(((RowSet*)pArg)->db, pArg); } static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){  assert( p!=0 );  if( p->nFresh==0 ){  struct RowSetChunk *pNew;  pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));  if( pNew==0 ){  return 0;  }  pNew->pNextChunk = p->pChunk;  p->pChunk = pNew;  p->pFresh = pNew->aEntry;  p->nFresh = ROWSET_ENTRY_PER_CHUNK;  }  p->nFresh--;  return p->pFresh++; } SQLITE_PRIVATE void sqlite3RowSetInsert(RowSet *p, i64 rowid){  struct RowSetEntry *pEntry;  struct RowSetEntry *pLast;  assert( p!=0 && (p->rsFlags & ROWSET_NEXT)==0 );  pEntry = rowSetEntryAlloc(p);  if( pEntry==0 ) return;  pEntry->v = rowid;  pEntry->pRight = 0;  pLast = p->pLast;  if( pLast ){  if( rowid<=pLast->v ){  p->rsFlags &= ~ROWSET_SORTED;  }  pLast->pRight = pEntry;  }else{  p->pEntry = pEntry;  }  p->pLast = pEntry; } static struct RowSetEntry *rowSetEntryMerge(  struct RowSetEntry *pA,  struct RowSetEntry *pB ){  struct RowSetEntry head;  struct RowSetEntry *pTail;  pTail = &head;  assert( pA!=0 && pB!=0 );  for(;;){  assert( pA->pRight==0 || pA->v<=pA->pRight->v );  assert( pB->pRight==0 || pB->v<=pB->pRight->v );  if( pA->v<=pB->v ){  if( pA->v<pB->v ) pTail = pTail->pRight = pA;  pA = pA->pRight;  if( pA==0 ){  pTail->pRight = pB;  break;  }  }else{  pTail = pTail->pRight = pB;  pB = pB->pRight;  if( pB==0 ){  pTail->pRight = pA;  break;  }  }  }  return head.pRight; } static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){  unsigned int i;  struct RowSetEntry *pNext, *aBucket[40];  memset(aBucket, 0, sizeof(aBucket));  while( pIn ){  pNext = pIn->pRight;  pIn->pRight = 0;  for(i=0; aBucket[i]; i++){  pIn = rowSetEntryMerge(aBucket[i], pIn);  aBucket[i] = 0;  }  aBucket[i] = pIn;  pIn = pNext;  }  pIn = aBucket[0];  for(i=1; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){  if( aBucket[i]==0 ) continue;  pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];  }  return pIn; } static void rowSetTreeToList(  struct RowSetEntry *pIn,  struct RowSetEntry **ppFirst,  struct RowSetEntry **ppLast ){  assert( pIn!=0 );  if( pIn->pLeft ){  struct RowSetEntry *p;  rowSetTreeToList(pIn->pLeft, ppFirst, &p);  p->pRight = pIn;  }else{  *ppFirst = pIn;  }  if( pIn->pRight ){  rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);  }else{  *ppLast = pIn;  }  assert( (*ppLast)->pRight==0 ); } static struct RowSetEntry *rowSetNDeepTree(  struct RowSetEntry **ppList,  int iDepth ){  struct RowSetEntry *p;  struct RowSetEntry *pLeft;  if( *ppList==0 ){  return 0;  }  if( iDepth>1 ){  pLeft = rowSetNDeepTree(ppList, iDepth-1);  p = *ppList;  if( p==0 ){  return pLeft;  }  p->pLeft = pLeft;  *ppList = p->pRight;  p->pRight = rowSetNDeepTree(ppList, iDepth-1);  }else{  p = *ppList;  *ppList = p->pRight;  p->pLeft = p->pRight = 0;  }  return p; } static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){  int iDepth;  struct RowSetEntry *p;  struct RowSetEntry *pLeft;  assert( pList!=0 );  p = pList;  pList = p->pRight;  p->pLeft = p->pRight = 0;  for(iDepth=1; pList; iDepth++){  pLeft = p;  p = pList;  pList = p->pRight;  p->pLeft = pLeft;  p->pRight = rowSetNDeepTree(&pList, iDepth);  }  return p; } SQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid){  assert( p!=0 );  assert( p->pForest==0 );  if( (p->rsFlags & ROWSET_NEXT)==0 ){  if( (p->rsFlags & ROWSET_SORTED)==0 ){  p->pEntry = rowSetEntrySort(p->pEntry);  }  p->rsFlags |= ROWSET_SORTED|ROWSET_NEXT;  }  if( p->pEntry ){  *pRowid = p->pEntry->v;  p->pEntry = p->pEntry->pRight;  if( p->pEntry==0 ){  sqlite3RowSetClear(p);  }  return 1;  }else{  return 0;  } } SQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){  struct RowSetEntry *p, *pTree;  assert( pRowSet!=0 && (pRowSet->rsFlags & ROWSET_NEXT)==0 );  if( iBatch!=pRowSet->iBatch ){  p = pRowSet->pEntry;  if( p ){  struct RowSetEntry **ppPrevTree = &pRowSet->pForest;  if( (pRowSet->rsFlags & ROWSET_SORTED)==0 ){  p = rowSetEntrySort(p);  }  for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){  ppPrevTree = &pTree->pRight;  if( pTree->pLeft==0 ){  pTree->pLeft = rowSetListToTree(p);  break;  }else{  struct RowSetEntry *pAux, *pTail;  rowSetTreeToList(pTree->pLeft, &pAux, &pTail);  pTree->pLeft = 0;  p = rowSetEntryMerge(pAux, p);  }  }  if( pTree==0 ){  *ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);  if( pTree ){  pTree->v = 0;  pTree->pRight = 0;  pTree->pLeft = rowSetListToTree(p);  }  }  pRowSet->pEntry = 0;  pRowSet->pLast = 0;  pRowSet->rsFlags |= ROWSET_SORTED;  }  pRowSet->iBatch = iBatch;  }  for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){  p = pTree->pLeft;  while( p ){  if( p->v<iRowid ){  p = p->pRight;  }else if( p->v>iRowid ){  p = p->pLeft;  }else{  return 1;  }  }  }  return 0; }
#ifndef SQLITE_OMIT_DISKIO
#ifndef SQLITE_WAL_H
#define SQLITE_WAL_H
#define WAL_SYNC_FLAGS(X)  ((X)&0x03)
#define CKPT_SYNC_FLAGS(X) (((X)>>2)&0x03)
#ifdef SQLITE_OMIT_WAL
# define sqlite3WalOpen(x,y,z)  0
# define sqlite3WalLimit(x,y)
# define sqlite3WalClose(v,w,x,y,z) 0
# define sqlite3WalBeginReadTransaction(y,z)  0
# define sqlite3WalEndReadTransaction(z)
# define sqlite3WalDbsize(y)  0
# define sqlite3WalBeginWriteTransaction(y) 0
# define sqlite3WalEndWriteTransaction(x) 0
# define sqlite3WalUndo(x,y,z)  0
# define sqlite3WalSavepoint(y,z)
# define sqlite3WalSavepointUndo(y,z) 0
# define sqlite3WalFrames(u,v,w,x,y,z)  0
# define sqlite3WalCheckpoint(q,r,s,t,u,v,w,x,y,z) 0
# define sqlite3WalCallback(z)  0
# define sqlite3WalExclusiveMode(y,z) 0
# define sqlite3WalHeapMemory(z)  0
# define sqlite3WalFramesize(z) 0
# define sqlite3WalFindFrame(x,y,z) 0
# define sqlite3WalFile(x)  0
#else
#define WAL_SAVEPOINT_NDATA 4
typedef struct Wal Wal; SQLITE_PRIVATE int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *, int, i64, Wal**); SQLITE_PRIVATE int sqlite3WalClose(Wal *pWal, sqlite3*, int sync_flags, int, u8 *); SQLITE_PRIVATE void sqlite3WalLimit(Wal*, i64); SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *); SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal); SQLITE_PRIVATE int sqlite3WalFindFrame(Wal *, Pgno, u32 *); SQLITE_PRIVATE int sqlite3WalReadFrame(Wal *, u32, int, u8 *); SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal); SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal); SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal); SQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx); SQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData); SQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData); SQLITE_PRIVATE int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int); SQLITE_PRIVATE int sqlite3WalCheckpoint(  Wal *pWal,  sqlite3 *db,  int eMode,  int (*xBusy)(void*),  void *pBusyArg,  int sync_flags,  int nBuf,  u8 *zBuf,  int *pnLog,  int *pnCkpt ); SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal); SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op); SQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal);
#ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE int sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot); SQLITE_PRIVATE void sqlite3WalSnapshotOpen(Wal *pWal, sqlite3_snapshot *pSnapshot); SQLITE_PRIVATE int sqlite3WalSnapshotRecover(Wal *pWal); SQLITE_PRIVATE int sqlite3WalSnapshotCheck(Wal *pWal, sqlite3_snapshot *pSnapshot); SQLITE_PRIVATE void sqlite3WalSnapshotUnlock(Wal *pWal);
#endif
#ifdef SQLITE_ENABLE_ZIPVFS
SQLITE_PRIVATE int sqlite3WalFramesize(Wal *pWal);
#endif
SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal);
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
SQLITE_PRIVATE int sqlite3WalWriteLock(Wal *pWal, int bLock); SQLITE_PRIVATE void sqlite3WalDb(Wal *pWal, sqlite3 *db);
#endif
#endif
#endif
#if 0
int sqlite3PagerTrace=1;
#define sqlite3DebugPrintf printf
#define PAGERTRACE(X)  if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }
#else
#define PAGERTRACE(X)
#endif
#define PAGERID(p) (SQLITE_PTR_TO_INT(p->fd))
#define FILEHANDLEID(fd) (SQLITE_PTR_TO_INT(fd))
#define PAGER_OPEN 0
#define PAGER_READER 1
#define PAGER_WRITER_LOCKED  2
#define PAGER_WRITER_CACHEMOD  3
#define PAGER_WRITER_DBMOD 4
#define PAGER_WRITER_FINISHED  5
#define PAGER_ERROR  6
#define UNKNOWN_LOCK (EXCLUSIVE_LOCK+1)
#define MAX_SECTOR_SIZE 0x10000
typedef struct PagerSavepoint PagerSavepoint; struct PagerSavepoint {  i64 iOffset;  i64 iHdrOffset;  Bitvec *pInSavepoint;  Pgno nOrig;  Pgno iSubRec;  int bTruncateOnRelease;
#ifndef SQLITE_OMIT_WAL
 u32 aWalData[WAL_SAVEPOINT_NDATA];
#endif
};
#define SPILLFLAG_OFF  0x01
#define SPILLFLAG_ROLLBACK 0x02
#define SPILLFLAG_NOSYNC 0x04
struct Pager {  sqlite3_vfs *pVfs;  u8 exclusiveMode;  u8 journalMode;  u8 useJournal;  u8 noSync;  u8 fullSync;  u8 extraSync;  u8 syncFlags;  u8 walSyncFlags;  u8 tempFile;  u8 noLock;  u8 readOnly;  u8 memDb;  u8 memVfs;  u8 eState;  u8 eLock;  u8 changeCountDone;  u8 setSuper;  u8 doNotSpill;  u8 subjInMemory;  u8 bUseFetch;  u8 hasHeldSharedLock;  Pgno dbSize;  Pgno dbOrigSize;  Pgno dbFileSize;  Pgno dbHintSize;  int errCode;  int nRec;  u32 cksumInit;  u32 nSubRec;  Bitvec *pInJournal;  sqlite3_file *fd;  sqlite3_file *jfd;  sqlite3_file *sjfd;  i64 journalOff;  i64 journalHdr;  sqlite3_backup *pBackup;  PagerSavepoint *aSavepoint;  int nSavepoint;  u32 iDataVersion;  char dbFileVers[16];  int nMmapOut;  sqlite3_int64 szMmap;  PgHdr *pMmapFreelist;  u16 nExtra;  i16 nReserve;  u32 vfsFlags;  u32 sectorSize;  Pgno mxPgno;  i64 pageSize;  i64 journalSizeLimit;  char *zFilename;  char *zJournal;  int (*xBusyHandler)(void*);  void *pBusyHandlerArg;  int aStat[4];
#ifdef SQLITE_TEST
 int nRead;
#endif
 void (*xReiniter)(DbPage*);  int (*xGet)(Pager*,Pgno,DbPage**,int);  char *pTmpSpace;  PCache *pPCache;
#ifndef SQLITE_OMIT_WAL
 Wal *pWal;  char *zWal;
#endif
};
#define PAGER_STAT_HIT  0
#define PAGER_STAT_MISS 1
#define PAGER_STAT_WRITE 2
#define PAGER_STAT_SPILL 3
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_pager_readdb_count = 0; SQLITE_API int sqlite3_pager_writedb_count = 0; SQLITE_API int sqlite3_pager_writej_count = 0;
# define PAGER_INCR(v) v++
#else
# define PAGER_INCR(v)
#endif
static const unsigned char aJournalMagic[] = {  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7, };
#define JOURNAL_PG_SZ(pPager) ((pPager->pageSize) + 8)
#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)
#ifdef SQLITE_OMIT_MEMORYDB
# define MEMDB 0
#else
# define MEMDB pPager->memDb
#endif
#if SQLITE_MAX_MMAP_SIZE>0
# define USEFETCH(x) ((x)->bUseFetch)
#else
# define USEFETCH(x) 0
#endif
#define isOpen(pFd) ((pFd)->pMethods!=0)
#ifdef SQLITE_DIRECT_OVERFLOW_READ
SQLITE_PRIVATE int sqlite3PagerDirectReadOk(Pager *pPager, Pgno pgno){  if( pPager->fd->pMethods==0 ) return 0;  if( sqlite3PCacheIsDirty(pPager->pPCache) ) return 0;
#ifndef SQLITE_OMIT_WAL
 if( pPager->pWal ){  u32 iRead = 0;  int rc;  rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);  return (rc==SQLITE_OK && iRead==0);  }
#endif
 return 1; }
#endif
#ifndef SQLITE_OMIT_WAL
# define pagerUseWal(x) ((x)->pWal!=0)
#else
# define pagerUseWal(x) 0
# define pagerRollbackWal(x) 0
# define pagerWalFrames(v,w,x,y) 0
# define pagerOpenWalIfPresent(z) SQLITE_OK
# define pagerBeginReadTransaction(z) SQLITE_OK
#endif
#ifndef NDEBUG
static int assert_pager_state(Pager *p){  Pager *pPager = p;  assert( p->eState==PAGER_OPEN   || p->eState==PAGER_READER   || p->eState==PAGER_WRITER_LOCKED   || p->eState==PAGER_WRITER_CACHEMOD   || p->eState==PAGER_WRITER_DBMOD   || p->eState==PAGER_WRITER_FINISHED   || p->eState==PAGER_ERROR  );  assert( p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK );  assert( p->tempFile==0 || pPager->changeCountDone );  assert( p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal );  assert( p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) );  if( MEMDB ){  assert( !isOpen(p->fd) );  assert( p->noSync );  assert( p->journalMode==PAGER_JOURNALMODE_OFF   || p->journalMode==PAGER_JOURNALMODE_MEMORY  );  assert( p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN );  assert( pagerUseWal(p)==0 );  }  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );  assert( p->eLock!=PENDING_LOCK );  switch( p->eState ){  case PAGER_OPEN:  assert( !MEMDB );  assert( pPager->errCode==SQLITE_OK );  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );  break;  case PAGER_READER:  assert( pPager->errCode==SQLITE_OK );  assert( p->eLock!=UNKNOWN_LOCK );  assert( p->eLock>=SHARED_LOCK );  break;  case PAGER_WRITER_LOCKED:  assert( p->eLock!=UNKNOWN_LOCK );  assert( pPager->errCode==SQLITE_OK );  if( !pagerUseWal(pPager) ){  assert( p->eLock>=RESERVED_LOCK );  }  assert( pPager->dbSize==pPager->dbOrigSize );  assert( pPager->dbOrigSize==pPager->dbFileSize );  assert( pPager->dbOrigSize==pPager->dbHintSize );  assert( pPager->setSuper==0 );  break;  case PAGER_WRITER_CACHEMOD:  assert( p->eLock!=UNKNOWN_LOCK );  assert( pPager->errCode==SQLITE_OK );  if( !pagerUseWal(pPager) ){  assert( p->eLock>=RESERVED_LOCK );  assert( isOpen(p->jfd)   || p->journalMode==PAGER_JOURNALMODE_OFF   || p->journalMode==PAGER_JOURNALMODE_WAL  );  }  assert( pPager->dbOrigSize==pPager->dbFileSize );  assert( pPager->dbOrigSize==pPager->dbHintSize );  break;  case PAGER_WRITER_DBMOD:  assert( p->eLock==EXCLUSIVE_LOCK );  assert( pPager->errCode==SQLITE_OK );  assert( !pagerUseWal(pPager) );  assert( p->eLock>=EXCLUSIVE_LOCK );  assert( isOpen(p->jfd)   || p->journalMode==PAGER_JOURNALMODE_OFF   || p->journalMode==PAGER_JOURNALMODE_WAL   || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)  );  assert( pPager->dbOrigSize<=pPager->dbHintSize );  break;  case PAGER_WRITER_FINISHED:  assert( p->eLock==EXCLUSIVE_LOCK );  assert( pPager->errCode==SQLITE_OK );  assert( !pagerUseWal(pPager) );  assert( isOpen(p->jfd)   || p->journalMode==PAGER_JOURNALMODE_OFF   || p->journalMode==PAGER_JOURNALMODE_WAL   || (sqlite3OsDeviceCharacteristics(p->fd)&SQLITE_IOCAP_BATCH_ATOMIC)  );  break;  case PAGER_ERROR:  assert( pPager->errCode!=SQLITE_OK );  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 || pPager->tempFile );  break;  }  return 1; }
#endif
#ifdef SQLITE_DEBUG
char *print_pager_state(Pager *p){  static char zRet[1024];  sqlite3_snprintf(1024, zRet,  "Filename: %s\n"  "State:  %s errCode=%d\n"  "Lock: %s\n"  "Locking mode: locking_mode=%s\n"  "Journal mode: journal_mode=%s\n"  "Backing store: tempFile=%d memDb=%d useJournal=%d\n"  "Journal:  journalOff=%lld journalHdr=%lld\n"  "Size: dbsize=%d dbOrigSize=%d dbFileSize=%d\n"  , p->zFilename  , p->eState==PAGER_OPEN ? "OPEN" :  p->eState==PAGER_READER ? "READER" :  p->eState==PAGER_WRITER_LOCKED  ? "WRITER_LOCKED" :  p->eState==PAGER_WRITER_CACHEMOD ? "WRITER_CACHEMOD" :  p->eState==PAGER_WRITER_DBMOD ? "WRITER_DBMOD" :  p->eState==PAGER_WRITER_FINISHED ? "WRITER_FINISHED" :  p->eState==PAGER_ERROR  ? "ERROR" : "?error?"  , (int)p->errCode  , p->eLock==NO_LOCK  ? "NO_LOCK" :  p->eLock==RESERVED_LOCK  ? "RESERVED" :  p->eLock==EXCLUSIVE_LOCK ? "EXCLUSIVE" :  p->eLock==SHARED_LOCK  ? "SHARED" :  p->eLock==UNKNOWN_LOCK ? "UNKNOWN" : "?error?"  , p->exclusiveMode ? "exclusive" : "normal"  , p->journalMode==PAGER_JOURNALMODE_MEMORY  ? "memory" :  p->journalMode==PAGER_JOURNALMODE_OFF ? "off" :  p->journalMode==PAGER_JOURNALMODE_DELETE  ? "delete" :  p->journalMode==PAGER_JOURNALMODE_PERSIST ? "persist" :  p->journalMode==PAGER_JOURNALMODE_TRUNCATE ? "truncate" :  p->journalMode==PAGER_JOURNALMODE_WAL ? "wal" : "?error?"  , (int)p->tempFile, (int)p->memDb, (int)p->useJournal  , p->journalOff, p->journalHdr  , (int)p->dbSize, (int)p->dbOrigSize, (int)p->dbFileSize  );  return zRet; }
#endif
static int getPageNormal(Pager*,Pgno,DbPage**,int); static int getPageError(Pager*,Pgno,DbPage**,int);
#if SQLITE_MAX_MMAP_SIZE>0
static int getPageMMap(Pager*,Pgno,DbPage**,int);
#endif
static void setGetterMethod(Pager *pPager){  if( pPager->errCode ){  pPager->xGet = getPageError;
#if SQLITE_MAX_MMAP_SIZE>0
 }else if( USEFETCH(pPager) ){  pPager->xGet = getPageMMap;
#endif
 }else{  pPager->xGet = getPageNormal;  } } static int subjRequiresPage(PgHdr *pPg){  Pager *pPager = pPg->pPager;  PagerSavepoint *p;  Pgno pgno = pPg->pgno;  int i;  for(i=0; i<pPager->nSavepoint; i++){  p = &pPager->aSavepoint[i];  if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){  for(i=i+1; i<pPager->nSavepoint; i++){  pPager->aSavepoint[i].bTruncateOnRelease = 0;  }  return 1;  }  }  return 0; }
#ifdef SQLITE_DEBUG
static int pageInJournal(Pager *pPager, PgHdr *pPg){  return sqlite3BitvecTest(pPager->pInJournal, pPg->pgno); }
#endif
static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){  unsigned char ac[4];  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);  if( rc==SQLITE_OK ){  *pRes = sqlite3Get4byte(ac);  }  return rc; }
#define put32bits(A,B) sqlite3Put4byte((u8*)A,B)
static int write32bits(sqlite3_file *fd, i64 offset, u32 val){  char ac[4];  put32bits(ac, val);  return sqlite3OsWrite(fd, ac, 4, offset); } static int pagerUnlockDb(Pager *pPager, int eLock){  int rc = SQLITE_OK;  assert( !pPager->exclusiveMode || pPager->eLock==eLock );  assert( eLock==NO_LOCK || eLock==SHARED_LOCK );  assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );  if( isOpen(pPager->fd) ){  assert( pPager->eLock>=eLock );  rc = pPager->noLock ? SQLITE_OK : sqlite3OsUnlock(pPager->fd, eLock);  if( pPager->eLock!=UNKNOWN_LOCK ){  pPager->eLock = (u8)eLock;  }  IOTRACE(("UNLOCK %p %d\n", pPager, eLock))  }  pPager->changeCountDone = pPager->tempFile;  return rc; } static int pagerLockDb(Pager *pPager, int eLock){  int rc = SQLITE_OK;  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){  rc = pPager->noLock ? SQLITE_OK : sqlite3OsLock(pPager->fd, eLock);  if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){  pPager->eLock = (u8)eLock;  IOTRACE(("LOCK %p %d\n", pPager, eLock))  }  }  return rc; } static int jrnlBufferSize(Pager *pPager){  assert( !MEMDB );
#if defined(SQLITE_ENABLE_ATOMIC_WRITE)  || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)

 int dc;  assert( isOpen(pPager->fd) );  dc = sqlite3OsDeviceCharacteristics(pPager->fd);
#else
 UNUSED_PARAMETER(pPager);
#endif
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
 if( pPager->dbSize>0 && (dc&SQLITE_IOCAP_BATCH_ATOMIC) ){  return -1;  }
#endif
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
 {  int nSector = pPager->sectorSize;  int szPage = pPager->pageSize;  assert(SQLITE_IOCAP_ATOMIC512==(512>>8));  assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));  if( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){  return 0;  }  }  return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);
#endif
 return 0; }
#ifdef SQLITE_CHECK_PAGES
static u32 pager_datahash(int nByte, unsigned char *pData){  u32 hash = 0;  int i;  for(i=0; i<nByte; i++){  hash = (hash*1039) + pData[i];  }  return hash; } static u32 pager_pagehash(PgHdr *pPage){  return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData); } static void pager_set_pagehash(PgHdr *pPage){  pPage->pageHash = pager_pagehash(pPage); }
#define CHECK_PAGE(x) checkPage(x)
static void checkPage(PgHdr *pPg){  Pager *pPager = pPg->pPager;  assert( pPager->eState!=PAGER_ERROR );  assert( (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) ); }
#else
#define pager_datahash(X,Y) 0
#define pager_pagehash(X) 0
#define pager_set_pagehash(X)
#define CHECK_PAGE(x)
#endif
static int readSuperJournal(sqlite3_file *pJrnl, char *zSuper, u32 nSuper){  int rc;  u32 len;  i64 szJ;  u32 cksum;  u32 u;  unsigned char aMagic[8];  zSuper[0] = '\0';  if( SQLITE_OK!=(rc = sqlite3OsFileSize(pJrnl, &szJ))   || szJ<16   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-16, &len))   || len>=nSuper   || len>szJ-16   || len==0   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-12, &cksum))   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))   || memcmp(aMagic, aJournalMagic, 8)   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zSuper, len, szJ-16-len))  ){  return rc;  }  for(u=0; u<len; u++){  cksum -= zSuper[u];  }  if( cksum ){  len = 0;  }  zSuper[len] = '\0';  zSuper[len+1] = '\0';  return SQLITE_OK; } static i64 journalHdrOffset(Pager *pPager){  i64 offset = 0;  i64 c = pPager->journalOff;  if( c ){  offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);  }  assert( offset%JOURNAL_HDR_SZ(pPager)==0 );  assert( offset>=c );  assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );  return offset; } static int zeroJournalHdr(Pager *pPager, int doTruncate){  int rc = SQLITE_OK;  assert( isOpen(pPager->jfd) );  assert( !sqlite3JournalIsInMemory(pPager->jfd) );  if( pPager->journalOff ){  const i64 iLimit = pPager->journalSizeLimit;  IOTRACE(("JZEROHDR %p\n", pPager))  if( doTruncate || iLimit==0 ){  rc = sqlite3OsTruncate(pPager->jfd, 0);  }else{  static const char zeroHdr[28] = {0};  rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);  }  if( rc==SQLITE_OK && !pPager->noSync ){  rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);  }  if( rc==SQLITE_OK && iLimit>0 ){  i64 sz;  rc = sqlite3OsFileSize(pPager->jfd, &sz);  if( rc==SQLITE_OK && sz>iLimit ){  rc = sqlite3OsTruncate(pPager->jfd, iLimit);  }  }  }  return rc; } static int writeJournalHdr(Pager *pPager){  int rc = SQLITE_OK;  char *zHeader = pPager->pTmpSpace;  u32 nHeader = (u32)pPager->pageSize;  u32 nWrite;  int ii;  assert( isOpen(pPager->jfd) );  if( nHeader>JOURNAL_HDR_SZ(pPager) ){  nHeader = JOURNAL_HDR_SZ(pPager);  }  for(ii=0; ii<pPager->nSavepoint; ii++){  if( pPager->aSavepoint[ii].iHdrOffset==0 ){  pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;  }  }  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);  assert( isOpen(pPager->fd) || pPager->noSync );  if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)   || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND)  ){  memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));  put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);  }else{  memset(zHeader, 0, sizeof(aJournalMagic)+4);  }  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);  put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);  put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);  put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);  put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize);  memset(&zHeader[sizeof(aJournalMagic)+20], 0,   nHeader-(sizeof(aJournalMagic)+20));  for(nWrite=0; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){  IOTRACE(("JHDR %p %lld %d\n", pPager, pPager->journalHdr, nHeader))  rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);  assert( pPager->journalHdr <= pPager->journalOff );  pPager->journalOff += nHeader;  }  return rc; } static int readJournalHdr(  Pager *pPager,  int isHot,  i64 journalSize,  u32 *pNRec,  u32 *pDbSize ){  int rc;  unsigned char aMagic[8];  i64 iHdrOff;  assert( isOpen(pPager->jfd) );  pPager->journalOff = journalHdrOffset(pPager);  if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){  return SQLITE_DONE;  }  iHdrOff = pPager->journalOff;  if( isHot || iHdrOff!=pPager->journalHdr ){  rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);  if( rc ){  return rc;  }  if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){  return SQLITE_DONE;  }  }  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))  ){  return rc;  }  if( pPager->journalOff==0 ){  u32 iPageSize;  u32 iSectorSize;  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))  ){  return rc;  }  if( iPageSize==0 ){  iPageSize = pPager->pageSize;  }  if( iPageSize<512 || iSectorSize<32   || iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZE   || ((iPageSize-1)&iPageSize)!=0  || ((iSectorSize-1)&iSectorSize)!=0  ){  return SQLITE_DONE;  }  rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);  testcase( rc!=SQLITE_OK );  pPager->sectorSize = iSectorSize;  }  pPager->journalOff += JOURNAL_HDR_SZ(pPager);  return rc; } static int writeSuperJournal(Pager *pPager, const char *zSuper){  int rc;  int nSuper;  i64 iHdrOff;  i64 jrnlSize;  u32 cksum = 0;  assert( pPager->setSuper==0 );  assert( !pagerUseWal(pPager) );  if( !zSuper   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY   || !isOpen(pPager->jfd)  ){  return SQLITE_OK;  }  pPager->setSuper = 1;  assert( pPager->journalHdr <= pPager->journalOff );  for(nSuper=0; zSuper[nSuper]; nSuper++){  cksum += zSuper[nSuper];  }  if( pPager->fullSync ){  pPager->journalOff = journalHdrOffset(pPager);  }  iHdrOff = pPager->journalOff;  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zSuper, nSuper, iHdrOff+4)))   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper, nSuper)))   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nSuper+4, cksum)))   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,   iHdrOff+4+nSuper+8)))  ){  return rc;  }  pPager->journalOff += (nSuper+20);  if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))   && jrnlSize>pPager->journalOff  ){  rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);  }  return rc; } static void pager_reset(Pager *pPager){  pPager->iDataVersion++;  sqlite3BackupRestart(pPager->pBackup);  sqlite3PcacheClear(pPager->pPCache); } SQLITE_PRIVATE u32 sqlite3PagerDataVersion(Pager *pPager){  return pPager->iDataVersion; } static void releaseAllSavepoints(Pager *pPager){  int ii;  for(ii=0; ii<pPager->nSavepoint; ii++){  sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);  }  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){  sqlite3OsClose(pPager->sjfd);  }  sqlite3_free(pPager->aSavepoint);  pPager->aSavepoint = 0;  pPager->nSavepoint = 0;  pPager->nSubRec = 0; } static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){  int ii;  int rc = SQLITE_OK;  for(ii=0; ii<pPager->nSavepoint; ii++){  PagerSavepoint *p = &pPager->aSavepoint[ii];  if( pgno<=p->nOrig ){  rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);  testcase( rc==SQLITE_NOMEM );  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );  }  }  return rc; } static void pager_unlock(Pager *pPager){  assert( pPager->eState==PAGER_READER   || pPager->eState==PAGER_OPEN   || pPager->eState==PAGER_ERROR  );  sqlite3BitvecDestroy(pPager->pInJournal);  pPager->pInJournal = 0;  releaseAllSavepoints(pPager);  if( pagerUseWal(pPager) ){  assert( !isOpen(pPager->jfd) );  sqlite3WalEndReadTransaction(pPager->pWal);  pPager->eState = PAGER_OPEN;  }else if( !pPager->exclusiveMode ){  int rc;  int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;  assert( (PAGER_JOURNALMODE_MEMORY  & 5)!=1 );  assert( (PAGER_JOURNALMODE_OFF & 5)!=1 );  assert( (PAGER_JOURNALMODE_WAL & 5)!=1 );  assert( (PAGER_JOURNALMODE_DELETE  & 5)!=1 );  assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );  assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );  if( 0==(iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)   || 1!=(pPager->journalMode & 5)  ){  sqlite3OsClose(pPager->jfd);  }  rc = pagerUnlockDb(pPager, NO_LOCK);  if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){  pPager->eLock = UNKNOWN_LOCK;  }  assert( pPager->errCode || pPager->eState!=PAGER_ERROR );  pPager->eState = PAGER_OPEN;  }  assert( pPager->errCode==SQLITE_OK || !MEMDB );  if( pPager->errCode ){  if( pPager->tempFile==0 ){  pager_reset(pPager);  pPager->changeCountDone = 0;  pPager->eState = PAGER_OPEN;  }else{  pPager->eState = (isOpen(pPager->jfd) ? PAGER_OPEN : PAGER_READER);  }  if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);  pPager->errCode = SQLITE_OK;  setGetterMethod(pPager);  }  pPager->journalOff = 0;  pPager->journalHdr = 0;  pPager->setSuper = 0; } static int pager_error(Pager *pPager, int rc){  int rc2 = rc & 0xff;  assert( rc==SQLITE_OK || !MEMDB );  assert(   pPager->errCode==SQLITE_FULL ||   pPager->errCode==SQLITE_OK ||   (pPager->errCode & 0xff)==SQLITE_IOERR  );  if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){  pPager->errCode = rc;  pPager->eState = PAGER_ERROR;  setGetterMethod(pPager);  }  return rc; } static int pager_truncate(Pager *pPager, Pgno nPage); static int pagerFlushOnCommit(Pager *pPager, int bCommit){  if( pPager->tempFile==0 ) return 1;  if( !bCommit ) return 0;  if( !isOpen(pPager->fd) ) return 0;  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25); } static int pager_end_transaction(Pager *pPager, int hasSuper, int bCommit){  int rc = SQLITE_OK;  int rc2 = SQLITE_OK;  assert( assert_pager_state(pPager) );  assert( pPager->eState!=PAGER_ERROR );  if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){  return SQLITE_OK;  }  releaseAllSavepoints(pPager);  assert( isOpen(pPager->jfd) || pPager->pInJournal==0  || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_BATCH_ATOMIC)  );  if( isOpen(pPager->jfd) ){  assert( !pagerUseWal(pPager) );  if( sqlite3JournalIsInMemory(pPager->jfd) ){  sqlite3OsClose(pPager->jfd);  }else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){  if( pPager->journalOff==0 ){  rc = SQLITE_OK;  }else{  rc = sqlite3OsTruncate(pPager->jfd, 0);  if( rc==SQLITE_OK && pPager->fullSync ){  rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);  }  }  pPager->journalOff = 0;  }else if( pPager->journalMode==PAGER_JOURNALMODE_PERSIST  || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)  ){  rc = zeroJournalHdr(pPager, hasSuper||pPager->tempFile);  pPager->journalOff = 0;  }else{  int bDelete = !pPager->tempFile;  assert( sqlite3JournalIsInMemory(pPager->jfd)==0 );  assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY   || pPager->journalMode==PAGER_JOURNALMODE_WAL  );  sqlite3OsClose(pPager->jfd);  if( bDelete ){  rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);  }  }  }
#ifdef SQLITE_CHECK_PAGES
 sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);  if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){  PgHdr *p = sqlite3PagerLookup(pPager, 1);  if( p ){  p->pageHash = 0;  sqlite3PagerUnrefNotNull(p);  }  }
#endif
 sqlite3BitvecDestroy(pPager->pInJournal);  pPager->pInJournal = 0;  pPager->nRec = 0;  if( rc==SQLITE_OK ){  if( MEMDB || pagerFlushOnCommit(pPager, bCommit) ){  sqlite3PcacheCleanAll(pPager->pPCache);  }else{  sqlite3PcacheClearWritable(pPager->pPCache);  }  sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);  }  if( pagerUseWal(pPager) ){  rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);  assert( rc2==SQLITE_OK );  }else if( rc==SQLITE_OK && bCommit && pPager->dbFileSize>pPager->dbSize ){  assert( pPager->eLock==EXCLUSIVE_LOCK );  rc = pager_truncate(pPager, pPager->dbSize);  }  if( rc==SQLITE_OK && bCommit ){  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;  }  if( !pPager->exclusiveMode   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))  ){  rc2 = pagerUnlockDb(pPager, SHARED_LOCK);  }  pPager->eState = PAGER_READER;  pPager->setSuper = 0;  return (rc==SQLITE_OK?rc2:rc); } static void pagerUnlockAndRollback(Pager *pPager){  if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){  assert( assert_pager_state(pPager) );  if( pPager->eState>=PAGER_WRITER_LOCKED ){  sqlite3BeginBenignMalloc();  sqlite3PagerRollback(pPager);  sqlite3EndBenignMalloc();  }else if( !pPager->exclusiveMode ){  assert( pPager->eState==PAGER_READER );  pager_end_transaction(pPager, 0, 0);  }  }  pager_unlock(pPager); } static u32 pager_cksum(Pager *pPager, const u8 *aData){  u32 cksum = pPager->cksumInit;  int i = pPager->pageSize-200;  while( i>0 ){  cksum += aData[i];  i -= 200;  }  return cksum; } static int pager_playback_one_page(  Pager *pPager,  i64 *pOffset,  Bitvec *pDone,  int isMainJrnl,  int isSavepnt ){  int rc;  PgHdr *pPg;  Pgno pgno;  u32 cksum;  char *aData;  sqlite3_file *jfd;  int isSynced;  assert( (isMainJrnl&~1)==0 );  assert( (isSavepnt&~1)==0 );  assert( isMainJrnl || pDone );  assert( isSavepnt || pDone==0 );  aData = pPager->pTmpSpace;  assert( aData );  assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) );  assert( pPager->eState>=PAGER_WRITER_CACHEMOD   || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)  );  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;  rc = read32bits(jfd, *pOffset, &pgno);  if( rc!=SQLITE_OK ) return rc;  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);  if( rc!=SQLITE_OK ) return rc;  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;  if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){  assert( !isSavepnt );  return SQLITE_DONE;  }  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){  return SQLITE_OK;  }  if( isMainJrnl ){  rc = read32bits(jfd, (*pOffset)-4, &cksum);  if( rc ) return rc;  if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){  return SQLITE_DONE;  }  }  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=SQLITE_OK ){  return rc;  }  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){  pPager->nReserve = ((u8*)aData)[20];  }  if( pagerUseWal(pPager) ){  pPg = 0;  }else{  pPg = sqlite3PagerLookup(pPager, pgno);  }  assert( pPg || !MEMDB );  assert( pPager->eState!=PAGER_OPEN || pPg==0 || pPager->tempFile );  PAGERTRACE(("PLAYBACK %d page %d hash(%08x) %s\n",   PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),   (isMainJrnl?"main-journal":"sub-journal")  ));  if( isMainJrnl ){  isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);  }else{  isSynced = (pPg==0 || 0==(pPg->flags & PGHDR_NEED_SYNC));  }  if( isOpen(pPager->fd)   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)   && isSynced  ){  i64 ofst = (pgno-1)*(i64)pPager->pageSize;  testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );  assert( !pagerUseWal(pPager) );  rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);  if( pgno>pPager->dbFileSize ){  pPager->dbFileSize = pgno;  }  if( pPager->pBackup ){  sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);  }  }else if( !isMainJrnl && pPg==0 ){  assert( isSavepnt );  assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)==0 );  pPager->doNotSpill |= SPILLFLAG_ROLLBACK;  rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);  assert( (pPager->doNotSpill & SPILLFLAG_ROLLBACK)!=0 );  pPager->doNotSpill &= ~SPILLFLAG_ROLLBACK;  if( rc!=SQLITE_OK ) return rc;  sqlite3PcacheMakeDirty(pPg);  }  if( pPg ){  void *pData;  pData = pPg->pData;  memcpy(pData, (u8*)aData, pPager->pageSize);  pPager->xReiniter(pPg);  pager_set_pagehash(pPg);  if( pgno==1 ){  memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));  }  sqlite3PcacheRelease(pPg);  }  return rc; } static int pager_delsuper(Pager *pPager, const char *zSuper){  sqlite3_vfs *pVfs = pPager->pVfs;  int rc;  sqlite3_file *pSuper;  sqlite3_file *pJournal;  char *zSuperJournal = 0;  i64 nSuperJournal;  char *zJournal;  char *zSuperPtr;  char *zFree = 0;  int nSuperPtr;  pSuper = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);  if( !pSuper ){  rc = SQLITE_NOMEM_BKPT;  pJournal = 0;  }else{  const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);  rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, 0);  pJournal = (sqlite3_file *)(((u8 *)pSuper) + pVfs->szOsFile);  }  if( rc!=SQLITE_OK ) goto delsuper_out;  rc = sqlite3OsFileSize(pSuper, &nSuperJournal);  if( rc!=SQLITE_OK ) goto delsuper_out;  nSuperPtr = pVfs->mxPathname+1;  zFree = sqlite3Malloc(4 + nSuperJournal + nSuperPtr + 2);  if( !zFree ){  rc = SQLITE_NOMEM_BKPT;  goto delsuper_out;  }  zFree[0] = zFree[1] = zFree[2] = zFree[3] = 0;  zSuperJournal = &zFree[4];  zSuperPtr = &zSuperJournal[nSuperJournal+2];  rc = sqlite3OsRead(pSuper, zSuperJournal, (int)nSuperJournal, 0);  if( rc!=SQLITE_OK ) goto delsuper_out;  zSuperJournal[nSuperJournal] = 0;  zSuperJournal[nSuperJournal+1] = 0;  zJournal = zSuperJournal;  while( (zJournal-zSuperJournal)<nSuperJournal ){  int exists;  rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);  if( rc!=SQLITE_OK ){  goto delsuper_out;  }  if( exists ){  int c;  int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_SUPER_JOURNAL);  rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);  if( rc!=SQLITE_OK ){  goto delsuper_out;  }  rc = readSuperJournal(pJournal, zSuperPtr, nSuperPtr);  sqlite3OsClose(pJournal);  if( rc!=SQLITE_OK ){  goto delsuper_out;  }  c = zSuperPtr[0]!=0 && strcmp(zSuperPtr, zSuper)==0;  if( c ){  goto delsuper_out;  }  }  zJournal += (sqlite3Strlen30(zJournal)+1);  }  sqlite3OsClose(pSuper);  rc = sqlite3OsDelete(pVfs, zSuper, 0); delsuper_out:  sqlite3_free(zFree);  if( pSuper ){  sqlite3OsClose(pSuper);  assert( !isOpen(pJournal) );  sqlite3_free(pSuper);  }  return rc; } static int pager_truncate(Pager *pPager, Pgno nPage){  int rc = SQLITE_OK;  assert( pPager->eState!=PAGER_ERROR );  assert( pPager->eState!=PAGER_READER );  if( isOpen(pPager->fd)   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)  ){  i64 currentSize, newSize;  int szPage = pPager->pageSize;  assert( pPager->eLock==EXCLUSIVE_LOCK );  rc = sqlite3OsFileSize(pPager->fd, &currentSize);  newSize = szPage*(i64)nPage;  if( rc==SQLITE_OK && currentSize!=newSize ){  if( currentSize>newSize ){  rc = sqlite3OsTruncate(pPager->fd, newSize);  }else if( (currentSize+szPage)<=newSize ){  char *pTmp = pPager->pTmpSpace;  memset(pTmp, 0, szPage);  testcase( (newSize-szPage) == currentSize );  testcase( (newSize-szPage) > currentSize );  rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);  }  if( rc==SQLITE_OK ){  pPager->dbFileSize = nPage;  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *pFile){  int iRet = sqlite3OsSectorSize(pFile);  if( iRet<32 ){  iRet = 512;  }else if( iRet>MAX_SECTOR_SIZE ){  assert( MAX_SECTOR_SIZE>=512 );  iRet = MAX_SECTOR_SIZE;  }  return iRet; } static void setSectorSize(Pager *pPager){  assert( isOpen(pPager->fd) || pPager->tempFile );  if( pPager->tempFile   || (sqlite3OsDeviceCharacteristics(pPager->fd) &  SQLITE_IOCAP_POWERSAFE_OVERWRITE)!=0  ){  pPager->sectorSize = 512;  }else{  pPager->sectorSize = sqlite3SectorSize(pPager->fd);  } } static int pager_playback(Pager *pPager, int isHot){  sqlite3_vfs *pVfs = pPager->pVfs;  i64 szJ;  u32 nRec;  u32 u;  Pgno mxPg = 0;  int rc;  int res = 1;  char *zSuper = 0;  int needPagerReset;  int nPlayback = 0;  u32 savedPageSize = pPager->pageSize;  assert( isOpen(pPager->jfd) );  rc = sqlite3OsFileSize(pPager->jfd, &szJ);  if( rc!=SQLITE_OK ){  goto end_playback;  }  zSuper = pPager->pTmpSpace;  rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);  if( rc==SQLITE_OK && zSuper[0] ){  rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);  }  zSuper = 0;  if( rc!=SQLITE_OK || !res ){  goto end_playback;  }  pPager->journalOff = 0;  needPagerReset = isHot;  while( 1 ){  rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  }  goto end_playback;  }  if( nRec==0xffffffff ){  assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );  nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));  }  if( nRec==0 && !isHot &&  pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){  nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));  }  if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){  rc = pager_truncate(pPager, mxPg);  if( rc!=SQLITE_OK ){  goto end_playback;  }  pPager->dbSize = mxPg;  }  for(u=0; u<nRec; u++){  if( needPagerReset ){  pager_reset(pPager);  needPagerReset = 0;  }  rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);  if( rc==SQLITE_OK ){  nPlayback++;  }else{  if( rc==SQLITE_DONE ){  pPager->journalOff = szJ;  break;  }else if( rc==SQLITE_IOERR_SHORT_READ ){  rc = SQLITE_OK;  goto end_playback;  }else{  goto end_playback;  }  }  }  }  assert( 0 ); end_playback:  if( rc==SQLITE_OK ){  rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);  }
#ifdef SQLITE_DEBUG
 sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);
#endif
 pPager->changeCountDone = pPager->tempFile;  if( rc==SQLITE_OK ){  zSuper = &pPager->pTmpSpace[4];  rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);  testcase( rc!=SQLITE_OK );  }  if( rc==SQLITE_OK   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)  ){  rc = sqlite3PagerSync(pPager, 0);  }  if( rc==SQLITE_OK ){  rc = pager_end_transaction(pPager, zSuper[0]!='\0', 0);  testcase( rc!=SQLITE_OK );  }  if( rc==SQLITE_OK && zSuper[0] && res ){  assert( zSuper==&pPager->pTmpSpace[4] );  memset(&zSuper[-4], 0, 4);  rc = pager_delsuper(pPager, zSuper);  testcase( rc!=SQLITE_OK );  }  if( isHot && nPlayback ){  sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",  nPlayback, pPager->zJournal);  }  setSectorSize(pPager);  return rc; } static int readDbPage(PgHdr *pPg){  Pager *pPager = pPg->pPager;  int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_WAL
 u32 iFrame = 0;  assert( pPager->eState>=PAGER_READER && !MEMDB );  assert( isOpen(pPager->fd) );  if( pagerUseWal(pPager) ){  rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);  if( rc ) return rc;  }  if( iFrame ){  rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);  }else
#endif
 {  i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;  rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);  if( rc==SQLITE_IOERR_SHORT_READ ){  rc = SQLITE_OK;  }  }  if( pPg->pgno==1 ){  if( rc ){  memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));  }else{  u8 *dbFileVers = &((u8*)pPg->pData)[24];  memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));  }  }  PAGER_INCR(sqlite3_pager_readdb_count);  PAGER_INCR(pPager->nRead);  IOTRACE(("PGIN %p %d\n", pPager, pPg->pgno));  PAGERTRACE(("FETCH %d page %d hash(%08x)\n",   PAGERID(pPager), pPg->pgno, pager_pagehash(pPg)));  return rc; } static void pager_write_changecounter(PgHdr *pPg){  u32 change_counter;  if( NEVER(pPg==0) ) return;  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;  put32bits(((char*)pPg->pData)+24, change_counter);  put32bits(((char*)pPg->pData)+92, change_counter);  put32bits(((char*)pPg->pData)+96, SQLITE_VERSION_NUMBER); }
#ifndef SQLITE_OMIT_WAL
static int pagerUndoCallback(void *pCtx, Pgno iPg){  int rc = SQLITE_OK;  Pager *pPager = (Pager *)pCtx;  PgHdr *pPg;  assert( pagerUseWal(pPager) );  pPg = sqlite3PagerLookup(pPager, iPg);  if( pPg ){  if( sqlite3PcachePageRefcount(pPg)==1 ){  sqlite3PcacheDrop(pPg);  }else{  rc = readDbPage(pPg);  if( rc==SQLITE_OK ){  pPager->xReiniter(pPg);  }  sqlite3PagerUnrefNotNull(pPg);  }  }  sqlite3BackupRestart(pPager->pBackup);  return rc; } static int pagerRollbackWal(Pager *pPager){  int rc;  PgHdr *pList;  pPager->dbSize = pPager->dbOrigSize;  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);  pList = sqlite3PcacheDirtyList(pPager->pPCache);  while( pList && rc==SQLITE_OK ){  PgHdr *pNext = pList->pDirty;  rc = pagerUndoCallback((void *)pPager, pList->pgno);  pList = pNext;  }  return rc; } static int pagerWalFrames(  Pager *pPager,  PgHdr *pList,  Pgno nTruncate,  int isCommit ){  int rc;  int nList;  PgHdr *p;  assert( pPager->pWal );  assert( pList );
#ifdef SQLITE_DEBUG
 for(p=pList; p && p->pDirty; p=p->pDirty){  assert( p->pgno < p->pDirty->pgno );  }
#endif
 assert( pList->pDirty==0 || isCommit );  if( isCommit ){  PgHdr **ppNext = &pList;  nList = 0;  for(p=pList; (*ppNext = p)!=0; p=p->pDirty){  if( p->pgno<=nTruncate ){  ppNext = &p->pDirty;  nList++;  }  }  assert( pList );  }else{  nList = 1;  }  pPager->aStat[PAGER_STAT_WRITE] += nList;  if( pList->pgno==1 ) pager_write_changecounter(pList);  rc = sqlite3WalFrames(pPager->pWal,  pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags  );  if( rc==SQLITE_OK && pPager->pBackup ){  for(p=pList; p; p=p->pDirty){  sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);  }  }
#ifdef SQLITE_CHECK_PAGES
 pList = sqlite3PcacheDirtyList(pPager->pPCache);  for(p=pList; p; p=p->pDirty){  pager_set_pagehash(p);  }
#endif
 return rc; } static int pagerBeginReadTransaction(Pager *pPager){  int rc;  int changed = 0;  assert( pagerUseWal(pPager) );  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );  sqlite3WalEndReadTransaction(pPager->pWal);  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);  if( rc!=SQLITE_OK || changed ){  pager_reset(pPager);  if( USEFETCH(pPager) ) sqlite3OsUnfetch(pPager->fd, 0, 0);  }  return rc; }
#endif
static int pagerPagecount(Pager *pPager, Pgno *pnPage){  Pgno nPage;  assert( pPager->eState==PAGER_OPEN );  assert( pPager->eLock>=SHARED_LOCK );  assert( isOpen(pPager->fd) );  assert( pPager->tempFile==0 );  nPage = sqlite3WalDbsize(pPager->pWal);  if( nPage==0 && ALWAYS(isOpen(pPager->fd)) ){  i64 n = 0;  int rc = sqlite3OsFileSize(pPager->fd, &n);  if( rc!=SQLITE_OK ){  return rc;  }  nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);  }  if( nPage>pPager->mxPgno ){  pPager->mxPgno = (Pgno)nPage;  }  *pnPage = nPage;  return SQLITE_OK; }
#ifndef SQLITE_OMIT_WAL
static int pagerOpenWalIfPresent(Pager *pPager){  int rc = SQLITE_OK;  assert( pPager->eState==PAGER_OPEN );  assert( pPager->eLock>=SHARED_LOCK );  if( !pPager->tempFile ){  int isWal;  rc = sqlite3OsAccess(  pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal  );  if( rc==SQLITE_OK ){  if( isWal ){  Pgno nPage;  rc = pagerPagecount(pPager, &nPage);  if( rc ) return rc;  if( nPage==0 ){  rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);  }else{  testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );  rc = sqlite3PagerOpenWal(pPager, 0);  }  }else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){  pPager->journalMode = PAGER_JOURNALMODE_DELETE;  }  }  }  return rc; }
#endif
static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){  i64 szJ;  i64 iHdrOff;  int rc = SQLITE_OK;  Bitvec *pDone = 0;  assert( pPager->eState!=PAGER_ERROR );  assert( pPager->eState>=PAGER_WRITER_LOCKED );  if( pSavepoint ){  pDone = sqlite3BitvecCreate(pSavepoint->nOrig);  if( !pDone ){  return SQLITE_NOMEM_BKPT;  }  }  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;  pPager->changeCountDone = pPager->tempFile;  if( !pSavepoint && pagerUseWal(pPager) ){  return pagerRollbackWal(pPager);  }  szJ = pPager->journalOff;  assert( pagerUseWal(pPager)==0 || szJ==0 );  if( pSavepoint && !pagerUseWal(pPager) ){  iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;  pPager->journalOff = pSavepoint->iOffset;  while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){  rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);  }  assert( rc!=SQLITE_DONE );  }else{  pPager->journalOff = 0;  }  while( rc==SQLITE_OK && pPager->journalOff<szJ ){  u32 ii;  u32 nJRec = 0;  u32 dummy;  rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);  assert( rc!=SQLITE_DONE );  if( nJRec==0   && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff  ){  nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));  }  for(ii=0; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){  rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);  }  assert( rc!=SQLITE_DONE );  }  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );  if( pSavepoint ){  u32 ii;  i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);  if( pagerUseWal(pPager) ){  rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);  }  for(ii=pSavepoint->iSubRec; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){  assert( offset==(i64)ii*(4+pPager->pageSize) );  rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);  }  assert( rc!=SQLITE_DONE );  }  sqlite3BitvecDestroy(pDone);  if( rc==SQLITE_OK ){  pPager->journalOff = szJ;  }  return rc; } SQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage); } SQLITE_PRIVATE int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage); } static void pagerFixMaplimit(Pager *pPager){
#if SQLITE_MAX_MMAP_SIZE>0
 sqlite3_file *fd = pPager->fd;  if( isOpen(fd) && fd->pMethods->iVersion>=3 ){  sqlite3_int64 sz;  sz = pPager->szMmap;  pPager->bUseFetch = (sz>0);  setGetterMethod(pPager);  sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_MMAP_SIZE, &sz);  }
#endif
} SQLITE_PRIVATE void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){  pPager->szMmap = szMmap;  pagerFixMaplimit(pPager); } SQLITE_PRIVATE void sqlite3PagerShrink(Pager *pPager){  sqlite3PcacheShrink(pPager->pPCache); }
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
SQLITE_PRIVATE void sqlite3PagerSetFlags(  Pager *pPager,  unsigned pgFlags ){  unsigned level = pgFlags & PAGER_SYNCHRONOUS_MASK;  if( pPager->tempFile ){  pPager->noSync = 1;  pPager->fullSync = 0;  pPager->extraSync = 0;  }else{  pPager->noSync = level==PAGER_SYNCHRONOUS_OFF ?1:0;  pPager->fullSync = level>=PAGER_SYNCHRONOUS_FULL ?1:0;  pPager->extraSync = level==PAGER_SYNCHRONOUS_EXTRA ?1:0;  }  if( pPager->noSync ){  pPager->syncFlags = 0;  }else if( pgFlags & PAGER_FULLFSYNC ){  pPager->syncFlags = SQLITE_SYNC_FULL;  }else{  pPager->syncFlags = SQLITE_SYNC_NORMAL;  }  pPager->walSyncFlags = (pPager->syncFlags<<2);  if( pPager->fullSync ){  pPager->walSyncFlags |= pPager->syncFlags;  }  if( (pgFlags & PAGER_CKPT_FULLFSYNC) && !pPager->noSync ){  pPager->walSyncFlags |= (SQLITE_SYNC_FULL<<2);  }  if( pgFlags & PAGER_CACHESPILL ){  pPager->doNotSpill &= ~SPILLFLAG_OFF;  }else{  pPager->doNotSpill |= SPILLFLAG_OFF;  } }
#endif
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_opentemp_count = 0;
#endif
static int pagerOpentemp(  Pager *pPager,  sqlite3_file *pFile,  int vfsFlags ){  int rc;
#ifdef SQLITE_TEST
 sqlite3_opentemp_count++;
#endif
 vfsFlags |= SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |  SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);  assert( rc!=SQLITE_OK || isOpen(pFile) );  return rc; } SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(  Pager *pPager,  int (*xBusyHandler)(void *),  void *pBusyHandlerArg ){  void **ap;  pPager->xBusyHandler = xBusyHandler;  pPager->pBusyHandlerArg = pBusyHandlerArg;  ap = (void **)&pPager->xBusyHandler;  assert( ((int(*)(void *))(ap[0]))==xBusyHandler );  assert( ap[1]==pBusyHandlerArg );  sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap); } SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){  int rc = SQLITE_OK;  u32 pageSize = *pPageSize;  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );  if( (pPager->memDb==0 || pPager->dbSize==0)   && sqlite3PcacheRefCount(pPager->pPCache)==0   && pageSize && pageSize!=(u32)pPager->pageSize  ){  char *pNew = NULL;  i64 nByte = 0;  if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){  rc = sqlite3OsFileSize(pPager->fd, &nByte);  }  if( rc==SQLITE_OK ){  pNew = (char *)sqlite3PageMalloc(pageSize+8);  if( !pNew ){  rc = SQLITE_NOMEM_BKPT;  }else{  memset(pNew+pageSize, 0, 8);  }  }  if( rc==SQLITE_OK ){  pager_reset(pPager);  rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);  }  if( rc==SQLITE_OK ){  sqlite3PageFree(pPager->pTmpSpace);  pPager->pTmpSpace = pNew;  pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);  pPager->pageSize = pageSize;  }else{  sqlite3PageFree(pNew);  }  }  *pPageSize = pPager->pageSize;  if( rc==SQLITE_OK ){  if( nReserve<0 ) nReserve = pPager->nReserve;  assert( nReserve>=0 && nReserve<1000 );  pPager->nReserve = (i16)nReserve;  pagerFixMaplimit(pPager);  }  return rc; } SQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager *pPager){  return pPager->pTmpSpace; } SQLITE_PRIVATE Pgno sqlite3PagerMaxPageCount(Pager *pPager, Pgno mxPage){  if( mxPage>0 ){  pPager->mxPgno = mxPage;  }  assert( pPager->eState!=PAGER_OPEN );  return pPager->mxPgno; }
#ifdef SQLITE_TEST
SQLITE_API extern int sqlite3_io_error_pending; SQLITE_API extern int sqlite3_io_error_hit; static int saved_cnt; void disable_simulated_io_errors(void){  saved_cnt = sqlite3_io_error_pending;  sqlite3_io_error_pending = -1; } void enable_simulated_io_errors(void){  sqlite3_io_error_pending = saved_cnt; }
#else
# define disable_simulated_io_errors()
# define enable_simulated_io_errors()
#endif
SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){  int rc = SQLITE_OK;  memset(pDest, 0, N);  assert( isOpen(pPager->fd) || pPager->tempFile );  assert( !pagerUseWal(pPager) );  if( isOpen(pPager->fd) ){  IOTRACE(("DBHDR %p 0 %d\n", pPager, N))  rc = sqlite3OsRead(pPager->fd, pDest, N, 0);  if( rc==SQLITE_IOERR_SHORT_READ ){  rc = SQLITE_OK;  }  }  return rc; } SQLITE_PRIVATE void sqlite3PagerPagecount(Pager *pPager, int *pnPage){  assert( pPager->eState>=PAGER_READER );  assert( pPager->eState!=PAGER_WRITER_FINISHED );  *pnPage = (int)pPager->dbSize; } static int pager_wait_on_lock(Pager *pPager, int locktype){  int rc;  assert( (pPager->eLock>=locktype)   || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)   || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)  );  do {  rc = pagerLockDb(pPager, locktype);  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );  return rc; }
#if defined(SQLITE_DEBUG)
static void assertTruncateConstraintCb(PgHdr *pPg){  assert( pPg->flags&PGHDR_DIRTY );  assert( pPg->pgno<=pPg->pPager->dbSize || !subjRequiresPage(pPg) ); } static void assertTruncateConstraint(Pager *pPager){  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb); }
#else
# define assertTruncateConstraint(pPager)
#endif
SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){  assert( pPager->dbSize>=nPage || CORRUPT_DB );  testcase( pPager->dbSize<nPage );  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );  pPager->dbSize = nPage; } static int pagerSyncHotJournal(Pager *pPager){  int rc = SQLITE_OK;  if( !pPager->noSync ){  rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);  }  if( rc==SQLITE_OK ){  rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);  }  return rc; }
#if SQLITE_MAX_MMAP_SIZE>0
static int pagerAcquireMapPage(  Pager *pPager,  Pgno pgno,  void *pData,  PgHdr **ppPage ){  PgHdr *p;  if( pPager->pMmapFreelist ){  *ppPage = p = pPager->pMmapFreelist;  pPager->pMmapFreelist = p->pDirty;  p->pDirty = 0;  assert( pPager->nExtra>=8 );  memset(p->pExtra, 0, 8);  }else{  *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);  if( p==0 ){  sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);  return SQLITE_NOMEM_BKPT;  }  p->pExtra = (void *)&p[1];  p->flags = PGHDR_MMAP;  p->nRef = 1;  p->pPager = pPager;  }  assert( p->pExtra==(void *)&p[1] );  assert( p->pPage==0 );  assert( p->flags==PGHDR_MMAP );  assert( p->pPager==pPager );  assert( p->nRef==1 );  p->pgno = pgno;  p->pData = pData;  pPager->nMmapOut++;  return SQLITE_OK; }
#endif
static void pagerReleaseMapPage(PgHdr *pPg){  Pager *pPager = pPg->pPager;  pPager->nMmapOut--;  pPg->pDirty = pPager->pMmapFreelist;  pPager->pMmapFreelist = pPg;  assert( pPager->fd->pMethods->iVersion>=3 );  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData); } static void pagerFreeMapHdrs(Pager *pPager){  PgHdr *p;  PgHdr *pNext;  for(p=pPager->pMmapFreelist; p; p=pNext){  pNext = p->pDirty;  sqlite3_free(p);  } } static int databaseIsUnmoved(Pager *pPager){  int bHasMoved = 0;  int rc;  if( pPager->tempFile ) return SQLITE_OK;  if( pPager->dbSize==0 ) return SQLITE_OK;  assert( pPager->zFilename && pPager->zFilename[0] );  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);  if( rc==SQLITE_NOTFOUND ){  rc = SQLITE_OK;  }else if( rc==SQLITE_OK && bHasMoved ){  rc = SQLITE_READONLY_DBMOVED;  }  return rc; } SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3 *db){  u8 *pTmp = (u8*)pPager->pTmpSpace;  assert( db || pagerUseWal(pPager)==0 );  assert( assert_pager_state(pPager) );  disable_simulated_io_errors();  sqlite3BeginBenignMalloc();  pagerFreeMapHdrs(pPager);  pPager->exclusiveMode = 0;
#ifndef SQLITE_OMIT_WAL
 {  u8 *a = 0;  assert( db || pPager->pWal==0 );  if( db && 0==(db->flags & SQLITE_NoCkptOnClose)   && SQLITE_OK==databaseIsUnmoved(pPager)  ){  a = pTmp;  }  sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);  pPager->pWal = 0;  }
#endif
 pager_reset(pPager);  if( MEMDB ){  pager_unlock(pPager);  }else{  if( isOpen(pPager->jfd) ){  pager_error(pPager, pagerSyncHotJournal(pPager));  }  pagerUnlockAndRollback(pPager);  }  sqlite3EndBenignMalloc();  enable_simulated_io_errors();  PAGERTRACE(("CLOSE %d\n", PAGERID(pPager)));  IOTRACE(("CLOSE %p\n", pPager))  sqlite3OsClose(pPager->jfd);  sqlite3OsClose(pPager->fd);  sqlite3PageFree(pTmp);  sqlite3PcacheClose(pPager->pPCache);  assert( !pPager->aSavepoint && !pPager->pInJournal );  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) );  sqlite3_free(pPager);  return SQLITE_OK; }
#if !defined(NDEBUG) || defined(SQLITE_TEST)
SQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage *pPg){  return pPg->pgno; }
#endif
SQLITE_PRIVATE void sqlite3PagerRef(DbPage *pPg){  sqlite3PcacheRef(pPg); } static int syncJournal(Pager *pPager, int newHdr){  int rc;  assert( pPager->eState==PAGER_WRITER_CACHEMOD   || pPager->eState==PAGER_WRITER_DBMOD  );  assert( assert_pager_state(pPager) );  assert( !pagerUseWal(pPager) );  rc = sqlite3PagerExclusiveLock(pPager);  if( rc!=SQLITE_OK ) return rc;  if( !pPager->noSync ){  assert( !pPager->tempFile );  if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){  const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);  assert( isOpen(pPager->jfd) );  if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){  i64 iNextHdrOffset;  u8 aMagic[8];  u8 zHeader[sizeof(aJournalMagic)+4];  memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));  put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);  iNextHdrOffset = journalHdrOffset(pPager);  rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);  if( rc==SQLITE_OK && 0==memcmp(aMagic, aJournalMagic, 8) ){  static const u8 zerobyte = 0;  rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);  }  if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){  return rc;  }  if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){  PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));  IOTRACE(("JSYNC %p\n", pPager))  rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);  if( rc!=SQLITE_OK ) return rc;  }  IOTRACE(("JHDR %p %lld\n", pPager, pPager->journalHdr));  rc = sqlite3OsWrite(  pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr  );  if( rc!=SQLITE_OK ) return rc;  }  if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){  PAGERTRACE(("SYNC journal of %d\n", PAGERID(pPager)));  IOTRACE(("JSYNC %p\n", pPager))  rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags|  (pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)  );  if( rc!=SQLITE_OK ) return rc;  }  pPager->journalHdr = pPager->journalOff;  if( newHdr && 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){  pPager->nRec = 0;  rc = writeJournalHdr(pPager);  if( rc!=SQLITE_OK ) return rc;  }  }else{  pPager->journalHdr = pPager->journalOff;  }  }  sqlite3PcacheClearSyncFlags(pPager->pPCache);  pPager->eState = PAGER_WRITER_DBMOD;  assert( assert_pager_state(pPager) );  return SQLITE_OK; } static int pager_write_pagelist(Pager *pPager, PgHdr *pList){  int rc = SQLITE_OK;  assert( !pagerUseWal(pPager) );  assert( pPager->tempFile || pPager->eState==PAGER_WRITER_DBMOD );  assert( pPager->eLock==EXCLUSIVE_LOCK );  assert( isOpen(pPager->fd) || pList->pDirty==0 );  if( !isOpen(pPager->fd) ){  assert( pPager->tempFile && rc==SQLITE_OK );  rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);  }  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );  if( rc==SQLITE_OK   && pPager->dbHintSize<pPager->dbSize   && (pList->pDirty || pList->pgno>pPager->dbHintSize)  ){  sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;  sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);  pPager->dbHintSize = pPager->dbSize;  }  while( rc==SQLITE_OK && pList ){  Pgno pgno = pList->pgno;  if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){  i64 offset = (pgno-1)*(i64)pPager->pageSize;  char *pData;  assert( (pList->flags&PGHDR_NEED_SYNC)==0 );  if( pList->pgno==1 ) pager_write_changecounter(pList);  pData = pList->pData;  rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);  if( pgno==1 ){  memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));  }  if( pgno>pPager->dbFileSize ){  pPager->dbFileSize = pgno;  }  pPager->aStat[PAGER_STAT_WRITE]++;  sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);  PAGERTRACE(("STORE %d page %d hash(%08x)\n",   PAGERID(pPager), pgno, pager_pagehash(pList)));  IOTRACE(("PGOUT %p %d\n", pPager, pgno));  PAGER_INCR(sqlite3_pager_writedb_count);  }else{  PAGERTRACE(("NOSTORE %d page %d\n", PAGERID(pPager), pgno));  }  pager_set_pagehash(pList);  pList = pList->pDirty;  }  return rc; } static int openSubJournal(Pager *pPager){  int rc = SQLITE_OK;  if( !isOpen(pPager->sjfd) ){  const int flags = SQLITE_OPEN_SUBJOURNAL | SQLITE_OPEN_READWRITE  | SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE  | SQLITE_OPEN_DELETEONCLOSE;  int nStmtSpill = sqlite3Config.nStmtSpill;  if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){  nStmtSpill = -1;  }  rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);  }  return rc; } static int subjournalPage(PgHdr *pPg){  int rc = SQLITE_OK;  Pager *pPager = pPg->pPager;  if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){  assert( pPager->useJournal );  assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );  assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );  assert( pagerUseWal(pPager)   || pageInJournal(pPager, pPg)   || pPg->pgno>pPager->dbOrigSize  );  rc = openSubJournal(pPager);  if( rc==SQLITE_OK ){  void *pData = pPg->pData;  i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);  char *pData2;  pData2 = pData;  PAGERTRACE(("STMT-JOURNAL %d page %d\n", PAGERID(pPager), pPg->pgno));  rc = write32bits(pPager->sjfd, offset, pPg->pgno);  if( rc==SQLITE_OK ){  rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);  }  }  }  if( rc==SQLITE_OK ){  pPager->nSubRec++;  assert( pPager->nSavepoint>0 );  rc = addToSavepointBitvecs(pPager, pPg->pgno);  }  return rc; } static int subjournalPageIfRequired(PgHdr *pPg){  if( subjRequiresPage(pPg) ){  return subjournalPage(pPg);  }else{  return SQLITE_OK;  } } static int pagerStress(void *p, PgHdr *pPg){  Pager *pPager = (Pager *)p;  int rc = SQLITE_OK;  assert( pPg->pPager==pPager );  assert( pPg->flags&PGHDR_DIRTY );  if( NEVER(pPager->errCode) ) return SQLITE_OK;  testcase( pPager->doNotSpill & SPILLFLAG_ROLLBACK );  testcase( pPager->doNotSpill & SPILLFLAG_OFF );  testcase( pPager->doNotSpill & SPILLFLAG_NOSYNC );  if( pPager->doNotSpill   && ((pPager->doNotSpill & (SPILLFLAG_ROLLBACK|SPILLFLAG_OFF))!=0  || (pPg->flags & PGHDR_NEED_SYNC)!=0)  ){  return SQLITE_OK;  }  pPager->aStat[PAGER_STAT_SPILL]++;  pPg->pDirty = 0;  if( pagerUseWal(pPager) ){  rc = subjournalPageIfRequired(pPg);  if( rc==SQLITE_OK ){  rc = pagerWalFrames(pPager, pPg, 0, 0);  }  }else{
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
 if( pPager->tempFile==0 ){  rc = sqlite3JournalCreate(pPager->jfd);  if( rc!=SQLITE_OK ) return pager_error(pPager, rc);  }
#endif
 if( pPg->flags&PGHDR_NEED_SYNC   || pPager->eState==PAGER_WRITER_CACHEMOD  ){  rc = syncJournal(pPager, 1);  }  if( rc==SQLITE_OK ){  assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );  rc = pager_write_pagelist(pPager, pPg);  }  }  if( rc==SQLITE_OK ){  PAGERTRACE(("STRESS %d page %d\n", PAGERID(pPager), pPg->pgno));  sqlite3PcacheMakeClean(pPg);  }  return pager_error(pPager, rc); } SQLITE_PRIVATE int sqlite3PagerFlush(Pager *pPager){  int rc = pPager->errCode;  if( !MEMDB ){  PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);  assert( assert_pager_state(pPager) );  while( rc==SQLITE_OK && pList ){  PgHdr *pNext = pList->pDirty;  if( pList->nRef==0 ){  rc = pagerStress((void*)pPager, pList);  }  pList = pNext;  }  }  return rc; } SQLITE_PRIVATE int sqlite3PagerOpen(  sqlite3_vfs *pVfs,  Pager **ppPager,  const char *zFilename,  int nExtra,  int flags,  int vfsFlags,  void (*xReinit)(DbPage*) ){  u8 *pPtr;  Pager *pPager = 0;  int rc = SQLITE_OK;  int tempFile = 0;  int memDb = 0;
#ifndef SQLITE_OMIT_DESERIALIZE
 int memJM = 0;
#else
# define memJM 0
#endif
 int readOnly = 0;  int journalFileSize;  char *zPathname = 0;  int nPathname = 0;  int useJournal = (flags & PAGER_OMIT_JOURNAL)==0;  int pcacheSize = sqlite3PcacheSize();  u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  const char *zUri = 0;  int nUriByte = 1;  int nUri = 0;  journalFileSize = ROUND8(sqlite3JournalSize(pVfs));  *ppPager = 0;
#ifndef SQLITE_OMIT_MEMORYDB
 if( flags & PAGER_MEMORY ){  memDb = 1;  if( zFilename && zFilename[0] ){  zPathname = sqlite3DbStrDup(0, zFilename);  if( zPathname==0 ) return SQLITE_NOMEM_BKPT;  nPathname = sqlite3Strlen30(zPathname);  zFilename = 0;  }  }
#endif
 if( zFilename && zFilename[0] ){  const char *z;  nPathname = pVfs->mxPathname+1;  zPathname = sqlite3DbMallocRaw(0, nPathname*2);  if( zPathname==0 ){  return SQLITE_NOMEM_BKPT;  }  zPathname[0] = 0;  rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_OK_SYMLINK ){  if( vfsFlags & SQLITE_OPEN_NOFOLLOW ){  rc = SQLITE_CANTOPEN_SYMLINK;  }else{  rc = SQLITE_OK;  }  }  }  nPathname = sqlite3Strlen30(zPathname);  z = zUri = &zFilename[sqlite3Strlen30(zFilename)+1];  while( *z ){  z += strlen(z)+1;  z += strlen(z)+1;  nUri++;  }  nUriByte = (int)(&z[1] - zUri);  assert( nUriByte>=1 );  if( rc==SQLITE_OK && nPathname+8>pVfs->mxPathname ){  rc = SQLITE_CANTOPEN_BKPT;  }  if( rc!=SQLITE_OK ){  sqlite3DbFree(0, zPathname);  return rc;  }  }  pPtr = (u8 *)sqlite3MallocZero(  ROUND8(sizeof(*pPager)) +  ROUND8(pcacheSize) +  ROUND8(pVfs->szOsFile) +  journalFileSize * 2 +  sizeof(pPager) +  4 +  nPathname + 1 +  nUriByte +  nPathname + 8 + 1 +
#ifndef SQLITE_OMIT_WAL
 nPathname + 4 + 1 +
#endif
 3  );  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) );  if( !pPtr ){  sqlite3DbFree(0, zPathname);  return SQLITE_NOMEM_BKPT;  }  pPager = (Pager*)pPtr; pPtr += ROUND8(sizeof(*pPager));  pPager->pPCache = (PCache*)pPtr; pPtr += ROUND8(pcacheSize);  pPager->fd = (sqlite3_file*)pPtr;  pPtr += ROUND8(pVfs->szOsFile);  pPager->sjfd = (sqlite3_file*)pPtr;  pPtr += journalFileSize;  pPager->jfd = (sqlite3_file*)pPtr;  pPtr += journalFileSize;  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );  memcpy(pPtr, &pPager, sizeof(pPager)); pPtr += sizeof(pPager);  pPtr += 4;  pPager->zFilename = (char*)pPtr;  if( nPathname>0 ){  memcpy(pPtr, zPathname, nPathname);  pPtr += nPathname + 1;  if( zUri ){  memcpy(pPtr, zUri, nUriByte);  pPtr += nUriByte;  }else{  pPtr++;  }  }  if( nPathname>0 ){  pPager->zJournal = (char*)pPtr;  memcpy(pPtr, zPathname, nPathname);  pPtr += nPathname;  memcpy(pPtr, "-journal",8);  pPtr += 8 + 1;
#ifdef SQLITE_ENABLE_8_3_NAMES
 sqlite3FileSuffix3(zFilename,pPager->zJournal);  pPtr = (u8*)(pPager->zJournal + sqlite3Strlen30(pPager->zJournal)+1);
#endif
 }else{  pPager->zJournal = 0;  }
#ifndef SQLITE_OMIT_WAL
 if( nPathname>0 ){  pPager->zWal = (char*)pPtr;  memcpy(pPtr, zPathname, nPathname);  pPtr += nPathname;  memcpy(pPtr, "-wal", 4); pPtr += 4 + 1;
#ifdef SQLITE_ENABLE_8_3_NAMES
 sqlite3FileSuffix3(zFilename, pPager->zWal);  pPtr = (u8*)(pPager->zWal + sqlite3Strlen30(pPager->zWal)+1);
#endif
 }else{  pPager->zWal = 0;  }
#endif
 (void)pPtr;  if( nPathname ) sqlite3DbFree(0, zPathname);  pPager->pVfs = pVfs;  pPager->vfsFlags = vfsFlags;  if( zFilename && zFilename[0] ){  int fout = 0;  rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);  assert( !memDb );
#ifndef SQLITE_OMIT_DESERIALIZE
 pPager->memVfs = memJM = (fout&SQLITE_OPEN_MEMORY)!=0;
#endif
 readOnly = (fout&SQLITE_OPEN_READONLY)!=0;  if( rc==SQLITE_OK ){  int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);  if( !readOnly ){  setSectorSize(pPager);  assert(SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE);  if( szPageDflt<pPager->sectorSize ){  if( pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE ){  szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;  }else{  szPageDflt = (u32)pPager->sectorSize;  }  }
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
 {  int ii;  assert(SQLITE_IOCAP_ATOMIC512==(512>>8));  assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));  assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);  for(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){  if( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ){  szPageDflt = ii;  }  }  }
#endif
 }  pPager->noLock = sqlite3_uri_boolean(pPager->zFilename, "nolock", 0);  if( (iDc & SQLITE_IOCAP_IMMUTABLE)!=0   || sqlite3_uri_boolean(pPager->zFilename, "immutable", 0) ){  vfsFlags |= SQLITE_OPEN_READONLY;  goto act_like_temp_file;  }  }  }else{ act_like_temp_file:  tempFile = 1;  pPager->eState = PAGER_READER;  pPager->eLock = EXCLUSIVE_LOCK;  pPager->noLock = 1;  readOnly = (vfsFlags&SQLITE_OPEN_READONLY);  }  if( rc==SQLITE_OK ){  assert( pPager->memDb==0 );  rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);  testcase( rc!=SQLITE_OK );  }  if( rc==SQLITE_OK ){  nExtra = ROUND8(nExtra);  assert( nExtra>=8 && nExtra<1000 );  rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,   !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);  }  if( rc!=SQLITE_OK ){  sqlite3OsClose(pPager->fd);  sqlite3PageFree(pPager->pTmpSpace);  sqlite3_free(pPager);  return rc;  }  PAGERTRACE(("OPEN %d %s\n", FILEHANDLEID(pPager->fd), pPager->zFilename));  IOTRACE(("OPEN %p %s\n", pPager, pPager->zFilename))  pPager->useJournal = (u8)useJournal;  pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;  pPager->tempFile = (u8)tempFile;  assert( tempFile==PAGER_LOCKINGMODE_NORMAL  || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE );  assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );  pPager->exclusiveMode = (u8)tempFile;  pPager->changeCountDone = pPager->tempFile;  pPager->memDb = (u8)memDb;  pPager->readOnly = (u8)readOnly;  assert( useJournal || pPager->tempFile );  pPager->noSync = pPager->tempFile;  if( pPager->noSync ){  assert( pPager->fullSync==0 );  assert( pPager->extraSync==0 );  assert( pPager->syncFlags==0 );  assert( pPager->walSyncFlags==0 );  }else{  pPager->fullSync = 1;  pPager->extraSync = 0;  pPager->syncFlags = SQLITE_SYNC_NORMAL;  pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);  }  pPager->nExtra = (u16)nExtra;  pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;  assert( isOpen(pPager->fd) || tempFile );  setSectorSize(pPager);  if( !useJournal ){  pPager->journalMode = PAGER_JOURNALMODE_OFF;  }else if( memDb || memJM ){  pPager->journalMode = PAGER_JOURNALMODE_MEMORY;  }  pPager->xReiniter = xReinit;  setGetterMethod(pPager);  *ppPager = pPager;  return SQLITE_OK; } SQLITE_API sqlite3_file *sqlite3_database_file_object(const char *zName){  Pager *pPager;  while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){  zName--;  }  pPager = *(Pager**)(zName - 4 - sizeof(Pager*));  return pPager->fd; } static int hasHotJournal(Pager *pPager, int *pExists){  sqlite3_vfs * const pVfs = pPager->pVfs;  int rc = SQLITE_OK;  int exists = 1;  int jrnlOpen = !!isOpen(pPager->jfd);  assert( pPager->useJournal );  assert( isOpen(pPager->fd) );  assert( pPager->eState==PAGER_OPEN );  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &  SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  ));  *pExists = 0;  if( !jrnlOpen ){  rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);  }  if( rc==SQLITE_OK && exists ){  int locked = 0;  rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);  if( rc==SQLITE_OK && !locked ){  Pgno nPage;  assert( pPager->tempFile==0 );  rc = pagerPagecount(pPager, &nPage);  if( rc==SQLITE_OK ){  if( nPage==0 && !jrnlOpen ){  sqlite3BeginBenignMalloc();  if( pagerLockDb(pPager, RESERVED_LOCK)==SQLITE_OK ){  sqlite3OsDelete(pVfs, pPager->zJournal, 0);  if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);  }  sqlite3EndBenignMalloc();  }else{  if( !jrnlOpen ){  int f = SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL;  rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);  }  if( rc==SQLITE_OK ){  u8 first = 0;  rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);  if( rc==SQLITE_IOERR_SHORT_READ ){  rc = SQLITE_OK;  }  if( !jrnlOpen ){  sqlite3OsClose(pPager->jfd);  }  *pExists = (first!=0);  }else if( rc==SQLITE_CANTOPEN ){  *pExists = 1;  rc = SQLITE_OK;  }  }  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){  int rc = SQLITE_OK;  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );  assert( assert_pager_state(pPager) );  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );  assert( pPager->errCode==SQLITE_OK );  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){  int bHotJournal = 1;  assert( !MEMDB );  assert( pPager->tempFile==0 || pPager->eLock==EXCLUSIVE_LOCK );  rc = pager_wait_on_lock(pPager, SHARED_LOCK);  if( rc!=SQLITE_OK ){  assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );  goto failed;  }  if( pPager->eLock<=SHARED_LOCK ){  rc = hasHotJournal(pPager, &bHotJournal);  }  if( rc!=SQLITE_OK ){  goto failed;  }  if( bHotJournal ){  if( pPager->readOnly ){  rc = SQLITE_READONLY_ROLLBACK;  goto failed;  }  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);  if( rc!=SQLITE_OK ){  goto failed;  }  if( !isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){  sqlite3_vfs * const pVfs = pPager->pVfs;  int bExists;  rc = sqlite3OsAccess(  pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);  if( rc==SQLITE_OK && bExists ){  int fout = 0;  int f = SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_JOURNAL;  assert( !pPager->tempFile );  rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);  assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );  if( rc==SQLITE_OK && fout&SQLITE_OPEN_READONLY ){  rc = SQLITE_CANTOPEN_BKPT;  sqlite3OsClose(pPager->jfd);  }  }  }  if( isOpen(pPager->jfd) ){  assert( rc==SQLITE_OK );  rc = pagerSyncHotJournal(pPager);  if( rc==SQLITE_OK ){  rc = pager_playback(pPager, !pPager->tempFile);  pPager->eState = PAGER_OPEN;  }  }else if( !pPager->exclusiveMode ){  pagerUnlockDb(pPager, SHARED_LOCK);  }  if( rc!=SQLITE_OK ){  pager_error(pPager, rc);  goto failed;  }  assert( pPager->eState==PAGER_OPEN );  assert( (pPager->eLock==SHARED_LOCK)   || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)  );  }  if( !pPager->tempFile && pPager->hasHeldSharedLock ){  char dbFileVers[sizeof(pPager->dbFileVers)];  IOTRACE(("CKVERS %p %d\n", pPager, sizeof(dbFileVers)));  rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);  if( rc!=SQLITE_OK ){  if( rc!=SQLITE_IOERR_SHORT_READ ){  goto failed;  }  memset(dbFileVers, 0, sizeof(dbFileVers));  }  if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){  pager_reset(pPager);  if( USEFETCH(pPager) ){  sqlite3OsUnfetch(pPager->fd, 0, 0);  }  }  }  rc = pagerOpenWalIfPresent(pPager);
#ifndef SQLITE_OMIT_WAL
 assert( pPager->pWal==0 || rc==SQLITE_OK );
#endif
 }  if( pagerUseWal(pPager) ){  assert( rc==SQLITE_OK );  rc = pagerBeginReadTransaction(pPager);  }  if( pPager->tempFile==0 && pPager->eState==PAGER_OPEN && rc==SQLITE_OK ){  rc = pagerPagecount(pPager, &pPager->dbSize);  }  failed:  if( rc!=SQLITE_OK ){  assert( !MEMDB );  pager_unlock(pPager);  assert( pPager->eState==PAGER_OPEN );  }else{  pPager->eState = PAGER_READER;  pPager->hasHeldSharedLock = 1;  }  return rc; } static void pagerUnlockIfUnused(Pager *pPager){  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){  assert( pPager->nMmapOut==0 );  pagerUnlockAndRollback(pPager);  } } static int getPageNormal(  Pager *pPager,  Pgno pgno,  DbPage **ppPage,  int flags ){  int rc = SQLITE_OK;  PgHdr *pPg;  u8 noContent;  sqlite3_pcache_page *pBase;  assert( pPager->errCode==SQLITE_OK );  assert( pPager->eState>=PAGER_READER );  assert( assert_pager_state(pPager) );  assert( pPager->hasHeldSharedLock==1 );  if( pgno==0 ) return SQLITE_CORRUPT_BKPT;  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);  if( pBase==0 ){  pPg = 0;  rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);  if( rc!=SQLITE_OK ) goto pager_acquire_err;  if( pBase==0 ){  rc = SQLITE_NOMEM_BKPT;  goto pager_acquire_err;  }  }  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);  assert( pPg==(*ppPage) );  assert( pPg->pgno==pgno );  assert( pPg->pPager==pPager || pPg->pPager==0 );  noContent = (flags & PAGER_GET_NOCONTENT)!=0;  if( pPg->pPager && !noContent ){  assert( pgno!=PAGER_MJ_PGNO(pPager) );  pPager->aStat[PAGER_STAT_HIT]++;  return SQLITE_OK;  }else{  if( pgno==PAGER_MJ_PGNO(pPager) ){  rc = SQLITE_CORRUPT_BKPT;  goto pager_acquire_err;  }  pPg->pPager = pPager;  assert( !isOpen(pPager->fd) || !MEMDB );  if( !isOpen(pPager->fd) || pPager->dbSize<pgno || noContent ){  if( pgno>pPager->mxPgno ){  rc = SQLITE_FULL;  goto pager_acquire_err;  }  if( noContent ){  sqlite3BeginBenignMalloc();  if( pgno<=pPager->dbOrigSize ){  TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);  testcase( rc==SQLITE_NOMEM );  }  TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);  testcase( rc==SQLITE_NOMEM );  sqlite3EndBenignMalloc();  }  memset(pPg->pData, 0, pPager->pageSize);  IOTRACE(("ZERO %p %d\n", pPager, pgno));  }else{  assert( pPg->pPager==pPager );  pPager->aStat[PAGER_STAT_MISS]++;  rc = readDbPage(pPg);  if( rc!=SQLITE_OK ){  goto pager_acquire_err;  }  }  pager_set_pagehash(pPg);  }  return SQLITE_OK; pager_acquire_err:  assert( rc!=SQLITE_OK );  if( pPg ){  sqlite3PcacheDrop(pPg);  }  pagerUnlockIfUnused(pPager);  *ppPage = 0;  return rc; }
#if SQLITE_MAX_MMAP_SIZE>0
static int getPageMMap(  Pager *pPager,  Pgno pgno,  DbPage **ppPage,  int flags ){  int rc = SQLITE_OK;  PgHdr *pPg = 0;  u32 iFrame = 0;  const int bMmapOk = (pgno>1   && (pPager->eState==PAGER_READER || (flags & PAGER_GET_READONLY))  );  assert( USEFETCH(pPager) );  if( pgno<=1 && pgno==0 ){  return SQLITE_CORRUPT_BKPT;  }  assert( pPager->eState>=PAGER_READER );  assert( assert_pager_state(pPager) );  assert( pPager->hasHeldSharedLock==1 );  assert( pPager->errCode==SQLITE_OK );  if( bMmapOk && pagerUseWal(pPager) ){  rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);  if( rc!=SQLITE_OK ){  *ppPage = 0;  return rc;  }  }  if( bMmapOk && iFrame==0 ){  void *pData = 0;  rc = sqlite3OsFetch(pPager->fd,  (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData  );  if( rc==SQLITE_OK && pData ){  if( pPager->eState>PAGER_READER || pPager->tempFile ){  pPg = sqlite3PagerLookup(pPager, pgno);  }  if( pPg==0 ){  rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);  }else{  sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);  }  if( pPg ){  assert( rc==SQLITE_OK );  *ppPage = pPg;  return SQLITE_OK;  }  }  if( rc!=SQLITE_OK ){  *ppPage = 0;  return rc;  }  }  return getPageNormal(pPager, pgno, ppPage, flags); }
#endif
static int getPageError(  Pager *pPager,  Pgno pgno,  DbPage **ppPage,  int flags ){  UNUSED_PARAMETER(pgno);  UNUSED_PARAMETER(flags);  assert( pPager->errCode!=SQLITE_OK );  *ppPage = 0;  return pPager->errCode; } SQLITE_PRIVATE int sqlite3PagerGet(  Pager *pPager,  Pgno pgno,  DbPage **ppPage,  int flags ){  return pPager->xGet(pPager, pgno, ppPage, flags); } SQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){  sqlite3_pcache_page *pPage;  assert( pPager!=0 );  assert( pgno!=0 );  assert( pPager->pPCache!=0 );  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);  assert( pPage==0 || pPager->hasHeldSharedLock );  if( pPage==0 ) return 0;  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage); } SQLITE_PRIVATE void sqlite3PagerUnrefNotNull(DbPage *pPg){  TESTONLY( Pager *pPager = pPg->pPager; )  assert( pPg!=0 );  if( pPg->flags & PGHDR_MMAP ){  assert( pPg->pgno!=1 );  pagerReleaseMapPage(pPg);  }else{  sqlite3PcacheRelease(pPg);  }  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 ); } SQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){  if( pPg ) sqlite3PagerUnrefNotNull(pPg); } SQLITE_PRIVATE void sqlite3PagerUnrefPageOne(DbPage *pPg){  Pager *pPager;  assert( pPg!=0 );  assert( pPg->pgno==1 );  assert( (pPg->flags & PGHDR_MMAP)==0 );  pPager = pPg->pPager;  sqlite3PcacheRelease(pPg);  pagerUnlockIfUnused(pPager); } static int pager_open_journal(Pager *pPager){  int rc = SQLITE_OK;  sqlite3_vfs * const pVfs = pPager->pVfs;  assert( pPager->eState==PAGER_WRITER_LOCKED );  assert( assert_pager_state(pPager) );  assert( pPager->pInJournal==0 );  if( NEVER(pPager->errCode) ) return pPager->errCode;  if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){  pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);  if( pPager->pInJournal==0 ){  return SQLITE_NOMEM_BKPT;  }  if( !isOpen(pPager->jfd) ){  if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){  sqlite3MemJournalOpen(pPager->jfd);  }else{  int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE;  int nSpill;  if( pPager->tempFile ){  flags |= (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL);  nSpill = sqlite3Config.nStmtSpill;  }else{  flags |= SQLITE_OPEN_MAIN_JOURNAL;  nSpill = jrnlBufferSize(pPager);  }  rc = databaseIsUnmoved(pPager);  if( rc==SQLITE_OK ){  rc = sqlite3JournalOpen (  pVfs, pPager->zJournal, pPager->jfd, flags, nSpill  );  }  }  assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );  }  if( rc==SQLITE_OK ){  pPager->nRec = 0;  pPager->journalOff = 0;  pPager->setSuper = 0;  pPager->journalHdr = 0;  rc = writeJournalHdr(pPager);  }  }  if( rc!=SQLITE_OK ){  sqlite3BitvecDestroy(pPager->pInJournal);  pPager->pInJournal = 0;  }else{  assert( pPager->eState==PAGER_WRITER_LOCKED );  pPager->eState = PAGER_WRITER_CACHEMOD;  }  return rc; } SQLITE_PRIVATE int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){  int rc = SQLITE_OK;  if( pPager->errCode ) return pPager->errCode;  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );  pPager->subjInMemory = (u8)subjInMemory;  if( pPager->eState==PAGER_READER ){  assert( pPager->pInJournal==0 );  if( pagerUseWal(pPager) ){  if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);  if( rc!=SQLITE_OK ){  return rc;  }  (void)sqlite3WalExclusiveMode(pPager->pWal, 1);  }  rc = sqlite3WalBeginWriteTransaction(pPager->pWal);  }else{  rc = pagerLockDb(pPager, RESERVED_LOCK);  if( rc==SQLITE_OK && exFlag ){  rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);  }  }  if( rc==SQLITE_OK ){  pPager->eState = PAGER_WRITER_LOCKED;  pPager->dbHintSize = pPager->dbSize;  pPager->dbFileSize = pPager->dbSize;  pPager->dbOrigSize = pPager->dbSize;  pPager->journalOff = 0;  }  assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );  assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );  assert( assert_pager_state(pPager) );  }  PAGERTRACE(("TRANSACTION %d\n", PAGERID(pPager)));  return rc; } static SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){  Pager *pPager = pPg->pPager;  int rc;  u32 cksum;  char *pData2;  i64 iOff = pPager->journalOff;  assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) );  assert( pPager->journalHdr<=pPager->journalOff );  pData2 = pPg->pData;  cksum = pager_cksum(pPager, (u8*)pData2);  pPg->flags |= PGHDR_NEED_SYNC;  rc = write32bits(pPager->jfd, iOff, pPg->pgno);  if( rc!=SQLITE_OK ) return rc;  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);  if( rc!=SQLITE_OK ) return rc;  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);  if( rc!=SQLITE_OK ) return rc;  IOTRACE(("JOUT %p %d %lld %d\n", pPager, pPg->pgno,   pPager->journalOff, pPager->pageSize));  PAGER_INCR(sqlite3_pager_writej_count);  PAGERTRACE(("JOURNAL %d page %d needSync=%d hash(%08x)\n",   PAGERID(pPager), pPg->pgno,   ((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg)));  pPager->journalOff += 8 + pPager->pageSize;  pPager->nRec++;  assert( pPager->pInJournal!=0 );  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);  testcase( rc==SQLITE_NOMEM );  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );  rc |= addToSavepointBitvecs(pPager, pPg->pgno);  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );  return rc; } static int pager_write(PgHdr *pPg){  Pager *pPager = pPg->pPager;  int rc = SQLITE_OK;  assert( pPager->eState==PAGER_WRITER_LOCKED   || pPager->eState==PAGER_WRITER_CACHEMOD   || pPager->eState==PAGER_WRITER_DBMOD  );  assert( assert_pager_state(pPager) );  assert( pPager->errCode==0 );  assert( pPager->readOnly==0 );  CHECK_PAGE(pPg);  if( pPager->eState==PAGER_WRITER_LOCKED ){  rc = pager_open_journal(pPager);  if( rc!=SQLITE_OK ) return rc;  }  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );  assert( assert_pager_state(pPager) );  sqlite3PcacheMakeDirty(pPg);  assert( (pPager->pInJournal!=0) == isOpen(pPager->jfd) );  if( pPager->pInJournal!=0   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0  ){  assert( pagerUseWal(pPager)==0 );  if( pPg->pgno<=pPager->dbOrigSize ){  rc = pagerAddPageToRollbackJournal(pPg);  if( rc!=SQLITE_OK ){  return rc;  }  }else{  if( pPager->eState!=PAGER_WRITER_DBMOD ){  pPg->flags |= PGHDR_NEED_SYNC;  }  PAGERTRACE(("APPEND %d page %d needSync=%d\n",  PAGERID(pPager), pPg->pgno,   ((pPg->flags&PGHDR_NEED_SYNC)?1:0)));  }  }  pPg->flags |= PGHDR_WRITEABLE;  if( pPager->nSavepoint>0 ){  rc = subjournalPageIfRequired(pPg);  }  if( pPager->dbSize<pPg->pgno ){  pPager->dbSize = pPg->pgno;  }  return rc; } static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){  int rc = SQLITE_OK;  Pgno nPageCount;  Pgno pg1;  int nPage = 0;  int ii;  int needSync = 0;  Pager *pPager = pPg->pPager;  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);  assert( !MEMDB );  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)==0 );  pPager->doNotSpill |= SPILLFLAG_NOSYNC;  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;  nPageCount = pPager->dbSize;  if( pPg->pgno>nPageCount ){  nPage = (pPg->pgno - pg1)+1;  }else if( (pg1+nPagePerSector-1)>nPageCount ){  nPage = nPageCount+1-pg1;  }else{  nPage = nPagePerSector;  }  assert(nPage>0);  assert(pg1<=pPg->pgno);  assert((pg1+nPage)>pPg->pgno);  for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){  Pgno pg = pg1+ii;  PgHdr *pPage;  if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){  if( pg!=PAGER_MJ_PGNO(pPager) ){  rc = sqlite3PagerGet(pPager, pg, &pPage, 0);  if( rc==SQLITE_OK ){  rc = pager_write(pPage);  if( pPage->flags&PGHDR_NEED_SYNC ){  needSync = 1;  }  sqlite3PagerUnrefNotNull(pPage);  }  }  }else if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){  if( pPage->flags&PGHDR_NEED_SYNC ){  needSync = 1;  }  sqlite3PagerUnrefNotNull(pPage);  }  }  if( rc==SQLITE_OK && needSync ){  assert( !MEMDB );  for(ii=0; ii<nPage; ii++){  PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);  if( pPage ){  pPage->flags |= PGHDR_NEED_SYNC;  sqlite3PagerUnrefNotNull(pPage);  }  }  }  assert( (pPager->doNotSpill & SPILLFLAG_NOSYNC)!=0 );  pPager->doNotSpill &= ~SPILLFLAG_NOSYNC;  return rc; } SQLITE_PRIVATE int sqlite3PagerWrite(PgHdr *pPg){  Pager *pPager = pPg->pPager;  assert( (pPg->flags & PGHDR_MMAP)==0 );  assert( pPager->eState>=PAGER_WRITER_LOCKED );  assert( assert_pager_state(pPager) );  if( (pPg->flags & PGHDR_WRITEABLE)!=0 && pPager->dbSize>=pPg->pgno ){  if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);  return SQLITE_OK;  }else if( pPager->errCode ){  return pPager->errCode;  }else if( pPager->sectorSize > (u32)pPager->pageSize ){  assert( pPager->tempFile==0 );  return pagerWriteLargeSector(pPg);  }else{  return pager_write(pPg);  } }
#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage *pPg){  return pPg->flags & PGHDR_WRITEABLE; }
#endif
SQLITE_PRIVATE void sqlite3PagerDontWrite(PgHdr *pPg){  Pager *pPager = pPg->pPager;  if( !pPager->tempFile && (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){  PAGERTRACE(("DONT_WRITE page %d of %d\n", pPg->pgno, PAGERID(pPager)));  IOTRACE(("CLEAN %p %d\n", pPager, pPg->pgno))  pPg->flags |= PGHDR_DONT_WRITE;  pPg->flags &= ~PGHDR_WRITEABLE;  testcase( pPg->flags & PGHDR_NEED_SYNC );  pager_set_pagehash(pPg);  } } static int pager_incr_changecounter(Pager *pPager, int isDirectMode){  int rc = SQLITE_OK;  assert( pPager->eState==PAGER_WRITER_CACHEMOD   || pPager->eState==PAGER_WRITER_DBMOD  );  assert( assert_pager_state(pPager) );
#ifndef SQLITE_ENABLE_ATOMIC_WRITE
# define DIRECT_MODE 0
 assert( isDirectMode==0 );  UNUSED_PARAMETER(isDirectMode);
#else
# define DIRECT_MODE isDirectMode
#endif
 if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){  PgHdr *pPgHdr;  assert( !pPager->tempFile && isOpen(pPager->fd) );  rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);  assert( pPgHdr==0 || rc==SQLITE_OK );  if( !DIRECT_MODE && ALWAYS(rc==SQLITE_OK) ){  rc = sqlite3PagerWrite(pPgHdr);  }  if( rc==SQLITE_OK ){  pager_write_changecounter(pPgHdr);  if( DIRECT_MODE ){  const void *zBuf;  assert( pPager->dbFileSize>0 );  zBuf = pPgHdr->pData;  if( rc==SQLITE_OK ){  rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);  pPager->aStat[PAGER_STAT_WRITE]++;  }  if( rc==SQLITE_OK ){  const void *pCopy = (const void *)&((const char *)zBuf)[24];  memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));  pPager->changeCountDone = 1;  }  }else{  pPager->changeCountDone = 1;  }  }  sqlite3PagerUnref(pPgHdr);  }  return rc; } SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zSuper){  int rc = SQLITE_OK;  void *pArg = (void*)zSuper;  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;  if( rc==SQLITE_OK && !pPager->noSync ){  assert( !MEMDB );  rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);  }  return rc; } SQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager *pPager){  int rc = pPager->errCode;  assert( assert_pager_state(pPager) );  if( rc==SQLITE_OK ){  assert( pPager->eState==PAGER_WRITER_CACHEMOD   || pPager->eState==PAGER_WRITER_DBMOD   || pPager->eState==PAGER_WRITER_LOCKED  );  assert( assert_pager_state(pPager) );  if( 0==pagerUseWal(pPager) ){  rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);  }  }  return rc; } SQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(  Pager *pPager,  const char *zSuper,  int noSync ){  int rc = SQLITE_OK;  assert( pPager->eState==PAGER_WRITER_LOCKED   || pPager->eState==PAGER_WRITER_CACHEMOD   || pPager->eState==PAGER_WRITER_DBMOD   || pPager->eState==PAGER_ERROR  );  assert( assert_pager_state(pPager) );  if( NEVER(pPager->errCode) ) return pPager->errCode;  if( sqlite3FaultSim(400) ) return SQLITE_IOERR;  PAGERTRACE(("DATABASE SYNC: File=%s zSuper=%s nSize=%d\n",  pPager->zFilename, zSuper, pPager->dbSize));  if( pPager->eState<PAGER_WRITER_CACHEMOD ) return SQLITE_OK;  assert( MEMDB==0 || pPager->tempFile );  assert( isOpen(pPager->fd) || pPager->tempFile );  if( 0==pagerFlushOnCommit(pPager, 1) ){  sqlite3BackupRestart(pPager->pBackup);  }else{  PgHdr *pList;  if( pagerUseWal(pPager) ){  PgHdr *pPageOne = 0;  pList = sqlite3PcacheDirtyList(pPager->pPCache);  if( pList==0 ){  rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);  pList = pPageOne;  pList->pDirty = 0;  }  assert( rc==SQLITE_OK );  if( ALWAYS(pList) ){  rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);  }  sqlite3PagerUnref(pPageOne);  if( rc==SQLITE_OK ){  sqlite3PcacheCleanAll(pPager->pPCache);  }  }else{
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
 sqlite3_file *fd = pPager->fd;  int bBatch = zSuper==0  && (sqlite3OsDeviceCharacteristics(fd) & SQLITE_IOCAP_BATCH_ATOMIC)  && !pPager->noSync  && sqlite3JournalIsInMemory(pPager->jfd);
#else
#  define bBatch 0
#endif
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
 if( bBatch==0 ){  PgHdr *pPg;  assert( isOpen(pPager->jfd)  || pPager->journalMode==PAGER_JOURNALMODE_OFF  || pPager->journalMode==PAGER_JOURNALMODE_WAL  );  if( !zSuper && isOpen(pPager->jfd)   && pPager->journalOff==jrnlBufferSize(pPager)   && pPager->dbSize>=pPager->dbOrigSize   && (!(pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)  ){  rc = pager_incr_changecounter(pPager, 1);  }else{  rc = sqlite3JournalCreate(pPager->jfd);  if( rc==SQLITE_OK ){  rc = pager_incr_changecounter(pPager, 0);  }  }  }
#else
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
 if( zSuper ){  rc = sqlite3JournalCreate(pPager->jfd);  if( rc!=SQLITE_OK ) goto commit_phase_one_exit;  assert( bBatch==0 );  }
#endif
 rc = pager_incr_changecounter(pPager, 0);
#endif
 if( rc!=SQLITE_OK ) goto commit_phase_one_exit;  rc = writeSuperJournal(pPager, zSuper);  if( rc!=SQLITE_OK ) goto commit_phase_one_exit;  rc = syncJournal(pPager, 0);  if( rc!=SQLITE_OK ) goto commit_phase_one_exit;  pList = sqlite3PcacheDirtyList(pPager->pPCache);
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
 if( bBatch ){  rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, 0);  if( rc==SQLITE_OK ){  rc = pager_write_pagelist(pPager, pList);  if( rc==SQLITE_OK ){  rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, 0);  }  if( rc!=SQLITE_OK ){  sqlite3OsFileControlHint(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);  }  }  if( (rc&0xFF)==SQLITE_IOERR && rc!=SQLITE_IOERR_NOMEM ){  rc = sqlite3JournalCreate(pPager->jfd);  if( rc!=SQLITE_OK ){  sqlite3OsClose(pPager->jfd);  goto commit_phase_one_exit;  }  bBatch = 0;  }else{  sqlite3OsClose(pPager->jfd);  }  }
#endif
 if( bBatch==0 ){  rc = pager_write_pagelist(pPager, pList);  }  if( rc!=SQLITE_OK ){  assert( rc!=SQLITE_IOERR_BLOCKED );  goto commit_phase_one_exit;  }  sqlite3PcacheCleanAll(pPager->pPCache);  if( pPager->dbSize>pPager->dbFileSize ){  Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));  assert( pPager->eState==PAGER_WRITER_DBMOD );  rc = pager_truncate(pPager, nNew);  if( rc!=SQLITE_OK ) goto commit_phase_one_exit;  }  if( !noSync ){  rc = sqlite3PagerSync(pPager, zSuper);  }  IOTRACE(("DBSYNC %p\n", pPager))  }  } commit_phase_one_exit:  if( rc==SQLITE_OK && !pagerUseWal(pPager) ){  pPager->eState = PAGER_WRITER_FINISHED;  }  return rc; } SQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager *pPager){  int rc = SQLITE_OK;  if( NEVER(pPager->errCode) ) return pPager->errCode;  pPager->iDataVersion++;  assert( pPager->eState==PAGER_WRITER_LOCKED   || pPager->eState==PAGER_WRITER_FINISHED   || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD)  );  assert( assert_pager_state(pPager) );  if( pPager->eState==PAGER_WRITER_LOCKED   && pPager->exclusiveMode   && pPager->journalMode==PAGER_JOURNALMODE_PERSIST  ){  assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );  pPager->eState = PAGER_READER;  return SQLITE_OK;  }  PAGERTRACE(("COMMIT %d\n", PAGERID(pPager)));  rc = pager_end_transaction(pPager, pPager->setSuper, 1);  return pager_error(pPager, rc); } SQLITE_PRIVATE int sqlite3PagerRollback(Pager *pPager){  int rc = SQLITE_OK;  PAGERTRACE(("ROLLBACK %d\n", PAGERID(pPager)));  assert( assert_pager_state(pPager) );  if( pPager->eState==PAGER_ERROR ) return pPager->errCode;  if( pPager->eState<=PAGER_READER ) return SQLITE_OK;  if( pagerUseWal(pPager) ){  int rc2;  rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);  rc2 = pager_end_transaction(pPager, pPager->setSuper, 0);  if( rc==SQLITE_OK ) rc = rc2;  }else if( !isOpen(pPager->jfd) || pPager->eState==PAGER_WRITER_LOCKED ){  int eState = pPager->eState;  rc = pager_end_transaction(pPager, 0, 0);  if( !MEMDB && eState>PAGER_WRITER_LOCKED ){  pPager->errCode = SQLITE_ABORT;  pPager->eState = PAGER_ERROR;  setGetterMethod(pPager);  return rc;  }  }else{  rc = pager_playback(pPager, 0);  }  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );  assert( rc==SQLITE_OK || rc==SQLITE_FULL || rc==SQLITE_CORRUPT  || rc==SQLITE_NOMEM || (rc&0xFF)==SQLITE_IOERR  || rc==SQLITE_CANTOPEN  );  return pager_error(pPager, rc); } SQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager *pPager){  return pPager->readOnly; }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager){  return sqlite3PcacheRefCount(pPager->pPCache); }
#endif
SQLITE_PRIVATE int sqlite3PagerMemUsed(Pager *pPager){  int perPageSize = pPager->pageSize + pPager->nExtra  + (int)(sizeof(PgHdr) + 5*sizeof(void*));  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)   + sqlite3MallocSize(pPager)   + pPager->pageSize; } SQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage *pPage){  return sqlite3PcachePageRefcount(pPage); }
#ifdef SQLITE_TEST
SQLITE_PRIVATE int *sqlite3PagerStats(Pager *pPager){  static int a[11];  a[0] = sqlite3PcacheRefCount(pPager->pPCache);  a[1] = sqlite3PcachePagecount(pPager->pPCache);  a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);  a[3] = pPager->eState==PAGER_OPEN ? -1 : (int) pPager->dbSize;  a[4] = pPager->eState;  a[5] = pPager->errCode;  a[6] = pPager->aStat[PAGER_STAT_HIT];  a[7] = pPager->aStat[PAGER_STAT_MISS];  a[8] = 0;  a[9] = pPager->nRead;  a[10] = pPager->aStat[PAGER_STAT_WRITE];  return a; }
#endif
SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){  assert( eStat==SQLITE_DBSTATUS_CACHE_HIT   || eStat==SQLITE_DBSTATUS_CACHE_MISS   || eStat==SQLITE_DBSTATUS_CACHE_WRITE   || eStat==SQLITE_DBSTATUS_CACHE_WRITE+1  );  assert( SQLITE_DBSTATUS_CACHE_HIT+1==SQLITE_DBSTATUS_CACHE_MISS );  assert( SQLITE_DBSTATUS_CACHE_HIT+2==SQLITE_DBSTATUS_CACHE_WRITE );  assert( PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1   && PAGER_STAT_WRITE==2 && PAGER_STAT_SPILL==3 );  eStat -= SQLITE_DBSTATUS_CACHE_HIT;  *pnVal += pPager->aStat[eStat];  if( reset ){  pPager->aStat[eStat] = 0;  } } SQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager){  return pPager->tempFile || pPager->memVfs; } static SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){  int rc = SQLITE_OK;  int nCurrent = pPager->nSavepoint;  int ii;  PagerSavepoint *aNew;  assert( pPager->eState>=PAGER_WRITER_LOCKED );  assert( assert_pager_state(pPager) );  assert( nSavepoint>nCurrent && pPager->useJournal );  aNew = (PagerSavepoint *)sqlite3Realloc(  pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint  );  if( !aNew ){  return SQLITE_NOMEM_BKPT;  }  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));  pPager->aSavepoint = aNew;  for(ii=nCurrent; ii<nSavepoint; ii++){  aNew[ii].nOrig = pPager->dbSize;  if( isOpen(pPager->jfd) && pPager->journalOff>0 ){  aNew[ii].iOffset = pPager->journalOff;  }else{  aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);  }  aNew[ii].iSubRec = pPager->nSubRec;  aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);  aNew[ii].bTruncateOnRelease = 1;  if( !aNew[ii].pInSavepoint ){  return SQLITE_NOMEM_BKPT;  }  if( pagerUseWal(pPager) ){  sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);  }  pPager->nSavepoint = ii+1;  }  assert( pPager->nSavepoint==nSavepoint );  assertTruncateConstraint(pPager);  return rc; } SQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){  assert( pPager->eState>=PAGER_WRITER_LOCKED );  assert( assert_pager_state(pPager) );  if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){  return pagerOpenSavepoint(pPager, nSavepoint);  }else{  return SQLITE_OK;  } } SQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){  int rc = pPager->errCode;
#ifdef SQLITE_ENABLE_ZIPVFS
 if( op==SAVEPOINT_RELEASE ) rc = SQLITE_OK;
#endif
 assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );  assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK );  if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){  int ii;  int nNew;  nNew = iSavepoint + (( op==SAVEPOINT_RELEASE ) ? 0 : 1);  for(ii=nNew; ii<pPager->nSavepoint; ii++){  sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);  }  pPager->nSavepoint = nNew;  if( op==SAVEPOINT_RELEASE ){  PagerSavepoint *pRel = &pPager->aSavepoint[nNew];  if( pRel->bTruncateOnRelease && isOpen(pPager->sjfd) ){  if( sqlite3JournalIsInMemory(pPager->sjfd) ){  i64 sz = (pPager->pageSize+4)*(i64)pRel->iSubRec;  rc = sqlite3OsTruncate(pPager->sjfd, sz);  assert( rc==SQLITE_OK );  }  pPager->nSubRec = pRel->iSubRec;  }  }  else if( pagerUseWal(pPager) || isOpen(pPager->jfd) ){  PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];  rc = pagerPlaybackSavepoint(pPager, pSavepoint);  assert(rc!=SQLITE_DONE);  }
#ifdef SQLITE_ENABLE_ZIPVFS
 else if(  pPager->journalMode==PAGER_JOURNALMODE_OFF   && pPager->eState>=PAGER_WRITER_CACHEMOD  ){  pPager->errCode = SQLITE_ABORT;  pPager->eState = PAGER_ERROR;  setGetterMethod(pPager);  }
#endif
 }  return rc; } SQLITE_PRIVATE const char *sqlite3PagerFilename(const Pager *pPager, int nullIfMemDb){  static const char zFake[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };  return (nullIfMemDb && pPager->memDb) ? &zFake[4] : pPager->zFilename; } SQLITE_PRIVATE sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){  return pPager->pVfs; } SQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager){  return pPager->fd; } SQLITE_PRIVATE sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){
#if SQLITE_OMIT_WAL
 return pPager->jfd;
#else
 return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;
#endif
} SQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager){  return pPager->zJournal; }
#ifndef SQLITE_OMIT_AUTOVACUUM
SQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){  PgHdr *pPgOld;  Pgno needSyncPgno = 0;  int rc;  Pgno origPgno;  assert( pPg->nRef>0 );  assert( pPager->eState==PAGER_WRITER_CACHEMOD   || pPager->eState==PAGER_WRITER_DBMOD  );  assert( assert_pager_state(pPager) );  assert( pPager->tempFile || !MEMDB );  if( pPager->tempFile ){  rc = sqlite3PagerWrite(pPg);  if( rc ) return rc;  }  if( (pPg->flags & PGHDR_DIRTY)!=0   && SQLITE_OK!=(rc = subjournalPageIfRequired(pPg))  ){  return rc;  }  PAGERTRACE(("MOVE %d page %d (needSync=%d) moves to %d\n",  PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC)?1:0, pgno));  IOTRACE(("MOVE %p %d %d\n", pPager, pPg->pgno, pgno))  if( (pPg->flags&PGHDR_NEED_SYNC) && !isCommit ){  needSyncPgno = pPg->pgno;  assert( pPager->journalMode==PAGER_JOURNALMODE_OFF ||  pageInJournal(pPager, pPg) || pPg->pgno>pPager->dbOrigSize );  assert( pPg->flags&PGHDR_DIRTY );  }  pPg->flags &= ~PGHDR_NEED_SYNC;  pPgOld = sqlite3PagerLookup(pPager, pgno);  assert( !pPgOld || pPgOld->nRef==1 || CORRUPT_DB );  if( pPgOld ){  if( NEVER(pPgOld->nRef>1) ){  sqlite3PagerUnrefNotNull(pPgOld);  return SQLITE_CORRUPT_BKPT;  }  pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC);  if( pPager->tempFile ){  sqlite3PcacheMove(pPgOld, pPager->dbSize+1);  }else{  sqlite3PcacheDrop(pPgOld);  }  }  origPgno = pPg->pgno;  sqlite3PcacheMove(pPg, pgno);  sqlite3PcacheMakeDirty(pPg);  if( pPager->tempFile && pPgOld ){  sqlite3PcacheMove(pPgOld, origPgno);  sqlite3PagerUnrefNotNull(pPgOld);  }  if( needSyncPgno ){  PgHdr *pPgHdr;  rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);  if( rc!=SQLITE_OK ){  if( needSyncPgno<=pPager->dbOrigSize ){  assert( pPager->pTmpSpace!=0 );  sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);  }  return rc;  }  pPgHdr->flags |= PGHDR_NEED_SYNC;  sqlite3PcacheMakeDirty(pPgHdr);  sqlite3PagerUnrefNotNull(pPgHdr);  }  return SQLITE_OK; }
#endif
SQLITE_PRIVATE void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){  assert( pPg->pgno!=iNew );  pPg->flags = flags;  sqlite3PcacheMove(pPg, iNew); } SQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *pPg){  assert( pPg->nRef>0 || pPg->pPager->memDb );  return pPg->pData; } SQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg){  return pPg->pExtra; } SQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *pPager, int eMode){  assert( eMode==PAGER_LOCKINGMODE_QUERY  || eMode==PAGER_LOCKINGMODE_NORMAL  || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );  assert( PAGER_LOCKINGMODE_QUERY<0 );  assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){  pPager->exclusiveMode = (u8)eMode;  }  return (int)pPager->exclusiveMode; } SQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){  u8 eOld = pPager->journalMode;  assert( eMode==PAGER_JOURNALMODE_DELETE  || eMode==PAGER_JOURNALMODE_TRUNCATE  || eMode==PAGER_JOURNALMODE_PERSIST  || eMode==PAGER_JOURNALMODE_OFF  || eMode==PAGER_JOURNALMODE_WAL  || eMode==PAGER_JOURNALMODE_MEMORY );  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL );  if( MEMDB ){  assert( eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF );  if( eMode!=PAGER_JOURNALMODE_MEMORY && eMode!=PAGER_JOURNALMODE_OFF ){  eMode = eOld;  }  }  if( eMode!=eOld ){  assert( pPager->eState!=PAGER_ERROR );  pPager->journalMode = (u8)eMode;  assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );  assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );  assert( (PAGER_JOURNALMODE_DELETE & 5)==0 );  assert( (PAGER_JOURNALMODE_MEMORY & 5)==4 );  assert( (PAGER_JOURNALMODE_OFF & 5)==0 );  assert( (PAGER_JOURNALMODE_WAL & 5)==5 );  assert( isOpen(pPager->fd) || pPager->exclusiveMode );  if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){  sqlite3OsClose(pPager->jfd);  if( pPager->eLock>=RESERVED_LOCK ){  sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);  }else{  int rc = SQLITE_OK;  int state = pPager->eState;  assert( state==PAGER_OPEN || state==PAGER_READER );  if( state==PAGER_OPEN ){  rc = sqlite3PagerSharedLock(pPager);  }  if( pPager->eState==PAGER_READER ){  assert( rc==SQLITE_OK );  rc = pagerLockDb(pPager, RESERVED_LOCK);  }  if( rc==SQLITE_OK ){  sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);  }  if( rc==SQLITE_OK && state==PAGER_READER ){  pagerUnlockDb(pPager, SHARED_LOCK);  }else if( state==PAGER_OPEN ){  pager_unlock(pPager);  }  assert( state==pPager->eState );  }  }else if( eMode==PAGER_JOURNALMODE_OFF ){  sqlite3OsClose(pPager->jfd);  }  }  return (int)pPager->journalMode; } SQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager *pPager){  return (int)pPager->journalMode; } SQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager *pPager){  assert( assert_pager_state(pPager) );  if( pPager->eState>=PAGER_WRITER_CACHEMOD ) return 0;  if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) return 0;  return 1; } SQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){  if( iLimit>=-1 ){  pPager->journalSizeLimit = iLimit;  sqlite3WalLimit(pPager->pWal, iLimit);  }  return pPager->journalSizeLimit; } SQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){  return &pPager->pBackup; }
#ifndef SQLITE_OMIT_VACUUM
SQLITE_PRIVATE void sqlite3PagerClearCache(Pager *pPager){  assert( MEMDB==0 || pPager->tempFile );  if( pPager->tempFile==0 ) pager_reset(pPager); }
#endif
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3PagerCheckpoint(  Pager *pPager,  sqlite3 *db,  int eMode,  int *pnLog,  int *pnCkpt ){  int rc = SQLITE_OK;  if( pPager->pWal ){  rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,  (eMode==SQLITE_CHECKPOINT_PASSIVE ? 0 : pPager->xBusyHandler),  pPager->pBusyHandlerArg,  pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,  pnLog, pnCkpt  );  }  return rc; } SQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager){  return sqlite3WalCallback(pPager->pWal); } SQLITE_PRIVATE int sqlite3PagerWalSupported(Pager *pPager){  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;  if( pPager->noLock ) return 0;  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap); } static int pagerExclusiveLock(Pager *pPager){  int rc;  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);  if( rc!=SQLITE_OK ){  pagerUnlockDb(pPager, SHARED_LOCK);  }  return rc; } static int pagerOpenWal(Pager *pPager){  int rc = SQLITE_OK;  assert( pPager->pWal==0 && pPager->tempFile==0 );  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );  if( pPager->exclusiveMode ){  rc = pagerExclusiveLock(pPager);  }  if( rc==SQLITE_OK ){  rc = sqlite3WalOpen(pPager->pVfs,  pPager->fd, pPager->zWal, pPager->exclusiveMode,  pPager->journalSizeLimit, &pPager->pWal  );  }  pagerFixMaplimit(pPager);  return rc; } SQLITE_PRIVATE int sqlite3PagerOpenWal(  Pager *pPager,  int *pbOpen ){  int rc = SQLITE_OK;  assert( assert_pager_state(pPager) );  assert( pPager->eState==PAGER_OPEN  || pbOpen );  assert( pPager->eState==PAGER_READER || !pbOpen );  assert( pbOpen==0 || *pbOpen==0 );  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );  if( !pPager->tempFile && !pPager->pWal ){  if( !sqlite3PagerWalSupported(pPager) ) return SQLITE_CANTOPEN;  sqlite3OsClose(pPager->jfd);  rc = pagerOpenWal(pPager);  if( rc==SQLITE_OK ){  pPager->journalMode = PAGER_JOURNALMODE_WAL;  pPager->eState = PAGER_OPEN;  }  }else{  *pbOpen = 1;  }  return rc; } SQLITE_PRIVATE int sqlite3PagerCloseWal(Pager *pPager, sqlite3 *db){  int rc = SQLITE_OK;  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL );  if( !pPager->pWal ){  int logexists = 0;  rc = pagerLockDb(pPager, SHARED_LOCK);  if( rc==SQLITE_OK ){  rc = sqlite3OsAccess(  pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists  );  }  if( rc==SQLITE_OK && logexists ){  rc = pagerOpenWal(pPager);  }  }  if( rc==SQLITE_OK && pPager->pWal ){  rc = pagerExclusiveLock(pPager);  if( rc==SQLITE_OK ){  rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,   pPager->pageSize, (u8*)pPager->pTmpSpace);  pPager->pWal = 0;  pagerFixMaplimit(pPager);  if( rc && !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);  }  }  return rc; }
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
SQLITE_PRIVATE int sqlite3PagerWalWriteLock(Pager *pPager, int bLock){  int rc = SQLITE_OK;  if( pagerUseWal(pPager) && pPager->exclusiveMode==0 ){  rc = sqlite3WalWriteLock(pPager->pWal, bLock);  }  return rc; } SQLITE_PRIVATE void sqlite3PagerWalDb(Pager *pPager, sqlite3 *db){  if( pagerUseWal(pPager) ){  sqlite3WalDb(pPager->pWal, db);  } }
#endif
#ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE int sqlite3PagerSnapshotGet(Pager *pPager, sqlite3_snapshot **ppSnapshot){  int rc = SQLITE_ERROR;  if( pPager->pWal ){  rc = sqlite3WalSnapshotGet(pPager->pWal, ppSnapshot);  }  return rc; } SQLITE_PRIVATE int sqlite3PagerSnapshotOpen(  Pager *pPager,  sqlite3_snapshot *pSnapshot ){  int rc = SQLITE_OK;  if( pPager->pWal ){  sqlite3WalSnapshotOpen(pPager->pWal, pSnapshot);  }else{  rc = SQLITE_ERROR;  }  return rc; } SQLITE_PRIVATE int sqlite3PagerSnapshotRecover(Pager *pPager){  int rc;  if( pPager->pWal ){  rc = sqlite3WalSnapshotRecover(pPager->pWal);  }else{  rc = SQLITE_ERROR;  }  return rc; } SQLITE_PRIVATE int sqlite3PagerSnapshotCheck(Pager *pPager, sqlite3_snapshot *pSnapshot){  int rc;  if( pPager->pWal ){  rc = sqlite3WalSnapshotCheck(pPager->pWal, pSnapshot);  }else{  rc = SQLITE_ERROR;  }  return rc; } SQLITE_PRIVATE void sqlite3PagerSnapshotUnlock(Pager *pPager){  assert( pPager->pWal );  sqlite3WalSnapshotUnlock(pPager->pWal); }
#endif
#endif
#ifdef SQLITE_ENABLE_ZIPVFS
SQLITE_PRIVATE int sqlite3PagerWalFramesize(Pager *pPager){  assert( pPager->eState>=PAGER_READER );  return sqlite3WalFramesize(pPager->pWal); }
#endif
#endif
#ifndef SQLITE_OMIT_WAL
#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
SQLITE_PRIVATE int sqlite3WalTrace = 0;
# define WALTRACE(X) if(sqlite3WalTrace) sqlite3DebugPrintf X
#else
# define WALTRACE(X)
#endif
#define WAL_MAX_VERSION 3007000
#define WALINDEX_MAX_VERSION 3007000
#define WAL_WRITE_LOCK  0
#define WAL_ALL_BUT_WRITE 1
#define WAL_CKPT_LOCK 1
#define WAL_RECOVER_LOCK  2
#define WAL_READ_LOCK(I)  (3+(I))
#define WAL_NREADER (SQLITE_SHM_NLOCK-3)
typedef struct WalIndexHdr WalIndexHdr; typedef struct WalIterator WalIterator; typedef struct WalCkptInfo WalCkptInfo; struct WalIndexHdr {  u32 iVersion;  u32 unused;  u32 iChange;  u8 isInit;  u8 bigEndCksum;  u16 szPage;  u32 mxFrame;  u32 nPage;  u32 aFrameCksum[2];  u32 aSalt[2];  u32 aCksum[2]; }; struct WalCkptInfo {  u32 nBackfill;  u32 aReadMark[WAL_NREADER];  u8 aLock[SQLITE_SHM_NLOCK];  u32 nBackfillAttempted;  u32 notUsed0; };
#define READMARK_NOT_USED 0xffffffff
#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))
#define WALINDEX_HDR_SIZE (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))
#define WAL_FRAME_HDRSIZE 24
#define WAL_HDRSIZE 32
#define WAL_MAGIC 0x377f0682
#define walFrameOffset(iFrame, szPage) (   WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)  )

struct Wal {  sqlite3_vfs *pVfs;  sqlite3_file *pDbFd;  sqlite3_file *pWalFd;  u32 iCallback;  i64 mxWalSize;  int nWiData;  int szFirstBlock;  volatile u32 **apWiData;  u32 szPage;  i16 readLock;  u8 syncFlags;  u8 exclusiveMode;  u8 writeLock;  u8 ckptLock;  u8 readOnly;  u8 truncateOnCommit;  u8 syncHeader;  u8 padToSectorBoundary;  u8 bShmUnreliable;  WalIndexHdr hdr;  u32 minFrame;  u32 iReCksum;  const char *zWalName;  u32 nCkpt;
#ifdef SQLITE_DEBUG
 u8 lockError;
#endif
#ifdef SQLITE_ENABLE_SNAPSHOT
 WalIndexHdr *pSnapshot;
#endif
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 sqlite3 *db;
#endif
};
#define WAL_NORMAL_MODE  0
#define WAL_EXCLUSIVE_MODE 1
#define WAL_HEAPMEMORY_MODE 2
#define WAL_RDWR 0
#define WAL_RDONLY 1
#define WAL_SHM_RDONLY 2
typedef u16 ht_slot; struct WalIterator {  u32 iPrior;  int nSegment;  struct WalSegment {  int iNext;  ht_slot *aIndex;  u32 *aPgno;  int nEntry;  int iZero;  } aSegment[1]; };
#define HASHTABLE_NPAGE 4096
#define HASHTABLE_HASH_1  383
#define HASHTABLE_NSLOT (HASHTABLE_NPAGE*2)
#define HASHTABLE_NPAGE_ONE (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))
#define WALINDEX_PGSZ  (   sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) )

static SQLITE_NOINLINE int walIndexPageRealloc(  Wal *pWal,  int iPage,  volatile u32 **ppPage ){  int rc = SQLITE_OK;  if( pWal->nWiData<=iPage ){  sqlite3_int64 nByte = sizeof(u32*)*(iPage+1);  volatile u32 **apNew;  apNew = (volatile u32 **)sqlite3Realloc((void *)pWal->apWiData, nByte);  if( !apNew ){  *ppPage = 0;  return SQLITE_NOMEM_BKPT;  }  memset((void*)&apNew[pWal->nWiData], 0,   sizeof(u32*)*(iPage+1-pWal->nWiData));  pWal->apWiData = apNew;  pWal->nWiData = iPage+1;  }  assert( pWal->apWiData[iPage]==0 );  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){  pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);  if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;  }else{  rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ,  pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]  );  assert( pWal->apWiData[iPage]!=0   || rc!=SQLITE_OK   || (pWal->writeLock==0 && iPage==0) );  testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );  if( rc==SQLITE_OK ){  if( iPage>0 && sqlite3FaultSim(600) ) rc = SQLITE_NOMEM;  }else if( (rc&0xff)==SQLITE_READONLY ){  pWal->readOnly |= WAL_SHM_RDONLY;  if( rc==SQLITE_READONLY ){  rc = SQLITE_OK;  }  }  }  *ppPage = pWal->apWiData[iPage];  assert( iPage==0 || *ppPage || rc!=SQLITE_OK );  return rc; } static int walIndexPage(  Wal *pWal,  int iPage,  volatile u32 **ppPage ){  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){  return walIndexPageRealloc(pWal, iPage, ppPage);  }  return SQLITE_OK; } static volatile WalCkptInfo *walCkptInfo(Wal *pWal){  assert( pWal->nWiData>0 && pWal->apWiData[0] );  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]); } static volatile WalIndexHdr *walIndexHdr(Wal *pWal){  assert( pWal->nWiData>0 && pWal->apWiData[0] );  return (volatile WalIndexHdr*)pWal->apWiData[0]; }
#define BYTESWAP32(x) (  (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8)  + (((x)&0x00FF0000)>>8) + (((x)&0xFF000000)>>24) )

static void walChecksumBytes(  int nativeCksum,  u8 *a,  int nByte,  const u32 *aIn,  u32 *aOut ){  u32 s1, s2;  u32 *aData = (u32 *)a;  u32 *aEnd = (u32 *)&a[nByte];  if( aIn ){  s1 = aIn[0];  s2 = aIn[1];  }else{  s1 = s2 = 0;  }  assert( nByte>=8 );  assert( (nByte&0x00000007)==0 );  assert( nByte<=65536 );  if( nativeCksum ){  do {  s1 += *aData++ + s2;  s2 += *aData++ + s1;  }while( aData<aEnd );  }else{  do {  s1 += BYTESWAP32(aData[0]) + s2;  s2 += BYTESWAP32(aData[1]) + s1;  aData += 2;  }while( aData<aEnd );  }  aOut[0] = s1;  aOut[1] = s2; } static void walShmBarrier(Wal *pWal){  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){  sqlite3OsShmBarrier(pWal->pDbFd);  } }
#if defined(__clang__) && !defined(SQLITE_NO_TSAN)
# define SQLITE_NO_TSAN __attribute__((no_sanitize_thread))
#else
# define SQLITE_NO_TSAN
#endif
static SQLITE_NO_TSAN void walIndexWriteHdr(Wal *pWal){  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);  const int nCksum = offsetof(WalIndexHdr, aCksum);  assert( pWal->writeLock );  pWal->hdr.isInit = 1;  pWal->hdr.iVersion = WALINDEX_MAX_VERSION;  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));  walShmBarrier(pWal);  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr)); } static void walEncodeFrame(  Wal *pWal,  u32 iPage,  u32 nTruncate,  u8 *aData,  u8 *aFrame ){  int nativeCksum;  u32 *aCksum = pWal->hdr.aFrameCksum;  assert( WAL_FRAME_HDRSIZE==24 );  sqlite3Put4byte(&aFrame[0], iPage);  sqlite3Put4byte(&aFrame[4], nTruncate);  if( pWal->iReCksum==0 ){  memcpy(&aFrame[8], pWal->hdr.aSalt, 8);  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);  sqlite3Put4byte(&aFrame[16], aCksum[0]);  sqlite3Put4byte(&aFrame[20], aCksum[1]);  }else{  memset(&aFrame[8], 0, 16);  } } static int walDecodeFrame(  Wal *pWal,  u32 *piPage,  u32 *pnTruncate,  u8 *aData,  u8 *aFrame ){  int nativeCksum;  u32 *aCksum = pWal->hdr.aFrameCksum;  u32 pgno;  assert( WAL_FRAME_HDRSIZE==24 );  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){  return 0;  }  pgno = sqlite3Get4byte(&aFrame[0]);  if( pgno==0 ){  return 0;  }  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16])   || aCksum[1]!=sqlite3Get4byte(&aFrame[20])  ){  return 0;  }  *piPage = pgno;  *pnTruncate = sqlite3Get4byte(&aFrame[4]);  return 1; }
#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
static const char *walLockName(int lockIdx){  if( lockIdx==WAL_WRITE_LOCK ){  return "WRITE-LOCK";  }else if( lockIdx==WAL_CKPT_LOCK ){  return "CKPT-LOCK";  }else if( lockIdx==WAL_RECOVER_LOCK ){  return "RECOVER-LOCK";  }else{  static char zName[15];  sqlite3_snprintf(sizeof(zName), zName, "READ-LOCK[%d]",   lockIdx-WAL_READ_LOCK(0));  return zName;  } }
#endif
static int walLockShared(Wal *pWal, int lockIdx){  int rc;  if( pWal->exclusiveMode ) return SQLITE_OK;  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,  SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);  WALTRACE(("WAL%p: acquire SHARED-%s %s\n", pWal,  walLockName(lockIdx), rc ? "failed" : "ok"));  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && (rc&0xFF)!=SQLITE_BUSY); )  return rc; } static void walUnlockShared(Wal *pWal, int lockIdx){  if( pWal->exclusiveMode ) return;  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,   SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);  WALTRACE(("WAL%p: release SHARED-%s\n", pWal, walLockName(lockIdx))); } static int walLockExclusive(Wal *pWal, int lockIdx, int n){  int rc;  if( pWal->exclusiveMode ) return SQLITE_OK;  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,  SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);  WALTRACE(("WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\n", pWal,  walLockName(lockIdx), n, rc ? "failed" : "ok"));  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && (rc&0xFF)!=SQLITE_BUSY); )  return rc; } static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){  if( pWal->exclusiveMode ) return;  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,   SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);  WALTRACE(("WAL%p: release EXCLUSIVE-%s cnt=%d\n", pWal,   walLockName(lockIdx), n)); } static int walHash(u32 iPage){  assert( iPage>0 );  assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );  return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT-1); } static int walNextHash(int iPriorHash){  return (iPriorHash+1)&(HASHTABLE_NSLOT-1); } typedef struct WalHashLoc WalHashLoc; struct WalHashLoc {  volatile ht_slot *aHash;  volatile u32 *aPgno;  u32 iZero; }; static int walHashGet(  Wal *pWal,  int iHash,  WalHashLoc *pLoc ){  int rc;  rc = walIndexPage(pWal, iHash, &pLoc->aPgno);  assert( rc==SQLITE_OK || iHash>0 );  if( pLoc->aPgno ){  pLoc->aHash = (volatile ht_slot *)&pLoc->aPgno[HASHTABLE_NPAGE];  if( iHash==0 ){  pLoc->aPgno = &pLoc->aPgno[WALINDEX_HDR_SIZE/sizeof(u32)];  pLoc->iZero = 0;  }else{  pLoc->iZero = HASHTABLE_NPAGE_ONE + (iHash-1)*HASHTABLE_NPAGE;  }  }else if( NEVER(rc==SQLITE_OK) ){  rc = SQLITE_ERROR;  }  return rc; } static int walFramePage(u32 iFrame){  int iHash = (iFrame+HASHTABLE_NPAGE-HASHTABLE_NPAGE_ONE-1) / HASHTABLE_NPAGE;  assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)   && (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE)   && (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE))   && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)   && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))  );  assert( iHash>=0 );  return iHash; } static u32 walFramePgno(Wal *pWal, u32 iFrame){  int iHash = walFramePage(iFrame);  if( iHash==0 ){  return pWal->apWiData[0][WALINDEX_HDR_SIZE/sizeof(u32) + iFrame - 1];  }  return pWal->apWiData[iHash][(iFrame-1-HASHTABLE_NPAGE_ONE)%HASHTABLE_NPAGE]; } static void walCleanupHash(Wal *pWal){  WalHashLoc sLoc;  int iLimit = 0;  int nByte;  int i;  assert( pWal->writeLock );  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE );  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE+1 );  if( pWal->hdr.mxFrame==0 ) return;  assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );  assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );  i = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);  if( NEVER(i) ) return;  iLimit = pWal->hdr.mxFrame - sLoc.iZero;  assert( iLimit>0 );  for(i=0; i<HASHTABLE_NSLOT; i++){  if( sLoc.aHash[i]>iLimit ){  sLoc.aHash[i] = 0;  }  }  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit]);  assert( nByte>=0 );  memset((void *)&sLoc.aPgno[iLimit], 0, nByte);
#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
 if( iLimit ){  int j;  int iKey;  for(j=0; j<iLimit; j++){  for(iKey=walHash(sLoc.aPgno[j]);sLoc.aHash[iKey];iKey=walNextHash(iKey)){  if( sLoc.aHash[iKey]==j+1 ) break;  }  assert( sLoc.aHash[iKey]==j+1 );  }  }
#endif
} static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){  int rc;  WalHashLoc sLoc;  rc = walHashGet(pWal, walFramePage(iFrame), &sLoc);  if( rc==SQLITE_OK ){  int iKey;  int idx;  int nCollide;  idx = iFrame - sLoc.iZero;  assert( idx <= HASHTABLE_NSLOT/2 + 1 );  if( idx==1 ){  int nByte = (int)((u8*)&sLoc.aHash[HASHTABLE_NSLOT] - (u8*)sLoc.aPgno);  assert( nByte>=0 );  memset((void*)sLoc.aPgno, 0, nByte);  }  if( sLoc.aPgno[idx-1] ){  walCleanupHash(pWal);  assert( !sLoc.aPgno[idx-1] );  }  nCollide = idx;  for(iKey=walHash(iPage); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){  if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;  }  sLoc.aPgno[idx-1] = iPage;  AtomicStore(&sLoc.aHash[iKey], (ht_slot)idx);
#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
 {  int i;  int nEntry = 0;  for(i=0; i<HASHTABLE_NSLOT; i++){ if( sLoc.aHash[i] ) nEntry++; }  assert( nEntry==idx );  }  if( (idx&0x3ff)==0 ){  int i;  for(i=0; i<idx; i++){  for(iKey=walHash(sLoc.aPgno[i]);  sLoc.aHash[iKey];  iKey=walNextHash(iKey)){  if( sLoc.aHash[iKey]==i+1 ) break;  }  assert( sLoc.aHash[iKey]==i+1 );  }  }
#endif
 }  return rc; } static int walIndexRecover(Wal *pWal){  int rc;  i64 nSize;  u32 aFrameCksum[2] = {0, 0};  int iLock;  assert( pWal->ckptLock==1 || pWal->ckptLock==0 );  assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );  assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );  assert( pWal->writeLock );  iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;  rc = walLockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);  if( rc ){  return rc;  }  WALTRACE(("WAL%p: recovery begin...\n", pWal));  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);  if( rc!=SQLITE_OK ){  goto recovery_error;  }  if( nSize>WAL_HDRSIZE ){  u8 aBuf[WAL_HDRSIZE];  u32 *aPrivate = 0;  u8 *aFrame = 0;  int szFrame;  u8 *aData;  int szPage;  u32 magic;  u32 version;  int isValid;  u32 iPg;  u32 iLastFrame;  rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);  if( rc!=SQLITE_OK ){  goto recovery_error;  }  magic = sqlite3Get4byte(&aBuf[0]);  szPage = sqlite3Get4byte(&aBuf[8]);  if( (magic&0xFFFFFFFE)!=WAL_MAGIC   || szPage&(szPage-1)   || szPage>SQLITE_MAX_PAGE_SIZE   || szPage<512  ){  goto finished;  }  pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);  pWal->szPage = szPage;  pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);  memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);  walChecksumBytes(pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN,  aBuf, WAL_HDRSIZE-2*4, 0, pWal->hdr.aFrameCksum  );  if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])   || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])  ){  goto finished;  }  version = sqlite3Get4byte(&aBuf[4]);  if( version!=WAL_MAX_VERSION ){  rc = SQLITE_CANTOPEN_BKPT;  goto finished;  }  szFrame = szPage + WAL_FRAME_HDRSIZE;  aFrame = (u8 *)sqlite3_malloc64(szFrame + WALINDEX_PGSZ);  if( !aFrame ){  rc = SQLITE_NOMEM_BKPT;  goto recovery_error;  }  aData = &aFrame[WAL_FRAME_HDRSIZE];  aPrivate = (u32*)&aData[szPage];  iLastFrame = (nSize - WAL_HDRSIZE) / szFrame;  for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){  u32 *aShare;  u32 iFrame;  u32 iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);  u32 iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);  u32 nHdr, nHdr32;  rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);  assert( aShare!=0 || rc!=SQLITE_OK );  if( aShare==0 ) break;  pWal->apWiData[iPg] = aPrivate;  for(iFrame=iFirst; iFrame<=iLast; iFrame++){  i64 iOffset = walFrameOffset(iFrame, szPage);  u32 pgno;  u32 nTruncate;  rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);  if( rc!=SQLITE_OK ) break;  isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);  if( !isValid ) break;  rc = walIndexAppend(pWal, iFrame, pgno);  if( NEVER(rc!=SQLITE_OK) ) break;  if( nTruncate ){  pWal->hdr.mxFrame = iFrame;  pWal->hdr.nPage = nTruncate;  pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));  testcase( szPage<=32768 );  testcase( szPage>=65536 );  aFrameCksum[0] = pWal->hdr.aFrameCksum[0];  aFrameCksum[1] = pWal->hdr.aFrameCksum[1];  }  }  pWal->apWiData[iPg] = aShare;  nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);  nHdr32 = nHdr / sizeof(u32);
#ifndef SQLITE_SAFER_WALINDEX_RECOVERY
 memcpy(&aShare[nHdr32], &aPrivate[nHdr32], WALINDEX_PGSZ-nHdr);
#else
 {  int i;  for(i=nHdr32; i<WALINDEX_PGSZ/sizeof(u32); i++){  if( aShare[i]!=aPrivate[i] ){  aShare[i] = aPrivate[i];  }  }  }
#endif
 if( iFrame<=iLast ) break;  }  sqlite3_free(aFrame);  } finished:  if( rc==SQLITE_OK ){  volatile WalCkptInfo *pInfo;  int i;  pWal->hdr.aFrameCksum[0] = aFrameCksum[0];  pWal->hdr.aFrameCksum[1] = aFrameCksum[1];  walIndexWriteHdr(pWal);  pInfo = walCkptInfo(pWal);  pInfo->nBackfill = 0;  pInfo->nBackfillAttempted = pWal->hdr.mxFrame;  pInfo->aReadMark[0] = 0;  for(i=1; i<WAL_NREADER; i++){  rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);  if( rc==SQLITE_OK ){  if( i==1 && pWal->hdr.mxFrame ){  pInfo->aReadMark[i] = pWal->hdr.mxFrame;  }else{  pInfo->aReadMark[i] = READMARK_NOT_USED;  }  walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);  }else if( rc!=SQLITE_BUSY ){  goto recovery_error;  }  }  if( pWal->hdr.nPage ){  sqlite3_log(SQLITE_NOTICE_RECOVER_WAL,  "recovered %d frames from WAL file %s",  pWal->hdr.mxFrame, pWal->zWalName  );  }  } recovery_error:  WALTRACE(("WAL%p: recovery %s\n", pWal, rc ? "failed" : "ok"));  walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);  return rc; } static void walIndexClose(Wal *pWal, int isDelete){  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE || pWal->bShmUnreliable ){  int i;  for(i=0; i<pWal->nWiData; i++){  sqlite3_free((void *)pWal->apWiData[i]);  pWal->apWiData[i] = 0;  }  }  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){  sqlite3OsShmUnmap(pWal->pDbFd, isDelete);  } } SQLITE_PRIVATE int sqlite3WalOpen(  sqlite3_vfs *pVfs,  sqlite3_file *pDbFd,  const char *zWalName,  int bNoShm,  i64 mxWalSize,  Wal **ppWal ){  int rc;  Wal *pRet;  int flags;  assert( zWalName && zWalName[0] );  assert( pDbFd );  assert( 48 == sizeof(WalIndexHdr) );  assert( 40 == sizeof(WalCkptInfo) );  assert(  120 == WALINDEX_LOCK_OFFSET );  assert(  136 == WALINDEX_HDR_SIZE );  assert( 4096 == HASHTABLE_NPAGE );  assert( 4062 == HASHTABLE_NPAGE_ONE );  assert( 8192 == HASHTABLE_NSLOT );  assert(  383 == HASHTABLE_HASH_1  );  assert( 32768 == WALINDEX_PGSZ );  assert(  8 == SQLITE_SHM_NLOCK  );  assert(  5 == WAL_NREADER );  assert( 24 == WAL_FRAME_HDRSIZE );  assert( 32 == WAL_HDRSIZE );  assert(  120 == WALINDEX_LOCK_OFFSET + WAL_WRITE_LOCK  );  assert(  121 == WALINDEX_LOCK_OFFSET + WAL_CKPT_LOCK );  assert(  122 == WALINDEX_LOCK_OFFSET + WAL_RECOVER_LOCK );  assert(  123 == WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(0) );  assert(  124 == WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(1) );  assert(  125 == WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(2) );  assert(  126 == WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(3) );  assert(  127 == WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(4) );
#ifdef WIN_SHM_BASE
 assert( WIN_SHM_BASE==WALINDEX_LOCK_OFFSET );
#endif
#ifdef UNIX_SHM_BASE
 assert( UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET );
#endif
 *ppWal = 0;  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);  if( !pRet ){  return SQLITE_NOMEM_BKPT;  }  pRet->pVfs = pVfs;  pRet->pWalFd = (sqlite3_file *)&pRet[1];  pRet->pDbFd = pDbFd;  pRet->readLock = -1;  pRet->mxWalSize = mxWalSize;  pRet->zWalName = zWalName;  pRet->syncHeader = 1;  pRet->padToSectorBoundary = 1;  pRet->exclusiveMode = (bNoShm ? WAL_HEAPMEMORY_MODE: WAL_NORMAL_MODE);  flags = (SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_WAL);  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);  if( rc==SQLITE_OK && flags&SQLITE_OPEN_READONLY ){  pRet->readOnly = WAL_RDONLY;  }  if( rc!=SQLITE_OK ){  walIndexClose(pRet, 0);  sqlite3OsClose(pRet->pWalFd);  sqlite3_free(pRet);  }else{  int iDC = sqlite3OsDeviceCharacteristics(pDbFd);  if( iDC & SQLITE_IOCAP_SEQUENTIAL ){ pRet->syncHeader = 0; }  if( iDC & SQLITE_IOCAP_POWERSAFE_OVERWRITE ){  pRet->padToSectorBoundary = 0;  }  *ppWal = pRet;  WALTRACE(("WAL%d: opened\n", pRet));  }  return rc; } SQLITE_PRIVATE void sqlite3WalLimit(Wal *pWal, i64 iLimit){  if( pWal ) pWal->mxWalSize = iLimit; } static int walIteratorNext(  WalIterator *p,  u32 *piPage,  u32 *piFrame ){  u32 iMin;  u32 iRet = 0xFFFFFFFF;  int i;  iMin = p->iPrior;  assert( iMin<0xffffffff );  for(i=p->nSegment-1; i>=0; i--){  struct WalSegment *pSegment = &p->aSegment[i];  while( pSegment->iNext<pSegment->nEntry ){  u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];  if( iPg>iMin ){  if( iPg<iRet ){  iRet = iPg;  *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];  }  break;  }  pSegment->iNext++;  }  }  *piPage = p->iPrior = iRet;  return (iRet==0xFFFFFFFF); } static void walMerge(  const u32 *aContent,  ht_slot *aLeft,  int nLeft,  ht_slot **paRight,  int *pnRight,  ht_slot *aTmp ){  int iLeft = 0;  int iRight = 0;  int iOut = 0;  int nRight = *pnRight;  ht_slot *aRight = *paRight;  assert( nLeft>0 && nRight>0 );  while( iRight<nRight || iLeft<nLeft ){  ht_slot logpage;  Pgno dbpage;  if( (iLeft<nLeft)   && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])  ){  logpage = aLeft[iLeft++];  }else{  logpage = aRight[iRight++];  }  dbpage = aContent[logpage];  aTmp[iOut++] = logpage;  if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;  assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );  assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );  }  *paRight = aLeft;  *pnRight = iOut;  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut); } static void walMergesort(  const u32 *aContent,  ht_slot *aBuffer,  ht_slot *aList,  int *pnList ){  struct Sublist {  int nList;  ht_slot *aList;  };  const int nList = *pnList;  int nMerge = 0;  ht_slot *aMerge = 0;  int iList;  u32 iSub = 0;  struct Sublist aSub[13];  memset(aSub, 0, sizeof(aSub));  assert( nList<=HASHTABLE_NPAGE && nList>0 );  assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) );  for(iList=0; iList<nList; iList++){  nMerge = 1;  aMerge = &aList[iList];  for(iSub=0; iList & (1<<iSub); iSub++){  struct Sublist *p;  assert( iSub<ArraySize(aSub) );  p = &aSub[iSub];  assert( p->aList && p->nList<=(1<<iSub) );  assert( p->aList==&aList[iList&~((2<<iSub)-1)] );  walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);  }  aSub[iSub].aList = aMerge;  aSub[iSub].nList = nMerge;  }  for(iSub++; iSub<ArraySize(aSub); iSub++){  if( nList & (1<<iSub) ){  struct Sublist *p;  assert( iSub<ArraySize(aSub) );  p = &aSub[iSub];  assert( p->nList<=(1<<iSub) );  assert( p->aList==&aList[nList&~((2<<iSub)-1)] );  walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);  }  }  assert( aMerge==aList );  *pnList = nMerge;
#ifdef SQLITE_DEBUG
 {  int i;  for(i=1; i<*pnList; i++){  assert( aContent[aList[i]] > aContent[aList[i-1]] );  }  }
#endif
} static void walIteratorFree(WalIterator *p){  sqlite3_free(p); } static int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){  WalIterator *p;  int nSegment;  u32 iLast;  sqlite3_int64 nByte;  int i;  ht_slot *aTmp;  int rc = SQLITE_OK;  assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );  iLast = pWal->hdr.mxFrame;  nSegment = walFramePage(iLast) + 1;  nByte = sizeof(WalIterator)  + (nSegment-1)*sizeof(struct WalSegment)  + iLast*sizeof(ht_slot);  p = (WalIterator *)sqlite3_malloc64(nByte);  if( !p ){  return SQLITE_NOMEM_BKPT;  }  memset(p, 0, nByte);  p->nSegment = nSegment;  aTmp = (ht_slot *)sqlite3_malloc64(  sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)  );  if( !aTmp ){  rc = SQLITE_NOMEM_BKPT;  }  for(i=walFramePage(nBackfill+1); rc==SQLITE_OK && i<nSegment; i++){  WalHashLoc sLoc;  rc = walHashGet(pWal, i, &sLoc);  if( rc==SQLITE_OK ){  int j;  int nEntry;  ht_slot *aIndex;  if( (i+1)==nSegment ){  nEntry = (int)(iLast - sLoc.iZero);  }else{  nEntry = (int)((u32*)sLoc.aHash - (u32*)sLoc.aPgno);  }  aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[sLoc.iZero];  sLoc.iZero++;  for(j=0; j<nEntry; j++){  aIndex[j] = (ht_slot)j;  }  walMergesort((u32 *)sLoc.aPgno, aTmp, aIndex, &nEntry);  p->aSegment[i].iZero = sLoc.iZero;  p->aSegment[i].nEntry = nEntry;  p->aSegment[i].aIndex = aIndex;  p->aSegment[i].aPgno = (u32 *)sLoc.aPgno;  }  }  sqlite3_free(aTmp);  if( rc!=SQLITE_OK ){  walIteratorFree(p);  p = 0;  }  *pp = p;  return rc; }
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
static int walEnableBlocking(Wal *pWal){  int res = 0;  if( pWal->db ){  int tmout = pWal->db->busyTimeout;  if( tmout ){  int rc;  rc = sqlite3OsFileControl(  pWal->pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&tmout  );  res = (rc==SQLITE_OK);  }  }  return res; } static void walDisableBlocking(Wal *pWal){  int tmout = 0;  sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&tmout); } SQLITE_PRIVATE int sqlite3WalWriteLock(Wal *pWal, int bLock){  int rc = SQLITE_OK;  assert( pWal->readLock<0 || bLock==0 );  if( bLock ){  assert( pWal->db );  if( walEnableBlocking(pWal) ){  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);  if( rc==SQLITE_OK ){  pWal->writeLock = 1;  }  walDisableBlocking(pWal);  }  }else if( pWal->writeLock ){  walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);  pWal->writeLock = 0;  }  return rc; } SQLITE_PRIVATE void sqlite3WalDb(Wal *pWal, sqlite3 *db){  pWal->db = db; } static int walLockWriter(Wal *pWal){  int rc;  walEnableBlocking(pWal);  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);  walDisableBlocking(pWal);  return rc; }
#else
# define walEnableBlocking(x) 0
# define walDisableBlocking(x)
# define walLockWriter(pWal) walLockExclusive((pWal), WAL_WRITE_LOCK, 1)
# define sqlite3WalDb(pWal, db)
#endif
static int walBusyLock(  Wal *pWal,  int (*xBusy)(void*),  void *pBusyArg,  int lockIdx,  int n ){  int rc;  do {  rc = walLockExclusive(pWal, lockIdx, n);  }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 if( rc==SQLITE_BUSY_TIMEOUT ){  walDisableBlocking(pWal);  rc = SQLITE_BUSY;  }
#endif
 return rc; } static int walPagesize(Wal *pWal){  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16); } static void walRestartHdr(Wal *pWal, u32 salt1){  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);  int i;  u32 *aSalt = pWal->hdr.aSalt;  pWal->nCkpt++;  pWal->hdr.mxFrame = 0;  sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);  walIndexWriteHdr(pWal);  AtomicStore(&pInfo->nBackfill, 0);  pInfo->nBackfillAttempted = 0;  pInfo->aReadMark[1] = 0;  for(i=2; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;  assert( pInfo->aReadMark[0]==0 ); } static int walCheckpoint(  Wal *pWal,  sqlite3 *db,  int eMode,  int (*xBusy)(void*),  void *pBusyArg,  int sync_flags,  u8 *zBuf ){  int rc = SQLITE_OK;  int szPage;  WalIterator *pIter = 0;  u32 iDbpage = 0;  u32 iFrame = 0;  u32 mxSafeFrame;  u32 mxPage;  int i;  volatile WalCkptInfo *pInfo;  szPage = walPagesize(pWal);  testcase( szPage<=32768 );  testcase( szPage>=65536 );  pInfo = walCkptInfo(pWal);  if( pInfo->nBackfill<pWal->hdr.mxFrame ){  assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );  mxSafeFrame = pWal->hdr.mxFrame;  mxPage = pWal->hdr.nPage;  for(i=1; i<WAL_NREADER; i++){  u32 y = AtomicLoad(pInfo->aReadMark+i);  if( mxSafeFrame>y ){  assert( y<=pWal->hdr.mxFrame );  rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);  if( rc==SQLITE_OK ){  u32 iMark = (i==1 ? mxSafeFrame : READMARK_NOT_USED);  AtomicStore(pInfo->aReadMark+i, iMark);  walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);  }else if( rc==SQLITE_BUSY ){  mxSafeFrame = y;  xBusy = 0;  }else{  goto walcheckpoint_out;  }  }  }  if( pInfo->nBackfill<mxSafeFrame ){  rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);  assert( rc==SQLITE_OK || pIter==0 );  }  if( pIter   && (rc = walBusyLock(pWal,xBusy,pBusyArg,WAL_READ_LOCK(0),1))==SQLITE_OK  ){  u32 nBackfill = pInfo->nBackfill;  pInfo->nBackfillAttempted = mxSafeFrame;  rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));  if( rc==SQLITE_OK ){  i64 nReq = ((i64)mxPage * szPage);  i64 nSize;  sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_START, 0);  rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);  if( rc==SQLITE_OK && nSize<nReq ){  if( (nSize+65536+(i64)pWal->hdr.mxFrame*szPage)<nReq ){  rc = SQLITE_CORRUPT_BKPT;  }else{  sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT,&nReq);  }  }  }  while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){  i64 iOffset;  assert( walFramePgno(pWal, iFrame)==iDbpage );  if( AtomicLoad(&db->u1.isInterrupted) ){  rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;  break;  }  if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){  continue;  }  iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;  rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);  if( rc!=SQLITE_OK ) break;  iOffset = (iDbpage-1)*(i64)szPage;  testcase( IS_BIG_INT(iOffset) );  rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);  if( rc!=SQLITE_OK ) break;  }  sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_DONE, 0);  if( rc==SQLITE_OK ){  if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){  i64 szDb = pWal->hdr.nPage*(i64)szPage;  testcase( IS_BIG_INT(szDb) );  rc = sqlite3OsTruncate(pWal->pDbFd, szDb);  if( rc==SQLITE_OK ){  rc = sqlite3OsSync(pWal->pDbFd, CKPT_SYNC_FLAGS(sync_flags));  }  }  if( rc==SQLITE_OK ){  AtomicStore(&pInfo->nBackfill, mxSafeFrame);  }  }  walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);  }  if( rc==SQLITE_BUSY ){  rc = SQLITE_OK;  }  }  if( rc==SQLITE_OK && eMode!=SQLITE_CHECKPOINT_PASSIVE ){  assert( pWal->writeLock );  if( pInfo->nBackfill<pWal->hdr.mxFrame ){  rc = SQLITE_BUSY;  }else if( eMode>=SQLITE_CHECKPOINT_RESTART ){  u32 salt1;  sqlite3_randomness(4, &salt1);  assert( pInfo->nBackfill==pWal->hdr.mxFrame );  rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);  if( rc==SQLITE_OK ){  if( eMode==SQLITE_CHECKPOINT_TRUNCATE ){  walRestartHdr(pWal, salt1);  rc = sqlite3OsTruncate(pWal->pWalFd, 0);  }  walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);  }  }  }  walcheckpoint_out:  walIteratorFree(pIter);  return rc; } static void walLimitSize(Wal *pWal, i64 nMax){  i64 sz;  int rx;  sqlite3BeginBenignMalloc();  rx = sqlite3OsFileSize(pWal->pWalFd, &sz);  if( rx==SQLITE_OK && (sz > nMax ) ){  rx = sqlite3OsTruncate(pWal->pWalFd, nMax);  }  sqlite3EndBenignMalloc();  if( rx ){  sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);  } } SQLITE_PRIVATE int sqlite3WalClose(  Wal *pWal,  sqlite3 *db,  int sync_flags,  int nBuf,  u8 *zBuf ){  int rc = SQLITE_OK;  if( pWal ){  int isDelete = 0;  if( zBuf!=0   && SQLITE_OK==(rc = sqlite3OsLock(pWal->pDbFd, SQLITE_LOCK_EXCLUSIVE))  ){  if( pWal->exclusiveMode==WAL_NORMAL_MODE ){  pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;  }  rc = sqlite3WalCheckpoint(pWal, db,  SQLITE_CHECKPOINT_PASSIVE, 0, 0, sync_flags, nBuf, zBuf, 0, 0  );  if( rc==SQLITE_OK ){  int bPersist = -1;  sqlite3OsFileControlHint(  pWal->pDbFd, SQLITE_FCNTL_PERSIST_WAL, &bPersist  );  if( bPersist!=1 ){  isDelete = 1;  }else if( pWal->mxWalSize>=0 ){  walLimitSize(pWal, 0);  }  }  }  walIndexClose(pWal, isDelete);  sqlite3OsClose(pWal->pWalFd);  if( isDelete ){  sqlite3BeginBenignMalloc();  sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);  sqlite3EndBenignMalloc();  }  WALTRACE(("WAL%p: closed\n", pWal));  sqlite3_free((void *)pWal->apWiData);  sqlite3_free(pWal);  }  return rc; } static SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged){  u32 aCksum[2];  WalIndexHdr h1, h2;  WalIndexHdr volatile *aHdr;  assert( pWal->nWiData>0 && pWal->apWiData[0] );  aHdr = walIndexHdr(pWal);  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));  walShmBarrier(pWal);  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){  return 1;  }  if( h1.isInit==0 ){  return 1;  }  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){  return 1;  }  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){  *pChanged = 1;  memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));  pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);  testcase( pWal->szPage<=32768 );  testcase( pWal->szPage>=65536 );  }  return 0; }
#define WAL_RETRY (-1)
static int walIndexReadHdr(Wal *pWal, int *pChanged){  int rc;  int badHdr;  volatile u32 *page0;  assert( pChanged );  rc = walIndexPage(pWal, 0, &page0);  if( rc!=SQLITE_OK ){  assert( rc!=SQLITE_READONLY );  if( rc==SQLITE_READONLY_CANTINIT ){  assert( page0==0 );  assert( pWal->writeLock==0 );  assert( pWal->readOnly & WAL_SHM_RDONLY );  pWal->bShmUnreliable = 1;  pWal->exclusiveMode = WAL_HEAPMEMORY_MODE;  *pChanged = 1;  }else{  return rc;  }  }else{  testcase( page0!=0 );  }  assert( page0!=0 || pWal->writeLock==0 );  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);  if( badHdr ){  if( pWal->bShmUnreliable==0 && (pWal->readOnly & WAL_SHM_RDONLY) ){  if( SQLITE_OK==(rc = walLockShared(pWal, WAL_WRITE_LOCK)) ){  walUnlockShared(pWal, WAL_WRITE_LOCK);  rc = SQLITE_READONLY_RECOVERY;  }  }else{  int bWriteLock = pWal->writeLock;  if( bWriteLock || SQLITE_OK==(rc = walLockWriter(pWal)) ){  pWal->writeLock = 1;  if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){  badHdr = walIndexTryHdr(pWal, pChanged);  if( badHdr ){  rc = walIndexRecover(pWal);  *pChanged = 1;  }  }  if( bWriteLock==0 ){  pWal->writeLock = 0;  walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);  }  }  }  }  if( badHdr==0 && pWal->hdr.iVersion!=WALINDEX_MAX_VERSION ){  rc = SQLITE_CANTOPEN_BKPT;  }  if( pWal->bShmUnreliable ){  if( rc!=SQLITE_OK ){  walIndexClose(pWal, 0);  pWal->bShmUnreliable = 0;  assert( pWal->nWiData>0 && pWal->apWiData[0]==0 );  if( rc==SQLITE_IOERR_SHORT_READ ) rc = WAL_RETRY;  }  pWal->exclusiveMode = WAL_NORMAL_MODE;  }  return rc; } static int walBeginShmUnreliable(Wal *pWal, int *pChanged){  i64 szWal;  i64 iOffset;  u8 aBuf[WAL_HDRSIZE];  u8 *aFrame = 0;  int szFrame;  u8 *aData;  volatile void *pDummy;  int rc;  u32 aSaveCksum[2];  assert( pWal->bShmUnreliable );  assert( pWal->readOnly & WAL_SHM_RDONLY );  assert( pWal->nWiData>0 && pWal->apWiData[0] );  rc = walLockShared(pWal, WAL_READ_LOCK(0));  if( rc!=SQLITE_OK ){  if( rc==SQLITE_BUSY ) rc = WAL_RETRY;  goto begin_unreliable_shm_out;  }  pWal->readLock = 0;  rc = sqlite3OsShmMap(pWal->pDbFd, 0, WALINDEX_PGSZ, 0, &pDummy);  assert( rc!=SQLITE_OK );  if( rc!=SQLITE_READONLY_CANTINIT ){  rc = (rc==SQLITE_READONLY ? WAL_RETRY : rc);  goto begin_unreliable_shm_out;  }  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));  rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);  if( rc!=SQLITE_OK ){  goto begin_unreliable_shm_out;  }  if( szWal<WAL_HDRSIZE ){  *pChanged = 1;  rc = (pWal->hdr.mxFrame==0 ? SQLITE_OK : WAL_RETRY);  goto begin_unreliable_shm_out;  }  rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);  if( rc!=SQLITE_OK ){  goto begin_unreliable_shm_out;  }  if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){  rc = WAL_RETRY;  goto begin_unreliable_shm_out;  }  szFrame = pWal->hdr.szPage + WAL_FRAME_HDRSIZE;  aFrame = (u8 *)sqlite3_malloc64(szFrame);  if( aFrame==0 ){  rc = SQLITE_NOMEM_BKPT;  goto begin_unreliable_shm_out;  }  aData = &aFrame[WAL_FRAME_HDRSIZE];  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];  for(iOffset=walFrameOffset(pWal->hdr.mxFrame+1, pWal->hdr.szPage);  iOffset+szFrame<=szWal;  iOffset+=szFrame  ){  u32 pgno;  u32 nTruncate;  rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);  if( rc!=SQLITE_OK ) break;  if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break;  if( nTruncate ){  rc = WAL_RETRY;  break;  }  }  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];  pWal->hdr.aFrameCksum[1] = aSaveCksum[1];  begin_unreliable_shm_out:  sqlite3_free(aFrame);  if( rc!=SQLITE_OK ){  int i;  for(i=0; i<pWal->nWiData; i++){  sqlite3_free((void*)pWal->apWiData[i]);  pWal->apWiData[i] = 0;  }  pWal->bShmUnreliable = 0;  sqlite3WalEndReadTransaction(pWal);  *pChanged = 1;  }  return rc; } static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){  volatile WalCkptInfo *pInfo;  u32 mxReadMark;  int mxI;  int i;  int rc = SQLITE_OK;  u32 mxFrame;  assert( pWal->readLock<0 );  assert( (pWal->readOnly & WAL_SHM_RDONLY)==0 || useWal==0 );  if( cnt>5 ){  int nDelay = 1;  if( cnt>100 ){  VVA_ONLY( pWal->lockError = 1; )  return SQLITE_PROTOCOL;  }  if( cnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;  sqlite3OsSleep(pWal->pVfs, nDelay);  }  if( !useWal ){  assert( rc==SQLITE_OK );  if( pWal->bShmUnreliable==0 ){  rc = walIndexReadHdr(pWal, pChanged);  }  if( rc==SQLITE_BUSY ){  if( pWal->apWiData[0]==0 ){  rc = WAL_RETRY;  }else if( SQLITE_OK==(rc = walLockShared(pWal, WAL_RECOVER_LOCK)) ){  walUnlockShared(pWal, WAL_RECOVER_LOCK);  rc = WAL_RETRY;  }else if( rc==SQLITE_BUSY ){  rc = SQLITE_BUSY_RECOVERY;  }  }  if( rc!=SQLITE_OK ){  return rc;  }  else if( pWal->bShmUnreliable ){  return walBeginShmUnreliable(pWal, pChanged);  }  }  assert( pWal->nWiData>0 );  assert( pWal->apWiData[0]!=0 );  pInfo = walCkptInfo(pWal);  if( !useWal && AtomicLoad(&pInfo->nBackfill)==pWal->hdr.mxFrame
#ifdef SQLITE_ENABLE_SNAPSHOT
  && (pWal->pSnapshot==0 || pWal->hdr.mxFrame==0)
#endif
 ){  rc = walLockShared(pWal, WAL_READ_LOCK(0));  walShmBarrier(pWal);  if( rc==SQLITE_OK ){  if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){  walUnlockShared(pWal, WAL_READ_LOCK(0));  return WAL_RETRY;  }  pWal->readLock = 0;  return SQLITE_OK;  }else if( rc!=SQLITE_BUSY ){  return rc;  }  }  mxReadMark = 0;  mxI = 0;  mxFrame = pWal->hdr.mxFrame;
#ifdef SQLITE_ENABLE_SNAPSHOT
 if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){  mxFrame = pWal->pSnapshot->mxFrame;  }
#endif
 for(i=1; i<WAL_NREADER; i++){  u32 thisMark = AtomicLoad(pInfo->aReadMark+i);  if( mxReadMark<=thisMark && thisMark<=mxFrame ){  assert( thisMark!=READMARK_NOT_USED );  mxReadMark = thisMark;  mxI = i;  }  }  if( (pWal->readOnly & WAL_SHM_RDONLY)==0   && (mxReadMark<mxFrame || mxI==0)  ){  for(i=1; i<WAL_NREADER; i++){  rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);  if( rc==SQLITE_OK ){  AtomicStore(pInfo->aReadMark+i,mxFrame);  mxReadMark = mxFrame;  mxI = i;  walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);  break;  }else if( rc!=SQLITE_BUSY ){  return rc;  }  }  }  if( mxI==0 ){  assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );  return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;  }  rc = walLockShared(pWal, WAL_READ_LOCK(mxI));  if( rc ){  return rc==SQLITE_BUSY ? WAL_RETRY : rc;  }  pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1;  walShmBarrier(pWal);  if( AtomicLoad(pInfo->aReadMark+mxI)!=mxReadMark   || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))  ){  walUnlockShared(pWal, WAL_READ_LOCK(mxI));  return WAL_RETRY;  }else{  assert( mxReadMark<=pWal->hdr.mxFrame );  pWal->readLock = (i16)mxI;  }  return rc; }
#ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE int sqlite3WalSnapshotRecover(Wal *pWal){  int rc;  assert( pWal->readLock>=0 );  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);  if( rc==SQLITE_OK ){  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);  int szPage = (int)pWal->szPage;  i64 szDb;  rc = sqlite3OsFileSize(pWal->pDbFd, &szDb);  if( rc==SQLITE_OK ){  void *pBuf1 = sqlite3_malloc(szPage);  void *pBuf2 = sqlite3_malloc(szPage);  if( pBuf1==0 || pBuf2==0 ){  rc = SQLITE_NOMEM;  }else{  u32 i = pInfo->nBackfillAttempted;  for(i=pInfo->nBackfillAttempted; i>AtomicLoad(&pInfo->nBackfill); i--){  WalHashLoc sLoc;  u32 pgno;  i64 iDbOff;  i64 iWalOff;  rc = walHashGet(pWal, walFramePage(i), &sLoc);  if( rc!=SQLITE_OK ) break;  assert( i - sLoc.iZero - 1 >=0 );  pgno = sLoc.aPgno[i-sLoc.iZero-1];  iDbOff = (i64)(pgno-1) * szPage;  if( iDbOff+szPage<=szDb ){  iWalOff = walFrameOffset(i, szPage) + WAL_FRAME_HDRSIZE;  rc = sqlite3OsRead(pWal->pWalFd, pBuf1, szPage, iWalOff);  if( rc==SQLITE_OK ){  rc = sqlite3OsRead(pWal->pDbFd, pBuf2, szPage, iDbOff);  }  if( rc!=SQLITE_OK || 0==memcmp(pBuf1, pBuf2, szPage) ){  break;  }  }  pInfo->nBackfillAttempted = i-1;  }  }  sqlite3_free(pBuf1);  sqlite3_free(pBuf2);  }  walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);  }  return rc; }
#endif
SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){  int rc;  int cnt = 0;
#ifdef SQLITE_ENABLE_SNAPSHOT
 int bChanged = 0;  WalIndexHdr *pSnapshot = pWal->pSnapshot;
#endif
 assert( pWal->ckptLock==0 );
#ifdef SQLITE_ENABLE_SNAPSHOT
 if( pSnapshot ){  if( memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){  bChanged = 1;  }  (void)walEnableBlocking(pWal);  rc = walLockShared(pWal, WAL_CKPT_LOCK);  walDisableBlocking(pWal);  if( rc!=SQLITE_OK ){  return rc;  }  pWal->ckptLock = 1;  }
#endif
 do{  rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);  }while( rc==WAL_RETRY );  testcase( (rc&0xff)==SQLITE_BUSY );  testcase( (rc&0xff)==SQLITE_IOERR );  testcase( rc==SQLITE_PROTOCOL );  testcase( rc==SQLITE_OK );
#ifdef SQLITE_ENABLE_SNAPSHOT
 if( rc==SQLITE_OK ){  if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);  assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );  assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame );  if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))   && pSnapshot->mxFrame>=pInfo->nBackfillAttempted  ){  assert( pWal->readLock>0 );  memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));  *pChanged = bChanged;  }else{  rc = SQLITE_ERROR_SNAPSHOT;  }  pWal->minFrame = 1;  if( rc!=SQLITE_OK ){  sqlite3WalEndReadTransaction(pWal);  }  }  }  if( pWal->ckptLock ){  assert( pSnapshot );  walUnlockShared(pWal, WAL_CKPT_LOCK);  pWal->ckptLock = 0;  }
#endif
 return rc; } SQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal){  sqlite3WalEndWriteTransaction(pWal);  if( pWal->readLock>=0 ){  walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));  pWal->readLock = -1;  } } SQLITE_PRIVATE int sqlite3WalFindFrame(  Wal *pWal,  Pgno pgno,  u32 *piRead ){  u32 iRead = 0;  u32 iLast = pWal->hdr.mxFrame;  int iHash;  int iMinHash;  assert( pWal->readLock>=0 || pWal->lockError );  if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){  *piRead = 0;  return SQLITE_OK;  }  iMinHash = walFramePage(pWal->minFrame);  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){  WalHashLoc sLoc;  int iKey;  int nCollide;  int rc;  u32 iH;  rc = walHashGet(pWal, iHash, &sLoc);  if( rc!=SQLITE_OK ){  return rc;  }  nCollide = HASHTABLE_NSLOT;  iKey = walHash(pgno);  while( (iH = AtomicLoad(&sLoc.aHash[iKey]))!=0 ){  u32 iFrame = iH + sLoc.iZero;  if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH-1]==pgno ){  assert( iFrame>iRead || CORRUPT_DB );  iRead = iFrame;  }  if( (nCollide--)==0 ){  return SQLITE_CORRUPT_BKPT;  }  iKey = walNextHash(iKey);  }  if( iRead ) break;  }
#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
 {  u32 iRead2 = 0;  u32 iTest;  assert( pWal->bShmUnreliable || pWal->minFrame>0 );  for(iTest=iLast; iTest>=pWal->minFrame && iTest>0; iTest--){  if( walFramePgno(pWal, iTest)==pgno ){  iRead2 = iTest;  break;  }  }  assert( iRead==iRead2 );  }
#endif
 *piRead = iRead;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3WalReadFrame(  Wal *pWal,  u32 iRead,  int nOut,  u8 *pOut ){  int sz;  i64 iOffset;  sz = pWal->hdr.szPage;  sz = (sz&0xfe00) + ((sz&0x0001)<<16);  testcase( sz<=32768 );  testcase( sz>=65536 );  iOffset = walFrameOffset(iRead, sz) + WAL_FRAME_HDRSIZE;  return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset); } SQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal){  if( pWal && ALWAYS(pWal->readLock>=0) ){  return pWal->hdr.nPage;  }  return 0; } SQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){  int rc;
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 if( pWal->writeLock ){  assert( !memcmp(&pWal->hdr,(void *)walIndexHdr(pWal),sizeof(WalIndexHdr)) );  return SQLITE_OK;  }
#endif
 assert( pWal->readLock>=0 );  assert( pWal->writeLock==0 && pWal->iReCksum==0 );  if( pWal->readOnly ){  return SQLITE_READONLY;  }  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);  if( rc ){  return rc;  }  pWal->writeLock = 1;  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){  walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);  pWal->writeLock = 0;  rc = SQLITE_BUSY_SNAPSHOT;  }  return rc; } SQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal){  if( pWal->writeLock ){  walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);  pWal->writeLock = 0;  pWal->iReCksum = 0;  pWal->truncateOnCommit = 0;  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){  int rc = SQLITE_OK;  if( ALWAYS(pWal->writeLock) ){  Pgno iMax = pWal->hdr.mxFrame;  Pgno iFrame;  memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));  for(iFrame=pWal->hdr.mxFrame+1;  ALWAYS(rc==SQLITE_OK) && iFrame<=iMax;  iFrame++  ){  assert( walFramePgno(pWal, iFrame)!=1 );  rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));  }  if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);  }  return rc; } SQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){  assert( pWal->writeLock );  aWalData[0] = pWal->hdr.mxFrame;  aWalData[1] = pWal->hdr.aFrameCksum[0];  aWalData[2] = pWal->hdr.aFrameCksum[1];  aWalData[3] = pWal->nCkpt; } SQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){  int rc = SQLITE_OK;  assert( pWal->writeLock );  assert( aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame );  if( aWalData[3]!=pWal->nCkpt ){  aWalData[0] = 0;  aWalData[3] = pWal->nCkpt;  }  if( aWalData[0]<pWal->hdr.mxFrame ){  pWal->hdr.mxFrame = aWalData[0];  pWal->hdr.aFrameCksum[0] = aWalData[1];  pWal->hdr.aFrameCksum[1] = aWalData[2];  walCleanupHash(pWal);  }  return rc; } static int walRestartLog(Wal *pWal){  int rc = SQLITE_OK;  int cnt;  if( pWal->readLock==0 ){  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);  assert( pInfo->nBackfill==pWal->hdr.mxFrame );  if( pInfo->nBackfill>0 ){  u32 salt1;  sqlite3_randomness(4, &salt1);  rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);  if( rc==SQLITE_OK ){  walRestartHdr(pWal, salt1);  walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);  }else if( rc!=SQLITE_BUSY ){  return rc;  }  }  walUnlockShared(pWal, WAL_READ_LOCK(0));  pWal->readLock = -1;  cnt = 0;  do{  int notUsed;  rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);  }while( rc==WAL_RETRY );  assert( (rc&0xff)!=SQLITE_BUSY );  testcase( (rc&0xff)==SQLITE_IOERR );  testcase( rc==SQLITE_PROTOCOL );  testcase( rc==SQLITE_OK );  }  return rc; } typedef struct WalWriter {  Wal *pWal;  sqlite3_file *pFd;  sqlite3_int64 iSyncPoint;  int syncFlags;  int szPage; } WalWriter; static int walWriteToLog(  WalWriter *p,  void *pContent,  int iAmt,  sqlite3_int64 iOffset ){  int rc;  if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){  int iFirstAmt = (int)(p->iSyncPoint - iOffset);  rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);  if( rc ) return rc;  iOffset += iFirstAmt;  iAmt -= iFirstAmt;  pContent = (void*)(iFirstAmt + (char*)pContent);  assert( WAL_SYNC_FLAGS(p->syncFlags)!=0 );  rc = sqlite3OsSync(p->pFd, WAL_SYNC_FLAGS(p->syncFlags));  if( iAmt==0 || rc ) return rc;  }  rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);  return rc; } static int walWriteOneFrame(  WalWriter *p,  PgHdr *pPage,  int nTruncate,  sqlite3_int64 iOffset ){  int rc;  void *pData;  u8 aFrame[WAL_FRAME_HDRSIZE];  pData = pPage->pData;  walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);  rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);  if( rc ) return rc;  rc = walWriteToLog(p, pData, p->szPage, iOffset+sizeof(aFrame));  return rc; } static int walRewriteChecksums(Wal *pWal, u32 iLast){  const int szPage = pWal->szPage;  int rc = SQLITE_OK;  u8 *aBuf;  u8 aFrame[WAL_FRAME_HDRSIZE];  u32 iRead;  i64 iCksumOff;  aBuf = sqlite3_malloc(szPage + WAL_FRAME_HDRSIZE);  if( aBuf==0 ) return SQLITE_NOMEM_BKPT;  assert( pWal->iReCksum>0 );  if( pWal->iReCksum==1 ){  iCksumOff = 24;  }else{  iCksumOff = walFrameOffset(pWal->iReCksum-1, szPage) + 16;  }  rc = sqlite3OsRead(pWal->pWalFd, aBuf, sizeof(u32)*2, iCksumOff);  pWal->hdr.aFrameCksum[0] = sqlite3Get4byte(aBuf);  pWal->hdr.aFrameCksum[1] = sqlite3Get4byte(&aBuf[sizeof(u32)]);  iRead = pWal->iReCksum;  pWal->iReCksum = 0;  for(; rc==SQLITE_OK && iRead<=iLast; iRead++){  i64 iOff = walFrameOffset(iRead, szPage);  rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage+WAL_FRAME_HDRSIZE, iOff);  if( rc==SQLITE_OK ){  u32 iPgno, nDbSize;  iPgno = sqlite3Get4byte(aBuf);  nDbSize = sqlite3Get4byte(&aBuf[4]);  walEncodeFrame(pWal, iPgno, nDbSize, &aBuf[WAL_FRAME_HDRSIZE], aFrame);  rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOff);  }  }  sqlite3_free(aBuf);  return rc; } SQLITE_PRIVATE int sqlite3WalFrames(  Wal *pWal,  int szPage,  PgHdr *pList,  Pgno nTruncate,  int isCommit,  int sync_flags ){  int rc;  u32 iFrame;  PgHdr *p;  PgHdr *pLast = 0;  int nExtra = 0;  int szFrame;  i64 iOffset;  WalWriter w;  u32 iFirst = 0;  WalIndexHdr *pLive;  assert( pList );  assert( pWal->writeLock );  assert( (isCommit!=0)==(nTruncate!=0) );
#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)
 { int cnt; for(cnt=0, p=pList; p; p=p->pDirty, cnt++){}  WALTRACE(("WAL%p: frame write begin. %d frames. mxFrame=%d. %s\n",  pWal, cnt, pWal->hdr.mxFrame, isCommit ? "Commit" : "Spill"));  }
#endif
 pLive = (WalIndexHdr*)walIndexHdr(pWal);  if( memcmp(&pWal->hdr, (void *)pLive, sizeof(WalIndexHdr))!=0 ){  iFirst = pLive->mxFrame+1;  }  if( SQLITE_OK!=(rc = walRestartLog(pWal)) ){  return rc;  }  iFrame = pWal->hdr.mxFrame;  if( iFrame==0 ){  u8 aWalHdr[WAL_HDRSIZE];  u32 aCksum[2];  sqlite3Put4byte(&aWalHdr[0], (WAL_MAGIC | SQLITE_BIGENDIAN));  sqlite3Put4byte(&aWalHdr[4], WAL_MAX_VERSION);  sqlite3Put4byte(&aWalHdr[8], szPage);  sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);  if( pWal->nCkpt==0 ) sqlite3_randomness(8, pWal->hdr.aSalt);  memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);  walChecksumBytes(1, aWalHdr, WAL_HDRSIZE-2*4, 0, aCksum);  sqlite3Put4byte(&aWalHdr[24], aCksum[0]);  sqlite3Put4byte(&aWalHdr[28], aCksum[1]);  pWal->szPage = szPage;  pWal->hdr.bigEndCksum = SQLITE_BIGENDIAN;  pWal->hdr.aFrameCksum[0] = aCksum[0];  pWal->hdr.aFrameCksum[1] = aCksum[1];  pWal->truncateOnCommit = 1;  rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);  WALTRACE(("WAL%p: wal-header write %s\n", pWal, rc ? "failed" : "ok"));  if( rc!=SQLITE_OK ){  return rc;  }  if( pWal->syncHeader ){  rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));  if( rc ) return rc;  }  }  assert( (int)pWal->szPage==szPage );  w.pWal = pWal;  w.pFd = pWal->pWalFd;  w.iSyncPoint = 0;  w.syncFlags = sync_flags;  w.szPage = szPage;  iOffset = walFrameOffset(iFrame+1, szPage);  szFrame = szPage + WAL_FRAME_HDRSIZE;  for(p=pList; p; p=p->pDirty){  int nDbSize;  if( iFirst && (p->pDirty || isCommit==0) ){  u32 iWrite = 0;  VVA_ONLY(rc =) sqlite3WalFindFrame(pWal, p->pgno, &iWrite);  assert( rc==SQLITE_OK || iWrite==0 );  if( iWrite>=iFirst ){  i64 iOff = walFrameOffset(iWrite, szPage) + WAL_FRAME_HDRSIZE;  void *pData;  if( pWal->iReCksum==0 || iWrite<pWal->iReCksum ){  pWal->iReCksum = iWrite;  }  pData = p->pData;  rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOff);  if( rc ) return rc;  p->flags &= ~PGHDR_WAL_APPEND;  continue;  }  }  iFrame++;  assert( iOffset==walFrameOffset(iFrame, szPage) );  nDbSize = (isCommit && p->pDirty==0) ? nTruncate : 0;  rc = walWriteOneFrame(&w, p, nDbSize, iOffset);  if( rc ) return rc;  pLast = p;  iOffset += szFrame;  p->flags |= PGHDR_WAL_APPEND;  }  if( isCommit && pWal->iReCksum ){  rc = walRewriteChecksums(pWal, iFrame);  if( rc ) return rc;  }  if( isCommit && WAL_SYNC_FLAGS(sync_flags)!=0 ){  int bSync = 1;  if( pWal->padToSectorBoundary ){  int sectorSize = sqlite3SectorSize(pWal->pWalFd);  w.iSyncPoint = ((iOffset+sectorSize-1)/sectorSize)*sectorSize;  bSync = (w.iSyncPoint==iOffset);  testcase( bSync );  while( iOffset<w.iSyncPoint ){  rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);  if( rc ) return rc;  iOffset += szFrame;  nExtra++;  assert( pLast!=0 );  }  }  if( bSync ){  assert( rc==SQLITE_OK );  rc = sqlite3OsSync(w.pFd, WAL_SYNC_FLAGS(sync_flags));  }  }  if( isCommit && pWal->truncateOnCommit && pWal->mxWalSize>=0 ){  i64 sz = pWal->mxWalSize;  if( walFrameOffset(iFrame+nExtra+1, szPage)>pWal->mxWalSize ){  sz = walFrameOffset(iFrame+nExtra+1, szPage);  }  walLimitSize(pWal, sz);  pWal->truncateOnCommit = 0;  }  iFrame = pWal->hdr.mxFrame;  for(p=pList; p && rc==SQLITE_OK; p=p->pDirty){  if( (p->flags & PGHDR_WAL_APPEND)==0 ) continue;  iFrame++;  rc = walIndexAppend(pWal, iFrame, p->pgno);  }  assert( pLast!=0 || nExtra==0 );  while( rc==SQLITE_OK && nExtra>0 ){  iFrame++;  nExtra--;  rc = walIndexAppend(pWal, iFrame, pLast->pgno);  }  if( rc==SQLITE_OK ){  pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));  testcase( szPage<=32768 );  testcase( szPage>=65536 );  pWal->hdr.mxFrame = iFrame;  if( isCommit ){  pWal->hdr.iChange++;  pWal->hdr.nPage = nTruncate;  }  if( isCommit ){  walIndexWriteHdr(pWal);  pWal->iCallback = iFrame;  }  }  WALTRACE(("WAL%p: frame write %s\n", pWal, rc ? "failed" : "ok"));  return rc; } SQLITE_PRIVATE int sqlite3WalCheckpoint(  Wal *pWal,  sqlite3 *db,  int eMode,  int (*xBusy)(void*),  void *pBusyArg,  int sync_flags,  int nBuf,  u8 *zBuf,  int *pnLog,  int *pnCkpt ){  int rc;  int isChanged = 0;  int eMode2 = eMode;  int (*xBusy2)(void*) = xBusy;  assert( pWal->ckptLock==0 );  assert( pWal->writeLock==0 );  assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );  if( pWal->readOnly ) return SQLITE_READONLY;  WALTRACE(("WAL%p: checkpoint begins\n", pWal));  sqlite3WalDb(pWal, db);  (void)walEnableBlocking(pWal);  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);  testcase( rc==SQLITE_BUSY );  testcase( rc!=SQLITE_OK && xBusy2!=0 );  if( rc==SQLITE_OK ){  pWal->ckptLock = 1;  if( eMode!=SQLITE_CHECKPOINT_PASSIVE ){  rc = walBusyLock(pWal, xBusy2, pBusyArg, WAL_WRITE_LOCK, 1);  if( rc==SQLITE_OK ){  pWal->writeLock = 1;  }else if( rc==SQLITE_BUSY ){  eMode2 = SQLITE_CHECKPOINT_PASSIVE;  xBusy2 = 0;  rc = SQLITE_OK;  }  }  }  if( rc==SQLITE_OK ){  walDisableBlocking(pWal);  rc = walIndexReadHdr(pWal, &isChanged);  (void)walEnableBlocking(pWal);  if( isChanged && pWal->pDbFd->pMethods->iVersion>=3 ){  sqlite3OsUnfetch(pWal->pDbFd, 0, 0);  }  }  if( rc==SQLITE_OK ){  if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){  rc = SQLITE_CORRUPT_BKPT;  }else{  rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);  }  if( rc==SQLITE_OK || rc==SQLITE_BUSY ){  if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;  if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);  }  }  if( isChanged ){  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));  }  walDisableBlocking(pWal);  sqlite3WalDb(pWal, 0);  sqlite3WalEndWriteTransaction(pWal);  if( pWal->ckptLock ){  walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);  pWal->ckptLock = 0;  }  WALTRACE(("WAL%p: checkpoint %s\n", pWal, rc ? "failed" : "ok"));
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 if( rc==SQLITE_BUSY_TIMEOUT ) rc = SQLITE_BUSY;
#endif
 return (rc==SQLITE_OK && eMode!=eMode2 ? SQLITE_BUSY : rc); } SQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal){  u32 ret = 0;  if( pWal ){  ret = pWal->iCallback;  pWal->iCallback = 0;  }  return (int)ret; } SQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op){  int rc;  assert( pWal->writeLock==0 );  assert( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE || op==-1 );  assert( pWal->readLock>=0 || pWal->lockError );  assert( pWal->readLock>=0 || (op<=0 && pWal->exclusiveMode==0) );  if( op==0 ){  if( pWal->exclusiveMode!=WAL_NORMAL_MODE ){  pWal->exclusiveMode = WAL_NORMAL_MODE;  if( walLockShared(pWal, WAL_READ_LOCK(pWal->readLock))!=SQLITE_OK ){  pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;  }  rc = pWal->exclusiveMode==WAL_NORMAL_MODE;  }else{  rc = 0;  }  }else if( op>0 ){  assert( pWal->exclusiveMode==WAL_NORMAL_MODE );  assert( pWal->readLock>=0 );  walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));  pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;  rc = 1;  }else{  rc = pWal->exclusiveMode==WAL_NORMAL_MODE;  }  return rc; } SQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal){  return (pWal && pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ); }
#ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_PRIVATE int sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot){  int rc = SQLITE_OK;  WalIndexHdr *pRet;  static const u32 aZero[4] = { 0, 0, 0, 0 };  assert( pWal->readLock>=0 && pWal->writeLock==0 );  if( memcmp(&pWal->hdr.aFrameCksum[0],aZero,16)==0 ){  *ppSnapshot = 0;  return SQLITE_ERROR;  }  pRet = (WalIndexHdr*)sqlite3_malloc(sizeof(WalIndexHdr));  if( pRet==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  memcpy(pRet, &pWal->hdr, sizeof(WalIndexHdr));  *ppSnapshot = (sqlite3_snapshot*)pRet;  }  return rc; } SQLITE_PRIVATE void sqlite3WalSnapshotOpen(  Wal *pWal,  sqlite3_snapshot *pSnapshot ){  pWal->pSnapshot = (WalIndexHdr*)pSnapshot; } SQLITE_API int sqlite3_snapshot_cmp(sqlite3_snapshot *p1, sqlite3_snapshot *p2){  WalIndexHdr *pHdr1 = (WalIndexHdr*)p1;  WalIndexHdr *pHdr2 = (WalIndexHdr*)p2;  if( pHdr1->aSalt[0]<pHdr2->aSalt[0] ) return -1;  if( pHdr1->aSalt[0]>pHdr2->aSalt[0] ) return +1;  if( pHdr1->mxFrame<pHdr2->mxFrame ) return -1;  if( pHdr1->mxFrame>pHdr2->mxFrame ) return +1;  return 0; } SQLITE_PRIVATE int sqlite3WalSnapshotCheck(Wal *pWal, sqlite3_snapshot *pSnapshot){  int rc;  rc = walLockShared(pWal, WAL_CKPT_LOCK);  if( rc==SQLITE_OK ){  WalIndexHdr *pNew = (WalIndexHdr*)pSnapshot;  if( memcmp(pNew->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))   || pNew->mxFrame<walCkptInfo(pWal)->nBackfillAttempted  ){  rc = SQLITE_ERROR_SNAPSHOT;  walUnlockShared(pWal, WAL_CKPT_LOCK);  }  }  return rc; } SQLITE_PRIVATE void sqlite3WalSnapshotUnlock(Wal *pWal){  assert( pWal );  walUnlockShared(pWal, WAL_CKPT_LOCK); }
#endif
#ifdef SQLITE_ENABLE_ZIPVFS
SQLITE_PRIVATE int sqlite3WalFramesize(Wal *pWal){  assert( pWal==0 || pWal->readLock>=0 );  return (pWal ? pWal->szPage : 0); }
#endif
SQLITE_PRIVATE sqlite3_file *sqlite3WalFile(Wal *pWal){  return pWal->pWalFd; }
#endif
#define MX_CELL_SIZE(pBt) ((int)(pBt->pageSize-8))
#define MX_CELL(pBt) ((pBt->pageSize-8)/6)
typedef struct MemPage MemPage; typedef struct BtLock BtLock; typedef struct CellInfo CellInfo;
#ifndef SQLITE_FILE_HEADER
# define SQLITE_FILE_HEADER "SQLite format 3"
#endif
#define PTF_INTKEY 0x01
#define PTF_ZERODATA 0x02
#define PTF_LEAFDATA 0x04
#define PTF_LEAF 0x08
struct MemPage {  u8 isInit;  u8 intKey;  u8 intKeyLeaf;  Pgno pgno;  u8 leaf;  u8 hdrOffset;  u8 childPtrSize;  u8 max1bytePayload;  u8 nOverflow;  u16 maxLocal;  u16 minLocal;  u16 cellOffset;  int nFree;  u16 nCell;  u16 maskPage;  u16 aiOvfl[4];  u8 *apOvfl[4];  BtShared *pBt;  u8 *aData;  u8 *aDataEnd;  u8 *aCellIdx;  u8 *aDataOfst;  DbPage *pDbPage;  u16 (*xCellSize)(MemPage*,u8*);  void (*xParseCell)(MemPage*,u8*,CellInfo*); }; struct BtLock {  Btree *pBtree;  Pgno iTable;  u8 eLock;  BtLock *pNext; };
#define READ_LOCK  1
#define WRITE_LOCK 2
struct Btree {  sqlite3 *db;  BtShared *pBt;  u8 inTrans;  u8 sharable;  u8 locked;  u8 hasIncrblobCur;  int wantToLock;  int nBackup;  u32 iBDataVersion;  Btree *pNext;  Btree *pPrev;
#ifdef SQLITE_DEBUG
 u64 nSeek;
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
 BtLock lock;
#endif
};
#define TRANS_NONE 0
#define TRANS_READ 1
#define TRANS_WRITE 2
#if TRANS_NONE!=SQLITE_TXN_NONE
# error wrong numeric code for no-transaction
#endif
#if TRANS_READ!=SQLITE_TXN_READ
# error wrong numeric code for read-transaction
#endif
#if TRANS_WRITE!=SQLITE_TXN_WRITE
# error wrong numeric code for write-transaction
#endif
struct BtShared {  Pager *pPager;  sqlite3 *db;  BtCursor *pCursor;  MemPage *pPage1;  u8 openFlags;
#ifndef SQLITE_OMIT_AUTOVACUUM
 u8 autoVacuum;  u8 incrVacuum;  u8 bDoTruncate;
#endif
 u8 inTransaction;  u8 max1bytePayload;  u8 nReserveWanted;  u16 btsFlags;  u16 maxLocal;  u16 minLocal;  u16 maxLeaf;  u16 minLeaf;  u32 pageSize;  u32 usableSize;  int nTransaction;  u32 nPage;  void *pSchema;  void (*xFreeSchema)(void*);  sqlite3_mutex *mutex;  Bitvec *pHasContent;
#ifndef SQLITE_OMIT_SHARED_CACHE
 int nRef;  BtShared *pNext;  BtLock *pLock;  Btree *pWriter;
#endif
 u8 *pTmpSpace;  int nPreformatSize; };
#define BTS_READ_ONLY 0x0001
#define BTS_PAGESIZE_FIXED  0x0002
#define BTS_SECURE_DELETE 0x0004
#define BTS_OVERWRITE 0x0008
#define BTS_FAST_SECURE 0x000c
#define BTS_INITIALLY_EMPTY 0x0010
#define BTS_NO_WAL  0x0020
#define BTS_EXCLUSIVE 0x0040
#define BTS_PENDING 0x0080
struct CellInfo {  i64 nKey;  u8 *pPayload;  u32 nPayload;  u16 nLocal;  u16 nSize; };
#define BTCURSOR_MAX_DEPTH 20
struct BtCursor {  u8 eState;  u8 curFlags;  u8 curPagerFlags;  u8 hints;  int skipNext;  Btree *pBtree;  Pgno *aOverflow;  void *pKey;
#define BTCURSOR_FIRST_UNINIT pBt
 BtShared *pBt;  BtCursor *pNext;  CellInfo info;  i64 nKey;  Pgno pgnoRoot;  i8 iPage;  u8 curIntKey;  u16 ix;  u16 aiIdx[BTCURSOR_MAX_DEPTH-1];  struct KeyInfo *pKeyInfo;  MemPage *pPage;  MemPage *apPage[BTCURSOR_MAX_DEPTH-1]; };
#define BTCF_WriteFlag 0x01
#define BTCF_ValidNKey 0x02
#define BTCF_ValidOvfl 0x04
#define BTCF_AtLast  0x08
#define BTCF_Incrblob  0x10
#define BTCF_Multiple  0x20
#define BTCF_Pinned  0x40
#define CURSOR_VALID  0
#define CURSOR_INVALID  1
#define CURSOR_SKIPNEXT 2
#define CURSOR_REQUIRESEEK  3
#define CURSOR_FAULT  4
# define PENDING_BYTE_PAGE(pBt) PAGER_MJ_PGNO(pBt)
#define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno)
#define PTRMAP_PTROFFSET(pgptrmap, pgno) (5*(pgno-pgptrmap-1))
#define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))
#define PTRMAP_ROOTPAGE 1
#define PTRMAP_FREEPAGE 2
#define PTRMAP_OVERFLOW1 3
#define PTRMAP_OVERFLOW2 4
#define PTRMAP_BTREE 5
#define btreeIntegrity(p)  assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 );  assert( p->pBt->inTransaction>=p->inTrans );

#ifndef SQLITE_OMIT_AUTOVACUUM
#define ISAUTOVACUUM (pBt->autoVacuum)
#else
#define ISAUTOVACUUM 0
#endif
typedef struct IntegrityCk IntegrityCk; struct IntegrityCk {  BtShared *pBt;  Pager *pPager;  u8 *aPgRef;  Pgno nPage;  int mxErr;  int nErr;  int bOomFault;  const char *zPfx;  Pgno v1;  int v2;  StrAccum errMsg;  u32 *heap;  sqlite3 *db; };
#define get2byte(x)  ((x)[0]<<8 | (x)[1])
#define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))
#define get4byte sqlite3Get4byte
#define put4byte sqlite3Put4byte
#if SQLITE_BYTEORDER==4321
# define get2byteAligned(x) (*(u16*)(x))
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4008000
# define get2byteAligned(x) __builtin_bswap16(*(u16*)(x))
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
# define get2byteAligned(x) _byteswap_ushort(*(u16*)(x))
#else
# define get2byteAligned(x) ((x)[0]<<8 | (x)[1])
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
#if SQLITE_THREADSAFE
static void lockBtreeMutex(Btree *p){  assert( p->locked==0 );  assert( sqlite3_mutex_notheld(p->pBt->mutex) );  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3_mutex_enter(p->pBt->mutex);  p->pBt->db = p->db;  p->locked = 1; } static void SQLITE_NOINLINE unlockBtreeMutex(Btree *p){  BtShared *pBt = p->pBt;  assert( p->locked==1 );  assert( sqlite3_mutex_held(pBt->mutex) );  assert( sqlite3_mutex_held(p->db->mutex) );  assert( p->db==pBt->db );  sqlite3_mutex_leave(pBt->mutex);  p->locked = 0; } static void SQLITE_NOINLINE btreeLockCarefully(Btree *p); SQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p){  assert( p->pNext==0 || p->pNext->pBt>p->pBt );  assert( p->pPrev==0 || p->pPrev->pBt<p->pBt );  assert( p->pNext==0 || p->pNext->db==p->db );  assert( p->pPrev==0 || p->pPrev->db==p->db );  assert( p->sharable || (p->pNext==0 && p->pPrev==0) );  assert( !p->locked || p->wantToLock>0 );  assert( p->sharable || p->wantToLock==0 );  assert( sqlite3_mutex_held(p->db->mutex) );  assert( (p->locked==0 && p->sharable) || p->pBt->db==p->db );  if( !p->sharable ) return;  p->wantToLock++;  if( p->locked ) return;  btreeLockCarefully(p); } static void SQLITE_NOINLINE btreeLockCarefully(Btree *p){  Btree *pLater;  if( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){  p->pBt->db = p->db;  p->locked = 1;  return;  }  for(pLater=p->pNext; pLater; pLater=pLater->pNext){  assert( pLater->sharable );  assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );  assert( !pLater->locked || pLater->wantToLock>0 );  if( pLater->locked ){  unlockBtreeMutex(pLater);  }  }  lockBtreeMutex(p);  for(pLater=p->pNext; pLater; pLater=pLater->pNext){  if( pLater->wantToLock ){  lockBtreeMutex(pLater);  }  } } SQLITE_PRIVATE void sqlite3BtreeLeave(Btree *p){  assert( sqlite3_mutex_held(p->db->mutex) );  if( p->sharable ){  assert( p->wantToLock>0 );  p->wantToLock--;  if( p->wantToLock==0 ){  unlockBtreeMutex(p);  }  } }
#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3BtreeHoldsMutex(Btree *p){  assert( p->sharable==0 || p->locked==0 || p->wantToLock>0 );  assert( p->sharable==0 || p->locked==0 || p->db==p->pBt->db );  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) );  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) );  return (p->sharable==0 || p->locked); }
#endif
static void SQLITE_NOINLINE btreeEnterAll(sqlite3 *db){  int i;  int skipOk = 1;  Btree *p;  assert( sqlite3_mutex_held(db->mutex) );  for(i=0; i<db->nDb; i++){  p = db->aDb[i].pBt;  if( p && p->sharable ){  sqlite3BtreeEnter(p);  skipOk = 0;  }  }  db->noSharedCache = skipOk; } SQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db){  if( db->noSharedCache==0 ) btreeEnterAll(db); } static void SQLITE_NOINLINE btreeLeaveAll(sqlite3 *db){  int i;  Btree *p;  assert( sqlite3_mutex_held(db->mutex) );  for(i=0; i<db->nDb; i++){  p = db->aDb[i].pBt;  if( p ) sqlite3BtreeLeave(p);  } } SQLITE_PRIVATE void sqlite3BtreeLeaveAll(sqlite3 *db){  if( db->noSharedCache==0 ) btreeLeaveAll(db); }
#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes(sqlite3 *db){  int i;  if( !sqlite3_mutex_held(db->mutex) ){  return 0;  }  for(i=0; i<db->nDb; i++){  Btree *p;  p = db->aDb[i].pBt;  if( p && p->sharable &&   (p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex)) ){  return 0;  }  }  return 1; }
#endif
#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3SchemaMutexHeld(sqlite3 *db, int iDb, Schema *pSchema){  Btree *p;  assert( db!=0 );  if( pSchema ) iDb = sqlite3SchemaToIndex(db, pSchema);  assert( iDb>=0 && iDb<db->nDb );  if( !sqlite3_mutex_held(db->mutex) ) return 0;  if( iDb==1 ) return 1;  p = db->aDb[iDb].pBt;  assert( p!=0 );  return p->sharable==0 || p->locked==1; }
#endif
#else
SQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p){  p->pBt->db = p->db; } SQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db){  int i;  for(i=0; i<db->nDb; i++){  Btree *p = db->aDb[i].pBt;  if( p ){  p->pBt->db = p->db;  }  } }
#endif
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE void sqlite3BtreeEnterCursor(BtCursor *pCur){  sqlite3BtreeEnter(pCur->pBtree); }
# if SQLITE_THREADSAFE
SQLITE_PRIVATE void sqlite3BtreeLeaveCursor(BtCursor *pCur){  sqlite3BtreeLeave(pCur->pBtree); }
# endif
#endif
#endif
static const char zMagicHeader[] = SQLITE_FILE_HEADER;
#if 0
int sqlite3BtreeTrace=1;
# define TRACE(X) if(sqlite3BtreeTrace){printf X;fflush(stdout);}
#else
# define TRACE(X)
#endif
#define get2byteNotZero(X) (((((int)get2byte(X))-1)&0xffff)+1)
#define BTALLOC_ANY  0
#define BTALLOC_EXACT 1
#define BTALLOC_LE 2
#ifndef SQLITE_OMIT_AUTOVACUUM
#define IfNotOmitAV(expr) (expr)
#else
#define IfNotOmitAV(expr) 0
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
#ifdef SQLITE_TEST
SQLITE_PRIVATE BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;
#else
static BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;
#endif
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_API int sqlite3_enable_shared_cache(int enable){  sqlite3GlobalConfig.sharedCacheEnabled = enable;  return SQLITE_OK; }
#endif
#ifdef SQLITE_OMIT_SHARED_CACHE
 #define querySharedCacheTableLock(a,b,c) SQLITE_OK
 #define setSharedCacheTableLock(a,b,c) SQLITE_OK
 #define clearAllSharedCacheTableLocks(a)
 #define downgradeAllSharedCacheTableLocks(a)
 #define hasSharedCacheTableLock(a,b,c,d) 1
 #define hasReadConflicts(a, b) 0
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE sqlite3_uint64 sqlite3BtreeSeekCount(Btree *pBt){  u64 n = pBt->nSeek;  pBt->nSeek = 0;  return n; }
#endif
#ifdef SQLITE_DEBUG
int corruptPageError(int lineno, MemPage *p){  char *zMsg;  sqlite3BeginBenignMalloc();  zMsg = sqlite3_mprintf("database corruption page %d of %s",  (int)p->pgno, sqlite3PagerFilename(p->pBt->pPager, 0)  );  sqlite3EndBenignMalloc();  if( zMsg ){  sqlite3ReportError(SQLITE_CORRUPT, lineno, zMsg);  }  sqlite3_free(zMsg);  return SQLITE_CORRUPT_BKPT; }
# define SQLITE_CORRUPT_PAGE(pMemPage) corruptPageError(__LINE__, pMemPage)
#else
# define SQLITE_CORRUPT_PAGE(pMemPage) SQLITE_CORRUPT_PGNO(pMemPage->pgno)
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
#ifdef SQLITE_DEBUG
static int hasSharedCacheTableLock(  Btree *pBtree,  Pgno iRoot,  int isIndex,  int eLockType ){  Schema *pSchema = (Schema *)pBtree->pBt->pSchema;  Pgno iTab = 0;  BtLock *pLock;  if( (pBtree->sharable==0)   || (eLockType==READ_LOCK && (pBtree->db->flags & SQLITE_ReadUncommit))  ){  return 1;  }  if( isIndex && (!pSchema || (pSchema->schemaFlags&DB_SchemaLoaded)==0) ){  return 1;  }  if( isIndex ){  HashElem *p;  int bSeen = 0;  for(p=sqliteHashFirst(&pSchema->idxHash); p; p=sqliteHashNext(p)){  Index *pIdx = (Index *)sqliteHashData(p);  if( pIdx->tnum==(int)iRoot ){  if( bSeen ){  return 1;  }  iTab = pIdx->pTable->tnum;  bSeen = 1;  }  }  }else{  iTab = iRoot;  }  for(pLock=pBtree->pBt->pLock; pLock; pLock=pLock->pNext){  if( pLock->pBtree==pBtree   && (pLock->iTable==iTab || (pLock->eLock==WRITE_LOCK && pLock->iTable==1))   && pLock->eLock>=eLockType  ){  return 1;  }  }  return 0; }
#endif
#ifdef SQLITE_DEBUG
static int hasReadConflicts(Btree *pBtree, Pgno iRoot){  BtCursor *p;  for(p=pBtree->pBt->pCursor; p; p=p->pNext){  if( p->pgnoRoot==iRoot   && p->pBtree!=pBtree   && 0==(p->pBtree->db->flags & SQLITE_ReadUncommit)  ){  return 1;  }  }  return 0; }
#endif
static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){  BtShared *pBt = p->pBt;  BtLock *pIter;  assert( sqlite3BtreeHoldsMutex(p) );  assert( eLock==READ_LOCK || eLock==WRITE_LOCK );  assert( p->db!=0 );  assert( !(p->db->flags&SQLITE_ReadUncommit)||eLock==WRITE_LOCK||iTab==1 );  assert( eLock==READ_LOCK || (p==pBt->pWriter && p->inTrans==TRANS_WRITE) );  assert( eLock==READ_LOCK || pBt->inTransaction==TRANS_WRITE );  if( !p->sharable ){  return SQLITE_OK;  }  if( pBt->pWriter!=p && (pBt->btsFlags & BTS_EXCLUSIVE)!=0 ){  sqlite3ConnectionBlocked(p->db, pBt->pWriter->db);  return SQLITE_LOCKED_SHAREDCACHE;  }  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){  assert( pIter->eLock==READ_LOCK || pIter->eLock==WRITE_LOCK );  assert( eLock==READ_LOCK || pIter->pBtree==p || pIter->eLock==READ_LOCK);  if( pIter->pBtree!=p && pIter->iTable==iTab && pIter->eLock!=eLock ){  sqlite3ConnectionBlocked(p->db, pIter->pBtree->db);  if( eLock==WRITE_LOCK ){  assert( p==pBt->pWriter );  pBt->btsFlags |= BTS_PENDING;  }  return SQLITE_LOCKED_SHAREDCACHE;  }  }  return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){  BtShared *pBt = p->pBt;  BtLock *pLock = 0;  BtLock *pIter;  assert( sqlite3BtreeHoldsMutex(p) );  assert( eLock==READ_LOCK || eLock==WRITE_LOCK );  assert( p->db!=0 );  assert( 0==(p->db->flags&SQLITE_ReadUncommit) || eLock==WRITE_LOCK );  assert( p->sharable );  assert( SQLITE_OK==querySharedCacheTableLock(p, iTable, eLock) );  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){  if( pIter->iTable==iTable && pIter->pBtree==p ){  pLock = pIter;  break;  }  }  if( !pLock ){  pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));  if( !pLock ){  return SQLITE_NOMEM_BKPT;  }  pLock->iTable = iTable;  pLock->pBtree = p;  pLock->pNext = pBt->pLock;  pBt->pLock = pLock;  }  assert( WRITE_LOCK>READ_LOCK );  if( eLock>pLock->eLock ){  pLock->eLock = eLock;  }  return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
static void clearAllSharedCacheTableLocks(Btree *p){  BtShared *pBt = p->pBt;  BtLock **ppIter = &pBt->pLock;  assert( sqlite3BtreeHoldsMutex(p) );  assert( p->sharable || 0==*ppIter );  assert( p->inTrans>0 );  while( *ppIter ){  BtLock *pLock = *ppIter;  assert( (pBt->btsFlags & BTS_EXCLUSIVE)==0 || pBt->pWriter==pLock->pBtree );  assert( pLock->pBtree->inTrans>=pLock->eLock );  if( pLock->pBtree==p ){  *ppIter = pLock->pNext;  assert( pLock->iTable!=1 || pLock==&p->lock );  if( pLock->iTable!=1 ){  sqlite3_free(pLock);  }  }else{  ppIter = &pLock->pNext;  }  }  assert( (pBt->btsFlags & BTS_PENDING)==0 || pBt->pWriter );  if( pBt->pWriter==p ){  pBt->pWriter = 0;  pBt->btsFlags &= ~(BTS_EXCLUSIVE|BTS_PENDING);  }else if( pBt->nTransaction==2 ){  pBt->btsFlags &= ~BTS_PENDING;  } } static void downgradeAllSharedCacheTableLocks(Btree *p){  BtShared *pBt = p->pBt;  if( pBt->pWriter==p ){  BtLock *pLock;  pBt->pWriter = 0;  pBt->btsFlags &= ~(BTS_EXCLUSIVE|BTS_PENDING);  for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){  assert( pLock->eLock==READ_LOCK || pLock->pBtree==p );  pLock->eLock = READ_LOCK;  }  } }
#endif
static void releasePage(MemPage *pPage); static void releasePageOne(MemPage *pPage); static void releasePageNotNull(MemPage *pPage);
#ifdef SQLITE_DEBUG
static int cursorHoldsMutex(BtCursor *p){  return sqlite3_mutex_held(p->pBt->mutex); } static int cursorOwnsBtShared(BtCursor *p){  assert( cursorHoldsMutex(p) );  return (p->pBtree->db==p->pBt->db); }
#endif
#define invalidateOverflowCache(pCur) (pCur->curFlags &= ~BTCF_ValidOvfl)
static void invalidateAllOverflowCache(BtShared *pBt){  BtCursor *p;  assert( sqlite3_mutex_held(pBt->mutex) );  for(p=pBt->pCursor; p; p=p->pNext){  invalidateOverflowCache(p);  } }
#ifndef SQLITE_OMIT_INCRBLOB
static void invalidateIncrblobCursors(  Btree *pBtree,  Pgno pgnoRoot,  i64 iRow,  int isClearTable ){  BtCursor *p;  assert( pBtree->hasIncrblobCur );  assert( sqlite3BtreeHoldsMutex(pBtree) );  pBtree->hasIncrblobCur = 0;  for(p=pBtree->pBt->pCursor; p; p=p->pNext){  if( (p->curFlags & BTCF_Incrblob)!=0 ){  pBtree->hasIncrblobCur = 1;  if( p->pgnoRoot==pgnoRoot && (isClearTable || p->info.nKey==iRow) ){  p->eState = CURSOR_INVALID;  }  }  } }
#else
 #define invalidateIncrblobCursors(w,x,y,z)
#endif
static int btreeSetHasContent(BtShared *pBt, Pgno pgno){  int rc = SQLITE_OK;  if( !pBt->pHasContent ){  assert( pgno<=pBt->nPage );  pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);  if( !pBt->pHasContent ){  rc = SQLITE_NOMEM_BKPT;  }  }  if( rc==SQLITE_OK && pgno<=sqlite3BitvecSize(pBt->pHasContent) ){  rc = sqlite3BitvecSet(pBt->pHasContent, pgno);  }  return rc; } static int btreeGetHasContent(BtShared *pBt, Pgno pgno){  Bitvec *p = pBt->pHasContent;  return p && (pgno>sqlite3BitvecSize(p) || sqlite3BitvecTestNotNull(p, pgno)); } static void btreeClearHasContent(BtShared *pBt){  sqlite3BitvecDestroy(pBt->pHasContent);  pBt->pHasContent = 0; } static void btreeReleaseAllCursorPages(BtCursor *pCur){  int i;  if( pCur->iPage>=0 ){  for(i=0; i<pCur->iPage; i++){  releasePageNotNull(pCur->apPage[i]);  }  releasePageNotNull(pCur->pPage);  pCur->iPage = -1;  } } static int saveCursorKey(BtCursor *pCur){  int rc = SQLITE_OK;  assert( CURSOR_VALID==pCur->eState );  assert( 0==pCur->pKey );  assert( cursorHoldsMutex(pCur) );  if( pCur->curIntKey ){  pCur->nKey = sqlite3BtreeIntegerKey(pCur);  }else{  void *pKey;  pCur->nKey = sqlite3BtreePayloadSize(pCur);  pKey = sqlite3Malloc( pCur->nKey + 9 + 8 );  if( pKey ){  rc = sqlite3BtreePayload(pCur, 0, (int)pCur->nKey, pKey);  if( rc==SQLITE_OK ){  memset(((u8*)pKey)+pCur->nKey, 0, 9+8);  pCur->pKey = pKey;  }else{  sqlite3_free(pKey);  }  }else{  rc = SQLITE_NOMEM_BKPT;  }  }  assert( !pCur->curIntKey || !pCur->pKey );  return rc; } static int saveCursorPosition(BtCursor *pCur){  int rc;  assert( CURSOR_VALID==pCur->eState || CURSOR_SKIPNEXT==pCur->eState );  assert( 0==pCur->pKey );  assert( cursorHoldsMutex(pCur) );  if( pCur->curFlags & BTCF_Pinned ){  return SQLITE_CONSTRAINT_PINNED;  }  if( pCur->eState==CURSOR_SKIPNEXT ){  pCur->eState = CURSOR_VALID;  }else{  pCur->skipNext = 0;  }  rc = saveCursorKey(pCur);  if( rc==SQLITE_OK ){  btreeReleaseAllCursorPages(pCur);  pCur->eState = CURSOR_REQUIRESEEK;  }  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl|BTCF_AtLast);  return rc; } static int SQLITE_NOINLINE saveCursorsOnList(BtCursor*,Pgno,BtCursor*); static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){  BtCursor *p;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( pExcept==0 || pExcept->pBt==pBt );  for(p=pBt->pCursor; p; p=p->pNext){  if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ) break;  }  if( p ) return saveCursorsOnList(p, iRoot, pExcept);  if( pExcept ) pExcept->curFlags &= ~BTCF_Multiple;  return SQLITE_OK; } static int SQLITE_NOINLINE saveCursorsOnList(  BtCursor *p,  Pgno iRoot,  BtCursor *pExcept ){  do{  if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ){  if( p->eState==CURSOR_VALID || p->eState==CURSOR_SKIPNEXT ){  int rc = saveCursorPosition(p);  if( SQLITE_OK!=rc ){  return rc;  }  }else{  testcase( p->iPage>=0 );  btreeReleaseAllCursorPages(p);  }  }  p = p->pNext;  }while( p );  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *pCur){  assert( cursorHoldsMutex(pCur) );  sqlite3_free(pCur->pKey);  pCur->pKey = 0;  pCur->eState = CURSOR_INVALID; } static int btreeMoveto(  BtCursor *pCur,  const void *pKey,  i64 nKey,  int bias,  int *pRes ){  int rc;  UnpackedRecord *pIdxKey;  if( pKey ){  KeyInfo *pKeyInfo = pCur->pKeyInfo;  assert( nKey==(i64)(int)nKey );  pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);  if( pIdxKey==0 ) return SQLITE_NOMEM_BKPT;  sqlite3VdbeRecordUnpack(pKeyInfo, (int)nKey, pKey, pIdxKey);  if( pIdxKey->nField==0 || pIdxKey->nField>pKeyInfo->nAllField ){  rc = SQLITE_CORRUPT_BKPT;  }else{  rc = sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes);  }  sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);  }else{  pIdxKey = 0;  rc = sqlite3BtreeTableMoveto(pCur, nKey, bias, pRes);  }  return rc; } static int btreeRestoreCursorPosition(BtCursor *pCur){  int rc;  int skipNext = 0;  assert( cursorOwnsBtShared(pCur) );  assert( pCur->eState>=CURSOR_REQUIRESEEK );  if( pCur->eState==CURSOR_FAULT ){  return pCur->skipNext;  }  pCur->eState = CURSOR_INVALID;  if( sqlite3FaultSim(410) ){  rc = SQLITE_IOERR;  }else{  rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);  }  if( rc==SQLITE_OK ){  sqlite3_free(pCur->pKey);  pCur->pKey = 0;  assert( pCur->eState==CURSOR_VALID || pCur->eState==CURSOR_INVALID );  if( skipNext ) pCur->skipNext = skipNext;  if( pCur->skipNext && pCur->eState==CURSOR_VALID ){  pCur->eState = CURSOR_SKIPNEXT;  }  }  return rc; }
#define restoreCursorPosition(p)  (p->eState>=CURSOR_REQUIRESEEK ?   btreeRestoreCursorPosition(p) :   SQLITE_OK)

SQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor *pCur){  assert( EIGHT_BYTE_ALIGNMENT(pCur)   || pCur==sqlite3BtreeFakeValidCursor() );  assert( offsetof(BtCursor, eState)==0 );  assert( sizeof(pCur->eState)==1 );  return CURSOR_VALID != *(u8*)pCur; } SQLITE_PRIVATE BtCursor *sqlite3BtreeFakeValidCursor(void){  static u8 fakeCursor = CURSOR_VALID;  assert( offsetof(BtCursor, eState)==0 );  return (BtCursor*)&fakeCursor; } SQLITE_PRIVATE int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){  int rc;  assert( pCur!=0 );  assert( pCur->eState!=CURSOR_VALID );  rc = restoreCursorPosition(pCur);  if( rc ){  *pDifferentRow = 1;  return rc;  }  if( pCur->eState!=CURSOR_VALID ){  *pDifferentRow = 1;  }else{  *pDifferentRow = 0;  }  return SQLITE_OK; }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
SQLITE_PRIVATE void sqlite3BtreeCursorHint(BtCursor *pCur, int eHintType, ...){ }
#endif
SQLITE_PRIVATE void sqlite3BtreeCursorHintFlags(BtCursor *pCur, unsigned x){  assert( x==BTREE_SEEK_EQ || x==BTREE_BULKLOAD || x==0 );  pCur->hints = x; }
#ifndef SQLITE_OMIT_AUTOVACUUM
static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){  int nPagesPerMapPage;  Pgno iPtrMap, ret;  assert( sqlite3_mutex_held(pBt->mutex) );  if( pgno<2 ) return 0;  nPagesPerMapPage = (pBt->usableSize/5)+1;  iPtrMap = (pgno-2)/nPagesPerMapPage;  ret = (iPtrMap*nPagesPerMapPage) + 2;  if( ret==PENDING_BYTE_PAGE(pBt) ){  ret++;  }  return ret; } static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){  DbPage *pDbPage;  u8 *pPtrmap;  Pgno iPtrmap;  int offset;  int rc;  if( *pRC ) return;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( 0==PTRMAP_ISPAGE(pBt, PENDING_BYTE_PAGE(pBt)) );  assert( pBt->autoVacuum );  if( key==0 ){  *pRC = SQLITE_CORRUPT_BKPT;  return;  }  iPtrmap = PTRMAP_PAGENO(pBt, key);  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);  if( rc!=SQLITE_OK ){  *pRC = rc;  return;  }  if( ((char*)sqlite3PagerGetExtra(pDbPage))[0]!=0 ){  *pRC = SQLITE_CORRUPT_BKPT;  goto ptrmap_exit;  }  offset = PTRMAP_PTROFFSET(iPtrmap, key);  if( offset<0 ){  *pRC = SQLITE_CORRUPT_BKPT;  goto ptrmap_exit;  }  assert( offset <= (int)pBt->usableSize-5 );  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);  if( eType!=pPtrmap[offset] || get4byte(&pPtrmap[offset+1])!=parent ){  TRACE(("PTRMAP_UPDATE: %d->(%d,%d)\n", key, eType, parent));  *pRC= rc = sqlite3PagerWrite(pDbPage);  if( rc==SQLITE_OK ){  pPtrmap[offset] = eType;  put4byte(&pPtrmap[offset+1], parent);  }  } ptrmap_exit:  sqlite3PagerUnref(pDbPage); } static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){  DbPage *pDbPage;  int iPtrmap;  u8 *pPtrmap;  int offset;  int rc;  assert( sqlite3_mutex_held(pBt->mutex) );  iPtrmap = PTRMAP_PAGENO(pBt, key);  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);  if( rc!=0 ){  return rc;  }  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);  offset = PTRMAP_PTROFFSET(iPtrmap, key);  if( offset<0 ){  sqlite3PagerUnref(pDbPage);  return SQLITE_CORRUPT_BKPT;  }  assert( offset <= (int)pBt->usableSize-5 );  assert( pEType!=0 );  *pEType = pPtrmap[offset];  if( pPgno ) *pPgno = get4byte(&pPtrmap[offset+1]);  sqlite3PagerUnref(pDbPage);  if( *pEType<1 || *pEType>5 ) return SQLITE_CORRUPT_PGNO(iPtrmap);  return SQLITE_OK; }
#else
 #define ptrmapPut(w,x,y,z,rc)
 #define ptrmapGet(w,x,y,z) SQLITE_OK
 #define ptrmapPutOvflPtr(x, y, z, rc)
#endif
#define findCell(P,I)  ((P)->aData + ((P)->maskPage & get2byteAligned(&(P)->aCellIdx[2*(I)])))

#define findCellPastPtr(P,I)  ((P)->aDataOfst + ((P)->maskPage & get2byteAligned(&(P)->aCellIdx[2*(I)])))

static SQLITE_NOINLINE void btreeParseCellAdjustSizeForOverflow(  MemPage *pPage,  u8 *pCell,  CellInfo *pInfo ){  int minLocal;  int maxLocal;  int surplus;  minLocal = pPage->minLocal;  maxLocal = pPage->maxLocal;  surplus = minLocal + (pInfo->nPayload - minLocal)%(pPage->pBt->usableSize-4);  testcase( surplus==maxLocal );  testcase( surplus==maxLocal+1 );  if( surplus <= maxLocal ){  pInfo->nLocal = (u16)surplus;  }else{  pInfo->nLocal = (u16)minLocal;  }  pInfo->nSize = (u16)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4; } static int btreePayloadToLocal(MemPage *pPage, i64 nPayload){  int maxLocal;  maxLocal = pPage->maxLocal;  if( nPayload<=maxLocal ){  return nPayload;  }else{  int minLocal;  int surplus;  minLocal = pPage->minLocal;  surplus = minLocal + (nPayload - minLocal)%(pPage->pBt->usableSize-4);  return ( surplus <= maxLocal ) ? surplus : minLocal;  } } static void btreeParseCellPtrNoPayload(  MemPage *pPage,  u8 *pCell,  CellInfo *pInfo ){  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pPage->leaf==0 );  assert( pPage->childPtrSize==4 );
#ifndef SQLITE_DEBUG
 UNUSED_PARAMETER(pPage);
#endif
 pInfo->nSize = 4 + getVarint(&pCell[4], (u64*)&pInfo->nKey);  pInfo->nPayload = 0;  pInfo->nLocal = 0;  pInfo->pPayload = 0;  return; } static void btreeParseCellPtr(  MemPage *pPage,  u8 *pCell,  CellInfo *pInfo ){  u8 *pIter;  u32 nPayload;  u64 iKey;  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pPage->leaf==0 || pPage->leaf==1 );  assert( pPage->intKeyLeaf );  assert( pPage->childPtrSize==0 );  pIter = pCell;  nPayload = *pIter;  if( nPayload>=0x80 ){  u8 *pEnd = &pIter[8];  nPayload &= 0x7f;  do{  nPayload = (nPayload<<7) | (*++pIter & 0x7f);  }while( (*pIter)>=0x80 && pIter<pEnd );  }  pIter++;  iKey = *pIter;  if( iKey>=0x80 ){  u8 *pEnd = &pIter[7];  iKey &= 0x7f;  while(1){  iKey = (iKey<<7) | (*++pIter & 0x7f);  if( (*pIter)<0x80 ) break;  if( pIter>=pEnd ){  iKey = (iKey<<8) | *++pIter;  break;  }  }  }  pIter++;  pInfo->nKey = *(i64*)&iKey;  pInfo->nPayload = nPayload;  pInfo->pPayload = pIter;  testcase( nPayload==pPage->maxLocal );  testcase( nPayload==(u32)pPage->maxLocal+1 );  if( nPayload<=pPage->maxLocal ){  pInfo->nSize = nPayload + (u16)(pIter - pCell);  if( pInfo->nSize<4 ) pInfo->nSize = 4;  pInfo->nLocal = (u16)nPayload;  }else{  btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);  } } static void btreeParseCellPtrIndex(  MemPage *pPage,  u8 *pCell,  CellInfo *pInfo ){  u8 *pIter;  u32 nPayload;  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pPage->leaf==0 || pPage->leaf==1 );  assert( pPage->intKeyLeaf==0 );  pIter = pCell + pPage->childPtrSize;  nPayload = *pIter;  if( nPayload>=0x80 ){  u8 *pEnd = &pIter[8];  nPayload &= 0x7f;  do{  nPayload = (nPayload<<7) | (*++pIter & 0x7f);  }while( *(pIter)>=0x80 && pIter<pEnd );  }  pIter++;  pInfo->nKey = nPayload;  pInfo->nPayload = nPayload;  pInfo->pPayload = pIter;  testcase( nPayload==pPage->maxLocal );  testcase( nPayload==(u32)pPage->maxLocal+1 );  if( nPayload<=pPage->maxLocal ){  pInfo->nSize = nPayload + (u16)(pIter - pCell);  if( pInfo->nSize<4 ) pInfo->nSize = 4;  pInfo->nLocal = (u16)nPayload;  }else{  btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);  } } static void btreeParseCell(  MemPage *pPage,  int iCell,  CellInfo *pInfo ){  pPage->xParseCell(pPage, findCell(pPage, iCell), pInfo); } static u16 cellSizePtr(MemPage *pPage, u8 *pCell){  u8 *pIter = pCell + pPage->childPtrSize;  u8 *pEnd;  u32 nSize;
#ifdef SQLITE_DEBUG
 CellInfo debuginfo;  pPage->xParseCell(pPage, pCell, &debuginfo);
#endif
 nSize = *pIter;  if( nSize>=0x80 ){  pEnd = &pIter[8];  nSize &= 0x7f;  do{  nSize = (nSize<<7) | (*++pIter & 0x7f);  }while( *(pIter)>=0x80 && pIter<pEnd );  }  pIter++;  if( pPage->intKey ){  pEnd = &pIter[9];  while( (*pIter++)&0x80 && pIter<pEnd );  }  testcase( nSize==pPage->maxLocal );  testcase( nSize==(u32)pPage->maxLocal+1 );  if( nSize<=pPage->maxLocal ){  nSize += (u32)(pIter - pCell);  if( nSize<4 ) nSize = 4;  }else{  int minLocal = pPage->minLocal;  nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);  testcase( nSize==pPage->maxLocal );  testcase( nSize==(u32)pPage->maxLocal+1 );  if( nSize>pPage->maxLocal ){  nSize = minLocal;  }  nSize += 4 + (u16)(pIter - pCell);  }  assert( nSize==debuginfo.nSize || CORRUPT_DB );  return (u16)nSize; } static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){  u8 *pIter = pCell + 4;  u8 *pEnd;
#ifdef SQLITE_DEBUG
 CellInfo debuginfo;  pPage->xParseCell(pPage, pCell, &debuginfo);
#else
 UNUSED_PARAMETER(pPage);
#endif
 assert( pPage->childPtrSize==4 );  pEnd = pIter + 9;  while( (*pIter++)&0x80 && pIter<pEnd );  assert( debuginfo.nSize==(u16)(pIter - pCell) || CORRUPT_DB );  return (u16)(pIter - pCell); }
#ifdef SQLITE_DEBUG
static u16 cellSize(MemPage *pPage, int iCell){  return pPage->xCellSize(pPage, findCell(pPage, iCell)); }
#endif
#ifndef SQLITE_OMIT_AUTOVACUUM
static void ptrmapPutOvflPtr(MemPage *pPage, MemPage *pSrc, u8 *pCell,int *pRC){  CellInfo info;  if( *pRC ) return;  assert( pCell!=0 );  pPage->xParseCell(pPage, pCell, &info);  if( info.nLocal<info.nPayload ){  Pgno ovfl;  if( SQLITE_WITHIN(pSrc->aDataEnd, pCell, pCell+info.nLocal) ){  testcase( pSrc!=pPage );  *pRC = SQLITE_CORRUPT_BKPT;  return;  }  ovfl = get4byte(&pCell[info.nSize-4]);  ptrmapPut(pPage->pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, pRC);  } }
#endif
static int defragmentPage(MemPage *pPage, int nMaxFrag){  int i;  int pc;  int hdr;  int size;  int usableSize;  int cellOffset;  int cbrk;  int nCell;  unsigned char *data;  unsigned char *temp;  unsigned char *src;  int iCellFirst;  int iCellLast;  int iCellStart;  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  assert( pPage->pBt!=0 );  assert( pPage->pBt->usableSize <= SQLITE_MAX_PAGE_SIZE );  assert( pPage->nOverflow==0 );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  temp = 0;  src = data = pPage->aData;  hdr = pPage->hdrOffset;  cellOffset = pPage->cellOffset;  nCell = pPage->nCell;  assert( nCell==get2byte(&data[hdr+3]) || CORRUPT_DB );  iCellFirst = cellOffset + 2*nCell;  usableSize = pPage->pBt->usableSize;  if( (int)data[hdr+7]<=nMaxFrag ){  int iFree = get2byte(&data[hdr+1]);  if( iFree>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);  if( iFree ){  int iFree2 = get2byte(&data[iFree]);  if( iFree2>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);  if( 0==iFree2 || (data[iFree2]==0 && data[iFree2+1]==0) ){  u8 *pEnd = &data[cellOffset + nCell*2];  u8 *pAddr;  int sz2 = 0;  int sz = get2byte(&data[iFree+2]);  int top = get2byte(&data[hdr+5]);  if( top>=iFree ){  return SQLITE_CORRUPT_PAGE(pPage);  }  if( iFree2 ){  if( iFree+sz>iFree2 ) return SQLITE_CORRUPT_PAGE(pPage);  sz2 = get2byte(&data[iFree2+2]);  if( iFree2+sz2 > usableSize ) return SQLITE_CORRUPT_PAGE(pPage);  memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));  sz += sz2;  }else if( NEVER(iFree+sz>usableSize) ){  return SQLITE_CORRUPT_PAGE(pPage);  }  cbrk = top+sz;  assert( cbrk+(iFree-top) <= usableSize );  memmove(&data[cbrk], &data[top], iFree-top);  for(pAddr=&data[cellOffset]; pAddr<pEnd; pAddr+=2){  pc = get2byte(pAddr);  if( pc<iFree ){ put2byte(pAddr, pc+sz); }  else if( pc<iFree2 ){ put2byte(pAddr, pc+sz2); }  }  goto defragment_out;  }  }  }  cbrk = usableSize;  iCellLast = usableSize - 4;  iCellStart = get2byte(&data[hdr+5]);  for(i=0; i<nCell; i++){  u8 *pAddr;  pAddr = &data[cellOffset + i*2];  pc = get2byte(pAddr);  testcase( pc==iCellFirst );  testcase( pc==iCellLast );  if( pc<iCellStart || pc>iCellLast ){  return SQLITE_CORRUPT_PAGE(pPage);  }  assert( pc>=iCellStart && pc<=iCellLast );  size = pPage->xCellSize(pPage, &src[pc]);  cbrk -= size;  if( cbrk<iCellStart || pc+size>usableSize ){  return SQLITE_CORRUPT_PAGE(pPage);  }  assert( cbrk+size<=usableSize && cbrk>=iCellStart );  testcase( cbrk+size==usableSize );  testcase( pc+size==usableSize );  put2byte(pAddr, cbrk);  if( temp==0 ){  if( cbrk==pc ) continue;  temp = sqlite3PagerTempSpace(pPage->pBt->pPager);  memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);  src = temp;  }  memcpy(&data[cbrk], &src[pc], size);  }  data[hdr+7] = 0;  defragment_out:  assert( pPage->nFree>=0 );  if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){  return SQLITE_CORRUPT_PAGE(pPage);  }  assert( cbrk>=iCellFirst );  put2byte(&data[hdr+5], cbrk);  data[hdr+1] = 0;  data[hdr+2] = 0;  memset(&data[iCellFirst], 0, cbrk-iCellFirst);  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  return SQLITE_OK; } static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){  const int hdr = pPg->hdrOffset;  u8 * const aData = pPg->aData;  int iAddr = hdr + 1;  int pc = get2byte(&aData[iAddr]);  int x;  int maxPC = pPg->pBt->usableSize - nByte;  int size;  assert( pc>0 );  while( pc<=maxPC ){  size = get2byte(&aData[pc+2]);  if( (x = size - nByte)>=0 ){  testcase( x==4 );  testcase( x==3 );  if( x<4 ){  if( aData[hdr+7]>57 ) return 0;  memcpy(&aData[iAddr], &aData[pc], 2);  aData[hdr+7] += (u8)x;  }else if( x+pc > maxPC ){  *pRc = SQLITE_CORRUPT_PAGE(pPg);  return 0;  }else{  put2byte(&aData[pc+2], x);  }  return &aData[pc + x];  }  iAddr = pc;  pc = get2byte(&aData[pc]);  if( pc<=iAddr+size ){  if( pc ){  *pRc = SQLITE_CORRUPT_PAGE(pPg);  }  return 0;  }  }  if( pc>maxPC+nByte-4 ){  *pRc = SQLITE_CORRUPT_PAGE(pPg);  }  return 0; } static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){  const int hdr = pPage->hdrOffset;  u8 * const data = pPage->aData;  int top;  int rc = SQLITE_OK;  int gap;  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  assert( pPage->pBt );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( nByte>=0 );  assert( pPage->nFree>=nByte );  assert( pPage->nOverflow==0 );  assert( nByte < (int)(pPage->pBt->usableSize-8) );  assert( pPage->cellOffset == hdr + 12 - 4*pPage->leaf );  gap = pPage->cellOffset + 2*pPage->nCell;  assert( gap<=65536 );  top = get2byte(&data[hdr+5]);  assert( top<=(int)pPage->pBt->usableSize );  if( gap>top ){  if( top==0 && pPage->pBt->usableSize==65536 ){  top = 65536;  }else{  return SQLITE_CORRUPT_PAGE(pPage);  }  }  testcase( gap+2==top );  testcase( gap+1==top );  testcase( gap==top );  if( (data[hdr+2] || data[hdr+1]) && gap+2<=top ){  u8 *pSpace = pageFindSlot(pPage, nByte, &rc);  if( pSpace ){  int g2;  assert( pSpace+nByte<=data+pPage->pBt->usableSize );  *pIdx = g2 = (int)(pSpace-data);  if( g2<=gap ){  return SQLITE_CORRUPT_PAGE(pPage);  }else{  return SQLITE_OK;  }  }else if( rc ){  return rc;  }  }  testcase( gap+2+nByte==top );  if( gap+2+nByte>top ){  assert( pPage->nCell>0 || CORRUPT_DB );  assert( pPage->nFree>=0 );  rc = defragmentPage(pPage, MIN(4, pPage->nFree - (2+nByte)));  if( rc ) return rc;  top = get2byteNotZero(&data[hdr+5]);  assert( gap+2+nByte<=top );  }  top -= nByte;  put2byte(&data[hdr+5], top);  assert( top+nByte <= (int)pPage->pBt->usableSize );  *pIdx = top;  return SQLITE_OK; } static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){  u16 iPtr;  u16 iFreeBlk;  u8 hdr;  u8 nFrag = 0;  u16 iOrigSize = iSize;  u16 x;  u32 iEnd = iStart + iSize;  unsigned char *data = pPage->aData;  assert( pPage->pBt!=0 );  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  assert( CORRUPT_DB || iStart>=pPage->hdrOffset+6+pPage->childPtrSize );  assert( CORRUPT_DB || iEnd <= pPage->pBt->usableSize );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( iSize>=4 );  assert( iStart<=pPage->pBt->usableSize-4 );  hdr = pPage->hdrOffset;  iPtr = hdr + 1;  if( data[iPtr+1]==0 && data[iPtr]==0 ){  iFreeBlk = 0;  }else{  while( (iFreeBlk = get2byte(&data[iPtr]))<iStart ){  if( iFreeBlk<iPtr+4 ){  if( iFreeBlk==0 ) break;  return SQLITE_CORRUPT_PAGE(pPage);  }  iPtr = iFreeBlk;  }  if( iFreeBlk>pPage->pBt->usableSize-4 ){  return SQLITE_CORRUPT_PAGE(pPage);  }  assert( iFreeBlk>iPtr || iFreeBlk==0 );  if( iFreeBlk && iEnd+3>=iFreeBlk ){  nFrag = iFreeBlk - iEnd;  if( iEnd>iFreeBlk ) return SQLITE_CORRUPT_PAGE(pPage);  iEnd = iFreeBlk + get2byte(&data[iFreeBlk+2]);  if( iEnd > pPage->pBt->usableSize ){  return SQLITE_CORRUPT_PAGE(pPage);  }  iSize = iEnd - iStart;  iFreeBlk = get2byte(&data[iFreeBlk]);  }  if( iPtr>hdr+1 ){  int iPtrEnd = iPtr + get2byte(&data[iPtr+2]);  if( iPtrEnd+3>=iStart ){  if( iPtrEnd>iStart ) return SQLITE_CORRUPT_PAGE(pPage);  nFrag += iStart - iPtrEnd;  iSize = iEnd - iPtr;  iStart = iPtr;  }  }  if( nFrag>data[hdr+7] ) return SQLITE_CORRUPT_PAGE(pPage);  data[hdr+7] -= nFrag;  }  x = get2byte(&data[hdr+5]);  if( iStart<=x ){  if( iStart<x ) return SQLITE_CORRUPT_PAGE(pPage);  if( iPtr!=hdr+1 ) return SQLITE_CORRUPT_PAGE(pPage);  put2byte(&data[hdr+1], iFreeBlk);  put2byte(&data[hdr+5], iEnd);  }else{  put2byte(&data[iPtr], iStart);  }  if( pPage->pBt->btsFlags & BTS_FAST_SECURE ){  memset(&data[iStart], 0, iSize);  }  put2byte(&data[iStart], iFreeBlk);  put2byte(&data[iStart+2], iSize);  pPage->nFree += iOrigSize;  return SQLITE_OK; } static int decodeFlags(MemPage *pPage, int flagByte){  BtShared *pBt;  assert( pPage->hdrOffset==(pPage->pgno==1 ? 100 : 0) );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  pPage->leaf = (u8)(flagByte>>3); assert( PTF_LEAF == 1<<3 );  flagByte &= ~PTF_LEAF;  pPage->childPtrSize = 4-4*pPage->leaf;  pPage->xCellSize = cellSizePtr;  pBt = pPage->pBt;  if( flagByte==(PTF_LEAFDATA | PTF_INTKEY) ){  assert( (PTF_LEAFDATA|PTF_INTKEY)==5 );  assert( (PTF_LEAFDATA|PTF_INTKEY|PTF_LEAF)==13 );  pPage->intKey = 1;  if( pPage->leaf ){  pPage->intKeyLeaf = 1;  pPage->xParseCell = btreeParseCellPtr;  }else{  pPage->intKeyLeaf = 0;  pPage->xCellSize = cellSizePtrNoPayload;  pPage->xParseCell = btreeParseCellPtrNoPayload;  }  pPage->maxLocal = pBt->maxLeaf;  pPage->minLocal = pBt->minLeaf;  }else if( flagByte==PTF_ZERODATA ){  assert( (PTF_ZERODATA)==2 );  assert( (PTF_ZERODATA|PTF_LEAF)==10 );  pPage->intKey = 0;  pPage->intKeyLeaf = 0;  pPage->xParseCell = btreeParseCellPtrIndex;  pPage->maxLocal = pBt->maxLocal;  pPage->minLocal = pBt->minLocal;  }else{  return SQLITE_CORRUPT_PAGE(pPage);  }  pPage->max1bytePayload = pBt->max1bytePayload;  return SQLITE_OK; } static int btreeComputeFreeSpace(MemPage *pPage){  int pc;  u8 hdr;  u8 *data;  int usableSize;  int nFree;  int top;  int iCellFirst;  int iCellLast;  assert( pPage->pBt!=0 );  assert( pPage->pBt->db!=0 );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );  assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );  assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );  assert( pPage->isInit==1 );  assert( pPage->nFree<0 );  usableSize = pPage->pBt->usableSize;  hdr = pPage->hdrOffset;  data = pPage->aData;  top = get2byteNotZero(&data[hdr+5]);  iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;  iCellLast = usableSize - 4;  pc = get2byte(&data[hdr+1]);  nFree = data[hdr+7] + top;  if( pc>0 ){  u32 next, size;  if( pc<top ){  return SQLITE_CORRUPT_PAGE(pPage);  }  while( 1 ){  if( pc>iCellLast ){  return SQLITE_CORRUPT_PAGE(pPage);  }  next = get2byte(&data[pc]);  size = get2byte(&data[pc+2]);  nFree = nFree + size;  if( next<=pc+size+3 ) break;  pc = next;  }  if( next>0 ){  return SQLITE_CORRUPT_PAGE(pPage);  }  if( pc+size>(unsigned int)usableSize ){  return SQLITE_CORRUPT_PAGE(pPage);  }  }  if( nFree>usableSize || nFree<iCellFirst ){  return SQLITE_CORRUPT_PAGE(pPage);  }  pPage->nFree = (u16)(nFree - iCellFirst);  return SQLITE_OK; } static SQLITE_NOINLINE int btreeCellSizeCheck(MemPage *pPage){  int iCellFirst;  int iCellLast;  int i;  int sz;  int pc;  u8 *data;  int usableSize;  int cellOffset;  iCellFirst = pPage->cellOffset + 2*pPage->nCell;  usableSize = pPage->pBt->usableSize;  iCellLast = usableSize - 4;  data = pPage->aData;  cellOffset = pPage->cellOffset;  if( !pPage->leaf ) iCellLast--;  for(i=0; i<pPage->nCell; i++){  pc = get2byteAligned(&data[cellOffset+i*2]);  testcase( pc==iCellFirst );  testcase( pc==iCellLast );  if( pc<iCellFirst || pc>iCellLast ){  return SQLITE_CORRUPT_PAGE(pPage);  }  sz = pPage->xCellSize(pPage, &data[pc]);  testcase( pc+sz==usableSize );  if( pc+sz>usableSize ){  return SQLITE_CORRUPT_PAGE(pPage);  }  }  return SQLITE_OK; } static int btreeInitPage(MemPage *pPage){  u8 *data;  BtShared *pBt;  assert( pPage->pBt!=0 );  assert( pPage->pBt->db!=0 );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pPage->pgno==sqlite3PagerPagenumber(pPage->pDbPage) );  assert( pPage == sqlite3PagerGetExtra(pPage->pDbPage) );  assert( pPage->aData == sqlite3PagerGetData(pPage->pDbPage) );  assert( pPage->isInit==0 );  pBt = pPage->pBt;  data = pPage->aData + pPage->hdrOffset;  if( decodeFlags(pPage, data[0]) ){  return SQLITE_CORRUPT_PAGE(pPage);  }  assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );  pPage->maskPage = (u16)(pBt->pageSize - 1);  pPage->nOverflow = 0;  pPage->cellOffset = pPage->hdrOffset + 8 + pPage->childPtrSize;  pPage->aCellIdx = data + pPage->childPtrSize + 8;  pPage->aDataEnd = pPage->aData + pBt->usableSize;  pPage->aDataOfst = pPage->aData + pPage->childPtrSize;  pPage->nCell = get2byte(&data[3]);  if( pPage->nCell>MX_CELL(pBt) ){  return SQLITE_CORRUPT_PAGE(pPage);  }  testcase( pPage->nCell==MX_CELL(pBt) );  assert( pPage->nCell>0   || get2byteNotZero(&data[5])==(int)pBt->usableSize   || CORRUPT_DB );  pPage->nFree = -1;  pPage->isInit = 1;  if( pBt->db->flags & SQLITE_CellSizeCk ){  return btreeCellSizeCheck(pPage);  }  return SQLITE_OK; } static void zeroPage(MemPage *pPage, int flags){  unsigned char *data = pPage->aData;  BtShared *pBt = pPage->pBt;  u8 hdr = pPage->hdrOffset;  u16 first;  assert( sqlite3PagerPagenumber(pPage->pDbPage)==pPage->pgno );  assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );  assert( sqlite3PagerGetData(pPage->pDbPage) == data );  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  assert( sqlite3_mutex_held(pBt->mutex) );  if( pBt->btsFlags & BTS_FAST_SECURE ){  memset(&data[hdr], 0, pBt->usableSize - hdr);  }  data[hdr] = (char)flags;  first = hdr + ((flags&PTF_LEAF)==0 ? 12 : 8);  memset(&data[hdr+1], 0, 4);  data[hdr+7] = 0;  put2byte(&data[hdr+5], pBt->usableSize);  pPage->nFree = (u16)(pBt->usableSize - first);  decodeFlags(pPage, flags);  pPage->cellOffset = first;  pPage->aDataEnd = &data[pBt->usableSize];  pPage->aCellIdx = &data[first];  pPage->aDataOfst = &data[pPage->childPtrSize];  pPage->nOverflow = 0;  assert( pBt->pageSize>=512 && pBt->pageSize<=65536 );  pPage->maskPage = (u16)(pBt->pageSize - 1);  pPage->nCell = 0;  pPage->isInit = 1; } static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){  MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);  if( pgno!=pPage->pgno ){  pPage->aData = sqlite3PagerGetData(pDbPage);  pPage->pDbPage = pDbPage;  pPage->pBt = pBt;  pPage->pgno = pgno;  pPage->hdrOffset = pgno==1 ? 100 : 0;  }  assert( pPage->aData==sqlite3PagerGetData(pDbPage) );  return pPage; } static int btreeGetPage(  BtShared *pBt,  Pgno pgno,  MemPage **ppPage,  int flags ){  int rc;  DbPage *pDbPage;  assert( flags==0 || flags==PAGER_GET_NOCONTENT || flags==PAGER_GET_READONLY );  assert( sqlite3_mutex_held(pBt->mutex) );  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);  if( rc ) return rc;  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);  return SQLITE_OK; } static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){  DbPage *pDbPage;  assert( sqlite3_mutex_held(pBt->mutex) );  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);  if( pDbPage ){  return btreePageFromDbPage(pDbPage, pgno, pBt);  }  return 0; } static Pgno btreePagecount(BtShared *pBt){  return pBt->nPage; } SQLITE_PRIVATE Pgno sqlite3BtreeLastPage(Btree *p){  assert( sqlite3BtreeHoldsMutex(p) );  return btreePagecount(p->pBt); } static int getAndInitPage(  BtShared *pBt,  Pgno pgno,  MemPage **ppPage,  BtCursor *pCur,  int bReadOnly ){  int rc;  DbPage *pDbPage;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( pCur==0 || ppPage==&pCur->pPage );  assert( pCur==0 || bReadOnly==pCur->curPagerFlags );  assert( pCur==0 || pCur->iPage>0 );  if( pgno>btreePagecount(pBt) ){  rc = SQLITE_CORRUPT_BKPT;  goto getAndInitPage_error1;  }  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);  if( rc ){  goto getAndInitPage_error1;  }  *ppPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);  if( (*ppPage)->isInit==0 ){  btreePageFromDbPage(pDbPage, pgno, pBt);  rc = btreeInitPage(*ppPage);  if( rc!=SQLITE_OK ){  goto getAndInitPage_error2;  }  }  assert( (*ppPage)->pgno==pgno );  assert( (*ppPage)->aData==sqlite3PagerGetData(pDbPage) );  if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){  rc = SQLITE_CORRUPT_PGNO(pgno);  goto getAndInitPage_error2;  }  return SQLITE_OK; getAndInitPage_error2:  releasePage(*ppPage); getAndInitPage_error1:  if( pCur ){  pCur->iPage--;  pCur->pPage = pCur->apPage[pCur->iPage];  }  testcase( pgno==0 );  assert( pgno!=0 || rc==SQLITE_CORRUPT );  return rc; } static void releasePageNotNull(MemPage *pPage){  assert( pPage->aData );  assert( pPage->pBt );  assert( pPage->pDbPage!=0 );  assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );  assert( sqlite3PagerGetData(pPage->pDbPage)==pPage->aData );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  sqlite3PagerUnrefNotNull(pPage->pDbPage); } static void releasePage(MemPage *pPage){  if( pPage ) releasePageNotNull(pPage); } static void releasePageOne(MemPage *pPage){  assert( pPage!=0 );  assert( pPage->aData );  assert( pPage->pBt );  assert( pPage->pDbPage!=0 );  assert( sqlite3PagerGetExtra(pPage->pDbPage) == (void*)pPage );  assert( sqlite3PagerGetData(pPage->pDbPage)==pPage->aData );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  sqlite3PagerUnrefPageOne(pPage->pDbPage); } static int btreeGetUnusedPage(  BtShared *pBt,  Pgno pgno,  MemPage **ppPage,  int flags ){  int rc = btreeGetPage(pBt, pgno, ppPage, flags);  if( rc==SQLITE_OK ){  if( sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1 ){  releasePage(*ppPage);  *ppPage = 0;  return SQLITE_CORRUPT_BKPT;  }  (*ppPage)->isInit = 0;  }else{  *ppPage = 0;  }  return rc; } static void pageReinit(DbPage *pData){  MemPage *pPage;  pPage = (MemPage *)sqlite3PagerGetExtra(pData);  assert( sqlite3PagerPageRefcount(pData)>0 );  if( pPage->isInit ){  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  pPage->isInit = 0;  if( sqlite3PagerPageRefcount(pData)>1 ){  btreeInitPage(pPage);  }  } } static int btreeInvokeBusyHandler(void *pArg){  BtShared *pBt = (BtShared*)pArg;  assert( pBt->db );  assert( sqlite3_mutex_held(pBt->db->mutex) );  return sqlite3InvokeBusyHandler(&pBt->db->busyHandler); } SQLITE_PRIVATE int sqlite3BtreeOpen(  sqlite3_vfs *pVfs,  const char *zFilename,  sqlite3 *db,  Btree **ppBtree,  int flags,  int vfsFlags ){  BtShared *pBt = 0;  Btree *p;  sqlite3_mutex *mutexOpen = 0;  int rc = SQLITE_OK;  u8 nReserve;  unsigned char zDbHeader[100];  const int isTempDb = zFilename==0 || zFilename[0]==0;
#ifdef SQLITE_OMIT_MEMORYDB
 const int isMemdb = 0;
#else
 const int isMemdb = (zFilename && strcmp(zFilename, ":memory:")==0)   || (isTempDb && sqlite3TempInMemory(db))   || (vfsFlags & SQLITE_OPEN_MEMORY)!=0;
#endif
 assert( db!=0 );  assert( pVfs!=0 );  assert( sqlite3_mutex_held(db->mutex) );  assert( (flags&0xff)==flags );  assert( (flags & BTREE_UNORDERED)==0 || (flags & BTREE_SINGLE)!=0 );  assert( (flags & BTREE_SINGLE)==0 || isTempDb );  if( isMemdb ){  flags |= BTREE_MEMORY;  }  if( (vfsFlags & SQLITE_OPEN_MAIN_DB)!=0 && (isMemdb || isTempDb) ){  vfsFlags = (vfsFlags & ~SQLITE_OPEN_MAIN_DB) | SQLITE_OPEN_TEMP_DB;  }  p = sqlite3MallocZero(sizeof(Btree));  if( !p ){  return SQLITE_NOMEM_BKPT;  }  p->inTrans = TRANS_NONE;  p->db = db;
#ifndef SQLITE_OMIT_SHARED_CACHE
 p->lock.pBtree = p;  p->lock.iTable = 1;
#endif
#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO)
 if( isTempDb==0 && (isMemdb==0 || (vfsFlags&SQLITE_OPEN_URI)!=0) ){  if( vfsFlags & SQLITE_OPEN_SHAREDCACHE ){  int nFilename = sqlite3Strlen30(zFilename)+1;  int nFullPathname = pVfs->mxPathname+1;  char *zFullPathname = sqlite3Malloc(MAX(nFullPathname,nFilename));  MUTEX_LOGIC( sqlite3_mutex *mutexShared; )  p->sharable = 1;  if( !zFullPathname ){  sqlite3_free(p);  return SQLITE_NOMEM_BKPT;  }  if( isMemdb ){  memcpy(zFullPathname, zFilename, nFilename);  }else{  rc = sqlite3OsFullPathname(pVfs, zFilename,   nFullPathname, zFullPathname);  if( rc ){  if( rc==SQLITE_OK_SYMLINK ){  rc = SQLITE_OK;  }else{  sqlite3_free(zFullPathname);  sqlite3_free(p);  return rc;  }  }  }
#if SQLITE_THREADSAFE
 mutexOpen = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_OPEN);  sqlite3_mutex_enter(mutexOpen);  mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);  sqlite3_mutex_enter(mutexShared);
#endif
 for(pBt=GLOBAL(BtShared*,sqlite3SharedCacheList); pBt; pBt=pBt->pNext){  assert( pBt->nRef>0 );  if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0))   && sqlite3PagerVfs(pBt->pPager)==pVfs ){  int iDb;  for(iDb=db->nDb-1; iDb>=0; iDb--){  Btree *pExisting = db->aDb[iDb].pBt;  if( pExisting && pExisting->pBt==pBt ){  sqlite3_mutex_leave(mutexShared);  sqlite3_mutex_leave(mutexOpen);  sqlite3_free(zFullPathname);  sqlite3_free(p);  return SQLITE_CONSTRAINT;  }  }  p->pBt = pBt;  pBt->nRef++;  break;  }  }  sqlite3_mutex_leave(mutexShared);  sqlite3_free(zFullPathname);  }
#ifdef SQLITE_DEBUG
 else{  p->sharable = 1;  }
#endif
 }
#endif
 if( pBt==0 ){  assert( sizeof(i64)==8 );  assert( sizeof(u64)==8 );  assert( sizeof(u32)==4 );  assert( sizeof(u16)==2 );  assert( sizeof(Pgno)==4 );  pBt = sqlite3MallocZero( sizeof(*pBt) );  if( pBt==0 ){  rc = SQLITE_NOMEM_BKPT;  goto btree_open_out;  }  rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename,  sizeof(MemPage), flags, vfsFlags, pageReinit);  if( rc==SQLITE_OK ){  sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);  rc = sqlite3PagerReadFileheader(pBt->pPager,sizeof(zDbHeader),zDbHeader);  }  if( rc!=SQLITE_OK ){  goto btree_open_out;  }  pBt->openFlags = (u8)flags;  pBt->db = db;  sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);  p->pBt = pBt;  pBt->pCursor = 0;  pBt->pPage1 = 0;  if( sqlite3PagerIsreadonly(pBt->pPager) ) pBt->btsFlags |= BTS_READ_ONLY;
#if defined(SQLITE_SECURE_DELETE)
 pBt->btsFlags |= BTS_SECURE_DELETE;
#elif defined(SQLITE_FAST_SECURE_DELETE)
 pBt->btsFlags |= BTS_OVERWRITE;
#endif
 pBt->pageSize = (zDbHeader[16]<<8) | (zDbHeader[17]<<16);  if( pBt->pageSize<512 || pBt->pageSize>SQLITE_MAX_PAGE_SIZE   || ((pBt->pageSize-1)&pBt->pageSize)!=0 ){  pBt->pageSize = 0;
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( zFilename && !isMemdb ){  pBt->autoVacuum = (SQLITE_DEFAULT_AUTOVACUUM ? 1 : 0);  pBt->incrVacuum = (SQLITE_DEFAULT_AUTOVACUUM==2 ? 1 : 0);  }
#endif
 nReserve = 0;  }else{  nReserve = zDbHeader[20];  pBt->btsFlags |= BTS_PAGESIZE_FIXED;
#ifndef SQLITE_OMIT_AUTOVACUUM
 pBt->autoVacuum = (get4byte(&zDbHeader[36 + 4*4])?1:0);  pBt->incrVacuum = (get4byte(&zDbHeader[36 + 7*4])?1:0);
#endif
 }  rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);  if( rc ) goto btree_open_out;  pBt->usableSize = pBt->pageSize - nReserve;  assert( (pBt->pageSize & 7)==0 );
#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO)
 pBt->nRef = 1;  if( p->sharable ){  MUTEX_LOGIC( sqlite3_mutex *mutexShared; )  MUTEX_LOGIC( mutexShared = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);)  if( SQLITE_THREADSAFE && sqlite3GlobalConfig.bCoreMutex ){  pBt->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_FAST);  if( pBt->mutex==0 ){  rc = SQLITE_NOMEM_BKPT;  goto btree_open_out;  }  }  sqlite3_mutex_enter(mutexShared);  pBt->pNext = GLOBAL(BtShared*,sqlite3SharedCacheList);  GLOBAL(BtShared*,sqlite3SharedCacheList) = pBt;  sqlite3_mutex_leave(mutexShared);  }
#endif
 }
#if !defined(SQLITE_OMIT_SHARED_CACHE) && !defined(SQLITE_OMIT_DISKIO)
 if( p->sharable ){  int i;  Btree *pSib;  for(i=0; i<db->nDb; i++){  if( (pSib = db->aDb[i].pBt)!=0 && pSib->sharable ){  while( pSib->pPrev ){ pSib = pSib->pPrev; }  if( (uptr)p->pBt<(uptr)pSib->pBt ){  p->pNext = pSib;  p->pPrev = 0;  pSib->pPrev = p;  }else{  while( pSib->pNext && (uptr)pSib->pNext->pBt<(uptr)p->pBt ){  pSib = pSib->pNext;  }  p->pNext = pSib->pNext;  p->pPrev = pSib;  if( p->pNext ){  p->pNext->pPrev = p;  }  pSib->pNext = p;  }  break;  }  }  }
#endif
 *ppBtree = p; btree_open_out:  if( rc!=SQLITE_OK ){  if( pBt && pBt->pPager ){  sqlite3PagerClose(pBt->pPager, 0);  }  sqlite3_free(pBt);  sqlite3_free(p);  *ppBtree = 0;  }else{  sqlite3_file *pFile;  if( sqlite3BtreeSchema(p, 0, 0)==0 ){  sqlite3BtreeSetCacheSize(p, SQLITE_DEFAULT_CACHE_SIZE);  }  pFile = sqlite3PagerFile(pBt->pPager);  if( pFile->pMethods ){  sqlite3OsFileControlHint(pFile, SQLITE_FCNTL_PDB, (void*)&pBt->db);  }  }  if( mutexOpen ){  assert( sqlite3_mutex_held(mutexOpen) );  sqlite3_mutex_leave(mutexOpen);  }  assert( rc!=SQLITE_OK || sqlite3BtreeConnectionCount(*ppBtree)>0 );  return rc; } static int removeFromSharingList(BtShared *pBt){
#ifndef SQLITE_OMIT_SHARED_CACHE
 MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )  BtShared *pList;  int removed = 0;  assert( sqlite3_mutex_notheld(pBt->mutex) );  MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )  sqlite3_mutex_enter(pMainMtx);  pBt->nRef--;  if( pBt->nRef<=0 ){  if( GLOBAL(BtShared*,sqlite3SharedCacheList)==pBt ){  GLOBAL(BtShared*,sqlite3SharedCacheList) = pBt->pNext;  }else{  pList = GLOBAL(BtShared*,sqlite3SharedCacheList);  while( ALWAYS(pList) && pList->pNext!=pBt ){  pList=pList->pNext;  }  if( ALWAYS(pList) ){  pList->pNext = pBt->pNext;  }  }  if( SQLITE_THREADSAFE ){  sqlite3_mutex_free(pBt->mutex);  }  removed = 1;  }  sqlite3_mutex_leave(pMainMtx);  return removed;
#else
 return 1;
#endif
} static void allocateTempSpace(BtShared *pBt){  if( !pBt->pTmpSpace ){  pBt->pTmpSpace = sqlite3PageMalloc( pBt->pageSize );  if( pBt->pTmpSpace ){  memset(pBt->pTmpSpace, 0, 8);  pBt->pTmpSpace += 4;  }  } } static void freeTempSpace(BtShared *pBt){  if( pBt->pTmpSpace ){  pBt->pTmpSpace -= 4;  sqlite3PageFree(pBt->pTmpSpace);  pBt->pTmpSpace = 0;  } } SQLITE_PRIVATE int sqlite3BtreeClose(Btree *p){  BtShared *pBt = p->pBt;  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3BtreeEnter(p);
#ifdef SQLITE_DEBUG
 {  BtCursor *pCur = pBt->pCursor;  while( pCur ){  BtCursor *pTmp = pCur;  pCur = pCur->pNext;  assert( pTmp->pBtree!=p );  }  }
#endif
 sqlite3BtreeRollback(p, SQLITE_OK, 0);  sqlite3BtreeLeave(p);  assert( p->wantToLock==0 && p->locked==0 );  if( !p->sharable || removeFromSharingList(pBt) ){  assert( !pBt->pCursor );  sqlite3PagerClose(pBt->pPager, p->db);  if( pBt->xFreeSchema && pBt->pSchema ){  pBt->xFreeSchema(pBt->pSchema);  }  sqlite3DbFree(0, pBt->pSchema);  freeTempSpace(pBt);  sqlite3_free(pBt);  }
#ifndef SQLITE_OMIT_SHARED_CACHE
 assert( p->wantToLock==0 );  assert( p->locked==0 );  if( p->pPrev ) p->pPrev->pNext = p->pNext;  if( p->pNext ) p->pNext->pPrev = p->pPrev;
#endif
 sqlite3_free(p);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){  BtShared *pBt = p->pBt;  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3BtreeEnter(p);  sqlite3PagerSetCachesize(pBt->pPager, mxPage);  sqlite3BtreeLeave(p);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeSetSpillSize(Btree *p, int mxPage){  BtShared *pBt = p->pBt;  int res;  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3BtreeEnter(p);  res = sqlite3PagerSetSpillsize(pBt->pPager, mxPage);  sqlite3BtreeLeave(p);  return res; }
#if SQLITE_MAX_MMAP_SIZE>0
SQLITE_PRIVATE int sqlite3BtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap){  BtShared *pBt = p->pBt;  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3BtreeEnter(p);  sqlite3PagerSetMmapLimit(pBt->pPager, szMmap);  sqlite3BtreeLeave(p);  return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
SQLITE_PRIVATE int sqlite3BtreeSetPagerFlags(  Btree *p,  unsigned pgFlags ){  BtShared *pBt = p->pBt;  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3BtreeEnter(p);  sqlite3PagerSetFlags(pBt->pPager, pgFlags);  sqlite3BtreeLeave(p);  return SQLITE_OK; }
#endif
SQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){  int rc = SQLITE_OK;  int x;  BtShared *pBt = p->pBt;  assert( nReserve>=0 && nReserve<=255 );  sqlite3BtreeEnter(p);  pBt->nReserveWanted = nReserve;  x = pBt->pageSize - pBt->usableSize;  if( nReserve<x ) nReserve = x;  if( pBt->btsFlags & BTS_PAGESIZE_FIXED ){  sqlite3BtreeLeave(p);  return SQLITE_READONLY;  }  assert( nReserve>=0 && nReserve<=255 );  if( pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE &&  ((pageSize-1)&pageSize)==0 ){  assert( (pageSize & 7)==0 );  assert( !pBt->pCursor );  if( nReserve>32 && pageSize==512 ) pageSize = 1024;  pBt->pageSize = (u32)pageSize;  freeTempSpace(pBt);  }  rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);  pBt->usableSize = pBt->pageSize - (u16)nReserve;  if( iFix ) pBt->btsFlags |= BTS_PAGESIZE_FIXED;  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree *p){  return p->pBt->pageSize; } SQLITE_PRIVATE int sqlite3BtreeGetReserveNoMutex(Btree *p){  int n;  assert( sqlite3_mutex_held(p->pBt->mutex) );  n = p->pBt->pageSize - p->pBt->usableSize;  return n; } SQLITE_PRIVATE int sqlite3BtreeGetRequestedReserve(Btree *p){  int n1, n2;  sqlite3BtreeEnter(p);  n1 = (int)p->pBt->nReserveWanted;  n2 = sqlite3BtreeGetReserveNoMutex(p);  sqlite3BtreeLeave(p);  return n1>n2 ? n1 : n2; } SQLITE_PRIVATE Pgno sqlite3BtreeMaxPageCount(Btree *p, Pgno mxPage){  Pgno n;  sqlite3BtreeEnter(p);  n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);  sqlite3BtreeLeave(p);  return n; } SQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree *p, int newFlag){  int b;  if( p==0 ) return 0;  sqlite3BtreeEnter(p);  assert( BTS_OVERWRITE==BTS_SECURE_DELETE*2 );  assert( BTS_FAST_SECURE==(BTS_OVERWRITE|BTS_SECURE_DELETE) );  if( newFlag>=0 ){  p->pBt->btsFlags &= ~BTS_FAST_SECURE;  p->pBt->btsFlags |= BTS_SECURE_DELETE*newFlag;  }  b = (p->pBt->btsFlags & BTS_FAST_SECURE)/BTS_SECURE_DELETE;  sqlite3BtreeLeave(p);  return b; } SQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){
#ifdef SQLITE_OMIT_AUTOVACUUM
 return SQLITE_READONLY;
#else
 BtShared *pBt = p->pBt;  int rc = SQLITE_OK;  u8 av = (u8)autoVacuum;  sqlite3BtreeEnter(p);  if( (pBt->btsFlags & BTS_PAGESIZE_FIXED)!=0 && (av ?1:0)!=pBt->autoVacuum ){  rc = SQLITE_READONLY;  }else{  pBt->autoVacuum = av ?1:0;  pBt->incrVacuum = av==2 ?1:0;  }  sqlite3BtreeLeave(p);  return rc;
#endif
} SQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *p){
#ifdef SQLITE_OMIT_AUTOVACUUM
 return BTREE_AUTOVACUUM_NONE;
#else
 int rc;  sqlite3BtreeEnter(p);  rc = (  (!p->pBt->autoVacuum)?BTREE_AUTOVACUUM_NONE:  (!p->pBt->incrVacuum)?BTREE_AUTOVACUUM_FULL:  BTREE_AUTOVACUUM_INCR  );  sqlite3BtreeLeave(p);  return rc;
#endif
}
#if SQLITE_DEFAULT_SYNCHRONOUS!=SQLITE_DEFAULT_WAL_SYNCHRONOUS  && !defined(SQLITE_OMIT_WAL)

static void setDefaultSyncFlag(BtShared *pBt, u8 safety_level){  sqlite3 *db;  Db *pDb;  if( (db=pBt->db)!=0 && (pDb=db->aDb)!=0 ){  while( pDb->pBt==0 || pDb->pBt->pBt!=pBt ){ pDb++; }  if( pDb->bSyncSet==0   && pDb->safety_level!=safety_level   && pDb!=&db->aDb[1]  ){  pDb->safety_level = safety_level;  sqlite3PagerSetFlags(pBt->pPager,  pDb->safety_level | (db->flags & PAGER_FLAGS_MASK));  }  } }
#else
# define setDefaultSyncFlag(pBt,safety_level)
#endif
static int newDatabase(BtShared*); static int lockBtree(BtShared *pBt){  int rc;  MemPage *pPage1;  u32 nPage;  u32 nPageFile = 0;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( pBt->pPage1==0 );  rc = sqlite3PagerSharedLock(pBt->pPager);  if( rc!=SQLITE_OK ) return rc;  rc = btreeGetPage(pBt, 1, &pPage1, 0);  if( rc!=SQLITE_OK ) return rc;  nPage = get4byte(28+(u8*)pPage1->aData);  sqlite3PagerPagecount(pBt->pPager, (int*)&nPageFile);  if( nPage==0 || memcmp(24+(u8*)pPage1->aData, 92+(u8*)pPage1->aData,4)!=0 ){  nPage = nPageFile;  }  if( (pBt->db->flags & SQLITE_ResetDatabase)!=0 ){  nPage = 0;  }  if( nPage>0 ){  u32 pageSize;  u32 usableSize;  u8 *page1 = pPage1->aData;  rc = SQLITE_NOTADB;  if( memcmp(page1, zMagicHeader, 16)!=0 ){  goto page1_init_failed;  }
#ifdef SQLITE_OMIT_WAL
 if( page1[18]>1 ){  pBt->btsFlags |= BTS_READ_ONLY;  }  if( page1[19]>1 ){  goto page1_init_failed;  }
#else
 if( page1[18]>2 ){  pBt->btsFlags |= BTS_READ_ONLY;  }  if( page1[19]>2 ){  goto page1_init_failed;  }  if( page1[19]==2 && (pBt->btsFlags & BTS_NO_WAL)==0 ){  int isOpen = 0;  rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);  if( rc!=SQLITE_OK ){  goto page1_init_failed;  }else{  setDefaultSyncFlag(pBt, SQLITE_DEFAULT_WAL_SYNCHRONOUS+1);  if( isOpen==0 ){  releasePageOne(pPage1);  return SQLITE_OK;  }  }  rc = SQLITE_NOTADB;  }else{  setDefaultSyncFlag(pBt, SQLITE_DEFAULT_SYNCHRONOUS+1);  }
#endif
 if( memcmp(&page1[21], "\100\040\040",3)!=0 ){  goto page1_init_failed;  }  pageSize = (page1[16]<<8) | (page1[17]<<16);  if( ((pageSize-1)&pageSize)!=0   || pageSize>SQLITE_MAX_PAGE_SIZE   || pageSize<=256  ){  goto page1_init_failed;  }  pBt->btsFlags |= BTS_PAGESIZE_FIXED;  assert( (pageSize & 7)==0 );  usableSize = pageSize - page1[20];  if( (u32)pageSize!=pBt->pageSize ){  releasePageOne(pPage1);  pBt->usableSize = usableSize;  pBt->pageSize = pageSize;  freeTempSpace(pBt);  rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize,   pageSize-usableSize);  return rc;  }  if( sqlite3WritableSchema(pBt->db)==0 && nPage>nPageFile ){  rc = SQLITE_CORRUPT_BKPT;  goto page1_init_failed;  }  if( usableSize<480 ){  goto page1_init_failed;  }  pBt->pageSize = pageSize;  pBt->usableSize = usableSize;
#ifndef SQLITE_OMIT_AUTOVACUUM
 pBt->autoVacuum = (get4byte(&page1[36 + 4*4])?1:0);  pBt->incrVacuum = (get4byte(&page1[36 + 7*4])?1:0);
#endif
 }  pBt->maxLocal = (u16)((pBt->usableSize-12)*64/255 - 23);  pBt->minLocal = (u16)((pBt->usableSize-12)*32/255 - 23);  pBt->maxLeaf = (u16)(pBt->usableSize - 35);  pBt->minLeaf = (u16)((pBt->usableSize-12)*32/255 - 23);  if( pBt->maxLocal>127 ){  pBt->max1bytePayload = 127;  }else{  pBt->max1bytePayload = (u8)pBt->maxLocal;  }  assert( pBt->maxLeaf + 23 <= MX_CELL_SIZE(pBt) );  pBt->pPage1 = pPage1;  pBt->nPage = nPage;  return SQLITE_OK; page1_init_failed:  releasePageOne(pPage1);  pBt->pPage1 = 0;  return rc; }
#ifndef NDEBUG
static int countValidCursors(BtShared *pBt, int wrOnly){  BtCursor *pCur;  int r = 0;  for(pCur=pBt->pCursor; pCur; pCur=pCur->pNext){  if( (wrOnly==0 || (pCur->curFlags & BTCF_WriteFlag)!=0)   && pCur->eState!=CURSOR_FAULT ) r++;  }  return r; }
#endif
static void unlockBtreeIfUnused(BtShared *pBt){  assert( sqlite3_mutex_held(pBt->mutex) );  assert( countValidCursors(pBt,0)==0 || pBt->inTransaction>TRANS_NONE );  if( pBt->inTransaction==TRANS_NONE && pBt->pPage1!=0 ){  MemPage *pPage1 = pBt->pPage1;  assert( pPage1->aData );  assert( sqlite3PagerRefcount(pBt->pPager)==1 );  pBt->pPage1 = 0;  releasePageOne(pPage1);  } } static int newDatabase(BtShared *pBt){  MemPage *pP1;  unsigned char *data;  int rc;  assert( sqlite3_mutex_held(pBt->mutex) );  if( pBt->nPage>0 ){  return SQLITE_OK;  }  pP1 = pBt->pPage1;  assert( pP1!=0 );  data = pP1->aData;  rc = sqlite3PagerWrite(pP1->pDbPage);  if( rc ) return rc;  memcpy(data, zMagicHeader, sizeof(zMagicHeader));  assert( sizeof(zMagicHeader)==16 );  data[16] = (u8)((pBt->pageSize>>8)&0xff);  data[17] = (u8)((pBt->pageSize>>16)&0xff);  data[18] = 1;  data[19] = 1;  assert( pBt->usableSize<=pBt->pageSize && pBt->usableSize+255>=pBt->pageSize);  data[20] = (u8)(pBt->pageSize - pBt->usableSize);  data[21] = 64;  data[22] = 32;  data[23] = 32;  memset(&data[24], 0, 100-24);  zeroPage(pP1, PTF_INTKEY|PTF_LEAF|PTF_LEAFDATA );  pBt->btsFlags |= BTS_PAGESIZE_FIXED;
#ifndef SQLITE_OMIT_AUTOVACUUM
 assert( pBt->autoVacuum==1 || pBt->autoVacuum==0 );  assert( pBt->incrVacuum==1 || pBt->incrVacuum==0 );  put4byte(&data[36 + 4*4], pBt->autoVacuum);  put4byte(&data[36 + 7*4], pBt->incrVacuum);
#endif
 pBt->nPage = 1;  data[31] = 1;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeNewDb(Btree *p){  int rc;  sqlite3BtreeEnter(p);  p->pBt->nPage = 0;  rc = newDatabase(p->pBt);  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){  BtShared *pBt = p->pBt;  Pager *pPager = pBt->pPager;  int rc = SQLITE_OK;  sqlite3BtreeEnter(p);  btreeIntegrity(p);  if( p->inTrans==TRANS_WRITE || (p->inTrans==TRANS_READ && !wrflag) ){  goto trans_begun;  }  assert( pBt->inTransaction==TRANS_WRITE || IfNotOmitAV(pBt->bDoTruncate)==0 );  if( (p->db->flags & SQLITE_ResetDatabase)   && sqlite3PagerIsreadonly(pPager)==0  ){  pBt->btsFlags &= ~BTS_READ_ONLY;  }  if( (pBt->btsFlags & BTS_READ_ONLY)!=0 && wrflag ){  rc = SQLITE_READONLY;  goto trans_begun;  }
#ifndef SQLITE_OMIT_SHARED_CACHE
 {  sqlite3 *pBlock = 0;  if( (wrflag && pBt->inTransaction==TRANS_WRITE)   || (pBt->btsFlags & BTS_PENDING)!=0  ){  pBlock = pBt->pWriter->db;  }else if( wrflag>1 ){  BtLock *pIter;  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){  if( pIter->pBtree!=p ){  pBlock = pIter->pBtree->db;  break;  }  }  }  if( pBlock ){  sqlite3ConnectionBlocked(p->db, pBlock);  rc = SQLITE_LOCKED_SHAREDCACHE;  goto trans_begun;  }  }
#endif
 rc = querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK);  if( SQLITE_OK!=rc ) goto trans_begun;  pBt->btsFlags &= ~BTS_INITIALLY_EMPTY;  if( pBt->nPage==0 ) pBt->btsFlags |= BTS_INITIALLY_EMPTY;  do {  sqlite3PagerWalDb(pPager, p->db);
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 if( pBt->pPage1==0 && wrflag ){  assert( pBt->inTransaction==TRANS_NONE );  rc = sqlite3PagerWalWriteLock(pPager, 1);  if( rc!=SQLITE_BUSY && rc!=SQLITE_OK ) break;  }
#endif
 while( pBt->pPage1==0 && SQLITE_OK==(rc = lockBtree(pBt)) );  if( rc==SQLITE_OK && wrflag ){  if( (pBt->btsFlags & BTS_READ_ONLY)!=0 ){  rc = SQLITE_READONLY;  }else{  rc = sqlite3PagerBegin(pPager, wrflag>1, sqlite3TempInMemory(p->db));  if( rc==SQLITE_OK ){  rc = newDatabase(pBt);  }else if( rc==SQLITE_BUSY_SNAPSHOT && pBt->inTransaction==TRANS_NONE ){  rc = SQLITE_BUSY;  }  }  }  if( rc!=SQLITE_OK ){  (void)sqlite3PagerWalWriteLock(pPager, 0);  unlockBtreeIfUnused(pBt);  }  }while( (rc&0xFF)==SQLITE_BUSY && pBt->inTransaction==TRANS_NONE &&  btreeInvokeBusyHandler(pBt) );  sqlite3PagerWalDb(pPager, 0);
#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
 if( rc==SQLITE_BUSY_TIMEOUT ) rc = SQLITE_BUSY;
#endif
 if( rc==SQLITE_OK ){  if( p->inTrans==TRANS_NONE ){  pBt->nTransaction++;
#ifndef SQLITE_OMIT_SHARED_CACHE
 if( p->sharable ){  assert( p->lock.pBtree==p && p->lock.iTable==1 );  p->lock.eLock = READ_LOCK;  p->lock.pNext = pBt->pLock;  pBt->pLock = &p->lock;  }
#endif
 }  p->inTrans = (wrflag?TRANS_WRITE:TRANS_READ);  if( p->inTrans>pBt->inTransaction ){  pBt->inTransaction = p->inTrans;  }  if( wrflag ){  MemPage *pPage1 = pBt->pPage1;
#ifndef SQLITE_OMIT_SHARED_CACHE
 assert( !pBt->pWriter );  pBt->pWriter = p;  pBt->btsFlags &= ~BTS_EXCLUSIVE;  if( wrflag>1 ) pBt->btsFlags |= BTS_EXCLUSIVE;
#endif
 if( pBt->nPage!=get4byte(&pPage1->aData[28]) ){  rc = sqlite3PagerWrite(pPage1->pDbPage);  if( rc==SQLITE_OK ){  put4byte(&pPage1->aData[28], pBt->nPage);  }  }  }  } trans_begun:  if( rc==SQLITE_OK ){  if( pSchemaVersion ){  *pSchemaVersion = get4byte(&pBt->pPage1->aData[40]);  }  if( wrflag ){  rc = sqlite3PagerOpenSavepoint(pPager, p->db->nSavepoint);  }  }  btreeIntegrity(p);  sqlite3BtreeLeave(p);  return rc; }
#ifndef SQLITE_OMIT_AUTOVACUUM
static int setChildPtrmaps(MemPage *pPage){  int i;  int nCell;  int rc;  BtShared *pBt = pPage->pBt;  Pgno pgno = pPage->pgno;  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);  if( rc!=SQLITE_OK ) return rc;  nCell = pPage->nCell;  for(i=0; i<nCell; i++){  u8 *pCell = findCell(pPage, i);  ptrmapPutOvflPtr(pPage, pPage, pCell, &rc);  if( !pPage->leaf ){  Pgno childPgno = get4byte(pCell);  ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, &rc);  }  }  if( !pPage->leaf ){  Pgno childPgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);  ptrmapPut(pBt, childPgno, PTRMAP_BTREE, pgno, &rc);  }  return rc; } static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  if( eType==PTRMAP_OVERFLOW2 ){  if( get4byte(pPage->aData)!=iFrom ){  return SQLITE_CORRUPT_PAGE(pPage);  }  put4byte(pPage->aData, iTo);  }else{  int i;  int nCell;  int rc;  rc = pPage->isInit ? SQLITE_OK : btreeInitPage(pPage);  if( rc ) return rc;  nCell = pPage->nCell;  for(i=0; i<nCell; i++){  u8 *pCell = findCell(pPage, i);  if( eType==PTRMAP_OVERFLOW1 ){  CellInfo info;  pPage->xParseCell(pPage, pCell, &info);  if( info.nLocal<info.nPayload ){  if( pCell+info.nSize > pPage->aData+pPage->pBt->usableSize ){  return SQLITE_CORRUPT_PAGE(pPage);  }  if( iFrom==get4byte(pCell+info.nSize-4) ){  put4byte(pCell+info.nSize-4, iTo);  break;  }  }  }else{  if( get4byte(pCell)==iFrom ){  put4byte(pCell, iTo);  break;  }  }  }  if( i==nCell ){  if( eType!=PTRMAP_BTREE ||  get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){  return SQLITE_CORRUPT_PAGE(pPage);  }  put4byte(&pPage->aData[pPage->hdrOffset+8], iTo);  }  }  return SQLITE_OK; } static int relocatePage(  BtShared *pBt,  MemPage *pDbPage,  u8 eType,  Pgno iPtrPage,  Pgno iFreePage,  int isCommit ){  MemPage *pPtrPage;  Pgno iDbPage = pDbPage->pgno;  Pager *pPager = pBt->pPager;  int rc;  assert( eType==PTRMAP_OVERFLOW2 || eType==PTRMAP_OVERFLOW1 ||  eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE );  assert( sqlite3_mutex_held(pBt->mutex) );  assert( pDbPage->pBt==pBt );  if( iDbPage<3 ) return SQLITE_CORRUPT_BKPT;  TRACE(("AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\n",  iDbPage, iFreePage, iPtrPage, eType));  rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);  if( rc!=SQLITE_OK ){  return rc;  }  pDbPage->pgno = iFreePage;  if( eType==PTRMAP_BTREE || eType==PTRMAP_ROOTPAGE ){  rc = setChildPtrmaps(pDbPage);  if( rc!=SQLITE_OK ){  return rc;  }  }else{  Pgno nextOvfl = get4byte(pDbPage->aData);  if( nextOvfl!=0 ){  ptrmapPut(pBt, nextOvfl, PTRMAP_OVERFLOW2, iFreePage, &rc);  if( rc!=SQLITE_OK ){  return rc;  }  }  }  if( eType!=PTRMAP_ROOTPAGE ){  rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0);  if( rc!=SQLITE_OK ){  return rc;  }  rc = sqlite3PagerWrite(pPtrPage->pDbPage);  if( rc!=SQLITE_OK ){  releasePage(pPtrPage);  return rc;  }  rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);  releasePage(pPtrPage);  if( rc==SQLITE_OK ){  ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc);  }  }  return rc; } static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8); static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){  Pgno nFreeList;  int rc;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( iLastPg>nFin );  if( !PTRMAP_ISPAGE(pBt, iLastPg) && iLastPg!=PENDING_BYTE_PAGE(pBt) ){  u8 eType;  Pgno iPtrPage;  nFreeList = get4byte(&pBt->pPage1->aData[36]);  if( nFreeList==0 ){  return SQLITE_DONE;  }  rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);  if( rc!=SQLITE_OK ){  return rc;  }  if( eType==PTRMAP_ROOTPAGE ){  return SQLITE_CORRUPT_BKPT;  }  if( eType==PTRMAP_FREEPAGE ){  if( bCommit==0 ){  Pgno iFreePg;  MemPage *pFreePg;  rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, BTALLOC_EXACT);  if( rc!=SQLITE_OK ){  return rc;  }  assert( iFreePg==iLastPg );  releasePage(pFreePg);  }  } else {  Pgno iFreePg;  MemPage *pLastPg;  u8 eMode = BTALLOC_ANY;  Pgno iNear = 0;  rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);  if( rc!=SQLITE_OK ){  return rc;  }  if( bCommit==0 ){  eMode = BTALLOC_LE;  iNear = nFin;  }  do {  MemPage *pFreePg;  rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);  if( rc!=SQLITE_OK ){  releasePage(pLastPg);  return rc;  }  releasePage(pFreePg);  }while( bCommit && iFreePg>nFin );  assert( iFreePg<iLastPg );  rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);  releasePage(pLastPg);  if( rc!=SQLITE_OK ){  return rc;  }  }  }  if( bCommit==0 ){  do {  iLastPg--;  }while( iLastPg==PENDING_BYTE_PAGE(pBt) || PTRMAP_ISPAGE(pBt, iLastPg) );  pBt->bDoTruncate = 1;  pBt->nPage = iLastPg;  }  return SQLITE_OK; } static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree){  int nEntry;  Pgno nPtrmap;  Pgno nFin;  nEntry = pBt->usableSize/5;  nPtrmap = (nFree-nOrig+PTRMAP_PAGENO(pBt, nOrig)+nEntry)/nEntry;  nFin = nOrig - nFree - nPtrmap;  if( nOrig>PENDING_BYTE_PAGE(pBt) && nFin<PENDING_BYTE_PAGE(pBt) ){  nFin--;  }  while( PTRMAP_ISPAGE(pBt, nFin) || nFin==PENDING_BYTE_PAGE(pBt) ){  nFin--;  }  return nFin; } SQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *p){  int rc;  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);  assert( pBt->inTransaction==TRANS_WRITE && p->inTrans==TRANS_WRITE );  if( !pBt->autoVacuum ){  rc = SQLITE_DONE;  }else{  Pgno nOrig = btreePagecount(pBt);  Pgno nFree = get4byte(&pBt->pPage1->aData[36]);  Pgno nFin = finalDbSize(pBt, nOrig, nFree);  if( nOrig<nFin || nFree>=nOrig ){  rc = SQLITE_CORRUPT_BKPT;  }else if( nFree>0 ){  rc = saveAllCursors(pBt, 0, 0);  if( rc==SQLITE_OK ){  invalidateAllOverflowCache(pBt);  rc = incrVacuumStep(pBt, nFin, nOrig, 0);  }  if( rc==SQLITE_OK ){  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);  put4byte(&pBt->pPage1->aData[28], pBt->nPage);  }  }else{  rc = SQLITE_DONE;  }  }  sqlite3BtreeLeave(p);  return rc; } static int autoVacuumCommit(Btree *p){  int rc = SQLITE_OK;  Pager *pPager;  BtShared *pBt;  sqlite3 *db;  VVA_ONLY( int nRef );  assert( p!=0 );  pBt = p->pBt;  pPager = pBt->pPager;  VVA_ONLY( nRef = sqlite3PagerRefcount(pPager); )  assert( sqlite3_mutex_held(pBt->mutex) );  invalidateAllOverflowCache(pBt);  assert(pBt->autoVacuum);  if( !pBt->incrVacuum ){  Pgno nFin;  Pgno nFree;  Pgno nVac;  Pgno iFree;  Pgno nOrig;  nOrig = btreePagecount(pBt);  if( PTRMAP_ISPAGE(pBt, nOrig) || nOrig==PENDING_BYTE_PAGE(pBt) ){  return SQLITE_CORRUPT_BKPT;  }  nFree = get4byte(&pBt->pPage1->aData[36]);  db = p->db;  if( db->xAutovacPages ){  int iDb;  for(iDb=0; ALWAYS(iDb<db->nDb); iDb++){  if( db->aDb[iDb].pBt==p ) break;  }  nVac = db->xAutovacPages(  db->pAutovacPagesArg,  db->aDb[iDb].zDbSName,  nOrig,  nFree,  pBt->pageSize  );  if( nVac>nFree ){  nVac = nFree;  }  if( nVac==0 ){  return SQLITE_OK;  }  }else{  nVac = nFree;  }  nFin = finalDbSize(pBt, nOrig, nVac);  if( nFin>nOrig ) return SQLITE_CORRUPT_BKPT;  if( nFin<nOrig ){  rc = saveAllCursors(pBt, 0, 0);  }  for(iFree=nOrig; iFree>nFin && rc==SQLITE_OK; iFree--){  rc = incrVacuumStep(pBt, nFin, iFree, nVac==nFree);  }  if( (rc==SQLITE_DONE || rc==SQLITE_OK) && nFree>0 ){  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);  if( nVac==nFree ){  put4byte(&pBt->pPage1->aData[32], 0);  put4byte(&pBt->pPage1->aData[36], 0);  }  put4byte(&pBt->pPage1->aData[28], nFin);  pBt->bDoTruncate = 1;  pBt->nPage = nFin;  }  if( rc!=SQLITE_OK ){  sqlite3PagerRollback(pPager);  }  }  assert( nRef>=sqlite3PagerRefcount(pPager) );  return rc; }
#else
# define setChildPtrmaps(x) SQLITE_OK
#endif
SQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zSuperJrnl){  int rc = SQLITE_OK;  if( p->inTrans==TRANS_WRITE ){  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum ){  rc = autoVacuumCommit(p);  if( rc!=SQLITE_OK ){  sqlite3BtreeLeave(p);  return rc;  }  }  if( pBt->bDoTruncate ){  sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);  }
#endif
 rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zSuperJrnl, 0);  sqlite3BtreeLeave(p);  }  return rc; } static void btreeEndTransaction(Btree *p){  BtShared *pBt = p->pBt;  sqlite3 *db = p->db;  assert( sqlite3BtreeHoldsMutex(p) );
#ifndef SQLITE_OMIT_AUTOVACUUM
 pBt->bDoTruncate = 0;
#endif
 if( p->inTrans>TRANS_NONE && db->nVdbeRead>1 ){  downgradeAllSharedCacheTableLocks(p);  p->inTrans = TRANS_READ;  }else{  if( p->inTrans!=TRANS_NONE ){  clearAllSharedCacheTableLocks(p);  pBt->nTransaction--;  if( 0==pBt->nTransaction ){  pBt->inTransaction = TRANS_NONE;  }  }  p->inTrans = TRANS_NONE;  unlockBtreeIfUnused(pBt);  }  btreeIntegrity(p); } SQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup){  if( p->inTrans==TRANS_NONE ) return SQLITE_OK;  sqlite3BtreeEnter(p);  btreeIntegrity(p);  if( p->inTrans==TRANS_WRITE ){  int rc;  BtShared *pBt = p->pBt;  assert( pBt->inTransaction==TRANS_WRITE );  assert( pBt->nTransaction>0 );  rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);  if( rc!=SQLITE_OK && bCleanup==0 ){  sqlite3BtreeLeave(p);  return rc;  }  p->iBDataVersion--;  pBt->inTransaction = TRANS_READ;  btreeClearHasContent(pBt);  }  btreeEndTransaction(p);  sqlite3BtreeLeave(p);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeCommit(Btree *p){  int rc;  sqlite3BtreeEnter(p);  rc = sqlite3BtreeCommitPhaseOne(p, 0);  if( rc==SQLITE_OK ){  rc = sqlite3BtreeCommitPhaseTwo(p, 0);  }  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int writeOnly){  BtCursor *p;  int rc = SQLITE_OK;  assert( (writeOnly==0 || writeOnly==1) && BTCF_WriteFlag==1 );  if( pBtree ){  sqlite3BtreeEnter(pBtree);  for(p=pBtree->pBt->pCursor; p; p=p->pNext){  if( writeOnly && (p->curFlags & BTCF_WriteFlag)==0 ){  if( p->eState==CURSOR_VALID || p->eState==CURSOR_SKIPNEXT ){  rc = saveCursorPosition(p);  if( rc!=SQLITE_OK ){  (void)sqlite3BtreeTripAllCursors(pBtree, rc, 0);  break;  }  }  }else{  sqlite3BtreeClearCursor(p);  p->eState = CURSOR_FAULT;  p->skipNext = errCode;  }  btreeReleaseAllCursorPages(p);  }  sqlite3BtreeLeave(pBtree);  }  return rc; } static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){  int nPage = get4byte(&pPage1->aData[28]);  testcase( nPage==0 );  if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);  testcase( pBt->nPage!=(u32)nPage );  pBt->nPage = nPage; } SQLITE_PRIVATE int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){  int rc;  BtShared *pBt = p->pBt;  MemPage *pPage1;  assert( writeOnly==1 || writeOnly==0 );  assert( tripCode==SQLITE_ABORT_ROLLBACK || tripCode==SQLITE_OK );  sqlite3BtreeEnter(p);  if( tripCode==SQLITE_OK ){  rc = tripCode = saveAllCursors(pBt, 0, 0);  if( rc ) writeOnly = 0;  }else{  rc = SQLITE_OK;  }  if( tripCode ){  int rc2 = sqlite3BtreeTripAllCursors(p, tripCode, writeOnly);  assert( rc==SQLITE_OK || (writeOnly==0 && rc2==SQLITE_OK) );  if( rc2!=SQLITE_OK ) rc = rc2;  }  btreeIntegrity(p);  if( p->inTrans==TRANS_WRITE ){  int rc2;  assert( TRANS_WRITE==pBt->inTransaction );  rc2 = sqlite3PagerRollback(pBt->pPager);  if( rc2!=SQLITE_OK ){  rc = rc2;  }  if( btreeGetPage(pBt, 1, &pPage1, 0)==SQLITE_OK ){  btreeSetNPage(pBt, pPage1);  releasePageOne(pPage1);  }  assert( countValidCursors(pBt, 1)==0 );  pBt->inTransaction = TRANS_READ;  btreeClearHasContent(pBt);  }  btreeEndTransaction(p);  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree *p, int iStatement){  int rc;  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);  assert( p->inTrans==TRANS_WRITE );  assert( (pBt->btsFlags & BTS_READ_ONLY)==0 );  assert( iStatement>0 );  assert( iStatement>p->db->nSavepoint );  assert( pBt->inTransaction==TRANS_WRITE );  rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement);  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){  int rc = SQLITE_OK;  if( p && p->inTrans==TRANS_WRITE ){  BtShared *pBt = p->pBt;  assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );  assert( iSavepoint>=0 || (iSavepoint==-1 && op==SAVEPOINT_ROLLBACK) );  sqlite3BtreeEnter(p);  if( op==SAVEPOINT_ROLLBACK ){  rc = saveAllCursors(pBt, 0, 0);  }  if( rc==SQLITE_OK ){  rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint);  }  if( rc==SQLITE_OK ){  if( iSavepoint<0 && (pBt->btsFlags & BTS_INITIALLY_EMPTY)!=0 ){  pBt->nPage = 0;  }  rc = newDatabase(pBt);  btreeSetNPage(pBt, pBt->pPage1);  assert( CORRUPT_DB || pBt->nPage>0 );  }  sqlite3BtreeLeave(p);  }  return rc; } static int btreeCursor(  Btree *p,  Pgno iTable,  int wrFlag,  struct KeyInfo *pKeyInfo,  BtCursor *pCur ){  BtShared *pBt = p->pBt;  BtCursor *pX;  assert( sqlite3BtreeHoldsMutex(p) );  assert( wrFlag==0   || wrFlag==BTREE_WRCSR   || wrFlag==(BTREE_WRCSR|BTREE_FORDELETE)  );  assert( hasSharedCacheTableLock(p, iTable, pKeyInfo!=0, (wrFlag?2:1))  || iTable<1 );  assert( wrFlag==0 || !hasReadConflicts(p, iTable) );  assert( p->inTrans>TRANS_NONE );  assert( wrFlag==0 || p->inTrans==TRANS_WRITE );  assert( pBt->pPage1 && pBt->pPage1->aData );  assert( wrFlag==0 || (pBt->btsFlags & BTS_READ_ONLY)==0 );  if( wrFlag ){  allocateTempSpace(pBt);  if( pBt->pTmpSpace==0 ) return SQLITE_NOMEM_BKPT;  }  if( iTable<=1 ){  if( iTable<1 ){  return SQLITE_CORRUPT_BKPT;  }else if( btreePagecount(pBt)==0 ){  assert( wrFlag==0 );  iTable = 0;  }  }  pCur->pgnoRoot = iTable;  pCur->iPage = -1;  pCur->pKeyInfo = pKeyInfo;  pCur->pBtree = p;  pCur->pBt = pBt;  pCur->curFlags = wrFlag ? BTCF_WriteFlag : 0;  pCur->curPagerFlags = wrFlag ? 0 : PAGER_GET_READONLY;  for(pX=pBt->pCursor; pX; pX=pX->pNext){  if( pX->pgnoRoot==iTable ){  pX->curFlags |= BTCF_Multiple;  pCur->curFlags |= BTCF_Multiple;  }  }  pCur->pNext = pBt->pCursor;  pBt->pCursor = pCur;  pCur->eState = CURSOR_INVALID;  return SQLITE_OK; } static int btreeCursorWithLock(  Btree *p,  Pgno iTable,  int wrFlag,  struct KeyInfo *pKeyInfo,  BtCursor *pCur ){  int rc;  sqlite3BtreeEnter(p);  rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeCursor(  Btree *p,  Pgno iTable,  int wrFlag,  struct KeyInfo *pKeyInfo,  BtCursor *pCur ){  if( p->sharable ){  return btreeCursorWithLock(p, iTable, wrFlag, pKeyInfo, pCur);  }else{  return btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);  } } SQLITE_PRIVATE int sqlite3BtreeCursorSize(void){  return ROUND8(sizeof(BtCursor)); } SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor *p){  memset(p, 0, offsetof(BtCursor, BTCURSOR_FIRST_UNINIT)); } SQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor *pCur){  Btree *pBtree = pCur->pBtree;  if( pBtree ){  BtShared *pBt = pCur->pBt;  sqlite3BtreeEnter(pBtree);  assert( pBt->pCursor!=0 );  if( pBt->pCursor==pCur ){  pBt->pCursor = pCur->pNext;  }else{  BtCursor *pPrev = pBt->pCursor;  do{  if( pPrev->pNext==pCur ){  pPrev->pNext = pCur->pNext;  break;  }  pPrev = pPrev->pNext;  }while( ALWAYS(pPrev) );  }  btreeReleaseAllCursorPages(pCur);  unlockBtreeIfUnused(pBt);  sqlite3_free(pCur->aOverflow);  sqlite3_free(pCur->pKey);  if( (pBt->openFlags & BTREE_SINGLE) && pBt->pCursor==0 ){  assert( pBtree->sharable==0 );  sqlite3BtreeClose(pBtree);  }else{  sqlite3BtreeLeave(pBtree);  }  pCur->pBtree = 0;  }  return SQLITE_OK; }
#ifndef NDEBUG
 static int cellInfoEqual(CellInfo *a, CellInfo *b){  if( a->nKey!=b->nKey ) return 0;  if( a->pPayload!=b->pPayload ) return 0;  if( a->nPayload!=b->nPayload ) return 0;  if( a->nLocal!=b->nLocal ) return 0;  if( a->nSize!=b->nSize ) return 0;  return 1;  }  static void assertCellInfo(BtCursor *pCur){  CellInfo info;  memset(&info, 0, sizeof(info));  btreeParseCell(pCur->pPage, pCur->ix, &info);  assert( CORRUPT_DB || cellInfoEqual(&info, &pCur->info) );  }
#else
 #define assertCellInfo(x)
#endif
static SQLITE_NOINLINE void getCellInfo(BtCursor *pCur){  if( pCur->info.nSize==0 ){  pCur->curFlags |= BTCF_ValidNKey;  btreeParseCell(pCur->pPage,pCur->ix,&pCur->info);  }else{  assertCellInfo(pCur);  } }
#ifndef NDEBUG
SQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor *pCur){  return pCur && pCur->eState==CURSOR_VALID; }
#endif
SQLITE_PRIVATE int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){  assert( pCur!=0 );  return pCur->eState==CURSOR_VALID; } SQLITE_PRIVATE i64 sqlite3BtreeIntegerKey(BtCursor *pCur){  assert( cursorHoldsMutex(pCur) );  assert( pCur->eState==CURSOR_VALID );  assert( pCur->curIntKey );  getCellInfo(pCur);  return pCur->info.nKey; } SQLITE_PRIVATE void sqlite3BtreeCursorPin(BtCursor *pCur){  assert( (pCur->curFlags & BTCF_Pinned)==0 );  pCur->curFlags |= BTCF_Pinned; } SQLITE_PRIVATE void sqlite3BtreeCursorUnpin(BtCursor *pCur){  assert( (pCur->curFlags & BTCF_Pinned)!=0 );  pCur->curFlags &= ~BTCF_Pinned; }
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
SQLITE_PRIVATE i64 sqlite3BtreeOffset(BtCursor *pCur){  assert( cursorHoldsMutex(pCur) );  assert( pCur->eState==CURSOR_VALID );  getCellInfo(pCur);  return (i64)pCur->pBt->pageSize*((i64)pCur->pPage->pgno - 1) +   (i64)(pCur->info.pPayload - pCur->pPage->aData); }
#endif
SQLITE_PRIVATE u32 sqlite3BtreePayloadSize(BtCursor *pCur){  assert( cursorHoldsMutex(pCur) );  assert( pCur->eState==CURSOR_VALID );  getCellInfo(pCur);  return pCur->info.nPayload; } SQLITE_PRIVATE sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor *pCur){  assert( cursorHoldsMutex(pCur) );  assert( pCur->eState==CURSOR_VALID );  return pCur->pBt->pageSize * (sqlite3_int64)pCur->pBt->nPage; } static int getOverflowPage(  BtShared *pBt,  Pgno ovfl,  MemPage **ppPage,  Pgno *pPgnoNext ){  Pgno next = 0;  MemPage *pPage = 0;  int rc = SQLITE_OK;  assert( sqlite3_mutex_held(pBt->mutex) );  assert(pPgnoNext);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum ){  Pgno pgno;  Pgno iGuess = ovfl+1;  u8 eType;  while( PTRMAP_ISPAGE(pBt, iGuess) || iGuess==PENDING_BYTE_PAGE(pBt) ){  iGuess++;  }  if( iGuess<=btreePagecount(pBt) ){  rc = ptrmapGet(pBt, iGuess, &eType, &pgno);  if( rc==SQLITE_OK && eType==PTRMAP_OVERFLOW2 && pgno==ovfl ){  next = iGuess;  rc = SQLITE_DONE;  }  }  }
#endif
 assert( next==0 || rc==SQLITE_DONE );  if( rc==SQLITE_OK ){  rc = btreeGetPage(pBt, ovfl, &pPage, (ppPage==0) ? PAGER_GET_READONLY : 0);  assert( rc==SQLITE_OK || pPage==0 );  if( rc==SQLITE_OK ){  next = get4byte(pPage->aData);  }  }  *pPgnoNext = next;  if( ppPage ){  *ppPage = pPage;  }else{  releasePage(pPage);  }  return (rc==SQLITE_DONE ? SQLITE_OK : rc); } static int copyPayload(  void *pPayload,  void *pBuf,  int nByte,  int eOp,  DbPage *pDbPage ){  if( eOp ){  int rc = sqlite3PagerWrite(pDbPage);  if( rc!=SQLITE_OK ){  return rc;  }  memcpy(pPayload, pBuf, nByte);  }else{  memcpy(pBuf, pPayload, nByte);  }  return SQLITE_OK; } static int accessPayload(  BtCursor *pCur,  u32 offset,  u32 amt,  unsigned char *pBuf,  int eOp ){  unsigned char *aPayload;  int rc = SQLITE_OK;  int iIdx = 0;  MemPage *pPage = pCur->pPage;  BtShared *pBt = pCur->pBt;
#ifdef SQLITE_DIRECT_OVERFLOW_READ
 unsigned char * const pBufStart = pBuf;
#endif
 assert( pPage );  assert( eOp==0 || eOp==1 );  assert( pCur->eState==CURSOR_VALID );  if( pCur->ix>=pPage->nCell ){  return SQLITE_CORRUPT_PAGE(pPage);  }  assert( cursorHoldsMutex(pCur) );  getCellInfo(pCur);  aPayload = pCur->info.pPayload;  assert( offset+amt <= pCur->info.nPayload );  assert( aPayload > pPage->aData );  if( (uptr)(aPayload - pPage->aData) > (pBt->usableSize - pCur->info.nLocal) ){  return SQLITE_CORRUPT_PAGE(pPage);  }  if( offset<pCur->info.nLocal ){  int a = amt;  if( a+offset>pCur->info.nLocal ){  a = pCur->info.nLocal - offset;  }  rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage->pDbPage);  offset = 0;  pBuf += a;  amt -= a;  }else{  offset -= pCur->info.nLocal;  }  if( rc==SQLITE_OK && amt>0 ){  const u32 ovflSize = pBt->usableSize - 4;  Pgno nextPage;  nextPage = get4byte(&aPayload[pCur->info.nLocal]);  if( (pCur->curFlags & BTCF_ValidOvfl)==0 ){  int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;  if( pCur->aOverflow==0   || nOvfl*(int)sizeof(Pgno) > sqlite3MallocSize(pCur->aOverflow)  ){  Pgno *aNew = (Pgno*)sqlite3Realloc(  pCur->aOverflow, nOvfl*2*sizeof(Pgno)  );  if( aNew==0 ){  return SQLITE_NOMEM_BKPT;  }else{  pCur->aOverflow = aNew;  }  }  memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));  pCur->curFlags |= BTCF_ValidOvfl;  }else{  if( pCur->aOverflow[offset/ovflSize] ){  iIdx = (offset/ovflSize);  nextPage = pCur->aOverflow[iIdx];  offset = (offset%ovflSize);  }  }  assert( rc==SQLITE_OK && amt>0 );  while( nextPage ){  if( nextPage > pBt->nPage ) return SQLITE_CORRUPT_BKPT;  assert( pCur->aOverflow[iIdx]==0  || pCur->aOverflow[iIdx]==nextPage  || CORRUPT_DB );  pCur->aOverflow[iIdx] = nextPage;  if( offset>=ovflSize ){  assert( pCur->curFlags & BTCF_ValidOvfl );  assert( pCur->pBtree->db==pBt->db );  if( pCur->aOverflow[iIdx+1] ){  nextPage = pCur->aOverflow[iIdx+1];  }else{  rc = getOverflowPage(pBt, nextPage, 0, &nextPage);  }  offset -= ovflSize;  }else{  int a = amt;  if( a + offset > ovflSize ){  a = ovflSize - offset;  }
#ifdef SQLITE_DIRECT_OVERFLOW_READ
 if( eOp==0   && offset==0   && sqlite3PagerDirectReadOk(pBt->pPager, nextPage)   && &pBuf[-4]>=pBufStart  ){  sqlite3_file *fd = sqlite3PagerFile(pBt->pPager);  u8 aSave[4];  u8 *aWrite = &pBuf[-4];  assert( aWrite>=pBufStart );  memcpy(aSave, aWrite, 4);  rc = sqlite3OsRead(fd, aWrite, a+4, (i64)pBt->pageSize*(nextPage-1));  if( rc && nextPage>pBt->nPage ) rc = SQLITE_CORRUPT_BKPT;  nextPage = get4byte(aWrite);  memcpy(aWrite, aSave, 4);  }else
#endif
 {  DbPage *pDbPage;  rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage,  (eOp==0 ? PAGER_GET_READONLY : 0)  );  if( rc==SQLITE_OK ){  aPayload = sqlite3PagerGetData(pDbPage);  nextPage = get4byte(aPayload);  rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage);  sqlite3PagerUnref(pDbPage);  offset = 0;  }  }  amt -= a;  if( amt==0 ) return rc;  pBuf += a;  }  if( rc ) break;  iIdx++;  }  }  if( rc==SQLITE_OK && amt>0 ){  return SQLITE_CORRUPT_PAGE(pPage);  }  return rc; } SQLITE_PRIVATE int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){  assert( cursorHoldsMutex(pCur) );  assert( pCur->eState==CURSOR_VALID );  assert( pCur->iPage>=0 && pCur->pPage );  return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0); }
#ifndef SQLITE_OMIT_INCRBLOB
static SQLITE_NOINLINE int accessPayloadChecked(  BtCursor *pCur,  u32 offset,  u32 amt,  void *pBuf ){  int rc;  if ( pCur->eState==CURSOR_INVALID ){  return SQLITE_ABORT;  }  assert( cursorOwnsBtShared(pCur) );  rc = btreeRestoreCursorPosition(pCur);  return rc ? rc : accessPayload(pCur, offset, amt, pBuf, 0); } SQLITE_PRIVATE int sqlite3BtreePayloadChecked(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){  if( pCur->eState==CURSOR_VALID ){  assert( cursorOwnsBtShared(pCur) );  return accessPayload(pCur, offset, amt, pBuf, 0);  }else{  return accessPayloadChecked(pCur, offset, amt, pBuf);  } }
#endif
static const void *fetchPayload(  BtCursor *pCur,  u32 *pAmt ){  int amt;  assert( pCur!=0 && pCur->iPage>=0 && pCur->pPage);  assert( pCur->eState==CURSOR_VALID );  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );  assert( cursorOwnsBtShared(pCur) );  assert( pCur->ix<pCur->pPage->nCell || CORRUPT_DB );  assert( pCur->info.nSize>0 );  assert( pCur->info.pPayload>pCur->pPage->aData || CORRUPT_DB );  assert( pCur->info.pPayload<pCur->pPage->aDataEnd ||CORRUPT_DB);  amt = pCur->info.nLocal;  if( amt>(int)(pCur->pPage->aDataEnd - pCur->info.pPayload) ){  assert( CORRUPT_DB );  amt = MAX(0, (int)(pCur->pPage->aDataEnd - pCur->info.pPayload));  }  *pAmt = (u32)amt;  return (void*)pCur->info.pPayload; } SQLITE_PRIVATE const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt){  return fetchPayload(pCur, pAmt); } static int moveToChild(BtCursor *pCur, u32 newPgno){  BtShared *pBt = pCur->pBt;  assert( cursorOwnsBtShared(pCur) );  assert( pCur->eState==CURSOR_VALID );  assert( pCur->iPage<BTCURSOR_MAX_DEPTH );  assert( pCur->iPage>=0 );  if( pCur->iPage>=(BTCURSOR_MAX_DEPTH-1) ){  return SQLITE_CORRUPT_BKPT;  }  pCur->info.nSize = 0;  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);  pCur->aiIdx[pCur->iPage] = pCur->ix;  pCur->apPage[pCur->iPage] = pCur->pPage;  pCur->ix = 0;  pCur->iPage++;  return getAndInitPage(pBt, newPgno, &pCur->pPage, pCur, pCur->curPagerFlags); }
#ifdef SQLITE_DEBUG
static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild){  if( CORRUPT_DB ) return;  assert( iIdx<=pParent->nCell );  if( iIdx==pParent->nCell ){  assert( get4byte(&pParent->aData[pParent->hdrOffset+8])==iChild );  }else{  assert( get4byte(findCell(pParent, iIdx))==iChild );  } }
#else
# define assertParentIndex(x,y,z)
#endif
static void moveToParent(BtCursor *pCur){  MemPage *pLeaf;  assert( cursorOwnsBtShared(pCur) );  assert( pCur->eState==CURSOR_VALID );  assert( pCur->iPage>0 );  assert( pCur->pPage );  assertParentIndex(  pCur->apPage[pCur->iPage-1],  pCur->aiIdx[pCur->iPage-1],  pCur->pPage->pgno  );  testcase( pCur->aiIdx[pCur->iPage-1] > pCur->apPage[pCur->iPage-1]->nCell );  pCur->info.nSize = 0;  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);  pCur->ix = pCur->aiIdx[pCur->iPage-1];  pLeaf = pCur->pPage;  pCur->pPage = pCur->apPage[--pCur->iPage];  releasePageNotNull(pLeaf); } static int moveToRoot(BtCursor *pCur){  MemPage *pRoot;  int rc = SQLITE_OK;  assert( cursorOwnsBtShared(pCur) );  assert( CURSOR_INVALID < CURSOR_REQUIRESEEK );  assert( CURSOR_VALID  < CURSOR_REQUIRESEEK );  assert( CURSOR_FAULT  > CURSOR_REQUIRESEEK );  assert( pCur->eState < CURSOR_REQUIRESEEK || pCur->iPage<0 );  assert( pCur->pgnoRoot>0 || pCur->iPage<0 );  if( pCur->iPage>=0 ){  if( pCur->iPage ){  releasePageNotNull(pCur->pPage);  while( --pCur->iPage ){  releasePageNotNull(pCur->apPage[pCur->iPage]);  }  pCur->pPage = pCur->apPage[0];  goto skip_init;  }  }else if( pCur->pgnoRoot==0 ){  pCur->eState = CURSOR_INVALID;  return SQLITE_EMPTY;  }else{  assert( pCur->iPage==(-1) );  if( pCur->eState>=CURSOR_REQUIRESEEK ){  if( pCur->eState==CURSOR_FAULT ){  assert( pCur->skipNext!=SQLITE_OK );  return pCur->skipNext;  }  sqlite3BtreeClearCursor(pCur);  }  rc = getAndInitPage(pCur->pBtree->pBt, pCur->pgnoRoot, &pCur->pPage,  0, pCur->curPagerFlags);  if( rc!=SQLITE_OK ){  pCur->eState = CURSOR_INVALID;  return rc;  }  pCur->iPage = 0;  pCur->curIntKey = pCur->pPage->intKey;  }  pRoot = pCur->pPage;  assert( pRoot->pgno==pCur->pgnoRoot );  assert( pRoot->intKey==1 || pRoot->intKey==0 );  if( pRoot->isInit==0 || (pCur->pKeyInfo==0)!=pRoot->intKey ){  return SQLITE_CORRUPT_PAGE(pCur->pPage);  } skip_init:  pCur->ix = 0;  pCur->info.nSize = 0;  pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidNKey|BTCF_ValidOvfl);  pRoot = pCur->pPage;  if( pRoot->nCell>0 ){  pCur->eState = CURSOR_VALID;  }else if( !pRoot->leaf ){  Pgno subpage;  if( pRoot->pgno!=1 ) return SQLITE_CORRUPT_BKPT;  subpage = get4byte(&pRoot->aData[pRoot->hdrOffset+8]);  pCur->eState = CURSOR_VALID;  rc = moveToChild(pCur, subpage);  }else{  pCur->eState = CURSOR_INVALID;  rc = SQLITE_EMPTY;  }  return rc; } static int moveToLeftmost(BtCursor *pCur){  Pgno pgno;  int rc = SQLITE_OK;  MemPage *pPage;  assert( cursorOwnsBtShared(pCur) );  assert( pCur->eState==CURSOR_VALID );  while( rc==SQLITE_OK && !(pPage = pCur->pPage)->leaf ){  assert( pCur->ix<pPage->nCell );  pgno = get4byte(findCell(pPage, pCur->ix));  rc = moveToChild(pCur, pgno);  }  return rc; } static int moveToRightmost(BtCursor *pCur){  Pgno pgno;  int rc = SQLITE_OK;  MemPage *pPage = 0;  assert( cursorOwnsBtShared(pCur) );  assert( pCur->eState==CURSOR_VALID );  while( !(pPage = pCur->pPage)->leaf ){  pgno = get4byte(&pPage->aData[pPage->hdrOffset+8]);  pCur->ix = pPage->nCell;  rc = moveToChild(pCur, pgno);  if( rc ) return rc;  }  pCur->ix = pPage->nCell-1;  assert( pCur->info.nSize==0 );  assert( (pCur->curFlags & BTCF_ValidNKey)==0 );  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){  int rc;  assert( cursorOwnsBtShared(pCur) );  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );  rc = moveToRoot(pCur);  if( rc==SQLITE_OK ){  assert( pCur->pPage->nCell>0 );  *pRes = 0;  rc = moveToLeftmost(pCur);  }else if( rc==SQLITE_EMPTY ){  assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );  *pRes = 1;  rc = SQLITE_OK;  }  return rc; } SQLITE_PRIVATE int sqlite3BtreeLast(BtCursor *pCur, int *pRes){  int rc;  assert( cursorOwnsBtShared(pCur) );  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );  if( CURSOR_VALID==pCur->eState && (pCur->curFlags & BTCF_AtLast)!=0 ){
#ifdef SQLITE_DEBUG
 int ii;  for(ii=0; ii<pCur->iPage; ii++){  assert( pCur->aiIdx[ii]==pCur->apPage[ii]->nCell );  }  assert( pCur->ix==pCur->pPage->nCell-1 || CORRUPT_DB );  testcase( pCur->ix!=pCur->pPage->nCell-1 );  assert( pCur->pPage->leaf );
#endif
 *pRes = 0;  return SQLITE_OK;  }  rc = moveToRoot(pCur);  if( rc==SQLITE_OK ){  assert( pCur->eState==CURSOR_VALID );  *pRes = 0;  rc = moveToRightmost(pCur);  if( rc==SQLITE_OK ){  pCur->curFlags |= BTCF_AtLast;  }else{  pCur->curFlags &= ~BTCF_AtLast;  }  }else if( rc==SQLITE_EMPTY ){  assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );  *pRes = 1;  rc = SQLITE_OK;  }  return rc; } SQLITE_PRIVATE int sqlite3BtreeTableMoveto(  BtCursor *pCur,  i64 intKey,  int biasRight,  int *pRes ){  int rc;  assert( cursorOwnsBtShared(pCur) );  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );  assert( pRes );  assert( pCur->pKeyInfo==0 );  assert( pCur->eState!=CURSOR_VALID || pCur->curIntKey!=0 );  if( pCur->eState==CURSOR_VALID && (pCur->curFlags & BTCF_ValidNKey)!=0 ){  if( pCur->info.nKey==intKey ){  *pRes = 0;  return SQLITE_OK;  }  if( pCur->info.nKey<intKey ){  if( (pCur->curFlags & BTCF_AtLast)!=0 ){  *pRes = -1;  return SQLITE_OK;  }  if( pCur->info.nKey+1==intKey ){  *pRes = 0;  rc = sqlite3BtreeNext(pCur, 0);  if( rc==SQLITE_OK ){  getCellInfo(pCur);  if( pCur->info.nKey==intKey ){  return SQLITE_OK;  }  }else if( rc!=SQLITE_DONE ){  return rc;  }  }  }  }
#ifdef SQLITE_DEBUG
 pCur->pBtree->nSeek++;
#endif
 rc = moveToRoot(pCur);  if( rc ){  if( rc==SQLITE_EMPTY ){  assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );  *pRes = -1;  return SQLITE_OK;  }  return rc;  }  assert( pCur->pPage );  assert( pCur->pPage->isInit );  assert( pCur->eState==CURSOR_VALID );  assert( pCur->pPage->nCell > 0 );  assert( pCur->iPage==0 || pCur->apPage[0]->intKey==pCur->curIntKey );  assert( pCur->curIntKey );  for(;;){  int lwr, upr, idx, c;  Pgno chldPg;  MemPage *pPage = pCur->pPage;  u8 *pCell;  assert( pPage->nCell>0 );  assert( pPage->intKey );  lwr = 0;  upr = pPage->nCell-1;  assert( biasRight==0 || biasRight==1 );  idx = upr>>(1-biasRight);  pCur->ix = (u16)idx;  for(;;){  i64 nCellKey;  pCell = findCellPastPtr(pPage, idx);  if( pPage->intKeyLeaf ){  while( 0x80 <= *(pCell++) ){  if( pCell>=pPage->aDataEnd ){  return SQLITE_CORRUPT_PAGE(pPage);  }  }  }  getVarint(pCell, (u64*)&nCellKey);  if( nCellKey<intKey ){  lwr = idx+1;  if( lwr>upr ){ c = -1; break; }  }else if( nCellKey>intKey ){  upr = idx-1;  if( lwr>upr ){ c = +1; break; }  }else{  assert( nCellKey==intKey );  pCur->ix = (u16)idx;  if( !pPage->leaf ){  lwr = idx;  goto moveto_table_next_layer;  }else{  pCur->curFlags |= BTCF_ValidNKey;  pCur->info.nKey = nCellKey;  pCur->info.nSize = 0;  *pRes = 0;  return SQLITE_OK;  }  }  assert( lwr+upr>=0 );  idx = (lwr+upr)>>1;  }  assert( lwr==upr+1 || !pPage->leaf );  assert( pPage->isInit );  if( pPage->leaf ){  assert( pCur->ix<pCur->pPage->nCell );  pCur->ix = (u16)idx;  *pRes = c;  rc = SQLITE_OK;  goto moveto_table_finish;  } moveto_table_next_layer:  if( lwr>=pPage->nCell ){  chldPg = get4byte(&pPage->aData[pPage->hdrOffset+8]);  }else{  chldPg = get4byte(findCell(pPage, lwr));  }  pCur->ix = (u16)lwr;  rc = moveToChild(pCur, chldPg);  if( rc ) break;  } moveto_table_finish:  pCur->info.nSize = 0;  assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );  return rc; } SQLITE_PRIVATE int sqlite3BtreeIndexMoveto(  BtCursor *pCur,  UnpackedRecord *pIdxKey,  int *pRes ){  int rc;  RecordCompare xRecordCompare;  assert( cursorOwnsBtShared(pCur) );  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );  assert( pRes );  assert( pCur->pKeyInfo!=0 );
#ifdef SQLITE_DEBUG
 pCur->pBtree->nSeek++;
#endif
 xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);  pIdxKey->errCode = 0;  assert( pIdxKey->default_rc==1   || pIdxKey->default_rc==0   || pIdxKey->default_rc==-1  );  rc = moveToRoot(pCur);  if( rc ){  if( rc==SQLITE_EMPTY ){  assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );  *pRes = -1;  return SQLITE_OK;  }  return rc;  }  assert( pCur->pPage );  assert( pCur->pPage->isInit );  assert( pCur->eState==CURSOR_VALID );  assert( pCur->pPage->nCell > 0 );  assert( pCur->iPage==0 || pCur->apPage[0]->intKey==pCur->curIntKey );  assert( pCur->curIntKey || pIdxKey );  for(;;){  int lwr, upr, idx, c;  Pgno chldPg;  MemPage *pPage = pCur->pPage;  u8 *pCell;  assert( pPage->nCell>0 );  assert( pPage->intKey==(pIdxKey==0) );  lwr = 0;  upr = pPage->nCell-1;  idx = upr>>1;  pCur->ix = (u16)idx;  for(;;){  int nCell;  pCell = findCellPastPtr(pPage, idx);  nCell = pCell[0];  if( nCell<=pPage->max1bytePayload ){  testcase( pCell+nCell+1==pPage->aDataEnd );  c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);  }else if( !(pCell[1] & 0x80)  && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal  ){  testcase( pCell+nCell+2==pPage->aDataEnd );  c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);  }else{  void *pCellKey;  u8 * const pCellBody = pCell - pPage->childPtrSize;  const int nOverrun = 18;  pPage->xParseCell(pPage, pCellBody, &pCur->info);  nCell = (int)pCur->info.nKey;  testcase( nCell<0 );  testcase( nCell==0 );  testcase( nCell==1 );  testcase( nCell==2 );  if( nCell<2 || nCell/pCur->pBt->usableSize>pCur->pBt->nPage ){  rc = SQLITE_CORRUPT_PAGE(pPage);  goto moveto_index_finish;  }  pCellKey = sqlite3Malloc( nCell+nOverrun );  if( pCellKey==0 ){  rc = SQLITE_NOMEM_BKPT;  goto moveto_index_finish;  }  pCur->ix = (u16)idx;  rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);  memset(((u8*)pCellKey)+nCell,0,nOverrun);  pCur->curFlags &= ~BTCF_ValidOvfl;  if( rc ){  sqlite3_free(pCellKey);  goto moveto_index_finish;  }  c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);  sqlite3_free(pCellKey);  }  assert(  (pIdxKey->errCode!=SQLITE_CORRUPT || c==0)   && (pIdxKey->errCode!=SQLITE_NOMEM || pCur->pBtree->db->mallocFailed)  );  if( c<0 ){  lwr = idx+1;  }else if( c>0 ){  upr = idx-1;  }else{  assert( c==0 );  *pRes = 0;  rc = SQLITE_OK;  pCur->ix = (u16)idx;  if( pIdxKey->errCode ) rc = SQLITE_CORRUPT_BKPT;  goto moveto_index_finish;  }  if( lwr>upr ) break;  assert( lwr+upr>=0 );  idx = (lwr+upr)>>1;  }  assert( lwr==upr+1 || (pPage->intKey && !pPage->leaf) );  assert( pPage->isInit );  if( pPage->leaf ){  assert( pCur->ix<pCur->pPage->nCell );  pCur->ix = (u16)idx;  *pRes = c;  rc = SQLITE_OK;  goto moveto_index_finish;  }  if( lwr>=pPage->nCell ){  chldPg = get4byte(&pPage->aData[pPage->hdrOffset+8]);  }else{  chldPg = get4byte(findCell(pPage, lwr));  }  pCur->ix = (u16)lwr;  rc = moveToChild(pCur, chldPg);  if( rc ) break;  } moveto_index_finish:  pCur->info.nSize = 0;  assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );  return rc; } SQLITE_PRIVATE int sqlite3BtreeEof(BtCursor *pCur){  return (CURSOR_VALID!=pCur->eState); } SQLITE_PRIVATE i64 sqlite3BtreeRowCountEst(BtCursor *pCur){  i64 n;  u8 i;  assert( cursorOwnsBtShared(pCur) );  assert( sqlite3_mutex_held(pCur->pBtree->db->mutex) );  if( NEVER(pCur->eState!=CURSOR_VALID) ) return -1;  if( NEVER(pCur->pPage->leaf==0) ) return -1;  n = pCur->pPage->nCell;  for(i=0; i<pCur->iPage; i++){  n *= pCur->apPage[i]->nCell;  }  return n; } static SQLITE_NOINLINE int btreeNext(BtCursor *pCur){  int rc;  int idx;  MemPage *pPage;  assert( cursorOwnsBtShared(pCur) );  if( pCur->eState!=CURSOR_VALID ){  assert( (pCur->curFlags & BTCF_ValidOvfl)==0 );  rc = restoreCursorPosition(pCur);  if( rc!=SQLITE_OK ){  return rc;  }  if( CURSOR_INVALID==pCur->eState ){  return SQLITE_DONE;  }  if( pCur->eState==CURSOR_SKIPNEXT ){  pCur->eState = CURSOR_VALID;  if( pCur->skipNext>0 ) return SQLITE_OK;  }  }  pPage = pCur->pPage;  idx = ++pCur->ix;  if( !pPage->isInit || sqlite3FaultSim(412) ){  return SQLITE_CORRUPT_BKPT;  }  if( idx>=pPage->nCell ){  if( !pPage->leaf ){  rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset+8]));  if( rc ) return rc;  return moveToLeftmost(pCur);  }  do{  if( pCur->iPage==0 ){  pCur->eState = CURSOR_INVALID;  return SQLITE_DONE;  }  moveToParent(pCur);  pPage = pCur->pPage;  }while( pCur->ix>=pPage->nCell );  if( pPage->intKey ){  return sqlite3BtreeNext(pCur, 0);  }else{  return SQLITE_OK;  }  }  if( pPage->leaf ){  return SQLITE_OK;  }else{  return moveToLeftmost(pCur);  } } SQLITE_PRIVATE int sqlite3BtreeNext(BtCursor *pCur, int flags){  MemPage *pPage;  UNUSED_PARAMETER( flags );  assert( cursorOwnsBtShared(pCur) );  assert( flags==0 || flags==1 );  pCur->info.nSize = 0;  pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);  if( pCur->eState!=CURSOR_VALID ) return btreeNext(pCur);  pPage = pCur->pPage;  if( (++pCur->ix)>=pPage->nCell ){  pCur->ix--;  return btreeNext(pCur);  }  if( pPage->leaf ){  return SQLITE_OK;  }else{  return moveToLeftmost(pCur);  } } static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur){  int rc;  MemPage *pPage;  assert( cursorOwnsBtShared(pCur) );  assert( (pCur->curFlags & (BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey))==0 );  assert( pCur->info.nSize==0 );  if( pCur->eState!=CURSOR_VALID ){  rc = restoreCursorPosition(pCur);  if( rc!=SQLITE_OK ){  return rc;  }  if( CURSOR_INVALID==pCur->eState ){  return SQLITE_DONE;  }  if( CURSOR_SKIPNEXT==pCur->eState ){  pCur->eState = CURSOR_VALID;  if( pCur->skipNext<0 ) return SQLITE_OK;  }  }  pPage = pCur->pPage;  assert( pPage->isInit );  if( !pPage->leaf ){  int idx = pCur->ix;  rc = moveToChild(pCur, get4byte(findCell(pPage, idx)));  if( rc ) return rc;  rc = moveToRightmost(pCur);  }else{  while( pCur->ix==0 ){  if( pCur->iPage==0 ){  pCur->eState = CURSOR_INVALID;  return SQLITE_DONE;  }  moveToParent(pCur);  }  assert( pCur->info.nSize==0 );  assert( (pCur->curFlags & (BTCF_ValidOvfl))==0 );  pCur->ix--;  pPage = pCur->pPage;  if( pPage->intKey && !pPage->leaf ){  rc = sqlite3BtreePrevious(pCur, 0);  }else{  rc = SQLITE_OK;  }  }  return rc; } SQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor *pCur, int flags){  assert( cursorOwnsBtShared(pCur) );  assert( flags==0 || flags==1 );  UNUSED_PARAMETER( flags );  pCur->curFlags &= ~(BTCF_AtLast|BTCF_ValidOvfl|BTCF_ValidNKey);  pCur->info.nSize = 0;  if( pCur->eState!=CURSOR_VALID   || pCur->ix==0   || pCur->pPage->leaf==0  ){  return btreePrevious(pCur);  }  pCur->ix--;  return SQLITE_OK; } static int allocateBtreePage(  BtShared *pBt,  MemPage **ppPage,  Pgno *pPgno,  Pgno nearby,  u8 eMode ){  MemPage *pPage1;  int rc;  u32 n;  u32 k;  MemPage *pTrunk = 0;  MemPage *pPrevTrunk = 0;  Pgno mxPage;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( eMode==BTALLOC_ANY || (nearby>0 && IfNotOmitAV(pBt->autoVacuum)) );  pPage1 = pBt->pPage1;  mxPage = btreePagecount(pBt);  n = get4byte(&pPage1->aData[36]);  testcase( n==mxPage-1 );  if( n>=mxPage ){  return SQLITE_CORRUPT_BKPT;  }  if( n>0 ){  Pgno iTrunk;  u8 searchList = 0;  u32 nSearch = 0;
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( eMode==BTALLOC_EXACT ){  if( nearby<=mxPage ){  u8 eType;  assert( nearby>0 );  assert( pBt->autoVacuum );  rc = ptrmapGet(pBt, nearby, &eType, 0);  if( rc ) return rc;  if( eType==PTRMAP_FREEPAGE ){  searchList = 1;  }  }  }else if( eMode==BTALLOC_LE ){  searchList = 1;  }
#endif
 rc = sqlite3PagerWrite(pPage1->pDbPage);  if( rc ) return rc;  put4byte(&pPage1->aData[36], n-1);  do {  pPrevTrunk = pTrunk;  if( pPrevTrunk ){  iTrunk = get4byte(&pPrevTrunk->aData[0]);  }else{  iTrunk = get4byte(&pPage1->aData[32]);  }  testcase( iTrunk==mxPage );  if( iTrunk>mxPage || nSearch++ > n ){  rc = SQLITE_CORRUPT_PGNO(pPrevTrunk ? pPrevTrunk->pgno : 1);  }else{  rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);  }  if( rc ){  pTrunk = 0;  goto end_allocate_page;  }  assert( pTrunk!=0 );  assert( pTrunk->aData!=0 );  k = get4byte(&pTrunk->aData[4]);  if( k==0 && !searchList ){  assert( pPrevTrunk==0 );  rc = sqlite3PagerWrite(pTrunk->pDbPage);  if( rc ){  goto end_allocate_page;  }  *pPgno = iTrunk;  memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);  *ppPage = pTrunk;  pTrunk = 0;  TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n-1));  }else if( k>(u32)(pBt->usableSize/4 - 2) ){  rc = SQLITE_CORRUPT_PGNO(iTrunk);  goto end_allocate_page;
#ifndef SQLITE_OMIT_AUTOVACUUM
 }else if( searchList  && (nearby==iTrunk || (iTrunk<nearby && eMode==BTALLOC_LE))  ){  *pPgno = iTrunk;  *ppPage = pTrunk;  searchList = 0;  rc = sqlite3PagerWrite(pTrunk->pDbPage);  if( rc ){  goto end_allocate_page;  }  if( k==0 ){  if( !pPrevTrunk ){  memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);  }else{  rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);  if( rc!=SQLITE_OK ){  goto end_allocate_page;  }  memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);  }  }else{  MemPage *pNewTrunk;  Pgno iNewTrunk = get4byte(&pTrunk->aData[8]);  if( iNewTrunk>mxPage ){  rc = SQLITE_CORRUPT_PGNO(iTrunk);  goto end_allocate_page;  }  testcase( iNewTrunk==mxPage );  rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);  if( rc!=SQLITE_OK ){  goto end_allocate_page;  }  rc = sqlite3PagerWrite(pNewTrunk->pDbPage);  if( rc!=SQLITE_OK ){  releasePage(pNewTrunk);  goto end_allocate_page;  }  memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);  put4byte(&pNewTrunk->aData[4], k-1);  memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);  releasePage(pNewTrunk);  if( !pPrevTrunk ){  assert( sqlite3PagerIswriteable(pPage1->pDbPage) );  put4byte(&pPage1->aData[32], iNewTrunk);  }else{  rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);  if( rc ){  goto end_allocate_page;  }  put4byte(&pPrevTrunk->aData[0], iNewTrunk);  }  }  pTrunk = 0;  TRACE(("ALLOCATE: %d trunk - %d free pages left\n", *pPgno, n-1));
#endif
 }else if( k>0 ){  u32 closest;  Pgno iPage;  unsigned char *aData = pTrunk->aData;  if( nearby>0 ){  u32 i;  closest = 0;  if( eMode==BTALLOC_LE ){  for(i=0; i<k; i++){  iPage = get4byte(&aData[8+i*4]);  if( iPage<=nearby ){  closest = i;  break;  }  }  }else{  int dist;  dist = sqlite3AbsInt32(get4byte(&aData[8]) - nearby);  for(i=1; i<k; i++){  int d2 = sqlite3AbsInt32(get4byte(&aData[8+i*4]) - nearby);  if( d2<dist ){  closest = i;  dist = d2;  }  }  }  }else{  closest = 0;  }  iPage = get4byte(&aData[8+closest*4]);  testcase( iPage==mxPage );  if( iPage>mxPage || iPage<2 ){  rc = SQLITE_CORRUPT_PGNO(iTrunk);  goto end_allocate_page;  }  testcase( iPage==mxPage );  if( !searchList   || (iPage==nearby || (iPage<nearby && eMode==BTALLOC_LE))  ){  int noContent;  *pPgno = iPage;  TRACE(("ALLOCATE: %d was leaf %d of %d on trunk %d"   ": %d more free pages\n",   *pPgno, closest+1, k, pTrunk->pgno, n-1));  rc = sqlite3PagerWrite(pTrunk->pDbPage);  if( rc ) goto end_allocate_page;  if( closest<k-1 ){  memcpy(&aData[8+closest*4], &aData[4+k*4], 4);  }  put4byte(&aData[4], k-1);  noContent = !btreeGetHasContent(pBt, *pPgno)? PAGER_GET_NOCONTENT : 0;  rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);  if( rc==SQLITE_OK ){  rc = sqlite3PagerWrite((*ppPage)->pDbPage);  if( rc!=SQLITE_OK ){  releasePage(*ppPage);  *ppPage = 0;  }  }  searchList = 0;  }  }  releasePage(pPrevTrunk);  pPrevTrunk = 0;  }while( searchList );  }else{  int bNoContent = (0==IfNotOmitAV(pBt->bDoTruncate))? PAGER_GET_NOCONTENT:0;  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);  if( rc ) return rc;  pBt->nPage++;  if( pBt->nPage==PENDING_BYTE_PAGE(pBt) ) pBt->nPage++;
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum && PTRMAP_ISPAGE(pBt, pBt->nPage) ){  MemPage *pPg = 0;  TRACE(("ALLOCATE: %d from end of file (pointer-map page)\n", pBt->nPage));  assert( pBt->nPage!=PENDING_BYTE_PAGE(pBt) );  rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);  if( rc==SQLITE_OK ){  rc = sqlite3PagerWrite(pPg->pDbPage);  releasePage(pPg);  }  if( rc ) return rc;  pBt->nPage++;  if( pBt->nPage==PENDING_BYTE_PAGE(pBt) ){ pBt->nPage++; }  }
#endif
 put4byte(28 + (u8*)pBt->pPage1->aData, pBt->nPage);  *pPgno = pBt->nPage;  assert( *pPgno!=PENDING_BYTE_PAGE(pBt) );  rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);  if( rc ) return rc;  rc = sqlite3PagerWrite((*ppPage)->pDbPage);  if( rc!=SQLITE_OK ){  releasePage(*ppPage);  *ppPage = 0;  }  TRACE(("ALLOCATE: %d from end of file\n", *pPgno));  }  assert( CORRUPT_DB || *pPgno!=PENDING_BYTE_PAGE(pBt) ); end_allocate_page:  releasePage(pTrunk);  releasePage(pPrevTrunk);  assert( rc!=SQLITE_OK || sqlite3PagerPageRefcount((*ppPage)->pDbPage)<=1 );  assert( rc!=SQLITE_OK || (*ppPage)->isInit==0 );  return rc; } static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){  MemPage *pTrunk = 0;  Pgno iTrunk = 0;  MemPage *pPage1 = pBt->pPage1;  MemPage *pPage;  int rc;  u32 nFree;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( CORRUPT_DB || iPage>1 );  assert( !pMemPage || pMemPage->pgno==iPage );  if( NEVER(iPage<2) || iPage>pBt->nPage ){  return SQLITE_CORRUPT_BKPT;  }  if( pMemPage ){  pPage = pMemPage;  sqlite3PagerRef(pPage->pDbPage);  }else{  pPage = btreePageLookup(pBt, iPage);  }  rc = sqlite3PagerWrite(pPage1->pDbPage);  if( rc ) goto freepage_out;  nFree = get4byte(&pPage1->aData[36]);  put4byte(&pPage1->aData[36], nFree+1);  if( pBt->btsFlags & BTS_SECURE_DELETE ){  if( (!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0) )   || ((rc = sqlite3PagerWrite(pPage->pDbPage))!=0)  ){  goto freepage_out;  }  memset(pPage->aData, 0, pPage->pBt->pageSize);  }  if( ISAUTOVACUUM ){  ptrmapPut(pBt, iPage, PTRMAP_FREEPAGE, 0, &rc);  if( rc ) goto freepage_out;  }  if( nFree!=0 ){  u32 nLeaf;  iTrunk = get4byte(&pPage1->aData[32]);  if( iTrunk>btreePagecount(pBt) ){  rc = SQLITE_CORRUPT_BKPT;  goto freepage_out;  }  rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);  if( rc!=SQLITE_OK ){  goto freepage_out;  }  nLeaf = get4byte(&pTrunk->aData[4]);  assert( pBt->usableSize>32 );  if( nLeaf > (u32)pBt->usableSize/4 - 2 ){  rc = SQLITE_CORRUPT_BKPT;  goto freepage_out;  }  if( nLeaf < (u32)pBt->usableSize/4 - 8 ){  rc = sqlite3PagerWrite(pTrunk->pDbPage);  if( rc==SQLITE_OK ){  put4byte(&pTrunk->aData[4], nLeaf+1);  put4byte(&pTrunk->aData[8+nLeaf*4], iPage);  if( pPage && (pBt->btsFlags & BTS_SECURE_DELETE)==0 ){  sqlite3PagerDontWrite(pPage->pDbPage);  }  rc = btreeSetHasContent(pBt, iPage);  }  TRACE(("FREE-PAGE: %d leaf on trunk page %d\n",pPage->pgno,pTrunk->pgno));  goto freepage_out;  }  }  if( pPage==0 && SQLITE_OK!=(rc = btreeGetPage(pBt, iPage, &pPage, 0)) ){  goto freepage_out;  }  rc = sqlite3PagerWrite(pPage->pDbPage);  if( rc!=SQLITE_OK ){  goto freepage_out;  }  put4byte(pPage->aData, iTrunk);  put4byte(&pPage->aData[4], 0);  put4byte(&pPage1->aData[32], iPage);  TRACE(("FREE-PAGE: %d new trunk page replacing %d\n", pPage->pgno, iTrunk)); freepage_out:  if( pPage ){  pPage->isInit = 0;  }  releasePage(pPage);  releasePage(pTrunk);  return rc; } static void freePage(MemPage *pPage, int *pRC){  if( (*pRC)==SQLITE_OK ){  *pRC = freePage2(pPage->pBt, pPage, pPage->pgno);  } } static SQLITE_NOINLINE int clearCellOverflow(  MemPage *pPage,  unsigned char *pCell,  CellInfo *pInfo ){  BtShared *pBt;  Pgno ovflPgno;  int rc;  int nOvfl;  u32 ovflPageSize;  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pInfo->nLocal!=pInfo->nPayload );  testcase( pCell + pInfo->nSize == pPage->aDataEnd );  testcase( pCell + (pInfo->nSize-1) == pPage->aDataEnd );  if( pCell + pInfo->nSize > pPage->aDataEnd ){  return SQLITE_CORRUPT_PAGE(pPage);  }  ovflPgno = get4byte(pCell + pInfo->nSize - 4);  pBt = pPage->pBt;  assert( pBt->usableSize > 4 );  ovflPageSize = pBt->usableSize - 4;  nOvfl = (pInfo->nPayload - pInfo->nLocal + ovflPageSize - 1)/ovflPageSize;  assert( nOvfl>0 ||  (CORRUPT_DB && (pInfo->nPayload + ovflPageSize)<ovflPageSize)  );  while( nOvfl-- ){  Pgno iNext = 0;  MemPage *pOvfl = 0;  if( ovflPgno<2 || ovflPgno>btreePagecount(pBt) ){  return SQLITE_CORRUPT_BKPT;  }  if( nOvfl ){  rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);  if( rc ) return rc;  }  if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno))!=0) )   && sqlite3PagerPageRefcount(pOvfl->pDbPage)!=1  ){  rc = SQLITE_CORRUPT_BKPT;  }else{  rc = freePage2(pBt, pOvfl, ovflPgno);  }  if( pOvfl ){  sqlite3PagerUnref(pOvfl->pDbPage);  }  if( rc ) return rc;  ovflPgno = iNext;  }  return SQLITE_OK; }
#define BTREE_CLEAR_CELL(rc, pPage, pCell, sInfo)   pPage->xParseCell(pPage, pCell, &sInfo);  if( sInfo.nLocal!=sInfo.nPayload ){   rc = clearCellOverflow(pPage, pCell, &sInfo);   }else{  rc = SQLITE_OK;   }

static int fillInCell(  MemPage *pPage,  unsigned char *pCell,  const BtreePayload *pX,  int *pnSize ){  int nPayload;  const u8 *pSrc;  int nSrc, n, rc, mn;  int spaceLeft;  MemPage *pToRelease;  unsigned char *pPrior;  unsigned char *pPayload;  BtShared *pBt;  Pgno pgnoOvfl;  int nHeader;  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pCell<pPage->aData || pCell>=&pPage->aData[pPage->pBt->pageSize]  || sqlite3PagerIswriteable(pPage->pDbPage) );  nHeader = pPage->childPtrSize;  if( pPage->intKey ){  nPayload = pX->nData + pX->nZero;  pSrc = pX->pData;  nSrc = pX->nData;  assert( pPage->intKeyLeaf );  nHeader += putVarint32(&pCell[nHeader], nPayload);  nHeader += putVarint(&pCell[nHeader], *(u64*)&pX->nKey);  }else{  assert( pX->nKey<=0x7fffffff && pX->pKey!=0 );  nSrc = nPayload = (int)pX->nKey;  pSrc = pX->pKey;  nHeader += putVarint32(&pCell[nHeader], nPayload);  }  pPayload = &pCell[nHeader];  if( nPayload<=pPage->maxLocal ){  n = nHeader + nPayload;  testcase( n==3 );  testcase( n==4 );  if( n<4 ) n = 4;  *pnSize = n;  assert( nSrc<=nPayload );  testcase( nSrc<nPayload );  memcpy(pPayload, pSrc, nSrc);  memset(pPayload+nSrc, 0, nPayload-nSrc);  return SQLITE_OK;  }  mn = pPage->minLocal;  n = mn + (nPayload - mn) % (pPage->pBt->usableSize - 4);  testcase( n==pPage->maxLocal );  testcase( n==pPage->maxLocal+1 );  if( n > pPage->maxLocal ) n = mn;  spaceLeft = n;  *pnSize = n + nHeader + 4;  pPrior = &pCell[nHeader+n];  pToRelease = 0;  pgnoOvfl = 0;  pBt = pPage->pBt;
#ifdef SQLITE_DEBUG
 {  CellInfo info;  pPage->xParseCell(pPage, pCell, &info);  assert( nHeader==(int)(info.pPayload - pCell) );  assert( info.nKey==pX->nKey );  assert( *pnSize == info.nSize );  assert( spaceLeft == info.nLocal );  }
#endif
 while( 1 ){  n = nPayload;  if( n>spaceLeft ) n = spaceLeft;  assert( pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) );  assert( pPayload<pPage->aData || pPayload>=&pPage->aData[pBt->pageSize]  || sqlite3PagerIswriteable(pPage->pDbPage) );  if( nSrc>=n ){  memcpy(pPayload, pSrc, n);  }else if( nSrc>0 ){  n = nSrc;  memcpy(pPayload, pSrc, n);  }else{  memset(pPayload, 0, n);  }  nPayload -= n;  if( nPayload<=0 ) break;  pPayload += n;  pSrc += n;  nSrc -= n;  spaceLeft -= n;  if( spaceLeft==0 ){  MemPage *pOvfl = 0;
#ifndef SQLITE_OMIT_AUTOVACUUM
 Pgno pgnoPtrmap = pgnoOvfl;  if( pBt->autoVacuum ){  do{  pgnoOvfl++;  } while(  PTRMAP_ISPAGE(pBt, pgnoOvfl) || pgnoOvfl==PENDING_BYTE_PAGE(pBt)  );  }
#endif
 rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum && rc==SQLITE_OK ){  u8 eType = (pgnoPtrmap?PTRMAP_OVERFLOW2:PTRMAP_OVERFLOW1);  ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc);  if( rc ){  releasePage(pOvfl);  }  }
#endif
 if( rc ){  releasePage(pToRelease);  return rc;  }  assert( pToRelease==0 || sqlite3PagerIswriteable(pToRelease->pDbPage) );  assert( pPrior<pPage->aData || pPrior>=&pPage->aData[pBt->pageSize]  || sqlite3PagerIswriteable(pPage->pDbPage) );  put4byte(pPrior, pgnoOvfl);  releasePage(pToRelease);  pToRelease = pOvfl;  pPrior = pOvfl->aData;  put4byte(pPrior, 0);  pPayload = &pOvfl->aData[4];  spaceLeft = pBt->usableSize - 4;  }  }  releasePage(pToRelease);  return SQLITE_OK; } static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){  u32 pc;  u8 *data;  u8 *ptr;  int rc;  int hdr;  if( *pRC ) return;  assert( idx>=0 );  assert( idx<pPage->nCell );  assert( CORRUPT_DB || sz==cellSize(pPage, idx) );  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( pPage->nFree>=0 );  data = pPage->aData;  ptr = &pPage->aCellIdx[2*idx];  assert( pPage->pBt->usableSize > (int)(ptr-data) );  pc = get2byte(ptr);  hdr = pPage->hdrOffset;  testcase( pc==(u32)get2byte(&data[hdr+5]) );  testcase( pc+sz==pPage->pBt->usableSize );  if( pc+sz > pPage->pBt->usableSize ){  *pRC = SQLITE_CORRUPT_BKPT;  return;  }  rc = freeSpace(pPage, pc, sz);  if( rc ){  *pRC = rc;  return;  }  pPage->nCell--;  if( pPage->nCell==0 ){  memset(&data[hdr+1], 0, 4);  data[hdr+7] = 0;  put2byte(&data[hdr+5], pPage->pBt->usableSize);  pPage->nFree = pPage->pBt->usableSize - pPage->hdrOffset   - pPage->childPtrSize - 8;  }else{  memmove(ptr, ptr+2, 2*(pPage->nCell - idx));  put2byte(&data[hdr+3], pPage->nCell);  pPage->nFree += 2;  } } static void insertCell(  MemPage *pPage,  int i,  u8 *pCell,  int sz,  u8 *pTemp,  Pgno iChild,  int *pRC ){  int idx = 0;  int j;  u8 *data;  u8 *pIns;  assert( *pRC==SQLITE_OK );  assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );  assert( MX_CELL(pPage->pBt)<=10921 );  assert( pPage->nCell<=MX_CELL(pPage->pBt) || CORRUPT_DB );  assert( pPage->nOverflow<=ArraySize(pPage->apOvfl) );  assert( ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) );  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( sz==pPage->xCellSize(pPage, pCell) || CORRUPT_DB );  assert( pPage->nFree>=0 );  if( pPage->nOverflow || sz+2>pPage->nFree ){  if( pTemp ){  memcpy(pTemp, pCell, sz);  pCell = pTemp;  }  if( iChild ){  put4byte(pCell, iChild);  }  j = pPage->nOverflow++;  assert( j < ArraySize(pPage->apOvfl)-1 );  pPage->apOvfl[j] = pCell;  pPage->aiOvfl[j] = (u16)i;  assert( j==0 || pPage->aiOvfl[j-1]<(u16)i );  assert( j==0 || i==pPage->aiOvfl[j-1]+1 );  }else{  int rc = sqlite3PagerWrite(pPage->pDbPage);  if( rc!=SQLITE_OK ){  *pRC = rc;  return;  }  assert( sqlite3PagerIswriteable(pPage->pDbPage) );  data = pPage->aData;  assert( &data[pPage->cellOffset]==pPage->aCellIdx );  rc = allocateSpace(pPage, sz, &idx);  if( rc ){ *pRC = rc; return; }  assert( idx >= 0 );  assert( idx >= pPage->cellOffset+2*pPage->nCell+2 || CORRUPT_DB );  assert( idx+sz <= (int)pPage->pBt->usableSize );  pPage->nFree -= (u16)(2 + sz);  if( iChild ){  memcpy(&data[idx+4], pCell+4, sz-4);  put4byte(&data[idx], iChild);  }else{  memcpy(&data[idx], pCell, sz);  }  pIns = pPage->aCellIdx + i*2;  memmove(pIns+2, pIns, 2*(pPage->nCell - i));  put2byte(pIns, idx);  pPage->nCell++;  if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;  assert( get2byte(&data[pPage->hdrOffset+3])==pPage->nCell || CORRUPT_DB );
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pPage->pBt->autoVacuum ){  ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);  }
#endif
 } }
#define NN 1
#define NB 3
typedef struct CellArray CellArray; struct CellArray {  int nCell;  MemPage *pRef;  u8 **apCell;  u16 *szCell;  u8 *apEnd[NB*2];  int ixNx[NB*2]; }; static void populateCellCache(CellArray *p, int idx, int N){  assert( idx>=0 && idx+N<=p->nCell );  while( N>0 ){  assert( p->apCell[idx]!=0 );  if( p->szCell[idx]==0 ){  p->szCell[idx] = p->pRef->xCellSize(p->pRef, p->apCell[idx]);  }else{  assert( CORRUPT_DB ||  p->szCell[idx]==p->pRef->xCellSize(p->pRef, p->apCell[idx]) );  }  idx++;  N--;  } } static SQLITE_NOINLINE u16 computeCellSize(CellArray *p, int N){  assert( N>=0 && N<p->nCell );  assert( p->szCell[N]==0 );  p->szCell[N] = p->pRef->xCellSize(p->pRef, p->apCell[N]);  return p->szCell[N]; } static u16 cachedCellSize(CellArray *p, int N){  assert( N>=0 && N<p->nCell );  if( p->szCell[N] ) return p->szCell[N];  return computeCellSize(p, N); } static int rebuildPage(  CellArray *pCArray,  int iFirst,  int nCell,  MemPage *pPg ){  const int hdr = pPg->hdrOffset;  u8 * const aData = pPg->aData;  const int usableSize = pPg->pBt->usableSize;  u8 * const pEnd = &aData[usableSize];  int i = iFirst;  u32 j;  int iEnd = i+nCell;  u8 *pCellptr = pPg->aCellIdx;  u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);  u8 *pData;  int k;  u8 *pSrcEnd;  assert( i<iEnd );  j = get2byte(&aData[hdr+5]);  if( j>(u32)usableSize ){ j = 0; }  memcpy(&pTmp[j], &aData[j], usableSize - j);  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}  pSrcEnd = pCArray->apEnd[k];  pData = pEnd;  while( 1 ){  u8 *pCell = pCArray->apCell[i];  u16 sz = pCArray->szCell[i];  assert( sz>0 );  if( SQLITE_WITHIN(pCell,aData+j,pEnd) ){  if( ((uptr)(pCell+sz))>(uptr)pEnd ) return SQLITE_CORRUPT_BKPT;  pCell = &pTmp[pCell - aData];  }else if( (uptr)(pCell+sz)>(uptr)pSrcEnd   && (uptr)(pCell)<(uptr)pSrcEnd  ){  return SQLITE_CORRUPT_BKPT;  }  pData -= sz;  put2byte(pCellptr, (pData - aData));  pCellptr += 2;  if( pData < pCellptr ) return SQLITE_CORRUPT_BKPT;  memmove(pData, pCell, sz);  assert( sz==pPg->xCellSize(pPg, pCell) || CORRUPT_DB );  i++;  if( i>=iEnd ) break;  if( pCArray->ixNx[k]<=i ){  k++;  pSrcEnd = pCArray->apEnd[k];  }  }  pPg->nCell = nCell;  pPg->nOverflow = 0;  put2byte(&aData[hdr+1], 0);  put2byte(&aData[hdr+3], pPg->nCell);  put2byte(&aData[hdr+5], pData - aData);  aData[hdr+7] = 0x00;  return SQLITE_OK; } static int pageInsertArray(  MemPage *pPg,  u8 *pBegin,  u8 **ppData,  u8 *pCellptr,  int iFirst,  int nCell,  CellArray *pCArray ){  int i = iFirst;  u8 *aData = pPg->aData;  u8 *pData = *ppData;  int iEnd = iFirst + nCell;  int k;  u8 *pEnd;  assert( CORRUPT_DB || pPg->hdrOffset==0 );  if( iEnd<=iFirst ) return 0;  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}  pEnd = pCArray->apEnd[k];  while( 1 ){  int sz, rc;  u8 *pSlot;  assert( pCArray->szCell[i]!=0 );  sz = pCArray->szCell[i];  if( (aData[1]==0 && aData[2]==0) || (pSlot = pageFindSlot(pPg,sz,&rc))==0 ){  if( (pData - pBegin)<sz ) return 1;  pData -= sz;  pSlot = pData;  }  assert( (pSlot+sz)<=pCArray->apCell[i]   || pSlot>=(pCArray->apCell[i]+sz)   || CORRUPT_DB );  if( (uptr)(pCArray->apCell[i]+sz)>(uptr)pEnd   && (uptr)(pCArray->apCell[i])<(uptr)pEnd  ){  assert( CORRUPT_DB );  (void)SQLITE_CORRUPT_BKPT;  return 1;  }  memmove(pSlot, pCArray->apCell[i], sz);  put2byte(pCellptr, (pSlot - aData));  pCellptr += 2;  i++;  if( i>=iEnd ) break;  if( pCArray->ixNx[k]<=i ){  k++;  pEnd = pCArray->apEnd[k];  }  }  *ppData = pData;  return 0; } static int pageFreeArray(  MemPage *pPg,  int iFirst,  int nCell,  CellArray *pCArray ){  u8 * const aData = pPg->aData;  u8 * const pEnd = &aData[pPg->pBt->usableSize];  u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];  int nRet = 0;  int i;  int iEnd = iFirst + nCell;  u8 *pFree = 0;  int szFree = 0;  for(i=iFirst; i<iEnd; i++){  u8 *pCell = pCArray->apCell[i];  if( SQLITE_WITHIN(pCell, pStart, pEnd) ){  int sz;  sz = pCArray->szCell[i]; assert( sz>0 );  if( pFree!=(pCell + sz) ){  if( pFree ){  assert( pFree>aData && (pFree - aData)<65536 );  freeSpace(pPg, (u16)(pFree - aData), szFree);  }  pFree = pCell;  szFree = sz;  if( pFree+sz>pEnd ){  return 0;  }  }else{  pFree = pCell;  szFree += sz;  }  nRet++;  }  }  if( pFree ){  assert( pFree>aData && (pFree - aData)<65536 );  freeSpace(pPg, (u16)(pFree - aData), szFree);  }  return nRet; } static int editPage(  MemPage *pPg,  int iOld,  int iNew,  int nNew,  CellArray *pCArray ){  u8 * const aData = pPg->aData;  const int hdr = pPg->hdrOffset;  u8 *pBegin = &pPg->aCellIdx[nNew * 2];  int nCell = pPg->nCell;  u8 *pData;  u8 *pCellptr;  int i;  int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;  int iNewEnd = iNew + nNew;
#ifdef SQLITE_DEBUG
 u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);  memcpy(pTmp, aData, pPg->pBt->usableSize);
#endif
 assert( nCell>=0 );  if( iOld<iNew ){  int nShift = pageFreeArray(pPg, iOld, iNew-iOld, pCArray);  if( NEVER(nShift>nCell) ) return SQLITE_CORRUPT_BKPT;  memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift*2], nCell*2);  nCell -= nShift;  }  if( iNewEnd < iOldEnd ){  int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);  assert( nCell>=nTail );  nCell -= nTail;  }  pData = &aData[get2byteNotZero(&aData[hdr+5])];  if( pData<pBegin ) goto editpage_fail;  if( pData>pPg->aDataEnd ) goto editpage_fail;  if( iNew<iOld ){  int nAdd = MIN(nNew,iOld-iNew);  assert( (iOld-iNew)<nNew || nCell==0 || CORRUPT_DB );  assert( nAdd>=0 );  pCellptr = pPg->aCellIdx;  memmove(&pCellptr[nAdd*2], pCellptr, nCell*2);  if( pageInsertArray(  pPg, pBegin, &pData, pCellptr,  iNew, nAdd, pCArray  ) ) goto editpage_fail;  nCell += nAdd;  }  for(i=0; i<pPg->nOverflow; i++){  int iCell = (iOld + pPg->aiOvfl[i]) - iNew;  if( iCell>=0 && iCell<nNew ){  pCellptr = &pPg->aCellIdx[iCell * 2];  if( nCell>iCell ){  memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);  }  nCell++;  cachedCellSize(pCArray, iCell+iNew);  if( pageInsertArray(  pPg, pBegin, &pData, pCellptr,  iCell+iNew, 1, pCArray  ) ) goto editpage_fail;  }  }  assert( nCell>=0 );  pCellptr = &pPg->aCellIdx[nCell*2];  if( pageInsertArray(  pPg, pBegin, &pData, pCellptr,  iNew+nCell, nNew-nCell, pCArray  ) ) goto editpage_fail;  pPg->nCell = nNew;  pPg->nOverflow = 0;  put2byte(&aData[hdr+3], pPg->nCell);  put2byte(&aData[hdr+5], pData - aData);
#ifdef SQLITE_DEBUG
 for(i=0; i<nNew && !CORRUPT_DB; i++){  u8 *pCell = pCArray->apCell[i+iNew];  int iOff = get2byteAligned(&pPg->aCellIdx[i*2]);  if( SQLITE_WITHIN(pCell, aData, &aData[pPg->pBt->usableSize]) ){  pCell = &pTmp[pCell - aData];  }  assert( 0==memcmp(pCell, &aData[iOff],  pCArray->pRef->xCellSize(pCArray->pRef, pCArray->apCell[i+iNew])) );  }
#endif
 return SQLITE_OK;  editpage_fail:  populateCellCache(pCArray, iNew, nNew);  return rebuildPage(pCArray, iNew, nNew, pPg); }
#ifndef SQLITE_OMIT_QUICKBALANCE
static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){  BtShared *const pBt = pPage->pBt;  MemPage *pNew;  int rc;  Pgno pgnoNew;  assert( sqlite3_mutex_held(pPage->pBt->mutex) );  assert( sqlite3PagerIswriteable(pParent->pDbPage) );  assert( pPage->nOverflow==1 );  if( pPage->nCell==0 ) return SQLITE_CORRUPT_BKPT;  assert( pPage->nFree>=0 );  assert( pParent->nFree>=0 );  rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);  if( rc==SQLITE_OK ){  u8 *pOut = &pSpace[4];  u8 *pCell = pPage->apOvfl[0];  u16 szCell = pPage->xCellSize(pPage, pCell);  u8 *pStop;  CellArray b;  assert( sqlite3PagerIswriteable(pNew->pDbPage) );  assert( CORRUPT_DB || pPage->aData[0]==(PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF) );  zeroPage(pNew, PTF_INTKEY|PTF_LEAFDATA|PTF_LEAF);  b.nCell = 1;  b.pRef = pPage;  b.apCell = &pCell;  b.szCell = &szCell;  b.apEnd[0] = pPage->aDataEnd;  b.ixNx[0] = 2;  rc = rebuildPage(&b, 0, 1, pNew);  if( NEVER(rc) ){  releasePage(pNew);  return rc;  }  pNew->nFree = pBt->usableSize - pNew->cellOffset - 2 - szCell;  if( ISAUTOVACUUM ){  ptrmapPut(pBt, pgnoNew, PTRMAP_BTREE, pParent->pgno, &rc);  if( szCell>pNew->minLocal ){  ptrmapPutOvflPtr(pNew, pNew, pCell, &rc);  }  }  pCell = findCell(pPage, pPage->nCell-1);  pStop = &pCell[9];  while( (*(pCell++)&0x80) && pCell<pStop );  pStop = &pCell[9];  while( ((*(pOut++) = *(pCell++))&0x80) && pCell<pStop );  if( rc==SQLITE_OK ){  insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),   0, pPage->pgno, &rc);  }  put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew);  releasePage(pNew);  }  return rc; }
#endif
#if 0
static int ptrmapCheckPages(MemPage **apPage, int nPage){  int i, j;  for(i=0; i<nPage; i++){  Pgno n;  u8 e;  MemPage *pPage = apPage[i];  BtShared *pBt = pPage->pBt;  assert( pPage->isInit );  for(j=0; j<pPage->nCell; j++){  CellInfo info;  u8 *z;  z = findCell(pPage, j);  pPage->xParseCell(pPage, z, &info);  if( info.nLocal<info.nPayload ){  Pgno ovfl = get4byte(&z[info.nSize-4]);  ptrmapGet(pBt, ovfl, &e, &n);  assert( n==pPage->pgno && e==PTRMAP_OVERFLOW1 );  }  if( !pPage->leaf ){  Pgno child = get4byte(z);  ptrmapGet(pBt, child, &e, &n);  assert( n==pPage->pgno && e==PTRMAP_BTREE );  }  }  if( !pPage->leaf ){  Pgno child = get4byte(&pPage->aData[pPage->hdrOffset+8]);  ptrmapGet(pBt, child, &e, &n);  assert( n==pPage->pgno && e==PTRMAP_BTREE );  }  }  return 1; }
#endif
static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){  if( (*pRC)==SQLITE_OK ){  BtShared * const pBt = pFrom->pBt;  u8 * const aFrom = pFrom->aData;  u8 * const aTo = pTo->aData;  int const iFromHdr = pFrom->hdrOffset;  int const iToHdr = ((pTo->pgno==1) ? 100 : 0);  int rc;  int iData;  assert( pFrom->isInit );  assert( pFrom->nFree>=iToHdr );  assert( get2byte(&aFrom[iFromHdr+5]) <= (int)pBt->usableSize );  iData = get2byte(&aFrom[iFromHdr+5]);  memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);  memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);  pTo->isInit = 0;  rc = btreeInitPage(pTo);  if( rc==SQLITE_OK ) rc = btreeComputeFreeSpace(pTo);  if( rc!=SQLITE_OK ){  *pRC = rc;  return;  }  if( ISAUTOVACUUM ){  *pRC = setChildPtrmaps(pTo);  }  } } static int balance_nonroot(  MemPage *pParent,  int iParentIdx,  u8 *aOvflSpace,  int isRoot,  int bBulk ){  BtShared *pBt;  int nMaxCells = 0;  int nNew = 0;  int nOld;  int i, j, k;  int nxDiv;  int rc = SQLITE_OK;  u16 leafCorrection;  int leafData;  int usableSpace;  int pageFlags;  int iSpace1 = 0;  int iOvflSpace = 0;  int szScratch;  MemPage *apOld[NB];  MemPage *apNew[NB+2];  u8 *pRight;  u8 *apDiv[NB-1];  int cntNew[NB+2];  int cntOld[NB+2];  int szNew[NB+2];  u8 *aSpace1;  Pgno pgno;  u8 abDone[NB+2];  Pgno aPgno[NB+2];  Pgno aPgOrder[NB+2];  u16 aPgFlags[NB+2];  CellArray b;  memset(abDone, 0, sizeof(abDone));  memset(&b, 0, sizeof(b));  pBt = pParent->pBt;  assert( sqlite3_mutex_held(pBt->mutex) );  assert( sqlite3PagerIswriteable(pParent->pDbPage) );  assert( pParent->nOverflow==0 || pParent->nOverflow==1 );  assert( pParent->nOverflow==0 || pParent->aiOvfl[0]==iParentIdx );  if( !aOvflSpace ){  return SQLITE_NOMEM_BKPT;  }  assert( pParent->nFree>=0 );  i = pParent->nOverflow + pParent->nCell;  if( i<2 ){  nxDiv = 0;  }else{  assert( bBulk==0 || bBulk==1 );  if( iParentIdx==0 ){  nxDiv = 0;  }else if( iParentIdx==i ){  nxDiv = i-2+bBulk;  }else{  nxDiv = iParentIdx-1;  }  i = 2-bBulk;  }  nOld = i+1;  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){  pRight = &pParent->aData[pParent->hdrOffset+8];  }else{  pRight = findCell(pParent, i+nxDiv-pParent->nOverflow);  }  pgno = get4byte(pRight);  while( 1 ){  if( rc==SQLITE_OK ){  rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);  }  if( rc ){  memset(apOld, 0, (i+1)*sizeof(MemPage*));  goto balance_cleanup;  }  if( apOld[i]->nFree<0 ){  rc = btreeComputeFreeSpace(apOld[i]);  if( rc ){  memset(apOld, 0, (i)*sizeof(MemPage*));  goto balance_cleanup;  }  }  nMaxCells += apOld[i]->nCell + ArraySize(pParent->apOvfl);  if( (i--)==0 ) break;  if( pParent->nOverflow && i+nxDiv==pParent->aiOvfl[0] ){  apDiv[i] = pParent->apOvfl[0];  pgno = get4byte(apDiv[i]);  szNew[i] = pParent->xCellSize(pParent, apDiv[i]);  pParent->nOverflow = 0;  }else{  apDiv[i] = findCell(pParent, i+nxDiv-pParent->nOverflow);  pgno = get4byte(apDiv[i]);  szNew[i] = pParent->xCellSize(pParent, apDiv[i]);  if( pBt->btsFlags & BTS_FAST_SECURE ){  int iOff;  iOff = SQLITE_PTR_TO_INT(apDiv[i]) - SQLITE_PTR_TO_INT(pParent->aData);  if( (iOff+szNew[i])<=(int)pBt->usableSize ){  memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);  apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];  }  }  dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);  }  }  nMaxCells = (nMaxCells + 3)&~3;  szScratch =   nMaxCells*sizeof(u8*)   + nMaxCells*sizeof(u16)   + pBt->pageSize;  assert( szScratch<=7*(int)pBt->pageSize );  b.apCell = sqlite3StackAllocRaw(0, szScratch );  if( b.apCell==0 ){  rc = SQLITE_NOMEM_BKPT;  goto balance_cleanup;  }  b.szCell = (u16*)&b.apCell[nMaxCells];  aSpace1 = (u8*)&b.szCell[nMaxCells];  assert( EIGHT_BYTE_ALIGNMENT(aSpace1) );  b.pRef = apOld[0];  leafCorrection = b.pRef->leaf*4;  leafData = b.pRef->intKeyLeaf;  for(i=0; i<nOld; i++){  MemPage *pOld = apOld[i];  int limit = pOld->nCell;  u8 *aData = pOld->aData;  u16 maskPage = pOld->maskPage;  u8 *piCell = aData + pOld->cellOffset;  u8 *piEnd;  VVA_ONLY( int nCellAtStart = b.nCell; )  if( pOld->aData[0]!=apOld[0]->aData[0] ){  rc = SQLITE_CORRUPT_BKPT;  goto balance_cleanup;  }  memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));  if( pOld->nOverflow>0 ){  if( NEVER(limit<pOld->aiOvfl[0]) ){  rc = SQLITE_CORRUPT_BKPT;  goto balance_cleanup;  }  limit = pOld->aiOvfl[0];  for(j=0; j<limit; j++){  b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));  piCell += 2;  b.nCell++;  }  for(k=0; k<pOld->nOverflow; k++){  assert( k==0 || pOld->aiOvfl[k-1]+1==pOld->aiOvfl[k] );  b.apCell[b.nCell] = pOld->apOvfl[k];  b.nCell++;  }  }  piEnd = aData + pOld->cellOffset + 2*pOld->nCell;  while( piCell<piEnd ){  assert( b.nCell<nMaxCells );  b.apCell[b.nCell] = aData + (maskPage & get2byteAligned(piCell));  piCell += 2;  b.nCell++;  }  assert( (b.nCell-nCellAtStart)==(pOld->nCell+pOld->nOverflow) );  cntOld[i] = b.nCell;  if( i<nOld-1 && !leafData){  u16 sz = (u16)szNew[i];  u8 *pTemp;  assert( b.nCell<nMaxCells );  b.szCell[b.nCell] = sz;  pTemp = &aSpace1[iSpace1];  iSpace1 += sz;  assert( sz<=pBt->maxLocal+23 );  assert( iSpace1 <= (int)pBt->pageSize );  memcpy(pTemp, apDiv[i], sz);  b.apCell[b.nCell] = pTemp+leafCorrection;  assert( leafCorrection==0 || leafCorrection==4 );  b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;  if( !pOld->leaf ){  assert( leafCorrection==0 );  assert( pOld->hdrOffset==0 || CORRUPT_DB );  memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);  }else{  assert( leafCorrection==4 );  while( b.szCell[b.nCell]<4 ){  assert( b.szCell[b.nCell]==3 || CORRUPT_DB );  assert( b.apCell[b.nCell]==&aSpace1[iSpace1-3] || CORRUPT_DB );  aSpace1[iSpace1++] = 0x00;  b.szCell[b.nCell]++;  }  }  b.nCell++;  }  }  usableSpace = pBt->usableSize - 12 + leafCorrection;  for(i=k=0; i<nOld; i++, k++){  MemPage *p = apOld[i];  b.apEnd[k] = p->aDataEnd;  b.ixNx[k] = cntOld[i];  if( k && b.ixNx[k]==b.ixNx[k-1] ){  k--;  }  if( !leafData ){  k++;  b.apEnd[k] = pParent->aDataEnd;  b.ixNx[k] = cntOld[i]+1;  }  assert( p->nFree>=0 );  szNew[i] = usableSpace - p->nFree;  for(j=0; j<p->nOverflow; j++){  szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);  }  cntNew[i] = cntOld[i];  }  k = nOld;  for(i=0; i<k; i++){  int sz;  while( szNew[i]>usableSpace ){  if( i+1>=k ){  k = i+2;  if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }  szNew[k-1] = 0;  cntNew[k-1] = b.nCell;  }  sz = 2 + cachedCellSize(&b, cntNew[i]-1);  szNew[i] -= sz;  if( !leafData ){  if( cntNew[i]<b.nCell ){  sz = 2 + cachedCellSize(&b, cntNew[i]);  }else{  sz = 0;  }  }  szNew[i+1] += sz;  cntNew[i]--;  }  while( cntNew[i]<b.nCell ){  sz = 2 + cachedCellSize(&b, cntNew[i]);  if( szNew[i]+sz>usableSpace ) break;  szNew[i] += sz;  cntNew[i]++;  if( !leafData ){  if( cntNew[i]<b.nCell ){  sz = 2 + cachedCellSize(&b, cntNew[i]);  }else{  sz = 0;  }  }  szNew[i+1] -= sz;  }  if( cntNew[i]>=b.nCell ){  k = i+1;  }else if( cntNew[i] <= (i>0 ? cntNew[i-1] : 0) ){  rc = SQLITE_CORRUPT_BKPT;  goto balance_cleanup;  }  }  for(i=k-1; i>0; i--){  int szRight = szNew[i];  int szLeft = szNew[i-1];  int r;  int d;  r = cntNew[i-1] - 1;  d = r + 1 - leafData;  (void)cachedCellSize(&b, d);  do{  assert( d<nMaxCells );  assert( r<nMaxCells );  (void)cachedCellSize(&b, r);  if( szRight!=0   && (bBulk || szRight+b.szCell[d]+2 > szLeft-(b.szCell[r]+(i==k-1?0:2)))){  break;  }  szRight += b.szCell[d] + 2;  szLeft -= b.szCell[r] + 2;  cntNew[i-1] = r;  r--;  d--;  }while( r>=0 );  szNew[i] = szRight;  szNew[i-1] = szLeft;  if( cntNew[i-1] <= (i>1 ? cntNew[i-2] : 0) ){  rc = SQLITE_CORRUPT_BKPT;  goto balance_cleanup;  }  }  assert( cntNew[0]>0 || (pParent->pgno==1 && pParent->nCell==0) || CORRUPT_DB);  TRACE(("BALANCE: old: %d(nc=%d) %d(nc=%d) %d(nc=%d)\n",  apOld[0]->pgno, apOld[0]->nCell,  nOld>=2 ? apOld[1]->pgno : 0, nOld>=2 ? apOld[1]->nCell : 0,  nOld>=3 ? apOld[2]->pgno : 0, nOld>=3 ? apOld[2]->nCell : 0  ));  pageFlags = apOld[0]->aData[0];  for(i=0; i<k; i++){  MemPage *pNew;  if( i<nOld ){  pNew = apNew[i] = apOld[i];  apOld[i] = 0;  rc = sqlite3PagerWrite(pNew->pDbPage);  nNew++;  if( sqlite3PagerPageRefcount(pNew->pDbPage)!=1+(i==(iParentIdx-nxDiv))   && rc==SQLITE_OK  ){  rc = SQLITE_CORRUPT_BKPT;  }  if( rc ) goto balance_cleanup;  }else{  assert( i>0 );  rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);  if( rc ) goto balance_cleanup;  zeroPage(pNew, pageFlags);  apNew[i] = pNew;  nNew++;  cntOld[i] = b.nCell;  if( ISAUTOVACUUM ){  ptrmapPut(pBt, pNew->pgno, PTRMAP_BTREE, pParent->pgno, &rc);  if( rc!=SQLITE_OK ){  goto balance_cleanup;  }  }  }  }  for(i=0; i<nNew; i++){  aPgOrder[i] = aPgno[i] = apNew[i]->pgno;  aPgFlags[i] = apNew[i]->pDbPage->flags;  for(j=0; j<i; j++){  if( NEVER(aPgno[j]==aPgno[i]) ){  assert( CORRUPT_DB );  rc = SQLITE_CORRUPT_BKPT;  goto balance_cleanup;  }  }  }  for(i=0; i<nNew; i++){  int iBest = 0;  for(j=1; j<nNew; j++){  if( aPgOrder[j]<aPgOrder[iBest] ) iBest = j;  }  pgno = aPgOrder[iBest];  aPgOrder[iBest] = 0xffffffff;  if( iBest!=i ){  if( iBest>i ){  sqlite3PagerRekey(apNew[iBest]->pDbPage, pBt->nPage+iBest+1, 0);  }  sqlite3PagerRekey(apNew[i]->pDbPage, pgno, aPgFlags[iBest]);  apNew[i]->pgno = pgno;  }  }  TRACE(("BALANCE: new: %d(%d nc=%d) %d(%d nc=%d) %d(%d nc=%d) "   "%d(%d nc=%d) %d(%d nc=%d)\n",  apNew[0]->pgno, szNew[0], cntNew[0],  nNew>=2 ? apNew[1]->pgno : 0, nNew>=2 ? szNew[1] : 0,  nNew>=2 ? cntNew[1] - cntNew[0] - !leafData : 0,  nNew>=3 ? apNew[2]->pgno : 0, nNew>=3 ? szNew[2] : 0,  nNew>=3 ? cntNew[2] - cntNew[1] - !leafData : 0,  nNew>=4 ? apNew[3]->pgno : 0, nNew>=4 ? szNew[3] : 0,  nNew>=4 ? cntNew[3] - cntNew[2] - !leafData : 0,  nNew>=5 ? apNew[4]->pgno : 0, nNew>=5 ? szNew[4] : 0,  nNew>=5 ? cntNew[4] - cntNew[3] - !leafData : 0  ));  assert( sqlite3PagerIswriteable(pParent->pDbPage) );  assert( nNew>=1 && nNew<=ArraySize(apNew) );  assert( apNew[nNew-1]!=0 );  put4byte(pRight, apNew[nNew-1]->pgno);  if( (pageFlags & PTF_LEAF)==0 && nOld!=nNew ){  MemPage *pOld = (nNew>nOld ? apNew : apOld)[nOld-1];  memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);  }  if( ISAUTOVACUUM ){  MemPage *pOld;  MemPage *pNew = pOld = apNew[0];  int cntOldNext = pNew->nCell + pNew->nOverflow;  int iNew = 0;  int iOld = 0;  for(i=0; i<b.nCell; i++){  u8 *pCell = b.apCell[i];  while( i==cntOldNext ){  iOld++;  assert( iOld<nNew || iOld<nOld );  assert( iOld>=0 && iOld<NB );  pOld = iOld<nNew ? apNew[iOld] : apOld[iOld];  cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;  }  if( i==cntNew[iNew] ){  pNew = apNew[++iNew];  if( !leafData ) continue;  }  if( iOld>=nNew   || pNew->pgno!=aPgno[iOld]   || !SQLITE_WITHIN(pCell,pOld->aData,pOld->aDataEnd)  ){  if( !leafCorrection ){  ptrmapPut(pBt, get4byte(pCell), PTRMAP_BTREE, pNew->pgno, &rc);  }  if( cachedCellSize(&b,i)>pNew->minLocal ){  ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);  }  if( rc ) goto balance_cleanup;  }  }  }  for(i=0; i<nNew-1; i++){  u8 *pCell;  u8 *pTemp;  int sz;  u8 *pSrcEnd;  MemPage *pNew = apNew[i];  j = cntNew[i];  assert( j<nMaxCells );  assert( b.apCell[j]!=0 );  pCell = b.apCell[j];  sz = b.szCell[j] + leafCorrection;  pTemp = &aOvflSpace[iOvflSpace];  if( !pNew->leaf ){  memcpy(&pNew->aData[8], pCell, 4);  }else if( leafData ){  CellInfo info;  j--;  pNew->xParseCell(pNew, b.apCell[j], &info);  pCell = pTemp;  sz = 4 + putVarint(&pCell[4], info.nKey);  pTemp = 0;  }else{  pCell -= 4;  if( b.szCell[j]==4 ){  assert(leafCorrection==4);  sz = pParent->xCellSize(pParent, pCell);  }  }  iOvflSpace += sz;  assert( sz<=pBt->maxLocal+23 );  assert( iOvflSpace <= (int)pBt->pageSize );  for(k=0; b.ixNx[k]<=i && ALWAYS(k<NB*2); k++){}  pSrcEnd = b.apEnd[k];  if( SQLITE_WITHIN(pSrcEnd, pCell, pCell+sz) ){  rc = SQLITE_CORRUPT_BKPT;  goto balance_cleanup;  }  insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno, &rc);  if( rc!=SQLITE_OK ) goto balance_cleanup;  assert( sqlite3PagerIswriteable(pParent->pDbPage) );  }  for(i=1-nNew; i<nNew; i++){  int iPg = i<0 ? -i : i;  assert( iPg>=0 && iPg<nNew );  if( abDone[iPg] ) continue;  if( i>=0   || cntOld[iPg-1]>=cntNew[iPg-1]  ){  int iNew;  int iOld;  int nNewCell;  assert( iPg==0 || cntOld[iPg-1]>=cntNew[iPg-1] || abDone[iPg-1] );  assert( cntNew[iPg]>=cntOld[iPg] || abDone[iPg+1] );  if( iPg==0 ){  iNew = iOld = 0;  nNewCell = cntNew[0];  }else{  iOld = iPg<nOld ? (cntOld[iPg-1] + !leafData) : b.nCell;  iNew = cntNew[iPg-1] + !leafData;  nNewCell = cntNew[iPg] - iNew;  }  rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);  if( rc ) goto balance_cleanup;  abDone[iPg]++;  apNew[iPg]->nFree = usableSpace-szNew[iPg];  assert( apNew[iPg]->nOverflow==0 );  assert( apNew[iPg]->nCell==nNewCell );  }  }  assert( memcmp(abDone, "\01\01\01\01\01", nNew)==0 );  assert( nOld>0 );  assert( nNew>0 );  if( isRoot && pParent->nCell==0 && pParent->hdrOffset<=apNew[0]->nFree ){  assert( nNew==1 || CORRUPT_DB );  rc = defragmentPage(apNew[0], -1);  testcase( rc!=SQLITE_OK );  assert( apNew[0]->nFree ==  (get2byteNotZero(&apNew[0]->aData[5]) - apNew[0]->cellOffset  - apNew[0]->nCell*2)  || rc!=SQLITE_OK  );  copyNodeContent(apNew[0], pParent, &rc);  freePage(apNew[0], &rc);  }else if( ISAUTOVACUUM && !leafCorrection ){  for(i=0; i<nNew; i++){  u32 key = get4byte(&apNew[i]->aData[8]);  ptrmapPut(pBt, key, PTRMAP_BTREE, apNew[i]->pgno, &rc);  }  }  assert( pParent->isInit );  TRACE(("BALANCE: finished: old=%d new=%d cells=%d\n",  nOld, nNew, b.nCell));  for(i=nNew; i<nOld; i++){  freePage(apOld[i], &rc);  }
#if 0
 if( ISAUTOVACUUM && rc==SQLITE_OK && apNew[0]->isInit ){  ptrmapCheckPages(apNew, nNew);  ptrmapCheckPages(&pParent, 1);  }
#endif
balance_cleanup:  sqlite3StackFree(0, b.apCell);  for(i=0; i<nOld; i++){  releasePage(apOld[i]);  }  for(i=0; i<nNew; i++){  releasePage(apNew[i]);  }  return rc; } static int balance_deeper(MemPage *pRoot, MemPage **ppChild){  int rc;  MemPage *pChild = 0;  Pgno pgnoChild = 0;  BtShared *pBt = pRoot->pBt;  assert( pRoot->nOverflow>0 );  assert( sqlite3_mutex_held(pBt->mutex) );  rc = sqlite3PagerWrite(pRoot->pDbPage);  if( rc==SQLITE_OK ){  rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot->pgno,0);  copyNodeContent(pRoot, pChild, &rc);  if( ISAUTOVACUUM ){  ptrmapPut(pBt, pgnoChild, PTRMAP_BTREE, pRoot->pgno, &rc);  }  }  if( rc ){  *ppChild = 0;  releasePage(pChild);  return rc;  }  assert( sqlite3PagerIswriteable(pChild->pDbPage) );  assert( sqlite3PagerIswriteable(pRoot->pDbPage) );  assert( pChild->nCell==pRoot->nCell || CORRUPT_DB );  TRACE(("BALANCE: copy root %d into %d\n", pRoot->pgno, pChild->pgno));  memcpy(pChild->aiOvfl, pRoot->aiOvfl,   pRoot->nOverflow*sizeof(pRoot->aiOvfl[0]));  memcpy(pChild->apOvfl, pRoot->apOvfl,   pRoot->nOverflow*sizeof(pRoot->apOvfl[0]));  pChild->nOverflow = pRoot->nOverflow;  zeroPage(pRoot, pChild->aData[0] & ~PTF_LEAF);  put4byte(&pRoot->aData[pRoot->hdrOffset+8], pgnoChild);  *ppChild = pChild;  return SQLITE_OK; } static int anotherValidCursor(BtCursor *pCur){  BtCursor *pOther;  for(pOther=pCur->pBt->pCursor; pOther; pOther=pOther->pNext){  if( pOther!=pCur   && pOther->eState==CURSOR_VALID   && pOther->pPage==pCur->pPage  ){  return SQLITE_CORRUPT_BKPT;  }  }  return SQLITE_OK; } static int balance(BtCursor *pCur){  int rc = SQLITE_OK;  const int nMin = pCur->pBt->usableSize * 2 / 3;  u8 aBalanceQuickSpace[13];  u8 *pFree = 0;  VVA_ONLY( int balance_quick_called = 0 );  VVA_ONLY( int balance_deeper_called = 0 );  do {  int iPage;  MemPage *pPage = pCur->pPage;  if( NEVER(pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;  if( pPage->nOverflow==0 && pPage->nFree<=nMin ){  break;  }else if( (iPage = pCur->iPage)==0 ){  if( pPage->nOverflow && (rc = anotherValidCursor(pCur))==SQLITE_OK ){  assert( balance_deeper_called==0 );  VVA_ONLY( balance_deeper_called++ );  rc = balance_deeper(pPage, &pCur->apPage[1]);  if( rc==SQLITE_OK ){  pCur->iPage = 1;  pCur->ix = 0;  pCur->aiIdx[0] = 0;  pCur->apPage[0] = pPage;  pCur->pPage = pCur->apPage[1];  assert( pCur->pPage->nOverflow );  }  }else{  break;  }  }else{  MemPage * const pParent = pCur->apPage[iPage-1];  int const iIdx = pCur->aiIdx[iPage-1];  rc = sqlite3PagerWrite(pParent->pDbPage);  if( rc==SQLITE_OK && pParent->nFree<0 ){  rc = btreeComputeFreeSpace(pParent);  }  if( rc==SQLITE_OK ){
#ifndef SQLITE_OMIT_QUICKBALANCE
 if( pPage->intKeyLeaf   && pPage->nOverflow==1   && pPage->aiOvfl[0]==pPage->nCell   && pParent->pgno!=1   && pParent->nCell==iIdx  ){  assert( balance_quick_called==0 );  VVA_ONLY( balance_quick_called++ );  rc = balance_quick(pParent, pPage, aBalanceQuickSpace);  }else
#endif
 {  u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);  rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1,   pCur->hints&BTREE_BULKLOAD);  if( pFree ){  sqlite3PageFree(pFree);  }  pFree = pSpace;  }  }  pPage->nOverflow = 0;  releasePage(pPage);  pCur->iPage--;  assert( pCur->iPage>=0 );  pCur->pPage = pCur->apPage[pCur->iPage];  }  }while( rc==SQLITE_OK );  if( pFree ){  sqlite3PageFree(pFree);  }  return rc; } static int btreeOverwriteContent(  MemPage *pPage,  u8 *pDest,  const BtreePayload *pX,  int iOffset,  int iAmt ){  int nData = pX->nData - iOffset;  if( nData<=0 ){  int i;  for(i=0; i<iAmt && pDest[i]==0; i++){}  if( i<iAmt ){  int rc = sqlite3PagerWrite(pPage->pDbPage);  if( rc ) return rc;  memset(pDest + i, 0, iAmt - i);  }  }else{  if( nData<iAmt ){  int rc = btreeOverwriteContent(pPage, pDest+nData, pX, iOffset+nData,   iAmt-nData);  if( rc ) return rc;  iAmt = nData;  }  if( memcmp(pDest, ((u8*)pX->pData) + iOffset, iAmt)!=0 ){  int rc = sqlite3PagerWrite(pPage->pDbPage);  if( rc ) return rc;  memmove(pDest, ((u8*)pX->pData) + iOffset, iAmt);  }  }  return SQLITE_OK; } static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){  int iOffset;  int nTotal = pX->nData + pX->nZero;  int rc;  MemPage *pPage = pCur->pPage;  BtShared *pBt;  Pgno ovflPgno;  u32 ovflPageSize;  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd   || pCur->info.pPayload < pPage->aData + pPage->cellOffset  ){  return SQLITE_CORRUPT_BKPT;  }  rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX,   0, pCur->info.nLocal);  if( rc ) return rc;  if( pCur->info.nLocal==nTotal ) return SQLITE_OK;  iOffset = pCur->info.nLocal;  assert( nTotal>=0 );  assert( iOffset>=0 );  ovflPgno = get4byte(pCur->info.pPayload + iOffset);  pBt = pPage->pBt;  ovflPageSize = pBt->usableSize - 4;  do{  rc = btreeGetPage(pBt, ovflPgno, &pPage, 0);  if( rc ) return rc;  if( sqlite3PagerPageRefcount(pPage->pDbPage)!=1 || pPage->isInit ){  rc = SQLITE_CORRUPT_BKPT;  }else{  if( iOffset+ovflPageSize<(u32)nTotal ){  ovflPgno = get4byte(pPage->aData);  }else{  ovflPageSize = nTotal - iOffset;  }  rc = btreeOverwriteContent(pPage, pPage->aData+4, pX,   iOffset, ovflPageSize);  }  sqlite3PagerUnref(pPage->pDbPage);  if( rc ) return rc;  iOffset += ovflPageSize;  }while( iOffset<nTotal );  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeInsert(  BtCursor *pCur,  const BtreePayload *pX,  int flags,  int seekResult ){  int rc;  int loc = seekResult;  int szNew = 0;  int idx;  MemPage *pPage;  Btree *p = pCur->pBtree;  BtShared *pBt = p->pBt;  unsigned char *oldCell;  unsigned char *newCell = 0;  assert( (flags & (BTREE_SAVEPOSITION|BTREE_APPEND|BTREE_PREFORMAT))==flags );  assert( (flags & BTREE_PREFORMAT)==0 || seekResult || pCur->pKeyInfo==0 );  if( pCur->eState==CURSOR_FAULT ){  assert( pCur->skipNext!=SQLITE_OK );  return pCur->skipNext;  }  assert( cursorOwnsBtShared(pCur) );  assert( (pCur->curFlags & BTCF_WriteFlag)!=0  && pBt->inTransaction==TRANS_WRITE  && (pBt->btsFlags & BTS_READ_ONLY)==0 );  assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );  assert( (flags & BTREE_PREFORMAT) || (pX->pKey==0)==(pCur->pKeyInfo==0) );  if( pCur->curFlags & BTCF_Multiple ){  rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);  if( rc ) return rc;  if( loc && pCur->iPage<0 ){  return SQLITE_CORRUPT_BKPT;  }  }  if( pCur->pKeyInfo==0 ){  assert( pX->pKey==0 );  if( p->hasIncrblobCur ){  invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);  }
#ifdef SQLITE_DEBUG
 if( flags & BTREE_SAVEPOSITION ){  assert( pCur->curFlags & BTCF_ValidNKey );  assert( pX->nKey==pCur->info.nKey );  assert( loc==0 );  }
#endif
 if( (pCur->curFlags&BTCF_ValidNKey)!=0 && pX->nKey==pCur->info.nKey ){  assert( pX->nData>=0 && pX->nZero>=0 );  if( pCur->info.nSize!=0   && pCur->info.nPayload==(u32)pX->nData+pX->nZero  ){  return btreeOverwriteCell(pCur, pX);  }  assert( loc==0 );  }else if( loc==0 ){  rc = sqlite3BtreeTableMoveto(pCur, pX->nKey,   (flags & BTREE_APPEND)!=0, &loc);  if( rc ) return rc;  }  }else{  assert( (flags & BTREE_SAVEPOSITION)==0 || loc==0 );  if( loc==0 && (flags & BTREE_SAVEPOSITION)==0 ){  if( pX->nMem ){  UnpackedRecord r;  r.pKeyInfo = pCur->pKeyInfo;  r.aMem = pX->aMem;  r.nField = pX->nMem;  r.default_rc = 0;  r.eqSeen = 0;  rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc);  }else{  rc = btreeMoveto(pCur, pX->pKey, pX->nKey,  (flags & BTREE_APPEND)!=0, &loc);  }  if( rc ) return rc;  }  if( loc==0 ){  getCellInfo(pCur);  if( pCur->info.nKey==pX->nKey ){  BtreePayload x2;  x2.pData = pX->pKey;  x2.nData = pX->nKey;  x2.nZero = 0;  return btreeOverwriteCell(pCur, &x2);  }  }  }  assert( pCur->eState==CURSOR_VALID   || (pCur->eState==CURSOR_INVALID && loc)   || CORRUPT_DB );  pPage = pCur->pPage;  assert( pPage->intKey || pX->nKey>=0 || (flags & BTREE_PREFORMAT) );  assert( pPage->leaf || !pPage->intKey );  if( pPage->nFree<0 ){  if( NEVER(pCur->eState>CURSOR_INVALID) ){  rc = SQLITE_CORRUPT_BKPT;  }else{  rc = btreeComputeFreeSpace(pPage);  }  if( rc ) return rc;  }  TRACE(("INSERT: table=%d nkey=%lld ndata=%d page=%d %s\n",  pCur->pgnoRoot, pX->nKey, pX->nData, pPage->pgno,  loc==0 ? "overwrite" : "new entry"));  assert( pPage->isInit );  newCell = pBt->pTmpSpace;  assert( newCell!=0 );  if( flags & BTREE_PREFORMAT ){  rc = SQLITE_OK;  szNew = pBt->nPreformatSize;  if( szNew<4 ) szNew = 4;  if( ISAUTOVACUUM && szNew>pPage->maxLocal ){  CellInfo info;  pPage->xParseCell(pPage, newCell, &info);  if( info.nPayload!=info.nLocal ){  Pgno ovfl = get4byte(&newCell[szNew-4]);  ptrmapPut(pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, &rc);  }  }  }else{  rc = fillInCell(pPage, newCell, pX, &szNew);  }  if( rc ) goto end_insert;  assert( szNew==pPage->xCellSize(pPage, newCell) );  assert( szNew <= MX_CELL_SIZE(pBt) );  idx = pCur->ix;  if( loc==0 ){  CellInfo info;  assert( idx>=0 );  if( idx>=pPage->nCell ){  return SQLITE_CORRUPT_BKPT;  }  rc = sqlite3PagerWrite(pPage->pDbPage);  if( rc ){  goto end_insert;  }  oldCell = findCell(pPage, idx);  if( !pPage->leaf ){  memcpy(newCell, oldCell, 4);  }  BTREE_CLEAR_CELL(rc, pPage, oldCell, info);  testcase( pCur->curFlags & BTCF_ValidOvfl );  invalidateOverflowCache(pCur);  if( info.nSize==szNew && info.nLocal==info.nPayload   && (!ISAUTOVACUUM || szNew<pPage->minLocal)  ){  assert( rc==SQLITE_OK );  if( oldCell < pPage->aData+pPage->hdrOffset+10 ){  return SQLITE_CORRUPT_BKPT;  }  if( oldCell+szNew > pPage->aDataEnd ){  return SQLITE_CORRUPT_BKPT;  }  memcpy(oldCell, newCell, szNew);  return SQLITE_OK;  }  dropCell(pPage, idx, info.nSize, &rc);  if( rc ) goto end_insert;  }else if( loc<0 && pPage->nCell>0 ){  assert( pPage->leaf );  idx = ++pCur->ix;  pCur->curFlags &= ~BTCF_ValidNKey;  }else{  assert( pPage->leaf );  }  insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);  assert( pPage->nOverflow==0 || rc==SQLITE_OK );  assert( rc!=SQLITE_OK || pPage->nCell>0 || pPage->nOverflow>0 );  pCur->info.nSize = 0;  if( pPage->nOverflow ){  assert( rc==SQLITE_OK );  pCur->curFlags &= ~(BTCF_ValidNKey);  rc = balance(pCur);  pCur->pPage->nOverflow = 0;  pCur->eState = CURSOR_INVALID;  if( (flags & BTREE_SAVEPOSITION) && rc==SQLITE_OK ){  btreeReleaseAllCursorPages(pCur);  if( pCur->pKeyInfo ){  assert( pCur->pKey==0 );  pCur->pKey = sqlite3Malloc( pX->nKey );  if( pCur->pKey==0 ){  rc = SQLITE_NOMEM;  }else{  memcpy(pCur->pKey, pX->pKey, pX->nKey);  }  }  pCur->eState = CURSOR_REQUIRESEEK;  pCur->nKey = pX->nKey;  }  }  assert( pCur->iPage<0 || pCur->pPage->nOverflow==0 ); end_insert:  return rc; } SQLITE_PRIVATE int sqlite3BtreeTransferRow(BtCursor *pDest, BtCursor *pSrc, i64 iKey){  int rc = SQLITE_OK;  BtShared *pBt = pDest->pBt;  u8 *aOut = pBt->pTmpSpace;  const u8 *aIn;  u32 nIn;  u32 nRem;  getCellInfo(pSrc);  aOut += putVarint32(aOut, pSrc->info.nPayload);  if( pDest->pKeyInfo==0 ) aOut += putVarint(aOut, iKey);  nIn = pSrc->info.nLocal;  aIn = pSrc->info.pPayload;  if( aIn+nIn>pSrc->pPage->aDataEnd ){  return SQLITE_CORRUPT_BKPT;  }  nRem = pSrc->info.nPayload;  if( nIn==nRem && nIn<pDest->pPage->maxLocal ){  memcpy(aOut, aIn, nIn);  pBt->nPreformatSize = nIn + (aOut - pBt->pTmpSpace);  }else{  Pager *pSrcPager = pSrc->pBt->pPager;  u8 *pPgnoOut = 0;  Pgno ovflIn = 0;  DbPage *pPageIn = 0;  MemPage *pPageOut = 0;  u32 nOut;  nOut = btreePayloadToLocal(pDest->pPage, pSrc->info.nPayload);  pBt->nPreformatSize = nOut + (aOut - pBt->pTmpSpace);  if( nOut<pSrc->info.nPayload ){  pPgnoOut = &aOut[nOut];  pBt->nPreformatSize += 4;  }  if( nRem>nIn ){  if( aIn+nIn+4>pSrc->pPage->aDataEnd ){  return SQLITE_CORRUPT_BKPT;  }  ovflIn = get4byte(&pSrc->info.pPayload[nIn]);  }  do {  nRem -= nOut;  do{  assert( nOut>0 );  if( nIn>0 ){  int nCopy = MIN(nOut, nIn);  memcpy(aOut, aIn, nCopy);  nOut -= nCopy;  nIn -= nCopy;  aOut += nCopy;  aIn += nCopy;  }  if( nOut>0 ){  sqlite3PagerUnref(pPageIn);  pPageIn = 0;  rc = sqlite3PagerGet(pSrcPager, ovflIn, &pPageIn, PAGER_GET_READONLY);  if( rc==SQLITE_OK ){  aIn = (const u8*)sqlite3PagerGetData(pPageIn);  ovflIn = get4byte(aIn);  aIn += 4;  nIn = pSrc->pBt->usableSize - 4;  }  }  }while( rc==SQLITE_OK && nOut>0 );  if( rc==SQLITE_OK && nRem>0 && ALWAYS(pPgnoOut) ){  Pgno pgnoNew;  MemPage *pNew = 0;  rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);  put4byte(pPgnoOut, pgnoNew);  if( ISAUTOVACUUM && pPageOut ){  ptrmapPut(pBt, pgnoNew, PTRMAP_OVERFLOW2, pPageOut->pgno, &rc);  }  releasePage(pPageOut);  pPageOut = pNew;  if( pPageOut ){  pPgnoOut = pPageOut->aData;  put4byte(pPgnoOut, 0);  aOut = &pPgnoOut[4];  nOut = MIN(pBt->usableSize - 4, nRem);  }  }  }while( nRem>0 && rc==SQLITE_OK );  releasePage(pPageOut);  sqlite3PagerUnref(pPageIn);  }  return rc; } SQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){  Btree *p = pCur->pBtree;  BtShared *pBt = p->pBt;  int rc;  MemPage *pPage;  unsigned char *pCell;  int iCellIdx;  int iCellDepth;  CellInfo info;  int bSkipnext = 0;  u8 bPreserve = flags & BTREE_SAVEPOSITION;  assert( cursorOwnsBtShared(pCur) );  assert( pBt->inTransaction==TRANS_WRITE );  assert( (pBt->btsFlags & BTS_READ_ONLY)==0 );  assert( pCur->curFlags & BTCF_WriteFlag );  assert( hasSharedCacheTableLock(p, pCur->pgnoRoot, pCur->pKeyInfo!=0, 2) );  assert( !hasReadConflicts(p, pCur->pgnoRoot) );  assert( (flags & ~(BTREE_SAVEPOSITION | BTREE_AUXDELETE))==0 );  if( pCur->eState==CURSOR_REQUIRESEEK ){  rc = btreeRestoreCursorPosition(pCur);  assert( rc!=SQLITE_OK || CORRUPT_DB || pCur->eState==CURSOR_VALID );  if( rc || pCur->eState!=CURSOR_VALID ) return rc;  }  assert( CORRUPT_DB || pCur->eState==CURSOR_VALID );  iCellDepth = pCur->iPage;  iCellIdx = pCur->ix;  pPage = pCur->pPage;  pCell = findCell(pPage, iCellIdx);  if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ){  return SQLITE_CORRUPT_BKPT;  }  if( pPage->nCell<=iCellIdx ){  return SQLITE_CORRUPT_BKPT;  }  if( bPreserve ){  if( !pPage->leaf   || (pPage->nFree+cellSizePtr(pPage,pCell)+2)>(int)(pBt->usableSize*2/3)   || pPage->nCell==1  ){  rc = saveCursorKey(pCur);  if( rc ) return rc;  }else{  bSkipnext = 1;  }  }  if( !pPage->leaf ){  rc = sqlite3BtreePrevious(pCur, 0);  assert( rc!=SQLITE_DONE );  if( rc ) return rc;  }  if( pCur->curFlags & BTCF_Multiple ){  rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);  if( rc ) return rc;  }  if( pCur->pKeyInfo==0 && p->hasIncrblobCur ){  invalidateIncrblobCursors(p, pCur->pgnoRoot, pCur->info.nKey, 0);  }  rc = sqlite3PagerWrite(pPage->pDbPage);  if( rc ) return rc;  BTREE_CLEAR_CELL(rc, pPage, pCell, info);  dropCell(pPage, iCellIdx, info.nSize, &rc);  if( rc ) return rc;  if( !pPage->leaf ){  MemPage *pLeaf = pCur->pPage;  int nCell;  Pgno n;  unsigned char *pTmp;  if( pLeaf->nFree<0 ){  rc = btreeComputeFreeSpace(pLeaf);  if( rc ) return rc;  }  if( iCellDepth<pCur->iPage-1 ){  n = pCur->apPage[iCellDepth+1]->pgno;  }else{  n = pCur->pPage->pgno;  }  pCell = findCell(pLeaf, pLeaf->nCell-1);  if( pCell<&pLeaf->aData[4] ) return SQLITE_CORRUPT_BKPT;  nCell = pLeaf->xCellSize(pLeaf, pCell);  assert( MX_CELL_SIZE(pBt) >= nCell );  pTmp = pBt->pTmpSpace;  assert( pTmp!=0 );  rc = sqlite3PagerWrite(pLeaf->pDbPage);  if( rc==SQLITE_OK ){  insertCell(pPage, iCellIdx, pCell-4, nCell+4, pTmp, n, &rc);  }  dropCell(pLeaf, pLeaf->nCell-1, nCell, &rc);  if( rc ) return rc;  }  rc = balance(pCur);  if( rc==SQLITE_OK && pCur->iPage>iCellDepth ){  releasePageNotNull(pCur->pPage);  pCur->iPage--;  while( pCur->iPage>iCellDepth ){  releasePage(pCur->apPage[pCur->iPage--]);  }  pCur->pPage = pCur->apPage[pCur->iPage];  rc = balance(pCur);  }  if( rc==SQLITE_OK ){  if( bSkipnext ){  assert( bPreserve && (pCur->iPage==iCellDepth || CORRUPT_DB) );  assert( pPage==pCur->pPage || CORRUPT_DB );  assert( (pPage->nCell>0 || CORRUPT_DB) && iCellIdx<=pPage->nCell );  pCur->eState = CURSOR_SKIPNEXT;  if( iCellIdx>=pPage->nCell ){  pCur->skipNext = -1;  pCur->ix = pPage->nCell-1;  }else{  pCur->skipNext = 1;  }  }else{  rc = moveToRoot(pCur);  if( bPreserve ){  btreeReleaseAllCursorPages(pCur);  pCur->eState = CURSOR_REQUIRESEEK;  }  if( rc==SQLITE_EMPTY ) rc = SQLITE_OK;  }  }  return rc; } static int btreeCreateTable(Btree *p, Pgno *piTable, int createTabFlags){  BtShared *pBt = p->pBt;  MemPage *pRoot;  Pgno pgnoRoot;  int rc;  int ptfFlags;  assert( sqlite3BtreeHoldsMutex(p) );  assert( pBt->inTransaction==TRANS_WRITE );  assert( (pBt->btsFlags & BTS_READ_ONLY)==0 );
#ifdef SQLITE_OMIT_AUTOVACUUM
 rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);  if( rc ){  return rc;  }
#else
 if( pBt->autoVacuum ){  Pgno pgnoMove;  MemPage *pPageMove;  invalidateAllOverflowCache(pBt);  sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &pgnoRoot);  if( pgnoRoot>btreePagecount(pBt) ){  return SQLITE_CORRUPT_BKPT;  }  pgnoRoot++;  while( pgnoRoot==PTRMAP_PAGENO(pBt, pgnoRoot) ||  pgnoRoot==PENDING_BYTE_PAGE(pBt) ){  pgnoRoot++;  }  assert( pgnoRoot>=3 );  rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, BTALLOC_EXACT);  if( rc!=SQLITE_OK ){  return rc;  }  if( pgnoMove!=pgnoRoot ){  u8 eType = 0;  Pgno iPtrPage = 0;  rc = saveAllCursors(pBt, 0, 0);  releasePage(pPageMove);  if( rc!=SQLITE_OK ){  return rc;  }  rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);  if( rc!=SQLITE_OK ){  return rc;  }  rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage);  if( eType==PTRMAP_ROOTPAGE || eType==PTRMAP_FREEPAGE ){  rc = SQLITE_CORRUPT_BKPT;  }  if( rc!=SQLITE_OK ){  releasePage(pRoot);  return rc;  }  assert( eType!=PTRMAP_ROOTPAGE );  assert( eType!=PTRMAP_FREEPAGE );  rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);  releasePage(pRoot);  if( rc!=SQLITE_OK ){  return rc;  }  rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);  if( rc!=SQLITE_OK ){  return rc;  }  rc = sqlite3PagerWrite(pRoot->pDbPage);  if( rc!=SQLITE_OK ){  releasePage(pRoot);  return rc;  }  }else{  pRoot = pPageMove;  }  ptrmapPut(pBt, pgnoRoot, PTRMAP_ROOTPAGE, 0, &rc);  if( rc ){  releasePage(pRoot);  return rc;  }  assert( sqlite3PagerIswriteable(pBt->pPage1->pDbPage) );  rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);  if( NEVER(rc) ){  releasePage(pRoot);  return rc;  }  }else{  rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);  if( rc ) return rc;  }
#endif
 assert( sqlite3PagerIswriteable(pRoot->pDbPage) );  if( createTabFlags & BTREE_INTKEY ){  ptfFlags = PTF_INTKEY | PTF_LEAFDATA | PTF_LEAF;  }else{  ptfFlags = PTF_ZERODATA | PTF_LEAF;  }  zeroPage(pRoot, ptfFlags);  sqlite3PagerUnref(pRoot->pDbPage);  assert( (pBt->openFlags & BTREE_SINGLE)==0 || pgnoRoot==2 );  *piTable = pgnoRoot;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree *p, Pgno *piTable, int flags){  int rc;  sqlite3BtreeEnter(p);  rc = btreeCreateTable(p, piTable, flags);  sqlite3BtreeLeave(p);  return rc; } static int clearDatabasePage(  BtShared *pBt,  Pgno pgno,  int freePageFlag,  i64 *pnChange ){  MemPage *pPage;  int rc;  unsigned char *pCell;  int i;  int hdr;  CellInfo info;  assert( sqlite3_mutex_held(pBt->mutex) );  if( pgno>btreePagecount(pBt) ){  return SQLITE_CORRUPT_BKPT;  }  rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);  if( rc ) return rc;  if( (pBt->openFlags & BTREE_SINGLE)==0   && sqlite3PagerPageRefcount(pPage->pDbPage)!=1  ){  rc = SQLITE_CORRUPT_BKPT;  goto cleardatabasepage_out;  }  hdr = pPage->hdrOffset;  for(i=0; i<pPage->nCell; i++){  pCell = findCell(pPage, i);  if( !pPage->leaf ){  rc = clearDatabasePage(pBt, get4byte(pCell), 1, pnChange);  if( rc ) goto cleardatabasepage_out;  }  BTREE_CLEAR_CELL(rc, pPage, pCell, info);  if( rc ) goto cleardatabasepage_out;  }  if( !pPage->leaf ){  rc = clearDatabasePage(pBt, get4byte(&pPage->aData[hdr+8]), 1, pnChange);  if( rc ) goto cleardatabasepage_out;  if( pPage->intKey ) pnChange = 0;  }  if( pnChange ){  testcase( !pPage->intKey );  *pnChange += pPage->nCell;  }  if( freePageFlag ){  freePage(pPage, &rc);  }else if( (rc = sqlite3PagerWrite(pPage->pDbPage))==0 ){  zeroPage(pPage, pPage->aData[hdr] | PTF_LEAF);  } cleardatabasepage_out:  releasePage(pPage);  return rc; } SQLITE_PRIVATE int sqlite3BtreeClearTable(Btree *p, int iTable, i64 *pnChange){  int rc;  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);  assert( p->inTrans==TRANS_WRITE );  rc = saveAllCursors(pBt, (Pgno)iTable, 0);  if( SQLITE_OK==rc ){  if( p->hasIncrblobCur ){  invalidateIncrblobCursors(p, (Pgno)iTable, 0, 1);  }  rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange);  }  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeClearTableOfCursor(BtCursor *pCur){  return sqlite3BtreeClearTable(pCur->pBtree, pCur->pgnoRoot, 0); } static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){  int rc;  MemPage *pPage = 0;  BtShared *pBt = p->pBt;  assert( sqlite3BtreeHoldsMutex(p) );  assert( p->inTrans==TRANS_WRITE );  assert( iTable>=2 );  if( iTable>btreePagecount(pBt) ){  return SQLITE_CORRUPT_BKPT;  }  rc = sqlite3BtreeClearTable(p, iTable, 0);  if( rc ) return rc;  rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);  if( NEVER(rc) ){  releasePage(pPage);  return rc;  }  *piMoved = 0;
#ifdef SQLITE_OMIT_AUTOVACUUM
 freePage(pPage, &rc);  releasePage(pPage);
#else
 if( pBt->autoVacuum ){  Pgno maxRootPgno;  sqlite3BtreeGetMeta(p, BTREE_LARGEST_ROOT_PAGE, &maxRootPgno);  if( iTable==maxRootPgno ){  freePage(pPage, &rc);  releasePage(pPage);  if( rc!=SQLITE_OK ){  return rc;  }  }else{  MemPage *pMove;  releasePage(pPage);  rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);  if( rc!=SQLITE_OK ){  return rc;  }  rc = relocatePage(pBt, pMove, PTRMAP_ROOTPAGE, 0, iTable, 0);  releasePage(pMove);  if( rc!=SQLITE_OK ){  return rc;  }  pMove = 0;  rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);  freePage(pMove, &rc);  releasePage(pMove);  if( rc!=SQLITE_OK ){  return rc;  }  *piMoved = maxRootPgno;  }  maxRootPgno--;  while( maxRootPgno==PENDING_BYTE_PAGE(pBt)   || PTRMAP_ISPAGE(pBt, maxRootPgno) ){  maxRootPgno--;  }  assert( maxRootPgno!=PENDING_BYTE_PAGE(pBt) );  rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);  }else{  freePage(pPage, &rc);  releasePage(pPage);  }
#endif
 return rc; } SQLITE_PRIVATE int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){  int rc;  sqlite3BtreeEnter(p);  rc = btreeDropTable(p, iTable, piMoved);  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);  assert( p->inTrans>TRANS_NONE );  assert( SQLITE_OK==querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK) );  assert( pBt->pPage1 );  assert( idx>=0 && idx<=15 );  if( idx==BTREE_DATA_VERSION ){  *pMeta = sqlite3PagerDataVersion(pBt->pPager) + p->iBDataVersion;  }else{  *pMeta = get4byte(&pBt->pPage1->aData[36 + idx*4]);  }
#ifdef SQLITE_OMIT_AUTOVACUUM
 if( idx==BTREE_LARGEST_ROOT_PAGE && *pMeta>0 ){  pBt->btsFlags |= BTS_READ_ONLY;  }
#endif
 sqlite3BtreeLeave(p); } SQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){  BtShared *pBt = p->pBt;  unsigned char *pP1;  int rc;  assert( idx>=1 && idx<=15 );  sqlite3BtreeEnter(p);  assert( p->inTrans==TRANS_WRITE );  assert( pBt->pPage1!=0 );  pP1 = pBt->pPage1->aData;  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);  if( rc==SQLITE_OK ){  put4byte(&pP1[36 + idx*4], iMeta);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( idx==BTREE_INCR_VACUUM ){  assert( pBt->autoVacuum || iMeta==0 );  assert( iMeta==0 || iMeta==1 );  pBt->incrVacuum = (u8)iMeta;  }
#endif
 }  sqlite3BtreeLeave(p);  return rc; } SQLITE_PRIVATE int sqlite3BtreeCount(sqlite3 *db, BtCursor *pCur, i64 *pnEntry){  i64 nEntry = 0;  int rc;  rc = moveToRoot(pCur);  if( rc==SQLITE_EMPTY ){  *pnEntry = 0;  return SQLITE_OK;  }  while( rc==SQLITE_OK && !AtomicLoad(&db->u1.isInterrupted) ){  int iIdx;  MemPage *pPage;  pPage = pCur->pPage;  if( pPage->leaf || !pPage->intKey ){  nEntry += pPage->nCell;  }  if( pPage->leaf ){  do {  if( pCur->iPage==0 ){  *pnEntry = nEntry;  return moveToRoot(pCur);  }  moveToParent(pCur);  }while ( pCur->ix>=pCur->pPage->nCell );  pCur->ix++;  pPage = pCur->pPage;  }  iIdx = pCur->ix;  if( iIdx==pPage->nCell ){  rc = moveToChild(pCur, get4byte(&pPage->aData[pPage->hdrOffset+8]));  }else{  rc = moveToChild(pCur, get4byte(findCell(pPage, iIdx)));  }  }  return rc; } SQLITE_PRIVATE Pager *sqlite3BtreePager(Btree *p){  return p->pBt->pPager; }
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
static void checkAppendMsg(  IntegrityCk *pCheck,  const char *zFormat,  ... ){  va_list ap;  if( !pCheck->mxErr ) return;  pCheck->mxErr--;  pCheck->nErr++;  va_start(ap, zFormat);  if( pCheck->errMsg.nChar ){  sqlite3_str_append(&pCheck->errMsg, "\n", 1);  }  if( pCheck->zPfx ){  sqlite3_str_appendf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);  }  sqlite3_str_vappendf(&pCheck->errMsg, zFormat, ap);  va_end(ap);  if( pCheck->errMsg.accError==SQLITE_NOMEM ){  pCheck->bOomFault = 1;  } }
#endif
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
static int getPageReferenced(IntegrityCk *pCheck, Pgno iPg){  assert( iPg<=pCheck->nPage && sizeof(pCheck->aPgRef[0])==1 );  return (pCheck->aPgRef[iPg/8] & (1 << (iPg & 0x07))); } static void setPageReferenced(IntegrityCk *pCheck, Pgno iPg){  assert( iPg<=pCheck->nPage && sizeof(pCheck->aPgRef[0])==1 );  pCheck->aPgRef[iPg/8] |= (1 << (iPg & 0x07)); } static int checkRef(IntegrityCk *pCheck, Pgno iPage){  if( iPage>pCheck->nPage || iPage==0 ){  checkAppendMsg(pCheck, "invalid page number %d", iPage);  return 1;  }  if( getPageReferenced(pCheck, iPage) ){  checkAppendMsg(pCheck, "2nd reference to page %d", iPage);  return 1;  }  if( AtomicLoad(&pCheck->db->u1.isInterrupted) ) return 1;  setPageReferenced(pCheck, iPage);  return 0; }
#ifndef SQLITE_OMIT_AUTOVACUUM
static void checkPtrmap(  IntegrityCk *pCheck,  Pgno iChild,  u8 eType,  Pgno iParent ){  int rc;  u8 ePtrmapType;  Pgno iPtrmapParent;  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->bOomFault = 1;  checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", iChild);  return;  }  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){  checkAppendMsg(pCheck,  "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",  iChild, eType, iParent, ePtrmapType, iPtrmapParent);  } }
#endif
static void checkList(  IntegrityCk *pCheck,  int isFreeList,  Pgno iPage,  u32 N ){  int i;  u32 expected = N;  int nErrAtStart = pCheck->nErr;  while( iPage!=0 && pCheck->mxErr ){  DbPage *pOvflPage;  unsigned char *pOvflData;  if( checkRef(pCheck, iPage) ) break;  N--;  if( sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage, 0) ){  checkAppendMsg(pCheck, "failed to get page %d", iPage);  break;  }  pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);  if( isFreeList ){  u32 n = (u32)get4byte(&pOvflData[4]);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pCheck->pBt->autoVacuum ){  checkPtrmap(pCheck, iPage, PTRMAP_FREEPAGE, 0);  }
#endif
 if( n>pCheck->pBt->usableSize/4-2 ){  checkAppendMsg(pCheck,   "freelist leaf count too big on page %d", iPage);  N--;  }else{  for(i=0; i<(int)n; i++){  Pgno iFreePage = get4byte(&pOvflData[8+i*4]);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pCheck->pBt->autoVacuum ){  checkPtrmap(pCheck, iFreePage, PTRMAP_FREEPAGE, 0);  }
#endif
 checkRef(pCheck, iFreePage);  }  N -= n;  }  }
#ifndef SQLITE_OMIT_AUTOVACUUM
 else{  if( pCheck->pBt->autoVacuum && N>0 ){  i = get4byte(pOvflData);  checkPtrmap(pCheck, i, PTRMAP_OVERFLOW2, iPage);  }  }
#endif
 iPage = get4byte(pOvflData);  sqlite3PagerUnref(pOvflPage);  }  if( N && nErrAtStart==pCheck->nErr ){  checkAppendMsg(pCheck,  "%s is %d but should be %d",  isFreeList ? "size" : "overflow list length",  expected-N, expected);  } }
#endif
static void btreeHeapInsert(u32 *aHeap, u32 x){  u32 j, i = ++aHeap[0];  aHeap[i] = x;  while( (j = i/2)>0 && aHeap[j]>aHeap[i] ){  x = aHeap[j];  aHeap[j] = aHeap[i];  aHeap[i] = x;  i = j;  } } static int btreeHeapPull(u32 *aHeap, u32 *pOut){  u32 j, i, x;  if( (x = aHeap[0])==0 ) return 0;  *pOut = aHeap[1];  aHeap[1] = aHeap[x];  aHeap[x] = 0xffffffff;  aHeap[0]--;  i = 1;  while( (j = i*2)<=aHeap[0] ){  if( aHeap[j]>aHeap[j+1] ) j++;  if( aHeap[i]<aHeap[j] ) break;  x = aHeap[i];  aHeap[i] = aHeap[j];  aHeap[j] = x;  i = j;  }  return 1; }
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
static int checkTreePage(  IntegrityCk *pCheck,  Pgno iPage,  i64 *piMinKey,  i64 maxKey ){  MemPage *pPage = 0;  int i;  int rc;  int depth = -1, d2;  int pgno;  int nFrag;  int hdr;  int cellStart;  int nCell;  int doCoverageCheck = 1;  int keyCanBeEqual = 1;  u8 *data;  u8 *pCell;  u8 *pCellIdx;  BtShared *pBt;  u32 pc;  u32 usableSize;  u32 contentOffset;  u32 *heap = 0;  u32 x, prev = 0;  const char *saved_zPfx = pCheck->zPfx;  int saved_v1 = pCheck->v1;  int saved_v2 = pCheck->v2;  u8 savedIsInit = 0;  pBt = pCheck->pBt;  usableSize = pBt->usableSize;  if( iPage==0 ) return 0;  if( checkRef(pCheck, iPage) ) return 0;  pCheck->zPfx = "Page %u: ";  pCheck->v1 = iPage;  if( (rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0 ){  checkAppendMsg(pCheck,   "unable to get the page. error code=%d", rc);  goto end_of_check;  }  savedIsInit = pPage->isInit;  pPage->isInit = 0;  if( (rc = btreeInitPage(pPage))!=0 ){  assert( rc==SQLITE_CORRUPT );  checkAppendMsg(pCheck,   "btreeInitPage() returns error code %d", rc);  goto end_of_check;  }  if( (rc = btreeComputeFreeSpace(pPage))!=0 ){  assert( rc==SQLITE_CORRUPT );  checkAppendMsg(pCheck, "free space corruption", rc);  goto end_of_check;  }  data = pPage->aData;  hdr = pPage->hdrOffset;  pCheck->zPfx = "On tree page %u cell %d: ";  contentOffset = get2byteNotZero(&data[hdr+5]);  assert( contentOffset<=usableSize );  nCell = get2byte(&data[hdr+3]);  assert( pPage->nCell==nCell );  cellStart = hdr + 12 - 4*pPage->leaf;  assert( pPage->aCellIdx==&data[cellStart] );  pCellIdx = &data[cellStart + 2*(nCell-1)];  if( !pPage->leaf ){  pgno = get4byte(&data[hdr+8]);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum ){  pCheck->zPfx = "On page %u at right child: ";  checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);  }
#endif
 depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);  keyCanBeEqual = 0;  }else{  heap = pCheck->heap;  heap[0] = 0;  }  for(i=nCell-1; i>=0 && pCheck->mxErr; i--){  CellInfo info;  pCheck->v2 = i;  assert( pCellIdx==&data[cellStart + i*2] );  pc = get2byteAligned(pCellIdx);  pCellIdx -= 2;  if( pc<contentOffset || pc>usableSize-4 ){  checkAppendMsg(pCheck, "Offset %d out of range %d..%d",   pc, contentOffset, usableSize-4);  doCoverageCheck = 0;  continue;  }  pCell = &data[pc];  pPage->xParseCell(pPage, pCell, &info);  if( pc+info.nSize>usableSize ){  checkAppendMsg(pCheck, "Extends off end of page");  doCoverageCheck = 0;  continue;  }  if( pPage->intKey ){  if( keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey) ){  checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);  }  maxKey = info.nKey;  keyCanBeEqual = 0;  }  if( info.nPayload>info.nLocal ){  u32 nPage;  Pgno pgnoOvfl;  assert( pc + info.nSize - 4 <= usableSize );  nPage = (info.nPayload - info.nLocal + usableSize - 5)/(usableSize - 4);  pgnoOvfl = get4byte(&pCell[info.nSize - 4]);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum ){  checkPtrmap(pCheck, pgnoOvfl, PTRMAP_OVERFLOW1, iPage);  }
#endif
 checkList(pCheck, 0, pgnoOvfl, nPage);  }  if( !pPage->leaf ){  pgno = get4byte(pCell);
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum ){  checkPtrmap(pCheck, pgno, PTRMAP_BTREE, iPage);  }
#endif
 d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);  keyCanBeEqual = 0;  if( d2!=depth ){  checkAppendMsg(pCheck, "Child page depth differs");  depth = d2;  }  }else{  btreeHeapInsert(heap, (pc<<16)|(pc+info.nSize-1));  }  }  *piMinKey = maxKey;  pCheck->zPfx = 0;  if( doCoverageCheck && pCheck->mxErr>0 ){  if( !pPage->leaf ){  heap = pCheck->heap;  heap[0] = 0;  for(i=nCell-1; i>=0; i--){  u32 size;  pc = get2byteAligned(&data[cellStart+i*2]);  size = pPage->xCellSize(pPage, &data[pc]);  btreeHeapInsert(heap, (pc<<16)|(pc+size-1));  }  }  i = get2byte(&data[hdr+1]);  while( i>0 ){  int size, j;  assert( (u32)i<=usableSize-4 );  size = get2byte(&data[i+2]);  assert( (u32)(i+size)<=usableSize );  btreeHeapInsert(heap, (((u32)i)<<16)|(i+size-1));  j = get2byte(&data[i]);  assert( j==0 || j>i+size );  assert( (u32)j<=usableSize-4 );  i = j;  }  nFrag = 0;  prev = contentOffset - 1;  while( btreeHeapPull(heap,&x) ){  if( (prev&0xffff)>=(x>>16) ){  checkAppendMsg(pCheck,  "Multiple uses for byte %u of page %u", x>>16, iPage);  break;  }else{  nFrag += (x>>16) - (prev&0xffff) - 1;  prev = x;  }  }  nFrag += usableSize - (prev&0xffff) - 1;  if( heap[0]==0 && nFrag!=data[hdr+7] ){  checkAppendMsg(pCheck,  "Fragmentation of %d bytes reported as %d on page %u",  nFrag, data[hdr+7], iPage);  }  } end_of_check:  if( !doCoverageCheck ) pPage->isInit = savedIsInit;  releasePage(pPage);  pCheck->zPfx = saved_zPfx;  pCheck->v1 = saved_v1;  pCheck->v2 = saved_v2;  return depth+1; }
#endif
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(  sqlite3 *db,  Btree *p,  Pgno *aRoot,  int nRoot,  int mxErr,  int *pnErr ){  Pgno i;  IntegrityCk sCheck;  BtShared *pBt = p->pBt;  u64 savedDbFlags = pBt->db->flags;  char zErr[100];  int bPartial = 0;  int bCkFreelist = 1;  VVA_ONLY( int nRef );  assert( nRoot>0 );  if( aRoot[0]==0 ){  assert( nRoot>1 );  bPartial = 1;  if( aRoot[1]!=1 ) bCkFreelist = 0;  }  sqlite3BtreeEnter(p);  assert( p->inTrans>TRANS_NONE && pBt->inTransaction>TRANS_NONE );  VVA_ONLY( nRef = sqlite3PagerRefcount(pBt->pPager) );  assert( nRef>=0 );  sCheck.db = db;  sCheck.pBt = pBt;  sCheck.pPager = pBt->pPager;  sCheck.nPage = btreePagecount(sCheck.pBt);  sCheck.mxErr = mxErr;  sCheck.nErr = 0;  sCheck.bOomFault = 0;  sCheck.zPfx = 0;  sCheck.v1 = 0;  sCheck.v2 = 0;  sCheck.aPgRef = 0;  sCheck.heap = 0;  sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof(zErr), SQLITE_MAX_LENGTH);  sCheck.errMsg.printfFlags = SQLITE_PRINTF_INTERNAL;  if( sCheck.nPage==0 ){  goto integrity_ck_cleanup;  }  sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage / 8)+ 1);  if( !sCheck.aPgRef ){  sCheck.bOomFault = 1;  goto integrity_ck_cleanup;  }  sCheck.heap = (u32*)sqlite3PageMalloc( pBt->pageSize );  if( sCheck.heap==0 ){  sCheck.bOomFault = 1;  goto integrity_ck_cleanup;  }  i = PENDING_BYTE_PAGE(pBt);  if( i<=sCheck.nPage ) setPageReferenced(&sCheck, i);  if( bCkFreelist ){  sCheck.zPfx = "Main freelist: ";  checkList(&sCheck, 1, get4byte(&pBt->pPage1->aData[32]),  get4byte(&pBt->pPage1->aData[36]));  sCheck.zPfx = 0;  }
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( !bPartial ){  if( pBt->autoVacuum ){  Pgno mx = 0;  Pgno mxInHdr;  for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];  mxInHdr = get4byte(&pBt->pPage1->aData[52]);  if( mx!=mxInHdr ){  checkAppendMsg(&sCheck,  "max rootpage (%d) disagrees with header (%d)",  mx, mxInHdr  );  }  }else if( get4byte(&pBt->pPage1->aData[64])!=0 ){  checkAppendMsg(&sCheck,  "incremental_vacuum enabled with a max rootpage of zero"  );  }  }
#endif
 testcase( pBt->db->flags & SQLITE_CellSizeCk );  pBt->db->flags &= ~(u64)SQLITE_CellSizeCk;  for(i=0; (int)i<nRoot && sCheck.mxErr; i++){  i64 notUsed;  if( aRoot[i]==0 ) continue;
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pBt->autoVacuum && aRoot[i]>1 && !bPartial ){  checkPtrmap(&sCheck, aRoot[i], PTRMAP_ROOTPAGE, 0);  }
#endif
 checkTreePage(&sCheck, aRoot[i], &notUsed, LARGEST_INT64);  }  pBt->db->flags = savedDbFlags;  if( !bPartial ){  for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){
#ifdef SQLITE_OMIT_AUTOVACUUM
 if( getPageReferenced(&sCheck, i)==0 ){  checkAppendMsg(&sCheck, "Page %d is never used", i);  }
#else
 if( getPageReferenced(&sCheck, i)==0 &&   (PTRMAP_PAGENO(pBt, i)!=i || !pBt->autoVacuum) ){  checkAppendMsg(&sCheck, "Page %d is never used", i);  }  if( getPageReferenced(&sCheck, i)!=0 &&   (PTRMAP_PAGENO(pBt, i)==i && pBt->autoVacuum) ){  checkAppendMsg(&sCheck, "Pointer map page %d is referenced", i);  }
#endif
 }  } integrity_ck_cleanup:  sqlite3PageFree(sCheck.heap);  sqlite3_free(sCheck.aPgRef);  if( sCheck.bOomFault ){  sqlite3_str_reset(&sCheck.errMsg);  sCheck.nErr++;  }  *pnErr = sCheck.nErr;  if( sCheck.nErr==0 ) sqlite3_str_reset(&sCheck.errMsg);  assert( nRef==sqlite3PagerRefcount(pBt->pPager) );  sqlite3BtreeLeave(p);  return sqlite3StrAccumFinish(&sCheck.errMsg); }
#endif
SQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *p){  assert( p->pBt->pPager!=0 );  return sqlite3PagerFilename(p->pBt->pPager, 1); } SQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *p){  assert( p->pBt->pPager!=0 );  return sqlite3PagerJournalname(p->pBt->pPager); } SQLITE_PRIVATE int sqlite3BtreeTxnState(Btree *p){  assert( p==0 || sqlite3_mutex_held(p->db->mutex) );  return p ? p->inTrans : 0; }
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt){  int rc = SQLITE_OK;  if( p ){  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);  if( pBt->inTransaction!=TRANS_NONE ){  rc = SQLITE_LOCKED;  }else{  rc = sqlite3PagerCheckpoint(pBt->pPager, p->db, eMode, pnLog, pnCkpt);  }  sqlite3BtreeLeave(p);  }  return rc; }
#endif
SQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree *p){  assert( p );  assert( sqlite3_mutex_held(p->db->mutex) );  return p->nBackup!=0; } SQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){  BtShared *pBt = p->pBt;  sqlite3BtreeEnter(p);  if( !pBt->pSchema && nBytes ){  pBt->pSchema = sqlite3DbMallocZero(0, nBytes);  pBt->xFreeSchema = xFree;  }  sqlite3BtreeLeave(p);  return pBt->pSchema; } SQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *p){  int rc;  assert( sqlite3_mutex_held(p->db->mutex) );  sqlite3BtreeEnter(p);  rc = querySharedCacheTableLock(p, SCHEMA_ROOT, READ_LOCK);  assert( rc==SQLITE_OK || rc==SQLITE_LOCKED_SHAREDCACHE );  sqlite3BtreeLeave(p);  return rc; }
#ifndef SQLITE_OMIT_SHARED_CACHE
SQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){  int rc = SQLITE_OK;  assert( p->inTrans!=TRANS_NONE );  if( p->sharable ){  u8 lockType = READ_LOCK + isWriteLock;  assert( READ_LOCK+1==WRITE_LOCK );  assert( isWriteLock==0 || isWriteLock==1 );  sqlite3BtreeEnter(p);  rc = querySharedCacheTableLock(p, iTab, lockType);  if( rc==SQLITE_OK ){  rc = setSharedCacheTableLock(p, iTab, lockType);  }  sqlite3BtreeLeave(p);  }  return rc; }
#endif
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){  int rc;  assert( cursorOwnsBtShared(pCsr) );  assert( sqlite3_mutex_held(pCsr->pBtree->db->mutex) );  assert( pCsr->curFlags & BTCF_Incrblob );  rc = restoreCursorPosition(pCsr);  if( rc!=SQLITE_OK ){  return rc;  }  assert( pCsr->eState!=CURSOR_REQUIRESEEK );  if( pCsr->eState!=CURSOR_VALID ){  return SQLITE_ABORT;  }  VVA_ONLY(rc =) saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);  assert( rc==SQLITE_OK );  if( (pCsr->curFlags & BTCF_WriteFlag)==0 ){  return SQLITE_READONLY;  }  assert( (pCsr->pBt->btsFlags & BTS_READ_ONLY)==0  && pCsr->pBt->inTransaction==TRANS_WRITE );  assert( hasSharedCacheTableLock(pCsr->pBtree, pCsr->pgnoRoot, 0, 2) );  assert( !hasReadConflicts(pCsr->pBtree, pCsr->pgnoRoot) );  assert( pCsr->pPage->intKey );  return accessPayload(pCsr, offset, amt, (unsigned char *)z, 1); } SQLITE_PRIVATE void sqlite3BtreeIncrblobCursor(BtCursor *pCur){  pCur->curFlags |= BTCF_Incrblob;  pCur->pBtree->hasIncrblobCur = 1; }
#endif
SQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){  BtShared *pBt = pBtree->pBt;  int rc;  assert( iVersion==1 || iVersion==2 );  pBt->btsFlags &= ~BTS_NO_WAL;  if( iVersion==1 ) pBt->btsFlags |= BTS_NO_WAL;  rc = sqlite3BtreeBeginTrans(pBtree, 0, 0);  if( rc==SQLITE_OK ){  u8 *aData = pBt->pPage1->aData;  if( aData[18]!=(u8)iVersion || aData[19]!=(u8)iVersion ){  rc = sqlite3BtreeBeginTrans(pBtree, 2, 0);  if( rc==SQLITE_OK ){  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);  if( rc==SQLITE_OK ){  aData[18] = (u8)iVersion;  aData[19] = (u8)iVersion;  }  }  }  }  pBt->btsFlags &= ~BTS_NO_WAL;  return rc; } SQLITE_PRIVATE int sqlite3BtreeCursorHasHint(BtCursor *pCsr, unsigned int mask){  return (pCsr->hints & mask)!=0; } SQLITE_PRIVATE int sqlite3BtreeIsReadonly(Btree *p){  return (p->pBt->btsFlags & BTS_READ_ONLY)!=0; } SQLITE_PRIVATE int sqlite3HeaderSizeBtree(void){ return ROUND8(sizeof(MemPage)); }
#if !defined(SQLITE_OMIT_SHARED_CACHE)
SQLITE_PRIVATE int sqlite3BtreeSharable(Btree *p){  return p->sharable; } SQLITE_PRIVATE int sqlite3BtreeConnectionCount(Btree *p){  testcase( p->sharable );  return p->pBt->nRef; }
#endif
struct sqlite3_backup {  sqlite3* pDestDb;  Btree *pDest;  u32 iDestSchema;  int bDestLocked;  Pgno iNext;  sqlite3* pSrcDb;  Btree *pSrc;  int rc;  Pgno nRemaining;  Pgno nPagecount;  int isAttached;  sqlite3_backup *pNext; }; static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){  int i = sqlite3FindDbName(pDb, zDb);  if( i==1 ){  Parse sParse;  int rc = 0;  memset(&sParse, 0, sizeof(sParse));  sParse.db = pDb;  if( sqlite3OpenTempDatabase(&sParse) ){  sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);  rc = SQLITE_ERROR;  }  sqlite3DbFree(pErrorDb, sParse.zErrMsg);  sqlite3ParserReset(&sParse);  if( rc ){  return 0;  }  }  if( i<0 ){  sqlite3ErrorWithMsg(pErrorDb, SQLITE_ERROR, "unknown database %s", zDb);  return 0;  }  return pDb->aDb[i].pBt; } static int setDestPgsz(sqlite3_backup *p){  int rc;  rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),0,0);  return rc; } static int checkReadTransaction(sqlite3 *db, Btree *p){  if( sqlite3BtreeTxnState(p)!=SQLITE_TXN_NONE ){  sqlite3ErrorWithMsg(db, SQLITE_ERROR, "destination database is in use");  return SQLITE_ERROR;  }  return SQLITE_OK; } SQLITE_API sqlite3_backup *sqlite3_backup_init(  sqlite3* pDestDb,  const char *zDestDb,  sqlite3* pSrcDb,  const char *zSrcDb ){  sqlite3_backup *p;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(pSrcDb)||!sqlite3SafetyCheckOk(pDestDb) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(pSrcDb->mutex);  sqlite3_mutex_enter(pDestDb->mutex);  if( pSrcDb==pDestDb ){  sqlite3ErrorWithMsg(  pDestDb, SQLITE_ERROR, "source and destination must be distinct"  );  p = 0;  }else {  p = (sqlite3_backup *)sqlite3MallocZero(sizeof(sqlite3_backup));  if( !p ){  sqlite3Error(pDestDb, SQLITE_NOMEM_BKPT);  }  }  if( p ){  p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);  p->pDest = findBtree(pDestDb, pDestDb, zDestDb);  p->pDestDb = pDestDb;  p->pSrcDb = pSrcDb;  p->iNext = 1;  p->isAttached = 0;  if( 0==p->pSrc || 0==p->pDest   || checkReadTransaction(pDestDb, p->pDest)!=SQLITE_OK   ){  sqlite3_free(p);  p = 0;  }  }  if( p ){  p->pSrc->nBackup++;  }  sqlite3_mutex_leave(pDestDb->mutex);  sqlite3_mutex_leave(pSrcDb->mutex);  return p; } static int isFatalError(int rc){  return (rc!=SQLITE_OK && rc!=SQLITE_BUSY && ALWAYS(rc!=SQLITE_LOCKED)); } static int backupOnePage(  sqlite3_backup *p,  Pgno iSrcPg,  const u8 *zSrcData,  int bUpdate ){  Pager * const pDestPager = sqlite3BtreePager(p->pDest);  const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);  int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);  const int nCopy = MIN(nSrcPgsz, nDestPgsz);  const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;  int rc = SQLITE_OK;  i64 iOff;  assert( sqlite3BtreeGetReserveNoMutex(p->pSrc)>=0 );  assert( p->bDestLocked );  assert( !isFatalError(p->rc) );  assert( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) );  assert( zSrcData );  if( nSrcPgsz!=nDestPgsz && sqlite3PagerIsMemdb(pDestPager) ){  rc = SQLITE_READONLY;  }  for(iOff=iEnd-(i64)nSrcPgsz; rc==SQLITE_OK && iOff<iEnd; iOff+=nDestPgsz){  DbPage *pDestPg = 0;  Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;  if( iDest==PENDING_BYTE_PAGE(p->pDest->pBt) ) continue;  if( SQLITE_OK==(rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0))   && SQLITE_OK==(rc = sqlite3PagerWrite(pDestPg))  ){  const u8 *zIn = &zSrcData[iOff%nSrcPgsz];  u8 *zDestData = sqlite3PagerGetData(pDestPg);  u8 *zOut = &zDestData[iOff%nDestPgsz];  memcpy(zOut, zIn, nCopy);  ((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;  if( iOff==0 && bUpdate==0 ){  sqlite3Put4byte(&zOut[28], sqlite3BtreeLastPage(p->pSrc));  }  }  sqlite3PagerUnref(pDestPg);  }  return rc; } static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){  i64 iCurrent;  int rc = sqlite3OsFileSize(pFile, &iCurrent);  if( rc==SQLITE_OK && iCurrent>iSize ){  rc = sqlite3OsTruncate(pFile, iSize);  }  return rc; } static void attachBackupObject(sqlite3_backup *p){  sqlite3_backup **pp;  assert( sqlite3BtreeHoldsMutex(p->pSrc) );  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));  p->pNext = *pp;  *pp = p;  p->isAttached = 1; } SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage){  int rc;  int destMode;  int pgszSrc = 0;  int pgszDest = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( p==0 ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(p->pSrcDb->mutex);  sqlite3BtreeEnter(p->pSrc);  if( p->pDestDb ){  sqlite3_mutex_enter(p->pDestDb->mutex);  }  rc = p->rc;  if( !isFatalError(rc) ){  Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);  Pager * const pDestPager = sqlite3BtreePager(p->pDest);  int ii;  int nSrcPage = -1;  int bCloseTrans = 0;  if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){  rc = SQLITE_BUSY;  }else{  rc = SQLITE_OK;  }  if( rc==SQLITE_OK && SQLITE_TXN_NONE==sqlite3BtreeTxnState(p->pSrc) ){  rc = sqlite3BtreeBeginTrans(p->pSrc, 0, 0);  bCloseTrans = 1;  }  if( p->bDestLocked==0 && rc==SQLITE_OK && setDestPgsz(p)==SQLITE_NOMEM ){  rc = SQLITE_NOMEM;  }  if( SQLITE_OK==rc && p->bDestLocked==0   && SQLITE_OK==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,  (int*)&p->iDestSchema))  ){  p->bDestLocked = 1;  }  pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);  pgszDest = sqlite3BtreeGetPageSize(p->pDest);  destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));  if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){  rc = SQLITE_READONLY;  }  nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);  assert( nSrcPage>=0 );  for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){  const Pgno iSrcPg = p->iNext;  if( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) ){  DbPage *pSrcPg;  rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg,PAGER_GET_READONLY);  if( rc==SQLITE_OK ){  rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);  sqlite3PagerUnref(pSrcPg);  }  }  p->iNext++;  }  if( rc==SQLITE_OK ){  p->nPagecount = nSrcPage;  p->nRemaining = nSrcPage+1-p->iNext;  if( p->iNext>(Pgno)nSrcPage ){  rc = SQLITE_DONE;  }else if( !p->isAttached ){  attachBackupObject(p);  }  }  if( rc==SQLITE_DONE ){  if( nSrcPage==0 ){  rc = sqlite3BtreeNewDb(p->pDest);  nSrcPage = 1;  }  if( rc==SQLITE_OK || rc==SQLITE_DONE ){  rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1);  }  if( rc==SQLITE_OK ){  if( p->pDestDb ){  sqlite3ResetAllSchemasOfConnection(p->pDestDb);  }  if( destMode==PAGER_JOURNALMODE_WAL ){  rc = sqlite3BtreeSetVersion(p->pDest, 2);  }  }  if( rc==SQLITE_OK ){  int nDestTruncate;  assert( pgszSrc==sqlite3BtreeGetPageSize(p->pSrc) );  assert( pgszDest==sqlite3BtreeGetPageSize(p->pDest) );  if( pgszSrc<pgszDest ){  int ratio = pgszDest/pgszSrc;  nDestTruncate = (nSrcPage+ratio-1)/ratio;  if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){  nDestTruncate--;  }  }else{  nDestTruncate = nSrcPage * (pgszSrc/pgszDest);  }  assert( nDestTruncate>0 );  if( pgszSrc<pgszDest ){  const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;  sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);  Pgno iPg;  int nDstPage;  i64 iOff;  i64 iEnd;  assert( pFile );  assert( nDestTruncate==0  || (i64)nDestTruncate*(i64)pgszDest >= iSize || (  nDestTruncate==(int)(PENDING_BYTE_PAGE(p->pDest->pBt)-1)   && iSize>=PENDING_BYTE && iSize<=PENDING_BYTE+pgszDest  ));  sqlite3PagerPagecount(pDestPager, &nDstPage);  for(iPg=nDestTruncate; rc==SQLITE_OK && iPg<=(Pgno)nDstPage; iPg++){  if( iPg!=PENDING_BYTE_PAGE(p->pDest->pBt) ){  DbPage *pPg;  rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);  if( rc==SQLITE_OK ){  rc = sqlite3PagerWrite(pPg);  sqlite3PagerUnref(pPg);  }  }  }  if( rc==SQLITE_OK ){  rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);  }  iEnd = MIN(PENDING_BYTE + pgszDest, iSize);  for(  iOff=PENDING_BYTE+pgszSrc;  rc==SQLITE_OK && iOff<iEnd;  iOff+=pgszSrc  ){  PgHdr *pSrcPg = 0;  const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);  rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0);  if( rc==SQLITE_OK ){  u8 *zData = sqlite3PagerGetData(pSrcPg);  rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);  }  sqlite3PagerUnref(pSrcPg);  }  if( rc==SQLITE_OK ){  rc = backupTruncateFile(pFile, iSize);  }  if( rc==SQLITE_OK ){  rc = sqlite3PagerSync(pDestPager, 0);  }  }else{  sqlite3PagerTruncateImage(pDestPager, nDestTruncate);  rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);  }  if( SQLITE_OK==rc   && SQLITE_OK==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))  ){  rc = SQLITE_DONE;  }  }  }  if( bCloseTrans ){  TESTONLY( int rc2 );  TESTONLY( rc2 = ) sqlite3BtreeCommitPhaseOne(p->pSrc, 0);  TESTONLY( rc2 |= ) sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);  assert( rc2==SQLITE_OK );  }  if( rc==SQLITE_IOERR_NOMEM ){  rc = SQLITE_NOMEM_BKPT;  }  p->rc = rc;  }  if( p->pDestDb ){  sqlite3_mutex_leave(p->pDestDb->mutex);  }  sqlite3BtreeLeave(p->pSrc);  sqlite3_mutex_leave(p->pSrcDb->mutex);  return rc; } SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p){  sqlite3_backup **pp;  sqlite3 *pSrcDb;  int rc;  if( p==0 ) return SQLITE_OK;  pSrcDb = p->pSrcDb;  sqlite3_mutex_enter(pSrcDb->mutex);  sqlite3BtreeEnter(p->pSrc);  if( p->pDestDb ){  sqlite3_mutex_enter(p->pDestDb->mutex);  }  if( p->pDestDb ){  p->pSrc->nBackup--;  }  if( p->isAttached ){  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));  assert( pp!=0 );  while( *pp!=p ){  pp = &(*pp)->pNext;  assert( pp!=0 );  }  *pp = p->pNext;  }  sqlite3BtreeRollback(p->pDest, SQLITE_OK, 0);  rc = (p->rc==SQLITE_DONE) ? SQLITE_OK : p->rc;  if( p->pDestDb ){  sqlite3Error(p->pDestDb, rc);  sqlite3LeaveMutexAndCloseZombie(p->pDestDb);  }  sqlite3BtreeLeave(p->pSrc);  if( p->pDestDb ){  sqlite3_free(p);  }  sqlite3LeaveMutexAndCloseZombie(pSrcDb);  return rc; } SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( p==0 ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return p->nRemaining; } SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( p==0 ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return p->nPagecount; } static SQLITE_NOINLINE void backupUpdate(  sqlite3_backup *p,  Pgno iPage,  const u8 *aData ){  assert( p!=0 );  do{  assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );  if( !isFatalError(p->rc) && iPage<p->iNext ){  int rc;  assert( p->pDestDb );  sqlite3_mutex_enter(p->pDestDb->mutex);  rc = backupOnePage(p, iPage, aData, 1);  sqlite3_mutex_leave(p->pDestDb->mutex);  assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );  if( rc!=SQLITE_OK ){  p->rc = rc;  }  }  }while( (p = p->pNext)!=0 ); } SQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){  if( pBackup ) backupUpdate(pBackup, iPage, aData); } SQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *pBackup){  sqlite3_backup *p;  for(p=pBackup; p; p=p->pNext){  assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );  p->iNext = 1;  } }
#ifndef SQLITE_OMIT_VACUUM
SQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){  int rc;  sqlite3_file *pFd;  sqlite3_backup b;  sqlite3BtreeEnter(pTo);  sqlite3BtreeEnter(pFrom);  assert( sqlite3BtreeTxnState(pTo)==SQLITE_TXN_WRITE );  pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));  if( pFd->pMethods ){  i64 nByte = sqlite3BtreeGetPageSize(pFrom)*(i64)sqlite3BtreeLastPage(pFrom);  rc = sqlite3OsFileControl(pFd, SQLITE_FCNTL_OVERWRITE, &nByte);  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;  if( rc ) goto copy_finished;  }  memset(&b, 0, sizeof(b));  b.pSrcDb = pFrom->db;  b.pSrc = pFrom;  b.pDest = pTo;  b.iNext = 1;  sqlite3_backup_step(&b, 0x7FFFFFFF);  assert( b.rc!=SQLITE_OK );  rc = sqlite3_backup_finish(&b);  if( rc==SQLITE_OK ){  pTo->pBt->btsFlags &= ~BTS_PAGESIZE_FIXED;  }else{  sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));  }  assert( sqlite3BtreeTxnState(pTo)!=SQLITE_TXN_WRITE ); copy_finished:  sqlite3BtreeLeave(pFrom);  sqlite3BtreeLeave(pTo);  return rc; }
#endif
#define ISPOWEROF2(X) (((X)&((X)-1))==0)
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3VdbeCheckMemInvariants(Mem *p){  assert( (p->flags & MEM_Dyn)==0 || p->xDel!=0 );  assert( (p->flags & MEM_Dyn)==0 || p->szMalloc==0 );  assert( ISPOWEROF2(p->flags & (MEM_Int|MEM_Real|MEM_IntReal)) );  if( p->flags & MEM_Null ){  assert( (p->flags & (MEM_Int|MEM_Real|MEM_Str|MEM_Blob|MEM_Agg))==0 );  if( (p->flags & (MEM_Term|MEM_Subtype))==(MEM_Term|MEM_Subtype) ){  assert( ((p->flags&MEM_Dyn)!=0 ? 1 : 0) +  ((p->flags&MEM_Ephem)!=0 ? 1 : 0) +  ((p->flags&MEM_Static)!=0 ? 1 : 0) <= 1 );  assert( (p->flags & ~(MEM_Null|MEM_Term|MEM_Subtype|MEM_FromBind   |MEM_Dyn|MEM_Ephem|MEM_Static))==0 );  }else{  }  }else{  assert( (p->flags & MEM_Cleared)==0 );  }  assert( p->szMalloc==0   || (p->flags==MEM_Undefined   && p->szMalloc<=sqlite3DbMallocSize(p->db,p->zMalloc))   || p->szMalloc==sqlite3DbMallocSize(p->db,p->zMalloc));  if( (p->flags & (MEM_Str|MEM_Blob)) && p->n>0 ){  assert(  ((p->szMalloc>0 && p->z==p->zMalloc)? 1 : 0) +  ((p->flags&MEM_Dyn)!=0 ? 1 : 0) +  ((p->flags&MEM_Ephem)!=0 ? 1 : 0) +  ((p->flags&MEM_Static)!=0 ? 1 : 0) == 1  );  }  return 1; }
#endif
static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){  StrAccum acc;  assert( p->flags & (MEM_Int|MEM_Real|MEM_IntReal) );  assert( sz>22 );  if( p->flags & MEM_Int ){
#if GCC_VERSION>=7000000
 i64 x;  assert( (p->flags&MEM_Int)*2==sizeof(x) );  memcpy(&x, (char*)&p->u, (p->flags&MEM_Int)*2);  sqlite3Int64ToText(x, zBuf);
#else
 sqlite3Int64ToText(p->u.i, zBuf);
#endif
 }else{  sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);  sqlite3_str_appendf(&acc, "%!.15g",   (p->flags & MEM_IntReal)!=0 ? (double)p->u.i : p->u.r);  assert( acc.zText==zBuf && acc.mxAlloc<=0 );  zBuf[acc.nChar] = 0;  } }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3VdbeMemValidStrRep(Mem *p){  char zBuf[100];  char *z;  int i, j, incr;  if( (p->flags & MEM_Str)==0 ) return 1;  if( p->flags & MEM_Term ){  if( p->szMalloc>0 && p->z==p->zMalloc ){  assert( p->enc==SQLITE_UTF8 || p->szMalloc >= ((p->n+1)&~1)+2 );  assert( p->enc!=SQLITE_UTF8 || p->szMalloc >= p->n+1 );  }  assert( p->z[p->n]==0 );  assert( p->enc==SQLITE_UTF8 || p->z[(p->n+1)&~1]==0 );  assert( p->enc==SQLITE_UTF8 || p->z[((p->n+1)&~1)+1]==0 );  }  if( (p->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 ) return 1;  vdbeMemRenderNum(sizeof(zBuf), zBuf, p);  z = p->z;  i = j = 0;  incr = 1;  if( p->enc!=SQLITE_UTF8 ){  incr = 2;  if( p->enc==SQLITE_UTF16BE ) z++;  }  while( zBuf[j] ){  if( zBuf[j++]!=z[i] ) return 0;  i += incr;  }  return 1; }
#endif
SQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){
#ifndef SQLITE_OMIT_UTF16
 int rc;
#endif
 assert( pMem!=0 );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  assert( desiredEnc==SQLITE_UTF8 || desiredEnc==SQLITE_UTF16LE   || desiredEnc==SQLITE_UTF16BE );  if( !(pMem->flags&MEM_Str) || pMem->enc==desiredEnc ){  return SQLITE_OK;  }  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );
#ifdef SQLITE_OMIT_UTF16
 return SQLITE_ERROR;
#else
 rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);  assert(rc==SQLITE_OK || rc==SQLITE_NOMEM);  assert(rc==SQLITE_OK || pMem->enc!=desiredEnc);  assert(rc==SQLITE_NOMEM || pMem->enc==desiredEnc);  return rc;
#endif
} SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPreserve){  assert( sqlite3VdbeCheckMemInvariants(pMem) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  testcase( pMem->db==0 );  assert( bPreserve==0 || pMem->flags&(MEM_Blob|MEM_Str) );  testcase( bPreserve && pMem->z==0 );  assert( pMem->szMalloc==0   || (pMem->flags==MEM_Undefined   && pMem->szMalloc<=sqlite3DbMallocSize(pMem->db,pMem->zMalloc))   || pMem->szMalloc==sqlite3DbMallocSize(pMem->db,pMem->zMalloc));  if( pMem->szMalloc>0 && bPreserve && pMem->z==pMem->zMalloc ){  if( pMem->db ){  pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);  }else{  pMem->zMalloc = sqlite3Realloc(pMem->z, n);  if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);  pMem->z = pMem->zMalloc;  }  bPreserve = 0;  }else{  if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);  pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);  }  if( pMem->zMalloc==0 ){  sqlite3VdbeMemSetNull(pMem);  pMem->z = 0;  pMem->szMalloc = 0;  return SQLITE_NOMEM_BKPT;  }else{  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);  }  if( bPreserve && pMem->z ){  assert( pMem->z!=pMem->zMalloc );  memcpy(pMem->zMalloc, pMem->z, pMem->n);  }  if( (pMem->flags&MEM_Dyn)!=0 ){  assert( pMem->xDel!=0 && pMem->xDel!=SQLITE_DYNAMIC );  pMem->xDel((void *)(pMem->z));  }  pMem->z = pMem->zMalloc;  pMem->flags &= ~(MEM_Dyn|MEM_Ephem|MEM_Static);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew){  assert( CORRUPT_DB || szNew>0 );  assert( (pMem->flags & MEM_Dyn)==0 || pMem->szMalloc==0 );  if( pMem->szMalloc<szNew ){  return sqlite3VdbeMemGrow(pMem, szNew, 0);  }  assert( (pMem->flags & MEM_Dyn)==0 );  pMem->z = pMem->zMalloc;  pMem->flags &= (MEM_Null|MEM_Int|MEM_Real|MEM_IntReal);  return SQLITE_OK; } static SQLITE_NOINLINE int vdbeMemAddTerminator(Mem *pMem){  if( sqlite3VdbeMemGrow(pMem, pMem->n+3, 1) ){  return SQLITE_NOMEM_BKPT;  }  pMem->z[pMem->n] = 0;  pMem->z[pMem->n+1] = 0;  pMem->z[pMem->n+2] = 0;  pMem->flags |= MEM_Term;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem *pMem){  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  if( (pMem->flags & (MEM_Str|MEM_Blob))!=0 ){  if( ExpandBlob(pMem) ) return SQLITE_NOMEM;  if( pMem->szMalloc==0 || pMem->z!=pMem->zMalloc ){  int rc = vdbeMemAddTerminator(pMem);  if( rc ) return rc;  }  }  pMem->flags &= ~MEM_Ephem;
#ifdef SQLITE_DEBUG
 pMem->pScopyFrom = 0;
#endif
 return SQLITE_OK; }
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE int sqlite3VdbeMemExpandBlob(Mem *pMem){  int nByte;  assert( pMem!=0 );  assert( pMem->flags & MEM_Zero );  assert( (pMem->flags&MEM_Blob)!=0 || MemNullNochng(pMem) );  testcase( sqlite3_value_nochange(pMem) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  nByte = pMem->n + pMem->u.nZero;  if( nByte<=0 ){  if( (pMem->flags & MEM_Blob)==0 ) return SQLITE_OK;  nByte = 1;  }  if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){  return SQLITE_NOMEM_BKPT;  }  assert( pMem->z!=0 );  assert( sqlite3DbMallocSize(pMem->db,pMem->z) >= nByte );  memset(&pMem->z[pMem->n], 0, pMem->u.nZero);  pMem->n += pMem->u.nZero;  pMem->flags &= ~(MEM_Zero|MEM_Term);  return SQLITE_OK; }
#endif
SQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem *pMem){  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  testcase( (pMem->flags & (MEM_Term|MEM_Str))==(MEM_Term|MEM_Str) );  testcase( (pMem->flags & (MEM_Term|MEM_Str))==0 );  if( (pMem->flags & (MEM_Term|MEM_Str))!=MEM_Str ){  return SQLITE_OK;  }else{  return vdbeMemAddTerminator(pMem);  } } SQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){  const int nByte = 32;  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( !(pMem->flags&MEM_Zero) );  assert( !(pMem->flags&(MEM_Str|MEM_Blob)) );  assert( pMem->flags&(MEM_Int|MEM_Real|MEM_IntReal) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  if( sqlite3VdbeMemClearAndResize(pMem, nByte) ){  pMem->enc = 0;  return SQLITE_NOMEM_BKPT;  }  vdbeMemRenderNum(nByte, pMem->z, pMem);  assert( pMem->z!=0 );  pMem->n = sqlite3Strlen30NN(pMem->z);  pMem->enc = SQLITE_UTF8;  pMem->flags |= MEM_Str|MEM_Term;  if( bForce ) pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal);  sqlite3VdbeChangeEncoding(pMem, enc);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){  sqlite3_context ctx;  Mem t;  assert( pFunc!=0 );  assert( pMem!=0 );  assert( pFunc->xFinalize!=0 );  assert( (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  memset(&ctx, 0, sizeof(ctx));  memset(&t, 0, sizeof(t));  t.flags = MEM_Null;  t.db = pMem->db;  ctx.pOut = &t;  ctx.pMem = pMem;  ctx.pFunc = pFunc;  pFunc->xFinalize(&ctx);  assert( (pMem->flags & MEM_Dyn)==0 );  if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);  memcpy(pMem, &t, sizeof(t));  return ctx.isError; }
#ifndef SQLITE_OMIT_WINDOWFUNC
SQLITE_PRIVATE int sqlite3VdbeMemAggValue(Mem *pAccum, Mem *pOut, FuncDef *pFunc){  sqlite3_context ctx;  assert( pFunc!=0 );  assert( pFunc->xValue!=0 );  assert( (pAccum->flags & MEM_Null)!=0 || pFunc==pAccum->u.pDef );  assert( pAccum->db==0 || sqlite3_mutex_held(pAccum->db->mutex) );  memset(&ctx, 0, sizeof(ctx));  sqlite3VdbeMemSetNull(pOut);  ctx.pOut = pOut;  ctx.pMem = pAccum;  ctx.pFunc = pFunc;  pFunc->xValue(&ctx);  return ctx.isError; }
#endif
static SQLITE_NOINLINE void vdbeMemClearExternAndSetNull(Mem *p){  assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) );  assert( VdbeMemDynamic(p) );  if( p->flags&MEM_Agg ){  sqlite3VdbeMemFinalize(p, p->u.pDef);  assert( (p->flags & MEM_Agg)==0 );  testcase( p->flags & MEM_Dyn );  }  if( p->flags&MEM_Dyn ){  assert( p->xDel!=SQLITE_DYNAMIC && p->xDel!=0 );  p->xDel((void *)p->z);  }  p->flags = MEM_Null; } static SQLITE_NOINLINE void vdbeMemClear(Mem *p){  if( VdbeMemDynamic(p) ){  vdbeMemClearExternAndSetNull(p);  }  if( p->szMalloc ){  sqlite3DbFreeNN(p->db, p->zMalloc);  p->szMalloc = 0;  }  p->z = 0; } SQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p){  assert( sqlite3VdbeCheckMemInvariants(p) );  if( VdbeMemDynamic(p) || p->szMalloc ){  vdbeMemClear(p);  } } static SQLITE_NOINLINE i64 doubleToInt64(double r){
#ifdef SQLITE_OMIT_FLOATING_POINT
 return r;
#else
 static const i64 maxInt = LARGEST_INT64;  static const i64 minInt = SMALLEST_INT64;  if( r<=(double)minInt ){  return minInt;  }else if( r>=(double)maxInt ){  return maxInt;  }else{  return (i64)r;  }
#endif
} static SQLITE_NOINLINE i64 memIntValue(Mem *pMem){  i64 value = 0;  sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);  return value; } SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){  int flags;  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  flags = pMem->flags;  if( flags & (MEM_Int|MEM_IntReal) ){  testcase( flags & MEM_IntReal );  return pMem->u.i;  }else if( flags & MEM_Real ){  return doubleToInt64(pMem->u.r);  }else if( (flags & (MEM_Str|MEM_Blob))!=0 && pMem->z!=0 ){  return memIntValue(pMem);  }else{  return 0;  } } static SQLITE_NOINLINE double memRealValue(Mem *pMem){  double val = (double)0;  sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);  return val; } SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem){  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  if( pMem->flags & MEM_Real ){  return pMem->u.r;  }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){  testcase( pMem->flags & MEM_IntReal );  return (double)pMem->u.i;  }else if( pMem->flags & (MEM_Str|MEM_Blob) ){  return memRealValue(pMem);  }else{  return (double)0;  } } SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){  testcase( pMem->flags & MEM_IntReal );  if( pMem->flags & (MEM_Int|MEM_IntReal) ) return pMem->u.i!=0;  if( pMem->flags & MEM_Null ) return ifNull;  return sqlite3VdbeRealValue(pMem)!=0.0; } SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem *pMem){  i64 ix;  assert( pMem!=0 );  assert( pMem->flags & MEM_Real );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  ix = doubleToInt64(pMem->u.r);  if( pMem->u.r==ix && ix>SMALLEST_INT64 && ix<LARGEST_INT64 ){  pMem->u.i = ix;  MemSetTypeFlag(pMem, MEM_Int);  } } SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem *pMem){  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  pMem->u.i = sqlite3VdbeIntValue(pMem);  MemSetTypeFlag(pMem, MEM_Int);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem *pMem){  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  pMem->u.r = sqlite3VdbeRealValue(pMem);  MemSetTypeFlag(pMem, MEM_Real);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){  double r2 = (double)i;  return r1==0.0  || (memcmp(&r1, &r2, sizeof(r1))==0  && i >= -2251799813685248LL && i < 2251799813685248LL); } SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem *pMem){  assert( pMem!=0 );  testcase( pMem->flags & MEM_Int );  testcase( pMem->flags & MEM_Real );  testcase( pMem->flags & MEM_IntReal );  testcase( pMem->flags & MEM_Null );  if( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))==0 ){  int rc;  sqlite3_int64 ix;  assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);  if( ((rc==0 || rc==1) && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1)   || sqlite3RealSameAsInt(pMem->u.r, (ix = (i64)pMem->u.r))  ){  pMem->u.i = ix;  MemSetTypeFlag(pMem, MEM_Int);  }else{  MemSetTypeFlag(pMem, MEM_Real);  }  }  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null))!=0 );  pMem->flags &= ~(MEM_Str|MEM_Blob|MEM_Zero);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemCast(Mem *pMem, u8 aff, u8 encoding){  if( pMem->flags & MEM_Null ) return SQLITE_OK;  switch( aff ){  case SQLITE_AFF_BLOB: {  if( (pMem->flags & MEM_Blob)==0 ){  sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);  assert( pMem->flags & MEM_Str || pMem->db->mallocFailed );  if( pMem->flags & MEM_Str ) MemSetTypeFlag(pMem, MEM_Blob);  }else{  pMem->flags &= ~(MEM_TypeMask&~MEM_Blob);  }  break;  }  case SQLITE_AFF_NUMERIC: {  sqlite3VdbeMemNumerify(pMem);  break;  }  case SQLITE_AFF_INTEGER: {  sqlite3VdbeMemIntegerify(pMem);  break;  }  case SQLITE_AFF_REAL: {  sqlite3VdbeMemRealify(pMem);  break;  }  default: {  assert( aff==SQLITE_AFF_TEXT );  assert( MEM_Str==(MEM_Blob>>3) );  pMem->flags |= (pMem->flags&MEM_Blob)>>3;  sqlite3ValueApplyAffinity(pMem, SQLITE_AFF_TEXT, encoding);  assert( pMem->flags & MEM_Str || pMem->db->mallocFailed );  pMem->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal|MEM_Blob|MEM_Zero);  return sqlite3VdbeChangeEncoding(pMem, encoding);  }  }  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VdbeMemInit(Mem *pMem, sqlite3 *db, u16 flags){  assert( (flags & ~MEM_TypeMask)==0 );  pMem->flags = flags;  pMem->db = db;  pMem->szMalloc = 0; } SQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem *pMem){  if( VdbeMemDynamic(pMem) ){  vdbeMemClearExternAndSetNull(pMem);  }else{  pMem->flags = MEM_Null;  } } SQLITE_PRIVATE void sqlite3ValueSetNull(sqlite3_value *p){  sqlite3VdbeMemSetNull((Mem*)p); }
#ifndef SQLITE_OMIT_INCRBLOB
SQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){  sqlite3VdbeMemRelease(pMem);  pMem->flags = MEM_Blob|MEM_Zero;  pMem->n = 0;  if( n<0 ) n = 0;  pMem->u.nZero = n;  pMem->enc = SQLITE_UTF8;  pMem->z = 0; }
#else
SQLITE_PRIVATE int sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){  int nByte = n>0?n:1;  if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){  return SQLITE_NOMEM_BKPT;  }  assert( pMem->z!=0 );  assert( sqlite3DbMallocSize(pMem->db, pMem->z)>=nByte );  memset(pMem->z, 0, nByte);  pMem->n = n>0?n:0;  pMem->flags = MEM_Blob;  pMem->enc = SQLITE_UTF8;  return SQLITE_OK; }
#endif
static SQLITE_NOINLINE void vdbeReleaseAndSetInt64(Mem *pMem, i64 val){  sqlite3VdbeMemSetNull(pMem);  pMem->u.i = val;  pMem->flags = MEM_Int; } SQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){  if( VdbeMemDynamic(pMem) ){  vdbeReleaseAndSetInt64(pMem, val);  }else{  pMem->u.i = val;  pMem->flags = MEM_Int;  } } SQLITE_PRIVATE void sqlite3NoopDestructor(void *p){ UNUSED_PARAMETER(p); } SQLITE_PRIVATE void sqlite3VdbeMemSetPointer(  Mem *pMem,  void *pPtr,  const char *zPType,  void (*xDestructor)(void*) ){  assert( pMem->flags==MEM_Null );  pMem->u.zPType = zPType ? zPType : "";  pMem->z = pPtr;  pMem->flags = MEM_Null|MEM_Dyn|MEM_Subtype|MEM_Term;  pMem->eSubtype = 'p';  pMem->xDel = xDestructor ? xDestructor : sqlite3NoopDestructor; }
#ifndef SQLITE_OMIT_FLOATING_POINT
SQLITE_PRIVATE void sqlite3VdbeMemSetDouble(Mem *pMem, double val){  sqlite3VdbeMemSetNull(pMem);  if( !sqlite3IsNaN(val) ){  pMem->u.r = val;  pMem->flags = MEM_Real;  } }
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3VdbeMemIsRowSet(const Mem *pMem){  return (pMem->flags&(MEM_Blob|MEM_Dyn))==(MEM_Blob|MEM_Dyn)   && pMem->xDel==sqlite3RowSetDelete; }
#endif
SQLITE_PRIVATE int sqlite3VdbeMemSetRowSet(Mem *pMem){  sqlite3 *db = pMem->db;  RowSet *p;  assert( db!=0 );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  sqlite3VdbeMemRelease(pMem);  p = sqlite3RowSetInit(db);  if( p==0 ) return SQLITE_NOMEM;  pMem->z = (char*)p;  pMem->flags = MEM_Blob|MEM_Dyn;  pMem->xDel = sqlite3RowSetDelete;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem *p){  assert( p->db!=0 );  if( p->flags & (MEM_Str|MEM_Blob) ){  int n = p->n;  if( p->flags & MEM_Zero ){  n += p->u.nZero;  }  return n>p->db->aLimit[SQLITE_LIMIT_LENGTH];  }  return 0; }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeMemAboutToChange(Vdbe *pVdbe, Mem *pMem){  int i;  Mem *pX;  for(i=1, pX=pVdbe->aMem+1; i<pVdbe->nMem; i++, pX++){  if( pX->pScopyFrom==pMem ){  u16 mFlags;  if( pVdbe->db->flags & SQLITE_VdbeTrace ){  sqlite3DebugPrintf("Invalidate R[%d] due to change in R[%d]\n",  (int)(pX - pVdbe->aMem), (int)(pMem - pVdbe->aMem));  }  mFlags = pMem->flags & pX->flags & pX->mScopyFlags;  assert( (mFlags&(MEM_Int|MEM_IntReal))==0 || pMem->u.i==pX->u.i );  pX->flags = MEM_Undefined;  pX->pScopyFrom = 0;  }  }  pMem->pScopyFrom = 0; }
#endif
static SQLITE_NOINLINE void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType){  vdbeMemClearExternAndSetNull(pTo);  assert( !VdbeMemDynamic(pTo) );  sqlite3VdbeMemShallowCopy(pTo, pFrom, eType); } SQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){  assert( !sqlite3VdbeMemIsRowSet(pFrom) );  assert( pTo->db==pFrom->db );  if( VdbeMemDynamic(pTo) ){ vdbeClrCopy(pTo,pFrom,srcType); return; }  memcpy(pTo, pFrom, MEMCELLSIZE);  if( (pFrom->flags&MEM_Static)==0 ){  pTo->flags &= ~(MEM_Dyn|MEM_Static|MEM_Ephem);  assert( srcType==MEM_Ephem || srcType==MEM_Static );  pTo->flags |= srcType;  } } SQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){  int rc = SQLITE_OK;  assert( !sqlite3VdbeMemIsRowSet(pFrom) );  if( VdbeMemDynamic(pTo) ) vdbeMemClearExternAndSetNull(pTo);  memcpy(pTo, pFrom, MEMCELLSIZE);  pTo->flags &= ~MEM_Dyn;  if( pTo->flags&(MEM_Str|MEM_Blob) ){  if( 0==(pFrom->flags&MEM_Static) ){  pTo->flags |= MEM_Ephem;  rc = sqlite3VdbeMemMakeWriteable(pTo);  }  }  return rc; } SQLITE_PRIVATE void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){  assert( pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) );  assert( pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) );  assert( pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db );  sqlite3VdbeMemRelease(pTo);  memcpy(pTo, pFrom, sizeof(Mem));  pFrom->flags = MEM_Null;  pFrom->szMalloc = 0; } SQLITE_PRIVATE int sqlite3VdbeMemSetStr(  Mem *pMem,  const char *z,  i64 n,  u8 enc,  void (*xDel)(void*) ){  i64 nByte = n;  int iLimit;  u16 flags = 0;  assert( pMem!=0 );  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  if( !z ){  sqlite3VdbeMemSetNull(pMem);  return SQLITE_OK;  }  if( pMem->db ){  iLimit = pMem->db->aLimit[SQLITE_LIMIT_LENGTH];  }else{  iLimit = SQLITE_MAX_LENGTH;  }  flags = (enc==0?MEM_Blob:MEM_Str);  if( nByte<0 ){  assert( enc!=0 );  if( enc==SQLITE_UTF8 ){  nByte = strlen(z);  }else{  for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){}  }  flags |= MEM_Term;  }  if( xDel==SQLITE_TRANSIENT ){  i64 nAlloc = nByte;  if( flags&MEM_Term ){  nAlloc += (enc==SQLITE_UTF8?1:2);  }  if( nByte>iLimit ){  return sqlite3ErrorToParser(pMem->db, SQLITE_TOOBIG);  }  testcase( nAlloc==0 );  testcase( nAlloc==31 );  testcase( nAlloc==32 );  if( sqlite3VdbeMemClearAndResize(pMem, (int)MAX(nAlloc,32)) ){  return SQLITE_NOMEM_BKPT;  }  memcpy(pMem->z, z, nAlloc);  }else{  sqlite3VdbeMemRelease(pMem);  pMem->z = (char *)z;  if( xDel==SQLITE_DYNAMIC ){  pMem->zMalloc = pMem->z;  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);  }else{  pMem->xDel = xDel;  flags |= ((xDel==SQLITE_STATIC)?MEM_Static:MEM_Dyn);  }  }  pMem->n = (int)(nByte & 0x7fffffff);  pMem->flags = flags;  if( enc ){  pMem->enc = enc;
#ifdef SQLITE_ENABLE_SESSION
 }else if( pMem->db==0 ){  pMem->enc = SQLITE_UTF8;
#endif
 }else{  assert( pMem->db!=0 );  pMem->enc = ENC(pMem->db);  }
#ifndef SQLITE_OMIT_UTF16
 if( enc>SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem) ){  return SQLITE_NOMEM_BKPT;  }
#endif
 if( nByte>iLimit ){  return sqlite3ErrorToParser(pMem->db, SQLITE_TOOBIG);  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeMemFromBtree(  BtCursor *pCur,  u32 offset,  u32 amt,  Mem *pMem ){  int rc;  pMem->flags = MEM_Null;  if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){  return SQLITE_CORRUPT_BKPT;  }  if( SQLITE_OK==(rc = sqlite3VdbeMemClearAndResize(pMem, amt+1)) ){  rc = sqlite3BtreePayload(pCur, offset, amt, pMem->z);  if( rc==SQLITE_OK ){  pMem->z[amt] = 0;  pMem->flags = MEM_Blob;  pMem->n = (int)amt;  }else{  sqlite3VdbeMemRelease(pMem);  }  }  return rc; } SQLITE_PRIVATE int sqlite3VdbeMemFromBtreeZeroOffset(  BtCursor *pCur,  u32 amt,  Mem *pMem ){  u32 available = 0;  int rc = SQLITE_OK;  assert( sqlite3BtreeCursorIsValid(pCur) );  assert( !VdbeMemDynamic(pMem) );  assert( !sqlite3VdbeMemIsRowSet(pMem) );  pMem->z = (char *)sqlite3BtreePayloadFetch(pCur, &available);  assert( pMem->z!=0 );  if( amt<=available ){  pMem->flags = MEM_Blob|MEM_Ephem;  pMem->n = (int)amt;  }else{  rc = sqlite3VdbeMemFromBtree(pCur, 0, amt, pMem);  }  return rc; } static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc){  assert( pVal!=0 );  assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );  assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );  assert( !sqlite3VdbeMemIsRowSet(pVal) );  assert( (pVal->flags & (MEM_Null))==0 );  if( pVal->flags & (MEM_Blob|MEM_Str) ){  if( ExpandBlob(pVal) ) return 0;  pVal->flags |= MEM_Str;  if( pVal->enc != (enc & ~SQLITE_UTF16_ALIGNED) ){  sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);  }  if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){  assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );  if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){  return 0;  }  }  sqlite3VdbeMemNulTerminate(pVal);  }else{  sqlite3VdbeMemStringify(pVal, enc, 0);  assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );  }  assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0  || pVal->db->mallocFailed );  if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){  assert( sqlite3VdbeMemValidStrRep(pVal) );  return pVal->z;  }else{  return 0;  } } SQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){  if( !pVal ) return 0;  assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );  assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );  assert( !sqlite3VdbeMemIsRowSet(pVal) );  if( (pVal->flags&(MEM_Str|MEM_Term))==(MEM_Str|MEM_Term) && pVal->enc==enc ){  assert( sqlite3VdbeMemValidStrRep(pVal) );  return pVal->z;  }  if( pVal->flags&MEM_Null ){  return 0;  }  return valueToText(pVal, enc); } SQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *db){  Mem *p = sqlite3DbMallocZero(db, sizeof(*p));  if( p ){  p->flags = MEM_Null;  p->db = db;  }  return p; } struct ValueNewStat4Ctx {  Parse *pParse;  Index *pIdx;  UnpackedRecord **ppRec;  int iVal; }; static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
#ifdef SQLITE_ENABLE_STAT4
 if( p ){  UnpackedRecord *pRec = p->ppRec[0];  if( pRec==0 ){  Index *pIdx = p->pIdx;  int nByte;  int i;  int nCol = pIdx->nColumn;  nByte = sizeof(Mem) * nCol + ROUND8(sizeof(UnpackedRecord));  pRec = (UnpackedRecord*)sqlite3DbMallocZero(db, nByte);  if( pRec ){  pRec->pKeyInfo = sqlite3KeyInfoOfIndex(p->pParse, pIdx);  if( pRec->pKeyInfo ){  assert( pRec->pKeyInfo->nAllField==nCol );  assert( pRec->pKeyInfo->enc==ENC(db) );  pRec->aMem = (Mem *)((u8*)pRec + ROUND8(sizeof(UnpackedRecord)));  for(i=0; i<nCol; i++){  pRec->aMem[i].flags = MEM_Null;  pRec->aMem[i].db = db;  }  }else{  sqlite3DbFreeNN(db, pRec);  pRec = 0;  }  }  if( pRec==0 ) return 0;  p->ppRec[0] = pRec;  }  pRec->nField = p->iVal+1;  return &pRec->aMem[p->iVal];  }
#else
 UNUSED_PARAMETER(p);
#endif
 return sqlite3ValueNew(db); }
#ifdef SQLITE_ENABLE_STAT4
static int valueFromFunction(  sqlite3 *db,  const Expr *p,  u8 enc,  u8 aff,  sqlite3_value **ppVal,  struct ValueNewStat4Ctx *pCtx ){  sqlite3_context ctx;  sqlite3_value **apVal = 0;  int nVal = 0;  FuncDef *pFunc = 0;  sqlite3_value *pVal = 0;  int rc = SQLITE_OK;  ExprList *pList = 0;  int i;  assert( pCtx!=0 );  assert( (p->flags & EP_TokenOnly)==0 );  assert( ExprUseXList(p) );  pList = p->x.pList;  if( pList ) nVal = pList->nExpr;  assert( !ExprHasProperty(p, EP_IntValue) );  pFunc = sqlite3FindFunction(db, p->u.zToken, nVal, enc, 0);  assert( pFunc );  if( (pFunc->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG))==0   || (pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)  ){  return SQLITE_OK;  }  if( pList ){  apVal = (sqlite3_value**)sqlite3DbMallocZero(db, sizeof(apVal[0]) * nVal);  if( apVal==0 ){  rc = SQLITE_NOMEM_BKPT;  goto value_from_function_out;  }  for(i=0; i<nVal; i++){  rc = sqlite3ValueFromExpr(db, pList->a[i].pExpr, enc, aff, &apVal[i]);  if( apVal[i]==0 || rc!=SQLITE_OK ) goto value_from_function_out;  }  }  pVal = valueNew(db, pCtx);  if( pVal==0 ){  rc = SQLITE_NOMEM_BKPT;  goto value_from_function_out;  }  assert( pCtx->pParse->rc==SQLITE_OK );  memset(&ctx, 0, sizeof(ctx));  ctx.pOut = pVal;  ctx.pFunc = pFunc;  pFunc->xSFunc(&ctx, nVal, apVal);  if( ctx.isError ){  rc = ctx.isError;  sqlite3ErrorMsg(pCtx->pParse, "%s", sqlite3_value_text(pVal));  }else{  sqlite3ValueApplyAffinity(pVal, aff, SQLITE_UTF8);  assert( rc==SQLITE_OK );  rc = sqlite3VdbeChangeEncoding(pVal, enc);  if( rc==SQLITE_OK && sqlite3VdbeMemTooBig(pVal) ){  rc = SQLITE_TOOBIG;  pCtx->pParse->nErr++;  }  }  pCtx->pParse->rc = rc;  value_from_function_out:  if( rc!=SQLITE_OK ){  pVal = 0;  }  if( apVal ){  for(i=0; i<nVal; i++){  sqlite3ValueFree(apVal[i]);  }  sqlite3DbFreeNN(db, apVal);  }  *ppVal = pVal;  return rc; }
#else
# define valueFromFunction(a,b,c,d,e,f) SQLITE_OK
#endif
static int valueFromExpr(  sqlite3 *db,  const Expr *pExpr,  u8 enc,  u8 affinity,  sqlite3_value **ppVal,  struct ValueNewStat4Ctx *pCtx ){  int op;  char *zVal = 0;  sqlite3_value *pVal = 0;  int negInt = 1;  const char *zNeg = "";  int rc = SQLITE_OK;  assert( pExpr!=0 );  while( (op = pExpr->op)==TK_UPLUS || op==TK_SPAN ) pExpr = pExpr->pLeft;
#if defined(SQLITE_ENABLE_STAT4)
 if( op==TK_REGISTER ) op = pExpr->op2;
#else
 if( NEVER(op==TK_REGISTER) ) op = pExpr->op2;
#endif
 assert( (pExpr->flags & EP_TokenOnly)==0 || pCtx==0 );  if( op==TK_CAST ){  u8 aff;  assert( !ExprHasProperty(pExpr, EP_IntValue) );  aff = sqlite3AffinityType(pExpr->u.zToken,0);  rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);  testcase( rc!=SQLITE_OK );  if( *ppVal ){  sqlite3VdbeMemCast(*ppVal, aff, SQLITE_UTF8);  sqlite3ValueApplyAffinity(*ppVal, affinity, SQLITE_UTF8);  }  return rc;  }  if( op==TK_UMINUS   && (pExpr->pLeft->op==TK_INTEGER || pExpr->pLeft->op==TK_FLOAT) ){  pExpr = pExpr->pLeft;  op = pExpr->op;  negInt = -1;  zNeg = "-";  }  if( op==TK_STRING || op==TK_FLOAT || op==TK_INTEGER ){  pVal = valueNew(db, pCtx);  if( pVal==0 ) goto no_mem;  if( ExprHasProperty(pExpr, EP_IntValue) ){  sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);  }else{  zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);  if( zVal==0 ) goto no_mem;  sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);  }  if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_BLOB ){  sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);  }else{  sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);  }  assert( (pVal->flags & MEM_IntReal)==0 );  if( pVal->flags & (MEM_Int|MEM_IntReal|MEM_Real) ){  testcase( pVal->flags & MEM_Int );  testcase( pVal->flags & MEM_Real );  pVal->flags &= ~MEM_Str;  }  if( enc!=SQLITE_UTF8 ){  rc = sqlite3VdbeChangeEncoding(pVal, enc);  }  }else if( op==TK_UMINUS ) {  if( SQLITE_OK==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx)   && pVal!=0  ){  sqlite3VdbeMemNumerify(pVal);  if( pVal->flags & MEM_Real ){  pVal->u.r = -pVal->u.r;  }else if( pVal->u.i==SMALLEST_INT64 ){
#ifndef SQLITE_OMIT_FLOATING_POINT
 pVal->u.r = -(double)SMALLEST_INT64;
#else
 pVal->u.r = LARGEST_INT64;
#endif
 MemSetTypeFlag(pVal, MEM_Real);  }else{  pVal->u.i = -pVal->u.i;  }  sqlite3ValueApplyAffinity(pVal, affinity, enc);  }  }else if( op==TK_NULL ){  pVal = valueNew(db, pCtx);  if( pVal==0 ) goto no_mem;  sqlite3VdbeMemSetNull(pVal);  }
#ifndef SQLITE_OMIT_BLOB_LITERAL
 else if( op==TK_BLOB ){  int nVal;  assert( !ExprHasProperty(pExpr, EP_IntValue) );  assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );  assert( pExpr->u.zToken[1]=='\'' );  pVal = valueNew(db, pCtx);  if( !pVal ) goto no_mem;  zVal = &pExpr->u.zToken[2];  nVal = sqlite3Strlen30(zVal)-1;  assert( zVal[nVal]=='\'' );  sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,   0, SQLITE_DYNAMIC);  }
#endif
#ifdef SQLITE_ENABLE_STAT4
 else if( op==TK_FUNCTION && pCtx!=0 ){  rc = valueFromFunction(db, pExpr, enc, affinity, &pVal, pCtx);  }
#endif
 else if( op==TK_TRUEFALSE ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  pVal = valueNew(db, pCtx);  if( pVal ){  pVal->flags = MEM_Int;  pVal->u.i = pExpr->u.zToken[4]==0;  }  }  *ppVal = pVal;  return rc;
no_mem:
#ifdef SQLITE_ENABLE_STAT4
 if( pCtx==0 || pCtx->pParse->nErr==0 )
#endif
 sqlite3OomFault(db);  sqlite3DbFree(db, zVal);  assert( *ppVal==0 );
#ifdef SQLITE_ENABLE_STAT4
 if( pCtx==0 ) sqlite3ValueFree(pVal);
#else
 assert( pCtx==0 ); sqlite3ValueFree(pVal);
#endif
 return SQLITE_NOMEM_BKPT; } SQLITE_PRIVATE int sqlite3ValueFromExpr(  sqlite3 *db,  const Expr *pExpr,  u8 enc,  u8 affinity,  sqlite3_value **ppVal ){  return pExpr ? valueFromExpr(db, pExpr, enc, affinity, ppVal, 0) : 0; }
#ifdef SQLITE_ENABLE_STAT4
static int stat4ValueFromExpr(  Parse *pParse,  Expr *pExpr,  u8 affinity,  struct ValueNewStat4Ctx *pAlloc,  sqlite3_value **ppVal ){  int rc = SQLITE_OK;  sqlite3_value *pVal = 0;  sqlite3 *db = pParse->db;  pExpr = sqlite3ExprSkipCollate(pExpr);  assert( pExpr==0 || pExpr->op!=TK_REGISTER || pExpr->op2!=TK_VARIABLE );  if( !pExpr ){  pVal = valueNew(db, pAlloc);  if( pVal ){  sqlite3VdbeMemSetNull((Mem*)pVal);  }  }else if( pExpr->op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){  Vdbe *v;  int iBindVar = pExpr->iColumn;  sqlite3VdbeSetVarmask(pParse->pVdbe, iBindVar);  if( (v = pParse->pReprepare)!=0 ){  pVal = valueNew(db, pAlloc);  if( pVal ){  rc = sqlite3VdbeMemCopy((Mem*)pVal, &v->aVar[iBindVar-1]);  sqlite3ValueApplyAffinity(pVal, affinity, ENC(db));  pVal->db = pParse->db;  }  }  }else{  rc = valueFromExpr(db, pExpr, ENC(db), affinity, &pVal, pAlloc);  }  assert( pVal==0 || pVal->db==db );  *ppVal = pVal;  return rc; } SQLITE_PRIVATE int sqlite3Stat4ProbeSetValue(  Parse *pParse,  Index *pIdx,  UnpackedRecord **ppRec,  Expr *pExpr,  int nElem,  int iVal,  int *pnExtract ){  int rc = SQLITE_OK;  int nExtract = 0;  if( pExpr==0 || pExpr->op!=TK_SELECT ){  int i;  struct ValueNewStat4Ctx alloc;  alloc.pParse = pParse;  alloc.pIdx = pIdx;  alloc.ppRec = ppRec;  for(i=0; i<nElem; i++){  sqlite3_value *pVal = 0;  Expr *pElem = (pExpr ? sqlite3VectorFieldSubexpr(pExpr, i) : 0);  u8 aff = sqlite3IndexColumnAffinity(pParse->db, pIdx, iVal+i);  alloc.iVal = iVal+i;  rc = stat4ValueFromExpr(pParse, pElem, aff, &alloc, &pVal);  if( !pVal ) break;  nExtract++;  }  }  *pnExtract = nExtract;  return rc; } SQLITE_PRIVATE int sqlite3Stat4ValueFromExpr(  Parse *pParse,  Expr *pExpr,  u8 affinity,  sqlite3_value **ppVal ){  return stat4ValueFromExpr(pParse, pExpr, affinity, 0, ppVal); } SQLITE_PRIVATE int sqlite3Stat4Column(  sqlite3 *db,  const void *pRec,  int nRec,  int iCol,  sqlite3_value **ppVal ){  u32 t = 0;  int nHdr;  int iHdr;  int iField;  int szField = 0;  int i;  u8 *a = (u8*)pRec;  Mem *pMem = *ppVal;  assert( iCol>0 );  iHdr = getVarint32(a, nHdr);  if( nHdr>nRec || iHdr>=nHdr ) return SQLITE_CORRUPT_BKPT;  iField = nHdr;  for(i=0; i<=iCol; i++){  iHdr += getVarint32(&a[iHdr], t);  testcase( iHdr==nHdr );  testcase( iHdr==nHdr+1 );  if( iHdr>nHdr ) return SQLITE_CORRUPT_BKPT;  szField = sqlite3VdbeSerialTypeLen(t);  iField += szField;  }  testcase( iField==nRec );  testcase( iField==nRec+1 );  if( iField>nRec ) return SQLITE_CORRUPT_BKPT;  if( pMem==0 ){  pMem = *ppVal = sqlite3ValueNew(db);  if( pMem==0 ) return SQLITE_NOMEM_BKPT;  }  sqlite3VdbeSerialGet(&a[iField-szField], t, pMem);  pMem->enc = ENC(db);  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3Stat4ProbeFree(UnpackedRecord *pRec){  if( pRec ){  int i;  int nCol = pRec->pKeyInfo->nAllField;  Mem *aMem = pRec->aMem;  sqlite3 *db = aMem[0].db;  for(i=0; i<nCol; i++){  sqlite3VdbeMemRelease(&aMem[i]);  }  sqlite3KeyInfoUnref(pRec->pKeyInfo);  sqlite3DbFreeNN(db, pRec);  } }
#endif
SQLITE_PRIVATE void sqlite3ValueSetStr(  sqlite3_value *v,  int n,  const void *z,  u8 enc,  void (*xDel)(void*) ){  if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel); } SQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value *v){  if( !v ) return;  sqlite3VdbeMemRelease((Mem *)v);  sqlite3DbFreeNN(((Mem*)v)->db, v); } static SQLITE_NOINLINE int valueBytes(sqlite3_value *pVal, u8 enc){  return valueToText(pVal, enc)!=0 ? pVal->n : 0; } SQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){  Mem *p = (Mem*)pVal;  assert( (p->flags & MEM_Null)==0 || (p->flags & (MEM_Str|MEM_Blob))==0 );  if( (p->flags & MEM_Str)!=0 && pVal->enc==enc ){  return p->n;  }  if( (p->flags & MEM_Blob)!=0 ){  if( p->flags & MEM_Zero ){  return p->n + p->u.nZero;  }else{  return p->n;  }  }  if( p->flags & MEM_Null ) return 0;  return valueBytes(pVal, enc); } static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef); static void vdbeFreeOpArray(sqlite3 *, Op *, int); SQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(Parse *pParse){  sqlite3 *db = pParse->db;  Vdbe *p;  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );  if( p==0 ) return 0;  memset(&p->aOp, 0, sizeof(Vdbe)-offsetof(Vdbe,aOp));  p->db = db;  if( db->pVdbe ){  db->pVdbe->pPrev = p;  }  p->pNext = db->pVdbe;  p->pPrev = 0;  db->pVdbe = p;  p->iVdbeMagic = VDBE_MAGIC_INIT;  p->pParse = pParse;  pParse->pVdbe = p;  assert( pParse->aLabel==0 );  assert( pParse->nLabel==0 );  assert( p->nOpAlloc==0 );  assert( pParse->szOpAlloc==0 );  sqlite3VdbeAddOp2(p, OP_Init, 0, 1);  return p; } SQLITE_PRIVATE Parse *sqlite3VdbeParser(Vdbe *p){  return p->pParse; } SQLITE_PRIVATE void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){  va_list ap;  sqlite3DbFree(p->db, p->zErrMsg);  va_start(ap, zFormat);  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);  va_end(ap); } SQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){  if( p==0 ) return;  p->prepFlags = prepFlags;  if( (prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){  p->expmask = 0;  }  assert( p->zSql==0 );  p->zSql = sqlite3DbStrNDup(p->db, z, n); }
#ifdef SQLITE_ENABLE_NORMALIZE
SQLITE_PRIVATE void sqlite3VdbeAddDblquoteStr(sqlite3 *db, Vdbe *p, const char *z){  if( p ){  int n = sqlite3Strlen30(z);  DblquoteStr *pStr = sqlite3DbMallocRawNN(db,  sizeof(*pStr)+n+1-sizeof(pStr->z));  if( pStr ){  pStr->pNextStr = p->pDblStr;  p->pDblStr = pStr;  memcpy(pStr->z, z, n+1);  }  } }
#endif
#ifdef SQLITE_ENABLE_NORMALIZE
SQLITE_PRIVATE int sqlite3VdbeUsesDoubleQuotedString(  Vdbe *pVdbe,  const char *zId ){  DblquoteStr *pStr;  assert( zId!=0 );  if( pVdbe->pDblStr==0 ) return 0;  for(pStr=pVdbe->pDblStr; pStr; pStr=pStr->pNextStr){  if( strcmp(zId, pStr->z)==0 ) return 1;  }  return 0; }
#endif
SQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){  Vdbe tmp, *pTmp;  char *zTmp;  assert( pA->db==pB->db );  tmp = *pA;  *pA = *pB;  *pB = tmp;  pTmp = pA->pNext;  pA->pNext = pB->pNext;  pB->pNext = pTmp;  pTmp = pA->pPrev;  pA->pPrev = pB->pPrev;  pB->pPrev = pTmp;  zTmp = pA->zSql;  pA->zSql = pB->zSql;  pB->zSql = zTmp;
#ifdef SQLITE_ENABLE_NORMALIZE
 zTmp = pA->zNormSql;  pA->zNormSql = pB->zNormSql;  pB->zNormSql = zTmp;
#endif
 pB->expmask = pA->expmask;  pB->prepFlags = pA->prepFlags;  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));  pB->aCounter[SQLITE_STMTSTATUS_REPREPARE]++; } static int growOpArray(Vdbe *v, int nOp){  VdbeOp *pNew;  Parse *p = v->pParse;
#ifdef SQLITE_TEST_REALLOC_STRESS
 sqlite3_int64 nNew = (v->nOpAlloc>=512 ? 2*(sqlite3_int64)v->nOpAlloc  : (sqlite3_int64)v->nOpAlloc+nOp);
#else
 sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc  : (sqlite3_int64)(1024/sizeof(Op)));  UNUSED_PARAMETER(nOp);
#endif
 if( nNew > p->db->aLimit[SQLITE_LIMIT_VDBE_OP] ){  sqlite3OomFault(p->db);  return SQLITE_NOMEM;  }  assert( nOp<=(1024/sizeof(Op)) );  assert( nNew>=(v->nOpAlloc+nOp) );  pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));  if( pNew ){  p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);  v->nOpAlloc = p->szOpAlloc/sizeof(Op);  v->aOp = pNew;  }  return (pNew ? SQLITE_OK : SQLITE_NOMEM_BKPT); }
#ifdef SQLITE_DEBUG
static void test_addop_breakpoint(int pc, Op *pOp){  static int n = 0;  n++; }
#endif
static SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){  assert( p->nOpAlloc<=p->nOp );  if( growOpArray(p, 1) ) return 1;  assert( p->nOpAlloc>p->nOp );  return sqlite3VdbeAddOp3(p, op, p1, p2, p3); } SQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){  int i;  VdbeOp *pOp;  i = p->nOp;  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );  assert( op>=0 && op<0xff );  if( p->nOpAlloc<=i ){  return growOp3(p, op, p1, p2, p3);  }  assert( p->aOp!=0 );  p->nOp++;  pOp = &p->aOp[i];  assert( pOp!=0 );  pOp->opcode = (u8)op;  pOp->p5 = 0;  pOp->p1 = p1;  pOp->p2 = p2;  pOp->p3 = p3;  pOp->p4.p = 0;  pOp->p4type = P4_NOTUSED;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 pOp->zComment = 0;
#endif
#ifdef SQLITE_DEBUG
 if( p->db->flags & SQLITE_VdbeAddopTrace ){  sqlite3VdbePrintOp(0, i, &p->aOp[i]);  test_addop_breakpoint(i, &p->aOp[i]);  }
#endif
#ifdef VDBE_PROFILE
 pOp->cycles = 0;  pOp->cnt = 0;
#endif
#ifdef SQLITE_VDBE_COVERAGE
 pOp->iSrcLine = 0;
#endif
 return i; } SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe *p, int op){  return sqlite3VdbeAddOp3(p, op, 0, 0, 0); } SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){  return sqlite3VdbeAddOp3(p, op, p1, 0, 0); } SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){  return sqlite3VdbeAddOp3(p, op, p1, p2, 0); } SQLITE_PRIVATE int sqlite3VdbeGoto(Vdbe *p, int iDest){  return sqlite3VdbeAddOp3(p, OP_Goto, 0, iDest, 0); } SQLITE_PRIVATE int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){  return sqlite3VdbeAddOp4(p, OP_String8, 0, iDest, 0, zStr, 0); } SQLITE_PRIVATE void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){  va_list ap;  int i;  char c;  va_start(ap, zTypes);  for(i=0; (c = zTypes[i])!=0; i++){  if( c=='s' ){  const char *z = va_arg(ap, const char*);  sqlite3VdbeAddOp4(p, z==0 ? OP_Null : OP_String8, 0, iDest+i, 0, z, 0);  }else if( c=='i' ){  sqlite3VdbeAddOp2(p, OP_Integer, va_arg(ap, int), iDest+i);  }else{  goto skip_op_resultrow;  }  }  sqlite3VdbeAddOp2(p, OP_ResultRow, iDest, i); skip_op_resultrow:  va_end(ap); } SQLITE_PRIVATE int sqlite3VdbeAddOp4(  Vdbe *p,  int op,  int p1,  int p2,  int p3,  const char *zP4,  int p4type ){  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);  sqlite3VdbeChangeP4(p, addr, zP4, p4type);  return addr; } SQLITE_PRIVATE int sqlite3VdbeAddFunctionCall(  Parse *pParse,  int p1,  int p2,  int p3,  int nArg,  const FuncDef *pFunc,  int eCallCtx ){  Vdbe *v = pParse->pVdbe;  int nByte;  int addr;  sqlite3_context *pCtx;  assert( v );  nByte = sizeof(*pCtx) + (nArg-1)*sizeof(sqlite3_value*);  pCtx = sqlite3DbMallocRawNN(pParse->db, nByte);  if( pCtx==0 ){  assert( pParse->db->mallocFailed );  freeEphemeralFunction(pParse->db, (FuncDef*)pFunc);  return 0;  }  pCtx->pOut = 0;  pCtx->pFunc = (FuncDef*)pFunc;  pCtx->pVdbe = 0;  pCtx->isError = 0;  pCtx->argc = nArg;  pCtx->iOp = sqlite3VdbeCurrentAddr(v);  addr = sqlite3VdbeAddOp4(v, eCallCtx ? OP_PureFunc : OP_Function,   p1, p2, p3, (char*)pCtx, P4_FUNCCTX);  sqlite3VdbeChangeP5(v, eCallCtx & NC_SelfRef);  return addr; } SQLITE_PRIVATE int sqlite3VdbeAddOp4Dup8(  Vdbe *p,  int op,  int p1,  int p2,  int p3,  const u8 *zP4,  int p4type ){  char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);  if( p4copy ) memcpy(p4copy, zP4, 8);  return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type); }
#ifndef SQLITE_OMIT_EXPLAIN
SQLITE_PRIVATE int sqlite3VdbeExplainParent(Parse *pParse){  VdbeOp *pOp;  if( pParse->addrExplain==0 ) return 0;  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);  return pOp->p2; }
#if defined(SQLITE_DEBUG)
SQLITE_PRIVATE void sqlite3ExplainBreakpoint(const char *z1, const char *z2){  (void)z1;  (void)z2; }
#endif
SQLITE_PRIVATE void sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){
#ifndef SQLITE_DEBUG
 if( pParse->explain==2 )
#endif
 {  char *zMsg;  Vdbe *v;  va_list ap;  int iThis;  va_start(ap, zFmt);  zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);  va_end(ap);  v = pParse->pVdbe;  iThis = v->nOp;  sqlite3VdbeAddOp4(v, OP_Explain, iThis, pParse->addrExplain, 0,  zMsg, P4_DYNAMIC);  sqlite3ExplainBreakpoint(bPush?"PUSH":"", sqlite3VdbeGetOp(v,-1)->p4.z);  if( bPush){  pParse->addrExplain = iThis;  }  } } SQLITE_PRIVATE void sqlite3VdbeExplainPop(Parse *pParse){  sqlite3ExplainBreakpoint("POP", 0);  pParse->addrExplain = sqlite3VdbeExplainParent(pParse); }
#endif
SQLITE_PRIVATE void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere, u16 p5){  int j;  sqlite3VdbeAddOp4(p, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);  sqlite3VdbeChangeP5(p, p5);  for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);  sqlite3MayAbort(p->pParse); } SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(  Vdbe *p,  int op,  int p1,  int p2,  int p3,  int p4 ){  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);  if( p->db->mallocFailed==0 ){  VdbeOp *pOp = &p->aOp[addr];  pOp->p4type = P4_INT32;  pOp->p4.i = p4;  }  return addr; } SQLITE_PRIVATE void sqlite3VdbeEndCoroutine(Vdbe *v, int regYield){  sqlite3VdbeAddOp1(v, OP_EndCoroutine, regYield);  v->pParse->nTempReg = 0;  v->pParse->nRangeReg = 0; } SQLITE_PRIVATE int sqlite3VdbeMakeLabel(Parse *pParse){  return --pParse->nLabel; } static SQLITE_NOINLINE void resizeResolveLabel(Parse *p, Vdbe *v, int j){  int nNewSize = 10 - p->nLabel;  p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,   nNewSize*sizeof(p->aLabel[0]));  if( p->aLabel==0 ){  p->nLabelAlloc = 0;  }else{
#ifdef SQLITE_DEBUG
 int i;  for(i=p->nLabelAlloc; i<nNewSize; i++) p->aLabel[i] = -1;
#endif
 p->nLabelAlloc = nNewSize;  p->aLabel[j] = v->nOp;  } } SQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe *v, int x){  Parse *p = v->pParse;  int j = ADDR(x);  assert( v->iVdbeMagic==VDBE_MAGIC_INIT );  assert( j<-p->nLabel );  assert( j>=0 );
#ifdef SQLITE_DEBUG
 if( p->db->flags & SQLITE_VdbeAddopTrace ){  printf("RESOLVE LABEL %d to %d\n", x, v->nOp);  }
#endif
 if( p->nLabelAlloc + p->nLabel < 0 ){  resizeResolveLabel(p,v,j);  }else{  assert( p->aLabel[j]==(-1) );  p->aLabel[j] = v->nOp;  } } SQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe *p){  p->runOnlyOnce = 1; } SQLITE_PRIVATE void sqlite3VdbeReusable(Vdbe *p){  p->runOnlyOnce = 0; }
#ifdef SQLITE_DEBUG
typedef struct VdbeOpIter VdbeOpIter; struct VdbeOpIter {  Vdbe *v;  SubProgram **apSub;  int nSub;  int iAddr;  int iSub; }; static Op *opIterNext(VdbeOpIter *p){  Vdbe *v = p->v;  Op *pRet = 0;  Op *aOp;  int nOp;  if( p->iSub<=p->nSub ){  if( p->iSub==0 ){  aOp = v->aOp;  nOp = v->nOp;  }else{  aOp = p->apSub[p->iSub-1]->aOp;  nOp = p->apSub[p->iSub-1]->nOp;  }  assert( p->iAddr<nOp );  pRet = &aOp[p->iAddr];  p->iAddr++;  if( p->iAddr==nOp ){  p->iSub++;  p->iAddr = 0;  }  if( pRet->p4type==P4_SUBPROGRAM ){  int nByte = (p->nSub+1)*sizeof(SubProgram*);  int j;  for(j=0; j<p->nSub; j++){  if( p->apSub[j]==pRet->p4.pProgram ) break;  }  if( j==p->nSub ){  p->apSub = sqlite3DbReallocOrFree(v->db, p->apSub, nByte);  if( !p->apSub ){  pRet = 0;  }else{  p->apSub[p->nSub++] = pRet->p4.pProgram;  }  }  }  }  return pRet; } SQLITE_PRIVATE int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){  int hasAbort = 0;  int hasFkCounter = 0;  int hasCreateTable = 0;  int hasCreateIndex = 0;  int hasInitCoroutine = 0;  Op *pOp;  VdbeOpIter sIter;  memset(&sIter, 0, sizeof(sIter));  sIter.v = v;  while( (pOp = opIterNext(&sIter))!=0 ){  int opcode = pOp->opcode;  if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename   || opcode==OP_VDestroy   || opcode==OP_VCreate   || opcode==OP_ParseSchema   || ((opcode==OP_Halt || opcode==OP_HaltIfNull)  && ((pOp->p1)!=SQLITE_OK && pOp->p2==OE_Abort))  ){  hasAbort = 1;  break;  }  if( opcode==OP_CreateBtree && pOp->p3==BTREE_INTKEY ) hasCreateTable = 1;  if( mayAbort ){  if( opcode==OP_CreateBtree && pOp->p3==BTREE_BLOBKEY ) hasCreateIndex = 1;  if( opcode==OP_Clear ) hasCreateIndex = 1;  }  if( opcode==OP_InitCoroutine ) hasInitCoroutine = 1;
#ifndef SQLITE_OMIT_FOREIGN_KEY
 if( opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1 ){  hasFkCounter = 1;  }
#endif
 }  sqlite3DbFree(v->db, sIter.apSub);  return ( v->db->mallocFailed || hasAbort==mayAbort || hasFkCounter  || (hasCreateTable && hasInitCoroutine) || hasCreateIndex  ); }
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeIncrWriteCounter(Vdbe *p, VdbeCursor *pC){  if( pC==0   || (pC->eCurType!=CURTYPE_SORTER   && pC->eCurType!=CURTYPE_PSEUDO   && !pC->isEphemeral)  ){  p->nWrite++;  } }
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeAssertAbortable(Vdbe *p){  assert( p->nWrite==0 || p->usesStmtJournal ); }
#endif
static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){  int nMaxArgs = *pMaxFuncArgs;  Op *pOp;  Parse *pParse = p->pParse;  int *aLabel = pParse->aLabel;  p->readOnly = 1;  p->bIsReader = 0;  pOp = &p->aOp[p->nOp-1];  while(1){  if( pOp->opcode<=SQLITE_MX_JUMP_OPCODE ){  switch( pOp->opcode ){  case OP_Transaction: {  if( pOp->p2!=0 ) p->readOnly = 0;   deliberate_fall_through  }  case OP_AutoCommit:  case OP_Savepoint: {  p->bIsReader = 1;  break;  }
#ifndef SQLITE_OMIT_WAL
 case OP_Checkpoint:
#endif
 case OP_Vacuum:  case OP_JournalMode: {  p->readOnly = 0;  p->bIsReader = 1;  break;  }  case OP_Next:  case OP_SorterNext: {  pOp->p4.xAdvance = sqlite3BtreeNext;  pOp->p4type = P4_ADVANCE;  assert( pOp->p2>=0 );  break;  }  case OP_Prev: {  pOp->p4.xAdvance = sqlite3BtreePrevious;  pOp->p4type = P4_ADVANCE;  assert( pOp->p2>=0 );  break;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 case OP_VUpdate: {  if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;  break;  }  case OP_VFilter: {  int n;  assert( (pOp - p->aOp) >= 3 );  assert( pOp[-1].opcode==OP_Integer );  n = pOp[-1].p1;  if( n>nMaxArgs ) nMaxArgs = n;   deliberate_fall_through  }
#endif
 default: {  if( pOp->p2<0 ){  assert( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)!=0 );  assert( ADDR(pOp->p2)<-pParse->nLabel );  pOp->p2 = aLabel[ADDR(pOp->p2)];  }  break;  }  }  assert( (sqlite3OpcodeProperty[pOp->opcode]&OPFLG_JUMP)==0 || pOp->p2>=0);  }  if( pOp==p->aOp ) break;  pOp--;  }  sqlite3DbFree(p->db, pParse->aLabel);  pParse->aLabel = 0;  pParse->nLabel = 0;  *pMaxFuncArgs = nMaxArgs;  assert( p->bIsReader!=0 || DbMaskAllZero(p->btreeMask) ); } SQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe *p){  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );  return p->nOp; }
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
SQLITE_PRIVATE void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N){  assert( p->nOp + N <= p->nOpAlloc ); }
#endif
#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)
SQLITE_PRIVATE void sqlite3VdbeVerifyNoResultRow(Vdbe *p){  int i;  for(i=0; i<p->nOp; i++){  assert( p->aOp[i].opcode!=OP_ResultRow );  } }
#endif
#if defined(SQLITE_DEBUG)
SQLITE_PRIVATE void sqlite3VdbeVerifyAbortable(Vdbe *p, int onError){  if( onError==OE_Abort ) sqlite3VdbeAddOp0(p, OP_Abortable); }
#endif
SQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){  VdbeOp *aOp = p->aOp;  assert( aOp && !p->db->mallocFailed );  assert( DbMaskAllZero(p->btreeMask) );  resolveP2Values(p, pnMaxArg);  *pnOp = p->nOp;  p->aOp = 0;  return aOp; } SQLITE_PRIVATE VdbeOp *sqlite3VdbeAddOpList(  Vdbe *p,  int nOp,  VdbeOpList const *aOp,  int iLineno ){  int i;  VdbeOp *pOut, *pFirst;  assert( nOp>0 );  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){  return 0;  }  pFirst = pOut = &p->aOp[p->nOp];  for(i=0; i<nOp; i++, aOp++, pOut++){  pOut->opcode = aOp->opcode;  pOut->p1 = aOp->p1;  pOut->p2 = aOp->p2;  assert( aOp->p2>=0 );  if( (sqlite3OpcodeProperty[aOp->opcode] & OPFLG_JUMP)!=0 && aOp->p2>0 ){  pOut->p2 += p->nOp;  }  pOut->p3 = aOp->p3;  pOut->p4type = P4_NOTUSED;  pOut->p4.p = 0;  pOut->p5 = 0;
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 pOut->zComment = 0;
#endif
#ifdef SQLITE_VDBE_COVERAGE
 pOut->iSrcLine = iLineno+i;
#else
 (void)iLineno;
#endif
#ifdef SQLITE_DEBUG
 if( p->db->flags & SQLITE_VdbeAddopTrace ){  sqlite3VdbePrintOp(0, i+p->nOp, &p->aOp[i+p->nOp]);  }
#endif
 }  p->nOp += nOp;  return pFirst; }
#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)
SQLITE_PRIVATE void sqlite3VdbeScanStatus(  Vdbe *p,  int addrExplain,  int addrLoop,  int addrVisit,  LogEst nEst,  const char *zName ){  sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);  ScanStatus *aNew;  aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);  if( aNew ){  ScanStatus *pNew = &aNew[p->nScan++];  pNew->addrExplain = addrExplain;  pNew->addrLoop = addrLoop;  pNew->addrVisit = addrVisit;  pNew->nEst = nEst;  pNew->zName = sqlite3DbStrDup(p->db, zName);  p->aScan = aNew;  } }
#endif
SQLITE_PRIVATE void sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode; } SQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){  sqlite3VdbeGetOp(p,addr)->p1 = val; } SQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){  sqlite3VdbeGetOp(p,addr)->p2 = val; } SQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){  sqlite3VdbeGetOp(p,addr)->p3 = val; } SQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u16 p5){  assert( p->nOp>0 || p->db->mallocFailed );  if( p->nOp>0 ) p->aOp[p->nOp-1].p5 = p5; } SQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr){  sqlite3VdbeChangeP2(p, addr, p->nOp); } SQLITE_PRIVATE void sqlite3VdbeJumpHereOrPopInst(Vdbe *p, int addr){  if( addr==p->nOp-1 ){  assert( p->aOp[addr].opcode==OP_Once   || p->aOp[addr].opcode==OP_If   || p->aOp[addr].opcode==OP_FkIfZero );  assert( p->aOp[addr].p4type==0 );
#ifdef SQLITE_VDBE_COVERAGE
 sqlite3VdbeGetOp(p,-1)->iSrcLine = 0;
#endif
 p->nOp--;  }else{  sqlite3VdbeChangeP2(p, addr, p->nOp);  } } static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){  if( (pDef->funcFlags & SQLITE_FUNC_EPHEM)!=0 ){  sqlite3DbFreeNN(db, pDef);  } } static SQLITE_NOINLINE void freeP4Mem(sqlite3 *db, Mem *p){  if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);  sqlite3DbFreeNN(db, p); } static SQLITE_NOINLINE void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){  freeEphemeralFunction(db, p->pFunc);  sqlite3DbFreeNN(db, p); } static void freeP4(sqlite3 *db, int p4type, void *p4){  assert( db );  switch( p4type ){  case P4_FUNCCTX: {  freeP4FuncCtx(db, (sqlite3_context*)p4);  break;  }  case P4_REAL:  case P4_INT64:  case P4_DYNAMIC:  case P4_DYNBLOB:  case P4_INTARRAY: {  sqlite3DbFree(db, p4);  break;  }  case P4_KEYINFO: {  if( db->pnBytesFreed==0 ) sqlite3KeyInfoUnref((KeyInfo*)p4);  break;  }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
 case P4_EXPR: {  sqlite3ExprDelete(db, (Expr*)p4);  break;  }
#endif
 case P4_FUNCDEF: {  freeEphemeralFunction(db, (FuncDef*)p4);  break;  }  case P4_MEM: {  if( db->pnBytesFreed==0 ){  sqlite3ValueFree((sqlite3_value*)p4);  }else{  freeP4Mem(db, (Mem*)p4);  }  break;  }  case P4_VTAB : {  if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);  break;  }  } } static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){  if( aOp ){  Op *pOp;  for(pOp=&aOp[nOp-1]; pOp>=aOp; pOp--){  if( pOp->p4type <= P4_FREE_IF_LE ) freeP4(db, pOp->p4type, pOp->p4.p);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 sqlite3DbFree(db, pOp->zComment);
#endif
 }  sqlite3DbFreeNN(db, aOp);  } } SQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){  p->pNext = pVdbe->pProgram;  pVdbe->pProgram = p; } SQLITE_PRIVATE int sqlite3VdbeHasSubProgram(Vdbe *pVdbe){  return pVdbe->pProgram!=0; } SQLITE_PRIVATE int sqlite3VdbeChangeToNoop(Vdbe *p, int addr){  VdbeOp *pOp;  if( p->db->mallocFailed ) return 0;  assert( addr>=0 && addr<p->nOp );  pOp = &p->aOp[addr];  freeP4(p->db, pOp->p4type, pOp->p4.p);  pOp->p4type = P4_NOTUSED;  pOp->p4.z = 0;  pOp->opcode = OP_Noop;  return 1; } SQLITE_PRIVATE int sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){  if( p->nOp>0 && p->aOp[p->nOp-1].opcode==op ){  return sqlite3VdbeChangeToNoop(p, p->nOp-1);  }else{  return 0;  } }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeReleaseRegisters(  Parse *pParse,  int iFirst,  int N,  u32 mask,  int bUndefine ){  if( N==0 ) return;  assert( pParse->pVdbe );  assert( iFirst>=1 );  assert( iFirst+N-1<=pParse->nMem );  if( N<=31 && mask!=0 ){  while( N>0 && (mask&1)!=0 ){  mask >>= 1;  iFirst++;  N--;  }  while( N>0 && N<=32 && (mask & MASKBIT32(N-1))!=0 ){  mask &= ~MASKBIT32(N-1);  N--;  }  }  if( N>0 ){  sqlite3VdbeAddOp3(pParse->pVdbe, OP_ReleaseReg, iFirst, N, *(int*)&mask);  if( bUndefine ) sqlite3VdbeChangeP5(pParse->pVdbe, 1);  } }
#endif
static void SQLITE_NOINLINE vdbeChangeP4Full(  Vdbe *p,  Op *pOp,  const char *zP4,  int n ){  if( pOp->p4type ){  freeP4(p->db, pOp->p4type, pOp->p4.p);  pOp->p4type = 0;  pOp->p4.p = 0;  }  if( n<0 ){  sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);  }else{  if( n==0 ) n = sqlite3Strlen30(zP4);  pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);  pOp->p4type = P4_DYNAMIC;  } } SQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){  Op *pOp;  sqlite3 *db;  assert( p!=0 );  db = p->db;  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );  assert( p->aOp!=0 || db->mallocFailed );  if( db->mallocFailed ){  if( n!=P4_VTAB ) freeP4(db, n, (void*)*(char**)&zP4);  return;  }  assert( p->nOp>0 );  assert( addr<p->nOp );  if( addr<0 ){  addr = p->nOp - 1;  }  pOp = &p->aOp[addr];  if( n>=0 || pOp->p4type ){  vdbeChangeP4Full(p, pOp, zP4, n);  return;  }  if( n==P4_INT32 ){  pOp->p4.i = SQLITE_PTR_TO_INT(zP4);  pOp->p4type = P4_INT32;  }else if( zP4!=0 ){  assert( n<0 );  pOp->p4.p = (void*)zP4;  pOp->p4type = (signed char)n;  if( n==P4_VTAB ) sqlite3VtabLock((VTable*)zP4);  } } SQLITE_PRIVATE void sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){  VdbeOp *pOp;  assert( n!=P4_INT32 && n!=P4_VTAB );  assert( n<=0 );  if( p->db->mallocFailed ){  freeP4(p->db, n, pP4);  }else{  assert( pP4!=0 );  assert( p->nOp>0 );  pOp = &p->aOp[p->nOp-1];  assert( pOp->p4type==P4_NOTUSED );  pOp->p4type = n;  pOp->p4.p = pP4;  } } SQLITE_PRIVATE void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){  Vdbe *v = pParse->pVdbe;  KeyInfo *pKeyInfo;  assert( v!=0 );  assert( pIdx!=0 );  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);  if( pKeyInfo ) sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO); }
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){  assert( p->nOp>0 || p->aOp==0 );  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed  || p->pParse->nErr>0 );  if( p->nOp ){  assert( p->aOp );  sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);  p->aOp[p->nOp-1].zComment = sqlite3VMPrintf(p->db, zFormat, ap);  } } SQLITE_PRIVATE void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){  va_list ap;  if( p ){  va_start(ap, zFormat);  vdbeVComment(p, zFormat, ap);  va_end(ap);  } } SQLITE_PRIVATE void sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){  va_list ap;  if( p ){  sqlite3VdbeAddOp0(p, OP_Noop);  va_start(ap, zFormat);  vdbeVComment(p, zFormat, ap);  va_end(ap);  } }
#endif
#ifdef SQLITE_VDBE_COVERAGE
SQLITE_PRIVATE void sqlite3VdbeSetLineNumber(Vdbe *v, int iLine){  sqlite3VdbeGetOp(v,-1)->iSrcLine = iLine; }
#endif
SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){  static VdbeOp dummy;  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );  if( addr<0 ){  addr = p->nOp - 1;  }  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );  if( p->db->mallocFailed ){  return (VdbeOp*)&dummy;  }else{  return &p->aOp[addr];  } }
#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)
static int translateP(char c, const Op *pOp){  if( c=='1' ) return pOp->p1;  if( c=='2' ) return pOp->p2;  if( c=='3' ) return pOp->p3;  if( c=='4' ) return pOp->p4.i;  return pOp->p5; } SQLITE_PRIVATE char *sqlite3VdbeDisplayComment(  sqlite3 *db,  const Op *pOp,  const char *zP4 ){  const char *zOpName;  const char *zSynopsis;  int nOpName;  int ii;  char zAlt[50];  StrAccum x;  sqlite3StrAccumInit(&x, 0, 0, 0, SQLITE_MAX_LENGTH);  zOpName = sqlite3OpcodeName(pOp->opcode);  nOpName = sqlite3Strlen30(zOpName);  if( zOpName[nOpName+1] ){  int seenCom = 0;  char c;  zSynopsis = zOpName + nOpName + 1;  if( strncmp(zSynopsis,"IF ",3)==0 ){  sqlite3_snprintf(sizeof(zAlt), zAlt, "if %s goto P2", zSynopsis+3);  zSynopsis = zAlt;  }  for(ii=0; (c = zSynopsis[ii])!=0; ii++){  if( c=='P' ){  c = zSynopsis[++ii];  if( c=='4' ){  sqlite3_str_appendall(&x, zP4);  }else if( c=='X' ){  sqlite3_str_appendall(&x, pOp->zComment);  seenCom = 1;  }else{  int v1 = translateP(c, pOp);  int v2;  if( strncmp(zSynopsis+ii+1, "@P", 2)==0 ){  ii += 3;  v2 = translateP(zSynopsis[ii], pOp);  if( strncmp(zSynopsis+ii+1,"+1",2)==0 ){  ii += 2;  v2++;  }  if( v2<2 ){  sqlite3_str_appendf(&x, "%d", v1);  }else{  sqlite3_str_appendf(&x, "%d..%d", v1, v1+v2-1);  }  }else if( strncmp(zSynopsis+ii+1, "@NP", 3)==0 ){  sqlite3_context *pCtx = pOp->p4.pCtx;  if( pOp->p4type!=P4_FUNCCTX || pCtx->argc==1 ){  sqlite3_str_appendf(&x, "%d", v1);  }else if( pCtx->argc>1 ){  sqlite3_str_appendf(&x, "%d..%d", v1, v1+pCtx->argc-1);  }else if( x.accError==0 ){  assert( x.nChar>2 );  x.nChar -= 2;  ii++;  }  ii += 3;  }else{  sqlite3_str_appendf(&x, "%d", v1);  if( strncmp(zSynopsis+ii+1, "..P3", 4)==0 && pOp->p3==0 ){  ii += 4;  }  }  }  }else{  sqlite3_str_appendchar(&x, 1, c);  }  }  if( !seenCom && pOp->zComment ){  sqlite3_str_appendf(&x, "; %s", pOp->zComment);  }  }else if( pOp->zComment ){  sqlite3_str_appendall(&x, pOp->zComment);  }  if( (x.accError & SQLITE_NOMEM)!=0 && db!=0 ){  sqlite3OomFault(db);  }  return sqlite3StrAccumFinish(&x); }
#endif
#if VDBE_DISPLAY_P4 && defined(SQLITE_ENABLE_CURSOR_HINTS)
static void displayP4Expr(StrAccum *p, Expr *pExpr){  const char *zOp = 0;  switch( pExpr->op ){  case TK_STRING:  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3_str_appendf(p, "%Q", pExpr->u.zToken);  break;  case TK_INTEGER:  sqlite3_str_appendf(p, "%d", pExpr->u.iValue);  break;  case TK_NULL:  sqlite3_str_appendf(p, "NULL");  break;  case TK_REGISTER: {  sqlite3_str_appendf(p, "r[%d]", pExpr->iTable);  break;  }  case TK_COLUMN: {  if( pExpr->iColumn<0 ){  sqlite3_str_appendf(p, "rowid");  }else{  sqlite3_str_appendf(p, "c%d", (int)pExpr->iColumn);  }  break;  }  case TK_LT: zOp = "LT"; break;  case TK_LE: zOp = "LE"; break;  case TK_GT: zOp = "GT"; break;  case TK_GE: zOp = "GE"; break;  case TK_NE: zOp = "NE"; break;  case TK_EQ: zOp = "EQ"; break;  case TK_IS: zOp = "IS"; break;  case TK_ISNOT:  zOp = "ISNOT";  break;  case TK_AND:  zOp = "AND";  break;  case TK_OR: zOp = "OR"; break;  case TK_PLUS: zOp = "ADD";  break;  case TK_STAR: zOp = "MUL";  break;  case TK_MINUS:  zOp = "SUB";  break;  case TK_REM:  zOp = "REM";  break;  case TK_BITAND: zOp = "BITAND"; break;  case TK_BITOR:  zOp = "BITOR";  break;  case TK_SLASH:  zOp = "DIV";  break;  case TK_LSHIFT: zOp = "LSHIFT"; break;  case TK_RSHIFT: zOp = "RSHIFT"; break;  case TK_CONCAT: zOp = "CONCAT"; break;  case TK_UMINUS: zOp = "MINUS";  break;  case TK_UPLUS:  zOp = "PLUS"; break;  case TK_BITNOT: zOp = "BITNOT"; break;  case TK_NOT:  zOp = "NOT";  break;  case TK_ISNULL: zOp = "ISNULL"; break;  case TK_NOTNULL: zOp = "NOTNULL"; break;  default:  sqlite3_str_appendf(p, "%s", "expr");  break;  }  if( zOp ){  sqlite3_str_appendf(p, "%s(", zOp);  displayP4Expr(p, pExpr->pLeft);  if( pExpr->pRight ){  sqlite3_str_append(p, ",", 1);  displayP4Expr(p, pExpr->pRight);  }  sqlite3_str_append(p, ")", 1);  } }
#endif
#if VDBE_DISPLAY_P4
SQLITE_PRIVATE char *sqlite3VdbeDisplayP4(sqlite3 *db, Op *pOp){  char *zP4 = 0;  StrAccum x;  sqlite3StrAccumInit(&x, 0, 0, 0, SQLITE_MAX_LENGTH);  switch( pOp->p4type ){  case P4_KEYINFO: {  int j;  KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;  assert( pKeyInfo->aSortFlags!=0 );  sqlite3_str_appendf(&x, "k(%d", pKeyInfo->nKeyField);  for(j=0; j<pKeyInfo->nKeyField; j++){  CollSeq *pColl = pKeyInfo->aColl[j];  const char *zColl = pColl ? pColl->zName : "";  if( strcmp(zColl, "BINARY")==0 ) zColl = "B";  sqlite3_str_appendf(&x, ",%s%s%s",   (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_DESC) ? "-" : "",   (pKeyInfo->aSortFlags[j] & KEYINFO_ORDER_BIGNULL)? "N." : "",   zColl);  }  sqlite3_str_append(&x, ")", 1);  break;  }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
 case P4_EXPR: {  displayP4Expr(&x, pOp->p4.pExpr);  break;  }
#endif
 case P4_COLLSEQ: {  static const char *const encnames[] = {"?", "8", "16LE", "16BE"};  CollSeq *pColl = pOp->p4.pColl;  assert( pColl->enc<4 );  sqlite3_str_appendf(&x, "%.18s-%s", pColl->zName,  encnames[pColl->enc]);  break;  }  case P4_FUNCDEF: {  FuncDef *pDef = pOp->p4.pFunc;  sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);  break;  }  case P4_FUNCCTX: {  FuncDef *pDef = pOp->p4.pCtx->pFunc;  sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);  break;  }  case P4_INT64: {  sqlite3_str_appendf(&x, "%lld", *pOp->p4.pI64);  break;  }  case P4_INT32: {  sqlite3_str_appendf(&x, "%d", pOp->p4.i);  break;  }  case P4_REAL: {  sqlite3_str_appendf(&x, "%.16g", *pOp->p4.pReal);  break;  }  case P4_MEM: {  Mem *pMem = pOp->p4.pMem;  if( pMem->flags & MEM_Str ){  zP4 = pMem->z;  }else if( pMem->flags & (MEM_Int|MEM_IntReal) ){  sqlite3_str_appendf(&x, "%lld", pMem->u.i);  }else if( pMem->flags & MEM_Real ){  sqlite3_str_appendf(&x, "%.16g", pMem->u.r);  }else if( pMem->flags & MEM_Null ){  zP4 = "NULL";  }else{  assert( pMem->flags & MEM_Blob );  zP4 = "(blob)";  }  break;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 case P4_VTAB: {  sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;  sqlite3_str_appendf(&x, "vtab:%p", pVtab);  break;  }
#endif
 case P4_INTARRAY: {  u32 i;  u32 *ai = pOp->p4.ai;  u32 n = ai[0];  for(i=1; i<=n; i++){  sqlite3_str_appendf(&x, "%c%u", (i==1 ? '[' : ','), ai[i]);  }  sqlite3_str_append(&x, "]", 1);  break;  }  case P4_SUBPROGRAM: {  zP4 = "program";  break;  }  case P4_DYNBLOB:  case P4_ADVANCE: {  break;  }  case P4_TABLE: {  zP4 = pOp->p4.pTab->zName;  break;  }  default: {  zP4 = pOp->p4.z;  }  }  if( zP4 ) sqlite3_str_appendall(&x, zP4);  if( (x.accError & SQLITE_NOMEM)!=0 ){  sqlite3OomFault(db);  }  return sqlite3StrAccumFinish(&x); }
#endif
SQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe *p, int i){  assert( i>=0 && i<p->db->nDb && i<(int)sizeof(yDbMask)*8 );  assert( i<(int)sizeof(p->btreeMask)*8 );  DbMaskSet(p->btreeMask, i);  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){  DbMaskSet(p->lockMask, i);  } }
#if !defined(SQLITE_OMIT_SHARED_CACHE)
SQLITE_PRIVATE void sqlite3VdbeEnter(Vdbe *p){  int i;  sqlite3 *db;  Db *aDb;  int nDb;  if( DbMaskAllZero(p->lockMask) ) return;  db = p->db;  aDb = db->aDb;  nDb = db->nDb;  for(i=0; i<nDb; i++){  if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){  sqlite3BtreeEnter(aDb[i].pBt);  }  } }
#endif
#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0
static SQLITE_NOINLINE void vdbeLeave(Vdbe *p){  int i;  sqlite3 *db;  Db *aDb;  int nDb;  db = p->db;  aDb = db->aDb;  nDb = db->nDb;  for(i=0; i<nDb; i++){  if( i!=1 && DbMaskTest(p->lockMask,i) && ALWAYS(aDb[i].pBt!=0) ){  sqlite3BtreeLeave(aDb[i].pBt);  }  } } SQLITE_PRIVATE void sqlite3VdbeLeave(Vdbe *p){  if( DbMaskAllZero(p->lockMask) ) return;  vdbeLeave(p); }
#endif
#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)
SQLITE_PRIVATE void sqlite3VdbePrintOp(FILE *pOut, int pc, VdbeOp *pOp){  char *zP4;  char *zCom;  sqlite3 dummyDb;  static const char *zFormat1 = "%4d %-13s %4d %4d %4d %-13s %.2X %s\n";  if( pOut==0 ) pOut = stdout;  sqlite3BeginBenignMalloc();  dummyDb.mallocFailed = 1;  zP4 = sqlite3VdbeDisplayP4(&dummyDb, pOp);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 zCom = sqlite3VdbeDisplayComment(0, pOp, zP4);
#else
 zCom = 0;
#endif
 fprintf(pOut, zFormat1, pc,  sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3,  zP4 ? zP4 : "", pOp->p5,  zCom ? zCom : ""  );  fflush(pOut);  sqlite3_free(zP4);  sqlite3_free(zCom);  sqlite3EndBenignMalloc(); }
#endif
static void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){  while( (N--)>0 ){  p->db = db;  p->flags = flags;  p->szMalloc = 0;
#ifdef SQLITE_DEBUG
 p->pScopyFrom = 0;
#endif
 p++;  } } static void releaseMemArray(Mem *p, int N){  if( p && N ){  Mem *pEnd = &p[N];  sqlite3 *db = p->db;  if( db->pnBytesFreed ){  do{  if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);  }while( (++p)<pEnd );  return;  }  do{  assert( (&p[1])==pEnd || p[0].db==p[1].db );  assert( sqlite3VdbeCheckMemInvariants(p) );  testcase( p->flags & MEM_Agg );  testcase( p->flags & MEM_Dyn );  if( p->flags&(MEM_Agg|MEM_Dyn) ){  testcase( (p->flags & MEM_Dyn)!=0 && p->xDel==sqlite3VdbeFrameMemDel );  sqlite3VdbeMemRelease(p);  }else if( p->szMalloc ){  sqlite3DbFreeNN(db, p->zMalloc);  p->szMalloc = 0;  }  p->flags = MEM_Undefined;  }while( (++p)<pEnd );  } }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3VdbeFrameIsValid(VdbeFrame *pFrame){  if( pFrame->iFrameMagic!=SQLITE_FRAME_MAGIC ) return 0;  return 1; }
#endif
SQLITE_PRIVATE void sqlite3VdbeFrameMemDel(void *pArg){  VdbeFrame *pFrame = (VdbeFrame*)pArg;  assert( sqlite3VdbeFrameIsValid(pFrame) );  pFrame->pParent = pFrame->v->pDelFrame;  pFrame->v->pDelFrame = pFrame; }
#if defined(SQLITE_ENABLE_BYTECODE_VTAB) || !defined(SQLITE_OMIT_EXPLAIN)
SQLITE_PRIVATE int sqlite3VdbeNextOpcode(  Vdbe *p,  Mem *pSub,  int eMode,  int *piPc,  int *piAddr,  Op **paOp ){  int nRow;  int nSub = 0;  SubProgram **apSub = 0;  int i;  int rc = SQLITE_OK;  Op *aOp = 0;  int iPc;  nRow = p->nOp;  if( pSub!=0 ){  if( pSub->flags&MEM_Blob ){  nSub = pSub->n/sizeof(Vdbe*);  apSub = (SubProgram **)pSub->z;  }  for(i=0; i<nSub; i++){  nRow += apSub[i]->nOp;  }  }  iPc = *piPc;  while(1){  i = iPc++;  if( i>=nRow ){  p->rc = SQLITE_OK;  rc = SQLITE_DONE;  break;  }  if( i<p->nOp ){  aOp = p->aOp;  }else{  int j;  i -= p->nOp;  assert( apSub!=0 );  assert( nSub>0 );  for(j=0; i>=apSub[j]->nOp; j++){  i -= apSub[j]->nOp;  assert( i<apSub[j]->nOp || j+1<nSub );  }  aOp = apSub[j]->aOp;  }  if( pSub!=0 && aOp[i].p4type==P4_SUBPROGRAM ){  int nByte = (nSub+1)*sizeof(SubProgram*);  int j;  for(j=0; j<nSub; j++){  if( apSub[j]==aOp[i].p4.pProgram ) break;  }  if( j==nSub ){  p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);  if( p->rc!=SQLITE_OK ){  rc = SQLITE_ERROR;  break;  }  apSub = (SubProgram **)pSub->z;  apSub[nSub++] = aOp[i].p4.pProgram;  MemSetTypeFlag(pSub, MEM_Blob);  pSub->n = nSub*sizeof(SubProgram*);  nRow += aOp[i].p4.pProgram->nOp;  }  }  if( eMode==0 ) break;
#ifdef SQLITE_ENABLE_BYTECODE_VTAB
 if( eMode==2 ){  Op *pOp = aOp + i;  if( pOp->opcode==OP_OpenRead ) break;  if( pOp->opcode==OP_OpenWrite && (pOp->p5 & OPFLAG_P2ISREG)==0 ) break;  if( pOp->opcode==OP_ReopenIdx ) break;  }else
#endif
 {  assert( eMode==1 );  if( aOp[i].opcode==OP_Explain ) break;  if( aOp[i].opcode==OP_Init && iPc>1 ) break;  }  }  *piPc = iPc;  *piAddr = i;  *paOp = aOp;  return rc; }
#endif
SQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame *p){  int i;  Mem *aMem = VdbeFrameMem(p);  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];  assert( sqlite3VdbeFrameIsValid(p) );  for(i=0; i<p->nChildCsr; i++){  sqlite3VdbeFreeCursor(p->v, apCsr[i]);  }  releaseMemArray(aMem, p->nChildMem);  sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);  sqlite3DbFree(p->v->db, p); }
#ifndef SQLITE_OMIT_EXPLAIN
SQLITE_PRIVATE int sqlite3VdbeList(  Vdbe *p ){  Mem *pSub = 0;  sqlite3 *db = p->db;  int i;  int rc = SQLITE_OK;  Mem *pMem = &p->aMem[1];  int bListSubprogs = (p->explain==1 || (db->flags & SQLITE_TriggerEQP)!=0);  Op *aOp;  Op *pOp;  assert( p->explain );  assert( p->iVdbeMagic==VDBE_MAGIC_RUN );  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM );  releaseMemArray(pMem, 8);  p->pResultSet = 0;  if( p->rc==SQLITE_NOMEM ){  sqlite3OomFault(db);  return SQLITE_ERROR;  }  if( bListSubprogs ){  assert( p->nMem>9 );  pSub = &p->aMem[9];  }else{  pSub = 0;  }  rc = sqlite3VdbeNextOpcode(p, pSub, p->explain==2, &p->pc, &i, &aOp);  if( rc==SQLITE_OK ){  pOp = aOp + i;  if( AtomicLoad(&db->u1.isInterrupted) ){  p->rc = SQLITE_INTERRUPT;  rc = SQLITE_ERROR;  sqlite3VdbeError(p, sqlite3ErrStr(p->rc));  }else{  char *zP4 = sqlite3VdbeDisplayP4(db, pOp);  if( p->explain==2 ){  sqlite3VdbeMemSetInt64(pMem, pOp->p1);  sqlite3VdbeMemSetInt64(pMem+1, pOp->p2);  sqlite3VdbeMemSetInt64(pMem+2, pOp->p3);  sqlite3VdbeMemSetStr(pMem+3, zP4, -1, SQLITE_UTF8, sqlite3_free);  p->nResColumn = 4;  }else{  sqlite3VdbeMemSetInt64(pMem+0, i);  sqlite3VdbeMemSetStr(pMem+1, (char*)sqlite3OpcodeName(pOp->opcode),   -1, SQLITE_UTF8, SQLITE_STATIC);  sqlite3VdbeMemSetInt64(pMem+2, pOp->p1);  sqlite3VdbeMemSetInt64(pMem+3, pOp->p2);  sqlite3VdbeMemSetInt64(pMem+4, pOp->p3);  sqlite3VdbeMemSetInt64(pMem+6, pOp->p5);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 {  char *zCom = sqlite3VdbeDisplayComment(db, pOp, zP4);  sqlite3VdbeMemSetStr(pMem+7, zCom, -1, SQLITE_UTF8, sqlite3_free);  }
#else
 sqlite3VdbeMemSetNull(pMem+7);
#endif
 sqlite3VdbeMemSetStr(pMem+5, zP4, -1, SQLITE_UTF8, sqlite3_free);  p->nResColumn = 8;  }  p->pResultSet = pMem;  if( db->mallocFailed ){  p->rc = SQLITE_NOMEM;  rc = SQLITE_ERROR;  }else{  p->rc = SQLITE_OK;  rc = SQLITE_ROW;  }  }  }  return rc; }
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbePrintSql(Vdbe *p){  const char *z = 0;  if( p->zSql ){  z = p->zSql;  }else if( p->nOp>=1 ){  const VdbeOp *pOp = &p->aOp[0];  if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){  z = pOp->p4.z;  while( sqlite3Isspace(*z) ) z++;  }  }  if( z ) printf("SQL: [%s]\n", z); }
#endif
#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)
SQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe *p){  int nOp = p->nOp;  VdbeOp *pOp;  if( sqlite3IoTrace==0 ) return;  if( nOp<1 ) return;  pOp = &p->aOp[0];  if( pOp->opcode==OP_Init && pOp->p4.z!=0 ){  int i, j;  char z[1000];  sqlite3_snprintf(sizeof(z), z, "%s", pOp->p4.z);  for(i=0; sqlite3Isspace(z[i]); i++){}  for(j=0; z[i]; i++){  if( sqlite3Isspace(z[i]) ){  if( z[i-1]!=' ' ){  z[j++] = ' ';  }  }else{  z[j++] = z[i];  }  }  z[j] = 0;  sqlite3IoTrace("SQL %s\n", z);  } }
#endif
struct ReusableSpace {  u8 *pSpace;  sqlite3_int64 nFree;  sqlite3_int64 nNeeded; }; static void *allocSpace(  struct ReusableSpace *p,  void *pBuf,  sqlite3_int64 nByte ){  assert( EIGHT_BYTE_ALIGNMENT(p->pSpace) );  if( pBuf==0 ){  nByte = ROUND8(nByte);  if( nByte <= p->nFree ){  p->nFree -= nByte;  pBuf = &p->pSpace[p->nFree];  }else{  p->nNeeded += nByte;  }  }  assert( EIGHT_BYTE_ALIGNMENT(pBuf) );  return pBuf; } SQLITE_PRIVATE void sqlite3VdbeRewind(Vdbe *p){
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
 int i;
#endif
 assert( p!=0 );  assert( p->iVdbeMagic==VDBE_MAGIC_INIT || p->iVdbeMagic==VDBE_MAGIC_RESET );  assert( p->nOp>0 );  p->iVdbeMagic = VDBE_MAGIC_RUN;
#ifdef SQLITE_DEBUG
 for(i=0; i<p->nMem; i++){  assert( p->aMem[i].db==p->db );  }
#endif
 p->pc = -1;  p->rc = SQLITE_OK;  p->errorAction = OE_Abort;  p->nChange = 0;  p->cacheCtr = 1;  p->minWriteFileFormat = 255;  p->iStatement = 0;  p->nFkConstraint = 0;
#ifdef VDBE_PROFILE
 for(i=0; i<p->nOp; i++){  p->aOp[i].cnt = 0;  p->aOp[i].cycles = 0;  }
#endif
} SQLITE_PRIVATE void sqlite3VdbeMakeReady(  Vdbe *p,  Parse *pParse ){  sqlite3 *db;  int nVar;  int nMem;  int nCursor;  int nArg;  int n;  struct ReusableSpace x;  assert( p!=0 );  assert( p->nOp>0 );  assert( pParse!=0 );  assert( p->iVdbeMagic==VDBE_MAGIC_INIT );  assert( pParse==p->pParse );  p->pVList = pParse->pVList;  pParse->pVList = 0;  db = p->db;  assert( db->mallocFailed==0 );  nVar = pParse->nVar;  nMem = pParse->nMem;  nCursor = pParse->nTab;  nArg = pParse->nMaxArg;  nMem += nCursor;  if( nCursor==0 && nMem>0 ) nMem++;  n = ROUND8(sizeof(Op)*p->nOp);  x.pSpace = &((u8*)p->aOp)[n];  assert( EIGHT_BYTE_ALIGNMENT(x.pSpace) );  x.nFree = ROUNDDOWN8(pParse->szOpAlloc - n);  assert( x.nFree>=0 );  assert( EIGHT_BYTE_ALIGNMENT(&x.pSpace[x.nFree]) );  resolveP2Values(p, &nArg);  p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);  if( pParse->explain ){  static const char * const azColName[] = {   "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",   "id", "parent", "notused", "detail"  };  int iFirst, mx, i;  if( nMem<10 ) nMem = 10;  p->explain = pParse->explain;  if( pParse->explain==2 ){  sqlite3VdbeSetNumCols(p, 4);  iFirst = 8;  mx = 12;  }else{  sqlite3VdbeSetNumCols(p, 8);  iFirst = 0;  mx = 8;  }  for(i=iFirst; i<mx; i++){  sqlite3VdbeSetColName(p, i-iFirst, COLNAME_NAME,  azColName[i], SQLITE_STATIC);  }  }  p->expired = 0;  x.nNeeded = 0;  p->aMem = allocSpace(&x, 0, nMem*sizeof(Mem));  p->aVar = allocSpace(&x, 0, nVar*sizeof(Mem));  p->apArg = allocSpace(&x, 0, nArg*sizeof(Mem*));  p->apCsr = allocSpace(&x, 0, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 p->anExec = allocSpace(&x, 0, p->nOp*sizeof(i64));
#endif
 if( x.nNeeded ){  x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);  x.nFree = x.nNeeded;  if( !db->mallocFailed ){  p->aMem = allocSpace(&x, p->aMem, nMem*sizeof(Mem));  p->aVar = allocSpace(&x, p->aVar, nVar*sizeof(Mem));  p->apArg = allocSpace(&x, p->apArg, nArg*sizeof(Mem*));  p->apCsr = allocSpace(&x, p->apCsr, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 p->anExec = allocSpace(&x, p->anExec, p->nOp*sizeof(i64));
#endif
 }  }  if( db->mallocFailed ){  p->nVar = 0;  p->nCursor = 0;  p->nMem = 0;  }else{  p->nCursor = nCursor;  p->nVar = (ynVar)nVar;  initMemArray(p->aVar, nVar, db, MEM_Null);  p->nMem = nMem;  initMemArray(p->aMem, nMem, db, MEM_Undefined);  memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 memset(p->anExec, 0, p->nOp*sizeof(i64));
#endif
 }  sqlite3VdbeRewind(p); } SQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){  if( pCx==0 ){  return;  }  assert( pCx->pBtx==0 || pCx->eCurType==CURTYPE_BTREE );  assert( pCx->pBtx==0 || pCx->isEphemeral );  switch( pCx->eCurType ){  case CURTYPE_SORTER: {  sqlite3VdbeSorterClose(p->db, pCx);  break;  }  case CURTYPE_BTREE: {  assert( pCx->uc.pCursor!=0 );  sqlite3BtreeCloseCursor(pCx->uc.pCursor);  break;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 case CURTYPE_VTAB: {  sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;  const sqlite3_module *pModule = pVCur->pVtab->pModule;  assert( pVCur->pVtab->nRef>0 );  pVCur->pVtab->nRef--;  pModule->xClose(pVCur);  break;  }
#endif
 } } static void closeCursorsInFrame(Vdbe *p){  if( p->apCsr ){  int i;  for(i=0; i<p->nCursor; i++){  VdbeCursor *pC = p->apCsr[i];  if( pC ){  sqlite3VdbeFreeCursor(p, pC);  p->apCsr[i] = 0;  }  }  } } SQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){  Vdbe *v = pFrame->v;  closeCursorsInFrame(v);
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 v->anExec = pFrame->anExec;
#endif
 v->aOp = pFrame->aOp;  v->nOp = pFrame->nOp;  v->aMem = pFrame->aMem;  v->nMem = pFrame->nMem;  v->apCsr = pFrame->apCsr;  v->nCursor = pFrame->nCursor;  v->db->lastRowid = pFrame->lastRowid;  v->nChange = pFrame->nChange;  v->db->nChange = pFrame->nDbChange;  sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);  v->pAuxData = pFrame->pAuxData;  pFrame->pAuxData = 0;  return pFrame->pc; } static void closeAllCursors(Vdbe *p){  if( p->pFrame ){  VdbeFrame *pFrame;  for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);  sqlite3VdbeFrameRestore(pFrame);  p->pFrame = 0;  p->nFrame = 0;  }  assert( p->nFrame==0 );  closeCursorsInFrame(p);  if( p->aMem ){  releaseMemArray(p->aMem, p->nMem);  }  while( p->pDelFrame ){  VdbeFrame *pDel = p->pDelFrame;  p->pDelFrame = pDel->pParent;  sqlite3VdbeFrameDelete(pDel);  }  if( p->pAuxData ) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);  assert( p->pAuxData==0 ); } SQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){  int n;  sqlite3 *db = p->db;  if( p->nResColumn ){  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);  sqlite3DbFree(db, p->aColName);  }  n = nResColumn*COLNAME_N;  p->nResColumn = (u16)nResColumn;  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );  if( p->aColName==0 ) return;  initMemArray(p->aColName, n, db, MEM_Null); } SQLITE_PRIVATE int sqlite3VdbeSetColName(  Vdbe *p,  int idx,  int var,  const char *zName,  void (*xDel)(void*) ){  int rc;  Mem *pColName;  assert( idx<p->nResColumn );  assert( var<COLNAME_N );  if( p->db->mallocFailed ){  assert( !zName || xDel!=SQLITE_DYNAMIC );  return SQLITE_NOMEM_BKPT;  }  assert( p->aColName!=0 );  pColName = &(p->aColName[idx+var*p->nResColumn]);  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel);  assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 );  return rc; } static int vdbeCommit(sqlite3 *db, Vdbe *p){  int i;  int nTrans = 0;  int rc = SQLITE_OK;  int needXcommit = 0;
#ifdef SQLITE_OMIT_VIRTUALTABLE
 UNUSED_PARAMETER(p);
#endif
 rc = sqlite3VtabSync(db, p);  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){  static const u8 aMJNeeded[] = {  1,   1,   0,   1,   0,   0  };  Pager *pPager;  needXcommit = 1;  sqlite3BtreeEnter(pBt);  pPager = sqlite3BtreePager(pBt);  if( db->aDb[i].safety_level!=PAGER_SYNCHRONOUS_OFF   && aMJNeeded[sqlite3PagerGetJournalMode(pPager)]   && sqlite3PagerIsMemdb(pPager)==0  ){  assert( i!=1 );  nTrans++;  }  rc = sqlite3PagerExclusiveLock(pPager);  sqlite3BtreeLeave(pBt);  }  }  if( rc!=SQLITE_OK ){  return rc;  }  if( needXcommit && db->xCommitCallback ){  rc = db->xCommitCallback(db->pCommitArg);  if( rc ){  return SQLITE_CONSTRAINT_COMMITHOOK;  }  }  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))   || nTrans<=1  ){  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  rc = sqlite3BtreeCommitPhaseOne(pBt, 0);  }  }  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);  }  }  if( rc==SQLITE_OK ){  sqlite3VtabCommit(db);  }  }
#ifndef SQLITE_OMIT_DISKIO
 else{  sqlite3_vfs *pVfs = db->pVfs;  char *zSuper = 0;  char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);  sqlite3_file *pSuperJrnl = 0;  i64 offset = 0;  int res;  int retryCount = 0;  int nMainFile;  nMainFile = sqlite3Strlen30(zMainFile);  zSuper = sqlite3MPrintf(db, "%.4c%s%.16c", 0,zMainFile,0);  if( zSuper==0 ) return SQLITE_NOMEM_BKPT;  zSuper += 4;  do {  u32 iRandom;  if( retryCount ){  if( retryCount>100 ){  sqlite3_log(SQLITE_FULL, "MJ delete: %s", zSuper);  sqlite3OsDelete(pVfs, zSuper, 0);  break;  }else if( retryCount==1 ){  sqlite3_log(SQLITE_FULL, "MJ collide: %s", zSuper);  }  }  retryCount++;  sqlite3_randomness(sizeof(iRandom), &iRandom);  sqlite3_snprintf(13, &zSuper[nMainFile], "-mj%06X9%02X",   (iRandom>>8)&0xffffff, iRandom&0xff);  assert( zSuper[sqlite3Strlen30(zSuper)-3]=='9' );  sqlite3FileSuffix3(zMainFile, zSuper);  rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);  }while( rc==SQLITE_OK && res );  if( rc==SQLITE_OK ){  rc = sqlite3OsOpenMalloc(pVfs, zSuper, &pSuperJrnl,  SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|  SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_SUPER_JOURNAL, 0  );  }  if( rc!=SQLITE_OK ){  sqlite3DbFree(db, zSuper-4);  return rc;  }  for(i=0; i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){  char const *zFile = sqlite3BtreeGetJournalname(pBt);  if( zFile==0 ){  continue;  }  assert( zFile[0]!=0 );  rc = sqlite3OsWrite(pSuperJrnl, zFile, sqlite3Strlen30(zFile)+1,offset);  offset += sqlite3Strlen30(zFile)+1;  if( rc!=SQLITE_OK ){  sqlite3OsCloseFree(pSuperJrnl);  sqlite3OsDelete(pVfs, zSuper, 0);  sqlite3DbFree(db, zSuper-4);  return rc;  }  }  }  if( 0==(sqlite3OsDeviceCharacteristics(pSuperJrnl)&SQLITE_IOCAP_SEQUENTIAL)   && SQLITE_OK!=(rc = sqlite3OsSync(pSuperJrnl, SQLITE_SYNC_NORMAL))  ){  sqlite3OsCloseFree(pSuperJrnl);  sqlite3OsDelete(pVfs, zSuper, 0);  sqlite3DbFree(db, zSuper-4);  return rc;  }  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  rc = sqlite3BtreeCommitPhaseOne(pBt, zSuper);  }  }  sqlite3OsCloseFree(pSuperJrnl);  assert( rc!=SQLITE_BUSY );  if( rc!=SQLITE_OK ){  sqlite3DbFree(db, zSuper-4);  return rc;  }  rc = sqlite3OsDelete(pVfs, zSuper, 1);  sqlite3DbFree(db, zSuper-4);  zSuper = 0;  if( rc ){  return rc;  }  disable_simulated_io_errors();  sqlite3BeginBenignMalloc();  for(i=0; i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  sqlite3BtreeCommitPhaseTwo(pBt, 1);  }  }  sqlite3EndBenignMalloc();  enable_simulated_io_errors();  sqlite3VtabCommit(db);  }
#endif
 return rc; }
#ifndef NDEBUG
static void checkActiveVdbeCnt(sqlite3 *db){  Vdbe *p;  int cnt = 0;  int nWrite = 0;  int nRead = 0;  p = db->pVdbe;  while( p ){  if( sqlite3_stmt_busy((sqlite3_stmt*)p) ){  cnt++;  if( p->readOnly==0 ) nWrite++;  if( p->bIsReader ) nRead++;  }  p = p->pNext;  }  assert( cnt==db->nVdbeActive );  assert( nWrite==db->nVdbeWrite );  assert( nRead==db->nVdbeRead ); }
#else
#define checkActiveVdbeCnt(x)
#endif
static SQLITE_NOINLINE int vdbeCloseStatement(Vdbe *p, int eOp){  sqlite3 *const db = p->db;  int rc = SQLITE_OK;  int i;  const int iSavepoint = p->iStatement-1;  assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);  assert( db->nStatement>0 );  assert( p->iStatement==(db->nStatement+db->nSavepoint) );  for(i=0; i<db->nDb; i++){  int rc2 = SQLITE_OK;  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  if( eOp==SAVEPOINT_ROLLBACK ){  rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);  }  if( rc2==SQLITE_OK ){  rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);  }  if( rc==SQLITE_OK ){  rc = rc2;  }  }  }  db->nStatement--;  p->iStatement = 0;  if( rc==SQLITE_OK ){  if( eOp==SAVEPOINT_ROLLBACK ){  rc = sqlite3VtabSavepoint(db, SAVEPOINT_ROLLBACK, iSavepoint);  }  if( rc==SQLITE_OK ){  rc = sqlite3VtabSavepoint(db, SAVEPOINT_RELEASE, iSavepoint);  }  }  if( eOp==SAVEPOINT_ROLLBACK ){  db->nDeferredCons = p->nStmtDefCons;  db->nDeferredImmCons = p->nStmtDefImmCons;  }  return rc; } SQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){  if( p->db->nStatement && p->iStatement ){  return vdbeCloseStatement(p, eOp);  }  return SQLITE_OK; }
#ifndef SQLITE_OMIT_FOREIGN_KEY
SQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *p, int deferred){  sqlite3 *db = p->db;  if( (deferred && (db->nDeferredCons+db->nDeferredImmCons)>0)   || (!deferred && p->nFkConstraint>0)  ){  p->rc = SQLITE_CONSTRAINT_FOREIGNKEY;  p->errorAction = OE_Abort;  sqlite3VdbeError(p, "FOREIGN KEY constraint failed");  return SQLITE_ERROR;  }  return SQLITE_OK; }
#endif
SQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe *p){  int rc;  sqlite3 *db = p->db;  if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){  return SQLITE_OK;  }  if( db->mallocFailed ){  p->rc = SQLITE_NOMEM_BKPT;  }  closeAllCursors(p);  checkActiveVdbeCnt(db);  if( p->pc>=0 && p->bIsReader ){  int mrc;  int eStatementOp = 0;  int isSpecialError;  sqlite3VdbeEnter(p);  if( p->rc ){  mrc = p->rc & 0xff;  isSpecialError = mrc==SQLITE_NOMEM  || mrc==SQLITE_IOERR  || mrc==SQLITE_INTERRUPT  || mrc==SQLITE_FULL;  }else{  mrc = isSpecialError = 0;  }  if( isSpecialError ){  if( !p->readOnly || mrc!=SQLITE_INTERRUPT ){  if( (mrc==SQLITE_NOMEM || mrc==SQLITE_FULL) && p->usesStmtJournal ){  eStatementOp = SAVEPOINT_ROLLBACK;  }else{  sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);  sqlite3CloseSavepoints(db);  db->autoCommit = 1;  p->nChange = 0;  }  }  }  if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){  sqlite3VdbeCheckFk(p, 0);  }  if( !sqlite3VtabInSync(db)   && db->autoCommit   && db->nVdbeWrite==(p->readOnly==0)  ){  if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){  rc = sqlite3VdbeCheckFk(p, 1);  if( rc!=SQLITE_OK ){  if( NEVER(p->readOnly) ){  sqlite3VdbeLeave(p);  return SQLITE_ERROR;  }  rc = SQLITE_CONSTRAINT_FOREIGNKEY;  }else if( db->flags & SQLITE_CorruptRdOnly ){  rc = SQLITE_CORRUPT;  db->flags &= ~SQLITE_CorruptRdOnly;  }else{  rc = vdbeCommit(db, p);  }  if( rc==SQLITE_BUSY && p->readOnly ){  sqlite3VdbeLeave(p);  return SQLITE_BUSY;  }else if( rc!=SQLITE_OK ){  p->rc = rc;  sqlite3RollbackAll(db, SQLITE_OK);  p->nChange = 0;  }else{  db->nDeferredCons = 0;  db->nDeferredImmCons = 0;  db->flags &= ~(u64)SQLITE_DeferFKs;  sqlite3CommitInternalChanges(db);  }  }else{  sqlite3RollbackAll(db, SQLITE_OK);  p->nChange = 0;  }  db->nStatement = 0;  }else if( eStatementOp==0 ){  if( p->rc==SQLITE_OK || p->errorAction==OE_Fail ){  eStatementOp = SAVEPOINT_RELEASE;  }else if( p->errorAction==OE_Abort ){  eStatementOp = SAVEPOINT_ROLLBACK;  }else{  sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);  sqlite3CloseSavepoints(db);  db->autoCommit = 1;  p->nChange = 0;  }  }  if( eStatementOp ){  rc = sqlite3VdbeCloseStatement(p, eStatementOp);  if( rc ){  if( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT ){  p->rc = rc;  sqlite3DbFree(db, p->zErrMsg);  p->zErrMsg = 0;  }  sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);  sqlite3CloseSavepoints(db);  db->autoCommit = 1;  p->nChange = 0;  }  }  if( p->changeCntOn ){  if( eStatementOp!=SAVEPOINT_ROLLBACK ){  sqlite3VdbeSetChanges(db, p->nChange);  }else{  sqlite3VdbeSetChanges(db, 0);  }  p->nChange = 0;  }  sqlite3VdbeLeave(p);  }  if( p->pc>=0 ){  db->nVdbeActive--;  if( !p->readOnly ) db->nVdbeWrite--;  if( p->bIsReader ) db->nVdbeRead--;  assert( db->nVdbeActive>=db->nVdbeRead );  assert( db->nVdbeRead>=db->nVdbeWrite );  assert( db->nVdbeWrite>=0 );  }  p->iVdbeMagic = VDBE_MAGIC_HALT;  checkActiveVdbeCnt(db);  if( db->mallocFailed ){  p->rc = SQLITE_NOMEM_BKPT;  }  if( db->autoCommit ){  sqlite3ConnectionUnlocked(db);  }  assert( db->nVdbeActive>0 || db->autoCommit==0 || db->nStatement==0 );  return (p->rc==SQLITE_BUSY ? SQLITE_BUSY : SQLITE_OK); } SQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe *p){  p->rc = SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p){  sqlite3 *db = p->db;  int rc = p->rc;  if( p->zErrMsg ){  db->bBenignMalloc++;  sqlite3BeginBenignMalloc();  if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);  sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);  sqlite3EndBenignMalloc();  db->bBenignMalloc--;  }else if( db->pErr ){  sqlite3ValueSetNull(db->pErr);  }  db->errCode = rc;  return rc; }
#ifdef SQLITE_ENABLE_SQLLOG
static void vdbeInvokeSqllog(Vdbe *v){  if( sqlite3GlobalConfig.xSqllog && v->rc==SQLITE_OK && v->zSql && v->pc>=0 ){  char *zExpanded = sqlite3VdbeExpandSql(v, v->zSql);  assert( v->db->init.busy==0 );  if( zExpanded ){  sqlite3GlobalConfig.xSqllog(  sqlite3GlobalConfig.pSqllogArg, v->db, zExpanded, 1  );  sqlite3DbFree(v->db, zExpanded);  }  } }
#else
# define vdbeInvokeSqllog(x)
#endif
SQLITE_PRIVATE int sqlite3VdbeReset(Vdbe *p){
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
 int i;
#endif
 sqlite3 *db;  db = p->db;  sqlite3VdbeHalt(p);  if( p->pc>=0 ){  vdbeInvokeSqllog(p);  if( db->pErr || p->zErrMsg ){  sqlite3VdbeTransferError(p);  }else{  db->errCode = p->rc;  }  if( p->runOnlyOnce ) p->expired = 1;  }else if( p->rc && p->expired ){  sqlite3ErrorWithMsg(db, p->rc, p->zErrMsg ? "%s" : 0, p->zErrMsg);  }
#ifdef SQLITE_DEBUG
 if( p->apCsr ) for(i=0; i<p->nCursor; i++) assert( p->apCsr[i]==0 );  if( p->aMem ){  for(i=0; i<p->nMem; i++) assert( p->aMem[i].flags==MEM_Undefined );  }
#endif
 if( p->zErrMsg ){  sqlite3DbFree(db, p->zErrMsg);  p->zErrMsg = 0;  }  p->pResultSet = 0;
#ifdef SQLITE_DEBUG
 p->nWrite = 0;
#endif
#ifdef VDBE_PROFILE
 {  FILE *out = fopen("vdbe_profile.out", "a");  if( out ){  fprintf(out, "---- ");  for(i=0; i<p->nOp; i++){  fprintf(out, "%02x", p->aOp[i].opcode);  }  fprintf(out, "\n");  if( p->zSql ){  char c, pc = 0;  fprintf(out, "-- ");  for(i=0; (c = p->zSql[i])!=0; i++){  if( pc=='\n' ) fprintf(out, "-- ");  putc(c, out);  pc = c;  }  if( pc!='\n' ) fprintf(out, "\n");  }  for(i=0; i<p->nOp; i++){  char zHdr[100];  sqlite3_snprintf(sizeof(zHdr), zHdr, "%6u %12llu %8llu ",   p->aOp[i].cnt,   p->aOp[i].cycles,   p->aOp[i].cnt>0 ? p->aOp[i].cycles/p->aOp[i].cnt : 0  );  fprintf(out, "%s", zHdr);  sqlite3VdbePrintOp(out, i, &p->aOp[i]);  }  fclose(out);  }  }
#endif
 p->iVdbeMagic = VDBE_MAGIC_RESET;  return p->rc & db->errMask; } SQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe *p){  int rc = SQLITE_OK;  if( p->iVdbeMagic==VDBE_MAGIC_RUN || p->iVdbeMagic==VDBE_MAGIC_HALT ){  rc = sqlite3VdbeReset(p);  assert( (rc & p->db->errMask)==rc );  }  sqlite3VdbeDelete(p);  return rc; } SQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){  while( *pp ){  AuxData *pAux = *pp;  if( (iOp<0)   || (pAux->iAuxOp==iOp  && pAux->iAuxArg>=0  && (pAux->iAuxArg>31 || !(mask & MASKBIT32(pAux->iAuxArg))))  ){  testcase( pAux->iAuxArg==31 );  if( pAux->xDeleteAux ){  pAux->xDeleteAux(pAux->pAux);  }  *pp = pAux->pNextAux;  sqlite3DbFree(db, pAux);  }else{  pp= &pAux->pNextAux;  }  } } SQLITE_PRIVATE void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){  SubProgram *pSub, *pNext;  assert( p->db==0 || p->db==db );  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);  for(pSub=p->pProgram; pSub; pSub=pNext){  pNext = pSub->pNext;  vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);  sqlite3DbFree(db, pSub);  }  if( p->iVdbeMagic!=VDBE_MAGIC_INIT ){  releaseMemArray(p->aVar, p->nVar);  sqlite3DbFree(db, p->pVList);  sqlite3DbFree(db, p->pFree);  }  vdbeFreeOpArray(db, p->aOp, p->nOp);  sqlite3DbFree(db, p->aColName);  sqlite3DbFree(db, p->zSql);
#ifdef SQLITE_ENABLE_NORMALIZE
 sqlite3DbFree(db, p->zNormSql);  {  DblquoteStr *pThis, *pNext;  for(pThis=p->pDblStr; pThis; pThis=pNext){  pNext = pThis->pNextStr;  sqlite3DbFree(db, pThis);  }  }
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 {  int i;  for(i=0; i<p->nScan; i++){  sqlite3DbFree(db, p->aScan[i].zName);  }  sqlite3DbFree(db, p->aScan);  }
#endif
} SQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p){  sqlite3 *db;  assert( p!=0 );  db = p->db;  assert( sqlite3_mutex_held(db->mutex) );  sqlite3VdbeClearObject(db, p);  if( p->pPrev ){  p->pPrev->pNext = p->pNext;  }else{  assert( db->pVdbe==p );  db->pVdbe = p->pNext;  }  if( p->pNext ){  p->pNext->pPrev = p->pPrev;  }  p->iVdbeMagic = VDBE_MAGIC_DEAD;  p->db = 0;  sqlite3DbFreeNN(db, p); } SQLITE_PRIVATE int SQLITE_NOINLINE sqlite3VdbeFinishMoveto(VdbeCursor *p){  int res, rc;
#ifdef SQLITE_TEST
 extern int sqlite3_search_count;
#endif
 assert( p->deferredMoveto );  assert( p->isTable );  assert( p->eCurType==CURTYPE_BTREE );  rc = sqlite3BtreeTableMoveto(p->uc.pCursor, p->movetoTarget, 0, &res);  if( rc ) return rc;  if( res!=0 ) return SQLITE_CORRUPT_BKPT;
#ifdef SQLITE_TEST
 sqlite3_search_count++;
#endif
 p->deferredMoveto = 0;  p->cacheStatus = CACHE_STALE;  return SQLITE_OK; } static int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p){  int isDifferentRow, rc;  assert( p->eCurType==CURTYPE_BTREE );  assert( p->uc.pCursor!=0 );  assert( sqlite3BtreeCursorHasMoved(p->uc.pCursor) );  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);  p->cacheStatus = CACHE_STALE;  if( isDifferentRow ) p->nullRow = 1;  return rc; } SQLITE_PRIVATE int sqlite3VdbeCursorRestore(VdbeCursor *p){  assert( p->eCurType==CURTYPE_BTREE );  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){  return handleMovedCursor(p);  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor **pp, u32 *piCol){  VdbeCursor *p = *pp;  assert( p->eCurType==CURTYPE_BTREE || p->eCurType==CURTYPE_PSEUDO );  if( p->deferredMoveto ){  u32 iMap;  assert( !p->isEphemeral );  if( p->aAltMap && (iMap = p->aAltMap[1+*piCol])>0 && !p->nullRow ){  *pp = p->pAltCursor;  *piCol = iMap - 1;  return SQLITE_OK;  }  return sqlite3VdbeFinishMoveto(p);  }  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){  return handleMovedCursor(p);  }  return SQLITE_OK; }
#if 0
SQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem *pMem, int file_format, u32 *pLen){  int flags = pMem->flags;  u32 n;  assert( pLen!=0 );  if( flags&MEM_Null ){  *pLen = 0;  return 0;  }  if( flags&(MEM_Int|MEM_IntReal) ){
#  define MAX_6BYTE ((((i64)0x00008000)<<32)-1)
 i64 i = pMem->u.i;  u64 u;  testcase( flags & MEM_Int );  testcase( flags & MEM_IntReal );  if( i<0 ){  u = ~i;  }else{  u = i;  }  if( u<=127 ){  if( (i&1)==i && file_format>=4 ){  *pLen = 0;  return 8+(u32)u;  }else{  *pLen = 1;  return 1;  }  }  if( u<=32767 ){ *pLen = 2; return 2; }  if( u<=8388607 ){ *pLen = 3; return 3; }  if( u<=2147483647 ){ *pLen = 4; return 4; }  if( u<=MAX_6BYTE ){ *pLen = 6; return 5; }  *pLen = 8;  if( flags&MEM_IntReal ){  pMem->u.r = (double)pMem->u.i;  pMem->flags &= ~MEM_IntReal;  pMem->flags |= MEM_Real;  return 7;  }  return 6;  }  if( flags&MEM_Real ){  *pLen = 8;  return 7;  }  assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) );  assert( pMem->n>=0 );  n = (u32)pMem->n;  if( flags & MEM_Zero ){  n += pMem->u.nZero;  }  *pLen = n;  return ((n*2) + 12 + ((flags&MEM_Str)!=0)); }
#endif
static const u8 sqlite3SmallTypeSizes[] = {   0, 1, 2, 3, 4, 6, 8, 8, 0, 0,   0, 0, 0, 0, 1, 1, 2, 2, 3, 3,   4, 4, 5, 5, 6, 6, 7, 7, 8, 8,   9, 9, 10, 10, 11, 11, 12, 12, 13, 13,  14, 14, 15, 15, 16, 16, 17, 17, 18, 18,  19, 19, 20, 20, 21, 21, 22, 22, 23, 23,  24, 24, 25, 25, 26, 26, 27, 27, 28, 28,  29, 29, 30, 30, 31, 31, 32, 32, 33, 33,  34, 34, 35, 35, 36, 36, 37, 37, 38, 38,  39, 39, 40, 40, 41, 41, 42, 42, 43, 43,  44, 44, 45, 45, 46, 46, 47, 47, 48, 48,  49, 49, 50, 50, 51, 51, 52, 52, 53, 53,  54, 54, 55, 55, 56, 56, 57, 57 }; SQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32 serial_type){  if( serial_type>=128 ){  return (serial_type-12)/2;  }else{  assert( serial_type<12  || sqlite3SmallTypeSizes[serial_type]==(serial_type - 12)/2 );  return sqlite3SmallTypeSizes[serial_type];  } } SQLITE_PRIVATE u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){  assert( serial_type<128 );  return sqlite3SmallTypeSizes[serial_type]; }
#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT
static u64 floatSwap(u64 in){  union {  u64 r;  u32 i[2];  } u;  u32 t;  u.r = in;  t = u.i[0];  u.i[0] = u.i[1];  u.i[1] = t;  return u.r; }
# define swapMixedEndianFloat(X) X = floatSwap(X)
#else
# define swapMixedEndianFloat(X)
#endif
SQLITE_PRIVATE u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){  u32 len;  if( serial_type<=7 && serial_type>0 ){  u64 v;  u32 i;  if( serial_type==7 ){  assert( sizeof(v)==sizeof(pMem->u.r) );  memcpy(&v, &pMem->u.r, sizeof(v));  swapMixedEndianFloat(v);  }else{  v = pMem->u.i;  }  len = i = sqlite3SmallTypeSizes[serial_type];  assert( i>0 );  do{  buf[--i] = (u8)(v&0xFF);  v >>= 8;  }while( i );  return len;  }  if( serial_type>=12 ){  assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0)   == (int)sqlite3VdbeSerialTypeLen(serial_type) );  len = pMem->n;  if( len>0 ) memcpy(buf, pMem->z, len);  return len;  }  return 0; }
#define ONE_BYTE_INT(x) ((i8)(x)[0])
#define TWO_BYTE_INT(x) (256*(i8)((x)[0])|(x)[1])
#define THREE_BYTE_INT(x) (65536*(i8)((x)[0])|((x)[1]<<8)|(x)[2])
#define FOUR_BYTE_UINT(x) (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
#define FOUR_BYTE_INT(x) (16777216*(i8)((x)[0])|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
static u32 serialGet(  const unsigned char *buf,  u32 serial_type,  Mem *pMem ){  u64 x = FOUR_BYTE_UINT(buf);  u32 y = FOUR_BYTE_UINT(buf+4);  x = (x<<32) + y;  if( serial_type==6 ){  pMem->u.i = *(i64*)&x;  pMem->flags = MEM_Int;  testcase( pMem->u.i<0 );  }else{
#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)
 static const u64 t1 = ((u64)0x3ff00000)<<32;  static const double r1 = 1.0;  u64 t2 = t1;  swapMixedEndianFloat(t2);  assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );
#endif
 assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );  swapMixedEndianFloat(x);  memcpy(&pMem->u.r, &x, sizeof(x));  pMem->flags = IsNaN(x) ? MEM_Null : MEM_Real;  }  return 8; } SQLITE_PRIVATE u32 sqlite3VdbeSerialGet(  const unsigned char *buf,  u32 serial_type,  Mem *pMem ){  switch( serial_type ){  case 10: {  pMem->flags = MEM_Null|MEM_Zero;  pMem->n = 0;  pMem->u.nZero = 0;  break;  }  case 11:  case 0: {  pMem->flags = MEM_Null;  break;  }  case 1: {  pMem->u.i = ONE_BYTE_INT(buf);  pMem->flags = MEM_Int;  testcase( pMem->u.i<0 );  return 1;  }  case 2: {  pMem->u.i = TWO_BYTE_INT(buf);  pMem->flags = MEM_Int;  testcase( pMem->u.i<0 );  return 2;  }  case 3: {  pMem->u.i = THREE_BYTE_INT(buf);  pMem->flags = MEM_Int;  testcase( pMem->u.i<0 );  return 3;  }  case 4: {  pMem->u.i = FOUR_BYTE_INT(buf);
#ifdef __HP_cc
 if( buf[0]&0x80 ) pMem->u.i |= 0xffffffff80000000LL;
#endif
 pMem->flags = MEM_Int;  testcase( pMem->u.i<0 );  return 4;  }  case 5: {  pMem->u.i = FOUR_BYTE_UINT(buf+2) + (((i64)1)<<32)*TWO_BYTE_INT(buf);  pMem->flags = MEM_Int;  testcase( pMem->u.i<0 );  return 6;  }  case 6:  case 7: {  return serialGet(buf,serial_type,pMem);  }  case 8:  case 9: {  pMem->u.i = serial_type-8;  pMem->flags = MEM_Int;  return 0;  }  default: {  static const u16 aFlag[] = { MEM_Blob|MEM_Ephem, MEM_Str|MEM_Ephem };  pMem->z = (char *)buf;  pMem->n = (serial_type-12)/2;  pMem->flags = aFlag[serial_type&1];  return pMem->n;  }  }  return 0; } SQLITE_PRIVATE UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(  KeyInfo *pKeyInfo ){  UnpackedRecord *p;  int nByte;  nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nKeyField+1);  p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);  if( !p ) return 0;  p->aMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];  assert( pKeyInfo->aSortFlags!=0 );  p->pKeyInfo = pKeyInfo;  p->nField = pKeyInfo->nKeyField + 1;  return p; } SQLITE_PRIVATE void sqlite3VdbeRecordUnpack(  KeyInfo *pKeyInfo,  int nKey,  const void *pKey,  UnpackedRecord *p ){  const unsigned char *aKey = (const unsigned char *)pKey;  u32 d;  u32 idx;  u16 u;  u32 szHdr;  Mem *pMem = p->aMem;  p->default_rc = 0;  assert( EIGHT_BYTE_ALIGNMENT(pMem) );  idx = getVarint32(aKey, szHdr);  d = szHdr;  u = 0;  while( idx<szHdr && d<=(u32)nKey ){  u32 serial_type;  idx += getVarint32(&aKey[idx], serial_type);  pMem->enc = pKeyInfo->enc;  pMem->db = pKeyInfo->db;  pMem->szMalloc = 0;  pMem->z = 0;  d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);  pMem++;  if( (++u)>=p->nField ) break;  }  if( d>(u32)nKey && u ){  assert( CORRUPT_DB );  sqlite3VdbeMemSetNull(pMem-1);  }  assert( u<=pKeyInfo->nKeyField + 1 );  p->nField = u; }
#ifdef SQLITE_DEBUG
static int vdbeRecordCompareDebug(  int nKey1, const void *pKey1,  const UnpackedRecord *pPKey2,  int desiredResult ){  u32 d1;  u32 idx1;  u32 szHdr1;  int i = 0;  int rc = 0;  const unsigned char *aKey1 = (const unsigned char *)pKey1;  KeyInfo *pKeyInfo;  Mem mem1;  pKeyInfo = pPKey2->pKeyInfo;  if( pKeyInfo->db==0 ) return 1;  mem1.enc = pKeyInfo->enc;  mem1.db = pKeyInfo->db;  VVA_ONLY( mem1.szMalloc = 0; )  idx1 = getVarint32(aKey1, szHdr1);  if( szHdr1>98307 ) return SQLITE_CORRUPT;  d1 = szHdr1;  assert( pKeyInfo->nAllField>=pPKey2->nField || CORRUPT_DB );  assert( pKeyInfo->aSortFlags!=0 );  assert( pKeyInfo->nKeyField>0 );  assert( idx1<=szHdr1 || CORRUPT_DB );  do{  u32 serial_type1;  idx1 += getVarint32( aKey1+idx1, serial_type1 );  if( d1+(u64)serial_type1+2>(u64)nKey1   && d1+(u64)sqlite3VdbeSerialTypeLen(serial_type1)>(u64)nKey1  ){  break;  }  d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);  rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],   pKeyInfo->nAllField>i ? pKeyInfo->aColl[i] : 0);  if( rc!=0 ){  assert( mem1.szMalloc==0 );  if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)   && ((mem1.flags & MEM_Null) || (pPKey2->aMem[i].flags & MEM_Null))  ){  rc = -rc;  }  if( pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC ){  rc = -rc;  }  goto debugCompareEnd;  }  i++;  }while( idx1<szHdr1 && i<pPKey2->nField );  assert( mem1.szMalloc==0 );  rc = pPKey2->default_rc; debugCompareEnd:  if( desiredResult==0 && rc==0 ) return 1;  if( desiredResult<0 && rc<0 ) return 1;  if( desiredResult>0 && rc>0 ) return 1;  if( CORRUPT_DB ) return 1;  if( pKeyInfo->db->mallocFailed ) return 1;  return 0; }
#endif
#ifdef SQLITE_DEBUG
static void vdbeAssertFieldCountWithinLimits(  int nKey, const void *pKey,  const KeyInfo *pKeyInfo ){  int nField = 0;  u32 szHdr;  u32 idx;  u32 notUsed;  const unsigned char *aKey = (const unsigned char*)pKey;  if( CORRUPT_DB ) return;  idx = getVarint32(aKey, szHdr);  assert( nKey>=0 );  assert( szHdr<=(u32)nKey );  while( idx<szHdr ){  idx += getVarint32(aKey+idx, notUsed);  nField++;  }  assert( nField <= pKeyInfo->nAllField ); }
#else
# define vdbeAssertFieldCountWithinLimits(A,B,C)
#endif
static int vdbeCompareMemString(  const Mem *pMem1,  const Mem *pMem2,  const CollSeq *pColl,  u8 *prcErr ){  if( pMem1->enc==pColl->enc ){  return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);  }else{  int rc;  const void *v1, *v2;  Mem c1;  Mem c2;  sqlite3VdbeMemInit(&c1, pMem1->db, MEM_Null);  sqlite3VdbeMemInit(&c2, pMem1->db, MEM_Null);  sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);  sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);  v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);  v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);  if( (v1==0 || v2==0) ){  if( prcErr ) *prcErr = SQLITE_NOMEM_BKPT;  rc = 0;  }else{  rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);  }  sqlite3VdbeMemRelease(&c1);  sqlite3VdbeMemRelease(&c2);  return rc;  } } static int isAllZero(const char *z, int n){  int i;  for(i=0; i<n; i++){  if( z[i] ) return 0;  }  return 1; } SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){  int c;  int n1 = pB1->n;  int n2 = pB2->n;  assert( (pB1->flags & MEM_Zero)==0 || n1==0 );  assert( (pB2->flags & MEM_Zero)==0 || n2==0 );  if( (pB1->flags|pB2->flags) & MEM_Zero ){  if( pB1->flags & pB2->flags & MEM_Zero ){  return pB1->u.nZero - pB2->u.nZero;  }else if( pB1->flags & MEM_Zero ){  if( !isAllZero(pB2->z, pB2->n) ) return -1;  return pB1->u.nZero - n2;  }else{  if( !isAllZero(pB1->z, pB1->n) ) return +1;  return n1 - pB2->u.nZero;  }  }  c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);  if( c ) return c;  return n1 - n2; } SQLITE_PRIVATE int sqlite3IntFloatCompare(i64 i, double r){  if( sizeof(LONGDOUBLE_TYPE)>8 ){  LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;  testcase( x<r );  testcase( x>r );  testcase( x==r );  if( x<r ) return -1;  if( x>r ) return +1;  return 0;  }else{  i64 y;  double s;  if( r<-9223372036854775808.0 ) return +1;  if( r>=9223372036854775808.0 ) return -1;  y = (i64)r;  if( i<y ) return -1;  if( i>y ) return +1;  s = (double)i;  if( s<r ) return -1;  if( s>r ) return +1;  return 0;  } } SQLITE_PRIVATE int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){  int f1, f2;  int combined_flags;  f1 = pMem1->flags;  f2 = pMem2->flags;  combined_flags = f1|f2;  assert( !sqlite3VdbeMemIsRowSet(pMem1) && !sqlite3VdbeMemIsRowSet(pMem2) );  if( combined_flags&MEM_Null ){  return (f2&MEM_Null) - (f1&MEM_Null);  }  if( combined_flags&(MEM_Int|MEM_Real|MEM_IntReal) ){  testcase( combined_flags & MEM_Int );  testcase( combined_flags & MEM_Real );  testcase( combined_flags & MEM_IntReal );  if( (f1 & f2 & (MEM_Int|MEM_IntReal))!=0 ){  testcase( f1 & f2 & MEM_Int );  testcase( f1 & f2 & MEM_IntReal );  if( pMem1->u.i < pMem2->u.i ) return -1;  if( pMem1->u.i > pMem2->u.i ) return +1;  return 0;  }  if( (f1 & f2 & MEM_Real)!=0 ){  if( pMem1->u.r < pMem2->u.r ) return -1;  if( pMem1->u.r > pMem2->u.r ) return +1;  return 0;  }  if( (f1&(MEM_Int|MEM_IntReal))!=0 ){  testcase( f1 & MEM_Int );  testcase( f1 & MEM_IntReal );  if( (f2&MEM_Real)!=0 ){  return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);  }else if( (f2&(MEM_Int|MEM_IntReal))!=0 ){  if( pMem1->u.i < pMem2->u.i ) return -1;  if( pMem1->u.i > pMem2->u.i ) return +1;  return 0;  }else{  return -1;  }  }  if( (f1&MEM_Real)!=0 ){  if( (f2&(MEM_Int|MEM_IntReal))!=0 ){  testcase( f2 & MEM_Int );  testcase( f2 & MEM_IntReal );  return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);  }else{  return -1;  }  }  return +1;  }  if( combined_flags&MEM_Str ){  if( (f1 & MEM_Str)==0 ){  return 1;  }  if( (f2 & MEM_Str)==0 ){  return -1;  }  assert( pMem1->enc==pMem2->enc || pMem1->db->mallocFailed );  assert( pMem1->enc==SQLITE_UTF8 ||  pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );  assert( !pColl || pColl->xCmp );  if( pColl ){  return vdbeCompareMemString(pMem1, pMem2, pColl, 0);  }  }  return sqlite3BlobCompare(pMem1, pMem2); } static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){  u32 y;  assert( CORRUPT_DB || (serial_type>=1 && serial_type<=9 && serial_type!=7) );  switch( serial_type ){  case 0:  case 1:  testcase( aKey[0]&0x80 );  return ONE_BYTE_INT(aKey);  case 2:  testcase( aKey[0]&0x80 );  return TWO_BYTE_INT(aKey);  case 3:  testcase( aKey[0]&0x80 );  return THREE_BYTE_INT(aKey);  case 4: {  testcase( aKey[0]&0x80 );  y = FOUR_BYTE_UINT(aKey);  return (i64)*(int*)&y;  }  case 5: {  testcase( aKey[0]&0x80 );  return FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);  }  case 6: {  u64 x = FOUR_BYTE_UINT(aKey);  testcase( aKey[0]&0x80 );  x = (x<<32) | FOUR_BYTE_UINT(aKey+4);  return (i64)*(i64*)&x;  }  }  return (serial_type - 8); } SQLITE_PRIVATE int sqlite3VdbeRecordCompareWithSkip(  int nKey1, const void *pKey1,  UnpackedRecord *pPKey2,  int bSkip ){  u32 d1;  int i;  u32 szHdr1;  u32 idx1;  int rc = 0;  Mem *pRhs = pPKey2->aMem;  KeyInfo *pKeyInfo;  const unsigned char *aKey1 = (const unsigned char *)pKey1;  Mem mem1;  if( bSkip ){  u32 s1;  idx1 = 1 + getVarint32(&aKey1[1], s1);  szHdr1 = aKey1[0];  d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);  i = 1;  pRhs++;  }else{  idx1 = getVarint32(aKey1, szHdr1);  d1 = szHdr1;  i = 0;  }  if( d1>(unsigned)nKey1 ){  pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;  return 0;  }  VVA_ONLY( mem1.szMalloc = 0; )  assert( pPKey2->pKeyInfo->nAllField>=pPKey2->nField   || CORRUPT_DB );  assert( pPKey2->pKeyInfo->aSortFlags!=0 );  assert( pPKey2->pKeyInfo->nKeyField>0 );  assert( idx1<=szHdr1 || CORRUPT_DB );  do{  u32 serial_type;  if( pRhs->flags & (MEM_Int|MEM_IntReal) ){  testcase( pRhs->flags & MEM_Int );  testcase( pRhs->flags & MEM_IntReal );  serial_type = aKey1[idx1];  testcase( serial_type==12 );  if( serial_type>=10 ){  rc = +1;  }else if( serial_type==0 ){  rc = -1;  }else if( serial_type==7 ){  sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);  rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);  }else{  i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);  i64 rhs = pRhs->u.i;  if( lhs<rhs ){  rc = -1;  }else if( lhs>rhs ){  rc = +1;  }  }  }  else if( pRhs->flags & MEM_Real ){  serial_type = aKey1[idx1];  if( serial_type>=10 ){  rc = +1;  }else if( serial_type==0 ){  rc = -1;  }else{  sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);  if( serial_type==7 ){  if( mem1.u.r<pRhs->u.r ){  rc = -1;  }else if( mem1.u.r>pRhs->u.r ){  rc = +1;  }  }else{  rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);  }  }  }  else if( pRhs->flags & MEM_Str ){  getVarint32NR(&aKey1[idx1], serial_type);  testcase( serial_type==12 );  if( serial_type<12 ){  rc = -1;  }else if( !(serial_type & 0x01) ){  rc = +1;  }else{  mem1.n = (serial_type - 12) / 2;  testcase( (d1+mem1.n)==(unsigned)nKey1 );  testcase( (d1+mem1.n+1)==(unsigned)nKey1 );  if( (d1+mem1.n) > (unsigned)nKey1   || (pKeyInfo = pPKey2->pKeyInfo)->nAllField<=i  ){  pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;  return 0;  }else if( pKeyInfo->aColl[i] ){  mem1.enc = pKeyInfo->enc;  mem1.db = pKeyInfo->db;  mem1.flags = MEM_Str;  mem1.z = (char*)&aKey1[d1];  rc = vdbeCompareMemString(  &mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode  );  }else{  int nCmp = MIN(mem1.n, pRhs->n);  rc = memcmp(&aKey1[d1], pRhs->z, nCmp);  if( rc==0 ) rc = mem1.n - pRhs->n;  }  }  }  else if( pRhs->flags & MEM_Blob ){  assert( (pRhs->flags & MEM_Zero)==0 || pRhs->n==0 );  getVarint32NR(&aKey1[idx1], serial_type);  testcase( serial_type==12 );  if( serial_type<12 || (serial_type & 0x01) ){  rc = -1;  }else{  int nStr = (serial_type - 12) / 2;  testcase( (d1+nStr)==(unsigned)nKey1 );  testcase( (d1+nStr+1)==(unsigned)nKey1 );  if( (d1+nStr) > (unsigned)nKey1 ){  pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;  return 0;  }else if( pRhs->flags & MEM_Zero ){  if( !isAllZero((const char*)&aKey1[d1],nStr) ){  rc = 1;  }else{  rc = nStr - pRhs->u.nZero;  }  }else{  int nCmp = MIN(nStr, pRhs->n);  rc = memcmp(&aKey1[d1], pRhs->z, nCmp);  if( rc==0 ) rc = nStr - pRhs->n;  }  }  }  else{  serial_type = aKey1[idx1];  rc = (serial_type!=0);  }  if( rc!=0 ){  int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];  if( sortFlags ){  if( (sortFlags & KEYINFO_ORDER_BIGNULL)==0   || ((sortFlags & KEYINFO_ORDER_DESC)   !=(serial_type==0 || (pRhs->flags&MEM_Null)))  ){  rc = -rc;  }  }  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, rc) );  assert( mem1.szMalloc==0 );  return rc;  }  i++;  if( i==pPKey2->nField ) break;  pRhs++;  d1 += sqlite3VdbeSerialTypeLen(serial_type);  idx1 += sqlite3VarintLen(serial_type);  }while( idx1<(unsigned)szHdr1 && d1<=(unsigned)nKey1 );  assert( mem1.szMalloc==0 );  assert( CORRUPT_DB   || vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, pPKey2->default_rc)   || pPKey2->pKeyInfo->db->mallocFailed  );  pPKey2->eqSeen = 1;  return pPKey2->default_rc; } SQLITE_PRIVATE int sqlite3VdbeRecordCompare(  int nKey1, const void *pKey1,  UnpackedRecord *pPKey2 ){  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0); } static int vdbeRecordCompareInt(  int nKey1, const void *pKey1,  UnpackedRecord *pPKey2 ){  const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];  int serial_type = ((const u8*)pKey1)[1];  int res;  u32 y;  u64 x;  i64 v;  i64 lhs;  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);  assert( (*(u8*)pKey1)<=0x3F || CORRUPT_DB );  switch( serial_type ){  case 1: {  lhs = ONE_BYTE_INT(aKey);  testcase( lhs<0 );  break;  }  case 2: {  lhs = TWO_BYTE_INT(aKey);  testcase( lhs<0 );  break;  }  case 3: {  lhs = THREE_BYTE_INT(aKey);  testcase( lhs<0 );  break;  }  case 4: {  y = FOUR_BYTE_UINT(aKey);  lhs = (i64)*(int*)&y;  testcase( lhs<0 );  break;  }  case 5: {  lhs = FOUR_BYTE_UINT(aKey+2) + (((i64)1)<<32)*TWO_BYTE_INT(aKey);  testcase( lhs<0 );  break;  }  case 6: {  x = FOUR_BYTE_UINT(aKey);  x = (x<<32) | FOUR_BYTE_UINT(aKey+4);  lhs = *(i64*)&x;  testcase( lhs<0 );  break;  }  case 8:  lhs = 0;  break;  case 9:  lhs = 1;  break;  case 0: case 7:  return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);  default:  return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);  }  v = pPKey2->aMem[0].u.i;  if( v>lhs ){  res = pPKey2->r1;  }else if( v<lhs ){  res = pPKey2->r2;  }else if( pPKey2->nField>1 ){  res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);  }else{  res = pPKey2->default_rc;  pPKey2->eqSeen = 1;  }  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res) );  return res; } static int vdbeRecordCompareString(  int nKey1, const void *pKey1,  UnpackedRecord *pPKey2 ){  const u8 *aKey1 = (const u8*)pKey1;  int serial_type;  int res;  assert( pPKey2->aMem[0].flags & MEM_Str );  vdbeAssertFieldCountWithinLimits(nKey1, pKey1, pPKey2->pKeyInfo);  serial_type = (u8)(aKey1[1]);  if( serial_type >= 0x80 ){  sqlite3GetVarint32(&aKey1[1], (u32*)&serial_type);  }  if( serial_type<12 ){  res = pPKey2->r1;  }else if( !(serial_type & 0x01) ){  res = pPKey2->r2;  }else{  int nCmp;  int nStr;  int szHdr = aKey1[0];  nStr = (serial_type-12) / 2;  if( (szHdr + nStr) > nKey1 ){  pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;  return 0;  }  nCmp = MIN( pPKey2->aMem[0].n, nStr );  res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);  if( res>0 ){  res = pPKey2->r2;  }else if( res<0 ){  res = pPKey2->r1;  }else{  res = nStr - pPKey2->aMem[0].n;  if( res==0 ){  if( pPKey2->nField>1 ){  res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);  }else{  res = pPKey2->default_rc;  pPKey2->eqSeen = 1;  }  }else if( res>0 ){  res = pPKey2->r2;  }else{  res = pPKey2->r1;  }  }  }  assert( vdbeRecordCompareDebug(nKey1, pKey1, pPKey2, res)   || CORRUPT_DB   || pPKey2->pKeyInfo->db->mallocFailed  );  return res; } SQLITE_PRIVATE RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){  if( p->pKeyInfo->nAllField<=13 ){  int flags = p->aMem[0].flags;  if( p->pKeyInfo->aSortFlags[0] ){  if( p->pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL ){  return sqlite3VdbeRecordCompare;  }  p->r1 = 1;  p->r2 = -1;  }else{  p->r1 = -1;  p->r2 = 1;  }  if( (flags & MEM_Int) ){  return vdbeRecordCompareInt;  }  testcase( flags & MEM_Real );  testcase( flags & MEM_Null );  testcase( flags & MEM_Blob );  if( (flags & (MEM_Real|MEM_IntReal|MEM_Null|MEM_Blob))==0   && p->pKeyInfo->aColl[0]==0  ){  assert( flags & MEM_Str );  return vdbeRecordCompareString;  }  }  return sqlite3VdbeRecordCompare; } SQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){  i64 nCellKey = 0;  int rc;  u32 szHdr;  u32 typeRowid;  u32 lenRowid;  Mem m, v;  assert( sqlite3BtreeCursorIsValid(pCur) );  nCellKey = sqlite3BtreePayloadSize(pCur);  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );  sqlite3VdbeMemInit(&m, db, 0);  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);  if( rc ){  return rc;  }  getVarint32NR((u8*)m.z, szHdr);  testcase( szHdr==3 );  testcase( szHdr==(u32)m.n );  testcase( szHdr>0x7fffffff );  assert( m.n>=0 );  if( unlikely(szHdr<3 || szHdr>(unsigned)m.n) ){  goto idx_rowid_corruption;  }  getVarint32NR((u8*)&m.z[szHdr-1], typeRowid);  testcase( typeRowid==1 );  testcase( typeRowid==2 );  testcase( typeRowid==3 );  testcase( typeRowid==4 );  testcase( typeRowid==5 );  testcase( typeRowid==6 );  testcase( typeRowid==8 );  testcase( typeRowid==9 );  if( unlikely(typeRowid<1 || typeRowid>9 || typeRowid==7) ){  goto idx_rowid_corruption;  }  lenRowid = sqlite3SmallTypeSizes[typeRowid];  testcase( (u32)m.n==szHdr+lenRowid );  if( unlikely((u32)m.n<szHdr+lenRowid) ){  goto idx_rowid_corruption;  }  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);  *rowid = v.u.i;  sqlite3VdbeMemRelease(&m);  return SQLITE_OK; idx_rowid_corruption:  testcase( m.szMalloc!=0 );  sqlite3VdbeMemRelease(&m);  return SQLITE_CORRUPT_BKPT; } SQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(  sqlite3 *db,  VdbeCursor *pC,  UnpackedRecord *pUnpacked,  int *res ){  i64 nCellKey = 0;  int rc;  BtCursor *pCur;  Mem m;  assert( pC->eCurType==CURTYPE_BTREE );  pCur = pC->uc.pCursor;  assert( sqlite3BtreeCursorIsValid(pCur) );  nCellKey = sqlite3BtreePayloadSize(pCur);  if( nCellKey<=0 || nCellKey>0x7fffffff ){  *res = 0;  return SQLITE_CORRUPT_BKPT;  }  sqlite3VdbeMemInit(&m, db, 0);  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);  if( rc ){  return rc;  }  *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);  sqlite3VdbeMemRelease(&m);  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, i64 nChange){  assert( sqlite3_mutex_held(db->mutex) );  db->nChange = nChange;  db->nTotalChange += nChange; } SQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe *v){  v->changeCntOn = 1; } SQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){  Vdbe *p;  for(p = db->pVdbe; p; p=p->pNext){  p->expired = iCode+1;  } } SQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe *v){  return v->db; } SQLITE_PRIVATE u8 sqlite3VdbePrepareFlags(Vdbe *v){  return v->prepFlags; } SQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){  assert( iVar>0 );  if( v ){  Mem *pMem = &v->aVar[iVar-1];  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );  if( 0==(pMem->flags & MEM_Null) ){  sqlite3_value *pRet = sqlite3ValueNew(v->db);  if( pRet ){  sqlite3VdbeMemCopy((Mem *)pRet, pMem);  sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);  }  return pRet;  }  }  return 0; } SQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){  assert( iVar>0 );  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );  if( iVar>=32 ){  v->expmask |= 0x80000000;  }else{  v->expmask |= ((u32)1 << (iVar-1));  } } SQLITE_PRIVATE int sqlite3NotPureFunc(sqlite3_context *pCtx){  const VdbeOp *pOp;
#ifdef SQLITE_ENABLE_STAT4
 if( pCtx->pVdbe==0 ) return 1;
#endif
 pOp = pCtx->pVdbe->aOp + pCtx->iOp;  if( pOp->opcode==OP_PureFunc ){  const char *zContext;  char *zMsg;  if( pOp->p5 & NC_IsCheck ){  zContext = "a CHECK constraint";  }else if( pOp->p5 & NC_GenCol ){  zContext = "a generated column";  }else{  zContext = "an index";  }  zMsg = sqlite3_mprintf("non-deterministic use of %s() in %s",   pCtx->pFunc->zName, zContext);  sqlite3_result_error(pCtx, zMsg, -1);  sqlite3_free(zMsg);  return 0;  }  return 1; }
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){  if( pVtab->zErrMsg ){  sqlite3 *db = p->db;  sqlite3DbFree(db, p->zErrMsg);  p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);  sqlite3_free(pVtab->zErrMsg);  pVtab->zErrMsg = 0;  } }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
static void vdbeFreeUnpacked(sqlite3 *db, int nField, UnpackedRecord *p){  if( p ){  int i;  for(i=0; i<nField; i++){  Mem *pMem = &p->aMem[i];  if( pMem->zMalloc ) sqlite3VdbeMemRelease(pMem);  }  sqlite3DbFreeNN(db, p);  } }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_PRIVATE void sqlite3VdbePreUpdateHook(  Vdbe *v,  VdbeCursor *pCsr,  int op,  const char *zDb,  Table *pTab,  i64 iKey1,  int iReg,  int iBlobWrite ){  sqlite3 *db = v->db;  i64 iKey2;  PreUpdate preupdate;  const char *zTbl = pTab->zName;  static const u8 fakeSortOrder = 0;  assert( db->pPreUpdate==0 );  memset(&preupdate, 0, sizeof(PreUpdate));  if( HasRowid(pTab)==0 ){  iKey1 = iKey2 = 0;  preupdate.pPk = sqlite3PrimaryKeyIndex(pTab);  }else{  if( op==SQLITE_UPDATE ){  iKey2 = v->aMem[iReg].u.i;  }else{  iKey2 = iKey1;  }  }  assert( pCsr!=0 );  assert( pCsr->eCurType==CURTYPE_BTREE );  assert( pCsr->nField==pTab->nCol   || (pCsr->nField==pTab->nCol+1 && op==SQLITE_DELETE && iReg==-1)  );  preupdate.v = v;  preupdate.pCsr = pCsr;  preupdate.op = op;  preupdate.iNewReg = iReg;  preupdate.keyinfo.db = db;  preupdate.keyinfo.enc = ENC(db);  preupdate.keyinfo.nKeyField = pTab->nCol;  preupdate.keyinfo.aSortFlags = (u8*)&fakeSortOrder;  preupdate.iKey1 = iKey1;  preupdate.iKey2 = iKey2;  preupdate.pTab = pTab;  preupdate.iBlobWrite = iBlobWrite;  db->pPreUpdate = &preupdate;  db->xPreUpdateCallback(db->pPreUpdateArg, db, op, zDb, zTbl, iKey1, iKey2);  db->pPreUpdate = 0;  sqlite3DbFree(db, preupdate.aRecord);  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pUnpacked);  vdbeFreeUnpacked(db, preupdate.keyinfo.nKeyField+1, preupdate.pNewUnpacked);  if( preupdate.aNew ){  int i;  for(i=0; i<pCsr->nField; i++){  sqlite3VdbeMemRelease(&preupdate.aNew[i]);  }  sqlite3DbFreeNN(db, preupdate.aNew);  } }
#endif
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt){  Vdbe *p = (Vdbe*)pStmt;  return p==0 || p->expired; }
#endif
static int vdbeSafety(Vdbe *p){  if( p->db==0 ){  sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");  return 1;  }else{  return 0;  } } static int vdbeSafetyNotNull(Vdbe *p){  if( p==0 ){  sqlite3_log(SQLITE_MISUSE, "API called with NULL prepared statement");  return 1;  }else{  return vdbeSafety(p);  } }
#ifndef SQLITE_OMIT_TRACE
static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){  sqlite3_int64 iNow;  sqlite3_int64 iElapse;  assert( p->startTime>0 );  assert( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0 );  assert( db->init.busy==0 );  assert( p->zSql!=0 );  sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);  iElapse = (iNow - p->startTime)*1000000;
#ifndef SQLITE_OMIT_DEPRECATED
 if( db->xProfile ){  db->xProfile(db->pProfileArg, p->zSql, iElapse);  }
#endif
 if( db->mTrace & SQLITE_TRACE_PROFILE ){  db->trace.xV2(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);  }  p->startTime = 0; }
# define checkProfileCallback(DB,P)   if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }

#else
# define checkProfileCallback(DB,P)
#endif
SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){  int rc;  if( pStmt==0 ){  rc = SQLITE_OK;  }else{  Vdbe *v = (Vdbe*)pStmt;  sqlite3 *db = v->db;  if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;  sqlite3_mutex_enter(db->mutex);  checkProfileCallback(db, v);  rc = sqlite3VdbeFinalize(v);  rc = sqlite3ApiExit(db, rc);  sqlite3LeaveMutexAndCloseZombie(db);  }  return rc; } SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){  int rc;  if( pStmt==0 ){  rc = SQLITE_OK;  }else{  Vdbe *v = (Vdbe*)pStmt;  sqlite3 *db = v->db;  sqlite3_mutex_enter(db->mutex);  checkProfileCallback(db, v);  rc = sqlite3VdbeReset(v);  sqlite3VdbeRewind(v);  assert( (rc & (db->errMask))==rc );  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  }  return rc; } SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){  int i;  int rc = SQLITE_OK;  Vdbe *p = (Vdbe*)pStmt;
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex;
#endif
 sqlite3_mutex_enter(mutex);  for(i=0; i<p->nVar; i++){  sqlite3VdbeMemRelease(&p->aVar[i]);  p->aVar[i].flags = MEM_Null;  }  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );  if( p->expmask ){  p->expired = 1;  }  sqlite3_mutex_leave(mutex);  return rc; } SQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){  Mem *p = (Mem*)pVal;  if( p->flags & (MEM_Blob|MEM_Str) ){  if( ExpandBlob(p)!=SQLITE_OK ){  assert( p->flags==MEM_Null && p->z==0 );  return 0;  }  p->flags |= MEM_Blob;  return p->n ? p->z : 0;  }else{  return sqlite3_value_text(pVal);  } } SQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal){  return sqlite3ValueBytes(pVal, SQLITE_UTF8); } SQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal){  return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE); } SQLITE_API double sqlite3_value_double(sqlite3_value *pVal){  return sqlite3VdbeRealValue((Mem*)pVal); } SQLITE_API int sqlite3_value_int(sqlite3_value *pVal){  return (int)sqlite3VdbeIntValue((Mem*)pVal); } SQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){  return sqlite3VdbeIntValue((Mem*)pVal); } SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value *pVal){  Mem *pMem = (Mem*)pVal;  return ((pMem->flags & MEM_Subtype) ? pMem->eSubtype : 0); } SQLITE_API void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){  Mem *p = (Mem*)pVal;  if( (p->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==   (MEM_Null|MEM_Term|MEM_Subtype)   && zPType!=0   && p->eSubtype=='p'   && strcmp(p->u.zPType, zPType)==0  ){  return (void*)p->z;  }else{  return 0;  } } SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){  return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal){  return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE); } SQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal){  return sqlite3ValueText(pVal, SQLITE_UTF16BE); } SQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal){  return sqlite3ValueText(pVal, SQLITE_UTF16LE); }
#endif
SQLITE_API int sqlite3_value_type(sqlite3_value* pVal){  static const u8 aType[] = {   SQLITE_BLOB,   SQLITE_NULL,   SQLITE_TEXT,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_BLOB,   SQLITE_NULL,   SQLITE_TEXT,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_INTEGER,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_TEXT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_BLOB,   SQLITE_NULL,   SQLITE_TEXT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,   SQLITE_FLOAT,   SQLITE_NULL,  };
#ifdef SQLITE_DEBUG
 {  int eType = SQLITE_BLOB;  if( pVal->flags & MEM_Null ){  eType = SQLITE_NULL;  }else if( pVal->flags & (MEM_Real|MEM_IntReal) ){  eType = SQLITE_FLOAT;  }else if( pVal->flags & MEM_Int ){  eType = SQLITE_INTEGER;  }else if( pVal->flags & MEM_Str ){  eType = SQLITE_TEXT;  }  assert( eType == aType[pVal->flags&MEM_AffMask] );  }
#endif
 return aType[pVal->flags&MEM_AffMask]; } SQLITE_API int sqlite3_value_nochange(sqlite3_value *pVal){  return (pVal->flags&(MEM_Null|MEM_Zero))==(MEM_Null|MEM_Zero); } SQLITE_API int sqlite3_value_frombind(sqlite3_value *pVal){  return (pVal->flags&MEM_FromBind)!=0; } SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){  sqlite3_value *pNew;  if( pOrig==0 ) return 0;  pNew = sqlite3_malloc( sizeof(*pNew) );  if( pNew==0 ) return 0;  memset(pNew, 0, sizeof(*pNew));  memcpy(pNew, pOrig, MEMCELLSIZE);  pNew->flags &= ~MEM_Dyn;  pNew->db = 0;  if( pNew->flags&(MEM_Str|MEM_Blob) ){  pNew->flags &= ~(MEM_Static|MEM_Dyn);  pNew->flags |= MEM_Ephem;  if( sqlite3VdbeMemMakeWriteable(pNew)!=SQLITE_OK ){  sqlite3ValueFree(pNew);  pNew = 0;  }  }  return pNew; } SQLITE_API void sqlite3_value_free(sqlite3_value *pOld){  sqlite3ValueFree(pOld); } static void setResultStrOrError(  sqlite3_context *pCtx,  const char *z,  int n,  u8 enc,  void (*xDel)(void*) ){  int rc = sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel);  if( rc ){  if( rc==SQLITE_TOOBIG ){  sqlite3_result_error_toobig(pCtx);  }else{  assert( rc==SQLITE_NOMEM );  sqlite3_result_error_nomem(pCtx);  }  } } static int invokeValueDestructor(  const void *p,  void (*xDel)(void*),  sqlite3_context *pCtx ){  assert( xDel!=SQLITE_DYNAMIC );  if( xDel==0 ){  }else if( xDel==SQLITE_TRANSIENT ){  }else{  xDel((void*)p);  }  sqlite3_result_error_toobig(pCtx);  return SQLITE_TOOBIG; } SQLITE_API void sqlite3_result_blob(  sqlite3_context *pCtx,  const void *z,  int n,  void (*xDel)(void *) ){  assert( n>=0 );  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  setResultStrOrError(pCtx, z, n, 0, xDel); } SQLITE_API void sqlite3_result_blob64(  sqlite3_context *pCtx,  const void *z,  sqlite3_uint64 n,  void (*xDel)(void *) ){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  assert( xDel!=SQLITE_DYNAMIC );  if( n>0x7fffffff ){  (void)invokeValueDestructor(z, xDel, pCtx);  }else{  setResultStrOrError(pCtx, z, (int)n, 0, xDel);  } } SQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemSetDouble(pCtx->pOut, rVal); } SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  pCtx->isError = SQLITE_ERROR;  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  pCtx->isError = SQLITE_ERROR;  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT); }
#endif
SQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal); } SQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemSetInt64(pCtx->pOut, iVal); } SQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemSetNull(pCtx->pOut); } SQLITE_API void sqlite3_result_pointer(  sqlite3_context *pCtx,  void *pPtr,  const char *zPType,  void (*xDestructor)(void*) ){  Mem *pOut = pCtx->pOut;  assert( sqlite3_mutex_held(pOut->db->mutex) );  sqlite3VdbeMemRelease(pOut);  pOut->flags = MEM_Null;  sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor); } SQLITE_API void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){  Mem *pOut = pCtx->pOut;  assert( sqlite3_mutex_held(pOut->db->mutex) );  pOut->eSubtype = eSubtype & 0xff;  pOut->flags |= MEM_Subtype; } SQLITE_API void sqlite3_result_text(  sqlite3_context *pCtx,  const char *z,  int n,  void (*xDel)(void *) ){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel); } SQLITE_API void sqlite3_result_text64(  sqlite3_context *pCtx,  const char *z,  sqlite3_uint64 n,  void (*xDel)(void *),  unsigned char enc ){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  assert( xDel!=SQLITE_DYNAMIC );  if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;  if( n>0x7fffffff ){  (void)invokeValueDestructor(z, xDel, pCtx);  }else{  setResultStrOrError(pCtx, z, (int)n, enc, xDel);  } }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API void sqlite3_result_text16(  sqlite3_context *pCtx,  const void *z,  int n,  void (*xDel)(void *) ){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  setResultStrOrError(pCtx, z, n, SQLITE_UTF16NATIVE, xDel); } SQLITE_API void sqlite3_result_text16be(  sqlite3_context *pCtx,  const void *z,  int n,  void (*xDel)(void *) ){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  setResultStrOrError(pCtx, z, n, SQLITE_UTF16BE, xDel); } SQLITE_API void sqlite3_result_text16le(  sqlite3_context *pCtx,  const void *z,  int n,  void (*xDel)(void *) ){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  setResultStrOrError(pCtx, z, n, SQLITE_UTF16LE, xDel); }
#endif
SQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemCopy(pCtx->pOut, pValue); } SQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n); } SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){  Mem *pOut = pCtx->pOut;  assert( sqlite3_mutex_held(pOut->db->mutex) );  if( n>(u64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH] ){  return SQLITE_TOOBIG;  }
#ifndef SQLITE_OMIT_INCRBLOB
 sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);  return SQLITE_OK;
#else
 return sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);
#endif
} SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){  pCtx->isError = errCode ? errCode : -1;
#ifdef SQLITE_DEBUG
 if( pCtx->pVdbe ) pCtx->pVdbe->rcApp = errCode;
#endif
 if( pCtx->pOut->flags & MEM_Null ){  sqlite3VdbeMemSetStr(pCtx->pOut, sqlite3ErrStr(errCode), -1,   SQLITE_UTF8, SQLITE_STATIC);  } } SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  pCtx->isError = SQLITE_TOOBIG;  sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1,   SQLITE_UTF8, SQLITE_STATIC); } SQLITE_API void sqlite3_result_error_nomem(sqlite3_context *pCtx){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  sqlite3VdbeMemSetNull(pCtx->pOut);  pCtx->isError = SQLITE_NOMEM_BKPT;  sqlite3OomFault(pCtx->pOut->db); }
#ifndef SQLITE_UNTESTABLE
SQLITE_PRIVATE void sqlite3ResultIntReal(sqlite3_context *pCtx){  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );  if( pCtx->pOut->flags & MEM_Int ){  pCtx->pOut->flags &= ~MEM_Int;  pCtx->pOut->flags |= MEM_IntReal;  } }
#endif
static int doWalCallbacks(sqlite3 *db){  int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_WAL
 int i;  for(i=0; i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  int nEntry;  sqlite3BtreeEnter(pBt);  nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));  sqlite3BtreeLeave(pBt);  if( nEntry>0 && db->xWalCallback && rc==SQLITE_OK ){  rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);  }  }  }
#endif
 return rc; } static int sqlite3Step(Vdbe *p){  sqlite3 *db;  int rc;  assert(p);  if( p->iVdbeMagic!=VDBE_MAGIC_RUN ){
#ifdef SQLITE_OMIT_AUTORESET
 if( (rc = p->rc&0xff)==SQLITE_BUSY || rc==SQLITE_LOCKED ){  sqlite3_reset((sqlite3_stmt*)p);  }else{  return SQLITE_MISUSE_BKPT;  }
#else
 sqlite3_reset((sqlite3_stmt*)p);
#endif
 }  db = p->db;  if( db->mallocFailed ){  p->rc = SQLITE_NOMEM;  return SQLITE_NOMEM_BKPT;  }  if( p->pc<0 && p->expired ){  p->rc = SQLITE_SCHEMA;  rc = SQLITE_ERROR;  if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){  rc = sqlite3VdbeTransferError(p);  }  goto end_of_step;  }  if( p->pc<0 ){  if( db->nVdbeActive==0 ){  AtomicStore(&db->u1.isInterrupted, 0);  }  assert( db->nVdbeWrite>0 || db->autoCommit==0  || (db->nDeferredCons==0 && db->nDeferredImmCons==0)  );
#ifndef SQLITE_OMIT_TRACE
 if( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0  && !db->init.busy && p->zSql ){  sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);  }else{  assert( p->startTime==0 );  }
#endif
 db->nVdbeActive++;  if( p->readOnly==0 ) db->nVdbeWrite++;  if( p->bIsReader ) db->nVdbeRead++;  p->pc = 0;  }
#ifdef SQLITE_DEBUG
 p->rcApp = SQLITE_OK;
#endif
#ifndef SQLITE_OMIT_EXPLAIN
 if( p->explain ){  rc = sqlite3VdbeList(p);  }else
#endif
 {  db->nVdbeExec++;  rc = sqlite3VdbeExec(p);  db->nVdbeExec--;  }  if( rc!=SQLITE_ROW ){
#ifndef SQLITE_OMIT_TRACE
 checkProfileCallback(db, p);
#endif
 if( rc==SQLITE_DONE && db->autoCommit ){  assert( p->rc==SQLITE_OK );  p->rc = doWalCallbacks(db);  if( p->rc!=SQLITE_OK ){  rc = SQLITE_ERROR;  }  }else if( rc!=SQLITE_DONE && (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){  rc = sqlite3VdbeTransferError(p);  }  }  db->errCode = rc;  if( SQLITE_NOMEM==sqlite3ApiExit(p->db, p->rc) ){  p->rc = SQLITE_NOMEM_BKPT;  if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ) rc = p->rc;  } end_of_step:  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0   || rc==SQLITE_ROW || rc==SQLITE_DONE  || rc==SQLITE_ERROR   || (rc&0xff)==SQLITE_BUSY || rc==SQLITE_MISUSE  );  return (rc&db->errMask); } SQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){  int rc = SQLITE_OK;  Vdbe *v = (Vdbe*)pStmt;  int cnt = 0;  sqlite3 *db;  if( vdbeSafetyNotNull(v) ){  return SQLITE_MISUSE_BKPT;  }  db = v->db;  sqlite3_mutex_enter(db->mutex);  v->doingRerun = 0;  while( (rc = sqlite3Step(v))==SQLITE_SCHEMA   && cnt++ < SQLITE_MAX_SCHEMA_RETRY ){  int savedPc = v->pc;  rc = sqlite3Reprepare(v);  if( rc!=SQLITE_OK ){  const char *zErr = (const char *)sqlite3_value_text(db->pErr);  sqlite3DbFree(db, v->zErrMsg);  if( !db->mallocFailed ){  v->zErrMsg = sqlite3DbStrDup(db, zErr);  v->rc = rc = sqlite3ApiExit(db, rc);  } else {  v->zErrMsg = 0;  v->rc = rc = SQLITE_NOMEM_BKPT;  }  break;  }  sqlite3_reset(pStmt);  if( savedPc>=0 ) v->doingRerun = 1;  assert( v->expired==0 );  }  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API void *sqlite3_user_data(sqlite3_context *p){  assert( p && p->pFunc );  return p->pFunc->pUserData; } SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){  assert( p && p->pOut );  return p->pOut->db; } SQLITE_API int sqlite3_vtab_nochange(sqlite3_context *p){  assert( p );  return sqlite3_value_nochange(p->pOut); } SQLITE_PRIVATE sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){  int rc;
#ifndef SQLITE_ENABLE_STAT4
 sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;  assert( p->pVdbe!=0 );
#else
 sqlite3_int64 iTime = 0;  sqlite3_int64 *piTime = p->pVdbe!=0 ? &p->pVdbe->iCurrentTime : &iTime;
#endif
 if( *piTime==0 ){  rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);  if( rc ) *piTime = 0;  }  return *piTime; } static SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte){  Mem *pMem = p->pMem;  assert( (pMem->flags & MEM_Agg)==0 );  if( nByte<=0 ){  sqlite3VdbeMemSetNull(pMem);  pMem->z = 0;  }else{  sqlite3VdbeMemClearAndResize(pMem, nByte);  pMem->flags = MEM_Agg;  pMem->u.pDef = p->pFunc;  if( pMem->z ){  memset(pMem->z, 0, nByte);  }  }  return (void*)pMem->z; } SQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){  assert( p && p->pFunc && p->pFunc->xFinalize );  assert( sqlite3_mutex_held(p->pOut->db->mutex) );  testcase( nByte<0 );  if( (p->pMem->flags & MEM_Agg)==0 ){  return createAggContext(p, nByte);  }else{  return (void*)p->pMem->z;  } } SQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){  AuxData *pAuxData;  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
#if SQLITE_ENABLE_STAT4
 if( pCtx->pVdbe==0 ) return 0;
#else
 assert( pCtx->pVdbe!=0 );
#endif
 for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){  if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){  return pAuxData->pAux;  }  }  return 0; } SQLITE_API void sqlite3_set_auxdata(  sqlite3_context *pCtx,  int iArg,  void *pAux,  void (*xDelete)(void*) ){  AuxData *pAuxData;  Vdbe *pVdbe = pCtx->pVdbe;  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
#ifdef SQLITE_ENABLE_STAT4
 if( pVdbe==0 ) goto failed;
#else
 assert( pVdbe!=0 );
#endif
 for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){  if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){  break;  }  }  if( pAuxData==0 ){  pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));  if( !pAuxData ) goto failed;  pAuxData->iAuxOp = pCtx->iOp;  pAuxData->iAuxArg = iArg;  pAuxData->pNextAux = pVdbe->pAuxData;  pVdbe->pAuxData = pAuxData;  if( pCtx->isError==0 ) pCtx->isError = -1;  }else if( pAuxData->xDeleteAux ){  pAuxData->xDeleteAux(pAuxData->pAux);  }  pAuxData->pAux = pAux;  pAuxData->xDeleteAux = xDelete;  return; failed:  if( xDelete ){  xDelete(pAux);  } }
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){  assert( p && p->pMem && p->pFunc && p->pFunc->xFinalize );  return p->pMem->n; }
#endif
SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){  Vdbe *pVm = (Vdbe *)pStmt;  return pVm ? pVm->nResColumn : 0; } SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt){  Vdbe *pVm = (Vdbe *)pStmt;  if( pVm==0 || pVm->pResultSet==0 ) return 0;  return pVm->nResColumn; } static const Mem *columnNullValue(void){  static const Mem nullMem
#if defined(SQLITE_DEBUG) && defined(__GNUC__)
 __attribute__((aligned(8)))
#endif
 = {   {0},   (u16)MEM_Null,   (u8)0,   (u8)0,   (int)0,   (char*)0,   (char*)0,   (int)0,   (u32)0,   (sqlite3*)0,   (void(*)(void*))0,
#ifdef SQLITE_DEBUG
  (Mem*)0,   0,
#endif
 };  return &nullMem; } static Mem *columnMem(sqlite3_stmt *pStmt, int i){  Vdbe *pVm;  Mem *pOut;  pVm = (Vdbe *)pStmt;  if( pVm==0 ) return (Mem*)columnNullValue();  assert( pVm->db );  sqlite3_mutex_enter(pVm->db->mutex);  if( pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){  pOut = &pVm->pResultSet[i];  }else{  sqlite3Error(pVm->db, SQLITE_RANGE);  pOut = (Mem*)columnNullValue();  }  return pOut; } static void columnMallocFailure(sqlite3_stmt *pStmt) {  Vdbe *p = (Vdbe *)pStmt;  if( p ){  assert( p->db!=0 );  assert( sqlite3_mutex_held(p->db->mutex) );  p->rc = sqlite3ApiExit(p->db, p->rc);  sqlite3_mutex_leave(p->db->mutex);  } } SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){  const void *val;  val = sqlite3_value_blob( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){  int val = sqlite3_value_bytes( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i){  double val = sqlite3_value_double( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i){  int val = sqlite3_value_int( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; } SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){  Mem *pOut = columnMem(pStmt, i);  if( pOut->flags&MEM_Static ){  pOut->flags &= ~MEM_Static;  pOut->flags |= MEM_Ephem;  }  columnMallocFailure(pStmt);  return (sqlite3_value *)pOut; }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return val; }
#endif
SQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i){  int iType = sqlite3_value_type( columnMem(pStmt,i) );  columnMallocFailure(pStmt);  return iType; } static const void *columnName(  sqlite3_stmt *pStmt,  int N,  int useUtf16,  int useType ){  const void *ret;  Vdbe *p;  int n;  sqlite3 *db;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( pStmt==0 ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 ret = 0;  p = (Vdbe *)pStmt;  db = p->db;  assert( db!=0 );  n = sqlite3_column_count(pStmt);  if( N<n && N>=0 ){  N += useType*n;  sqlite3_mutex_enter(db->mutex);  assert( db->mallocFailed==0 );
#ifndef SQLITE_OMIT_UTF16
 if( useUtf16 ){  ret = sqlite3_value_text16((sqlite3_value*)&p->aColName[N]);  }else
#endif
 {  ret = sqlite3_value_text((sqlite3_value*)&p->aColName[N]);  }  if( db->mallocFailed ){  sqlite3OomClear(db);  ret = 0;  }  sqlite3_mutex_leave(db->mutex);  }  return ret; } SQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 0, COLNAME_NAME); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 1, COLNAME_NAME); }
#endif
#if defined(SQLITE_OMIT_DECLTYPE) && defined(SQLITE_ENABLE_COLUMN_METADATA)
# error "Must not define both SQLITE_OMIT_DECLTYPE   and SQLITE_ENABLE_COLUMN_METADATA"

#endif
#ifndef SQLITE_OMIT_DECLTYPE
SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 0, COLNAME_DECLTYPE); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 1, COLNAME_DECLTYPE); }
#endif
#endif
#ifdef SQLITE_ENABLE_COLUMN_METADATA
SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 0, COLNAME_DATABASE); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 1, COLNAME_DATABASE); }
#endif
SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 0, COLNAME_TABLE); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 1, COLNAME_TABLE); }
#endif
SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 0, COLNAME_COLUMN); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){  return columnName(pStmt, N, 1, COLNAME_COLUMN); }
#endif
#endif
static int vdbeUnbind(Vdbe *p, int i){  Mem *pVar;  if( vdbeSafetyNotNull(p) ){  return SQLITE_MISUSE_BKPT;  }  sqlite3_mutex_enter(p->db->mutex);  if( p->iVdbeMagic!=VDBE_MAGIC_RUN || p->pc>=0 ){  sqlite3Error(p->db, SQLITE_MISUSE);  sqlite3_mutex_leave(p->db->mutex);  sqlite3_log(SQLITE_MISUSE,  "bind on a busy prepared statement: [%s]", p->zSql);  return SQLITE_MISUSE_BKPT;  }  if( i<1 || i>p->nVar ){  sqlite3Error(p->db, SQLITE_RANGE);  sqlite3_mutex_leave(p->db->mutex);  return SQLITE_RANGE;  }  i--;  pVar = &p->aVar[i];  sqlite3VdbeMemRelease(pVar);  pVar->flags = MEM_Null;  p->db->errCode = SQLITE_OK;  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );  if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){  p->expired = 1;  }  return SQLITE_OK; } static int bindText(  sqlite3_stmt *pStmt,  int i,  const void *zData,  i64 nData,  void (*xDel)(void*),  u8 encoding ){  Vdbe *p = (Vdbe *)pStmt;  Mem *pVar;  int rc;  rc = vdbeUnbind(p, i);  if( rc==SQLITE_OK ){  if( zData!=0 ){  pVar = &p->aVar[i-1];  rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);  if( rc==SQLITE_OK && encoding!=0 ){  rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));  }  if( rc ){  sqlite3Error(p->db, rc);  rc = sqlite3ApiExit(p->db, rc);  }  }  sqlite3_mutex_leave(p->db->mutex);  }else if( xDel!=SQLITE_STATIC && xDel!=SQLITE_TRANSIENT ){  xDel((void*)zData);  }  return rc; } SQLITE_API int sqlite3_bind_blob(  sqlite3_stmt *pStmt,  int i,  const void *zData,  int nData,  void (*xDel)(void*) ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( nData<0 ) return SQLITE_MISUSE_BKPT;
#endif
 return bindText(pStmt, i, zData, nData, xDel, 0); } SQLITE_API int sqlite3_bind_blob64(  sqlite3_stmt *pStmt,  int i,  const void *zData,  sqlite3_uint64 nData,  void (*xDel)(void*) ){  assert( xDel!=SQLITE_DYNAMIC );  return bindText(pStmt, i, zData, nData, xDel, 0); } SQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){  int rc;  Vdbe *p = (Vdbe *)pStmt;  rc = vdbeUnbind(p, i);  if( rc==SQLITE_OK ){  sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);  sqlite3_mutex_leave(p->db->mutex);  }  return rc; } SQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){  return sqlite3_bind_int64(p, i, (i64)iValue); } SQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){  int rc;  Vdbe *p = (Vdbe *)pStmt;  rc = vdbeUnbind(p, i);  if( rc==SQLITE_OK ){  sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);  sqlite3_mutex_leave(p->db->mutex);  }  return rc; } SQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){  int rc;  Vdbe *p = (Vdbe*)pStmt;  rc = vdbeUnbind(p, i);  if( rc==SQLITE_OK ){  sqlite3_mutex_leave(p->db->mutex);  }  return rc; } SQLITE_API int sqlite3_bind_pointer(  sqlite3_stmt *pStmt,  int i,  void *pPtr,  const char *zPTtype,  void (*xDestructor)(void*) ){  int rc;  Vdbe *p = (Vdbe*)pStmt;  rc = vdbeUnbind(p, i);  if( rc==SQLITE_OK ){  sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);  sqlite3_mutex_leave(p->db->mutex);  }else if( xDestructor ){  xDestructor(pPtr);  }  return rc; } SQLITE_API int sqlite3_bind_text(  sqlite3_stmt *pStmt,  int i,  const char *zData,  int nData,  void (*xDel)(void*) ){  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8); } SQLITE_API int sqlite3_bind_text64(  sqlite3_stmt *pStmt,  int i,  const char *zData,  sqlite3_uint64 nData,  void (*xDel)(void*),  unsigned char enc ){  assert( xDel!=SQLITE_DYNAMIC );  if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;  return bindText(pStmt, i, zData, nData, xDel, enc); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_bind_text16(  sqlite3_stmt *pStmt,  int i,  const void *zData,  int nData,  void (*xDel)(void*) ){  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE); }
#endif
SQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){  int rc;  switch( sqlite3_value_type((sqlite3_value*)pValue) ){  case SQLITE_INTEGER: {  rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);  break;  }  case SQLITE_FLOAT: {  rc = sqlite3_bind_double(pStmt, i, pValue->u.r);  break;  }  case SQLITE_BLOB: {  if( pValue->flags & MEM_Zero ){  rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);  }else{  rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,SQLITE_TRANSIENT);  }  break;  }  case SQLITE_TEXT: {  rc = bindText(pStmt,i, pValue->z, pValue->n, SQLITE_TRANSIENT,  pValue->enc);  break;  }  default: {  rc = sqlite3_bind_null(pStmt, i);  break;  }  }  return rc; } SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){  int rc;  Vdbe *p = (Vdbe *)pStmt;  rc = vdbeUnbind(p, i);  if( rc==SQLITE_OK ){
#ifndef SQLITE_OMIT_INCRBLOB
 sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);
#else
 rc = sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);
#endif
 sqlite3_mutex_leave(p->db->mutex);  }  return rc; } SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){  int rc;  Vdbe *p = (Vdbe *)pStmt;  sqlite3_mutex_enter(p->db->mutex);  if( n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){  rc = SQLITE_TOOBIG;  }else{  assert( (n & 0x7FFFFFFF)==n );  rc = sqlite3_bind_zeroblob(pStmt, i, n);  }  rc = sqlite3ApiExit(p->db, rc);  sqlite3_mutex_leave(p->db->mutex);  return rc; } SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){  Vdbe *p = (Vdbe*)pStmt;  return p ? p->nVar : 0; } SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){  Vdbe *p = (Vdbe*)pStmt;  if( p==0 ) return 0;  return sqlite3VListNumToName(p->pVList, i); } SQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){  if( p==0 || zName==0 ) return 0;  return sqlite3VListNameToNum(p->pVList, zName, nName); } SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName)); } SQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){  Vdbe *pFrom = (Vdbe*)pFromStmt;  Vdbe *pTo = (Vdbe*)pToStmt;  int i;  assert( pTo->db==pFrom->db );  assert( pTo->nVar==pFrom->nVar );  sqlite3_mutex_enter(pTo->db->mutex);  for(i=0; i<pFrom->nVar; i++){  sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);  }  sqlite3_mutex_leave(pTo->db->mutex);  return SQLITE_OK; }
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){  Vdbe *pFrom = (Vdbe*)pFromStmt;  Vdbe *pTo = (Vdbe*)pToStmt;  if( pFrom->nVar!=pTo->nVar ){  return SQLITE_ERROR;  }  assert( (pTo->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pTo->expmask==0 );  if( pTo->expmask ){  pTo->expired = 1;  }  assert( (pFrom->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pFrom->expmask==0 );  if( pFrom->expmask ){  pFrom->expired = 1;  }  return sqlite3TransferBindings(pFromStmt, pToStmt); }
#endif
SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){  return pStmt ? ((Vdbe*)pStmt)->db : 0; } SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1; } SQLITE_API int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){  return pStmt ? ((Vdbe*)pStmt)->explain : 0; } SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt *pStmt){  Vdbe *v = (Vdbe*)pStmt;  return v!=0 && v->iVdbeMagic==VDBE_MAGIC_RUN && v->pc>=0; } SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){  sqlite3_stmt *pNext;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(pDb) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(pDb->mutex);  if( pStmt==0 ){  pNext = (sqlite3_stmt*)pDb->pVdbe;  }else{  pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;  }  sqlite3_mutex_leave(pDb->mutex);  return pNext; } SQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){  Vdbe *pVdbe = (Vdbe*)pStmt;  u32 v;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !pStmt   || (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))  ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 if( op==SQLITE_STMTSTATUS_MEMUSED ){  sqlite3 *db = pVdbe->db;  sqlite3_mutex_enter(db->mutex);  v = 0;  db->pnBytesFreed = (int*)&v;  sqlite3VdbeClearObject(db, pVdbe);  sqlite3DbFree(db, pVdbe);  db->pnBytesFreed = 0;  sqlite3_mutex_leave(db->mutex);  }else{  v = pVdbe->aCounter[op];  if( resetFlag ) pVdbe->aCounter[op] = 0;  }  return (int)v; } SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt){  Vdbe *p = (Vdbe *)pStmt;  return p ? p->zSql : 0; } SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt){
#ifdef SQLITE_OMIT_TRACE
 return 0;
#else
 char *z = 0;  const char *zSql = sqlite3_sql(pStmt);  if( zSql ){  Vdbe *p = (Vdbe *)pStmt;  sqlite3_mutex_enter(p->db->mutex);  z = sqlite3VdbeExpandSql(p, zSql);  sqlite3_mutex_leave(p->db->mutex);  }  return z;
#endif
}
#ifdef SQLITE_ENABLE_NORMALIZE
SQLITE_API const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt){  Vdbe *p = (Vdbe *)pStmt;  if( p==0 ) return 0;  if( p->zNormSql==0 && ALWAYS(p->zSql!=0) ){  sqlite3_mutex_enter(p->db->mutex);  p->zNormSql = sqlite3Normalize(p, p->zSql);  sqlite3_mutex_leave(p->db->mutex);  }  return p->zNormSql; }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
static UnpackedRecord *vdbeUnpackRecord(  KeyInfo *pKeyInfo,  int nKey,  const void *pKey ){  UnpackedRecord *pRet;  pRet = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);  if( pRet ){  memset(pRet->aMem, 0, sizeof(Mem)*(pKeyInfo->nKeyField+1));  sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, pRet);  }  return pRet; } SQLITE_API int sqlite3_preupdate_old(sqlite3 *db, int iIdx, sqlite3_value **ppValue){  PreUpdate *p = db->pPreUpdate;  Mem *pMem;  int rc = SQLITE_OK;  if( !p || p->op==SQLITE_INSERT ){  rc = SQLITE_MISUSE_BKPT;  goto preupdate_old_out;  }  if( p->pPk ){  iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);  }  if( iIdx>=p->pCsr->nField || iIdx<0 ){  rc = SQLITE_RANGE;  goto preupdate_old_out;  }  if( p->pUnpacked==0 ){  u32 nRec;  u8 *aRec;  assert( p->pCsr->eCurType==CURTYPE_BTREE );  nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);  aRec = sqlite3DbMallocRaw(db, nRec);  if( !aRec ) goto preupdate_old_out;  rc = sqlite3BtreePayload(p->pCsr->uc.pCursor, 0, nRec, aRec);  if( rc==SQLITE_OK ){  p->pUnpacked = vdbeUnpackRecord(&p->keyinfo, nRec, aRec);  if( !p->pUnpacked ) rc = SQLITE_NOMEM;  }  if( rc!=SQLITE_OK ){  sqlite3DbFree(db, aRec);  goto preupdate_old_out;  }  p->aRecord = aRec;  }  pMem = *ppValue = &p->pUnpacked->aMem[iIdx];  if( iIdx==p->pTab->iPKey ){  sqlite3VdbeMemSetInt64(pMem, p->iKey1);  }else if( iIdx>=p->pUnpacked->nField ){  *ppValue = (sqlite3_value *)columnNullValue();  }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){  if( pMem->flags & (MEM_Int|MEM_IntReal) ){  testcase( pMem->flags & MEM_Int );  testcase( pMem->flags & MEM_IntReal );  sqlite3VdbeMemRealify(pMem);  }  }  preupdate_old_out:  sqlite3Error(db, rc);  return sqlite3ApiExit(db, rc); }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_API int sqlite3_preupdate_count(sqlite3 *db){  PreUpdate *p = db->pPreUpdate;  return (p ? p->keyinfo.nKeyField : 0); }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_API int sqlite3_preupdate_depth(sqlite3 *db){  PreUpdate *p = db->pPreUpdate;  return (p ? p->v->nFrame : 0); }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_API int sqlite3_preupdate_blobwrite(sqlite3 *db){  PreUpdate *p = db->pPreUpdate;  return (p ? p->iBlobWrite : -1); }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_API int sqlite3_preupdate_new(sqlite3 *db, int iIdx, sqlite3_value **ppValue){  PreUpdate *p = db->pPreUpdate;  int rc = SQLITE_OK;  Mem *pMem;  if( !p || p->op==SQLITE_DELETE ){  rc = SQLITE_MISUSE_BKPT;  goto preupdate_new_out;  }  if( p->pPk && p->op!=SQLITE_UPDATE ){  iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);  }  if( iIdx>=p->pCsr->nField || iIdx<0 ){  rc = SQLITE_RANGE;  goto preupdate_new_out;  }  if( p->op==SQLITE_INSERT ){  UnpackedRecord *pUnpack = p->pNewUnpacked;  if( !pUnpack ){  Mem *pData = &p->v->aMem[p->iNewReg];  rc = ExpandBlob(pData);  if( rc!=SQLITE_OK ) goto preupdate_new_out;  pUnpack = vdbeUnpackRecord(&p->keyinfo, pData->n, pData->z);  if( !pUnpack ){  rc = SQLITE_NOMEM;  goto preupdate_new_out;  }  p->pNewUnpacked = pUnpack;  }  pMem = &pUnpack->aMem[iIdx];  if( iIdx==p->pTab->iPKey ){  sqlite3VdbeMemSetInt64(pMem, p->iKey2);  }else if( iIdx>=pUnpack->nField ){  pMem = (sqlite3_value *)columnNullValue();  }  }else{  assert( p->op==SQLITE_UPDATE );  if( !p->aNew ){  p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem) * p->pCsr->nField);  if( !p->aNew ){  rc = SQLITE_NOMEM;  goto preupdate_new_out;  }  }  assert( iIdx>=0 && iIdx<p->pCsr->nField );  pMem = &p->aNew[iIdx];  if( pMem->flags==0 ){  if( iIdx==p->pTab->iPKey ){  sqlite3VdbeMemSetInt64(pMem, p->iKey2);  }else{  rc = sqlite3VdbeMemCopy(pMem, &p->v->aMem[p->iNewReg+1+iIdx]);  if( rc!=SQLITE_OK ) goto preupdate_new_out;  }  }  }  *ppValue = pMem;  preupdate_new_out:  sqlite3Error(db, rc);  return sqlite3ApiExit(db, rc); }
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
SQLITE_API int sqlite3_stmt_scanstatus(  sqlite3_stmt *pStmt,  int idx,  int iScanStatusOp,  void *pOut ){  Vdbe *p = (Vdbe*)pStmt;  ScanStatus *pScan;  if( idx<0 || idx>=p->nScan ) return 1;  pScan = &p->aScan[idx];  switch( iScanStatusOp ){  case SQLITE_SCANSTAT_NLOOP: {  *(sqlite3_int64*)pOut = p->anExec[pScan->addrLoop];  break;  }  case SQLITE_SCANSTAT_NVISIT: {  *(sqlite3_int64*)pOut = p->anExec[pScan->addrVisit];  break;  }  case SQLITE_SCANSTAT_EST: {  double r = 1.0;  LogEst x = pScan->nEst;  while( x<100 ){  x += 10;  r *= 0.5;  }  *(double*)pOut = r*sqlite3LogEstToInt(x);  break;  }  case SQLITE_SCANSTAT_NAME: {  *(const char**)pOut = pScan->zName;  break;  }  case SQLITE_SCANSTAT_EXPLAIN: {  if( pScan->addrExplain ){  *(const char**)pOut = p->aOp[ pScan->addrExplain ].p4.z;  }else{  *(const char**)pOut = 0;  }  break;  }  case SQLITE_SCANSTAT_SELECTID: {  if( pScan->addrExplain ){  *(int*)pOut = p->aOp[ pScan->addrExplain ].p1;  }else{  *(int*)pOut = -1;  }  break;  }  default: {  return 1;  }  }  return 0; } SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){  Vdbe *p = (Vdbe*)pStmt;  memset(p->anExec, 0, p->nOp * sizeof(i64)); }
#endif
#ifndef SQLITE_OMIT_TRACE
static int findNextHostParameter(const char *zSql, int *pnToken){  int tokenType;  int nTotal = 0;  int n;  *pnToken = 0;  while( zSql[0] ){  n = sqlite3GetToken((u8*)zSql, &tokenType);  assert( n>0 && tokenType!=TK_ILLEGAL );  if( tokenType==TK_VARIABLE ){  *pnToken = n;  break;  }  nTotal += n;  zSql += n;  }  return nTotal; } SQLITE_PRIVATE char *sqlite3VdbeExpandSql(  Vdbe *p,  const char *zRawSql ){  sqlite3 *db;  int idx = 0;  int nextIndex = 1;  int n;  int nToken;  int i;  Mem *pVar;  StrAccum out;
#ifndef SQLITE_OMIT_UTF16
 Mem utf8;
#endif
 db = p->db;  sqlite3StrAccumInit(&out, 0, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);  if( db->nVdbeExec>1 ){  while( *zRawSql ){  const char *zStart = zRawSql;  while( *(zRawSql++)!='\n' && *zRawSql );  sqlite3_str_append(&out, "-- ", 3);  assert( (zRawSql - zStart) > 0 );  sqlite3_str_append(&out, zStart, (int)(zRawSql-zStart));  }  }else if( p->nVar==0 ){  sqlite3_str_append(&out, zRawSql, sqlite3Strlen30(zRawSql));  }else{  while( zRawSql[0] ){  n = findNextHostParameter(zRawSql, &nToken);  assert( n>0 );  sqlite3_str_append(&out, zRawSql, n);  zRawSql += n;  assert( zRawSql[0] || nToken==0 );  if( nToken==0 ) break;  if( zRawSql[0]=='?' ){  if( nToken>1 ){  assert( sqlite3Isdigit(zRawSql[1]) );  sqlite3GetInt32(&zRawSql[1], &idx);  }else{  idx = nextIndex;  }  }else{  assert( zRawSql[0]==':' || zRawSql[0]=='$' ||  zRawSql[0]=='@' || zRawSql[0]=='#' );  testcase( zRawSql[0]==':' );  testcase( zRawSql[0]=='$' );  testcase( zRawSql[0]=='@' );  testcase( zRawSql[0]=='#' );  idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);  assert( idx>0 );  }  zRawSql += nToken;  nextIndex = MAX(idx + 1, nextIndex);  assert( idx>0 && idx<=p->nVar );  pVar = &p->aVar[idx-1];  if( pVar->flags & MEM_Null ){  sqlite3_str_append(&out, "NULL", 4);  }else if( pVar->flags & (MEM_Int|MEM_IntReal) ){  sqlite3_str_appendf(&out, "%lld", pVar->u.i);  }else if( pVar->flags & MEM_Real ){  sqlite3_str_appendf(&out, "%!.15g", pVar->u.r);  }else if( pVar->flags & MEM_Str ){  int nOut;
#ifndef SQLITE_OMIT_UTF16
 u8 enc = ENC(db);  if( enc!=SQLITE_UTF8 ){  memset(&utf8, 0, sizeof(utf8));  utf8.db = db;  sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, SQLITE_STATIC);  if( SQLITE_NOMEM==sqlite3VdbeChangeEncoding(&utf8, SQLITE_UTF8) ){  out.accError = SQLITE_NOMEM;  out.nAlloc = 0;  }  pVar = &utf8;  }
#endif
 nOut = pVar->n;
#ifdef SQLITE_TRACE_SIZE_LIMIT
 if( nOut>SQLITE_TRACE_SIZE_LIMIT ){  nOut = SQLITE_TRACE_SIZE_LIMIT;  while( nOut<pVar->n && (pVar->z[nOut]&0xc0)==0x80 ){ nOut++; }  }
#endif
 sqlite3_str_appendf(&out, "'%.*q'", nOut, pVar->z);
#ifdef SQLITE_TRACE_SIZE_LIMIT
 if( nOut<pVar->n ){  sqlite3_str_appendf(&out, "", pVar->n-nOut);  }
#endif
#ifndef SQLITE_OMIT_UTF16
 if( enc!=SQLITE_UTF8 ) sqlite3VdbeMemRelease(&utf8);
#endif
 }else if( pVar->flags & MEM_Zero ){  sqlite3_str_appendf(&out, "zeroblob(%d)", pVar->u.nZero);  }else{  int nOut;  assert( pVar->flags & MEM_Blob );  sqlite3_str_append(&out, "x'", 2);  nOut = pVar->n;
#ifdef SQLITE_TRACE_SIZE_LIMIT
 if( nOut>SQLITE_TRACE_SIZE_LIMIT ) nOut = SQLITE_TRACE_SIZE_LIMIT;
#endif
 for(i=0; i<nOut; i++){  sqlite3_str_appendf(&out, "%02x", pVar->z[i]&0xff);  }  sqlite3_str_append(&out, "'", 1);
#ifdef SQLITE_TRACE_SIZE_LIMIT
 if( nOut<pVar->n ){  sqlite3_str_appendf(&out, "", pVar->n-nOut);  }
#endif
 }  }  }  if( out.accError ) sqlite3_str_reset(&out);  return sqlite3StrAccumFinish(&out); }
#endif
#ifdef SQLITE_DEBUG
# define memAboutToChange(P,M) sqlite3VdbeMemAboutToChange(P,M)
#else
# define memAboutToChange(P,M)
#endif
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_search_count = 0;
#endif
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_interrupt_count = 0;
#endif
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_sort_count = 0;
#endif
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_max_blobsize = 0; static void updateMaxBlobsize(Mem *p){  if( (p->flags & (MEM_Str|MEM_Blob))!=0 && p->n>sqlite3_max_blobsize ){  sqlite3_max_blobsize = p->n;  } }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
# define HAS_UPDATE_HOOK(DB) ((DB)->xPreUpdateCallback||(DB)->xUpdateCallback)
#else
# define HAS_UPDATE_HOOK(DB) ((DB)->xUpdateCallback)
#endif
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_found_count = 0;
#endif
#if defined(SQLITE_TEST) && !defined(SQLITE_UNTESTABLE)
# define UPDATE_MAX_BLOBSIZE(P) updateMaxBlobsize(P)
#else
# define UPDATE_MAX_BLOBSIZE(P)
#endif
#ifdef SQLITE_DEBUG
static void test_trace_breakpoint(int pc, Op *pOp, Vdbe *v){  static int n = 0;  n++; }
#endif
#if !defined(SQLITE_VDBE_COVERAGE)
# define VdbeBranchTaken(I,M)
#else
# define VdbeBranchTaken(I,M) vdbeTakeBranch(pOp->iSrcLine,I,M)
 static void vdbeTakeBranch(u32 iSrcLine, u8 I, u8 M){  u8 mNever;  assert( I<=2 );  assert( M<=4 );  assert( I<M );  I = 1<<I;  mNever = iSrcLine >> 24;  assert( (I & mNever)==0 );  if( sqlite3GlobalConfig.xVdbeBranch==0 ) return;  I |= mNever;  if( M==2 ) I |= 0x04;  if( M==4 ){  I |= 0x08;  if( (mNever&0x08)!=0 && (I&0x05)!=0) I |= 0x05;  }  sqlite3GlobalConfig.xVdbeBranch(sqlite3GlobalConfig.pVdbeBranchArg,  iSrcLine&0xffffff, I, M);  }
#endif
#define Deephemeralize(P)   if( ((P)->flags&MEM_Ephem)!=0   && sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}

#define isSorter(x) ((x)->eCurType==CURTYPE_SORTER)
static VdbeCursor *allocateCursor(  Vdbe *p,  int iCur,  int nField,  int iDb,  u8 eCurType ){  Mem *pMem = iCur>0 ? &p->aMem[p->nMem-iCur] : p->aMem;  int nByte;  VdbeCursor *pCx = 0;  nByte =  ROUND8(sizeof(VdbeCursor)) + 2*sizeof(u32)*nField +  (eCurType==CURTYPE_BTREE?sqlite3BtreeCursorSize():0);  assert( iCur>=0 && iCur<p->nCursor );  if( p->apCsr[iCur] ){  sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);  p->apCsr[iCur] = 0;  }  assert( pMem->flags==MEM_Undefined );  assert( (pMem->flags & MEM_Dyn)==0 );  assert( pMem->szMalloc==0 || pMem->z==pMem->zMalloc );  if( pMem->szMalloc<nByte ){  if( pMem->szMalloc>0 ){  sqlite3DbFreeNN(pMem->db, pMem->zMalloc);  }  pMem->z = pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, nByte);  if( pMem->zMalloc==0 ){  pMem->szMalloc = 0;  return 0;  }  pMem->szMalloc = nByte;  }  p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->zMalloc;  memset(pCx, 0, offsetof(VdbeCursor,pAltCursor));  pCx->eCurType = eCurType;  pCx->iDb = iDb;  pCx->nField = nField;  pCx->aOffset = &pCx->aType[nField];  if( eCurType==CURTYPE_BTREE ){  pCx->uc.pCursor = (BtCursor*)  &pMem->z[ROUND8(sizeof(VdbeCursor))+2*sizeof(u32)*nField];  sqlite3BtreeCursorZero(pCx->uc.pCursor);  }  return pCx; } static int alsoAnInt(Mem *pRec, double rValue, i64 *piValue){  i64 iValue = (double)rValue;  if( sqlite3RealSameAsInt(rValue,iValue) ){  *piValue = iValue;  return 1;  }  return 0==sqlite3Atoi64(pRec->z, piValue, pRec->n, pRec->enc); } static void applyNumericAffinity(Mem *pRec, int bTryForInt){  double rValue;  u8 enc = pRec->enc;  int rc;  assert( (pRec->flags & (MEM_Str|MEM_Int|MEM_Real|MEM_IntReal))==MEM_Str );  rc = sqlite3AtoF(pRec->z, &rValue, pRec->n, enc);  if( rc<=0 ) return;  if( rc==1 && alsoAnInt(pRec, rValue, &pRec->u.i) ){  pRec->flags |= MEM_Int;  }else{  pRec->u.r = rValue;  pRec->flags |= MEM_Real;  if( bTryForInt ) sqlite3VdbeIntegerAffinity(pRec);  }  pRec->flags &= ~MEM_Str; } static void applyAffinity(  Mem *pRec,  char affinity,  u8 enc ){  if( affinity>=SQLITE_AFF_NUMERIC ){  assert( affinity==SQLITE_AFF_INTEGER || affinity==SQLITE_AFF_REAL   || affinity==SQLITE_AFF_NUMERIC );  if( (pRec->flags & MEM_Int)==0 ){  if( (pRec->flags & MEM_Real)==0 ){  if( pRec->flags & MEM_Str ) applyNumericAffinity(pRec,1);  }else{  sqlite3VdbeIntegerAffinity(pRec);  }  }  }else if( affinity==SQLITE_AFF_TEXT ){  if( 0==(pRec->flags&MEM_Str) ){  if( (pRec->flags&(MEM_Real|MEM_Int|MEM_IntReal)) ){  testcase( pRec->flags & MEM_Int );  testcase( pRec->flags & MEM_Real );  testcase( pRec->flags & MEM_IntReal );  sqlite3VdbeMemStringify(pRec, enc, 1);  }  }  pRec->flags &= ~(MEM_Real|MEM_Int|MEM_IntReal);  } } SQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal){  int eType = sqlite3_value_type(pVal);  if( eType==SQLITE_TEXT ){  Mem *pMem = (Mem*)pVal;  applyNumericAffinity(pMem, 0);  eType = sqlite3_value_type(pVal);  }  return eType; } SQLITE_PRIVATE void sqlite3ValueApplyAffinity(  sqlite3_value *pVal,  u8 affinity,  u8 enc ){  applyAffinity((Mem *)pVal, affinity, enc); } static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem){  int rc;  sqlite3_int64 ix;  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal))==0 );  assert( (pMem->flags & (MEM_Str|MEM_Blob))!=0 );  if( ExpandBlob(pMem) ){  pMem->u.i = 0;  return MEM_Int;  }  rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);  if( rc<=0 ){  if( rc==0 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1 ){  pMem->u.i = ix;  return MEM_Int;  }else{  return MEM_Real;  }  }else if( rc==1 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)==0 ){  pMem->u.i = ix;  return MEM_Int;  }  return MEM_Real; } static u16 numericType(Mem *pMem){  if( pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal) ){  testcase( pMem->flags & MEM_Int );  testcase( pMem->flags & MEM_Real );  testcase( pMem->flags & MEM_IntReal );  return pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal);  }  if( pMem->flags & (MEM_Str|MEM_Blob) ){  testcase( pMem->flags & MEM_Str );  testcase( pMem->flags & MEM_Blob );  return computeNumericType(pMem);  }  return 0; }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint(Mem *pMem, StrAccum *pStr){  int f = pMem->flags;  static const char *const encnames[] = {"(X)", "(8)", "(16LE)", "(16BE)"};  if( f&MEM_Blob ){  int i;  char c;  if( f & MEM_Dyn ){  c = 'z';  assert( (f & (MEM_Static|MEM_Ephem))==0 );  }else if( f & MEM_Static ){  c = 't';  assert( (f & (MEM_Dyn|MEM_Ephem))==0 );  }else if( f & MEM_Ephem ){  c = 'e';  assert( (f & (MEM_Static|MEM_Dyn))==0 );  }else{  c = 's';  }  sqlite3_str_appendf(pStr, "%cx[", c);  for(i=0; i<25 && i<pMem->n; i++){  sqlite3_str_appendf(pStr, "%02X", ((int)pMem->z[i] & 0xFF));  }  sqlite3_str_appendf(pStr, "|");  for(i=0; i<25 && i<pMem->n; i++){  char z = pMem->z[i];  sqlite3_str_appendchar(pStr, 1, (z<32||z>126)?'.':z);  }  sqlite3_str_appendf(pStr,"]");  if( f & MEM_Zero ){  sqlite3_str_appendf(pStr, "+%dz",pMem->u.nZero);  }  }else if( f & MEM_Str ){  int j;  u8 c;  if( f & MEM_Dyn ){  c = 'z';  assert( (f & (MEM_Static|MEM_Ephem))==0 );  }else if( f & MEM_Static ){  c = 't';  assert( (f & (MEM_Dyn|MEM_Ephem))==0 );  }else if( f & MEM_Ephem ){  c = 'e';  assert( (f & (MEM_Static|MEM_Dyn))==0 );  }else{  c = 's';  }  sqlite3_str_appendf(pStr, " %c%d[", c, pMem->n);  for(j=0; j<25 && j<pMem->n; j++){  c = pMem->z[j];  sqlite3_str_appendchar(pStr, 1, (c>=0x20&&c<=0x7f) ? c : '.');  }  sqlite3_str_appendf(pStr, "]%s", encnames[pMem->enc]);  } }
#endif
#ifdef SQLITE_DEBUG
static void memTracePrint(Mem *p){  if( p->flags & MEM_Undefined ){  printf(" undefined");  }else if( p->flags & MEM_Null ){  printf(p->flags & MEM_Zero ? " NULL-nochng" : " NULL");  }else if( (p->flags & (MEM_Int|MEM_Str))==(MEM_Int|MEM_Str) ){  printf(" si:%lld", p->u.i);  }else if( (p->flags & (MEM_IntReal))!=0 ){  printf(" ir:%lld", p->u.i);  }else if( p->flags & MEM_Int ){  printf(" i:%lld", p->u.i);
#ifndef SQLITE_OMIT_FLOATING_POINT
 }else if( p->flags & MEM_Real ){  printf(" r:%.17g", p->u.r);
#endif
 }else if( sqlite3VdbeMemIsRowSet(p) ){  printf(" (rowset)");  }else{  StrAccum acc;  char zBuf[1000];  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  sqlite3VdbeMemPrettyPrint(p, &acc);  printf(" %s", sqlite3StrAccumFinish(&acc));  }  if( p->flags & MEM_Subtype ) printf(" subtype=0x%02x", p->eSubtype); } static void registerTrace(int iReg, Mem *p){  printf("R[%d] = ", iReg);  memTracePrint(p);  if( p->pScopyFrom ){  printf(" <== R[%d]", (int)(p->pScopyFrom - &p[-iReg]));  }  printf("\n");  sqlite3VdbeCheckMemInvariants(p); }  void sqlite3PrintMem(Mem *pMem){  memTracePrint(pMem);  printf("\n");  fflush(stdout); }
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3VdbeRegisterDump(Vdbe *v){  int i;  for(i=1; i<v->nMem; i++) registerTrace(i, v->aMem+i); }
#endif
#ifdef SQLITE_DEBUG
# define REGISTER_TRACE(R,M) if(db->flags&SQLITE_VdbeTrace)registerTrace(R,M)
#else
# define REGISTER_TRACE(R,M)
#endif
#ifdef VDBE_PROFILE
#endif
#ifndef NDEBUG
static int checkSavepointCount(sqlite3 *db){  int n = 0;  Savepoint *p;  for(p=db->pSavepoint; p; p=p->pNext) n++;  assert( n==(db->nSavepoint + db->isTransactionSavepoint) );  return 1; }
#endif
static SQLITE_NOINLINE Mem *out2PrereleaseWithClear(Mem *pOut){  sqlite3VdbeMemSetNull(pOut);  pOut->flags = MEM_Int;  return pOut; } static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){  Mem *pOut;  assert( pOp->p2>0 );  assert( pOp->p2<=(p->nMem+1 - p->nCursor) );  pOut = &p->aMem[pOp->p2];  memAboutToChange(p, pOut);  if( VdbeMemDynamic(pOut) ){  return out2PrereleaseWithClear(pOut);  }else{  pOut->flags = MEM_Int;  return pOut;  } } static const char *vdbeMemTypeName(Mem *pMem){  static const char *azTypes[] = {  "INT",  "REAL",  "TEXT",  "BLOB",  "NULL"  };  return azTypes[sqlite3_value_type(pMem)-1]; } SQLITE_PRIVATE int sqlite3VdbeExec(  Vdbe *p ){  Op *aOp = p->aOp;  Op *pOp = aOp;
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
 Op *pOrigOp;
#endif
#ifdef SQLITE_DEBUG
 int nExtraDelete = 0;
#endif
 int rc = SQLITE_OK;  sqlite3 *db = p->db;  u8 resetSchemaOnFault = 0;  u8 encoding = ENC(db);  int iCompare = 0;  u64 nVmStep = 0;
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
 u64 nProgressLimit;
#endif
 Mem *aMem = p->aMem;  Mem *pIn1 = 0;  Mem *pIn2 = 0;  Mem *pIn3 = 0;  Mem *pOut = 0;
#ifdef VDBE_PROFILE
 u64 start;
#endif
 assert( p->iVdbeMagic==VDBE_MAGIC_RUN );  sqlite3VdbeEnter(p);
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
 if( db->xProgress ){  u32 iPrior = p->aCounter[SQLITE_STMTSTATUS_VM_STEP];  assert( 0 < db->nProgressOps );  nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);  }else{  nProgressLimit = LARGEST_UINT64;  }
#endif
 if( p->rc==SQLITE_NOMEM ){  goto no_mem;  }  assert( p->rc==SQLITE_OK || (p->rc&0xff)==SQLITE_BUSY );  testcase( p->rc!=SQLITE_OK );  p->rc = SQLITE_OK;  assert( p->bIsReader || p->readOnly!=0 );  p->iCurrentTime = 0;  assert( p->explain==0 );  p->pResultSet = 0;  db->busyHandler.nBusy = 0;  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;  sqlite3VdbeIOTraceSql(p);
#ifdef SQLITE_DEBUG
 sqlite3BeginBenignMalloc();  if( p->pc==0   && (p->db->flags & (SQLITE_VdbeListing|SQLITE_VdbeEQP|SQLITE_VdbeTrace))!=0  ){  int i;  int once = 1;  sqlite3VdbePrintSql(p);  if( p->db->flags & SQLITE_VdbeListing ){  printf("VDBE Program Listing:\n");  for(i=0; i<p->nOp; i++){  sqlite3VdbePrintOp(stdout, i, &aOp[i]);  }  }  if( p->db->flags & SQLITE_VdbeEQP ){  for(i=0; i<p->nOp; i++){  if( aOp[i].opcode==OP_Explain ){  if( once ) printf("VDBE Query Plan:\n");  printf("%s\n", aOp[i].p4.z);  once = 0;  }  }  }  if( p->db->flags & SQLITE_VdbeTrace ) printf("VDBE Trace:\n");  }  sqlite3EndBenignMalloc();
#endif
 for(pOp=&aOp[p->pc]; 1; pOp++){  assert( rc==SQLITE_OK );  assert( pOp>=aOp && pOp<&aOp[p->nOp]);
#ifdef VDBE_PROFILE
 start = sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();
#endif
 nVmStep++;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 if( p->anExec ) p->anExec[(int)(pOp-aOp)]++;
#endif
#ifdef SQLITE_DEBUG
 if( db->flags & SQLITE_VdbeTrace ){  sqlite3VdbePrintOp(stdout, (int)(pOp - aOp), pOp);  test_trace_breakpoint((int)(pOp - aOp),pOp,p);  }
#endif
#ifdef SQLITE_TEST
 if( sqlite3_interrupt_count>0 ){  sqlite3_interrupt_count--;  if( sqlite3_interrupt_count==0 ){  sqlite3_interrupt(db);  }  }
#endif
#ifdef SQLITE_DEBUG
 {  u8 opProperty = sqlite3OpcodeProperty[pOp->opcode];  if( (opProperty & OPFLG_IN1)!=0 ){  assert( pOp->p1>0 );  assert( pOp->p1<=(p->nMem+1 - p->nCursor) );  assert( memIsValid(&aMem[pOp->p1]) );  assert( sqlite3VdbeCheckMemInvariants(&aMem[pOp->p1]) );  REGISTER_TRACE(pOp->p1, &aMem[pOp->p1]);  }  if( (opProperty & OPFLG_IN2)!=0 ){  assert( pOp->p2>0 );  assert( pOp->p2<=(p->nMem+1 - p->nCursor) );  assert( memIsValid(&aMem[pOp->p2]) );  assert( sqlite3VdbeCheckMemInvariants(&aMem[pOp->p2]) );  REGISTER_TRACE(pOp->p2, &aMem[pOp->p2]);  }  if( (opProperty & OPFLG_IN3)!=0 ){  assert( pOp->p3>0 );  assert( pOp->p3<=(p->nMem+1 - p->nCursor) );  assert( memIsValid(&aMem[pOp->p3]) );  assert( sqlite3VdbeCheckMemInvariants(&aMem[pOp->p3]) );  REGISTER_TRACE(pOp->p3, &aMem[pOp->p3]);  }  if( (opProperty & OPFLG_OUT2)!=0 ){  assert( pOp->p2>0 );  assert( pOp->p2<=(p->nMem+1 - p->nCursor) );  memAboutToChange(p, &aMem[pOp->p2]);  }  if( (opProperty & OPFLG_OUT3)!=0 ){  assert( pOp->p3>0 );  assert( pOp->p3<=(p->nMem+1 - p->nCursor) );  memAboutToChange(p, &aMem[pOp->p3]);  }  }
#endif
#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)
 pOrigOp = pOp;
#endif
 switch( pOp->opcode ){ case OP_Goto: {
#ifdef SQLITE_DEBUG
 if( pOp->p5 ){  assert( pOp->p2 < (int)(pOp - aOp) );  assert( pOp->p2 > 1 );  pOp = &aOp[pOp->p2 - 2];  assert( pOp[1].opcode==OP_ReleaseReg );  goto check_for_interrupt;  }
#endif
jump_to_p2_and_check_for_interrupt:  pOp = &aOp[pOp->p2 - 1]; check_for_interrupt:  if( AtomicLoad(&db->u1.isInterrupted) ) goto abort_due_to_interrupt;
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
 while( nVmStep>=nProgressLimit && db->xProgress!=0 ){  assert( db->nProgressOps!=0 );  nProgressLimit += db->nProgressOps;  if( db->xProgress(db->pProgressArg) ){  nProgressLimit = LARGEST_UINT64;  rc = SQLITE_INTERRUPT;  goto abort_due_to_error;  }  }
#endif
 break; } case OP_Gosub: {  assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );  pIn1 = &aMem[pOp->p1];  assert( VdbeMemDynamic(pIn1)==0 );  memAboutToChange(p, pIn1);  pIn1->flags = MEM_Int;  pIn1->u.i = (int)(pOp-aOp);  REGISTER_TRACE(pOp->p1, pIn1); jump_to_p2:  pOp = &aOp[pOp->p2 - 1];  break; } case OP_Return: {  pIn1 = &aMem[pOp->p1];  assert( pIn1->flags==MEM_Int );  pOp = &aOp[pIn1->u.i];  pIn1->flags = MEM_Undefined;  break; } case OP_InitCoroutine: {  assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );  assert( pOp->p2>=0 && pOp->p2<p->nOp );  assert( pOp->p3>=0 && pOp->p3<p->nOp );  pOut = &aMem[pOp->p1];  assert( !VdbeMemDynamic(pOut) );  pOut->u.i = pOp->p3 - 1;  pOut->flags = MEM_Int;  if( pOp->p2 ) goto jump_to_p2;  break; } case OP_EndCoroutine: {  VdbeOp *pCaller;  pIn1 = &aMem[pOp->p1];  assert( pIn1->flags==MEM_Int );  assert( pIn1->u.i>=0 && pIn1->u.i<p->nOp );  pCaller = &aOp[pIn1->u.i];  assert( pCaller->opcode==OP_Yield );  assert( pCaller->p2>=0 && pCaller->p2<p->nOp );  pOp = &aOp[pCaller->p2 - 1];  pIn1->flags = MEM_Undefined;  break; } case OP_Yield: {  int pcDest;  pIn1 = &aMem[pOp->p1];  assert( VdbeMemDynamic(pIn1)==0 );  pIn1->flags = MEM_Int;  pcDest = (int)pIn1->u.i;  pIn1->u.i = (int)(pOp - aOp);  REGISTER_TRACE(pOp->p1, pIn1);  pOp = &aOp[pcDest];  break; } case OP_HaltIfNull: {  pIn3 = &aMem[pOp->p3];
#ifdef SQLITE_DEBUG
 if( pOp->p2==OE_Abort ){ sqlite3VdbeAssertAbortable(p); }
#endif
 if( (pIn3->flags & MEM_Null)==0 ) break;  deliberate_fall_through } case OP_Halt: {  VdbeFrame *pFrame;  int pcx;  pcx = (int)(pOp - aOp);
#ifdef SQLITE_DEBUG
 if( pOp->p2==OE_Abort ){ sqlite3VdbeAssertAbortable(p); }
#endif
 if( pOp->p1==SQLITE_OK && p->pFrame ){  pFrame = p->pFrame;  p->pFrame = pFrame->pParent;  p->nFrame--;  sqlite3VdbeSetChanges(db, p->nChange);  pcx = sqlite3VdbeFrameRestore(pFrame);  if( pOp->p2==OE_Ignore ){  pcx = p->aOp[pcx].p2-1;  }  aOp = p->aOp;  aMem = p->aMem;  pOp = &aOp[pcx];  break;  }  p->rc = pOp->p1;  p->errorAction = (u8)pOp->p2;  p->pc = pcx;  assert( pOp->p5<=4 );  if( p->rc ){  if( pOp->p5 ){  static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK",   "FOREIGN KEY" };  testcase( pOp->p5==1 );  testcase( pOp->p5==2 );  testcase( pOp->p5==3 );  testcase( pOp->p5==4 );  sqlite3VdbeError(p, "%s constraint failed", azType[pOp->p5-1]);  if( pOp->p4.z ){  p->zErrMsg = sqlite3MPrintf(db, "%z: %s", p->zErrMsg, pOp->p4.z);  }  }else{  sqlite3VdbeError(p, "%s", pOp->p4.z);  }  sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pcx, p->zSql, p->zErrMsg);  }  rc = sqlite3VdbeHalt(p);  assert( rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR );  if( rc==SQLITE_BUSY ){  p->rc = SQLITE_BUSY;  }else{  assert( rc==SQLITE_OK || (p->rc&0xff)==SQLITE_CONSTRAINT );  assert( rc==SQLITE_OK || db->nDeferredCons>0 || db->nDeferredImmCons>0 );  rc = p->rc ? SQLITE_ERROR : SQLITE_DONE;  }  goto vdbe_return; } case OP_Integer: {  pOut = out2Prerelease(p, pOp);  pOut->u.i = pOp->p1;  break; } case OP_Int64: {  pOut = out2Prerelease(p, pOp);  assert( pOp->p4.pI64!=0 );  pOut->u.i = *pOp->p4.pI64;  break; }
#ifndef SQLITE_OMIT_FLOATING_POINT
case OP_Real: {  pOut = out2Prerelease(p, pOp);  pOut->flags = MEM_Real;  assert( !sqlite3IsNaN(*pOp->p4.pReal) );  pOut->u.r = *pOp->p4.pReal;  break; }
#endif
case OP_String8: {  assert( pOp->p4.z!=0 );  pOut = out2Prerelease(p, pOp);  pOp->p1 = sqlite3Strlen30(pOp->p4.z);
#ifndef SQLITE_OMIT_UTF16
 if( encoding!=SQLITE_UTF8 ){  rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC);  assert( rc==SQLITE_OK || rc==SQLITE_TOOBIG );  if( rc ) goto too_big;  if( SQLITE_OK!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem;  assert( pOut->szMalloc>0 && pOut->zMalloc==pOut->z );  assert( VdbeMemDynamic(pOut)==0 );  pOut->szMalloc = 0;  pOut->flags |= MEM_Static;  if( pOp->p4type==P4_DYNAMIC ){  sqlite3DbFree(db, pOp->p4.z);  }  pOp->p4type = P4_DYNAMIC;  pOp->p4.z = pOut->z;  pOp->p1 = pOut->n;  }
#endif
 if( pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH] ){  goto too_big;  }  pOp->opcode = OP_String;  assert( rc==SQLITE_OK );  deliberate_fall_through } case OP_String: {  assert( pOp->p4.z!=0 );  pOut = out2Prerelease(p, pOp);  pOut->flags = MEM_Str|MEM_Static|MEM_Term;  pOut->z = pOp->p4.z;  pOut->n = pOp->p1;  pOut->enc = encoding;  UPDATE_MAX_BLOBSIZE(pOut);
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 if( pOp->p3>0 ){  assert( pOp->p3<=(p->nMem+1 - p->nCursor) );  pIn3 = &aMem[pOp->p3];  assert( pIn3->flags & MEM_Int );  if( pIn3->u.i==pOp->p5 ) pOut->flags = MEM_Blob|MEM_Static|MEM_Term;  }
#endif
 break; } case OP_Null: {  int cnt;  u16 nullFlag;  pOut = out2Prerelease(p, pOp);  cnt = pOp->p3-pOp->p2;  assert( pOp->p3<=(p->nMem+1 - p->nCursor) );  pOut->flags = nullFlag = pOp->p1 ? (MEM_Null|MEM_Cleared) : MEM_Null;  pOut->n = 0;
#ifdef SQLITE_DEBUG
 pOut->uTemp = 0;
#endif
 while( cnt>0 ){  pOut++;  memAboutToChange(p, pOut);  sqlite3VdbeMemSetNull(pOut);  pOut->flags = nullFlag;  pOut->n = 0;  cnt--;  }  break; } case OP_SoftNull: {  assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );  pOut = &aMem[pOp->p1];  pOut->flags = (pOut->flags&~(MEM_Undefined|MEM_AffMask))|MEM_Null;  break; } case OP_Blob: {  assert( pOp->p1 <= SQLITE_MAX_LENGTH );  pOut = out2Prerelease(p, pOp);  sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);  pOut->enc = encoding;  UPDATE_MAX_BLOBSIZE(pOut);  break; } case OP_Variable: {  Mem *pVar;  assert( pOp->p1>0 && pOp->p1<=p->nVar );  assert( pOp->p4.z==0 || pOp->p4.z==sqlite3VListNumToName(p->pVList,pOp->p1) );  pVar = &p->aVar[pOp->p1 - 1];  if( sqlite3VdbeMemTooBig(pVar) ){  goto too_big;  }  pOut = &aMem[pOp->p2];  if( VdbeMemDynamic(pOut) ) sqlite3VdbeMemSetNull(pOut);  memcpy(pOut, pVar, MEMCELLSIZE);  pOut->flags &= ~(MEM_Dyn|MEM_Ephem);  pOut->flags |= MEM_Static|MEM_FromBind;  UPDATE_MAX_BLOBSIZE(pOut);  break; } case OP_Move: {  int n;  int p1;  int p2;  n = pOp->p3;  p1 = pOp->p1;  p2 = pOp->p2;  assert( n>0 && p1>0 && p2>0 );  assert( p1+n<=p2 || p2+n<=p1 );  pIn1 = &aMem[p1];  pOut = &aMem[p2];  do{  assert( pOut<=&aMem[(p->nMem+1 - p->nCursor)] );  assert( pIn1<=&aMem[(p->nMem+1 - p->nCursor)] );  assert( memIsValid(pIn1) );  memAboutToChange(p, pOut);  sqlite3VdbeMemMove(pOut, pIn1);
#ifdef SQLITE_DEBUG
 pIn1->pScopyFrom = 0;  { int i;  for(i=1; i<p->nMem; i++){  if( aMem[i].pScopyFrom==pIn1 ){  aMem[i].pScopyFrom = pOut;  }  }  }
#endif
 Deephemeralize(pOut);  REGISTER_TRACE(p2++, pOut);  pIn1++;  pOut++;  }while( --n );  break; } case OP_Copy: {  int n;  n = pOp->p3;  pIn1 = &aMem[pOp->p1];  pOut = &aMem[pOp->p2];  assert( pOut!=pIn1 );  while( 1 ){  memAboutToChange(p, pOut);  sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);  Deephemeralize(pOut);
#ifdef SQLITE_DEBUG
 pOut->pScopyFrom = 0;
#endif
 REGISTER_TRACE(pOp->p2+pOp->p3-n, pOut);  if( (n--)==0 ) break;  pOut++;  pIn1++;  }  break; } case OP_SCopy: {  pIn1 = &aMem[pOp->p1];  pOut = &aMem[pOp->p2];  assert( pOut!=pIn1 );  sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);
#ifdef SQLITE_DEBUG
 pOut->pScopyFrom = pIn1;  pOut->mScopyFlags = pIn1->flags;
#endif
 break; } case OP_IntCopy: {  pIn1 = &aMem[pOp->p1];  assert( (pIn1->flags & MEM_Int)!=0 );  pOut = &aMem[pOp->p2];  sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);  break; } case OP_ChngCntRow: {  assert( pOp->p2==1 );  if( (rc = sqlite3VdbeCheckFk(p,0))!=SQLITE_OK ){  goto abort_due_to_error;  }  deliberate_fall_through } case OP_ResultRow: {  Mem *pMem;  int i;  assert( p->nResColumn==pOp->p2 );  assert( pOp->p1>0 || CORRUPT_DB );  assert( pOp->p1+pOp->p2<=(p->nMem+1 - p->nCursor)+1 );  p->cacheCtr = (p->cacheCtr + 2)|1;  pMem = p->pResultSet = &aMem[pOp->p1];  for(i=0; i<pOp->p2; i++){  assert( memIsValid(&pMem[i]) );  Deephemeralize(&pMem[i]);  assert( (pMem[i].flags & MEM_Ephem)==0  || (pMem[i].flags & (MEM_Str|MEM_Blob))==0 );  sqlite3VdbeMemNulTerminate(&pMem[i]);  REGISTER_TRACE(pOp->p1+i, &pMem[i]);
#ifdef SQLITE_DEBUG
 pMem[i].pScopyFrom = 0;
#endif
 }  if( db->mallocFailed ) goto no_mem;  if( db->mTrace & SQLITE_TRACE_ROW ){  db->trace.xV2(SQLITE_TRACE_ROW, db->pTraceArg, p, 0);  }  p->pc = (int)(pOp - aOp) + 1;  rc = SQLITE_ROW;  goto vdbe_return; } case OP_Concat: {  i64 nByte;  u16 flags1;  u16 flags2;  pIn1 = &aMem[pOp->p1];  pIn2 = &aMem[pOp->p2];  pOut = &aMem[pOp->p3];  testcase( pOut==pIn2 );  assert( pIn1!=pOut );  flags1 = pIn1->flags;  testcase( flags1 & MEM_Null );  testcase( pIn2->flags & MEM_Null );  if( (flags1 | pIn2->flags) & MEM_Null ){  sqlite3VdbeMemSetNull(pOut);  break;  }  if( (flags1 & (MEM_Str|MEM_Blob))==0 ){  if( sqlite3VdbeMemStringify(pIn1,encoding,0) ) goto no_mem;  flags1 = pIn1->flags & ~MEM_Str;  }else if( (flags1 & MEM_Zero)!=0 ){  if( sqlite3VdbeMemExpandBlob(pIn1) ) goto no_mem;  flags1 = pIn1->flags & ~MEM_Str;  }  flags2 = pIn2->flags;  if( (flags2 & (MEM_Str|MEM_Blob))==0 ){  if( sqlite3VdbeMemStringify(pIn2,encoding,0) ) goto no_mem;  flags2 = pIn2->flags & ~MEM_Str;  }else if( (flags2 & MEM_Zero)!=0 ){  if( sqlite3VdbeMemExpandBlob(pIn2) ) goto no_mem;  flags2 = pIn2->flags & ~MEM_Str;  }  nByte = pIn1->n + pIn2->n;  if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){  goto too_big;  }  if( sqlite3VdbeMemGrow(pOut, (int)nByte+3, pOut==pIn2) ){  goto no_mem;  }  MemSetTypeFlag(pOut, MEM_Str);  if( pOut!=pIn2 ){  memcpy(pOut->z, pIn2->z, pIn2->n);  assert( (pIn2->flags & MEM_Dyn) == (flags2 & MEM_Dyn) );  pIn2->flags = flags2;  }  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);  assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );  pIn1->flags = flags1;  pOut->z[nByte]=0;  pOut->z[nByte+1] = 0;  pOut->z[nByte+2] = 0;  pOut->flags |= MEM_Term;  pOut->n = (int)nByte;  pOut->enc = encoding;  UPDATE_MAX_BLOBSIZE(pOut);  break; } case OP_Add: case OP_Subtract: case OP_Multiply: case OP_Divide: case OP_Remainder: {  u16 flags;  u16 type1;  u16 type2;  i64 iA;  i64 iB;  double rA;  double rB;  pIn1 = &aMem[pOp->p1];  type1 = numericType(pIn1);  pIn2 = &aMem[pOp->p2];  type2 = numericType(pIn2);  pOut = &aMem[pOp->p3];  flags = pIn1->flags | pIn2->flags;  if( (type1 & type2 & MEM_Int)!=0 ){  iA = pIn1->u.i;  iB = pIn2->u.i;  switch( pOp->opcode ){  case OP_Add:  if( sqlite3AddInt64(&iB,iA) ) goto fp_math; break;  case OP_Subtract: if( sqlite3SubInt64(&iB,iA) ) goto fp_math; break;  case OP_Multiply: if( sqlite3MulInt64(&iB,iA) ) goto fp_math; break;  case OP_Divide: {  if( iA==0 ) goto arithmetic_result_is_null;  if( iA==-1 && iB==SMALLEST_INT64 ) goto fp_math;  iB /= iA;  break;  }  default: {  if( iA==0 ) goto arithmetic_result_is_null;  if( iA==-1 ) iA = 1;  iB %= iA;  break;  }  }  pOut->u.i = iB;  MemSetTypeFlag(pOut, MEM_Int);  }else if( (flags & MEM_Null)!=0 ){  goto arithmetic_result_is_null;  }else{ fp_math:  rA = sqlite3VdbeRealValue(pIn1);  rB = sqlite3VdbeRealValue(pIn2);  switch( pOp->opcode ){  case OP_Add:  rB += rA;  break;  case OP_Subtract: rB -= rA;  break;  case OP_Multiply: rB *= rA;  break;  case OP_Divide: {  if( rA==(double)0 ) goto arithmetic_result_is_null;  rB /= rA;  break;  }  default: {  iA = sqlite3VdbeIntValue(pIn1);  iB = sqlite3VdbeIntValue(pIn2);  if( iA==0 ) goto arithmetic_result_is_null;  if( iA==-1 ) iA = 1;  rB = (double)(iB % iA);  break;  }  }
#ifdef SQLITE_OMIT_FLOATING_POINT
 pOut->u.i = rB;  MemSetTypeFlag(pOut, MEM_Int);
#else
 if( sqlite3IsNaN(rB) ){  goto arithmetic_result_is_null;  }  pOut->u.r = rB;  MemSetTypeFlag(pOut, MEM_Real);
#endif
 }  break; arithmetic_result_is_null:  sqlite3VdbeMemSetNull(pOut);  break; } case OP_CollSeq: {  assert( pOp->p4type==P4_COLLSEQ );  if( pOp->p1 ){  sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);  }  break; } case OP_BitAnd: case OP_BitOr: case OP_ShiftLeft: case OP_ShiftRight: {  i64 iA;  u64 uA;  i64 iB;  u8 op;  pIn1 = &aMem[pOp->p1];  pIn2 = &aMem[pOp->p2];  pOut = &aMem[pOp->p3];  if( (pIn1->flags | pIn2->flags) & MEM_Null ){  sqlite3VdbeMemSetNull(pOut);  break;  }  iA = sqlite3VdbeIntValue(pIn2);  iB = sqlite3VdbeIntValue(pIn1);  op = pOp->opcode;  if( op==OP_BitAnd ){  iA &= iB;  }else if( op==OP_BitOr ){  iA |= iB;  }else if( iB!=0 ){  assert( op==OP_ShiftRight || op==OP_ShiftLeft );  if( iB<0 ){  assert( OP_ShiftRight==OP_ShiftLeft+1 );  op = 2*OP_ShiftLeft + 1 - op;  iB = iB>(-64) ? -iB : 64;  }  if( iB>=64 ){  iA = (iA>=0 || op==OP_ShiftLeft) ? 0 : -1;  }else{  memcpy(&uA, &iA, sizeof(uA));  if( op==OP_ShiftLeft ){  uA <<= iB;  }else{  uA >>= iB;  if( iA<0 ) uA |= ((((u64)0xffffffff)<<32)|0xffffffff) << (64-iB);  }  memcpy(&iA, &uA, sizeof(iA));  }  }  pOut->u.i = iA;  MemSetTypeFlag(pOut, MEM_Int);  break; } case OP_AddImm: {  pIn1 = &aMem[pOp->p1];  memAboutToChange(p, pIn1);  sqlite3VdbeMemIntegerify(pIn1);  pIn1->u.i += pOp->p2;  break; } case OP_MustBeInt: {  pIn1 = &aMem[pOp->p1];  if( (pIn1->flags & MEM_Int)==0 ){  applyAffinity(pIn1, SQLITE_AFF_NUMERIC, encoding);  if( (pIn1->flags & MEM_Int)==0 ){  VdbeBranchTaken(1, 2);  if( pOp->p2==0 ){  rc = SQLITE_MISMATCH;  goto abort_due_to_error;  }else{  goto jump_to_p2;  }  }  }  VdbeBranchTaken(0, 2);  MemSetTypeFlag(pIn1, MEM_Int);  break; }
#ifndef SQLITE_OMIT_FLOATING_POINT
case OP_RealAffinity: {  pIn1 = &aMem[pOp->p1];  if( pIn1->flags & (MEM_Int|MEM_IntReal) ){  testcase( pIn1->flags & MEM_Int );  testcase( pIn1->flags & MEM_IntReal );  sqlite3VdbeMemRealify(pIn1);  REGISTER_TRACE(pOp->p1, pIn1);  }  break; }
#endif
#ifndef SQLITE_OMIT_CAST
case OP_Cast: {  assert( pOp->p2>=SQLITE_AFF_BLOB && pOp->p2<=SQLITE_AFF_REAL );  testcase( pOp->p2==SQLITE_AFF_TEXT );  testcase( pOp->p2==SQLITE_AFF_BLOB );  testcase( pOp->p2==SQLITE_AFF_NUMERIC );  testcase( pOp->p2==SQLITE_AFF_INTEGER );  testcase( pOp->p2==SQLITE_AFF_REAL );  pIn1 = &aMem[pOp->p1];  memAboutToChange(p, pIn1);  rc = ExpandBlob(pIn1);  if( rc ) goto abort_due_to_error;  rc = sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);  if( rc ) goto abort_due_to_error;  UPDATE_MAX_BLOBSIZE(pIn1);  REGISTER_TRACE(pOp->p1, pIn1);  break; }
#endif
case OP_Eq: case OP_Ne: case OP_Lt: case OP_Le: case OP_Gt: case OP_Ge: {  int res, res2;  char affinity;  u16 flags1;  u16 flags3;  pIn1 = &aMem[pOp->p1];  pIn3 = &aMem[pOp->p3];  flags1 = pIn1->flags;  flags3 = pIn3->flags;  if( (flags1 & flags3 & MEM_Int)!=0 ){  assert( (pOp->p5 & SQLITE_AFF_MASK)!=SQLITE_AFF_TEXT || CORRUPT_DB );  if( pIn3->u.i > pIn1->u.i ){  iCompare = +1;  if( sqlite3aGTb[pOp->opcode] ){  VdbeBranchTaken(1, (pOp->p5 & SQLITE_NULLEQ)?2:3);  goto jump_to_p2;  }  }else if( pIn3->u.i < pIn1->u.i ){  iCompare = -1;  if( sqlite3aLTb[pOp->opcode] ){  VdbeBranchTaken(1, (pOp->p5 & SQLITE_NULLEQ)?2:3);  goto jump_to_p2;  }  }else{  iCompare = 0;  if( sqlite3aEQb[pOp->opcode] ){  VdbeBranchTaken(1, (pOp->p5 & SQLITE_NULLEQ)?2:3);  goto jump_to_p2;  }  }  VdbeBranchTaken(0, (pOp->p5 & SQLITE_NULLEQ)?2:3);  break;  }  if( (flags1 | flags3)&MEM_Null ){  if( pOp->p5 & SQLITE_NULLEQ ){  assert( (flags1 & MEM_Cleared)==0 );  assert( (pOp->p5 & SQLITE_JUMPIFNULL)==0 || CORRUPT_DB );  testcase( (pOp->p5 & SQLITE_JUMPIFNULL)!=0 );  if( (flags1&flags3&MEM_Null)!=0   && (flags3&MEM_Cleared)==0  ){  res = 0;  }else{  res = ((flags3 & MEM_Null) ? -1 : +1);  }  }else{  iCompare = 1;  VdbeBranchTaken(2,3);  if( pOp->p5 & SQLITE_JUMPIFNULL ){  goto jump_to_p2;  }  break;  }  }else{  affinity = pOp->p5 & SQLITE_AFF_MASK;  if( affinity>=SQLITE_AFF_NUMERIC ){  if( (flags1 | flags3)&MEM_Str ){  if( (flags1 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){  applyNumericAffinity(pIn1,0);  testcase( flags3==pIn3->flags );  flags3 = pIn3->flags;  }  if( (flags3 & (MEM_Int|MEM_IntReal|MEM_Real|MEM_Str))==MEM_Str ){  applyNumericAffinity(pIn3,0);  }  }  }else if( affinity==SQLITE_AFF_TEXT ){  if( (flags1 & MEM_Str)==0 && (flags1&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){  testcase( pIn1->flags & MEM_Int );  testcase( pIn1->flags & MEM_Real );  testcase( pIn1->flags & MEM_IntReal );  sqlite3VdbeMemStringify(pIn1, encoding, 1);  testcase( (flags1&MEM_Dyn) != (pIn1->flags&MEM_Dyn) );  flags1 = (pIn1->flags & ~MEM_TypeMask) | (flags1 & MEM_TypeMask);  if( NEVER(pIn1==pIn3) ) flags3 = flags1 | MEM_Str;  }  if( (flags3 & MEM_Str)==0 && (flags3&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){  testcase( pIn3->flags & MEM_Int );  testcase( pIn3->flags & MEM_Real );  testcase( pIn3->flags & MEM_IntReal );  sqlite3VdbeMemStringify(pIn3, encoding, 1);  testcase( (flags3&MEM_Dyn) != (pIn3->flags&MEM_Dyn) );  flags3 = (pIn3->flags & ~MEM_TypeMask) | (flags3 & MEM_TypeMask);  }  }  assert( pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 );  res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);  }  assert( OP_Eq==OP_Ne+1 ); assert( OP_Gt==OP_Ne+2 ); assert( OP_Le==OP_Ne+3 );  assert( OP_Lt==OP_Ne+4 ); assert( OP_Ge==OP_Ne+5 );  if( res<0 ){  res2 = sqlite3aLTb[pOp->opcode];  }else if( res==0 ){  res2 = sqlite3aEQb[pOp->opcode];  }else{  res2 = sqlite3aGTb[pOp->opcode];  }  iCompare = res;  assert( (pIn3->flags & MEM_Dyn) == (flags3 & MEM_Dyn) );  pIn3->flags = flags3;  assert( (pIn1->flags & MEM_Dyn) == (flags1 & MEM_Dyn) );  pIn1->flags = flags1;  VdbeBranchTaken(res2!=0, (pOp->p5 & SQLITE_NULLEQ)?2:3);  if( res2 ){  goto jump_to_p2;  }  break; } case OP_ElseEq: {
#ifdef SQLITE_DEBUG
 int iAddr;  for(iAddr = (int)(pOp - aOp) - 1; ALWAYS(iAddr>=0); iAddr--){  if( aOp[iAddr].opcode==OP_ReleaseReg ) continue;  assert( aOp[iAddr].opcode==OP_Lt || aOp[iAddr].opcode==OP_Gt );  break;  }
#endif
 VdbeBranchTaken(iCompare==0, 2);  if( iCompare==0 ) goto jump_to_p2;  break; } case OP_Permutation: {  assert( pOp->p4type==P4_INTARRAY );  assert( pOp->p4.ai );  assert( pOp[1].opcode==OP_Compare );  assert( pOp[1].p5 & OPFLAG_PERMUTE );  break; } case OP_Compare: {  int n;  int i;  int p1;  int p2;  const KeyInfo *pKeyInfo;  u32 idx;  CollSeq *pColl;  int bRev;  u32 *aPermute;  if( (pOp->p5 & OPFLAG_PERMUTE)==0 ){  aPermute = 0;  }else{  assert( pOp>aOp );  assert( pOp[-1].opcode==OP_Permutation );  assert( pOp[-1].p4type==P4_INTARRAY );  aPermute = pOp[-1].p4.ai + 1;  assert( aPermute!=0 );  }  n = pOp->p3;  pKeyInfo = pOp->p4.pKeyInfo;  assert( n>0 );  assert( pKeyInfo!=0 );  p1 = pOp->p1;  p2 = pOp->p2;
#ifdef SQLITE_DEBUG
 if( aPermute ){  int k, mx = 0;  for(k=0; k<n; k++) if( aPermute[k]>(u32)mx ) mx = aPermute[k];  assert( p1>0 && p1+mx<=(p->nMem+1 - p->nCursor)+1 );  assert( p2>0 && p2+mx<=(p->nMem+1 - p->nCursor)+1 );  }else{  assert( p1>0 && p1+n<=(p->nMem+1 - p->nCursor)+1 );  assert( p2>0 && p2+n<=(p->nMem+1 - p->nCursor)+1 );  }
#endif
 for(i=0; i<n; i++){  idx = aPermute ? aPermute[i] : (u32)i;  assert( memIsValid(&aMem[p1+idx]) );  assert( memIsValid(&aMem[p2+idx]) );  REGISTER_TRACE(p1+idx, &aMem[p1+idx]);  REGISTER_TRACE(p2+idx, &aMem[p2+idx]);  assert( i<pKeyInfo->nKeyField );  pColl = pKeyInfo->aColl[i];  bRev = (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_DESC);  iCompare = sqlite3MemCompare(&aMem[p1+idx], &aMem[p2+idx], pColl);  if( iCompare ){  if( (pKeyInfo->aSortFlags[i] & KEYINFO_ORDER_BIGNULL)   && ((aMem[p1+idx].flags & MEM_Null) || (aMem[p2+idx].flags & MEM_Null))  ){  iCompare = -iCompare;  }  if( bRev ) iCompare = -iCompare;  break;  }  }  break; } case OP_Jump: {  if( iCompare<0 ){  VdbeBranchTaken(0,4); pOp = &aOp[pOp->p1 - 1];  }else if( iCompare==0 ){  VdbeBranchTaken(1,4); pOp = &aOp[pOp->p2 - 1];  }else{  VdbeBranchTaken(2,4); pOp = &aOp[pOp->p3 - 1];  }  break; } case OP_And: case OP_Or: {  int v1;  int v2;  v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);  v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);  if( pOp->opcode==OP_And ){  static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };  v1 = and_logic[v1*3+v2];  }else{  static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };  v1 = or_logic[v1*3+v2];  }  pOut = &aMem[pOp->p3];  if( v1==2 ){  MemSetTypeFlag(pOut, MEM_Null);  }else{  pOut->u.i = v1;  MemSetTypeFlag(pOut, MEM_Int);  }  break; } case OP_IsTrue: {  assert( pOp->p4type==P4_INT32 );  assert( pOp->p4.i==0 || pOp->p4.i==1 );  assert( pOp->p3==0 || pOp->p3==1 );  sqlite3VdbeMemSetInt64(&aMem[pOp->p2],  sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);  break; } case OP_Not: {  pIn1 = &aMem[pOp->p1];  pOut = &aMem[pOp->p2];  if( (pIn1->flags & MEM_Null)==0 ){  sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1,0));  }else{  sqlite3VdbeMemSetNull(pOut);  }  break; } case OP_BitNot: {  pIn1 = &aMem[pOp->p1];  pOut = &aMem[pOp->p2];  sqlite3VdbeMemSetNull(pOut);  if( (pIn1->flags & MEM_Null)==0 ){  pOut->flags = MEM_Int;  pOut->u.i = ~sqlite3VdbeIntValue(pIn1);  }  break; } case OP_Once: {  u32 iAddr;  assert( p->aOp[0].opcode==OP_Init );  if( p->pFrame ){  iAddr = (int)(pOp - p->aOp);  if( (p->pFrame->aOnce[iAddr/8] & (1<<(iAddr & 7)))!=0 ){  VdbeBranchTaken(1, 2);  goto jump_to_p2;  }  p->pFrame->aOnce[iAddr/8] |= 1<<(iAddr & 7);  }else{  if( p->aOp[0].p1==pOp->p1 ){  VdbeBranchTaken(1, 2);  goto jump_to_p2;  }  }  VdbeBranchTaken(0, 2);  pOp->p1 = p->aOp[0].p1;  break; } case OP_If: {  int c;  c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);  VdbeBranchTaken(c!=0, 2);  if( c ) goto jump_to_p2;  break; } case OP_IfNot: {  int c;  c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);  VdbeBranchTaken(c!=0, 2);  if( c ) goto jump_to_p2;  break; } case OP_IsNull: {  pIn1 = &aMem[pOp->p1];  VdbeBranchTaken( (pIn1->flags & MEM_Null)!=0, 2);  if( (pIn1->flags & MEM_Null)!=0 ){  goto jump_to_p2;  }  break; } case OP_IsNullOrType: {  int doTheJump;  pIn1 = &aMem[pOp->p1];  doTheJump = (pIn1->flags & MEM_Null)!=0 || sqlite3_value_type(pIn1)==pOp->p3;  VdbeBranchTaken( doTheJump, 2);  if( doTheJump ) goto jump_to_p2;  break; } case OP_ZeroOrNull: {  if( (aMem[pOp->p1].flags & MEM_Null)!=0   || (aMem[pOp->p3].flags & MEM_Null)!=0  ){  sqlite3VdbeMemSetNull(aMem + pOp->p2);  }else{  sqlite3VdbeMemSetInt64(aMem + pOp->p2, 0);  }  break; } case OP_NotNull: {  pIn1 = &aMem[pOp->p1];  VdbeBranchTaken( (pIn1->flags & MEM_Null)==0, 2);  if( (pIn1->flags & MEM_Null)==0 ){  goto jump_to_p2;  }  break; } case OP_IfNullRow: {  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( p->apCsr[pOp->p1]!=0 );  if( p->apCsr[pOp->p1]->nullRow ){  sqlite3VdbeMemSetNull(aMem + pOp->p3);  goto jump_to_p2;  }  break; }
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
case OP_Offset: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  pOut = &p->aMem[pOp->p3];  if( NEVER(pC==0) || pC->eCurType!=CURTYPE_BTREE ){  sqlite3VdbeMemSetNull(pOut);  }else{  sqlite3VdbeMemSetInt64(pOut, sqlite3BtreeOffset(pC->uc.pCursor));  }  break; }
#endif
case OP_Column: {  u32 p2;  VdbeCursor *pC;  BtCursor *pCrsr;  u32 *aOffset;  int len;  int i;  Mem *pDest;  Mem sMem;  const u8 *zData;  const u8 *zHdr;  const u8 *zEndHdr;  u64 offset64;  u32 t;  Mem *pReg;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  p2 = (u32)pOp->p2;  rc = sqlite3VdbeCursorMoveto(&pC, &p2);  if( rc ) goto abort_due_to_error;  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );  pDest = &aMem[pOp->p3];  memAboutToChange(p, pDest);  assert( pC!=0 );  assert( p2<(u32)pC->nField );  aOffset = pC->aOffset;  assert( pC->eCurType!=CURTYPE_VTAB );  assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow );  assert( pC->eCurType!=CURTYPE_SORTER );  if( pC->cacheStatus!=p->cacheCtr ){  if( pC->nullRow ){  if( pC->eCurType==CURTYPE_PSEUDO ){  assert( pC->seekResult>0 );  pReg = &aMem[pC->seekResult];  assert( pReg->flags & MEM_Blob );  assert( memIsValid(pReg) );  pC->payloadSize = pC->szRow = pReg->n;  pC->aRow = (u8*)pReg->z;  }else{  sqlite3VdbeMemSetNull(pDest);  goto op_column_out;  }  }else{  pCrsr = pC->uc.pCursor;  assert( pC->eCurType==CURTYPE_BTREE );  assert( pCrsr );  assert( sqlite3BtreeCursorIsValid(pCrsr) );  pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);  pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);  assert( pC->szRow<=pC->payloadSize );  assert( pC->szRow<=65536 );  if( pC->payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){  goto too_big;  }  }  pC->cacheStatus = p->cacheCtr;  pC->iHdrOffset = getVarint32(pC->aRow, aOffset[0]);  pC->nHdrParsed = 0;  if( pC->szRow<aOffset[0] ){  pC->aRow = 0;  pC->szRow = 0;  if( aOffset[0] > 98307 || aOffset[0] > pC->payloadSize ){  goto op_column_corrupt;  }  }else{  zData = pC->aRow;  assert( pC->nHdrParsed<=p2 );  testcase( aOffset[0]==0 );  goto op_column_read_header;  }  }  if( pC->nHdrParsed<=p2 ){  if( pC->iHdrOffset<aOffset[0] ){  if( pC->aRow==0 ){  memset(&sMem, 0, sizeof(sMem));  rc = sqlite3VdbeMemFromBtreeZeroOffset(pC->uc.pCursor,aOffset[0],&sMem);  if( rc!=SQLITE_OK ) goto abort_due_to_error;  zData = (u8*)sMem.z;  }else{  zData = pC->aRow;  }  op_column_read_header:  i = pC->nHdrParsed;  offset64 = aOffset[i];  zHdr = zData + pC->iHdrOffset;  zEndHdr = zData + aOffset[0];  testcase( zHdr>=zEndHdr );  do{  if( (pC->aType[i] = t = zHdr[0])<0x80 ){  zHdr++;  offset64 += sqlite3VdbeOneByteSerialTypeLen(t);  }else{  zHdr += sqlite3GetVarint32(zHdr, &t);  pC->aType[i] = t;  offset64 += sqlite3VdbeSerialTypeLen(t);  }  aOffset[++i] = (u32)(offset64 & 0xffffffff);  }while( (u32)i<=p2 && zHdr<zEndHdr );  if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize))   || (offset64 > pC->payloadSize)  ){  if( aOffset[0]==0 ){  i = 0;  zHdr = zEndHdr;  }else{  if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem);  goto op_column_corrupt;  }  }  pC->nHdrParsed = i;  pC->iHdrOffset = (u32)(zHdr - zData);  if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem);  }else{  t = 0;  }  if( pC->nHdrParsed<=p2 ){  if( pOp->p4type==P4_MEM ){  sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, MEM_Static);  }else{  sqlite3VdbeMemSetNull(pDest);  }  goto op_column_out;  }  }else{  t = pC->aType[p2];  }  assert( p2<pC->nHdrParsed );  assert( rc==SQLITE_OK );  assert( sqlite3VdbeCheckMemInvariants(pDest) );  if( VdbeMemDynamic(pDest) ){  sqlite3VdbeMemSetNull(pDest);  }  assert( t==pC->aType[p2] );  if( pC->szRow>=aOffset[p2+1] ){  zData = pC->aRow + aOffset[p2];  if( t<12 ){  sqlite3VdbeSerialGet(zData, t, pDest);  }else{  static const u16 aFlag[] = { MEM_Blob, MEM_Str|MEM_Term };  pDest->n = len = (t-12)/2;  pDest->enc = encoding;  if( pDest->szMalloc < len+2 ){  pDest->flags = MEM_Null;  if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem;  }else{  pDest->z = pDest->zMalloc;  }  memcpy(pDest->z, zData, len);  pDest->z[len] = 0;  pDest->z[len+1] = 0;  pDest->flags = aFlag[t&1];  }  }else{  pDest->enc = encoding;  if( ((pOp->p5 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0  && ((t>=12 && (t&1)==0) || (pOp->p5 & OPFLAG_TYPEOFARG)!=0))   || (len = sqlite3VdbeSerialTypeLen(t))==0  ){  sqlite3VdbeSerialGet((u8*)sqlite3CtypeMap, t, pDest);  }else{  rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);  if( rc!=SQLITE_OK ) goto abort_due_to_error;  sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);  pDest->flags &= ~MEM_Ephem;  }  } op_column_out:  UPDATE_MAX_BLOBSIZE(pDest);  REGISTER_TRACE(pOp->p3, pDest);  break; op_column_corrupt:  if( aOp[0].p3>0 ){  pOp = &aOp[aOp[0].p3-1];  break;  }else{  rc = SQLITE_CORRUPT_BKPT;  goto abort_due_to_error;  } } case OP_TypeCheck: {  Table *pTab;  Column *aCol;  int i;  assert( pOp->p4type==P4_TABLE );  pTab = pOp->p4.pTab;  assert( pTab->tabFlags & TF_Strict );  assert( pTab->nNVCol==pOp->p2 );  aCol = pTab->aCol;  pIn1 = &aMem[pOp->p1];  for(i=0; i<pTab->nCol; i++){  if( aCol[i].colFlags & COLFLAG_GENERATED ){  if( aCol[i].colFlags & COLFLAG_VIRTUAL ) continue;  if( pOp->p3 ){ pIn1++; continue; }  }  assert( pIn1 < &aMem[pOp->p1+pOp->p2] );  applyAffinity(pIn1, aCol[i].affinity, encoding);  if( (pIn1->flags & MEM_Null)==0 ){  switch( aCol[i].eCType ){  case COLTYPE_BLOB: {  if( (pIn1->flags & MEM_Blob)==0 ) goto vdbe_type_error;  break;  }  case COLTYPE_INTEGER:  case COLTYPE_INT: {  if( (pIn1->flags & MEM_Int)==0 ) goto vdbe_type_error;  break;  }  case COLTYPE_TEXT: {  if( (pIn1->flags & MEM_Str)==0 ) goto vdbe_type_error;  break;  }  case COLTYPE_REAL: {  if( pIn1->flags & MEM_Int ){  testcase( pIn1->u.i==140737488355328LL );  testcase( pIn1->u.i==140737488355327LL );  testcase( pIn1->u.i==-140737488355328LL );  testcase( pIn1->u.i==-140737488355329LL );  if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL){  pIn1->flags |= MEM_IntReal;  pIn1->flags &= ~MEM_Int;  }else{  pIn1->u.r = (double)pIn1->u.i;  pIn1->flags |= MEM_Real;  pIn1->flags &= ~MEM_Int;  }  }else if( (pIn1->flags & MEM_Real)==0 ){  goto vdbe_type_error;  }  break;  }  default: {  break;  }  }  }  REGISTER_TRACE((int)(pIn1-aMem), pIn1);  pIn1++;  }  assert( pIn1 == &aMem[pOp->p1+pOp->p2] );  break; vdbe_type_error:  sqlite3VdbeError(p, "cannot store %s value in %s column %s.%s",   vdbeMemTypeName(pIn1), sqlite3StdType[aCol[i].eCType-1],   pTab->zName, aCol[i].zCnName);  rc = SQLITE_CONSTRAINT_DATATYPE;  goto abort_due_to_error; } case OP_Affinity: {  const char *zAffinity;  zAffinity = pOp->p4.z;  assert( zAffinity!=0 );  assert( pOp->p2>0 );  assert( zAffinity[pOp->p2]==0 );  pIn1 = &aMem[pOp->p1];  while( 1 ){  assert( pIn1 <= &p->aMem[(p->nMem+1 - p->nCursor)] );  assert( zAffinity[0]==SQLITE_AFF_NONE || memIsValid(pIn1) );  applyAffinity(pIn1, zAffinity[0], encoding);  if( zAffinity[0]==SQLITE_AFF_REAL && (pIn1->flags & MEM_Int)!=0 ){  testcase( pIn1->u.i==140737488355328LL );  testcase( pIn1->u.i==140737488355327LL );  testcase( pIn1->u.i==-140737488355328LL );  testcase( pIn1->u.i==-140737488355329LL );  if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL ){  pIn1->flags |= MEM_IntReal;  pIn1->flags &= ~MEM_Int;  }else{  pIn1->u.r = (double)pIn1->u.i;  pIn1->flags |= MEM_Real;  pIn1->flags &= ~MEM_Int;  }  }  REGISTER_TRACE((int)(pIn1-aMem), pIn1);  zAffinity++;  if( zAffinity[0]==0 ) break;  pIn1++;  }  break; } case OP_MakeRecord: {  Mem *pRec;  u64 nData;  int nHdr;  i64 nByte;  i64 nZero;  int nVarint;  u32 serial_type;  Mem *pData0;  Mem *pLast;  int nField;  char *zAffinity;  int file_format;  u32 len;  u8 *zHdr;  u8 *zPayload;  nData = 0;  nHdr = 0;  nZero = 0;  nField = pOp->p1;  zAffinity = pOp->p4.z;  assert( nField>0 && pOp->p2>0 && pOp->p2+nField<=(p->nMem+1 - p->nCursor)+1 );  pData0 = &aMem[nField];  nField = pOp->p2;  pLast = &pData0[nField-1];  file_format = p->minWriteFileFormat;  assert( pOp->p3<pOp->p1 || pOp->p3>=pOp->p1+pOp->p2 );  pOut = &aMem[pOp->p3];  memAboutToChange(p, pOut);  assert( pData0<=pLast );  if( zAffinity ){  pRec = pData0;  do{  applyAffinity(pRec, zAffinity[0], encoding);  if( zAffinity[0]==SQLITE_AFF_REAL && (pRec->flags & MEM_Int) ){  pRec->flags |= MEM_IntReal;  pRec->flags &= ~(MEM_Int);  }  REGISTER_TRACE((int)(pRec-aMem), pRec);  zAffinity++;  pRec++;  assert( zAffinity[0]==0 || pRec<=pLast );  }while( zAffinity[0] );  }
#ifdef SQLITE_ENABLE_NULL_TRIM
 if( pOp->p5 ){  while( (pLast->flags & MEM_Null)!=0 && nField>pOp->p5 ){  pLast--;  nField--;  }  }
#endif
 pRec = pLast;  do{  assert( memIsValid(pRec) );  if( pRec->flags & MEM_Null ){  if( pRec->flags & MEM_Zero ){
#ifndef SQLITE_ENABLE_NULL_TRIM
 assert( pOp->p5==OPFLAG_NOCHNG_MAGIC || CORRUPT_DB );
#endif
 pRec->uTemp = 10;  }else{  pRec->uTemp = 0;  }  nHdr++;  }else if( pRec->flags & (MEM_Int|MEM_IntReal) ){  i64 i = pRec->u.i;  u64 uu;  testcase( pRec->flags & MEM_Int );  testcase( pRec->flags & MEM_IntReal );  if( i<0 ){  uu = ~i;  }else{  uu = i;  }  nHdr++;  testcase( uu==127 );  testcase( uu==128 );  testcase( uu==32767 );  testcase( uu==32768 );  testcase( uu==8388607 );  testcase( uu==8388608 );  testcase( uu==2147483647 ); testcase( uu==2147483648 );  testcase( uu==140737488355327LL ); testcase( uu==140737488355328LL );  if( uu<=127 ){  if( (i&1)==i && file_format>=4 ){  pRec->uTemp = 8+(u32)uu;  }else{  nData++;  pRec->uTemp = 1;  }  }else if( uu<=32767 ){  nData += 2;  pRec->uTemp = 2;  }else if( uu<=8388607 ){  nData += 3;  pRec->uTemp = 3;  }else if( uu<=2147483647 ){  nData += 4;  pRec->uTemp = 4;  }else if( uu<=140737488355327LL ){  nData += 6;  pRec->uTemp = 5;  }else{  nData += 8;  if( pRec->flags & MEM_IntReal ){  pRec->u.r = (double)pRec->u.i;  pRec->flags &= ~MEM_IntReal;  pRec->flags |= MEM_Real;  pRec->uTemp = 7;  }else{  pRec->uTemp = 6;  }  }  }else if( pRec->flags & MEM_Real ){  nHdr++;  nData += 8;  pRec->uTemp = 7;  }else{  assert( db->mallocFailed || pRec->flags&(MEM_Str|MEM_Blob) );  assert( pRec->n>=0 );  len = (u32)pRec->n;  serial_type = (len*2) + 12 + ((pRec->flags & MEM_Str)!=0);  if( pRec->flags & MEM_Zero ){  serial_type += pRec->u.nZero*2;  if( nData ){  if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem;  len += pRec->u.nZero;  }else{  nZero += pRec->u.nZero;  }  }  nData += len;  nHdr += sqlite3VarintLen(serial_type);  pRec->uTemp = serial_type;  }  if( pRec==pData0 ) break;  pRec--;  }while(1);  testcase( nHdr==126 );  testcase( nHdr==127 );  if( nHdr<=126 ){  nHdr += 1;  }else{  nVarint = sqlite3VarintLen(nHdr);  nHdr += nVarint;  if( nVarint<sqlite3VarintLen(nHdr) ) nHdr++;  }  nByte = nHdr+nData;  if( nByte+nZero<=pOut->szMalloc ){  pOut->z = pOut->zMalloc;  }else{  if( nByte+nZero>db->aLimit[SQLITE_LIMIT_LENGTH] ){  goto too_big;  }  if( sqlite3VdbeMemClearAndResize(pOut, (int)nByte) ){  goto no_mem;  }  }  pOut->n = (int)nByte;  pOut->flags = MEM_Blob;  if( nZero ){  pOut->u.nZero = nZero;  pOut->flags |= MEM_Zero;  }  UPDATE_MAX_BLOBSIZE(pOut);  zHdr = (u8 *)pOut->z;  zPayload = zHdr + nHdr;  zHdr += putVarint32(zHdr, nHdr);  assert( pData0<=pLast );  pRec = pData0;  do{  serial_type = pRec->uTemp;  zHdr += putVarint32(zHdr, serial_type);  zPayload += sqlite3VdbeSerialPut(zPayload, pRec, serial_type);  }while( (++pRec)<=pLast );  assert( nHdr==(int)(zHdr - (u8*)pOut->z) );  assert( nByte==(int)(zPayload - (u8*)pOut->z) );  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );  REGISTER_TRACE(pOp->p3, pOut);  break; } case OP_Count: {  i64 nEntry;  BtCursor *pCrsr;  assert( p->apCsr[pOp->p1]->eCurType==CURTYPE_BTREE );  pCrsr = p->apCsr[pOp->p1]->uc.pCursor;  assert( pCrsr );  if( pOp->p3 ){  nEntry = sqlite3BtreeRowCountEst(pCrsr);  }else{  nEntry = 0;  rc = sqlite3BtreeCount(db, pCrsr, &nEntry);  if( rc ) goto abort_due_to_error;  }  pOut = out2Prerelease(p, pOp);  pOut->u.i = nEntry;  goto check_for_interrupt; } case OP_Savepoint: {  int p1;  char *zName;  int nName;  Savepoint *pNew;  Savepoint *pSavepoint;  Savepoint *pTmp;  int iSavepoint;  int ii;  p1 = pOp->p1;  zName = pOp->p4.z;  assert( db->pSavepoint==0 || db->autoCommit==0 );  assert( p1==SAVEPOINT_BEGIN||p1==SAVEPOINT_RELEASE||p1==SAVEPOINT_ROLLBACK );  assert( db->pSavepoint || db->isTransactionSavepoint==0 );  assert( checkSavepointCount(db) );  assert( p->bIsReader );  if( p1==SAVEPOINT_BEGIN ){  if( db->nVdbeWrite>0 ){  sqlite3VdbeError(p, "cannot open savepoint - SQL statements in progress");  rc = SQLITE_BUSY;  }else{  nName = sqlite3Strlen30(zName);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 assert( db->autoCommit==0 || db->nVTrans==0 );  rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN,  db->nStatement+db->nSavepoint);  if( rc!=SQLITE_OK ) goto abort_due_to_error;
#endif
 pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint)+nName+1);  if( pNew ){  pNew->zName = (char *)&pNew[1];  memcpy(pNew->zName, zName, nName+1);  if( db->autoCommit ){  db->autoCommit = 0;  db->isTransactionSavepoint = 1;  }else{  db->nSavepoint++;  }  pNew->pNext = db->pSavepoint;  db->pSavepoint = pNew;  pNew->nDeferredCons = db->nDeferredCons;  pNew->nDeferredImmCons = db->nDeferredImmCons;  }  }  }else{  assert( p1==SAVEPOINT_RELEASE || p1==SAVEPOINT_ROLLBACK );  iSavepoint = 0;  for(  pSavepoint = db->pSavepoint;  pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName);  pSavepoint = pSavepoint->pNext  ){  iSavepoint++;  }  if( !pSavepoint ){  sqlite3VdbeError(p, "no such savepoint: %s", zName);  rc = SQLITE_ERROR;  }else if( db->nVdbeWrite>0 && p1==SAVEPOINT_RELEASE ){  sqlite3VdbeError(p, "cannot release savepoint - "  "SQL statements in progress");  rc = SQLITE_BUSY;  }else{  int isTransaction = pSavepoint->pNext==0 && db->isTransactionSavepoint;  if( isTransaction && p1==SAVEPOINT_RELEASE ){  if( (rc = sqlite3VdbeCheckFk(p, 1))!=SQLITE_OK ){  goto vdbe_return;  }  db->autoCommit = 1;  if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){  p->pc = (int)(pOp - aOp);  db->autoCommit = 0;  p->rc = rc = SQLITE_BUSY;  goto vdbe_return;  }  rc = p->rc;  if( rc ){  db->autoCommit = 0;  }else{  db->isTransactionSavepoint = 0;  }  }else{  int isSchemaChange;  iSavepoint = db->nSavepoint - iSavepoint - 1;  if( p1==SAVEPOINT_ROLLBACK ){  isSchemaChange = (db->mDbFlags & DBFLAG_SchemaChange)!=0;  for(ii=0; ii<db->nDb; ii++){  rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt,   SQLITE_ABORT_ROLLBACK,   isSchemaChange==0);  if( rc!=SQLITE_OK ) goto abort_due_to_error;  }  }else{  assert( p1==SAVEPOINT_RELEASE );  isSchemaChange = 0;  }  for(ii=0; ii<db->nDb; ii++){  rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);  if( rc!=SQLITE_OK ){  goto abort_due_to_error;  }  }  if( isSchemaChange ){  sqlite3ExpirePreparedStatements(db, 0);  sqlite3ResetAllSchemasOfConnection(db);  db->mDbFlags |= DBFLAG_SchemaChange;  }  }  if( rc ) goto abort_due_to_error;  while( db->pSavepoint!=pSavepoint ){  pTmp = db->pSavepoint;  db->pSavepoint = pTmp->pNext;  sqlite3DbFree(db, pTmp);  db->nSavepoint--;  }  if( p1==SAVEPOINT_RELEASE ){  assert( pSavepoint==db->pSavepoint );  db->pSavepoint = pSavepoint->pNext;  sqlite3DbFree(db, pSavepoint);  if( !isTransaction ){  db->nSavepoint--;  }  }else{  assert( p1==SAVEPOINT_ROLLBACK );  db->nDeferredCons = pSavepoint->nDeferredCons;  db->nDeferredImmCons = pSavepoint->nDeferredImmCons;  }  if( !isTransaction || p1==SAVEPOINT_ROLLBACK ){  rc = sqlite3VtabSavepoint(db, p1, iSavepoint);  if( rc!=SQLITE_OK ) goto abort_due_to_error;  }  }  }  if( rc ) goto abort_due_to_error;  break; } case OP_AutoCommit: {  int desiredAutoCommit;  int iRollback;  desiredAutoCommit = pOp->p1;  iRollback = pOp->p2;  assert( desiredAutoCommit==1 || desiredAutoCommit==0 );  assert( desiredAutoCommit==1 || iRollback==0 );  assert( db->nVdbeActive>0 );  assert( p->bIsReader );  if( desiredAutoCommit!=db->autoCommit ){  if( iRollback ){  assert( desiredAutoCommit==1 );  sqlite3RollbackAll(db, SQLITE_ABORT_ROLLBACK);  db->autoCommit = 1;  }else if( desiredAutoCommit && db->nVdbeWrite>0 ){  sqlite3VdbeError(p, "cannot commit transaction - "  "SQL statements in progress");  rc = SQLITE_BUSY;  goto abort_due_to_error;  }else if( (rc = sqlite3VdbeCheckFk(p, 1))!=SQLITE_OK ){  goto vdbe_return;  }else{  db->autoCommit = (u8)desiredAutoCommit;  }  if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){  p->pc = (int)(pOp - aOp);  db->autoCommit = (u8)(1-desiredAutoCommit);  p->rc = rc = SQLITE_BUSY;  goto vdbe_return;  }  sqlite3CloseSavepoints(db);  if( p->rc==SQLITE_OK ){  rc = SQLITE_DONE;  }else{  rc = SQLITE_ERROR;  }  goto vdbe_return;  }else{  sqlite3VdbeError(p,  (!desiredAutoCommit)?"cannot start a transaction within a transaction":(  (iRollback)?"cannot rollback - no transaction is active":   "cannot commit - no transaction is active"));  rc = SQLITE_ERROR;  goto abort_due_to_error;  }  assert(0); } case OP_Transaction: {  Btree *pBt;  int iMeta = 0;  assert( p->bIsReader );  assert( p->readOnly==0 || pOp->p2==0 );  assert( pOp->p2>=0 && pOp->p2<=2 );  assert( pOp->p1>=0 && pOp->p1<db->nDb );  assert( DbMaskTest(p->btreeMask, pOp->p1) );  assert( rc==SQLITE_OK );  if( pOp->p2 && (db->flags & (SQLITE_QueryOnly|SQLITE_CorruptRdOnly))!=0 ){  if( db->flags & SQLITE_QueryOnly ){  rc = SQLITE_READONLY;  }else{  rc = SQLITE_CORRUPT;  }  goto abort_due_to_error;  }  pBt = db->aDb[pOp->p1].pBt;  if( pBt ){  rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);  testcase( rc==SQLITE_BUSY_SNAPSHOT );  testcase( rc==SQLITE_BUSY_RECOVERY );  if( rc!=SQLITE_OK ){  if( (rc&0xff)==SQLITE_BUSY ){  p->pc = (int)(pOp - aOp);  p->rc = rc;  goto vdbe_return;  }  goto abort_due_to_error;  }  if( p->usesStmtJournal   && pOp->p2   && (db->autoCommit==0 || db->nVdbeRead>1)  ){  assert( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE );  if( p->iStatement==0 ){  assert( db->nStatement>=0 && db->nSavepoint>=0 );  db->nStatement++;  p->iStatement = db->nSavepoint + db->nStatement;  }  rc = sqlite3VtabSavepoint(db, SAVEPOINT_BEGIN, p->iStatement-1);  if( rc==SQLITE_OK ){  rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);  }  p->nStmtDefCons = db->nDeferredCons;  p->nStmtDefImmCons = db->nDeferredImmCons;  }  }  assert( pOp->p5==0 || pOp->p4type==P4_INT32 );  if( rc==SQLITE_OK   && pOp->p5   && (iMeta!=pOp->p3  || db->aDb[pOp->p1].pSchema->iGeneration!=pOp->p4.i)  ){  sqlite3DbFree(db, p->zErrMsg);  p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");  if( db->aDb[pOp->p1].pSchema->schema_cookie!=iMeta ){  sqlite3ResetOneSchema(db, pOp->p1);  }  p->expired = 1;  rc = SQLITE_SCHEMA;  }  if( rc ) goto abort_due_to_error;  break; } case OP_ReadCookie: {  int iMeta;  int iDb;  int iCookie;  assert( p->bIsReader );  iDb = pOp->p1;  iCookie = pOp->p3;  assert( pOp->p3<SQLITE_N_BTREE_META );  assert( iDb>=0 && iDb<db->nDb );  assert( db->aDb[iDb].pBt!=0 );  assert( DbMaskTest(p->btreeMask, iDb) );  sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);  pOut = out2Prerelease(p, pOp);  pOut->u.i = iMeta;  break; } case OP_SetCookie: {  Db *pDb;  sqlite3VdbeIncrWriteCounter(p, 0);  assert( pOp->p2<SQLITE_N_BTREE_META );  assert( pOp->p1>=0 && pOp->p1<db->nDb );  assert( DbMaskTest(p->btreeMask, pOp->p1) );  assert( p->readOnly==0 );  pDb = &db->aDb[pOp->p1];  assert( pDb->pBt!=0 );  assert( sqlite3SchemaMutexHeld(db, pOp->p1, 0) );  rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);  if( pOp->p2==BTREE_SCHEMA_VERSION ){  pDb->pSchema->schema_cookie = pOp->p3 - pOp->p5;  db->mDbFlags |= DBFLAG_SchemaChange;  sqlite3FkClearTriggerCache(db, pOp->p1);  }else if( pOp->p2==BTREE_FILE_FORMAT ){  pDb->pSchema->file_format = pOp->p3;  }  if( pOp->p1==1 ){  sqlite3ExpirePreparedStatements(db, 0);  p->expired = 0;  }  if( rc ) goto abort_due_to_error;  break; } case OP_ReopenIdx: {  int nField;  KeyInfo *pKeyInfo;  u32 p2;  int iDb;  int wrFlag;  Btree *pX;  VdbeCursor *pCur;  Db *pDb;  assert( pOp->p5==0 || pOp->p5==OPFLAG_SEEKEQ );  assert( pOp->p4type==P4_KEYINFO );  pCur = p->apCsr[pOp->p1];  if( pCur && pCur->pgnoRoot==(u32)pOp->p2 ){  assert( pCur->iDb==pOp->p3 );  assert( pCur->eCurType==CURTYPE_BTREE );  sqlite3BtreeClearCursor(pCur->uc.pCursor);  goto open_cursor_set_hints;  } case OP_OpenRead: case OP_OpenWrite:  assert( pOp->opcode==OP_OpenWrite || pOp->p5==0 || pOp->p5==OPFLAG_SEEKEQ );  assert( p->bIsReader );  assert( pOp->opcode==OP_OpenRead || pOp->opcode==OP_ReopenIdx  || p->readOnly==0 );  if( p->expired==1 ){  rc = SQLITE_ABORT_ROLLBACK;  goto abort_due_to_error;  }  nField = 0;  pKeyInfo = 0;  p2 = (u32)pOp->p2;  iDb = pOp->p3;  assert( iDb>=0 && iDb<db->nDb );  assert( DbMaskTest(p->btreeMask, iDb) );  pDb = &db->aDb[iDb];  pX = pDb->pBt;  assert( pX!=0 );  if( pOp->opcode==OP_OpenWrite ){  assert( OPFLAG_FORDELETE==BTREE_FORDELETE );  wrFlag = BTREE_WRCSR | (pOp->p5 & OPFLAG_FORDELETE);  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( pDb->pSchema->file_format < p->minWriteFileFormat ){  p->minWriteFileFormat = pDb->pSchema->file_format;  }  }else{  wrFlag = 0;  }  if( pOp->p5 & OPFLAG_P2ISREG ){  assert( p2>0 );  assert( p2<=(u32)(p->nMem+1 - p->nCursor) );  assert( pOp->opcode==OP_OpenWrite );  pIn2 = &aMem[p2];  assert( memIsValid(pIn2) );  assert( (pIn2->flags & MEM_Int)!=0 );  sqlite3VdbeMemIntegerify(pIn2);  p2 = (int)pIn2->u.i;  assert( p2>=2 );  }  if( pOp->p4type==P4_KEYINFO ){  pKeyInfo = pOp->p4.pKeyInfo;  assert( pKeyInfo->enc==ENC(db) );  assert( pKeyInfo->db==db );  nField = pKeyInfo->nAllField;  }else if( pOp->p4type==P4_INT32 ){  nField = pOp->p4.i;  }  assert( pOp->p1>=0 );  assert( nField>=0 );  testcase( nField==0 );  pCur = allocateCursor(p, pOp->p1, nField, iDb, CURTYPE_BTREE);  if( pCur==0 ) goto no_mem;  pCur->nullRow = 1;  pCur->isOrdered = 1;  pCur->pgnoRoot = p2;
#ifdef SQLITE_DEBUG
 pCur->wrFlag = wrFlag;
#endif
 rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);  pCur->pKeyInfo = pKeyInfo;  pCur->isTable = pOp->p4type!=P4_KEYINFO; open_cursor_set_hints:  assert( OPFLAG_BULKCSR==BTREE_BULKLOAD );  assert( OPFLAG_SEEKEQ==BTREE_SEEK_EQ );  testcase( pOp->p5 & OPFLAG_BULKCSR );  testcase( pOp->p2 & OPFLAG_SEEKEQ );  sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,   (pOp->p5 & (OPFLAG_BULKCSR|OPFLAG_SEEKEQ)));  if( rc ) goto abort_due_to_error;  break; } case OP_OpenDup: {  VdbeCursor *pOrig;  VdbeCursor *pCx;  pOrig = p->apCsr[pOp->p2];  assert( pOrig );  assert( pOrig->isEphemeral );  pCx = allocateCursor(p, pOp->p1, pOrig->nField, -1, CURTYPE_BTREE);  if( pCx==0 ) goto no_mem;  pCx->nullRow = 1;  pCx->isEphemeral = 1;  pCx->pKeyInfo = pOrig->pKeyInfo;  pCx->isTable = pOrig->isTable;  pCx->pgnoRoot = pOrig->pgnoRoot;  pCx->isOrdered = pOrig->isOrdered;  pCx->pBtx = pOrig->pBtx;  pCx->hasBeenDuped = 1;  pOrig->hasBeenDuped = 1;  rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,  pCx->pKeyInfo, pCx->uc.pCursor);  assert( rc==SQLITE_OK );  break; } case OP_OpenAutoindex: case OP_OpenEphemeral: {  VdbeCursor *pCx;  KeyInfo *pKeyInfo;  static const int vfsFlags =  SQLITE_OPEN_READWRITE |  SQLITE_OPEN_CREATE |  SQLITE_OPEN_EXCLUSIVE |  SQLITE_OPEN_DELETEONCLOSE |  SQLITE_OPEN_TRANSIENT_DB;  assert( pOp->p1>=0 );  assert( pOp->p2>=0 );  if( pOp->p3>0 ){  assert( pOp->p2==0 );  assert( pOp->opcode==OP_OpenEphemeral );  assert( aMem[pOp->p3].flags & MEM_Null );  aMem[pOp->p3].n = 0;  aMem[pOp->p3].z = "";  }  pCx = p->apCsr[pOp->p1];  if( pCx && !pCx->hasBeenDuped && ALWAYS(pOp->p2<=pCx->nField) ){  assert( pCx->isEphemeral );  pCx->seqCount = 0;  pCx->cacheStatus = CACHE_STALE;  rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);  }else{  pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_BTREE);  if( pCx==0 ) goto no_mem;  pCx->isEphemeral = 1;  rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,  BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5,  vfsFlags);  if( rc==SQLITE_OK ){  rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);  if( rc==SQLITE_OK ){  if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){  assert( pOp->p4type==P4_KEYINFO );  rc = sqlite3BtreeCreateTable(pCx->pBtx, &pCx->pgnoRoot,  BTREE_BLOBKEY | pOp->p5);  if( rc==SQLITE_OK ){  assert( pCx->pgnoRoot==SCHEMA_ROOT+1 );  assert( pKeyInfo->db==db );  assert( pKeyInfo->enc==ENC(db) );  rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, BTREE_WRCSR,  pKeyInfo, pCx->uc.pCursor);  }  pCx->isTable = 0;  }else{  pCx->pgnoRoot = SCHEMA_ROOT;  rc = sqlite3BtreeCursor(pCx->pBtx, SCHEMA_ROOT, BTREE_WRCSR,  0, pCx->uc.pCursor);  pCx->isTable = 1;  }  }  pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);  if( rc ){  sqlite3BtreeClose(pCx->pBtx);  }  }  }  if( rc ) goto abort_due_to_error;  pCx->nullRow = 1;  break; } case OP_SorterOpen: {  VdbeCursor *pCx;  assert( pOp->p1>=0 );  assert( pOp->p2>=0 );  pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, CURTYPE_SORTER);  if( pCx==0 ) goto no_mem;  pCx->pKeyInfo = pOp->p4.pKeyInfo;  assert( pCx->pKeyInfo->db==db );  assert( pCx->pKeyInfo->enc==ENC(db) );  rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);  if( rc ) goto abort_due_to_error;  break; } case OP_SequenceTest: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( isSorter(pC) );  if( (pC->seqCount++)==0 ){  goto jump_to_p2;  }  break; } case OP_OpenPseudo: {  VdbeCursor *pCx;  assert( pOp->p1>=0 );  assert( pOp->p3>=0 );  pCx = allocateCursor(p, pOp->p1, pOp->p3, -1, CURTYPE_PSEUDO);  if( pCx==0 ) goto no_mem;  pCx->nullRow = 1;  pCx->seekResult = pOp->p2;  pCx->isTable = 1;  pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();  assert( pOp->p5==0 );  break; } case OP_Close: {  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);  p->apCsr[pOp->p1] = 0;  break; }
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
case OP_ColumnsUsed: {  VdbeCursor *pC;  pC = p->apCsr[pOp->p1];  assert( pC->eCurType==CURTYPE_BTREE );  pC->maskUsed = *(u64*)pOp->p4.pI64;  break; }
#endif
case OP_SeekLT: case OP_SeekLE: case OP_SeekGE: case OP_SeekGT: {  int res;  int oc;  VdbeCursor *pC;  UnpackedRecord r;  int nField;  i64 iKey;  int eqOnly;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( pOp->p2!=0 );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( OP_SeekLE == OP_SeekLT+1 );  assert( OP_SeekGE == OP_SeekLT+2 );  assert( OP_SeekGT == OP_SeekLT+3 );  assert( pC->isOrdered );  assert( pC->uc.pCursor!=0 );  oc = pOp->opcode;  eqOnly = 0;  pC->nullRow = 0;
#ifdef SQLITE_DEBUG
 pC->seekOp = pOp->opcode;
#endif
 pC->deferredMoveto = 0;  pC->cacheStatus = CACHE_STALE;  if( pC->isTable ){  u16 flags3, newType;  assert( sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ)==0  || CORRUPT_DB );  pIn3 = &aMem[pOp->p3];  flags3 = pIn3->flags;  if( (flags3 & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Str))==MEM_Str ){  applyNumericAffinity(pIn3, 0);  }  iKey = sqlite3VdbeIntValue(pIn3);  newType = pIn3->flags;  pIn3->flags = flags3;  if( (newType & (MEM_Int|MEM_IntReal))==0 ){  int c;  if( (newType & MEM_Real)==0 ){  if( (newType & MEM_Null) || oc>=OP_SeekGE ){  VdbeBranchTaken(1,2);  goto jump_to_p2;  }else{  rc = sqlite3BtreeLast(pC->uc.pCursor, &res);  if( rc!=SQLITE_OK ) goto abort_due_to_error;  goto seek_not_found;  }  }  c = sqlite3IntFloatCompare(iKey, pIn3->u.r);  if( c>0 ){  assert( OP_SeekGE==(OP_SeekGT-1) );  assert( OP_SeekLT==(OP_SeekLE-1) );  assert( (OP_SeekLE & 0x0001)==(OP_SeekGT & 0x0001) );  if( (oc & 0x0001)==(OP_SeekGT & 0x0001) ) oc--;  }  else if( c<0 ){  assert( OP_SeekLE==(OP_SeekLT+1) );  assert( OP_SeekGT==(OP_SeekGE+1) );  assert( (OP_SeekLT & 0x0001)==(OP_SeekGE & 0x0001) );  if( (oc & 0x0001)==(OP_SeekLT & 0x0001) ) oc++;  }  }  rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)iKey, 0, &res);  pC->movetoTarget = iKey;  if( rc!=SQLITE_OK ){  goto abort_due_to_error;  }  }else{  if( sqlite3BtreeCursorHasHint(pC->uc.pCursor, BTREE_SEEK_EQ) ){  eqOnly = 1;  assert( pOp->opcode==OP_SeekGE || pOp->opcode==OP_SeekLE );  assert( pOp[1].opcode==OP_IdxLT || pOp[1].opcode==OP_IdxGT );  assert( pOp->opcode==OP_SeekGE || pOp[1].opcode==OP_IdxLT );  assert( pOp->opcode==OP_SeekLE || pOp[1].opcode==OP_IdxGT );  assert( pOp[1].p1==pOp[0].p1 );  assert( pOp[1].p2==pOp[0].p2 );  assert( pOp[1].p3==pOp[0].p3 );  assert( pOp[1].p4.i==pOp[0].p4.i );  }  nField = pOp->p4.i;  assert( pOp->p4type==P4_INT32 );  assert( nField>0 );  r.pKeyInfo = pC->pKeyInfo;  r.nField = (u16)nField;  r.default_rc = ((1 & (oc - OP_SeekLT)) ? -1 : +1);  assert( oc!=OP_SeekGT || r.default_rc==-1 );  assert( oc!=OP_SeekLE || r.default_rc==-1 );  assert( oc!=OP_SeekGE || r.default_rc==+1 );  assert( oc!=OP_SeekLT || r.default_rc==+1 );  r.aMem = &aMem[pOp->p3];
#ifdef SQLITE_DEBUG
 { int i; for(i=0; i<r.nField; i++) assert( memIsValid(&r.aMem[i]) ); }
#endif
 r.eqSeen = 0;  rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, &r, &res);  if( rc!=SQLITE_OK ){  goto abort_due_to_error;  }  if( eqOnly && r.eqSeen==0 ){  assert( res!=0 );  goto seek_not_found;  }  }
#ifdef SQLITE_TEST
 sqlite3_search_count++;
#endif
 if( oc>=OP_SeekGE ){ assert( oc==OP_SeekGE || oc==OP_SeekGT );  if( res<0 || (res==0 && oc==OP_SeekGT) ){  res = 0;  rc = sqlite3BtreeNext(pC->uc.pCursor, 0);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  res = 1;  }else{  goto abort_due_to_error;  }  }  }else{  res = 0;  }  }else{  assert( oc==OP_SeekLT || oc==OP_SeekLE );  if( res>0 || (res==0 && oc==OP_SeekLT) ){  res = 0;  rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  res = 1;  }else{  goto abort_due_to_error;  }  }  }else{  res = sqlite3BtreeEof(pC->uc.pCursor);  }  } seek_not_found:  assert( pOp->p2>0 );  VdbeBranchTaken(res!=0,2);  if( res ){  goto jump_to_p2;  }else if( eqOnly ){  assert( pOp[1].opcode==OP_IdxLT || pOp[1].opcode==OP_IdxGT );  pOp++;  }  break; } case OP_SeekScan: {  VdbeCursor *pC;  int res;  int nStep;  UnpackedRecord r;  assert( pOp[1].opcode==OP_SeekGE );  assert( pOp->p2>=(int)(pOp-aOp)+2 );  assert( aOp[pOp->p2-1].opcode==OP_IdxGT || aOp[pOp->p2-1].opcode==OP_IdxGE );  testcase( aOp[pOp->p2-1].opcode==OP_IdxGE );  assert( pOp[1].p1==aOp[pOp->p2-1].p1 );  assert( pOp[1].p2==aOp[pOp->p2-1].p2 );  assert( pOp[1].p3==aOp[pOp->p2-1].p3 );  assert( pOp->p1>0 );  pC = p->apCsr[pOp[1].p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( !pC->isTable );  if( !sqlite3BtreeCursorIsValidNN(pC->uc.pCursor) ){
#ifdef SQLITE_DEBUG
  if( db->flags&SQLITE_VdbeTrace ){   printf("... cursor not valid - fall through\n");   }
#endif
 break;  }  nStep = pOp->p1;  assert( nStep>=1 );  r.pKeyInfo = pC->pKeyInfo;  r.nField = (u16)pOp[1].p4.i;  r.default_rc = 0;  r.aMem = &aMem[pOp[1].p3];
#ifdef SQLITE_DEBUG
 {  int i;  for(i=0; i<r.nField; i++){  assert( memIsValid(&r.aMem[i]) );  REGISTER_TRACE(pOp[1].p3+i, &aMem[pOp[1].p3+i]);  }  }
#endif
 res = 0;  while(1){  rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);  if( rc ) goto abort_due_to_error;  if( res>0 ){  seekscan_search_fail:
#ifdef SQLITE_DEBUG
 if( db->flags&SQLITE_VdbeTrace ){  printf("... %d steps and then skip\n", pOp->p1 - nStep);  }
#endif
 VdbeBranchTaken(1,3);  pOp++;  goto jump_to_p2;  }  if( res==0 ){
#ifdef SQLITE_DEBUG
 if( db->flags&SQLITE_VdbeTrace ){  printf("... %d steps and then success\n", pOp->p1 - nStep);  }
#endif
 VdbeBranchTaken(2,3);  goto jump_to_p2;  break;  }  if( nStep<=0 ){
#ifdef SQLITE_DEBUG
 if( db->flags&SQLITE_VdbeTrace ){  printf("... fall through after %d steps\n", pOp->p1);  }
#endif
 VdbeBranchTaken(0,3);  break;  }  nStep--;  rc = sqlite3BtreeNext(pC->uc.pCursor, 0);  if( rc ){  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  goto seekscan_search_fail;  }else{  goto abort_due_to_error;  }  }  }  break; } case OP_SeekHit: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pOp->p3>=pOp->p2 );  if( pC->seekHit<pOp->p2 ){
#ifdef SQLITE_DEBUG
 if( db->flags&SQLITE_VdbeTrace ){  printf("seekHit changes from %d to %d\n", pC->seekHit, pOp->p2);  }
#endif
 pC->seekHit = pOp->p2;  }else if( pC->seekHit>pOp->p3 ){
#ifdef SQLITE_DEBUG
 if( db->flags&SQLITE_VdbeTrace ){  printf("seekHit changes from %d to %d\n", pC->seekHit, pOp->p3);  }
#endif
 pC->seekHit = pOp->p3;  }  break; } case OP_IfNotOpen: {  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  VdbeBranchTaken(p->apCsr[pOp->p1]==0, 2);  if( !p->apCsr[pOp->p1] ){  goto jump_to_p2_and_check_for_interrupt;  }  break; } case OP_IfNoHope: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );
#ifdef SQLITE_DEBUG
 if( db->flags&SQLITE_VdbeTrace ){  printf("seekHit is %d\n", pC->seekHit);  }
#endif
 if( pC->seekHit>=pOp->p4.i ) break;  deliberate_fall_through } case OP_NoConflict: case OP_NotFound: case OP_Found: {  int alreadyExists;  int takeJump;  int ii;  VdbeCursor *pC;  int res;  UnpackedRecord *pFree;  UnpackedRecord *pIdxKey;  UnpackedRecord r;
#ifdef SQLITE_TEST
 if( pOp->opcode!=OP_NoConflict ) sqlite3_found_count++;
#endif
 assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( pOp->p4type==P4_INT32 );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );
#ifdef SQLITE_DEBUG
 pC->seekOp = pOp->opcode;
#endif
 pIn3 = &aMem[pOp->p3];  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->uc.pCursor!=0 );  assert( pC->isTable==0 );  if( pOp->p4.i>0 ){  r.pKeyInfo = pC->pKeyInfo;  r.nField = (u16)pOp->p4.i;  r.aMem = pIn3;
#ifdef SQLITE_DEBUG
 for(ii=0; ii<r.nField; ii++){  assert( memIsValid(&r.aMem[ii]) );  assert( (r.aMem[ii].flags & MEM_Zero)==0 || r.aMem[ii].n==0 );  if( ii ) REGISTER_TRACE(pOp->p3+ii, &r.aMem[ii]);  }
#endif
 pIdxKey = &r;  pFree = 0;  }else{  assert( pIn3->flags & MEM_Blob );  rc = ExpandBlob(pIn3);  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );  if( rc ) goto no_mem;  pFree = pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);  if( pIdxKey==0 ) goto no_mem;  sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, pIdxKey);  }  pIdxKey->default_rc = 0;  takeJump = 0;  if( pOp->opcode==OP_NoConflict ){  for(ii=0; ii<pIdxKey->nField; ii++){  if( pIdxKey->aMem[ii].flags & MEM_Null ){  takeJump = 1;  break;  }  }  }  rc = sqlite3BtreeIndexMoveto(pC->uc.pCursor, pIdxKey, &res);  if( pFree ) sqlite3DbFreeNN(db, pFree);  if( rc!=SQLITE_OK ){  goto abort_due_to_error;  }  pC->seekResult = res;  alreadyExists = (res==0);  pC->nullRow = 1-alreadyExists;  pC->deferredMoveto = 0;  pC->cacheStatus = CACHE_STALE;  if( pOp->opcode==OP_Found ){  VdbeBranchTaken(alreadyExists!=0,2);  if( alreadyExists ) goto jump_to_p2;  }else{  VdbeBranchTaken(takeJump||alreadyExists==0,2);  if( takeJump || !alreadyExists ) goto jump_to_p2;  if( pOp->opcode==OP_IfNoHope ) pC->seekHit = pOp->p4.i;  }  break; } case OP_SeekRowid: {  VdbeCursor *pC;  BtCursor *pCrsr;  int res;  u64 iKey;  pIn3 = &aMem[pOp->p3];  testcase( pIn3->flags & MEM_Int );  testcase( pIn3->flags & MEM_IntReal );  testcase( pIn3->flags & MEM_Real );  testcase( (pIn3->flags & (MEM_Str|MEM_Int))==MEM_Str );  if( (pIn3->flags & (MEM_Int|MEM_IntReal))==0 ){  Mem x = pIn3[0];  applyAffinity(&x, SQLITE_AFF_NUMERIC, encoding);  if( (x.flags & MEM_Int)==0 ) goto jump_to_p2;  iKey = x.u.i;  goto notExistsWithKey;  }  deliberate_fall_through case OP_NotExists:  pIn3 = &aMem[pOp->p3];  assert( (pIn3->flags & MEM_Int)!=0 || pOp->opcode==OP_SeekRowid );  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  iKey = pIn3->u.i;
notExistsWithKey:  pC = p->apCsr[pOp->p1];  assert( pC!=0 );
#ifdef SQLITE_DEBUG
 if( pOp->opcode==OP_SeekRowid ) pC->seekOp = OP_SeekRowid;
#endif
 assert( pC->isTable );  assert( pC->eCurType==CURTYPE_BTREE );  pCrsr = pC->uc.pCursor;  assert( pCrsr!=0 );  res = 0;  rc = sqlite3BtreeTableMoveto(pCrsr, iKey, 0, &res);  assert( rc==SQLITE_OK || res==0 );  pC->movetoTarget = iKey;  pC->nullRow = 0;  pC->cacheStatus = CACHE_STALE;  pC->deferredMoveto = 0;  VdbeBranchTaken(res!=0,2);  pC->seekResult = res;  if( res!=0 ){  assert( rc==SQLITE_OK );  if( pOp->p2==0 ){  rc = SQLITE_CORRUPT_BKPT;  }else{  goto jump_to_p2;  }  }  if( rc ) goto abort_due_to_error;  break; } case OP_Sequence: {  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( p->apCsr[pOp->p1]!=0 );  assert( p->apCsr[pOp->p1]->eCurType!=CURTYPE_VTAB );  pOut = out2Prerelease(p, pOp);  pOut->u.i = p->apCsr[pOp->p1]->seqCount++;  break; } case OP_NewRowid: {  i64 v;  VdbeCursor *pC;  int res;  int cnt;
#ifndef SQLITE_OMIT_AUTOINCREMENT
 Mem *pMem;  VdbeFrame *pFrame;
#endif
 v = 0;  res = 0;  pOut = out2Prerelease(p, pOp);  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->isTable );  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->uc.pCursor!=0 );  {  assert( pC->isTable );
#ifdef SQLITE_32BIT_ROWID
#  define MAX_ROWID 0x7fffffff
#else
#  define MAX_ROWID (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )
#endif
 if( !pC->useRandomRowid ){  rc = sqlite3BtreeLast(pC->uc.pCursor, &res);  if( rc!=SQLITE_OK ){  goto abort_due_to_error;  }  if( res ){  v = 1;  }else{  assert( sqlite3BtreeCursorIsValid(pC->uc.pCursor) );  v = sqlite3BtreeIntegerKey(pC->uc.pCursor);  if( v>=MAX_ROWID ){  pC->useRandomRowid = 1;  }else{  v++;  }  }  }
#ifndef SQLITE_OMIT_AUTOINCREMENT
 if( pOp->p3 ){  assert( pOp->p3>0 );  if( p->pFrame ){  for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);  assert( pOp->p3<=pFrame->nMem );  pMem = &pFrame->aMem[pOp->p3];  }else{  assert( pOp->p3<=(p->nMem+1 - p->nCursor) );  pMem = &aMem[pOp->p3];  memAboutToChange(p, pMem);  }  assert( memIsValid(pMem) );  REGISTER_TRACE(pOp->p3, pMem);  sqlite3VdbeMemIntegerify(pMem);  assert( (pMem->flags & MEM_Int)!=0 );  if( pMem->u.i==MAX_ROWID || pC->useRandomRowid ){  rc = SQLITE_FULL;  goto abort_due_to_error;  }  if( v<pMem->u.i+1 ){  v = pMem->u.i + 1;  }  pMem->u.i = v;  }
#endif
 if( pC->useRandomRowid ){  assert( pOp->p3==0 );  cnt = 0;  do{  sqlite3_randomness(sizeof(v), &v);  v &= (MAX_ROWID>>1); v++;  }while( ((rc = sqlite3BtreeTableMoveto(pC->uc.pCursor, (u64)v,   0, &res))==SQLITE_OK)  && (res==0)  && (++cnt<100));  if( rc ) goto abort_due_to_error;  if( res==0 ){  rc = SQLITE_FULL;  goto abort_due_to_error;  }  assert( v>0 );  }  pC->deferredMoveto = 0;  pC->cacheStatus = CACHE_STALE;  }  pOut->u.i = v;  break; } case OP_Insert: {  Mem *pData;  Mem *pKey;  VdbeCursor *pC;  int seekResult;  const char *zDb;  Table *pTab;  BtreePayload x;  pData = &aMem[pOp->p2];  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( memIsValid(pData) );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->deferredMoveto==0 );  assert( pC->uc.pCursor!=0 );  assert( (pOp->p5 & OPFLAG_ISNOOP) || pC->isTable );  assert( pOp->p4type==P4_TABLE || pOp->p4type>=P4_STATIC );  REGISTER_TRACE(pOp->p2, pData);  sqlite3VdbeIncrWriteCounter(p, pC);  pKey = &aMem[pOp->p3];  assert( pKey->flags & MEM_Int );  assert( memIsValid(pKey) );  REGISTER_TRACE(pOp->p3, pKey);  x.nKey = pKey->u.i;  if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){  assert( pC->iDb>=0 );  zDb = db->aDb[pC->iDb].zDbSName;  pTab = pOp->p4.pTab;  assert( (pOp->p5 & OPFLAG_ISNOOP) || HasRowid(pTab) );  }else{  pTab = 0;  zDb = 0;  }
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 if( pTab ){  if( db->xPreUpdateCallback && !(pOp->p5 & OPFLAG_ISUPDATE) ){  sqlite3VdbePreUpdateHook(p,pC,SQLITE_INSERT,zDb,pTab,x.nKey,pOp->p2,-1);  }  if( db->xUpdateCallback==0 || pTab->aCol==0 ){  pTab = 0;  }  }  if( pOp->p5 & OPFLAG_ISNOOP ) break;
#endif
 if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;  assert( (pData->flags & (MEM_Blob|MEM_Str))!=0 || pData->n==0 );  x.pData = pData->z;  x.nData = pData->n;  seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0);  if( pData->flags & MEM_Zero ){  x.nZero = pData->u.nZero;  }else{  x.nZero = 0;  }  x.pKey = 0;  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,  (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION|OPFLAG_PREFORMAT)),  seekResult  );  pC->deferredMoveto = 0;  pC->cacheStatus = CACHE_STALE;  if( rc ) goto abort_due_to_error;  if( pTab ){  assert( db->xUpdateCallback!=0 );  assert( pTab->aCol!=0 );  db->xUpdateCallback(db->pUpdateArg,   (pOp->p5 & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT,   zDb, pTab->zName, x.nKey);  }  break; } case OP_RowCell: {  VdbeCursor *pDest;  VdbeCursor *pSrc;  i64 iKey;  assert( pOp[1].opcode==OP_Insert || pOp[1].opcode==OP_IdxInsert );  assert( pOp[1].opcode==OP_Insert || pOp->p3==0 );  assert( pOp[1].opcode==OP_IdxInsert || pOp->p3>0 );  assert( pOp[1].p5 & OPFLAG_PREFORMAT );  pDest = p->apCsr[pOp->p1];  pSrc = p->apCsr[pOp->p2];  iKey = pOp->p3 ? aMem[pOp->p3].u.i : 0;  rc = sqlite3BtreeTransferRow(pDest->uc.pCursor, pSrc->uc.pCursor, iKey);  if( rc!=SQLITE_OK ) goto abort_due_to_error;  break; }; case OP_Delete: {  VdbeCursor *pC;  const char *zDb;  Table *pTab;  int opflags;  opflags = pOp->p2;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->uc.pCursor!=0 );  assert( pC->deferredMoveto==0 );  sqlite3VdbeIncrWriteCounter(p, pC);
#ifdef SQLITE_DEBUG
 if( pOp->p4type==P4_TABLE   && HasRowid(pOp->p4.pTab)   && pOp->p5==0   && sqlite3BtreeCursorIsValidNN(pC->uc.pCursor)  ){  i64 iKey = sqlite3BtreeIntegerKey(pC->uc.pCursor);  assert( CORRUPT_DB || pC->movetoTarget==iKey );  }
#endif
 if( pOp->p4type==P4_TABLE && HAS_UPDATE_HOOK(db) ){  assert( pC->iDb>=0 );  assert( pOp->p4.pTab!=0 );  zDb = db->aDb[pC->iDb].zDbSName;  pTab = pOp->p4.pTab;  if( (pOp->p5 & OPFLAG_SAVEPOSITION)!=0 && pC->isTable ){  pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);  }  }else{  zDb = 0;  pTab = 0;  }
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 assert( db->xPreUpdateCallback==0 || pTab==pOp->p4.pTab );  if( db->xPreUpdateCallback && pTab ){  assert( !(opflags & OPFLAG_ISUPDATE)   || HasRowid(pTab)==0   || (aMem[pOp->p3].flags & MEM_Int)  );  sqlite3VdbePreUpdateHook(p, pC,  (opflags & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_DELETE,  zDb, pTab, pC->movetoTarget,  pOp->p3, -1  );  }  if( opflags & OPFLAG_ISNOOP ) break;
#endif
 assert( (pOp->p5 & ~(OPFLAG_SAVEPOSITION|OPFLAG_AUXDELETE))==0 );  assert( OPFLAG_SAVEPOSITION==BTREE_SAVEPOSITION );  assert( OPFLAG_AUXDELETE==BTREE_AUXDELETE );
#ifdef SQLITE_DEBUG
 if( p->pFrame==0 ){  if( pC->isEphemeral==0  && (pOp->p5 & OPFLAG_AUXDELETE)==0  && (pC->wrFlag & OPFLAG_FORDELETE)==0  ){  nExtraDelete++;  }  if( pOp->p2 & OPFLAG_NCHANGE ){  nExtraDelete--;  }  }
#endif
 rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);  pC->cacheStatus = CACHE_STALE;  pC->seekResult = 0;  if( rc ) goto abort_due_to_error;  if( opflags & OPFLAG_NCHANGE ){  p->nChange++;  if( db->xUpdateCallback && ALWAYS(pTab!=0) && HasRowid(pTab) ){  db->xUpdateCallback(db->pUpdateArg, SQLITE_DELETE, zDb, pTab->zName,  pC->movetoTarget);  assert( pC->iDb>=0 );  }  }  break; } case OP_ResetCount: {  sqlite3VdbeSetChanges(db, p->nChange);  p->nChange = 0;  break; } case OP_SorterCompare: {  VdbeCursor *pC;  int res;  int nKeyCol;  pC = p->apCsr[pOp->p1];  assert( isSorter(pC) );  assert( pOp->p4type==P4_INT32 );  pIn3 = &aMem[pOp->p3];  nKeyCol = pOp->p4.i;  res = 0;  rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);  VdbeBranchTaken(res!=0,2);  if( rc ) goto abort_due_to_error;  if( res ) goto jump_to_p2;  break; }; case OP_SorterData: {  VdbeCursor *pC;  pOut = &aMem[pOp->p2];  pC = p->apCsr[pOp->p1];  assert( isSorter(pC) );  rc = sqlite3VdbeSorterRowkey(pC, pOut);  assert( rc!=SQLITE_OK || (pOut->flags & MEM_Blob) );  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  if( rc ) goto abort_due_to_error;  p->apCsr[pOp->p3]->cacheStatus = CACHE_STALE;  break; } case OP_RowData: {  VdbeCursor *pC;  BtCursor *pCrsr;  u32 n;  pOut = out2Prerelease(p, pOp);  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( isSorter(pC)==0 );  assert( pC->nullRow==0 );  assert( pC->uc.pCursor!=0 );  pCrsr = pC->uc.pCursor;  assert( pC->deferredMoveto==0 );  assert( sqlite3BtreeCursorIsValid(pCrsr) );  n = sqlite3BtreePayloadSize(pCrsr);  if( n>(u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){  goto too_big;  }  testcase( n==0 );  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut);  if( rc ) goto abort_due_to_error;  if( !pOp->p3 ) Deephemeralize(pOut);  UPDATE_MAX_BLOBSIZE(pOut);  REGISTER_TRACE(pOp->p2, pOut);  break; } case OP_Rowid: {  VdbeCursor *pC;  i64 v;  sqlite3_vtab *pVtab;  const sqlite3_module *pModule;  pOut = out2Prerelease(p, pOp);  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType!=CURTYPE_PSEUDO || pC->nullRow );  if( pC->nullRow ){  pOut->flags = MEM_Null;  break;  }else if( pC->deferredMoveto ){  v = pC->movetoTarget;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 }else if( pC->eCurType==CURTYPE_VTAB ){  assert( pC->uc.pVCur!=0 );  pVtab = pC->uc.pVCur->pVtab;  pModule = pVtab->pModule;  assert( pModule->xRowid );  rc = pModule->xRowid(pC->uc.pVCur, &v);  sqlite3VtabImportErrmsg(p, pVtab);  if( rc ) goto abort_due_to_error;
#endif
 }else{  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->uc.pCursor!=0 );  rc = sqlite3VdbeCursorRestore(pC);  if( rc ) goto abort_due_to_error;  if( pC->nullRow ){  pOut->flags = MEM_Null;  break;  }  v = sqlite3BtreeIntegerKey(pC->uc.pCursor);  }  pOut->u.i = v;  break; } case OP_NullRow: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  pC->nullRow = 1;  pC->cacheStatus = CACHE_STALE;  if( pC->eCurType==CURTYPE_BTREE ){  assert( pC->uc.pCursor!=0 );  sqlite3BtreeClearCursor(pC->uc.pCursor);  }
#ifdef SQLITE_DEBUG
 if( pC->seekOp==0 ) pC->seekOp = OP_NullRow;
#endif
 break; } case OP_SeekEnd: case OP_Last: {  VdbeCursor *pC;  BtCursor *pCrsr;  int res;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  pCrsr = pC->uc.pCursor;  res = 0;  assert( pCrsr!=0 );
#ifdef SQLITE_DEBUG
 pC->seekOp = pOp->opcode;
#endif
 if( pOp->opcode==OP_SeekEnd ){  assert( pOp->p2==0 );  pC->seekResult = -1;  if( sqlite3BtreeCursorIsValidNN(pCrsr) ){  break;  }  }  rc = sqlite3BtreeLast(pCrsr, &res);  pC->nullRow = (u8)res;  pC->deferredMoveto = 0;  pC->cacheStatus = CACHE_STALE;  if( rc ) goto abort_due_to_error;  if( pOp->p2>0 ){  VdbeBranchTaken(res!=0,2);  if( res ) goto jump_to_p2;  }  break; } case OP_IfSmaller: {  VdbeCursor *pC;  BtCursor *pCrsr;  int res;  i64 sz;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  pCrsr = pC->uc.pCursor;  assert( pCrsr );  rc = sqlite3BtreeFirst(pCrsr, &res);  if( rc ) goto abort_due_to_error;  if( res==0 ){  sz = sqlite3BtreeRowCountEst(pCrsr);  if( ALWAYS(sz>=0) && sqlite3LogEst((u64)sz)<pOp->p3 ) res = 1;  }  VdbeBranchTaken(res!=0,2);  if( res ) goto jump_to_p2;  break; } case OP_SorterSort: case OP_Sort: {
#ifdef SQLITE_TEST
 sqlite3_sort_count++;  sqlite3_search_count--;
#endif
 p->aCounter[SQLITE_STMTSTATUS_SORT]++;  deliberate_fall_through } case OP_Rewind: {  VdbeCursor *pC;  BtCursor *pCrsr;  int res;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( pOp->p5==0 );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( isSorter(pC)==(pOp->opcode==OP_SorterSort) );  res = 1;
#ifdef SQLITE_DEBUG
 pC->seekOp = OP_Rewind;
#endif
 if( isSorter(pC) ){  rc = sqlite3VdbeSorterRewind(pC, &res);  }else{  assert( pC->eCurType==CURTYPE_BTREE );  pCrsr = pC->uc.pCursor;  assert( pCrsr );  rc = sqlite3BtreeFirst(pCrsr, &res);  pC->deferredMoveto = 0;  pC->cacheStatus = CACHE_STALE;  }  if( rc ) goto abort_due_to_error;  pC->nullRow = (u8)res;  assert( pOp->p2>0 && pOp->p2<p->nOp );  VdbeBranchTaken(res!=0,2);  if( res ) goto jump_to_p2;  break; } case OP_SorterNext: {  VdbeCursor *pC;  pC = p->apCsr[pOp->p1];  assert( isSorter(pC) );  rc = sqlite3VdbeSorterNext(db, pC);  goto next_tail; case OP_Prev: case OP_Next:  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( pOp->p5<ArraySize(p->aCounter) );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->deferredMoveto==0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( pOp->opcode!=OP_Next || pOp->p4.xAdvance==sqlite3BtreeNext );  assert( pOp->opcode!=OP_Prev || pOp->p4.xAdvance==sqlite3BtreePrevious );  assert( pOp->opcode!=OP_Next   || pC->seekOp==OP_SeekGT || pC->seekOp==OP_SeekGE   || pC->seekOp==OP_Rewind || pC->seekOp==OP_Found   || pC->seekOp==OP_NullRow|| pC->seekOp==OP_SeekRowid   || pC->seekOp==OP_IfNoHope);  assert( pOp->opcode!=OP_Prev   || pC->seekOp==OP_SeekLT || pC->seekOp==OP_SeekLE   || pC->seekOp==OP_Last  || pC->seekOp==OP_IfNoHope   || pC->seekOp==OP_NullRow);  rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
next_tail:  pC->cacheStatus = CACHE_STALE;  VdbeBranchTaken(rc==SQLITE_OK,2);  if( rc==SQLITE_OK ){  pC->nullRow = 0;  p->aCounter[pOp->p5]++;
#ifdef SQLITE_TEST
 sqlite3_search_count++;
#endif
 goto jump_to_p2_and_check_for_interrupt;  }  if( rc!=SQLITE_DONE ) goto abort_due_to_error;  rc = SQLITE_OK;  pC->nullRow = 1;  goto check_for_interrupt; } case OP_IdxInsert: {  VdbeCursor *pC;  BtreePayload x;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  sqlite3VdbeIncrWriteCounter(p, pC);  assert( pC!=0 );  assert( !isSorter(pC) );  pIn2 = &aMem[pOp->p2];  assert( (pIn2->flags & MEM_Blob) || (pOp->p5 & OPFLAG_PREFORMAT) );  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->isTable==0 );  rc = ExpandBlob(pIn2);  if( rc ) goto abort_due_to_error;  x.nKey = pIn2->n;  x.pKey = pIn2->z;  x.aMem = aMem + pOp->p3;  x.nMem = (u16)pOp->p4.i;  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,   (pOp->p5 & (OPFLAG_APPEND|OPFLAG_SAVEPOSITION|OPFLAG_PREFORMAT)),  ((pOp->p5 & OPFLAG_USESEEKRESULT) ? pC->seekResult : 0)  );  assert( pC->deferredMoveto==0 );  pC->cacheStatus = CACHE_STALE;  if( rc) goto abort_due_to_error;  break; } case OP_SorterInsert: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  sqlite3VdbeIncrWriteCounter(p, pC);  assert( pC!=0 );  assert( isSorter(pC) );  pIn2 = &aMem[pOp->p2];  assert( pIn2->flags & MEM_Blob );  assert( pC->isTable==0 );  rc = ExpandBlob(pIn2);  if( rc ) goto abort_due_to_error;  rc = sqlite3VdbeSorterWrite(pC, pIn2);  if( rc) goto abort_due_to_error;  break; } case OP_IdxDelete: {  VdbeCursor *pC;  BtCursor *pCrsr;  int res;  UnpackedRecord r;  assert( pOp->p3>0 );  assert( pOp->p2>0 && pOp->p2+pOp->p3<=(p->nMem+1 - p->nCursor)+1 );  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  sqlite3VdbeIncrWriteCounter(p, pC);  pCrsr = pC->uc.pCursor;  assert( pCrsr!=0 );  r.pKeyInfo = pC->pKeyInfo;  r.nField = (u16)pOp->p3;  r.default_rc = 0;  r.aMem = &aMem[pOp->p2];  rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res);  if( rc ) goto abort_due_to_error;  if( res==0 ){  rc = sqlite3BtreeDelete(pCrsr, BTREE_AUXDELETE);  if( rc ) goto abort_due_to_error;  }else if( pOp->p5 && !sqlite3WritableSchema(db) ){  rc = sqlite3ReportError(SQLITE_CORRUPT_INDEX, __LINE__, "index corruption");  goto abort_due_to_error;  }  assert( pC->deferredMoveto==0 );  pC->cacheStatus = CACHE_STALE;  pC->seekResult = 0;  break; } case OP_DeferredSeek: case OP_IdxRowid: {  VdbeCursor *pC;  VdbeCursor *pTabCur;  i64 rowid;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->uc.pCursor!=0 );  assert( pC->isTable==0 );  assert( pC->deferredMoveto==0 );  assert( !pC->nullRow || pOp->opcode==OP_IdxRowid );  rc = sqlite3VdbeCursorRestore(pC);  if( NEVER(rc!=SQLITE_OK) ) goto abort_due_to_error;  if( !pC->nullRow ){  rowid = 0;  rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);  if( rc!=SQLITE_OK ){  goto abort_due_to_error;  }  if( pOp->opcode==OP_DeferredSeek ){  assert( pOp->p3>=0 && pOp->p3<p->nCursor );  pTabCur = p->apCsr[pOp->p3];  assert( pTabCur!=0 );  assert( pTabCur->eCurType==CURTYPE_BTREE );  assert( pTabCur->uc.pCursor!=0 );  assert( pTabCur->isTable );  pTabCur->nullRow = 0;  pTabCur->movetoTarget = rowid;  pTabCur->deferredMoveto = 1;  assert( pOp->p4type==P4_INTARRAY || pOp->p4.ai==0 );  pTabCur->aAltMap = pOp->p4.ai;  assert( !pC->isEphemeral );  assert( !pTabCur->isEphemeral );  pTabCur->pAltCursor = pC;  }else{  pOut = out2Prerelease(p, pOp);  pOut->u.i = rowid;  }  }else{  assert( pOp->opcode==OP_IdxRowid );  sqlite3VdbeMemSetNull(&aMem[pOp->p2]);  }  break; } case OP_FinishSeek: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  if( pC->deferredMoveto ){  rc = sqlite3VdbeFinishMoveto(pC);  if( rc ) goto abort_due_to_error;  }  break; } case OP_IdxLE: case OP_IdxGT: case OP_IdxLT: case OP_IdxGE: {  VdbeCursor *pC;  int res;  UnpackedRecord r;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->isOrdered );  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->uc.pCursor!=0);  assert( pC->deferredMoveto==0 );  assert( pOp->p4type==P4_INT32 );  r.pKeyInfo = pC->pKeyInfo;  r.nField = (u16)pOp->p4.i;  if( pOp->opcode<OP_IdxLT ){  assert( pOp->opcode==OP_IdxLE || pOp->opcode==OP_IdxGT );  r.default_rc = -1;  }else{  assert( pOp->opcode==OP_IdxGE || pOp->opcode==OP_IdxLT );  r.default_rc = 0;  }  r.aMem = &aMem[pOp->p3];
#ifdef SQLITE_DEBUG
 {  int i;  for(i=0; i<r.nField; i++){  assert( memIsValid(&r.aMem[i]) );  REGISTER_TRACE(pOp->p3+i, &aMem[pOp->p3+i]);  }  }
#endif
 {  i64 nCellKey = 0;  BtCursor *pCur;  Mem m;  assert( pC->eCurType==CURTYPE_BTREE );  pCur = pC->uc.pCursor;  assert( sqlite3BtreeCursorIsValid(pCur) );  nCellKey = sqlite3BtreePayloadSize(pCur);  if( nCellKey<=0 || nCellKey>0x7fffffff ){  rc = SQLITE_CORRUPT_BKPT;  goto abort_due_to_error;  }  sqlite3VdbeMemInit(&m, db, 0);  rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);  if( rc ) goto abort_due_to_error;  res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);  sqlite3VdbeMemRelease(&m);  }  assert( (OP_IdxLE&1)==(OP_IdxLT&1) && (OP_IdxGE&1)==(OP_IdxGT&1) );  if( (pOp->opcode&1)==(OP_IdxLT&1) ){  assert( pOp->opcode==OP_IdxLE || pOp->opcode==OP_IdxLT );  res = -res;  }else{  assert( pOp->opcode==OP_IdxGE || pOp->opcode==OP_IdxGT );  res++;  }  VdbeBranchTaken(res>0,2);  assert( rc==SQLITE_OK );  if( res>0 ) goto jump_to_p2;  break; } case OP_Destroy: {  int iMoved;  int iDb;  sqlite3VdbeIncrWriteCounter(p, 0);  assert( p->readOnly==0 );  assert( pOp->p1>1 );  pOut = out2Prerelease(p, pOp);  pOut->flags = MEM_Null;  if( db->nVdbeRead > db->nVDestroy+1 ){  rc = SQLITE_LOCKED;  p->errorAction = OE_Abort;  goto abort_due_to_error;  }else{  iDb = pOp->p3;  assert( DbMaskTest(p->btreeMask, iDb) );  iMoved = 0;  rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);  pOut->flags = MEM_Int;  pOut->u.i = iMoved;  if( rc ) goto abort_due_to_error;
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( iMoved!=0 ){  sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);  assert( resetSchemaOnFault==0 || resetSchemaOnFault==iDb+1 );  resetSchemaOnFault = iDb+1;  }
#endif
 }  break; } case OP_Clear: {  i64 nChange;  sqlite3VdbeIncrWriteCounter(p, 0);  nChange = 0;  assert( p->readOnly==0 );  assert( DbMaskTest(p->btreeMask, pOp->p2) );  rc = sqlite3BtreeClearTable(db->aDb[pOp->p2].pBt, (u32)pOp->p1, &nChange);  if( pOp->p3 ){  p->nChange += nChange;  if( pOp->p3>0 ){  assert( memIsValid(&aMem[pOp->p3]) );  memAboutToChange(p, &aMem[pOp->p3]);  aMem[pOp->p3].u.i += nChange;  }  }  if( rc ) goto abort_due_to_error;  break; } case OP_ResetSorter: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  if( isSorter(pC) ){  sqlite3VdbeSorterReset(db, pC->uc.pSorter);  }else{  assert( pC->eCurType==CURTYPE_BTREE );  assert( pC->isEphemeral );  rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);  if( rc ) goto abort_due_to_error;  }  break; } case OP_CreateBtree: {  Pgno pgno;  Db *pDb;  sqlite3VdbeIncrWriteCounter(p, 0);  pOut = out2Prerelease(p, pOp);  pgno = 0;  assert( pOp->p3==BTREE_INTKEY || pOp->p3==BTREE_BLOBKEY );  assert( pOp->p1>=0 && pOp->p1<db->nDb );  assert( DbMaskTest(p->btreeMask, pOp->p1) );  assert( p->readOnly==0 );  pDb = &db->aDb[pOp->p1];  assert( pDb->pBt!=0 );  rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);  if( rc ) goto abort_due_to_error;  pOut->u.i = pgno;  break; } case OP_SqlExec: {  sqlite3VdbeIncrWriteCounter(p, 0);  db->nSqlExec++;  rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);  db->nSqlExec--;  if( rc ) goto abort_due_to_error;  break; } case OP_ParseSchema: {  int iDb;  const char *zSchema;  char *zSql;  InitData initData;
#ifdef SQLITE_DEBUG
 for(iDb=0; iDb<db->nDb; iDb++){  assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );  }
#endif
 iDb = pOp->p1;  assert( iDb>=0 && iDb<db->nDb );  assert( DbHasProperty(db, iDb, DB_SchemaLoaded)   || db->mallocFailed   || (CORRUPT_DB && (db->flags & SQLITE_NoSchemaError)!=0) );
#ifndef SQLITE_OMIT_ALTERTABLE
 if( pOp->p4.z==0 ){  sqlite3SchemaClear(db->aDb[iDb].pSchema);  db->mDbFlags &= ~DBFLAG_SchemaKnownOk;  rc = sqlite3InitOne(db, iDb, &p->zErrMsg, pOp->p5);  db->mDbFlags |= DBFLAG_SchemaChange;  p->expired = 0;  }else
#endif
 {  zSchema = LEGACY_SCHEMA_TABLE;  initData.db = db;  initData.iDb = iDb;  initData.pzErrMsg = &p->zErrMsg;  initData.mInitFlags = 0;  initData.mxPage = sqlite3BtreeLastPage(db->aDb[iDb].pBt);  zSql = sqlite3MPrintf(db,   "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid",   db->aDb[iDb].zDbSName, zSchema, pOp->p4.z);  if( zSql==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  assert( db->init.busy==0 );  db->init.busy = 1;  initData.rc = SQLITE_OK;  initData.nInitRow = 0;  assert( !db->mallocFailed );  rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);  if( rc==SQLITE_OK ) rc = initData.rc;  if( rc==SQLITE_OK && initData.nInitRow==0 ){  rc = SQLITE_CORRUPT_BKPT;  }  sqlite3DbFreeNN(db, zSql);  db->init.busy = 0;  }  }  if( rc ){  sqlite3ResetAllSchemasOfConnection(db);  if( rc==SQLITE_NOMEM ){  goto no_mem;  }  goto abort_due_to_error;  }  break; }
#if !defined(SQLITE_OMIT_ANALYZE)
case OP_LoadAnalysis: {  assert( pOp->p1>=0 && pOp->p1<db->nDb );  rc = sqlite3AnalysisLoad(db, pOp->p1);  if( rc ) goto abort_due_to_error;  break; }
#endif
case OP_DropTable: {  sqlite3VdbeIncrWriteCounter(p, 0);  sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);  break; } case OP_DropIndex: {  sqlite3VdbeIncrWriteCounter(p, 0);  sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);  break; } case OP_DropTrigger: {  sqlite3VdbeIncrWriteCounter(p, 0);  sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);  break; }
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
case OP_IntegrityCk: {  int nRoot;  Pgno *aRoot;  int nErr;  char *z;  Mem *pnErr;  assert( p->bIsReader );  nRoot = pOp->p2;  aRoot = pOp->p4.ai;  assert( nRoot>0 );  assert( aRoot[0]==(Pgno)nRoot );  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );  pnErr = &aMem[pOp->p3];  assert( (pnErr->flags & MEM_Int)!=0 );  assert( (pnErr->flags & (MEM_Str|MEM_Blob))==0 );  pIn1 = &aMem[pOp->p1];  assert( pOp->p5<db->nDb );  assert( DbMaskTest(p->btreeMask, pOp->p5) );  z = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot,   (int)pnErr->u.i+1, &nErr);  sqlite3VdbeMemSetNull(pIn1);  if( nErr==0 ){  assert( z==0 );  }else if( z==0 ){  goto no_mem;  }else{  pnErr->u.i -= nErr-1;  sqlite3VdbeMemSetStr(pIn1, z, -1, SQLITE_UTF8, sqlite3_free);  }  UPDATE_MAX_BLOBSIZE(pIn1);  sqlite3VdbeChangeEncoding(pIn1, encoding);  goto check_for_interrupt; }
#endif
case OP_RowSetAdd: {  pIn1 = &aMem[pOp->p1];  pIn2 = &aMem[pOp->p2];  assert( (pIn2->flags & MEM_Int)!=0 );  if( (pIn1->flags & MEM_Blob)==0 ){  if( sqlite3VdbeMemSetRowSet(pIn1) ) goto no_mem;  }  assert( sqlite3VdbeMemIsRowSet(pIn1) );  sqlite3RowSetInsert((RowSet*)pIn1->z, pIn2->u.i);  break; } case OP_RowSetRead: {  i64 val;  pIn1 = &aMem[pOp->p1];  assert( (pIn1->flags & MEM_Blob)==0 || sqlite3VdbeMemIsRowSet(pIn1) );  if( (pIn1->flags & MEM_Blob)==0   || sqlite3RowSetNext((RowSet*)pIn1->z, &val)==0  ){  sqlite3VdbeMemSetNull(pIn1);  VdbeBranchTaken(1,2);  goto jump_to_p2_and_check_for_interrupt;  }else{  VdbeBranchTaken(0,2);  sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);  }  goto check_for_interrupt; } case OP_RowSetTest: {  int iSet;  int exists;  pIn1 = &aMem[pOp->p1];  pIn3 = &aMem[pOp->p3];  iSet = pOp->p4.i;  assert( pIn3->flags&MEM_Int );  if( (pIn1->flags & MEM_Blob)==0 ){  if( sqlite3VdbeMemSetRowSet(pIn1) ) goto no_mem;  }  assert( sqlite3VdbeMemIsRowSet(pIn1) );  assert( pOp->p4type==P4_INT32 );  assert( iSet==-1 || iSet>=0 );  if( iSet ){  exists = sqlite3RowSetTest((RowSet*)pIn1->z, iSet, pIn3->u.i);  VdbeBranchTaken(exists!=0,2);  if( exists ) goto jump_to_p2;  }  if( iSet>=0 ){  sqlite3RowSetInsert((RowSet*)pIn1->z, pIn3->u.i);  }  break; }
#ifndef SQLITE_OMIT_TRIGGER
case OP_Program: {  int nMem;  int nByte;  Mem *pRt;  Mem *pMem;  Mem *pEnd;  VdbeFrame *pFrame;  SubProgram *pProgram;  void *t;  pProgram = pOp->p4.pProgram;  pRt = &aMem[pOp->p3];  assert( pProgram->nOp>0 );  if( pOp->p5 ){  t = pProgram->token;  for(pFrame=p->pFrame; pFrame && pFrame->token!=t; pFrame=pFrame->pParent);  if( pFrame ) break;  }  if( p->nFrame>=db->aLimit[SQLITE_LIMIT_TRIGGER_DEPTH] ){  rc = SQLITE_ERROR;  sqlite3VdbeError(p, "too many levels of trigger recursion");  goto abort_due_to_error;  }  if( (pRt->flags&MEM_Blob)==0 ){  nMem = pProgram->nMem + pProgram->nCsr;  assert( nMem>0 );  if( pProgram->nCsr==0 ) nMem++;  nByte = ROUND8(sizeof(VdbeFrame))  + nMem * sizeof(Mem)  + pProgram->nCsr * sizeof(VdbeCursor*)  + (pProgram->nOp + 7)/8;  pFrame = sqlite3DbMallocZero(db, nByte);  if( !pFrame ){  goto no_mem;  }  sqlite3VdbeMemRelease(pRt);  pRt->flags = MEM_Blob|MEM_Dyn;  pRt->z = (char*)pFrame;  pRt->n = nByte;  pRt->xDel = sqlite3VdbeFrameMemDel;  pFrame->v = p;  pFrame->nChildMem = nMem;  pFrame->nChildCsr = pProgram->nCsr;  pFrame->pc = (int)(pOp - aOp);  pFrame->aMem = p->aMem;  pFrame->nMem = p->nMem;  pFrame->apCsr = p->apCsr;  pFrame->nCursor = p->nCursor;  pFrame->aOp = p->aOp;  pFrame->nOp = p->nOp;  pFrame->token = pProgram->token;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 pFrame->anExec = p->anExec;
#endif
#ifdef SQLITE_DEBUG
 pFrame->iFrameMagic = SQLITE_FRAME_MAGIC;
#endif
 pEnd = &VdbeFrameMem(pFrame)[pFrame->nChildMem];  for(pMem=VdbeFrameMem(pFrame); pMem!=pEnd; pMem++){  pMem->flags = MEM_Undefined;  pMem->db = db;  }  }else{  pFrame = (VdbeFrame*)pRt->z;  assert( pRt->xDel==sqlite3VdbeFrameMemDel );  assert( pProgram->nMem+pProgram->nCsr==pFrame->nChildMem  || (pProgram->nCsr==0 && pProgram->nMem+1==pFrame->nChildMem) );  assert( pProgram->nCsr==pFrame->nChildCsr );  assert( (int)(pOp - aOp)==pFrame->pc );  }  p->nFrame++;  pFrame->pParent = p->pFrame;  pFrame->lastRowid = db->lastRowid;  pFrame->nChange = p->nChange;  pFrame->nDbChange = p->db->nChange;  assert( pFrame->pAuxData==0 );  pFrame->pAuxData = p->pAuxData;  p->pAuxData = 0;  p->nChange = 0;  p->pFrame = pFrame;  p->aMem = aMem = VdbeFrameMem(pFrame);  p->nMem = pFrame->nChildMem;  p->nCursor = (u16)pFrame->nChildCsr;  p->apCsr = (VdbeCursor **)&aMem[p->nMem];  pFrame->aOnce = (u8*)&p->apCsr[pProgram->nCsr];  memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);  p->aOp = aOp = pProgram->aOp;  p->nOp = pProgram->nOp;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 p->anExec = 0;
#endif
#ifdef SQLITE_DEBUG
 {  int i;  for(i=0; i<p->nMem; i++){  aMem[i].pScopyFrom = 0;  MemSetTypeFlag(&aMem[i], MEM_Undefined);  }  }
#endif
 pOp = &aOp[-1];  goto check_for_interrupt; } case OP_Param: {  VdbeFrame *pFrame;  Mem *pIn;  pOut = out2Prerelease(p, pOp);  pFrame = p->pFrame;  pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];  sqlite3VdbeMemShallowCopy(pOut, pIn, MEM_Ephem);  break; }
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
case OP_FkCounter: {  if( db->flags & SQLITE_DeferFKs ){  db->nDeferredImmCons += pOp->p2;  }else if( pOp->p1 ){  db->nDeferredCons += pOp->p2;  }else{  p->nFkConstraint += pOp->p2;  }  break; } case OP_FkIfZero: {  if( pOp->p1 ){  VdbeBranchTaken(db->nDeferredCons==0 && db->nDeferredImmCons==0, 2);  if( db->nDeferredCons==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;  }else{  VdbeBranchTaken(p->nFkConstraint==0 && db->nDeferredImmCons==0, 2);  if( p->nFkConstraint==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;  }  break; }
#endif
#ifndef SQLITE_OMIT_AUTOINCREMENT
case OP_MemMax: {  VdbeFrame *pFrame;  if( p->pFrame ){  for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);  pIn1 = &pFrame->aMem[pOp->p1];  }else{  pIn1 = &aMem[pOp->p1];  }  assert( memIsValid(pIn1) );  sqlite3VdbeMemIntegerify(pIn1);  pIn2 = &aMem[pOp->p2];  sqlite3VdbeMemIntegerify(pIn2);  if( pIn1->u.i<pIn2->u.i){  pIn1->u.i = pIn2->u.i;  }  break; }
#endif
case OP_IfPos: {  pIn1 = &aMem[pOp->p1];  assert( pIn1->flags&MEM_Int );  VdbeBranchTaken( pIn1->u.i>0, 2);  if( pIn1->u.i>0 ){  pIn1->u.i -= pOp->p3;  goto jump_to_p2;  }  break; } case OP_OffsetLimit: {  i64 x;  pIn1 = &aMem[pOp->p1];  pIn3 = &aMem[pOp->p3];  pOut = out2Prerelease(p, pOp);  assert( pIn1->flags & MEM_Int );  assert( pIn3->flags & MEM_Int );  x = pIn1->u.i;  if( x<=0 || sqlite3AddInt64(&x, pIn3->u.i>0?pIn3->u.i:0) ){  pOut->u.i = -1;  }else{  pOut->u.i = x;  }  break; } case OP_IfNotZero: {  pIn1 = &aMem[pOp->p1];  assert( pIn1->flags&MEM_Int );  VdbeBranchTaken(pIn1->u.i<0, 2);  if( pIn1->u.i ){   if( pIn1->u.i>0 ) pIn1->u.i--;   goto jump_to_p2;  }  break; } case OP_DecrJumpZero: {  pIn1 = &aMem[pOp->p1];  assert( pIn1->flags&MEM_Int );  if( pIn1->u.i>SMALLEST_INT64 ) pIn1->u.i--;  VdbeBranchTaken(pIn1->u.i==0, 2);  if( pIn1->u.i==0 ) goto jump_to_p2;  break; } case OP_AggInverse: case OP_AggStep: {  int n;  sqlite3_context *pCtx;  assert( pOp->p4type==P4_FUNCDEF );  n = pOp->p5;  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );  assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );  assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );  pCtx = sqlite3DbMallocRawNN(db, n*sizeof(sqlite3_value*) +   (sizeof(pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value*)));  if( pCtx==0 ) goto no_mem;  pCtx->pMem = 0;  pCtx->pOut = (Mem*)&(pCtx->argv[n]);  sqlite3VdbeMemInit(pCtx->pOut, db, MEM_Null);  pCtx->pFunc = pOp->p4.pFunc;  pCtx->iOp = (int)(pOp - aOp);  pCtx->pVdbe = p;  pCtx->skipFlag = 0;  pCtx->isError = 0;  pCtx->argc = n;  pOp->p4type = P4_FUNCCTX;  pOp->p4.pCtx = pCtx;  assert( pOp->p1==(pOp->opcode==OP_AggInverse) );  pOp->opcode = OP_AggStep1;  deliberate_fall_through } case OP_AggStep1: {  int i;  sqlite3_context *pCtx;  Mem *pMem;  assert( pOp->p4type==P4_FUNCCTX );  pCtx = pOp->p4.pCtx;  pMem = &aMem[pOp->p3];
#ifdef SQLITE_DEBUG
 if( pOp->p1 ){  assert( pMem->uTemp==0x1122e0e3 );  }else{  pMem->uTemp = 0x1122e0e3;  }
#endif
 if( pCtx->pMem != pMem ){  pCtx->pMem = pMem;  for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];  }
#ifdef SQLITE_DEBUG
 for(i=0; i<pCtx->argc; i++){  assert( memIsValid(pCtx->argv[i]) );  REGISTER_TRACE(pOp->p2+i, pCtx->argv[i]);  }
#endif
 pMem->n++;  assert( pCtx->pOut->flags==MEM_Null );  assert( pCtx->isError==0 );  assert( pCtx->skipFlag==0 );
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pOp->p1 ){  (pCtx->pFunc->xInverse)(pCtx,pCtx->argc,pCtx->argv);  }else
#endif
 (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv);  if( pCtx->isError ){  if( pCtx->isError>0 ){  sqlite3VdbeError(p, "%s", sqlite3_value_text(pCtx->pOut));  rc = pCtx->isError;  }  if( pCtx->skipFlag ){  assert( pOp[-1].opcode==OP_CollSeq );  i = pOp[-1].p1;  if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1);  pCtx->skipFlag = 0;  }  sqlite3VdbeMemRelease(pCtx->pOut);  pCtx->pOut->flags = MEM_Null;  pCtx->isError = 0;  if( rc ) goto abort_due_to_error;  }  assert( pCtx->pOut->flags==MEM_Null );  assert( pCtx->skipFlag==0 );  break; } case OP_AggValue: case OP_AggFinal: {  Mem *pMem;  assert( pOp->p1>0 && pOp->p1<=(p->nMem+1 - p->nCursor) );  assert( pOp->p3==0 || pOp->opcode==OP_AggValue );  pMem = &aMem[pOp->p1];  assert( (pMem->flags & ~(MEM_Null|MEM_Agg))==0 );
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pOp->p3 ){  memAboutToChange(p, &aMem[pOp->p3]);  rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);  pMem = &aMem[pOp->p3];  }else
#endif
 {  rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);  }  if( rc ){  sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem));  goto abort_due_to_error;  }  sqlite3VdbeChangeEncoding(pMem, encoding);  UPDATE_MAX_BLOBSIZE(pMem);  if( sqlite3VdbeMemTooBig(pMem) ){  goto too_big;  }  break; }
#ifndef SQLITE_OMIT_WAL
case OP_Checkpoint: {  int i;  int aRes[3];  Mem *pMem;  assert( p->readOnly==0 );  aRes[0] = 0;  aRes[1] = aRes[2] = -1;  assert( pOp->p2==SQLITE_CHECKPOINT_PASSIVE   || pOp->p2==SQLITE_CHECKPOINT_FULL   || pOp->p2==SQLITE_CHECKPOINT_RESTART   || pOp->p2==SQLITE_CHECKPOINT_TRUNCATE  );  rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);  if( rc ){  if( rc!=SQLITE_BUSY ) goto abort_due_to_error;  rc = SQLITE_OK;  aRes[0] = 1;  }  for(i=0, pMem = &aMem[pOp->p3]; i<3; i++, pMem++){  sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);  }  break; };
#endif
#ifndef SQLITE_OMIT_PRAGMA
case OP_JournalMode: {  Btree *pBt;  Pager *pPager;  int eNew;  int eOld;
#ifndef SQLITE_OMIT_WAL
 const char *zFilename;
#endif
 pOut = out2Prerelease(p, pOp);  eNew = pOp->p3;  assert( eNew==PAGER_JOURNALMODE_DELETE   || eNew==PAGER_JOURNALMODE_TRUNCATE   || eNew==PAGER_JOURNALMODE_PERSIST   || eNew==PAGER_JOURNALMODE_OFF   || eNew==PAGER_JOURNALMODE_MEMORY   || eNew==PAGER_JOURNALMODE_WAL   || eNew==PAGER_JOURNALMODE_QUERY  );  assert( pOp->p1>=0 && pOp->p1<db->nDb );  assert( p->readOnly==0 );  pBt = db->aDb[pOp->p1].pBt;  pPager = sqlite3BtreePager(pBt);  eOld = sqlite3PagerGetJournalMode(pPager);  if( eNew==PAGER_JOURNALMODE_QUERY ) eNew = eOld;  assert( sqlite3BtreeHoldsMutex(pBt) );  if( !sqlite3PagerOkToChangeJournalMode(pPager) ) eNew = eOld;
#ifndef SQLITE_OMIT_WAL
 zFilename = sqlite3PagerFilename(pPager, 1);  if( eNew==PAGER_JOURNALMODE_WAL   && (sqlite3Strlen30(zFilename)==0   || !sqlite3PagerWalSupported(pPager))  ){  eNew = eOld;  }  if( (eNew!=eOld)   && (eOld==PAGER_JOURNALMODE_WAL || eNew==PAGER_JOURNALMODE_WAL)  ){  if( !db->autoCommit || db->nVdbeRead>1 ){  rc = SQLITE_ERROR;  sqlite3VdbeError(p,  "cannot change %s wal mode from within a transaction",  (eNew==PAGER_JOURNALMODE_WAL ? "into" : "out of")  );  goto abort_due_to_error;  }else{  if( eOld==PAGER_JOURNALMODE_WAL ){  rc = sqlite3PagerCloseWal(pPager, db);  if( rc==SQLITE_OK ){  sqlite3PagerSetJournalMode(pPager, eNew);  }  }else if( eOld==PAGER_JOURNALMODE_MEMORY ){  sqlite3PagerSetJournalMode(pPager, PAGER_JOURNALMODE_OFF);  }  assert( sqlite3BtreeTxnState(pBt)!=SQLITE_TXN_WRITE );  if( rc==SQLITE_OK ){  rc = sqlite3BtreeSetVersion(pBt, (eNew==PAGER_JOURNALMODE_WAL ? 2 : 1));  }  }  }
#endif
 if( rc ) eNew = eOld;  eNew = sqlite3PagerSetJournalMode(pPager, eNew);  pOut->flags = MEM_Str|MEM_Static|MEM_Term;  pOut->z = (char *)sqlite3JournalModename(eNew);  pOut->n = sqlite3Strlen30(pOut->z);  pOut->enc = SQLITE_UTF8;  sqlite3VdbeChangeEncoding(pOut, encoding);  if( rc ) goto abort_due_to_error;  break; };
#endif
#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)
case OP_Vacuum: {  assert( p->readOnly==0 );  rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1,  pOp->p2 ? &aMem[pOp->p2] : 0);  if( rc ) goto abort_due_to_error;  break; }
#endif
#if !defined(SQLITE_OMIT_AUTOVACUUM)
case OP_IncrVacuum: {  Btree *pBt;  assert( pOp->p1>=0 && pOp->p1<db->nDb );  assert( DbMaskTest(p->btreeMask, pOp->p1) );  assert( p->readOnly==0 );  pBt = db->aDb[pOp->p1].pBt;  rc = sqlite3BtreeIncrVacuum(pBt);  VdbeBranchTaken(rc==SQLITE_DONE,2);  if( rc ){  if( rc!=SQLITE_DONE ) goto abort_due_to_error;  rc = SQLITE_OK;  goto jump_to_p2;  }  break; }
#endif
case OP_Expire: {  assert( pOp->p2==0 || pOp->p2==1 );  if( !pOp->p1 ){  sqlite3ExpirePreparedStatements(db, pOp->p2);  }else{  p->expired = pOp->p2+1;  }  break; } case OP_CursorLock: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  sqlite3BtreeCursorPin(pC->uc.pCursor);  break; } case OP_CursorUnlock: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  pC = p->apCsr[pOp->p1];  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  sqlite3BtreeCursorUnpin(pC->uc.pCursor);  break; }
#ifndef SQLITE_OMIT_SHARED_CACHE
case OP_TableLock: {  u8 isWriteLock = (u8)pOp->p3;  if( isWriteLock || 0==(db->flags&SQLITE_ReadUncommit) ){  int p1 = pOp->p1;  assert( p1>=0 && p1<db->nDb );  assert( DbMaskTest(p->btreeMask, p1) );  assert( isWriteLock==0 || isWriteLock==1 );  rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);  if( rc ){  if( (rc&0xFF)==SQLITE_LOCKED ){  const char *z = pOp->p4.z;  sqlite3VdbeError(p, "database table is locked: %s", z);  }  goto abort_due_to_error;  }  }  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VBegin: {  VTable *pVTab;  pVTab = pOp->p4.pVtab;  rc = sqlite3VtabBegin(db, pVTab);  if( pVTab ) sqlite3VtabImportErrmsg(p, pVTab->pVtab);  if( rc ) goto abort_due_to_error;  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VCreate: {  Mem sMem;  const char *zTab;  memset(&sMem, 0, sizeof(sMem));  sMem.db = db;  assert( (aMem[pOp->p2].flags & MEM_Str)!=0 );  assert( (aMem[pOp->p2].flags & MEM_Static)!=0 );  rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);  assert( rc==SQLITE_OK );  zTab = (const char*)sqlite3_value_text(&sMem);  assert( zTab || db->mallocFailed );  if( zTab ){  rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);  }  sqlite3VdbeMemRelease(&sMem);  if( rc ) goto abort_due_to_error;  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VDestroy: {  db->nVDestroy++;  rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);  db->nVDestroy--;  assert( p->errorAction==OE_Abort && p->usesStmtJournal );  if( rc ) goto abort_due_to_error;  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VOpen: {  VdbeCursor *pCur;  sqlite3_vtab_cursor *pVCur;  sqlite3_vtab *pVtab;  const sqlite3_module *pModule;  assert( p->bIsReader );  pCur = 0;  pVCur = 0;  pVtab = pOp->p4.pVtab->pVtab;  if( pVtab==0 || NEVER(pVtab->pModule==0) ){  rc = SQLITE_LOCKED;  goto abort_due_to_error;  }  pModule = pVtab->pModule;  rc = pModule->xOpen(pVtab, &pVCur);  sqlite3VtabImportErrmsg(p, pVtab);  if( rc ) goto abort_due_to_error;  pVCur->pVtab = pVtab;  pCur = allocateCursor(p, pOp->p1, 0, -1, CURTYPE_VTAB);  if( pCur ){  pCur->uc.pVCur = pVCur;  pVtab->nRef++;  }else{  assert( db->mallocFailed );  pModule->xClose(pVCur);  goto no_mem;  }  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VFilter: {  int nArg;  int iQuery;  const sqlite3_module *pModule;  Mem *pQuery;  Mem *pArgc;  sqlite3_vtab_cursor *pVCur;  sqlite3_vtab *pVtab;  VdbeCursor *pCur;  int res;  int i;  Mem **apArg;  pQuery = &aMem[pOp->p3];  pArgc = &pQuery[1];  pCur = p->apCsr[pOp->p1];  assert( memIsValid(pQuery) );  REGISTER_TRACE(pOp->p3, pQuery);  assert( pCur!=0 );  assert( pCur->eCurType==CURTYPE_VTAB );  pVCur = pCur->uc.pVCur;  pVtab = pVCur->pVtab;  pModule = pVtab->pModule;  assert( (pQuery->flags&MEM_Int)!=0 && pArgc->flags==MEM_Int );  nArg = (int)pArgc->u.i;  iQuery = (int)pQuery->u.i;  apArg = p->apArg;  for(i = 0; i<nArg; i++){  apArg[i] = &pArgc[i+1];  }  rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);  sqlite3VtabImportErrmsg(p, pVtab);  if( rc ) goto abort_due_to_error;  res = pModule->xEof(pVCur);  pCur->nullRow = 0;  VdbeBranchTaken(res!=0,2);  if( res ) goto jump_to_p2;  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VColumn: {  sqlite3_vtab *pVtab;  const sqlite3_module *pModule;  Mem *pDest;  sqlite3_context sContext;  VdbeCursor *pCur = p->apCsr[pOp->p1];  assert( pCur!=0 );  assert( pCur->eCurType==CURTYPE_VTAB );  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );  pDest = &aMem[pOp->p3];  memAboutToChange(p, pDest);  if( pCur->nullRow ){  sqlite3VdbeMemSetNull(pDest);  break;  }  pVtab = pCur->uc.pVCur->pVtab;  pModule = pVtab->pModule;  assert( pModule->xColumn );  memset(&sContext, 0, sizeof(sContext));  sContext.pOut = pDest;  assert( pOp->p5==OPFLAG_NOCHNG || pOp->p5==0 );  if( pOp->p5 & OPFLAG_NOCHNG ){  sqlite3VdbeMemSetNull(pDest);  pDest->flags = MEM_Null|MEM_Zero;  pDest->u.nZero = 0;  }else{  MemSetTypeFlag(pDest, MEM_Null);  }  rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);  sqlite3VtabImportErrmsg(p, pVtab);  if( sContext.isError>0 ){  sqlite3VdbeError(p, "%s", sqlite3_value_text(pDest));  rc = sContext.isError;  }  sqlite3VdbeChangeEncoding(pDest, encoding);  REGISTER_TRACE(pOp->p3, pDest);  UPDATE_MAX_BLOBSIZE(pDest);  if( sqlite3VdbeMemTooBig(pDest) ){  goto too_big;  }  if( rc ) goto abort_due_to_error;  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VNext: {  sqlite3_vtab *pVtab;  const sqlite3_module *pModule;  int res;  VdbeCursor *pCur;  pCur = p->apCsr[pOp->p1];  assert( pCur!=0 );  assert( pCur->eCurType==CURTYPE_VTAB );  if( pCur->nullRow ){  break;  }  pVtab = pCur->uc.pVCur->pVtab;  pModule = pVtab->pModule;  assert( pModule->xNext );  rc = pModule->xNext(pCur->uc.pVCur);  sqlite3VtabImportErrmsg(p, pVtab);  if( rc ) goto abort_due_to_error;  res = pModule->xEof(pCur->uc.pVCur);  VdbeBranchTaken(!res,2);  if( !res ){  goto jump_to_p2_and_check_for_interrupt;  }  goto check_for_interrupt; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VRename: {  sqlite3_vtab *pVtab;  Mem *pName;  int isLegacy;  isLegacy = (db->flags & SQLITE_LegacyAlter);  db->flags |= SQLITE_LegacyAlter;  pVtab = pOp->p4.pVtab->pVtab;  pName = &aMem[pOp->p1];  assert( pVtab->pModule->xRename );  assert( memIsValid(pName) );  assert( p->readOnly==0 );  REGISTER_TRACE(pOp->p1, pName);  assert( pName->flags & MEM_Str );  testcase( pName->enc==SQLITE_UTF8 );  testcase( pName->enc==SQLITE_UTF16BE );  testcase( pName->enc==SQLITE_UTF16LE );  rc = sqlite3VdbeChangeEncoding(pName, SQLITE_UTF8);  if( rc ) goto abort_due_to_error;  rc = pVtab->pModule->xRename(pVtab, pName->z);  if( isLegacy==0 ) db->flags &= ~(u64)SQLITE_LegacyAlter;  sqlite3VtabImportErrmsg(p, pVtab);  p->expired = 0;  if( rc ) goto abort_due_to_error;  break; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
case OP_VUpdate: {  sqlite3_vtab *pVtab;  const sqlite3_module *pModule;  int nArg;  int i;  sqlite_int64 rowid = 0;  Mem **apArg;  Mem *pX;  assert( pOp->p2==1 || pOp->p5==OE_Fail  || pOp->p5==OE_Rollback   || pOp->p5==OE_Abort || pOp->p5==OE_Ignore || pOp->p5==OE_Replace  );  assert( p->readOnly==0 );  if( db->mallocFailed ) goto no_mem;  sqlite3VdbeIncrWriteCounter(p, 0);  pVtab = pOp->p4.pVtab->pVtab;  if( pVtab==0 || NEVER(pVtab->pModule==0) ){  rc = SQLITE_LOCKED;  goto abort_due_to_error;  }  pModule = pVtab->pModule;  nArg = pOp->p2;  assert( pOp->p4type==P4_VTAB );  if( ALWAYS(pModule->xUpdate) ){  u8 vtabOnConflict = db->vtabOnConflict;  apArg = p->apArg;  pX = &aMem[pOp->p3];  for(i=0; i<nArg; i++){  assert( memIsValid(pX) );  memAboutToChange(p, pX);  apArg[i] = pX;  pX++;  }  db->vtabOnConflict = pOp->p5;  rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);  db->vtabOnConflict = vtabOnConflict;  sqlite3VtabImportErrmsg(p, pVtab);  if( rc==SQLITE_OK && pOp->p1 ){  assert( nArg>1 && apArg[0] && (apArg[0]->flags&MEM_Null) );  db->lastRowid = rowid;  }  if( (rc&0xff)==SQLITE_CONSTRAINT && pOp->p4.pVtab->bConstraint ){  if( pOp->p5==OE_Ignore ){  rc = SQLITE_OK;  }else{  p->errorAction = ((pOp->p5==OE_Replace) ? OE_Abort : pOp->p5);  }  }else{  p->nChange++;  }  if( rc ) goto abort_due_to_error;  }  break; }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
case OP_Pagecount: {  pOut = out2Prerelease(p, pOp);  pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);  break; }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
case OP_MaxPgcnt: {  unsigned int newMax;  Btree *pBt;  pOut = out2Prerelease(p, pOp);  pBt = db->aDb[pOp->p1].pBt;  newMax = 0;  if( pOp->p3 ){  newMax = sqlite3BtreeLastPage(pBt);  if( newMax < (unsigned)pOp->p3 ) newMax = (unsigned)pOp->p3;  }  pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);  break; }
#endif
case OP_PureFunc: case OP_Function: {  int i;  sqlite3_context *pCtx;  assert( pOp->p4type==P4_FUNCCTX );  pCtx = pOp->p4.pCtx;  pOut = &aMem[pOp->p3];  if( pCtx->pOut != pOut ){  pCtx->pVdbe = p;  pCtx->pOut = pOut;  for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];  }  assert( pCtx->pVdbe==p );  memAboutToChange(p, pOut);
#ifdef SQLITE_DEBUG
 for(i=0; i<pCtx->argc; i++){  assert( memIsValid(pCtx->argv[i]) );  REGISTER_TRACE(pOp->p2+i, pCtx->argv[i]);  }
#endif
 MemSetTypeFlag(pOut, MEM_Null);  assert( pCtx->isError==0 );  (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);  if( pCtx->isError ){  if( pCtx->isError>0 ){  sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut));  rc = pCtx->isError;  }  sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);  pCtx->isError = 0;  if( rc ) goto abort_due_to_error;  }  if( pOut->flags & (MEM_Str|MEM_Blob) ){  sqlite3VdbeChangeEncoding(pOut, encoding);  if( sqlite3VdbeMemTooBig(pOut) ) goto too_big;  }  REGISTER_TRACE(pOp->p3, pOut);  UPDATE_MAX_BLOBSIZE(pOut);  break; } case OP_Trace: case OP_Init: {  int i;
#ifndef SQLITE_OMIT_TRACE
 char *zTrace;
#endif
 assert( pOp->p4.z==0 || strncmp(pOp->p4.z, "-" "- ", 3)==0 );  assert( pOp==p->aOp || pOp->opcode==OP_Trace );
#ifndef SQLITE_OMIT_TRACE
 if( (db->mTrace & (SQLITE_TRACE_STMT|SQLITE_TRACE_LEGACY))!=0   && !p->doingRerun   && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql))!=0  ){
#ifndef SQLITE_OMIT_DEPRECATED
 if( db->mTrace & SQLITE_TRACE_LEGACY ){  char *z = sqlite3VdbeExpandSql(p, zTrace);  db->trace.xLegacy(db->pTraceArg, z);  sqlite3_free(z);  }else
#endif
 if( db->nVdbeExec>1 ){  char *z = sqlite3MPrintf(db, "-- %s", zTrace);  (void)db->trace.xV2(SQLITE_TRACE_STMT, db->pTraceArg, p, z);  sqlite3DbFree(db, z);  }else{  (void)db->trace.xV2(SQLITE_TRACE_STMT, db->pTraceArg, p, zTrace);  }  }
#ifdef SQLITE_USE_FCNTL_TRACE
 zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql);  if( zTrace ){  int j;  for(j=0; j<db->nDb; j++){  if( DbMaskTest(p->btreeMask, j)==0 ) continue;  sqlite3_file_control(db, db->aDb[j].zDbSName, SQLITE_FCNTL_TRACE, zTrace);  }  }
#endif
#ifdef SQLITE_DEBUG
 if( (db->flags & SQLITE_SqlTrace)!=0   && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql))!=0  ){  sqlite3DebugPrintf("SQL-trace: %s\n", zTrace);  }
#endif
#endif
 assert( pOp->p2>0 );  if( pOp->p1>=sqlite3GlobalConfig.iOnceResetThreshold ){  if( pOp->opcode==OP_Trace ) break;  for(i=1; i<p->nOp; i++){  if( p->aOp[i].opcode==OP_Once ) p->aOp[i].p1 = 0;  }  pOp->p1 = 0;  }  pOp->p1++;  p->aCounter[SQLITE_STMTSTATUS_RUN]++;  goto jump_to_p2; }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
case OP_CursorHint: {  VdbeCursor *pC;  assert( pOp->p1>=0 && pOp->p1<p->nCursor );  assert( pOp->p4type==P4_EXPR );  pC = p->apCsr[pOp->p1];  if( pC ){  assert( pC->eCurType==CURTYPE_BTREE );  sqlite3BtreeCursorHint(pC->uc.pCursor, BTREE_HINT_RANGE,   pOp->p4.pExpr, aMem);  }  break; }
#endif
#ifdef SQLITE_DEBUG
case OP_Abortable: {  sqlite3VdbeAssertAbortable(p);  break; }
#endif
#ifdef SQLITE_DEBUG
case OP_ReleaseReg: {  Mem *pMem;  int i;  u32 constMask;  assert( pOp->p1>0 );  assert( pOp->p1+pOp->p2<=(p->nMem+1 - p->nCursor)+1 );  pMem = &aMem[pOp->p1];  constMask = pOp->p3;  for(i=0; i<pOp->p2; i++, pMem++){  if( i>=32 || (constMask & MASKBIT32(i))==0 ){  pMem->pScopyFrom = 0;  if( i<32 && pOp->p5 ) MemSetTypeFlag(pMem, MEM_Undefined);  }  }  break; }
#endif
default: {  assert( pOp->opcode==OP_Noop || pOp->opcode==OP_Explain );  break; }  }
#ifdef VDBE_PROFILE
 {  u64 endTime = sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();  if( endTime>start ) pOrigOp->cycles += endTime - start;  pOrigOp->cnt++;  }
#endif
#ifndef NDEBUG
 assert( pOp>=&aOp[-1] && pOp<&aOp[p->nOp-1] );
#ifdef SQLITE_DEBUG
 if( db->flags & SQLITE_VdbeTrace ){  u8 opProperty = sqlite3OpcodeProperty[pOrigOp->opcode];  if( rc!=0 ) printf("rc=%d\n",rc);  if( opProperty & (OPFLG_OUT2) ){  registerTrace(pOrigOp->p2, &aMem[pOrigOp->p2]);  }  if( opProperty & OPFLG_OUT3 ){  registerTrace(pOrigOp->p3, &aMem[pOrigOp->p3]);  }  if( opProperty==0xff ){  sqlite3VdbeRegisterDump(p);  }  }
#endif
#endif
 } abort_due_to_error:  if( db->mallocFailed ){  rc = SQLITE_NOMEM_BKPT;  }else if( rc==SQLITE_IOERR_CORRUPTFS ){  rc = SQLITE_CORRUPT_BKPT;  }  assert( rc );
#ifdef SQLITE_DEBUG
 if( db->flags & SQLITE_VdbeTrace ){  const char *zTrace = p->zSql;  if( zTrace==0 ){  if( aOp[0].opcode==OP_Trace ){  zTrace = aOp[0].p4.z;  }  if( zTrace==0 ) zTrace = "???";  }  printf("ABORT-due-to-error (rc=%d): %s\n", rc, zTrace);  }
#endif
 if( p->zErrMsg==0 && rc!=SQLITE_IOERR_NOMEM ){  sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc));  }  p->rc = rc;  sqlite3SystemError(db, rc);  testcase( sqlite3GlobalConfig.xLog!=0 );  sqlite3_log(rc, "statement aborts at %d: [%s] %s",   (int)(pOp - aOp), p->zSql, p->zErrMsg);  sqlite3VdbeHalt(p);  if( rc==SQLITE_IOERR_NOMEM ) sqlite3OomFault(db);  if( rc==SQLITE_CORRUPT && db->autoCommit==0 ){  db->flags |= SQLITE_CorruptRdOnly;  }  rc = SQLITE_ERROR;  if( resetSchemaOnFault>0 ){  sqlite3ResetOneSchema(db, resetSchemaOnFault-1);  } vdbe_return:
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
 while( nVmStep>=nProgressLimit && db->xProgress!=0 ){  nProgressLimit += db->nProgressOps;  if( db->xProgress(db->pProgressArg) ){  nProgressLimit = LARGEST_UINT64;  rc = SQLITE_INTERRUPT;  goto abort_due_to_error;  }  }
#endif
 p->aCounter[SQLITE_STMTSTATUS_VM_STEP] += (int)nVmStep;  sqlite3VdbeLeave(p);  assert( rc!=SQLITE_OK || nExtraDelete==0   || sqlite3_strlike("DELETE%",p->zSql,0)!=0  );  return rc; too_big:  sqlite3VdbeError(p, "string or blob too big");  rc = SQLITE_TOOBIG;  goto abort_due_to_error;
no_mem:  sqlite3OomFault(db);  sqlite3VdbeError(p, "out of memory");  rc = SQLITE_NOMEM_BKPT;  goto abort_due_to_error; abort_due_to_interrupt:  assert( AtomicLoad(&db->u1.isInterrupted) );  rc = SQLITE_INTERRUPT;  goto abort_due_to_error; }
#ifndef SQLITE_OMIT_INCRBLOB
typedef struct Incrblob Incrblob; struct Incrblob {  int nByte;  int iOffset;  u16 iCol;  BtCursor *pCsr;  sqlite3_stmt *pStmt;  sqlite3 *db;  char *zDb;  Table *pTab; }; static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){  int rc;  char *zErr = 0;  Vdbe *v = (Vdbe *)p->pStmt;  v->aMem[1].flags = MEM_Int;  v->aMem[1].u.i = iRow;  if( v->pc>4 ){  v->pc = 4;  assert( v->aOp[v->pc].opcode==OP_NotExists );  rc = sqlite3VdbeExec(v);  }else{  rc = sqlite3_step(p->pStmt);  }  if( rc==SQLITE_ROW ){  VdbeCursor *pC = v->apCsr[0];  u32 type;  assert( pC!=0 );  assert( pC->eCurType==CURTYPE_BTREE );  type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;  testcase( pC->nHdrParsed==p->iCol );  testcase( pC->nHdrParsed==p->iCol+1 );  if( type<12 ){  zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",  type==0?"null": type==7?"real": "integer"  );  rc = SQLITE_ERROR;  sqlite3_finalize(p->pStmt);  p->pStmt = 0;  }else{  p->iOffset = pC->aType[p->iCol + pC->nField];  p->nByte = sqlite3VdbeSerialTypeLen(type);  p->pCsr = pC->uc.pCursor;  sqlite3BtreeIncrblobCursor(p->pCsr);  }  }  if( rc==SQLITE_ROW ){  rc = SQLITE_OK;  }else if( p->pStmt ){  rc = sqlite3_finalize(p->pStmt);  p->pStmt = 0;  if( rc==SQLITE_OK ){  zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);  rc = SQLITE_ERROR;  }else{  zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));  }  }  assert( rc!=SQLITE_OK || zErr==0 );  assert( rc!=SQLITE_ROW && rc!=SQLITE_DONE );  *pzErr = zErr;  return rc; } SQLITE_API int sqlite3_blob_open(  sqlite3* db,  const char *zDb,  const char *zTable,  const char *zColumn,  sqlite_int64 iRow,  int wrFlag,  sqlite3_blob **ppBlob ){  int nAttempt = 0;  int iCol;  int rc = SQLITE_OK;  char *zErr = 0;  Table *pTab;  Incrblob *pBlob = 0;  Parse sParse;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( ppBlob==0 ){  return SQLITE_MISUSE_BKPT;  }
#endif
 *ppBlob = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zTable==0 ){  return SQLITE_MISUSE_BKPT;  }
#endif
 wrFlag = !!wrFlag;  sqlite3_mutex_enter(db->mutex);  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));  do {  memset(&sParse, 0, sizeof(Parse));  if( !pBlob ) goto blob_open_out;  sParse.db = db;  sqlite3DbFree(db, zErr);  zErr = 0;  sqlite3BtreeEnterAll(db);  pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);  if( pTab && IsVirtual(pTab) ){  pTab = 0;  sqlite3ErrorMsg(&sParse, "cannot open virtual table: %s", zTable);  }  if( pTab && !HasRowid(pTab) ){  pTab = 0;  sqlite3ErrorMsg(&sParse, "cannot open table without rowid: %s", zTable);  }
#ifndef SQLITE_OMIT_VIEW
 if( pTab && IsView(pTab) ){  pTab = 0;  sqlite3ErrorMsg(&sParse, "cannot open view: %s", zTable);  }
#endif
 if( !pTab ){  if( sParse.zErrMsg ){  sqlite3DbFree(db, zErr);  zErr = sParse.zErrMsg;  sParse.zErrMsg = 0;  }  rc = SQLITE_ERROR;  sqlite3BtreeLeaveAll(db);  goto blob_open_out;  }  pBlob->pTab = pTab;  pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;  for(iCol=0; iCol<pTab->nCol; iCol++) {  if( sqlite3StrICmp(pTab->aCol[iCol].zCnName, zColumn)==0 ){  break;  }  }  if( iCol==pTab->nCol ){  sqlite3DbFree(db, zErr);  zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);  rc = SQLITE_ERROR;  sqlite3BtreeLeaveAll(db);  goto blob_open_out;  }  if( wrFlag ){  const char *zFault = 0;  Index *pIdx;
#ifndef SQLITE_OMIT_FOREIGN_KEY
 if( db->flags&SQLITE_ForeignKeys ){  FKey *pFKey;  assert( IsOrdinaryTable(pTab) );  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){  int j;  for(j=0; j<pFKey->nCol; j++){  if( pFKey->aCol[j].iFrom==iCol ){  zFault = "foreign key";  }  }  }  }
#endif
 for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  int j;  for(j=0; j<pIdx->nKeyCol; j++){  if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==XN_EXPR ){  zFault = "indexed";  }  }  }  if( zFault ){  sqlite3DbFree(db, zErr);  zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);  rc = SQLITE_ERROR;  sqlite3BtreeLeaveAll(db);  goto blob_open_out;  }  }  pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);  assert( pBlob->pStmt || db->mallocFailed );  if( pBlob->pStmt ){  static const int iLn = VDBE_OFFSET_LINENO(2);  static const VdbeOpList openBlob[] = {  {OP_TableLock, 0, 0, 0},  {OP_OpenRead, 0, 0, 0},  {OP_NotExists, 0, 5, 1},  {OP_Column, 0, 0, 1},  {OP_ResultRow, 1, 0, 0},  {OP_Halt, 0, 0, 0},  };  Vdbe *v = (Vdbe *)pBlob->pStmt;  int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  VdbeOp *aOp;  sqlite3VdbeAddOp4Int(v, OP_Transaction, iDb, wrFlag,   pTab->pSchema->schema_cookie,   pTab->pSchema->iGeneration);  sqlite3VdbeChangeP5(v, 1);  assert( sqlite3VdbeCurrentAddr(v)==2 || db->mallocFailed );  aOp = sqlite3VdbeAddOpList(v, ArraySize(openBlob), openBlob, iLn);  sqlite3VdbeUsesBtree(v, iDb);  if( db->mallocFailed==0 ){  assert( aOp!=0 );
#ifdef SQLITE_OMIT_SHARED_CACHE
 aOp[0].opcode = OP_Noop;
#else
 aOp[0].p1 = iDb;  aOp[0].p2 = pTab->tnum;  aOp[0].p3 = wrFlag;  sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT);  }  if( db->mallocFailed==0 ){
#endif
 if( wrFlag ) aOp[1].opcode = OP_OpenWrite;  aOp[1].p2 = pTab->tnum;  aOp[1].p3 = iDb;  aOp[1].p4type = P4_INT32;  aOp[1].p4.i = pTab->nCol+1;  aOp[3].p2 = pTab->nCol;  sParse.nVar = 0;  sParse.nMem = 1;  sParse.nTab = 1;  sqlite3VdbeMakeReady(v, &sParse);  }  }  pBlob->iCol = iCol;  pBlob->db = db;  sqlite3BtreeLeaveAll(db);  if( db->mallocFailed ){  goto blob_open_out;  }  rc = blobSeekToRow(pBlob, iRow, &zErr);  } while( (++nAttempt)<SQLITE_MAX_SCHEMA_RETRY && rc==SQLITE_SCHEMA ); blob_open_out:  if( rc==SQLITE_OK && db->mallocFailed==0 ){  *ppBlob = (sqlite3_blob *)pBlob;  }else{  if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);  sqlite3DbFree(db, pBlob);  }  sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);  sqlite3DbFree(db, zErr);  sqlite3ParserReset(&sParse);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){  Incrblob *p = (Incrblob *)pBlob;  int rc;  sqlite3 *db;  if( p ){  sqlite3_stmt *pStmt = p->pStmt;  db = p->db;  sqlite3_mutex_enter(db->mutex);  sqlite3DbFree(db, p);  sqlite3_mutex_leave(db->mutex);  rc = sqlite3_finalize(pStmt);  }else{  rc = SQLITE_OK;  }  return rc; } static int blobReadWrite(  sqlite3_blob *pBlob,  void *z,  int n,  int iOffset,  int (*xCall)(BtCursor*, u32, u32, void*) ){  int rc;  Incrblob *p = (Incrblob *)pBlob;  Vdbe *v;  sqlite3 *db;  if( p==0 ) return SQLITE_MISUSE_BKPT;  db = p->db;  sqlite3_mutex_enter(db->mutex);  v = (Vdbe*)p->pStmt;  if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){  rc = SQLITE_ERROR;  }else if( v==0 ){  rc = SQLITE_ABORT;  }else{  assert( db == v->db );  sqlite3BtreeEnterCursor(p->pCsr);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 if( xCall==sqlite3BtreePutData && db->xPreUpdateCallback ){  sqlite3_int64 iKey;  iKey = sqlite3BtreeIntegerKey(p->pCsr);  assert( v->apCsr[0]!=0 );  assert( v->apCsr[0]->eCurType==CURTYPE_BTREE );  sqlite3VdbePreUpdateHook(  v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1, p->iCol  );  }
#endif
 rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);  sqlite3BtreeLeaveCursor(p->pCsr);  if( rc==SQLITE_ABORT ){  sqlite3VdbeFinalize(v);  p->pStmt = 0;  }else{  v->rc = rc;  }  }  sqlite3Error(db, rc);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked); } SQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData); } SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){  Incrblob *p = (Incrblob *)pBlob;  return (p && p->pStmt) ? p->nByte : 0; } SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){  int rc;  Incrblob *p = (Incrblob *)pBlob;  sqlite3 *db;  if( p==0 ) return SQLITE_MISUSE_BKPT;  db = p->db;  sqlite3_mutex_enter(db->mutex);  if( p->pStmt==0 ){  rc = SQLITE_ABORT;  }else{  char *zErr;  ((Vdbe*)p->pStmt)->rc = SQLITE_OK;  rc = blobSeekToRow(p, iRow, &zErr);  if( rc!=SQLITE_OK ){  sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);  sqlite3DbFree(db, zErr);  }  assert( rc!=SQLITE_SCHEMA );  }  rc = sqlite3ApiExit(db, rc);  assert( rc==SQLITE_OK || p->pStmt==0 );  sqlite3_mutex_leave(db->mutex);  return rc; }
#endif
#if 0
# define SQLITE_DEBUG_SORTER_THREADS 1
#endif
#define SQLITE_MAX_PMASZ (1<<29)
typedef struct MergeEngine MergeEngine; typedef struct PmaReader PmaReader; typedef struct PmaWriter PmaWriter; typedef struct SorterRecord SorterRecord; typedef struct SortSubtask SortSubtask; typedef struct SorterFile SorterFile; typedef struct SorterList SorterList; typedef struct IncrMerger IncrMerger; struct SorterFile {  sqlite3_file *pFd;  i64 iEof; }; struct SorterList {  SorterRecord *pList;  u8 *aMemory;  int szPMA; }; struct MergeEngine {  int nTree;  SortSubtask *pTask;  int *aTree;  PmaReader *aReadr; }; typedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int); struct SortSubtask {  SQLiteThread *pThread;  int bDone;  VdbeSorter *pSorter;  UnpackedRecord *pUnpacked;  SorterList list;  int nPMA;  SorterCompare xCompare;  SorterFile file;  SorterFile file2; }; struct VdbeSorter {  int mnPmaSize;  int mxPmaSize;  int mxKeysize;  int pgsz;  PmaReader *pReader;  MergeEngine *pMerger;  sqlite3 *db;  KeyInfo *pKeyInfo;  UnpackedRecord *pUnpacked;  SorterList list;  int iMemory;  int nMemory;  u8 bUsePMA;  u8 bUseThreads;  u8 iPrev;  u8 nTask;  u8 typeMask;  SortSubtask aTask[1]; };
#define SORTER_TYPE_INTEGER 0x01
#define SORTER_TYPE_TEXT 0x02
struct PmaReader {  i64 iReadOff;  i64 iEof;  int nAlloc;  int nKey;  sqlite3_file *pFd;  u8 *aAlloc;  u8 *aKey;  u8 *aBuffer;  int nBuffer;  u8 *aMap;  IncrMerger *pIncr; }; struct IncrMerger {  SortSubtask *pTask;  MergeEngine *pMerger;  i64 iStartOff;  int mxSz;  int bEof;  int bUseThread;  SorterFile aFile[2]; }; struct PmaWriter {  int eFWErr;  u8 *aBuffer;  int nBuffer;  int iBufStart;  int iBufEnd;  i64 iWriteOff;  sqlite3_file *pFd; }; struct SorterRecord {  int nVal;  union {  SorterRecord *pNext;  int iNext;  } u; };
#define SRVAL(p) ((void*)((SorterRecord*)(p) + 1))
#define SORTER_MAX_MERGE_COUNT 16
static int vdbeIncrSwap(IncrMerger*); static void vdbeIncrFree(IncrMerger *); static void vdbePmaReaderClear(PmaReader *pReadr){  sqlite3_free(pReadr->aAlloc);  sqlite3_free(pReadr->aBuffer);  if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);  vdbeIncrFree(pReadr->pIncr);  memset(pReadr, 0, sizeof(PmaReader)); } static int vdbePmaReadBlob(  PmaReader *p,  int nByte,  u8 **ppOut ){  int iBuf;  int nAvail;  if( p->aMap ){  *ppOut = &p->aMap[p->iReadOff];  p->iReadOff += nByte;  return SQLITE_OK;  }  assert( p->aBuffer );  iBuf = p->iReadOff % p->nBuffer;  if( iBuf==0 ){  int nRead;  int rc;  if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){  nRead = p->nBuffer;  }else{  nRead = (int)(p->iEof - p->iReadOff);  }  assert( nRead>0 );  rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);  assert( rc!=SQLITE_IOERR_SHORT_READ );  if( rc!=SQLITE_OK ) return rc;  }  nAvail = p->nBuffer - iBuf;  if( nByte<=nAvail ){  *ppOut = &p->aBuffer[iBuf];  p->iReadOff += nByte;  }else{  int nRem;  if( p->nAlloc<nByte ){  u8 *aNew;  sqlite3_int64 nNew = MAX(128, 2*(sqlite3_int64)p->nAlloc);  while( nByte>nNew ) nNew = nNew*2;  aNew = sqlite3Realloc(p->aAlloc, nNew);  if( !aNew ) return SQLITE_NOMEM_BKPT;  p->nAlloc = nNew;  p->aAlloc = aNew;  }  memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);  p->iReadOff += nAvail;  nRem = nByte - nAvail;  while( nRem>0 ){  int rc;  int nCopy;  u8 *aNext;  nCopy = nRem;  if( nRem>p->nBuffer ) nCopy = p->nBuffer;  rc = vdbePmaReadBlob(p, nCopy, &aNext);  if( rc!=SQLITE_OK ) return rc;  assert( aNext!=p->aAlloc );  memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);  nRem -= nCopy;  }  *ppOut = p->aAlloc;  }  return SQLITE_OK; } static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){  int iBuf;  if( p->aMap ){  p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);  }else{  iBuf = p->iReadOff % p->nBuffer;  if( iBuf && (p->nBuffer-iBuf)>=9 ){  p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);  }else{  u8 aVarint[16], *a;  int i = 0, rc;  do{  rc = vdbePmaReadBlob(p, 1, &a);  if( rc ) return rc;  aVarint[(i++)&0xf] = a[0];  }while( (a[0]&0x80)!=0 );  sqlite3GetVarint(aVarint, pnOut);  }  }  return SQLITE_OK; } static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){  int rc = SQLITE_OK;  if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){  sqlite3_file *pFd = pFile->pFd;  if( pFd->pMethods->iVersion>=3 ){  rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);  testcase( rc!=SQLITE_OK );  }  }  return rc; } static int vdbePmaReaderSeek(  SortSubtask *pTask,  PmaReader *pReadr,  SorterFile *pFile,  i64 iOff ){  int rc = SQLITE_OK;  assert( pReadr->pIncr==0 || pReadr->pIncr->bEof==0 );  if( sqlite3FaultSim(201) ) return SQLITE_IOERR_READ;  if( pReadr->aMap ){  sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);  pReadr->aMap = 0;  }  pReadr->iReadOff = iOff;  pReadr->iEof = pFile->iEof;  pReadr->pFd = pFile->pFd;  rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);  if( rc==SQLITE_OK && pReadr->aMap==0 ){  int pgsz = pTask->pSorter->pgsz;  int iBuf = pReadr->iReadOff % pgsz;  if( pReadr->aBuffer==0 ){  pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);  if( pReadr->aBuffer==0 ) rc = SQLITE_NOMEM_BKPT;  pReadr->nBuffer = pgsz;  }  if( rc==SQLITE_OK && iBuf ){  int nRead = pgsz - iBuf;  if( (pReadr->iReadOff + nRead) > pReadr->iEof ){  nRead = (int)(pReadr->iEof - pReadr->iReadOff);  }  rc = sqlite3OsRead(  pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff  );  testcase( rc!=SQLITE_OK );  }  }  return rc; } static int vdbePmaReaderNext(PmaReader *pReadr){  int rc = SQLITE_OK;  u64 nRec = 0;  if( pReadr->iReadOff>=pReadr->iEof ){  IncrMerger *pIncr = pReadr->pIncr;  int bEof = 1;  if( pIncr ){  rc = vdbeIncrSwap(pIncr);  if( rc==SQLITE_OK && pIncr->bEof==0 ){  rc = vdbePmaReaderSeek(  pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff  );  bEof = 0;  }  }  if( bEof ){  vdbePmaReaderClear(pReadr);  testcase( rc!=SQLITE_OK );  return rc;  }  }  if( rc==SQLITE_OK ){  rc = vdbePmaReadVarint(pReadr, &nRec);  }  if( rc==SQLITE_OK ){  pReadr->nKey = (int)nRec;  rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);  testcase( rc!=SQLITE_OK );  }  return rc; } static int vdbePmaReaderInit(  SortSubtask *pTask,  SorterFile *pFile,  i64 iStart,  PmaReader *pReadr,  i64 *pnByte ){  int rc;  assert( pFile->iEof>iStart );  assert( pReadr->aAlloc==0 && pReadr->nAlloc==0 );  assert( pReadr->aBuffer==0 );  assert( pReadr->aMap==0 );  rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);  if( rc==SQLITE_OK ){  u64 nByte = 0;  rc = vdbePmaReadVarint(pReadr, &nByte);  pReadr->iEof = pReadr->iReadOff + nByte;  *pnByte += nByte;  }  if( rc==SQLITE_OK ){  rc = vdbePmaReaderNext(pReadr);  }  return rc; } static int vdbeSorterCompareTail(  SortSubtask *pTask,  int *pbKey2Cached,  const void *pKey1, int nKey1,  const void *pKey2, int nKey2 ){  UnpackedRecord *r2 = pTask->pUnpacked;  if( *pbKey2Cached==0 ){  sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);  *pbKey2Cached = 1;  }  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1); } static int vdbeSorterCompare(  SortSubtask *pTask,  int *pbKey2Cached,  const void *pKey1, int nKey1,  const void *pKey2, int nKey2 ){  UnpackedRecord *r2 = pTask->pUnpacked;  if( !*pbKey2Cached ){  sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);  *pbKey2Cached = 1;  }  return sqlite3VdbeRecordCompare(nKey1, pKey1, r2); } static int vdbeSorterCompareText(  SortSubtask *pTask,  int *pbKey2Cached,  const void *pKey1, int nKey1,  const void *pKey2, int nKey2 ){  const u8 * const p1 = (const u8 * const)pKey1;  const u8 * const p2 = (const u8 * const)pKey2;  const u8 * const v1 = &p1[ p1[0] ];  const u8 * const v2 = &p2[ p2[0] ];  int n1;  int n2;  int res;  getVarint32NR(&p1[1], n1);  getVarint32NR(&p2[1], n2);  res = memcmp(v1, v2, (MIN(n1, n2) - 13)/2);  if( res==0 ){  res = n1 - n2;  }  if( res==0 ){  if( pTask->pSorter->pKeyInfo->nKeyField>1 ){  res = vdbeSorterCompareTail(  pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2  );  }  }else{  assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );  if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){  res = res * -1;  }  }  return res; } static int vdbeSorterCompareInt(  SortSubtask *pTask,  int *pbKey2Cached,  const void *pKey1, int nKey1,  const void *pKey2, int nKey2 ){  const u8 * const p1 = (const u8 * const)pKey1;  const u8 * const p2 = (const u8 * const)pKey2;  const int s1 = p1[1];  const int s2 = p2[1];  const u8 * const v1 = &p1[ p1[0] ];  const u8 * const v2 = &p2[ p2[0] ];  int res;  assert( (s1>0 && s1<7) || s1==8 || s1==9 );  assert( (s2>0 && s2<7) || s2==8 || s2==9 );  if( s1==s2 ){  static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };  const u8 n = aLen[s1];  int i;  res = 0;  for(i=0; i<n; i++){  if( (res = v1[i] - v2[i])!=0 ){  if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){  res = v1[0] & 0x80 ? -1 : +1;  }  break;  }  }  }else if( s1>7 && s2>7 ){  res = s1 - s2;  }else{  if( s2>7 ){  res = +1;  }else if( s1>7 ){  res = -1;  }else{  res = s1 - s2;  }  assert( res!=0 );  if( res>0 ){  if( *v1 & 0x80 ) res = -1;  }else{  if( *v2 & 0x80 ) res = +1;  }  }  if( res==0 ){  if( pTask->pSorter->pKeyInfo->nKeyField>1 ){  res = vdbeSorterCompareTail(  pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2  );  }  }else if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){  assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );  res = res * -1;  }  return res; } SQLITE_PRIVATE int sqlite3VdbeSorterInit(  sqlite3 *db,  int nField,  VdbeCursor *pCsr ){  int pgsz;  int i;  VdbeSorter *pSorter;  KeyInfo *pKeyInfo;  int szKeyInfo;  int sz;  int rc = SQLITE_OK;
#if SQLITE_MAX_WORKER_THREADS==0
# define nWorker 0
#else
 int nWorker;
#endif
#if SQLITE_MAX_WORKER_THREADS>0
 if( sqlite3TempInMemory(db) || sqlite3GlobalConfig.bCoreMutex==0 ){  nWorker = 0;  }else{  nWorker = db->aLimit[SQLITE_LIMIT_WORKER_THREADS];  }
#endif
#if SQLITE_MAX_WORKER_THREADS>=SORTER_MAX_MERGE_COUNT
 if( nWorker>=SORTER_MAX_MERGE_COUNT ){  nWorker = SORTER_MAX_MERGE_COUNT-1;  }
#endif
 assert( pCsr->pKeyInfo && pCsr->pBtx==0 );  assert( pCsr->eCurType==CURTYPE_SORTER );  szKeyInfo = sizeof(KeyInfo) + (pCsr->pKeyInfo->nKeyField-1)*sizeof(CollSeq*);  sz = sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask);  pSorter = (VdbeSorter*)sqlite3DbMallocZero(db, sz + szKeyInfo);  pCsr->uc.pSorter = pSorter;  if( pSorter==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  Btree *pBt = db->aDb[0].pBt;  pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);  memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);  pKeyInfo->db = 0;  if( nField && nWorker==0 ){  pKeyInfo->nKeyField = nField;  }  sqlite3BtreeEnter(pBt);  pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(pBt);  sqlite3BtreeLeave(pBt);  pSorter->nTask = nWorker + 1;  pSorter->iPrev = (u8)(nWorker - 1);  pSorter->bUseThreads = (pSorter->nTask>1);  pSorter->db = db;  for(i=0; i<pSorter->nTask; i++){  SortSubtask *pTask = &pSorter->aTask[i];  pTask->pSorter = pSorter;  }  if( !sqlite3TempInMemory(db) ){  i64 mxCache;  u32 szPma = sqlite3GlobalConfig.szPma;  pSorter->mnPmaSize = szPma * pgsz;  mxCache = db->aDb[0].pSchema->cache_size;  if( mxCache<0 ){  mxCache = mxCache * -1024;  }else{  mxCache = mxCache * pgsz;  }  mxCache = MIN(mxCache, SQLITE_MAX_PMASZ);  pSorter->mxPmaSize = MAX(pSorter->mnPmaSize, (int)mxCache);  if( sqlite3GlobalConfig.bSmallMalloc==0 ){  assert( pSorter->iMemory==0 );  pSorter->nMemory = pgsz;  pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);  if( !pSorter->list.aMemory ) rc = SQLITE_NOMEM_BKPT;  }  }  if( pKeyInfo->nAllField<13   && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)   && (pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL)==0  ){  pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;  }  }  return rc; }
#undef nWorker
static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){  SorterRecord *p;  SorterRecord *pNext;  for(p=pRecord; p; p=pNext){  pNext = p->u.pNext;  sqlite3DbFree(db, p);  } } static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){  sqlite3DbFree(db, pTask->pUnpacked);
#if SQLITE_MAX_WORKER_THREADS>0
 if( pTask->list.aMemory ){  sqlite3_free(pTask->list.aMemory);  }else
#endif
 {  assert( pTask->list.aMemory==0 );  vdbeSorterRecordFree(0, pTask->list.pList);  }  if( pTask->file.pFd ){  sqlite3OsCloseFree(pTask->file.pFd);  }  if( pTask->file2.pFd ){  sqlite3OsCloseFree(pTask->file2.pFd);  }  memset(pTask, 0, sizeof(SortSubtask)); }
#ifdef SQLITE_DEBUG_SORTER_THREADS
static void vdbeSorterWorkDebug(SortSubtask *pTask, const char *zEvent){  i64 t;  int iTask = (pTask - pTask->pSorter->aTask);  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);  fprintf(stderr, "%lld:%d %s\n", t, iTask, zEvent); } static void vdbeSorterRewindDebug(const char *zEvent){  i64 t = 0;  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);  if( ALWAYS(pVfs) ) sqlite3OsCurrentTimeInt64(pVfs, &t);  fprintf(stderr, "%lld:X %s\n", t, zEvent); } static void vdbeSorterPopulateDebug(  SortSubtask *pTask,  const char *zEvent ){  i64 t;  int iTask = (pTask - pTask->pSorter->aTask);  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);  fprintf(stderr, "%lld:bg%d %s\n", t, iTask, zEvent); } static void vdbeSorterBlockDebug(  SortSubtask *pTask,  int bBlocked,  const char *zEvent ){  if( bBlocked ){  i64 t;  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);  fprintf(stderr, "%lld:main %s\n", t, zEvent);  } }
#else
# define vdbeSorterWorkDebug(x,y)
# define vdbeSorterRewindDebug(y)
# define vdbeSorterPopulateDebug(x,y)
# define vdbeSorterBlockDebug(x,y,z)
#endif
#if SQLITE_MAX_WORKER_THREADS>0
static int vdbeSorterJoinThread(SortSubtask *pTask){  int rc = SQLITE_OK;  if( pTask->pThread ){
#ifdef SQLITE_DEBUG_SORTER_THREADS
 int bDone = pTask->bDone;
#endif
 void *pRet = SQLITE_INT_TO_PTR(SQLITE_ERROR);  vdbeSorterBlockDebug(pTask, !bDone, "enter");  (void)sqlite3ThreadJoin(pTask->pThread, &pRet);  vdbeSorterBlockDebug(pTask, !bDone, "exit");  rc = SQLITE_PTR_TO_INT(pRet);  assert( pTask->bDone==1 );  pTask->bDone = 0;  pTask->pThread = 0;  }  return rc; } static int vdbeSorterCreateThread(  SortSubtask *pTask,  void *(*xTask)(void*),  void *pIn ){  assert( pTask->pThread==0 && pTask->bDone==0 );  return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn); } static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){  int rc = rcin;  int i;  for(i=pSorter->nTask-1; i>=0; i--){  SortSubtask *pTask = &pSorter->aTask[i];  int rc2 = vdbeSorterJoinThread(pTask);  if( rc==SQLITE_OK ) rc = rc2;  }  return rc; }
#else
# define vdbeSorterJoinAll(x,rcin) (rcin)
# define vdbeSorterJoinThread(pTask) SQLITE_OK
#endif
static MergeEngine *vdbeMergeEngineNew(int nReader){  int N = 2;  int nByte;  MergeEngine *pNew;  assert( nReader<=SORTER_MAX_MERGE_COUNT );  while( N<nReader ) N += N;  nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));  pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);  if( pNew ){  pNew->nTree = N;  pNew->pTask = 0;  pNew->aReadr = (PmaReader*)&pNew[1];  pNew->aTree = (int*)&pNew->aReadr[N];  }  return pNew; } static void vdbeMergeEngineFree(MergeEngine *pMerger){  int i;  if( pMerger ){  for(i=0; i<pMerger->nTree; i++){  vdbePmaReaderClear(&pMerger->aReadr[i]);  }  }  sqlite3_free(pMerger); } static void vdbeIncrFree(IncrMerger *pIncr){  if( pIncr ){
#if SQLITE_MAX_WORKER_THREADS>0
 if( pIncr->bUseThread ){  vdbeSorterJoinThread(pIncr->pTask);  if( pIncr->aFile[0].pFd ) sqlite3OsCloseFree(pIncr->aFile[0].pFd);  if( pIncr->aFile[1].pFd ) sqlite3OsCloseFree(pIncr->aFile[1].pFd);  }
#endif
 vdbeMergeEngineFree(pIncr->pMerger);  sqlite3_free(pIncr);  } } SQLITE_PRIVATE void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){  int i;  (void)vdbeSorterJoinAll(pSorter, SQLITE_OK);  assert( pSorter->bUseThreads || pSorter->pReader==0 );
#if SQLITE_MAX_WORKER_THREADS>0
 if( pSorter->pReader ){  vdbePmaReaderClear(pSorter->pReader);  sqlite3DbFree(db, pSorter->pReader);  pSorter->pReader = 0;  }
#endif
 vdbeMergeEngineFree(pSorter->pMerger);  pSorter->pMerger = 0;  for(i=0; i<pSorter->nTask; i++){  SortSubtask *pTask = &pSorter->aTask[i];  vdbeSortSubtaskCleanup(db, pTask);  pTask->pSorter = pSorter;  }  if( pSorter->list.aMemory==0 ){  vdbeSorterRecordFree(0, pSorter->list.pList);  }  pSorter->list.pList = 0;  pSorter->list.szPMA = 0;  pSorter->bUsePMA = 0;  pSorter->iMemory = 0;  pSorter->mxKeysize = 0;  sqlite3DbFree(db, pSorter->pUnpacked);  pSorter->pUnpacked = 0; } SQLITE_PRIVATE void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){  VdbeSorter *pSorter;  assert( pCsr->eCurType==CURTYPE_SORTER );  pSorter = pCsr->uc.pSorter;  if( pSorter ){  sqlite3VdbeSorterReset(db, pSorter);  sqlite3_free(pSorter->list.aMemory);  sqlite3DbFree(db, pSorter);  pCsr->uc.pSorter = 0;  } }
#if SQLITE_MAX_MMAP_SIZE>0
static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){  if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){  void *p = 0;  int chunksize = 4*1024;  sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_CHUNK_SIZE, &chunksize);  sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_SIZE_HINT, &nByte);  sqlite3OsFetch(pFd, 0, (int)nByte, &p);  if( p ) sqlite3OsUnfetch(pFd, 0, p);  } }
#else
# define vdbeSorterExtendFile(x,y,z)
#endif
static int vdbeSorterOpenTempFile(  sqlite3 *db,  i64 nExtend,  sqlite3_file **ppFd ){  int rc;  if( sqlite3FaultSim(202) ) return SQLITE_IOERR_ACCESS;  rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,  SQLITE_OPEN_TEMP_JOURNAL |  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |  SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE, &rc  );  if( rc==SQLITE_OK ){  i64 max = SQLITE_MAX_MMAP_SIZE;  sqlite3OsFileControlHint(*ppFd, SQLITE_FCNTL_MMAP_SIZE, (void*)&max);  if( nExtend>0 ){  vdbeSorterExtendFile(db, *ppFd, nExtend);  }  }  return rc; } static int vdbeSortAllocUnpacked(SortSubtask *pTask){  if( pTask->pUnpacked==0 ){  pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);  if( pTask->pUnpacked==0 ) return SQLITE_NOMEM_BKPT;  pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;  pTask->pUnpacked->errCode = 0;  }  return SQLITE_OK; } static SorterRecord *vdbeSorterMerge(  SortSubtask *pTask,  SorterRecord *p1,  SorterRecord *p2 ){  SorterRecord *pFinal = 0;  SorterRecord **pp = &pFinal;  int bCached = 0;  assert( p1!=0 && p2!=0 );  for(;;){  int res;  res = pTask->xCompare(  pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal  );  if( res<=0 ){  *pp = p1;  pp = &p1->u.pNext;  p1 = p1->u.pNext;  if( p1==0 ){  *pp = p2;  break;  }  }else{  *pp = p2;  pp = &p2->u.pNext;  p2 = p2->u.pNext;  bCached = 0;  if( p2==0 ){  *pp = p1;  break;  }  }  }  return pFinal; } static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){  if( p->typeMask==SORTER_TYPE_INTEGER ){  return vdbeSorterCompareInt;  }else if( p->typeMask==SORTER_TYPE_TEXT ){  return vdbeSorterCompareText;  }  return vdbeSorterCompare; } static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){  int i;  SorterRecord *p;  int rc;  SorterRecord *aSlot[64];  rc = vdbeSortAllocUnpacked(pTask);  if( rc!=SQLITE_OK ) return rc;  p = pList->pList;  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);  memset(aSlot, 0, sizeof(aSlot));  while( p ){  SorterRecord *pNext;  if( pList->aMemory ){  if( (u8*)p==pList->aMemory ){  pNext = 0;  }else{  assert( p->u.iNext<sqlite3MallocSize(pList->aMemory) );  pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];  }  }else{  pNext = p->u.pNext;  }  p->u.pNext = 0;  for(i=0; aSlot[i]; i++){  p = vdbeSorterMerge(pTask, p, aSlot[i]);  aSlot[i] = 0;  }  aSlot[i] = p;  p = pNext;  }  p = 0;  for(i=0; i<ArraySize(aSlot); i++){  if( aSlot[i]==0 ) continue;  p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];  }  pList->pList = p;  assert( pTask->pUnpacked->errCode==SQLITE_OK   || pTask->pUnpacked->errCode==SQLITE_NOMEM  );  return pTask->pUnpacked->errCode; } static void vdbePmaWriterInit(  sqlite3_file *pFd,  PmaWriter *p,  int nBuf,  i64 iStart ){  memset(p, 0, sizeof(PmaWriter));  p->aBuffer = (u8*)sqlite3Malloc(nBuf);  if( !p->aBuffer ){  p->eFWErr = SQLITE_NOMEM_BKPT;  }else{  p->iBufEnd = p->iBufStart = (iStart % nBuf);  p->iWriteOff = iStart - p->iBufStart;  p->nBuffer = nBuf;  p->pFd = pFd;  } } static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){  int nRem = nData;  while( nRem>0 && p->eFWErr==0 ){  int nCopy = nRem;  if( nCopy>(p->nBuffer - p->iBufEnd) ){  nCopy = p->nBuffer - p->iBufEnd;  }  memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);  p->iBufEnd += nCopy;  if( p->iBufEnd==p->nBuffer ){  p->eFWErr = sqlite3OsWrite(p->pFd,  &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,  p->iWriteOff + p->iBufStart  );  p->iBufStart = p->iBufEnd = 0;  p->iWriteOff += p->nBuffer;  }  assert( p->iBufEnd<p->nBuffer );  nRem -= nCopy;  } } static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof){  int rc;  if( p->eFWErr==0 && ALWAYS(p->aBuffer) && p->iBufEnd>p->iBufStart ){  p->eFWErr = sqlite3OsWrite(p->pFd,  &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,  p->iWriteOff + p->iBufStart  );  }  *piEof = (p->iWriteOff + p->iBufEnd);  sqlite3_free(p->aBuffer);  rc = p->eFWErr;  memset(p, 0, sizeof(PmaWriter));  return rc; } static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){  int nByte;  u8 aByte[10];  nByte = sqlite3PutVarint(aByte, iVal);  vdbePmaWriteBlob(p, aByte, nByte); } static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){  sqlite3 *db = pTask->pSorter->db;  int rc = SQLITE_OK;  PmaWriter writer;
#ifdef SQLITE_DEBUG
 i64 iSz = pList->szPMA + sqlite3VarintLen(pList->szPMA) + pTask->file.iEof;
#endif
 vdbeSorterWorkDebug(pTask, "enter");  memset(&writer, 0, sizeof(PmaWriter));  assert( pList->szPMA>0 );  if( pTask->file.pFd==0 ){  rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);  assert( rc!=SQLITE_OK || pTask->file.pFd );  assert( pTask->file.iEof==0 );  assert( pTask->nPMA==0 );  }  if( rc==SQLITE_OK ){  vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof+pList->szPMA+9);  }  if( rc==SQLITE_OK ){  rc = vdbeSorterSort(pTask, pList);  }  if( rc==SQLITE_OK ){  SorterRecord *p;  SorterRecord *pNext = 0;  vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,  pTask->file.iEof);  pTask->nPMA++;  vdbePmaWriteVarint(&writer, pList->szPMA);  for(p=pList->pList; p; p=pNext){  pNext = p->u.pNext;  vdbePmaWriteVarint(&writer, p->nVal);  vdbePmaWriteBlob(&writer, SRVAL(p), p->nVal);  if( pList->aMemory==0 ) sqlite3_free(p);  }  pList->pList = p;  rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof);  }  vdbeSorterWorkDebug(pTask, "exit");  assert( rc!=SQLITE_OK || pList->pList==0 );  assert( rc!=SQLITE_OK || pTask->file.iEof==iSz );  return rc; } static int vdbeMergeEngineStep(  MergeEngine *pMerger,  int *pbEof ){  int rc;  int iPrev = pMerger->aTree[1];  SortSubtask *pTask = pMerger->pTask;  rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);  if( rc==SQLITE_OK ){  int i;  PmaReader *pReadr1;  PmaReader *pReadr2;  int bCached = 0;  pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];  pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];  for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){  int iRes;  if( pReadr1->pFd==0 ){  iRes = +1;  }else if( pReadr2->pFd==0 ){  iRes = -1;  }else{  iRes = pTask->xCompare(pTask, &bCached,  pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey  );  }  if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){  pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);  pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];  bCached = 0;  }else{  if( pReadr1->pFd ) bCached = 0;  pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);  pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];  }  }  *pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);  }  return (rc==SQLITE_OK ? pTask->pUnpacked->errCode : rc); }
#if SQLITE_MAX_WORKER_THREADS>0
static void *vdbeSorterFlushThread(void *pCtx){  SortSubtask *pTask = (SortSubtask*)pCtx;  int rc;  assert( pTask->bDone==0 );  rc = vdbeSorterListToPMA(pTask, &pTask->list);  pTask->bDone = 1;  return SQLITE_INT_TO_PTR(rc); }
#endif
static int vdbeSorterFlushPMA(VdbeSorter *pSorter){
#if SQLITE_MAX_WORKER_THREADS==0
 pSorter->bUsePMA = 1;  return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);
#else
 int rc = SQLITE_OK;  int i;  SortSubtask *pTask = 0;  int nWorker = (pSorter->nTask-1);  pSorter->bUsePMA = 1;  for(i=0; i<nWorker; i++){  int iTest = (pSorter->iPrev + i + 1) % nWorker;  pTask = &pSorter->aTask[iTest];  if( pTask->bDone ){  rc = vdbeSorterJoinThread(pTask);  }  if( rc!=SQLITE_OK || pTask->pThread==0 ) break;  }  if( rc==SQLITE_OK ){  if( i==nWorker ){  rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);  }else{  u8 *aMem;  void *pCtx;  assert( pTask!=0 );  assert( pTask->pThread==0 && pTask->bDone==0 );  assert( pTask->list.pList==0 );  assert( pTask->list.aMemory==0 || pSorter->list.aMemory!=0 );  aMem = pTask->list.aMemory;  pCtx = (void*)pTask;  pSorter->iPrev = (u8)(pTask - pSorter->aTask);  pTask->list = pSorter->list;  pSorter->list.pList = 0;  pSorter->list.szPMA = 0;  if( aMem ){  pSorter->list.aMemory = aMem;  pSorter->nMemory = sqlite3MallocSize(aMem);  }else if( pSorter->list.aMemory ){  pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);  if( !pSorter->list.aMemory ) return SQLITE_NOMEM_BKPT;  }  rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);  }  }  return rc;
#endif
} SQLITE_PRIVATE int sqlite3VdbeSorterWrite(  const VdbeCursor *pCsr,  Mem *pVal ){  VdbeSorter *pSorter;  int rc = SQLITE_OK;  SorterRecord *pNew;  int bFlush;  int nReq;  int nPMA;  int t;  assert( pCsr->eCurType==CURTYPE_SORTER );  pSorter = pCsr->uc.pSorter;  getVarint32NR((const u8*)&pVal->z[1], t);  if( t>0 && t<10 && t!=7 ){  pSorter->typeMask &= SORTER_TYPE_INTEGER;  }else if( t>10 && (t & 0x01) ){  pSorter->typeMask &= SORTER_TYPE_TEXT;  }else{  pSorter->typeMask = 0;  }  assert( pSorter );  nReq = pVal->n + sizeof(SorterRecord);  nPMA = pVal->n + sqlite3VarintLen(pVal->n);  if( pSorter->mxPmaSize ){  if( pSorter->list.aMemory ){  bFlush = pSorter->iMemory && (pSorter->iMemory+nReq) > pSorter->mxPmaSize;  }else{  bFlush = (  (pSorter->list.szPMA > pSorter->mxPmaSize)   || (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())  );  }  if( bFlush ){  rc = vdbeSorterFlushPMA(pSorter);  pSorter->list.szPMA = 0;  pSorter->iMemory = 0;  assert( rc!=SQLITE_OK || pSorter->list.pList==0 );  }  }  pSorter->list.szPMA += nPMA;  if( nPMA>pSorter->mxKeysize ){  pSorter->mxKeysize = nPMA;  }  if( pSorter->list.aMemory ){  int nMin = pSorter->iMemory + nReq;  if( nMin>pSorter->nMemory ){  u8 *aNew;  sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;  int iListOff = -1;  if( pSorter->list.pList ){  iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;  }  while( nNew < nMin ) nNew = nNew*2;  if( nNew > pSorter->mxPmaSize ) nNew = pSorter->mxPmaSize;  if( nNew < nMin ) nNew = nMin;  aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);  if( !aNew ) return SQLITE_NOMEM_BKPT;  if( iListOff>=0 ){  pSorter->list.pList = (SorterRecord*)&aNew[iListOff];  }  pSorter->list.aMemory = aNew;  pSorter->nMemory = nNew;  }  pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];  pSorter->iMemory += ROUND8(nReq);  if( pSorter->list.pList ){  pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);  }  }else{  pNew = (SorterRecord *)sqlite3Malloc(nReq);  if( pNew==0 ){  return SQLITE_NOMEM_BKPT;  }  pNew->u.pNext = pSorter->list.pList;  }  memcpy(SRVAL(pNew), pVal->z, pVal->n);  pNew->nVal = pVal->n;  pSorter->list.pList = pNew;  return rc; } static int vdbeIncrPopulate(IncrMerger *pIncr){  int rc = SQLITE_OK;  int rc2;  i64 iStart = pIncr->iStartOff;  SorterFile *pOut = &pIncr->aFile[1];  SortSubtask *pTask = pIncr->pTask;  MergeEngine *pMerger = pIncr->pMerger;  PmaWriter writer;  assert( pIncr->bEof==0 );  vdbeSorterPopulateDebug(pTask, "enter");  vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);  while( rc==SQLITE_OK ){  int dummy;  PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];  int nKey = pReader->nKey;  i64 iEof = writer.iWriteOff + writer.iBufEnd;  if( pReader->pFd==0 ) break;  if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) break;  vdbePmaWriteVarint(&writer, nKey);  vdbePmaWriteBlob(&writer, pReader->aKey, nKey);  assert( pIncr->pMerger->pTask==pTask );  rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);  }  rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof);  if( rc==SQLITE_OK ) rc = rc2;  vdbeSorterPopulateDebug(pTask, "exit");  return rc; }
#if SQLITE_MAX_WORKER_THREADS>0
static void *vdbeIncrPopulateThread(void *pCtx){  IncrMerger *pIncr = (IncrMerger*)pCtx;  void *pRet = SQLITE_INT_TO_PTR( vdbeIncrPopulate(pIncr) );  pIncr->pTask->bDone = 1;  return pRet; } static int vdbeIncrBgPopulate(IncrMerger *pIncr){  void *p = (void*)pIncr;  assert( pIncr->bUseThread );  return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p); }
#endif
static int vdbeIncrSwap(IncrMerger *pIncr){  int rc = SQLITE_OK;
#if SQLITE_MAX_WORKER_THREADS>0
 if( pIncr->bUseThread ){  rc = vdbeSorterJoinThread(pIncr->pTask);  if( rc==SQLITE_OK ){  SorterFile f0 = pIncr->aFile[0];  pIncr->aFile[0] = pIncr->aFile[1];  pIncr->aFile[1] = f0;  }  if( rc==SQLITE_OK ){  if( pIncr->aFile[0].iEof==pIncr->iStartOff ){  pIncr->bEof = 1;  }else{  rc = vdbeIncrBgPopulate(pIncr);  }  }  }else
#endif
 {  rc = vdbeIncrPopulate(pIncr);  pIncr->aFile[0] = pIncr->aFile[1];  if( pIncr->aFile[0].iEof==pIncr->iStartOff ){  pIncr->bEof = 1;  }  }  return rc; } static int vdbeIncrMergerNew(  SortSubtask *pTask,  MergeEngine *pMerger,  IncrMerger **ppOut ){  int rc = SQLITE_OK;  IncrMerger *pIncr = *ppOut = (IncrMerger*)   (sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));  if( pIncr ){  pIncr->pMerger = pMerger;  pIncr->pTask = pTask;  pIncr->mxSz = MAX(pTask->pSorter->mxKeysize+9,pTask->pSorter->mxPmaSize/2);  pTask->file2.iEof += pIncr->mxSz;  }else{  vdbeMergeEngineFree(pMerger);  rc = SQLITE_NOMEM_BKPT;  }  assert( *ppOut!=0 || rc!=SQLITE_OK );  return rc; }
#if SQLITE_MAX_WORKER_THREADS>0
static void vdbeIncrMergerSetThreads(IncrMerger *pIncr){  pIncr->bUseThread = 1;  pIncr->pTask->file2.iEof -= pIncr->mxSz; }
#endif
static void vdbeMergeEngineCompare(  MergeEngine *pMerger,  int iOut ){  int i1;  int i2;  int iRes;  PmaReader *p1;  PmaReader *p2;  assert( iOut<pMerger->nTree && iOut>0 );  if( iOut>=(pMerger->nTree/2) ){  i1 = (iOut - pMerger->nTree/2) * 2;  i2 = i1 + 1;  }else{  i1 = pMerger->aTree[iOut*2];  i2 = pMerger->aTree[iOut*2+1];  }  p1 = &pMerger->aReadr[i1];  p2 = &pMerger->aReadr[i2];  if( p1->pFd==0 ){  iRes = i2;  }else if( p2->pFd==0 ){  iRes = i1;  }else{  SortSubtask *pTask = pMerger->pTask;  int bCached = 0;  int res;  assert( pTask->pUnpacked!=0 );  res = pTask->xCompare(  pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey  );  if( res<=0 ){  iRes = i1;  }else{  iRes = i2;  }  }  pMerger->aTree[iOut] = iRes; }
#define INCRINIT_NORMAL 0
#define INCRINIT_TASK  1
#define INCRINIT_ROOT  2
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode); static int vdbeMergeEngineInit(  SortSubtask *pTask,  MergeEngine *pMerger,  int eMode ){  int rc = SQLITE_OK;  int i;  int nTree;  assert( pMerger!=0 );  assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );  assert( pMerger->pTask==0 );  pMerger->pTask = pTask;  nTree = pMerger->nTree;  for(i=0; i<nTree; i++){  if( SQLITE_MAX_WORKER_THREADS>0 && eMode==INCRINIT_ROOT ){  rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);  }else{  rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);  }  if( rc!=SQLITE_OK ) return rc;  }  for(i=pMerger->nTree-1; i>0; i--){  vdbeMergeEngineCompare(pMerger, i);  }  return pTask->pUnpacked->errCode; } static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){  int rc = SQLITE_OK;  IncrMerger *pIncr = pReadr->pIncr;  SortSubtask *pTask = pIncr->pTask;  sqlite3 *db = pTask->pSorter->db;  assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);  if( rc==SQLITE_OK ){  int mxSz = pIncr->mxSz;
#if SQLITE_MAX_WORKER_THREADS>0
 if( pIncr->bUseThread ){  rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);  if( rc==SQLITE_OK ){  rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);  }  }else
#endif
{  if( pTask->file2.pFd==0 ){  assert( pTask->file2.iEof>0 );  rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);  pTask->file2.iEof = 0;  }  if( rc==SQLITE_OK ){  pIncr->aFile[1].pFd = pTask->file2.pFd;  pIncr->iStartOff = pTask->file2.iEof;  pTask->file2.iEof += mxSz;  }  }  }
#if SQLITE_MAX_WORKER_THREADS>0
 if( rc==SQLITE_OK && pIncr->bUseThread ){  assert( eMode==INCRINIT_ROOT || eMode==INCRINIT_TASK );  rc = vdbeIncrPopulate(pIncr);  }
#endif
 if( rc==SQLITE_OK && (SQLITE_MAX_WORKER_THREADS==0 || eMode!=INCRINIT_TASK) ){  rc = vdbePmaReaderNext(pReadr);  }  return rc; }
#if SQLITE_MAX_WORKER_THREADS>0
static void *vdbePmaReaderBgIncrInit(void *pCtx){  PmaReader *pReader = (PmaReader*)pCtx;  void *pRet = SQLITE_INT_TO_PTR(  vdbePmaReaderIncrMergeInit(pReader,INCRINIT_TASK)   );  pReader->pIncr->pTask->bDone = 1;  return pRet; }
#endif
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){  IncrMerger *pIncr = pReadr->pIncr;  int rc = SQLITE_OK;  if( pIncr ){
#if SQLITE_MAX_WORKER_THREADS>0
 assert( pIncr->bUseThread==0 || eMode==INCRINIT_TASK );  if( pIncr->bUseThread ){  void *pCtx = (void*)pReadr;  rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);  }else
#endif
 {  rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);  }  }  return rc; } static int vdbeMergeEngineLevel0(  SortSubtask *pTask,  int nPMA,  i64 *piOffset,  MergeEngine **ppOut ){  MergeEngine *pNew;  i64 iOff = *piOffset;  int i;  int rc = SQLITE_OK;  *ppOut = pNew = vdbeMergeEngineNew(nPMA);  if( pNew==0 ) rc = SQLITE_NOMEM_BKPT;  for(i=0; i<nPMA && rc==SQLITE_OK; i++){  i64 nDummy = 0;  PmaReader *pReadr = &pNew->aReadr[i];  rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);  iOff = pReadr->iEof;  }  if( rc!=SQLITE_OK ){  vdbeMergeEngineFree(pNew);  *ppOut = 0;  }  *piOffset = iOff;  return rc; } static int vdbeSorterTreeDepth(int nPMA){  int nDepth = 0;  i64 nDiv = SORTER_MAX_MERGE_COUNT;  while( nDiv < (i64)nPMA ){  nDiv = nDiv * SORTER_MAX_MERGE_COUNT;  nDepth++;  }  return nDepth; } static int vdbeSorterAddToTree(  SortSubtask *pTask,  int nDepth,  int iSeq,  MergeEngine *pRoot,  MergeEngine *pLeaf ){  int rc = SQLITE_OK;  int nDiv = 1;  int i;  MergeEngine *p = pRoot;  IncrMerger *pIncr;  rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);  for(i=1; i<nDepth; i++){  nDiv = nDiv * SORTER_MAX_MERGE_COUNT;  }  for(i=1; i<nDepth && rc==SQLITE_OK; i++){  int iIter = (iSeq / nDiv) % SORTER_MAX_MERGE_COUNT;  PmaReader *pReadr = &p->aReadr[iIter];  if( pReadr->pIncr==0 ){  MergeEngine *pNew = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);  if( pNew==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);  }  }  if( rc==SQLITE_OK ){  p = pReadr->pIncr->pMerger;  nDiv = nDiv / SORTER_MAX_MERGE_COUNT;  }  }  if( rc==SQLITE_OK ){  p->aReadr[iSeq % SORTER_MAX_MERGE_COUNT].pIncr = pIncr;  }else{  vdbeIncrFree(pIncr);  }  return rc; } static int vdbeSorterMergeTreeBuild(  VdbeSorter *pSorter,  MergeEngine **ppOut ){  MergeEngine *pMain = 0;  int rc = SQLITE_OK;  int iTask;
#if SQLITE_MAX_WORKER_THREADS>0
 assert( pSorter->bUseThreads || pSorter->nTask==1 );  if( pSorter->nTask>1 ){  pMain = vdbeMergeEngineNew(pSorter->nTask);  if( pMain==0 ) rc = SQLITE_NOMEM_BKPT;  }
#endif
 for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){  SortSubtask *pTask = &pSorter->aTask[iTask];  assert( pTask->nPMA>0 || SQLITE_MAX_WORKER_THREADS>0 );  if( SQLITE_MAX_WORKER_THREADS==0 || pTask->nPMA ){  MergeEngine *pRoot = 0;  int nDepth = vdbeSorterTreeDepth(pTask->nPMA);  i64 iReadOff = 0;  if( pTask->nPMA<=SORTER_MAX_MERGE_COUNT ){  rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);  }else{  int i;  int iSeq = 0;  pRoot = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);  if( pRoot==0 ) rc = SQLITE_NOMEM_BKPT;  for(i=0; i<pTask->nPMA && rc==SQLITE_OK; i += SORTER_MAX_MERGE_COUNT){  MergeEngine *pMerger = 0;  int nReader;  nReader = MIN(pTask->nPMA - i, SORTER_MAX_MERGE_COUNT);  rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);  if( rc==SQLITE_OK ){  rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);  }  }  }  if( rc==SQLITE_OK ){
#if SQLITE_MAX_WORKER_THREADS>0
 if( pMain!=0 ){  rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);  }else
#endif
 {  assert( pMain==0 );  pMain = pRoot;  }  }else{  vdbeMergeEngineFree(pRoot);  }  }  }  if( rc!=SQLITE_OK ){  vdbeMergeEngineFree(pMain);  pMain = 0;  }  *ppOut = pMain;  return rc; } static int vdbeSorterSetupMerge(VdbeSorter *pSorter){  int rc;  SortSubtask *pTask0 = &pSorter->aTask[0];  MergeEngine *pMain = 0;
#if SQLITE_MAX_WORKER_THREADS
 sqlite3 *db = pTask0->pSorter->db;  int i;  SorterCompare xCompare = vdbeSorterGetCompare(pSorter);  for(i=0; i<pSorter->nTask; i++){  pSorter->aTask[i].xCompare = xCompare;  }
#endif
 rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);  if( rc==SQLITE_OK ){
#if SQLITE_MAX_WORKER_THREADS
 assert( pSorter->bUseThreads==0 || pSorter->nTask>1 );  if( pSorter->bUseThreads ){  int iTask;  PmaReader *pReadr = 0;  SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];  rc = vdbeSortAllocUnpacked(pLast);  if( rc==SQLITE_OK ){  pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));  pSorter->pReader = pReadr;  if( pReadr==0 ) rc = SQLITE_NOMEM_BKPT;  }  if( rc==SQLITE_OK ){  rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);  if( rc==SQLITE_OK ){  vdbeIncrMergerSetThreads(pReadr->pIncr);  for(iTask=0; iTask<(pSorter->nTask-1); iTask++){  IncrMerger *pIncr;  if( (pIncr = pMain->aReadr[iTask].pIncr) ){  vdbeIncrMergerSetThreads(pIncr);  assert( pIncr->pTask!=pLast );  }  }  for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){  PmaReader *p = &pMain->aReadr[iTask];  assert( p->pIncr==0 || (  (p->pIncr->pTask==&pSorter->aTask[iTask])   && (iTask!=pSorter->nTask-1 || p->pIncr->bUseThread==0)  ));  rc = vdbePmaReaderIncrInit(p, INCRINIT_TASK);  }  }  pMain = 0;  }  if( rc==SQLITE_OK ){  rc = vdbePmaReaderIncrMergeInit(pReadr, INCRINIT_ROOT);  }  }else
#endif
 {  rc = vdbeMergeEngineInit(pTask0, pMain, INCRINIT_NORMAL);  pSorter->pMerger = pMain;  pMain = 0;  }  }  if( rc!=SQLITE_OK ){  vdbeMergeEngineFree(pMain);  }  return rc; } SQLITE_PRIVATE int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){  VdbeSorter *pSorter;  int rc = SQLITE_OK;  assert( pCsr->eCurType==CURTYPE_SORTER );  pSorter = pCsr->uc.pSorter;  assert( pSorter );  if( pSorter->bUsePMA==0 ){  if( pSorter->list.pList ){  *pbEof = 0;  rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);  }else{  *pbEof = 1;  }  return rc;  }  assert( pSorter->list.pList );  rc = vdbeSorterFlushPMA(pSorter);  rc = vdbeSorterJoinAll(pSorter, rc);  vdbeSorterRewindDebug("rewind");  assert( pSorter->pReader==0 );  if( rc==SQLITE_OK ){  rc = vdbeSorterSetupMerge(pSorter);  *pbEof = 0;  }  vdbeSorterRewindDebug("rewinddone");  return rc; } SQLITE_PRIVATE int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){  VdbeSorter *pSorter;  int rc;  assert( pCsr->eCurType==CURTYPE_SORTER );  pSorter = pCsr->uc.pSorter;  assert( pSorter->bUsePMA || (pSorter->pReader==0 && pSorter->pMerger==0) );  if( pSorter->bUsePMA ){  assert( pSorter->pReader==0 || pSorter->pMerger==0 );  assert( pSorter->bUseThreads==0 || pSorter->pReader );  assert( pSorter->bUseThreads==1 || pSorter->pMerger );
#if SQLITE_MAX_WORKER_THREADS>0
 if( pSorter->bUseThreads ){  rc = vdbePmaReaderNext(pSorter->pReader);  if( rc==SQLITE_OK && pSorter->pReader->pFd==0 ) rc = SQLITE_DONE;  }else
#endif
 {  int res = 0;  assert( pSorter->pMerger!=0 );  assert( pSorter->pMerger->pTask==(&pSorter->aTask[0]) );  rc = vdbeMergeEngineStep(pSorter->pMerger, &res);  if( rc==SQLITE_OK && res ) rc = SQLITE_DONE;  }  }else{  SorterRecord *pFree = pSorter->list.pList;  pSorter->list.pList = pFree->u.pNext;  pFree->u.pNext = 0;  if( pSorter->list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);  rc = pSorter->list.pList ? SQLITE_OK : SQLITE_DONE;  }  return rc; } static void *vdbeSorterRowkey(  const VdbeSorter *pSorter,  int *pnKey ){  void *pKey;  if( pSorter->bUsePMA ){  PmaReader *pReader;
#if SQLITE_MAX_WORKER_THREADS>0
 if( pSorter->bUseThreads ){  pReader = pSorter->pReader;  }else
#endif
{  pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];  }  *pnKey = pReader->nKey;  pKey = pReader->aKey;  }else{  *pnKey = pSorter->list.pList->nVal;  pKey = SRVAL(pSorter->list.pList);  }  return pKey; } SQLITE_PRIVATE int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){  VdbeSorter *pSorter;  void *pKey; int nKey;  assert( pCsr->eCurType==CURTYPE_SORTER );  pSorter = pCsr->uc.pSorter;  pKey = vdbeSorterRowkey(pSorter, &nKey);  if( sqlite3VdbeMemClearAndResize(pOut, nKey) ){  return SQLITE_NOMEM_BKPT;  }  pOut->n = nKey;  MemSetTypeFlag(pOut, MEM_Blob);  memcpy(pOut->z, pKey, nKey);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VdbeSorterCompare(  const VdbeCursor *pCsr,  Mem *pVal,  int nKeyCol,  int *pRes ){  VdbeSorter *pSorter;  UnpackedRecord *r2;  KeyInfo *pKeyInfo;  int i;  void *pKey; int nKey;  assert( pCsr->eCurType==CURTYPE_SORTER );  pSorter = pCsr->uc.pSorter;  r2 = pSorter->pUnpacked;  pKeyInfo = pCsr->pKeyInfo;  if( r2==0 ){  r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);  if( r2==0 ) return SQLITE_NOMEM_BKPT;  r2->nField = nKeyCol;  }  assert( r2->nField==nKeyCol );  pKey = vdbeSorterRowkey(pSorter, &nKey);  sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, r2);  for(i=0; i<nKeyCol; i++){  if( r2->aMem[i].flags & MEM_Null ){  *pRes = -1;  return SQLITE_OK;  }  }  *pRes = sqlite3VdbeRecordCompare(pVal->n, pVal->z, r2);  return SQLITE_OK; }
#if defined(SQLITE_ENABLE_BYTECODE_VTAB) && !defined(SQLITE_OMIT_VIRTUALTABLE)
typedef struct bytecodevtab bytecodevtab; struct bytecodevtab {  sqlite3_vtab base;  sqlite3 *db;  int bTablesUsed; }; typedef struct bytecodevtab_cursor bytecodevtab_cursor; struct bytecodevtab_cursor {  sqlite3_vtab_cursor base;  sqlite3_stmt *pStmt;  int iRowid;  int iAddr;  int needFinalize;  int showSubprograms;  Op *aOp;  char *zP4;  const char *zType;  const char *zSchema;  const char *zName;  Mem sub; }; static int bytecodevtabConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  bytecodevtab *pNew;  int rc;  int isTabUsed = pAux!=0;  const char *azSchema[2] = {  "CREATE TABLE x("  "addr INT,"  "opcode TEXT,"  "p1 INT,"  "p2 INT,"  "p3 INT,"  "p4 TEXT,"  "p5 INT,"  "comment TEXT,"  "subprog TEXT,"  "stmt HIDDEN"  ");",  "CREATE TABLE x("  "type TEXT,"  "schema TEXT,"  "name TEXT,"  "wr INT,"  "subprog TEXT,"  "stmt HIDDEN"   ");"  };  rc = sqlite3_declare_vtab(db, azSchema[isTabUsed]);  if( rc==SQLITE_OK ){  pNew = sqlite3_malloc( sizeof(*pNew) );  *ppVtab = (sqlite3_vtab*)pNew;  if( pNew==0 ) return SQLITE_NOMEM;  memset(pNew, 0, sizeof(*pNew));  pNew->db = db;  pNew->bTablesUsed = isTabUsed*2;  }  return rc; } static int bytecodevtabDisconnect(sqlite3_vtab *pVtab){  bytecodevtab *p = (bytecodevtab*)pVtab;  sqlite3_free(p);  return SQLITE_OK; } static int bytecodevtabOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){  bytecodevtab *pVTab = (bytecodevtab*)p;  bytecodevtab_cursor *pCur;  pCur = sqlite3_malloc( sizeof(*pCur) );  if( pCur==0 ) return SQLITE_NOMEM;  memset(pCur, 0, sizeof(*pCur));  sqlite3VdbeMemInit(&pCur->sub, pVTab->db, 1);  *ppCursor = &pCur->base;  return SQLITE_OK; } static void bytecodevtabCursorClear(bytecodevtab_cursor *pCur){  sqlite3_free(pCur->zP4);  pCur->zP4 = 0;  sqlite3VdbeMemRelease(&pCur->sub);  sqlite3VdbeMemSetNull(&pCur->sub);  if( pCur->needFinalize ){  sqlite3_finalize(pCur->pStmt);  }  pCur->pStmt = 0;  pCur->needFinalize = 0;  pCur->zType = 0;  pCur->zSchema = 0;  pCur->zName = 0; } static int bytecodevtabClose(sqlite3_vtab_cursor *cur){  bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;  bytecodevtabCursorClear(pCur);  sqlite3_free(pCur);  return SQLITE_OK; } static int bytecodevtabNext(sqlite3_vtab_cursor *cur){  bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;  bytecodevtab *pTab = (bytecodevtab*)cur->pVtab;  int rc;  if( pCur->zP4 ){  sqlite3_free(pCur->zP4);  pCur->zP4 = 0;  }  if( pCur->zName ){  pCur->zName = 0;  pCur->zType = 0;  pCur->zSchema = 0;  }  rc = sqlite3VdbeNextOpcode(   (Vdbe*)pCur->pStmt,   pCur->showSubprograms ? &pCur->sub : 0,   pTab->bTablesUsed,   &pCur->iRowid,   &pCur->iAddr,   &pCur->aOp);  if( rc!=SQLITE_OK ){  sqlite3VdbeMemSetNull(&pCur->sub);  pCur->aOp = 0;  }  return SQLITE_OK; } static int bytecodevtabEof(sqlite3_vtab_cursor *cur){  bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;  return pCur->aOp==0; } static int bytecodevtabColumn(  sqlite3_vtab_cursor *cur,  sqlite3_context *ctx,  int i ){  bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;  bytecodevtab *pVTab = (bytecodevtab*)cur->pVtab;  Op *pOp = pCur->aOp + pCur->iAddr;  if( pVTab->bTablesUsed ){  if( i==4 ){  i = 8;  }else{  if( i<=2 && pCur->zType==0 ){  Schema *pSchema;  HashElem *k;  int iDb = pOp->p3;  Pgno iRoot = (Pgno)pOp->p2;  sqlite3 *db = pVTab->db;  pSchema = db->aDb[iDb].pSchema;  pCur->zSchema = db->aDb[iDb].zDbSName;  for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){  Table *pTab = (Table*)sqliteHashData(k);  if( !IsVirtual(pTab) && pTab->tnum==iRoot ){  pCur->zName = pTab->zName;  pCur->zType = "table";  break;  }  }  if( pCur->zName==0 ){  for(k=sqliteHashFirst(&pSchema->idxHash); k; k=sqliteHashNext(k)){  Index *pIdx = (Index*)sqliteHashData(k);  if( pIdx->tnum==iRoot ){  pCur->zName = pIdx->zName;  pCur->zType = "index";  }  }  }  }  i += 10;  }  }  switch( i ){  case 0:  sqlite3_result_int(ctx, pCur->iAddr);  break;  case 1:  sqlite3_result_text(ctx, (char*)sqlite3OpcodeName(pOp->opcode),  -1, SQLITE_STATIC);  break;  case 2:  sqlite3_result_int(ctx, pOp->p1);  break;  case 3:  sqlite3_result_int(ctx, pOp->p2);  break;  case 4:  sqlite3_result_int(ctx, pOp->p3);  break;  case 5:  case 7:  if( pCur->zP4==0 ){  pCur->zP4 = sqlite3VdbeDisplayP4(pVTab->db, pOp);  }  if( i==5 ){  sqlite3_result_text(ctx, pCur->zP4, -1, SQLITE_STATIC);  }else{
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 char *zCom = sqlite3VdbeDisplayComment(pVTab->db, pOp, pCur->zP4);  sqlite3_result_text(ctx, zCom, -1, sqlite3_free);
#endif
 }  break;  case 6:  sqlite3_result_int(ctx, pOp->p5);  break;  case 8: {  Op *aOp = pCur->aOp;  assert( aOp[0].opcode==OP_Init );  assert( aOp[0].p4.z==0 || strncmp(aOp[0].p4.z,"-" "- ",3)==0 );  if( pCur->iRowid==pCur->iAddr+1 ){  break;  }else if( aOp[0].p4.z!=0 ){   sqlite3_result_text(ctx, aOp[0].p4.z+3, -1, SQLITE_STATIC);  }else{   sqlite3_result_text(ctx, "(FK)", 4, SQLITE_STATIC);  }  break;  }  case 10:  sqlite3_result_text(ctx, pCur->zType, -1, SQLITE_STATIC);  break;  case 11:  sqlite3_result_text(ctx, pCur->zSchema, -1, SQLITE_STATIC);  break;  case 12:  sqlite3_result_text(ctx, pCur->zName, -1, SQLITE_STATIC);  break;  case 13:  sqlite3_result_int(ctx, pOp->opcode==OP_OpenWrite);  break;  }  return SQLITE_OK; } static int bytecodevtabRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){  bytecodevtab_cursor *pCur = (bytecodevtab_cursor*)cur;  *pRowid = pCur->iRowid;  return SQLITE_OK; } static int bytecodevtabFilter(  sqlite3_vtab_cursor *pVtabCursor,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  bytecodevtab_cursor *pCur = (bytecodevtab_cursor *)pVtabCursor;  bytecodevtab *pVTab = (bytecodevtab *)pVtabCursor->pVtab;  int rc = SQLITE_OK;  bytecodevtabCursorClear(pCur);  pCur->iRowid = 0;  pCur->iAddr = 0;  pCur->showSubprograms = idxNum==0;  assert( argc==1 );  if( sqlite3_value_type(argv[0])==SQLITE_TEXT ){  const char *zSql = (const char*)sqlite3_value_text(argv[0]);  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v2(pVTab->db, zSql, -1, &pCur->pStmt, 0);  pCur->needFinalize = 1;  }  }else{  pCur->pStmt = (sqlite3_stmt*)sqlite3_value_pointer(argv[0],"stmt-pointer");  }  if( pCur->pStmt==0 ){  pVTab->base.zErrMsg = sqlite3_mprintf(   "argument to %s() is not a valid SQL statement",   pVTab->bTablesUsed ? "tables_used" : "bytecode"  );  rc = SQLITE_ERROR;  }else{  bytecodevtabNext(pVtabCursor);  }  return rc; } static int bytecodevtabBestIndex(  sqlite3_vtab *tab,  sqlite3_index_info *pIdxInfo ){  int i;  int rc = SQLITE_CONSTRAINT;  struct sqlite3_index_constraint *p;  bytecodevtab *pVTab = (bytecodevtab*)tab;  int iBaseCol = pVTab->bTablesUsed ? 4 : 8;  pIdxInfo->estimatedCost = (double)100;  pIdxInfo->estimatedRows = 100;  pIdxInfo->idxNum = 0;  for(i=0, p=pIdxInfo->aConstraint; i<pIdxInfo->nConstraint; i++, p++){  if( p->usable==0 ) continue;  if( p->op==SQLITE_INDEX_CONSTRAINT_EQ && p->iColumn==iBaseCol+1 ){  rc = SQLITE_OK;  pIdxInfo->aConstraintUsage[i].omit = 1;  pIdxInfo->aConstraintUsage[i].argvIndex = 1;  }  if( p->op==SQLITE_INDEX_CONSTRAINT_ISNULL && p->iColumn==iBaseCol ){  pIdxInfo->aConstraintUsage[i].omit = 1;  pIdxInfo->idxNum = 1;  }  }  return rc; } static sqlite3_module bytecodevtabModule = {  0,  0,  bytecodevtabConnect,  bytecodevtabBestIndex,  bytecodevtabDisconnect,  0,  bytecodevtabOpen,  bytecodevtabClose,  bytecodevtabFilter,  bytecodevtabNext,  bytecodevtabEof,  bytecodevtabColumn,  bytecodevtabRowid,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }; SQLITE_PRIVATE int sqlite3VdbeBytecodeVtabInit(sqlite3 *db){  int rc;  rc = sqlite3_create_module(db, "bytecode", &bytecodevtabModule, 0);  if( rc==SQLITE_OK ){  rc = sqlite3_create_module(db, "tables_used", &bytecodevtabModule, &db);  }  return rc; }
#elif defined(SQLITE_ENABLE_BYTECODE_VTAB)
SQLITE_PRIVATE int sqlite3VdbeBytecodeVtabInit(sqlite3 *db){ return SQLITE_OK; }
#endif
typedef struct MemJournal MemJournal; typedef struct FilePoint FilePoint; typedef struct FileChunk FileChunk; struct FileChunk {  FileChunk *pNext;  u8 zChunk[8]; };
#define MEMJOURNAL_DFLT_FILECHUNKSIZE 1024
#define fileChunkSize(nChunkSize) (sizeof(FileChunk) + ((nChunkSize)-8))
struct FilePoint {  sqlite3_int64 iOffset;  FileChunk *pChunk; }; struct MemJournal {  const sqlite3_io_methods *pMethod;  int nChunkSize;  int nSpill;  FileChunk *pFirst;  FilePoint endpoint;  FilePoint readpoint;  int flags;  sqlite3_vfs *pVfs;  const char *zJournal; }; static int memjrnlRead(  sqlite3_file *pJfd,  void *zBuf,  int iAmt,  sqlite_int64 iOfst ){  MemJournal *p = (MemJournal *)pJfd;  u8 *zOut = zBuf;  int nRead = iAmt;  int iChunkOffset;  FileChunk *pChunk;  if( (iAmt+iOfst)>p->endpoint.iOffset ){  return SQLITE_IOERR_SHORT_READ;  }  assert( p->readpoint.iOffset==0 || p->readpoint.pChunk!=0 );  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){  sqlite3_int64 iOff = 0;  for(pChunk=p->pFirst;  ALWAYS(pChunk) && (iOff+p->nChunkSize)<=iOfst;  pChunk=pChunk->pNext  ){  iOff += p->nChunkSize;  }  }else{  pChunk = p->readpoint.pChunk;  assert( pChunk!=0 );  }  iChunkOffset = (int)(iOfst%p->nChunkSize);  do {  int iSpace = p->nChunkSize - iChunkOffset;  int nCopy = MIN(nRead, (p->nChunkSize - iChunkOffset));  memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);  zOut += nCopy;  nRead -= iSpace;  iChunkOffset = 0;  } while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );  p->readpoint.iOffset = pChunk ? iOfst+iAmt : 0;  p->readpoint.pChunk = pChunk;  return SQLITE_OK; } static void memjrnlFreeChunks(FileChunk *pFirst){  FileChunk *pIter;  FileChunk *pNext;  for(pIter=pFirst; pIter; pIter=pNext){  pNext = pIter->pNext;  sqlite3_free(pIter);  } } static int memjrnlCreateFile(MemJournal *p){  int rc;  sqlite3_file *pReal = (sqlite3_file*)p;  MemJournal copy = *p;  memset(p, 0, sizeof(MemJournal));  rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);  if( rc==SQLITE_OK ){  int nChunk = copy.nChunkSize;  i64 iOff = 0;  FileChunk *pIter;  for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){  if( iOff + nChunk > copy.endpoint.iOffset ){  nChunk = copy.endpoint.iOffset - iOff;  }  rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);  if( rc ) break;  iOff += nChunk;  }  if( rc==SQLITE_OK ){  memjrnlFreeChunks(copy.pFirst);  }  }  if( rc!=SQLITE_OK ){  sqlite3OsClose(pReal);  *p = copy;  }  return rc; } static int memjrnlWrite(  sqlite3_file *pJfd,  const void *zBuf,  int iAmt,  sqlite_int64 iOfst ){  MemJournal *p = (MemJournal *)pJfd;  int nWrite = iAmt;  u8 *zWrite = (u8 *)zBuf;  if( p->nSpill>0 && (iAmt+iOfst)>p->nSpill ){  int rc = memjrnlCreateFile(p);  if( rc==SQLITE_OK ){  rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);  }  return rc;  }  else{  assert( iOfst==p->endpoint.iOffset || iOfst==0 );
#if defined(SQLITE_ENABLE_ATOMIC_WRITE)  || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)

 if( iOfst==0 && p->pFirst ){  assert( p->nChunkSize>iAmt );  memcpy((u8*)p->pFirst->zChunk, zBuf, iAmt);  }else
#else
 assert( iOfst>0 || p->pFirst==0 );
#endif
 {  while( nWrite>0 ){  FileChunk *pChunk = p->endpoint.pChunk;  int iChunkOffset = (int)(p->endpoint.iOffset%p->nChunkSize);  int iSpace = MIN(nWrite, p->nChunkSize - iChunkOffset);  if( iChunkOffset==0 ){  FileChunk *pNew = sqlite3_malloc(fileChunkSize(p->nChunkSize));  if( !pNew ){  return SQLITE_IOERR_NOMEM_BKPT;  }  pNew->pNext = 0;  if( pChunk ){  assert( p->pFirst );  pChunk->pNext = pNew;  }else{  assert( !p->pFirst );  p->pFirst = pNew;  }  p->endpoint.pChunk = pNew;  }  memcpy((u8*)p->endpoint.pChunk->zChunk + iChunkOffset, zWrite, iSpace);  zWrite += iSpace;  nWrite -= iSpace;  p->endpoint.iOffset += iSpace;  }  }  }  return SQLITE_OK; } static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){  MemJournal *p = (MemJournal *)pJfd;  assert( p->endpoint.pChunk==0 || p->endpoint.pChunk->pNext==0 );  if( size<p->endpoint.iOffset ){  FileChunk *pIter = 0;  if( size==0 ){  memjrnlFreeChunks(p->pFirst);  p->pFirst = 0;  }else{  i64 iOff = p->nChunkSize;  for(pIter=p->pFirst; ALWAYS(pIter) && iOff<size; pIter=pIter->pNext){  iOff += p->nChunkSize;  }  if( ALWAYS(pIter) ){  memjrnlFreeChunks(pIter->pNext);  pIter->pNext = 0;  }  }  p->endpoint.pChunk = pIter;  p->endpoint.iOffset = size;  p->readpoint.pChunk = 0;  p->readpoint.iOffset = 0;  }  return SQLITE_OK; } static int memjrnlClose(sqlite3_file *pJfd){  MemJournal *p = (MemJournal *)pJfd;  memjrnlFreeChunks(p->pFirst);  return SQLITE_OK; } static int memjrnlSync(sqlite3_file *pJfd, int flags){  UNUSED_PARAMETER2(pJfd, flags);  return SQLITE_OK; } static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){  MemJournal *p = (MemJournal *)pJfd;  *pSize = (sqlite_int64) p->endpoint.iOffset;  return SQLITE_OK; } static const struct sqlite3_io_methods MemJournalMethods = {  1,  memjrnlClose,  memjrnlRead,  memjrnlWrite,  memjrnlTruncate,  memjrnlSync,  memjrnlFileSize,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }; SQLITE_PRIVATE int sqlite3JournalOpen(  sqlite3_vfs *pVfs,  const char *zName,  sqlite3_file *pJfd,  int flags,  int nSpill ){  MemJournal *p = (MemJournal*)pJfd;  memset(p, 0, sizeof(MemJournal));  if( nSpill==0 ){  return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);  }  if( nSpill>0 ){  p->nChunkSize = nSpill;  }else{  p->nChunkSize = 8 + MEMJOURNAL_DFLT_FILECHUNKSIZE - sizeof(FileChunk);  assert( MEMJOURNAL_DFLT_FILECHUNKSIZE==fileChunkSize(p->nChunkSize) );  }  pJfd->pMethods = (const sqlite3_io_methods*)&MemJournalMethods;  p->nSpill = nSpill;  p->flags = flags;  p->zJournal = zName;  p->pVfs = pVfs;  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *pJfd){  sqlite3JournalOpen(0, 0, pJfd, 0, -1); }
#if defined(SQLITE_ENABLE_ATOMIC_WRITE)  || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)

SQLITE_PRIVATE int sqlite3JournalCreate(sqlite3_file *pJfd){  int rc = SQLITE_OK;  MemJournal *p = (MemJournal*)pJfd;  if( pJfd->pMethods==&MemJournalMethods && (
#ifdef SQLITE_ENABLE_ATOMIC_WRITE
  p->nSpill>0
#else
  NEVER(p->nSpill>0)
#endif
#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
  || (p->flags & SQLITE_OPEN_MAIN_JOURNAL)
#endif
 )){  rc = memjrnlCreateFile(p);  }  return rc; }
#endif
SQLITE_PRIVATE int sqlite3JournalIsInMemory(sqlite3_file *p){  return p->pMethods==&MemJournalMethods; } SQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *pVfs){  return MAX(pVfs->szOsFile, (int)sizeof(MemJournal)); }
#if !defined(SQLITE_OMIT_WINDOWFUNC)
static int walkWindowList(Walker *pWalker, Window *pList, int bOneOnly){  Window *pWin;  for(pWin=pList; pWin; pWin=pWin->pNextWin){  int rc;  rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);  if( rc ) return WRC_Abort;  rc = sqlite3WalkExprList(pWalker, pWin->pPartition);  if( rc ) return WRC_Abort;  rc = sqlite3WalkExpr(pWalker, pWin->pFilter);  if( rc ) return WRC_Abort;  rc = sqlite3WalkExpr(pWalker, pWin->pStart);  if( rc ) return WRC_Abort;  rc = sqlite3WalkExpr(pWalker, pWin->pEnd);  if( rc ) return WRC_Abort;  if( bOneOnly ) break;  }  return WRC_Continue; }
#endif
static SQLITE_NOINLINE int walkExpr(Walker *pWalker, Expr *pExpr){  int rc;  testcase( ExprHasProperty(pExpr, EP_TokenOnly) );  testcase( ExprHasProperty(pExpr, EP_Reduced) );  while(1){  rc = pWalker->xExprCallback(pWalker, pExpr);  if( rc ) return rc & WRC_Abort;  if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){  assert( pExpr->x.pList==0 || pExpr->pRight==0 );  if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;  if( pExpr->pRight ){  assert( !ExprHasProperty(pExpr, EP_WinFunc) );  pExpr = pExpr->pRight;  continue;  }else if( ExprUseXSelect(pExpr) ){  assert( !ExprHasProperty(pExpr, EP_WinFunc) );  if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;  }else{  if( pExpr->x.pList ){  if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(pExpr, EP_WinFunc) ){  if( walkWindowList(pWalker, pExpr->y.pWin, 1) ) return WRC_Abort;  }
#endif
 }  }  break;  }  return WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){  return pExpr ? walkExpr(pWalker,pExpr) : WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkExprList(Walker *pWalker, ExprList *p){  int i;  struct ExprList_item *pItem;  if( p ){  for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){  if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return WRC_Abort;  }  }  return WRC_Continue; } SQLITE_PRIVATE void sqlite3WalkWinDefnDummyCallback(Walker *pWalker, Select *p){  UNUSED_PARAMETER(pWalker);  UNUSED_PARAMETER(p); } SQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){  if( sqlite3WalkExprList(pWalker, p->pEList) ) return WRC_Abort;  if( sqlite3WalkExpr(pWalker, p->pWhere) ) return WRC_Abort;  if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) return WRC_Abort;  if( sqlite3WalkExpr(pWalker, p->pHaving) ) return WRC_Abort;  if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) return WRC_Abort;  if( sqlite3WalkExpr(pWalker, p->pLimit) ) return WRC_Abort;
#if !defined(SQLITE_OMIT_WINDOWFUNC)
 if( p->pWinDefn ){  Parse *pParse;  if( pWalker->xSelectCallback2==sqlite3WalkWinDefnDummyCallback   || ((pParse = pWalker->pParse)!=0 && IN_RENAME_OBJECT)
#ifndef SQLITE_OMIT_CTE
  || pWalker->xSelectCallback2==sqlite3SelectPopWith
#endif
 ){  int rc = walkWindowList(pWalker, p->pWinDefn, 0);  return rc;  }  }
#endif
 return WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){  SrcList *pSrc;  int i;  SrcItem *pItem;  pSrc = p->pSrc;  if( ALWAYS(pSrc) ){  for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){  if( pItem->pSelect && sqlite3WalkSelect(pWalker, pItem->pSelect) ){  return WRC_Abort;  }  if( pItem->fg.isTabFunc   && sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg)  ){  return WRC_Abort;  }  }  }  return WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkSelect(Walker *pWalker, Select *p){  int rc;  if( p==0 ) return WRC_Continue;  if( pWalker->xSelectCallback==0 ) return WRC_Continue;  do{  rc = pWalker->xSelectCallback(pWalker, p);  if( rc ) return rc & WRC_Abort;  if( sqlite3WalkSelectExpr(pWalker, p)   || sqlite3WalkSelectFrom(pWalker, p)  ){  return WRC_Abort;  }  if( pWalker->xSelectCallback2 ){  pWalker->xSelectCallback2(pWalker, p);  }  p = p->pPrior;  }while( p!=0 );  return WRC_Continue; } SQLITE_PRIVATE int sqlite3WalkerDepthIncrease(Walker *pWalker, Select *pSelect){  UNUSED_PARAMETER(pSelect);  pWalker->walkerDepth++;  return WRC_Continue; } SQLITE_PRIVATE void sqlite3WalkerDepthDecrease(Walker *pWalker, Select *pSelect){  UNUSED_PARAMETER(pSelect);  pWalker->walkerDepth--; } SQLITE_PRIVATE int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  return WRC_Continue; } SQLITE_PRIVATE int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  return WRC_Continue; }
#define EXCLUDED_TABLE_NUMBER 2
static int incrAggDepth(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_AGG_FUNCTION ) pExpr->op2 += pWalker->u.n;  return WRC_Continue; } static void incrAggFunctionDepth(Expr *pExpr, int N){  if( N>0 ){  Walker w;  memset(&w, 0, sizeof(w));  w.xExprCallback = incrAggDepth;  w.u.n = N;  sqlite3WalkExpr(&w, pExpr);  } } static void resolveAlias(  Parse *pParse,  ExprList *pEList,  int iCol,  Expr *pExpr,  int nSubquery ){  Expr *pOrig;  Expr *pDup;  sqlite3 *db;  assert( iCol>=0 && iCol<pEList->nExpr );  pOrig = pEList->a[iCol].pExpr;  assert( pOrig!=0 );  db = pParse->db;  pDup = sqlite3ExprDup(db, pOrig, 0);  if( db->mallocFailed ){  sqlite3ExprDelete(db, pDup);  pDup = 0;  }else{  incrAggFunctionDepth(pDup, nSubquery);  if( pExpr->op==TK_COLLATE ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);  }  ExprSetProperty(pExpr, EP_Static);  sqlite3ExprDelete(db, pExpr);  memcpy(pExpr, pDup, sizeof(*pExpr));  if( !ExprHasProperty(pExpr, EP_IntValue) && pExpr->u.zToken!=0 ){  assert( (pExpr->flags & (EP_Reduced|EP_TokenOnly))==0 );  pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken);  pExpr->flags |= EP_MemToken;  }  if( ExprHasProperty(pExpr, EP_WinFunc) ){  if( ALWAYS(pExpr->y.pWin!=0) ){  pExpr->y.pWin->pOwner = pExpr;  }  }  sqlite3DbFree(db, pDup);  } } static int nameInUsingClause(IdList *pUsing, const char *zCol){  if( pUsing ){  int k;  for(k=0; k<pUsing->nId; k++){  if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ) return 1;  }  }  return 0; } SQLITE_PRIVATE int sqlite3MatchEName(  const struct ExprList_item *pItem,  const char *zCol,  const char *zTab,  const char *zDb ){  int n;  const char *zSpan;  if( pItem->eEName!=ENAME_TAB ) return 0;  zSpan = pItem->zEName;  for(n=0; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){}  if( zDb && (sqlite3StrNICmp(zSpan, zDb, n)!=0 || zDb[n]!=0) ){  return 0;  }  zSpan += n+1;  for(n=0; ALWAYS(zSpan[n]) && zSpan[n]!='.'; n++){}  if( zTab && (sqlite3StrNICmp(zSpan, zTab, n)!=0 || zTab[n]!=0) ){  return 0;  }  zSpan += n+1;  if( zCol && sqlite3StrICmp(zSpan, zCol)!=0 ){  return 0;  }  return 1; } static int areDoubleQuotedStringsEnabled(sqlite3 *db, NameContext *pTopNC){  if( db->init.busy ) return 1;  if( pTopNC->ncFlags & NC_IsDDL ){  if( sqlite3WritableSchema(db) && (db->flags & SQLITE_DqsDML)!=0 ){  return 1;  }  return (db->flags & SQLITE_DqsDDL)!=0;  }else{  return (db->flags & SQLITE_DqsDML)!=0;  } } SQLITE_PRIVATE Bitmask sqlite3ExprColUsed(Expr *pExpr){  int n;  Table *pExTab;  n = pExpr->iColumn;  assert( ExprUseYTab(pExpr) );  pExTab = pExpr->y.pTab;  assert( pExTab!=0 );  if( (pExTab->tabFlags & TF_HasGenerated)!=0   && (pExTab->aCol[n].colFlags & COLFLAG_GENERATED)!=0  ){  testcase( pExTab->nCol==BMS-1 );  testcase( pExTab->nCol==BMS );  return pExTab->nCol>=BMS ? ALLBITS : MASKBIT(pExTab->nCol)-1;  }else{  testcase( n==BMS-1 );  testcase( n==BMS );  if( n>=BMS ) n = BMS-1;  return ((Bitmask)1)<<n;  } } static int lookupName(  Parse *pParse,  const char *zDb,  const char *zTab,  const char *zCol,  NameContext *pNC,  Expr *pExpr ){  int i, j;  int cnt = 0;  int cntTab = 0;  int nSubquery = 0;  sqlite3 *db = pParse->db;  SrcItem *pItem;  SrcItem *pMatch = 0;  NameContext *pTopNC = pNC;  Schema *pSchema = 0;  int eNewExprOp = TK_COLUMN;  Table *pTab = 0;  Column *pCol;  assert( pNC );  assert( zCol );  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );  pExpr->iTable = -1;  ExprSetVVAProperty(pExpr, EP_NoReduce);  if( zDb ){  testcase( pNC->ncFlags & NC_PartIdx );  testcase( pNC->ncFlags & NC_IsCheck );  if( (pNC->ncFlags & (NC_PartIdx|NC_IsCheck))!=0 ){  zDb = 0;  }else{  for(i=0; i<db->nDb; i++){  assert( db->aDb[i].zDbSName );  if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){  pSchema = db->aDb[i].pSchema;  break;  }  }  if( i==db->nDb && sqlite3StrICmp("main", zDb)==0 ){  pSchema = db->aDb[0].pSchema;  zDb = db->aDb[0].zDbSName;  }  }  }  assert( pNC && cnt==0 );  do{  ExprList *pEList;  SrcList *pSrcList = pNC->pSrcList;  if( pSrcList ){  for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){  u8 hCol;  pTab = pItem->pTab;  assert( pTab!=0 && pTab->zName!=0 );  assert( pTab->nCol>0 || pParse->nErr );  if( pItem->pSelect && (pItem->pSelect->selFlags & SF_NestedFrom)!=0 ){  int hit = 0;  pEList = pItem->pSelect->pEList;  for(j=0; j<pEList->nExpr; j++){  if( sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb) ){  cnt++;  cntTab = 2;  pMatch = pItem;  pExpr->iColumn = j;  hit = 1;  }  }  if( hit || zTab==0 ) continue;  }  if( zDb && pTab->pSchema!=pSchema ){  continue;  }  if( zTab ){  const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;  assert( zTabName!=0 );  if( sqlite3StrICmp(zTabName, zTab)!=0 ){  continue;  }  assert( ExprUseYTab(pExpr) );  if( IN_RENAME_OBJECT && pItem->zAlias ){  sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);  }  }  hCol = sqlite3StrIHash(zCol);  for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){  if( pCol->hName==hCol   && sqlite3StrICmp(pCol->zCnName, zCol)==0  ){  if( cnt==1 ){  if( pItem->fg.jointype & JT_NATURAL ) continue;  if( nameInUsingClause(pItem->pUsing, zCol) ) continue;  }  cnt++;  pMatch = pItem;  pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;  break;  }  }  if( 0==cnt && VisibleRowid(pTab) ){  cntTab++;  pMatch = pItem;  }  }  if( pMatch ){  pExpr->iTable = pMatch->iCursor;  assert( ExprUseYTab(pExpr) );  pExpr->y.pTab = pMatch->pTab;  assert( (pMatch->fg.jointype & JT_RIGHT)==0 );  if( (pMatch->fg.jointype & JT_LEFT)!=0 ){  ExprSetProperty(pExpr, EP_CanBeNull);  }  pSchema = pExpr->y.pTab->pSchema;  }  }
#if !defined(SQLITE_OMIT_TRIGGER) || !defined(SQLITE_OMIT_UPSERT)
 if( cnt==0 && zDb==0 ){  pTab = 0;
#ifndef SQLITE_OMIT_TRIGGER
 if( pParse->pTriggerTab!=0 ){  int op = pParse->eTriggerOp;  assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );  if( pParse->bReturning ){  if( (pNC->ncFlags & NC_UBaseReg)!=0   && (zTab==0 || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0)  ){  pExpr->iTable = op!=TK_DELETE;  pTab = pParse->pTriggerTab;  }  }else if( op!=TK_DELETE && zTab && sqlite3StrICmp("new",zTab) == 0 ){  pExpr->iTable = 1;  pTab = pParse->pTriggerTab;  }else if( op!=TK_INSERT && zTab && sqlite3StrICmp("old",zTab)==0 ){  pExpr->iTable = 0;  pTab = pParse->pTriggerTab;  }  }
#endif
#ifndef SQLITE_OMIT_UPSERT
 if( (pNC->ncFlags & NC_UUpsert)!=0 && zTab!=0 ){  Upsert *pUpsert = pNC->uNC.pUpsert;  if( pUpsert && sqlite3StrICmp("excluded",zTab)==0 ){  pTab = pUpsert->pUpsertSrc->a[0].pTab;  pExpr->iTable = EXCLUDED_TABLE_NUMBER;  }  }
#endif
 if( pTab ){  int iCol;  u8 hCol = sqlite3StrIHash(zCol);  pSchema = pTab->pSchema;  cntTab++;  for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){  if( pCol->hName==hCol   && sqlite3StrICmp(pCol->zCnName, zCol)==0  ){  if( iCol==pTab->iPKey ){  iCol = -1;  }  break;  }  }  if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && VisibleRowid(pTab) ){  iCol = -1;  }  if( iCol<pTab->nCol ){  cnt++;  pMatch = 0;
#ifndef SQLITE_OMIT_UPSERT
 if( pExpr->iTable==EXCLUDED_TABLE_NUMBER ){  testcase( iCol==(-1) );  assert( ExprUseYTab(pExpr) );  if( IN_RENAME_OBJECT ){  pExpr->iColumn = iCol;  pExpr->y.pTab = pTab;  eNewExprOp = TK_COLUMN;  }else{  pExpr->iTable = pNC->uNC.pUpsert->regData +   sqlite3TableColumnToStorage(pTab, iCol);  eNewExprOp = TK_REGISTER;  }  }else
#endif
 {  assert( ExprUseYTab(pExpr) );  pExpr->y.pTab = pTab;  if( pParse->bReturning ){  eNewExprOp = TK_REGISTER;  pExpr->iTable = pNC->uNC.iBaseReg + (pTab->nCol+1)*pExpr->iTable +   sqlite3TableColumnToStorage(pTab, iCol) + 1;  }else{  pExpr->iColumn = (i16)iCol;  eNewExprOp = TK_TRIGGER;
#ifndef SQLITE_OMIT_TRIGGER
 if( iCol<0 ){  pExpr->affExpr = SQLITE_AFF_INTEGER;  }else if( pExpr->iTable==0 ){  testcase( iCol==31 );  testcase( iCol==32 );  pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));  }else{  testcase( iCol==31 );  testcase( iCol==32 );  pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));  }
#endif
 }  }  }  }  }
#endif
 if( cnt==0   && cntTab==1   && pMatch   && (pNC->ncFlags & (NC_IdxExpr|NC_GenCol))==0   && sqlite3IsRowid(zCol)   && ALWAYS(VisibleRowid(pMatch->pTab))  ){  cnt = 1;  pExpr->iColumn = -1;  pExpr->affExpr = SQLITE_AFF_INTEGER;  }  if( cnt==0   && (pNC->ncFlags & NC_UEList)!=0   && zTab==0  ){  pEList = pNC->uNC.pEList;  assert( pEList!=0 );  for(j=0; j<pEList->nExpr; j++){  char *zAs = pEList->a[j].zEName;  if( pEList->a[j].eEName==ENAME_NAME   && sqlite3_stricmp(zAs, zCol)==0  ){  Expr *pOrig;  assert( pExpr->pLeft==0 && pExpr->pRight==0 );  assert( ExprUseXList(pExpr)==0 || pExpr->x.pList==0 );  assert( ExprUseXSelect(pExpr)==0 || pExpr->x.pSelect==0 );  pOrig = pEList->a[j].pExpr;  if( (pNC->ncFlags&NC_AllowAgg)==0 && ExprHasProperty(pOrig, EP_Agg) ){  sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);  return WRC_Abort;  }  if( ExprHasProperty(pOrig, EP_Win)   && ((pNC->ncFlags&NC_AllowWin)==0 || pNC!=pTopNC )  ){  sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",zAs);  return WRC_Abort;  }  if( sqlite3ExprVectorSize(pOrig)!=1 ){  sqlite3ErrorMsg(pParse, "row value misused");  return WRC_Abort;  }  resolveAlias(pParse, pEList, j, pExpr, nSubquery);  cnt = 1;  pMatch = 0;  assert( zTab==0 && zDb==0 );  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);  }  goto lookupname_end;  }  }  }  if( cnt ) break;  pNC = pNC->pNext;  nSubquery++;  }while( pNC );  if( cnt==0 && zTab==0 ){  assert( pExpr->op==TK_ID );  if( ExprHasProperty(pExpr,EP_DblQuoted)   && areDoubleQuotedStringsEnabled(db, pTopNC)  ){  sqlite3_log(SQLITE_WARNING,  "double-quoted string literal: \"%w\"", zCol);
#ifdef SQLITE_ENABLE_NORMALIZE
 sqlite3VdbeAddDblquoteStr(db, pParse->pVdbe, zCol);
#endif
 pExpr->op = TK_STRING;  memset(&pExpr->y, 0, sizeof(pExpr->y));  return WRC_Prune;  }  if( sqlite3ExprIdToTrueFalse(pExpr) ){  return WRC_Prune;  }  }  if( cnt!=1 ){  const char *zErr;  zErr = cnt==0 ? "no such column" : "ambiguous column name";  if( zDb ){  sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);  }else if( zTab ){  sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);  }else{  sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);  }  pParse->checkSchema = 1;  pTopNC->nNcErr++;  }  if( pExpr->iColumn>=0 && pMatch!=0 ){  pMatch->colUsed |= sqlite3ExprColUsed(pExpr);  }  if( !ExprHasProperty(pExpr,(EP_TokenOnly|EP_Leaf)) ){  sqlite3ExprDelete(db, pExpr->pLeft);  pExpr->pLeft = 0;  sqlite3ExprDelete(db, pExpr->pRight);  pExpr->pRight = 0;  }  pExpr->op = eNewExprOp;  ExprSetProperty(pExpr, EP_Leaf); lookupname_end:  if( cnt==1 ){  assert( pNC!=0 );
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( pParse->db->xAuth   && (pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER)  ){  sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);  }
#endif
 for(;;){  assert( pTopNC!=0 );  pTopNC->nRef++;  if( pTopNC==pNC ) break;  pTopNC = pTopNC->pNext;  }  return WRC_Prune;  } else {  return WRC_Abort;  } } SQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);  if( p ){  SrcItem *pItem = &pSrc->a[iSrc];  Table *pTab;  assert( ExprUseYTab(p) );  pTab = p->y.pTab = pItem->pTab;  p->iTable = pItem->iCursor;  if( p->y.pTab->iPKey==iCol ){  p->iColumn = -1;  }else{  p->iColumn = (ynVar)iCol;  if( (pTab->tabFlags & TF_HasGenerated)!=0   && (pTab->aCol[iCol].colFlags & COLFLAG_GENERATED)!=0  ){  testcase( pTab->nCol==63 );  testcase( pTab->nCol==64 );  pItem->colUsed = pTab->nCol>=64 ? ALLBITS : MASKBIT(pTab->nCol)-1;  }else{  testcase( iCol==BMS );  testcase( iCol==BMS-1 );  pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);  }  }  }  return p; } static void notValidImpl(   Parse *pParse,   NameContext *pNC,   const char *zMsg,   Expr *pExpr ){  const char *zIn = "partial index WHERE clauses";  if( pNC->ncFlags & NC_IdxExpr ) zIn = "index expressions";
#ifndef SQLITE_OMIT_CHECK
 else if( pNC->ncFlags & NC_IsCheck ) zIn = "CHECK constraints";
#endif
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 else if( pNC->ncFlags & NC_GenCol ) zIn = "generated columns";
#endif
 sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);  if( pExpr ) pExpr->op = TK_NULL; }
#define sqlite3ResolveNotValid(P,N,M,X,E)  assert( ((X)&~(NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol))==0 );  if( ((N)->ncFlags & (X))!=0 ) notValidImpl(P,N,M,E);

static int exprProbability(Expr *p){  double r = -1.0;  if( p->op!=TK_FLOAT ) return -1;  assert( !ExprHasProperty(p, EP_IntValue) );  sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), SQLITE_UTF8);  assert( r>=0.0 );  if( r>1.0 ) return -1;  return (int)(r*134217728.0); } static int resolveExprStep(Walker *pWalker, Expr *pExpr){  NameContext *pNC;  Parse *pParse;  pNC = pWalker->u.pNC;  assert( pNC!=0 );  pParse = pNC->pParse;  assert( pParse==pWalker->pParse );
#ifndef NDEBUG
 if( pNC->pSrcList && pNC->pSrcList->nAlloc>0 ){  SrcList *pSrcList = pNC->pSrcList;  int i;  for(i=0; i<pNC->pSrcList->nSrc; i++){  assert( pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab);  }  }
#endif
 switch( pExpr->op ){  case TK_ROW: {  SrcList *pSrcList = pNC->pSrcList;  SrcItem *pItem;  assert( pSrcList && pSrcList->nSrc>=1 );  pItem = pSrcList->a;  pExpr->op = TK_COLUMN;  assert( ExprUseYTab(pExpr) );  pExpr->y.pTab = pItem->pTab;  pExpr->iTable = pItem->iCursor;  pExpr->iColumn--;  pExpr->affExpr = SQLITE_AFF_INTEGER;  break;  }  case TK_NOTNULL:  case TK_ISNULL: {  int anRef[8];  NameContext *p;  int i;  for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){  anRef[i] = p->nRef;  }  sqlite3WalkExpr(pWalker, pExpr->pLeft);  if( 0==sqlite3ExprCanBeNull(pExpr->pLeft) && !IN_RENAME_OBJECT ){  testcase( ExprHasProperty(pExpr, EP_FromJoin) );  assert( !ExprHasProperty(pExpr, EP_IntValue) );  if( pExpr->op==TK_NOTNULL ){  pExpr->u.zToken = "true";  ExprSetProperty(pExpr, EP_IsTrue);  }else{  pExpr->u.zToken = "false";  ExprSetProperty(pExpr, EP_IsFalse);  }  pExpr->op = TK_TRUEFALSE;  for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){  p->nRef = anRef[i];  }  sqlite3ExprDelete(pParse->db, pExpr->pLeft);  pExpr->pLeft = 0;  }  return WRC_Prune;  }  case TK_ID:  case TK_DOT: {  const char *zColumn;  const char *zTable;  const char *zDb;  Expr *pRight;  if( pExpr->op==TK_ID ){  zDb = 0;  zTable = 0;  assert( !ExprHasProperty(pExpr, EP_IntValue) );  zColumn = pExpr->u.zToken;  }else{  Expr *pLeft = pExpr->pLeft;  testcase( pNC->ncFlags & NC_IdxExpr );  testcase( pNC->ncFlags & NC_GenCol );  sqlite3ResolveNotValid(pParse, pNC, "the \".\" operator",   NC_IdxExpr|NC_GenCol, 0);  pRight = pExpr->pRight;  if( pRight->op==TK_ID ){  zDb = 0;  }else{  assert( pRight->op==TK_DOT );  assert( !ExprHasProperty(pRight, EP_IntValue) );  zDb = pLeft->u.zToken;  pLeft = pRight->pLeft;  pRight = pRight->pRight;  }  assert( ExprUseUToken(pLeft) && ExprUseUToken(pRight) );  zTable = pLeft->u.zToken;  zColumn = pRight->u.zToken;  assert( ExprUseYTab(pExpr) );  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenRemap(pParse, (void*)pExpr, (void*)pRight);  sqlite3RenameTokenRemap(pParse, (void*)&pExpr->y.pTab, (void*)pLeft);  }  }  return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);  }  case TK_FUNCTION: {  ExprList *pList = pExpr->x.pList;  int n = pList ? pList->nExpr : 0;  int no_such_func = 0;  int wrong_num_args = 0;  int is_agg = 0;  int nId;  const char *zId;  FuncDef *pDef;  u8 enc = ENC(pParse->db);  int savedAllowFlags = (pNC->ncFlags & (NC_AllowAgg | NC_AllowWin));
#ifndef SQLITE_OMIT_WINDOWFUNC
 Window *pWin = (IsWindowFunc(pExpr) ? pExpr->y.pWin : 0);
#endif
 assert( !ExprHasProperty(pExpr, EP_xIsSelect|EP_IntValue) );  zId = pExpr->u.zToken;  nId = sqlite3Strlen30(zId);  pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);  if( pDef==0 ){  pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, 0);  if( pDef==0 ){  no_such_func = 1;  }else{  wrong_num_args = 1;  }  }else{  is_agg = pDef->xFinalize!=0;  if( pDef->funcFlags & SQLITE_FUNC_UNLIKELY ){  ExprSetProperty(pExpr, EP_Unlikely);  if( n==2 ){  pExpr->iTable = exprProbability(pList->a[1].pExpr);  if( pExpr->iTable<0 ){  sqlite3ErrorMsg(pParse,  "second argument to likelihood() must be a "  "constant between 0.0 and 1.0");  pNC->nNcErr++;  }  }else{  pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;  }  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 {  int auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0,pDef->zName,0);  if( auth!=SQLITE_OK ){  if( auth==SQLITE_DENY ){  sqlite3ErrorMsg(pParse, "not authorized to use function: %s",  pDef->zName);  pNC->nNcErr++;  }  pExpr->op = TK_NULL;  return WRC_Prune;  }  }
#endif
 if( pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG) ){  ExprSetProperty(pExpr,EP_ConstFunc);  }  if( (pDef->funcFlags & SQLITE_FUNC_CONSTANT)==0 ){  sqlite3ResolveNotValid(pParse, pNC, "non-deterministic functions",   NC_IdxExpr|NC_PartIdx|NC_GenCol, 0);  }else{  assert( (NC_SelfRef & 0xff)==NC_SelfRef );  pExpr->op2 = pNC->ncFlags & NC_SelfRef;  if( pNC->ncFlags & NC_FromDDL ) ExprSetProperty(pExpr, EP_FromDDL);  }  if( (pDef->funcFlags & SQLITE_FUNC_INTERNAL)!=0   && pParse->nested==0   && (pParse->db->mDbFlags & DBFLAG_InternalFunc)==0  ){  no_such_func = 1;  pDef = 0;  }else  if( (pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE))!=0   && !IN_RENAME_OBJECT  ){  sqlite3ExprFunctionUsable(pParse, pExpr, pDef);  }  }  if( 0==IN_RENAME_OBJECT ){
#ifndef SQLITE_OMIT_WINDOWFUNC
 assert( is_agg==0 || (pDef->funcFlags & SQLITE_FUNC_MINMAX)  || (pDef->xValue==0 && pDef->xInverse==0)  || (pDef->xValue && pDef->xInverse && pDef->xSFunc && pDef->xFinalize)  );  if( pDef && pDef->xValue==0 && pWin ){  sqlite3ErrorMsg(pParse,  "%.*s() may not be used as a window function", nId, zId  );  pNC->nNcErr++;  }else if(  (is_agg && (pNC->ncFlags & NC_AllowAgg)==0)   || (is_agg && (pDef->funcFlags&SQLITE_FUNC_WINDOW) && !pWin)   || (is_agg && pWin && (pNC->ncFlags & NC_AllowWin)==0)  ){  const char *zType;  if( (pDef->funcFlags & SQLITE_FUNC_WINDOW) || pWin ){  zType = "window";  }else{  zType = "aggregate";  }  sqlite3ErrorMsg(pParse, "misuse of %s function %.*s()",zType,nId,zId);  pNC->nNcErr++;  is_agg = 0;  }
#else
 if( (is_agg && (pNC->ncFlags & NC_AllowAgg)==0) ){  sqlite3ErrorMsg(pParse,"misuse of aggregate function %.*s()",nId,zId);  pNC->nNcErr++;  is_agg = 0;  }
#endif
 else if( no_such_func && pParse->db->init.busy==0
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
 && pParse->explain==0
#endif
 ){  sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);  pNC->nNcErr++;  }else if( wrong_num_args ){  sqlite3ErrorMsg(pParse,"wrong number of arguments to function %.*s()",   nId, zId);  pNC->nNcErr++;  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 else if( is_agg==0 && ExprHasProperty(pExpr, EP_WinFunc) ){  sqlite3ErrorMsg(pParse,  "FILTER may not be used with non-aggregate %.*s()",  nId, zId  );  pNC->nNcErr++;  }
#endif
 if( is_agg ){
#ifndef SQLITE_OMIT_WINDOWFUNC
 pNC->ncFlags &= ~(NC_AllowWin | (!pWin ? NC_AllowAgg : 0));
#else
 pNC->ncFlags &= ~NC_AllowAgg;
#endif
 }  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 else if( ExprHasProperty(pExpr, EP_WinFunc) ){  is_agg = 1;  }
#endif
 sqlite3WalkExprList(pWalker, pList);  if( is_agg ){
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pWin ){  Select *pSel = pNC->pWinSelect;  assert( pWin==0 || (ExprUseYWin(pExpr) && pWin==pExpr->y.pWin) );  if( IN_RENAME_OBJECT==0 ){  sqlite3WindowUpdate(pParse, pSel ? pSel->pWinDefn : 0, pWin, pDef);  if( pParse->db->mallocFailed ) break;  }  sqlite3WalkExprList(pWalker, pWin->pPartition);  sqlite3WalkExprList(pWalker, pWin->pOrderBy);  sqlite3WalkExpr(pWalker, pWin->pFilter);  sqlite3WindowLink(pSel, pWin);  pNC->ncFlags |= NC_HasWin;  }else
#endif
 {  NameContext *pNC2;  pExpr->op = TK_AGG_FUNCTION;  pExpr->op2 = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(pExpr, EP_WinFunc) ){  sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);  }
#endif
 pNC2 = pNC;  while( pNC2  && sqlite3ReferencesSrcList(pParse, pExpr, pNC2->pSrcList)==0  ){  pExpr->op2++;  pNC2 = pNC2->pNext;  }  assert( pDef!=0 || IN_RENAME_OBJECT );  if( pNC2 && pDef ){  assert( SQLITE_FUNC_MINMAX==NC_MinMaxAgg );  assert( SQLITE_FUNC_ANYORDER==NC_OrderAgg );  testcase( (pDef->funcFlags & SQLITE_FUNC_MINMAX)!=0 );  testcase( (pDef->funcFlags & SQLITE_FUNC_ANYORDER)!=0 );  pNC2->ncFlags |= NC_HasAgg  | ((pDef->funcFlags^SQLITE_FUNC_ANYORDER)  & (SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER));  }  }  pNC->ncFlags |= savedAllowFlags;  }  return WRC_Prune;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case TK_SELECT:  case TK_EXISTS: testcase( pExpr->op==TK_EXISTS );
#endif
 case TK_IN: {  testcase( pExpr->op==TK_IN );  if( ExprUseXSelect(pExpr) ){  int nRef = pNC->nRef;  testcase( pNC->ncFlags & NC_IsCheck );  testcase( pNC->ncFlags & NC_PartIdx );  testcase( pNC->ncFlags & NC_IdxExpr );  testcase( pNC->ncFlags & NC_GenCol );  if( pNC->ncFlags & NC_SelfRef ){  notValidImpl(pParse, pNC, "subqueries", pExpr);  }else{  sqlite3WalkSelect(pWalker, pExpr->x.pSelect);  }  assert( pNC->nRef>=nRef );  if( nRef!=pNC->nRef ){  ExprSetProperty(pExpr, EP_VarSelect);  pNC->ncFlags |= NC_VarSelect;  }  }  break;  }  case TK_VARIABLE: {  testcase( pNC->ncFlags & NC_IsCheck );  testcase( pNC->ncFlags & NC_PartIdx );  testcase( pNC->ncFlags & NC_IdxExpr );  testcase( pNC->ncFlags & NC_GenCol );  sqlite3ResolveNotValid(pParse, pNC, "parameters",   NC_IsCheck|NC_PartIdx|NC_IdxExpr|NC_GenCol, pExpr);  break;  }  case TK_IS:  case TK_ISNOT: {  Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);  assert( !ExprHasProperty(pExpr, EP_Reduced) );  if( ALWAYS(pRight) && (pRight->op==TK_ID || pRight->op==TK_TRUEFALSE) ){  int rc = resolveExprStep(pWalker, pRight);  if( rc==WRC_Abort ) return WRC_Abort;  if( pRight->op==TK_TRUEFALSE ){  pExpr->op2 = pExpr->op;  pExpr->op = TK_TRUTH;  return WRC_Continue;  }  }  deliberate_fall_through  }  case TK_BETWEEN:  case TK_EQ:  case TK_NE:  case TK_LT:  case TK_LE:  case TK_GT:  case TK_GE: {  int nLeft, nRight;  if( pParse->db->mallocFailed ) break;  assert( pExpr->pLeft!=0 );  nLeft = sqlite3ExprVectorSize(pExpr->pLeft);  if( pExpr->op==TK_BETWEEN ){  assert( ExprUseXList(pExpr) );  nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);  if( nRight==nLeft ){  nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);  }  }else{  assert( pExpr->pRight!=0 );  nRight = sqlite3ExprVectorSize(pExpr->pRight);  }  if( nLeft!=nRight ){  testcase( pExpr->op==TK_EQ );  testcase( pExpr->op==TK_NE );  testcase( pExpr->op==TK_LT );  testcase( pExpr->op==TK_LE );  testcase( pExpr->op==TK_GT );  testcase( pExpr->op==TK_GE );  testcase( pExpr->op==TK_IS );  testcase( pExpr->op==TK_ISNOT );  testcase( pExpr->op==TK_BETWEEN );  sqlite3ErrorMsg(pParse, "row value misused");  }  break;  }  }  return (pParse->nErr || pParse->db->mallocFailed) ? WRC_Abort : WRC_Continue; } static int resolveAsName(  Parse *pParse,  ExprList *pEList,  Expr *pE ){  int i;  UNUSED_PARAMETER(pParse);  if( pE->op==TK_ID ){  const char *zCol;  assert( !ExprHasProperty(pE, EP_IntValue) );  zCol = pE->u.zToken;  for(i=0; i<pEList->nExpr; i++){  if( pEList->a[i].eEName==ENAME_NAME   && sqlite3_stricmp(pEList->a[i].zEName, zCol)==0  ){  return i+1;  }  }  }  return 0; } static int resolveOrderByTermToExprList(  Parse *pParse,  Select *pSelect,  Expr *pE ){  int i;  ExprList *pEList;  NameContext nc;  sqlite3 *db;  int rc;  u8 savedSuppErr;  assert( sqlite3ExprIsInteger(pE, &i)==0 );  pEList = pSelect->pEList;  memset(&nc, 0, sizeof(nc));  nc.pParse = pParse;  nc.pSrcList = pSelect->pSrc;  nc.uNC.pEList = pEList;  nc.ncFlags = NC_AllowAgg|NC_UEList|NC_NoSelect;  nc.nNcErr = 0;  db = pParse->db;  savedSuppErr = db->suppressErr;  db->suppressErr = 1;  rc = sqlite3ResolveExprNames(&nc, pE);  db->suppressErr = savedSuppErr;  if( rc ) return 0;  for(i=0; i<pEList->nExpr; i++){  if( sqlite3ExprCompare(0, pEList->a[i].pExpr, pE, -1)<2 ){  return i+1;  }  }  return 0; } static void resolveOutOfRangeError(  Parse *pParse,  const char *zType,  int i,  int mx ){  sqlite3ErrorMsg(pParse,  "%r %s BY term out of range - should be "  "between 1 and %d", i, zType, mx); } static int resolveCompoundOrderBy(  Parse *pParse,  Select *pSelect ){  int i;  ExprList *pOrderBy;  ExprList *pEList;  sqlite3 *db;  int moreToDo = 1;  pOrderBy = pSelect->pOrderBy;  if( pOrderBy==0 ) return 0;  db = pParse->db;  if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){  sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");  return 1;  }  for(i=0; i<pOrderBy->nExpr; i++){  pOrderBy->a[i].done = 0;  }  pSelect->pNext = 0;  while( pSelect->pPrior ){  pSelect->pPrior->pNext = pSelect;  pSelect = pSelect->pPrior;  }  while( pSelect && moreToDo ){  struct ExprList_item *pItem;  moreToDo = 0;  pEList = pSelect->pEList;  assert( pEList!=0 );  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){  int iCol = -1;  Expr *pE, *pDup;  if( pItem->done ) continue;  pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);  if( NEVER(pE==0) ) continue;  if( sqlite3ExprIsInteger(pE, &iCol) ){  if( iCol<=0 || iCol>pEList->nExpr ){  resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr);  return 1;  }  }else{  iCol = resolveAsName(pParse, pEList, pE);  if( iCol==0 ){  pDup = sqlite3ExprDup(db, pE, 0);  if( !db->mallocFailed ){  assert(pDup);  iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);  if( IN_RENAME_OBJECT && iCol>0 ){  resolveOrderByTermToExprList(pParse, pSelect, pE);  }  }  sqlite3ExprDelete(db, pDup);  }  }  if( iCol>0 ){  if( !IN_RENAME_OBJECT ){  Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);  if( pNew==0 ) return 1;  pNew->flags |= EP_IntValue;  pNew->u.iValue = iCol;  if( pItem->pExpr==pE ){  pItem->pExpr = pNew;  }else{  Expr *pParent = pItem->pExpr;  assert( pParent->op==TK_COLLATE );  while( pParent->pLeft->op==TK_COLLATE ) pParent = pParent->pLeft;  assert( pParent->pLeft==pE );  pParent->pLeft = pNew;  }  sqlite3ExprDelete(db, pE);  pItem->u.x.iOrderByCol = (u16)iCol;  }  pItem->done = 1;  }else{  moreToDo = 1;  }  }  pSelect = pSelect->pNext;  }  for(i=0; i<pOrderBy->nExpr; i++){  if( pOrderBy->a[i].done==0 ){  sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "  "column in the result set", i+1);  return 1;  }  }  return 0; } SQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(  Parse *pParse,  Select *pSelect,  ExprList *pOrderBy,  const char *zType ){  int i;  sqlite3 *db = pParse->db;  ExprList *pEList;  struct ExprList_item *pItem;  if( pOrderBy==0 || pParse->db->mallocFailed || IN_RENAME_OBJECT ) return 0;  if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){  sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);  return 1;  }  pEList = pSelect->pEList;  assert( pEList!=0 );  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){  if( pItem->u.x.iOrderByCol ){  if( pItem->u.x.iOrderByCol>pEList->nExpr ){  resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr);  return 1;  }  resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,0);  }  }  return 0; }
#ifndef SQLITE_OMIT_WINDOWFUNC
static int resolveRemoveWindowsCb(Walker *pWalker, Expr *pExpr){  UNUSED_PARAMETER(pWalker);  if( ExprHasProperty(pExpr, EP_WinFunc) ){  Window *pWin = pExpr->y.pWin;  sqlite3WindowUnlinkFromSelect(pWin);  }  return WRC_Continue; } static void windowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){  if( pSelect->pWin ){  Walker sWalker;  memset(&sWalker, 0, sizeof(Walker));  sWalker.xExprCallback = resolveRemoveWindowsCb;  sWalker.u.pSelect = pSelect;  sqlite3WalkExpr(&sWalker, pExpr);  } }
#else
# define windowRemoveExprFromSelect(a, b)
#endif
static int resolveOrderGroupBy(  NameContext *pNC,  Select *pSelect,  ExprList *pOrderBy,  const char *zType ){  int i, j;  int iCol;  struct ExprList_item *pItem;  Parse *pParse;  int nResult;  assert( pOrderBy!=0 );  nResult = pSelect->pEList->nExpr;  pParse = pNC->pParse;  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){  Expr *pE = pItem->pExpr;  Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pE);  if( NEVER(pE2==0) ) continue;  if( zType[0]!='G' ){  iCol = resolveAsName(pParse, pSelect->pEList, pE2);  if( iCol>0 ){  pItem->u.x.iOrderByCol = (u16)iCol;  continue;  }  }  if( sqlite3ExprIsInteger(pE2, &iCol) ){  if( iCol<1 || iCol>0xffff ){  resolveOutOfRangeError(pParse, zType, i+1, nResult);  return 1;  }  pItem->u.x.iOrderByCol = (u16)iCol;  continue;  }  pItem->u.x.iOrderByCol = 0;  if( sqlite3ResolveExprNames(pNC, pE) ){  return 1;  }  for(j=0; j<pSelect->pEList->nExpr; j++){  if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){  windowRemoveExprFromSelect(pSelect, pE);  pItem->u.x.iOrderByCol = j+1;  }  }  }  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType); } static int resolveSelectStep(Walker *pWalker, Select *p){  NameContext *pOuterNC;  NameContext sNC;  int isCompound;  int nCompound;  Parse *pParse;  int i;  ExprList *pGroupBy;  Select *pLeftmost;  sqlite3 *db;  assert( p!=0 );  if( p->selFlags & SF_Resolved ){  return WRC_Prune;  }  pOuterNC = pWalker->u.pNC;  pParse = pWalker->pParse;  db = pParse->db;  if( (p->selFlags & SF_Expanded)==0 ){  sqlite3SelectPrep(pParse, p, pOuterNC);  return (pParse->nErr || db->mallocFailed) ? WRC_Abort : WRC_Prune;  }  isCompound = p->pPrior!=0;  nCompound = 0;  pLeftmost = p;  while( p ){  assert( (p->selFlags & SF_Expanded)!=0 );  assert( (p->selFlags & SF_Resolved)==0 );  assert( db->suppressErr==0 );  p->selFlags |= SF_Resolved;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  sNC.pWinSelect = p;  if( sqlite3ResolveExprNames(&sNC, p->pLimit) ){  return WRC_Abort;  }  if( p->selFlags & SF_Converted ){  Select *pSub = p->pSrc->a[0].pSelect;  assert( p->pSrc->nSrc==1 && p->pOrderBy );  assert( pSub->pPrior && pSub->pOrderBy==0 );  pSub->pOrderBy = p->pOrderBy;  p->pOrderBy = 0;  }  for(i=0; i<p->pSrc->nSrc; i++){  SrcItem *pItem = &p->pSrc->a[i];  if( pItem->pSelect && (pItem->pSelect->selFlags & SF_Resolved)==0 ){  int nRef = pOuterNC ? pOuterNC->nRef : 0;  const char *zSavedContext = pParse->zAuthContext;  if( pItem->zName ) pParse->zAuthContext = pItem->zName;  sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);  pParse->zAuthContext = zSavedContext;  if( pParse->nErr || db->mallocFailed ) return WRC_Abort;  if( pOuterNC ){  assert( pItem->fg.isCorrelated==0 && pOuterNC->nRef>=nRef );  pItem->fg.isCorrelated = (pOuterNC->nRef>nRef);  }  }  }  sNC.ncFlags = NC_AllowAgg|NC_AllowWin;  sNC.pSrcList = p->pSrc;  sNC.pNext = pOuterNC;  if( sqlite3ResolveExprListNames(&sNC, p->pEList) ) return WRC_Abort;  sNC.ncFlags &= ~NC_AllowWin;  assert( (p->selFlags & SF_Aggregate)==0 );  pGroupBy = p->pGroupBy;  if( pGroupBy || (sNC.ncFlags & NC_HasAgg)!=0 ){  assert( NC_MinMaxAgg==SF_MinMaxAgg );  assert( NC_OrderAgg==SF_OrderByReqd );  p->selFlags |= SF_Aggregate | (sNC.ncFlags&(NC_MinMaxAgg|NC_OrderAgg));  }else{  sNC.ncFlags &= ~NC_AllowAgg;  }  assert( (sNC.ncFlags & (NC_UAggInfo|NC_UUpsert|NC_UBaseReg))==0 );  sNC.uNC.pEList = p->pEList;  sNC.ncFlags |= NC_UEList;  if( p->pHaving ){  if( !pGroupBy ){  sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");  return WRC_Abort;  }  if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return WRC_Abort;  }  if( sqlite3ResolveExprNames(&sNC, p->pWhere) ) return WRC_Abort;  for(i=0; i<p->pSrc->nSrc; i++){  SrcItem *pItem = &p->pSrc->a[i];  if( pItem->fg.isTabFunc   && sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg)  ){  return WRC_Abort;  }  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( IN_RENAME_OBJECT ){  Window *pWin;  for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){  if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)   || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)  ){  return WRC_Abort;  }  }  }
#endif
 sNC.pNext = 0;  sNC.ncFlags |= NC_AllowAgg|NC_AllowWin;  if( p->selFlags & SF_Converted ){  Select *pSub = p->pSrc->a[0].pSelect;  p->pOrderBy = pSub->pOrderBy;  pSub->pOrderBy = 0;  }  if( p->pOrderBy!=0   && isCompound<=nCompound   && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")  ){  return WRC_Abort;  }  if( db->mallocFailed ){  return WRC_Abort;  }  sNC.ncFlags &= ~NC_AllowWin;  if( pGroupBy ){  struct ExprList_item *pItem;  if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){  return WRC_Abort;  }  for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){  if( ExprHasProperty(pItem->pExpr, EP_Agg) ){  sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "  "the GROUP BY clause");  return WRC_Abort;  }  }  }  if( p->pNext && p->pEList->nExpr!=p->pNext->pEList->nExpr ){  sqlite3SelectWrongNumTermsError(pParse, p->pNext);  return WRC_Abort;  }  p = p->pPrior;  nCompound++;  }  if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){  return WRC_Abort;  }  return WRC_Prune; } SQLITE_PRIVATE int sqlite3ResolveExprNames(  NameContext *pNC,  Expr *pExpr ){  int savedHasAgg;  Walker w;  if( pExpr==0 ) return SQLITE_OK;  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);  w.pParse = pNC->pParse;  w.xExprCallback = resolveExprStep;  w.xSelectCallback = (pNC->ncFlags & NC_NoSelect) ? 0 : resolveSelectStep;  w.xSelectCallback2 = 0;  w.u.pNC = pNC;
#if SQLITE_MAX_EXPR_DEPTH>0
 w.pParse->nHeight += pExpr->nHeight;  if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){  return SQLITE_ERROR;  }
#endif
 sqlite3WalkExpr(&w, pExpr);
#if SQLITE_MAX_EXPR_DEPTH>0
 w.pParse->nHeight -= pExpr->nHeight;
#endif
 assert( EP_Agg==NC_HasAgg );  assert( EP_Win==NC_HasWin );  testcase( pNC->ncFlags & NC_HasAgg );  testcase( pNC->ncFlags & NC_HasWin );  ExprSetProperty(pExpr, pNC->ncFlags & (NC_HasAgg|NC_HasWin) );  pNC->ncFlags |= savedHasAgg;  return pNC->nNcErr>0 || w.pParse->nErr>0; } SQLITE_PRIVATE int sqlite3ResolveExprListNames(  NameContext *pNC,  ExprList *pList ){  int i;  int savedHasAgg = 0;  Walker w;  if( pList==0 ) return WRC_Continue;  w.pParse = pNC->pParse;  w.xExprCallback = resolveExprStep;  w.xSelectCallback = resolveSelectStep;  w.xSelectCallback2 = 0;  w.u.pNC = pNC;  savedHasAgg = pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);  for(i=0; i<pList->nExpr; i++){  Expr *pExpr = pList->a[i].pExpr;  if( pExpr==0 ) continue;
#if SQLITE_MAX_EXPR_DEPTH>0
 w.pParse->nHeight += pExpr->nHeight;  if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){  return WRC_Abort;  }
#endif
 sqlite3WalkExpr(&w, pExpr);
#if SQLITE_MAX_EXPR_DEPTH>0
 w.pParse->nHeight -= pExpr->nHeight;
#endif
 assert( EP_Agg==NC_HasAgg );  assert( EP_Win==NC_HasWin );  testcase( pNC->ncFlags & NC_HasAgg );  testcase( pNC->ncFlags & NC_HasWin );  if( pNC->ncFlags & (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg) ){  ExprSetProperty(pExpr, pNC->ncFlags & (NC_HasAgg|NC_HasWin) );  savedHasAgg |= pNC->ncFlags &  (NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);  pNC->ncFlags &= ~(NC_HasAgg|NC_MinMaxAgg|NC_HasWin|NC_OrderAgg);  }  if( w.pParse->nErr>0 ) return WRC_Abort;  }  pNC->ncFlags |= savedHasAgg;  return WRC_Continue; } SQLITE_PRIVATE void sqlite3ResolveSelectNames(  Parse *pParse,  Select *p,  NameContext *pOuterNC ){  Walker w;  assert( p!=0 );  w.xExprCallback = resolveExprStep;  w.xSelectCallback = resolveSelectStep;  w.xSelectCallback2 = 0;  w.pParse = pParse;  w.u.pNC = pOuterNC;  sqlite3WalkSelect(&w, p); } SQLITE_PRIVATE int sqlite3ResolveSelfReference(  Parse *pParse,  Table *pTab,  int type,  Expr *pExpr,  ExprList *pList ){  SrcList sSrc;  NameContext sNC;  int rc;  assert( type==0 || pTab!=0 );  assert( type==NC_IsCheck || type==NC_PartIdx || type==NC_IdxExpr  || type==NC_GenCol || pTab==0 );  memset(&sNC, 0, sizeof(sNC));  memset(&sSrc, 0, sizeof(sSrc));  if( pTab ){  sSrc.nSrc = 1;  sSrc.a[0].zName = pTab->zName;  sSrc.a[0].pTab = pTab;  sSrc.a[0].iCursor = -1;  if( pTab->pSchema!=pParse->db->aDb[1].pSchema ){  type |= NC_FromDDL;  }  }  sNC.pParse = pParse;  sNC.pSrcList = &sSrc;  sNC.ncFlags = type | NC_IsDDL;  if( (rc = sqlite3ResolveExprNames(&sNC, pExpr))!=SQLITE_OK ) return rc;  if( pList ) rc = sqlite3ResolveExprListNames(&sNC, pList);  return rc; } static void exprCodeBetween(Parse*,Expr*,int,void(*)(Parse*,Expr*,int,int),int); static int exprCodeVector(Parse *pParse, Expr *p, int *piToFree); SQLITE_PRIVATE char sqlite3TableColumnAffinity(const Table *pTab, int iCol){  if( iCol<0 || NEVER(iCol>=pTab->nCol) ) return SQLITE_AFF_INTEGER;  return pTab->aCol[iCol].affinity; } SQLITE_PRIVATE char sqlite3ExprAffinity(const Expr *pExpr){  int op;  while( ExprHasProperty(pExpr, EP_Skip|EP_IfNullRow) ){  assert( pExpr->op==TK_COLLATE   || pExpr->op==TK_IF_NULL_ROW   || (pExpr->op==TK_REGISTER && pExpr->op2==TK_IF_NULL_ROW) );  pExpr = pExpr->pLeft;  assert( pExpr!=0 );  }  op = pExpr->op;  if( op==TK_REGISTER ) op = pExpr->op2;  if( op==TK_COLUMN || op==TK_AGG_COLUMN ){  assert( ExprUseYTab(pExpr) );  if( pExpr->y.pTab ){  return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);  }  }  if( op==TK_SELECT ){  assert( ExprUseXSelect(pExpr) );  assert( pExpr->x.pSelect!=0 );  assert( pExpr->x.pSelect->pEList!=0 );  assert( pExpr->x.pSelect->pEList->a[0].pExpr!=0 );  return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);  }
#ifndef SQLITE_OMIT_CAST
 if( op==TK_CAST ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  return sqlite3AffinityType(pExpr->u.zToken, 0);  }
#endif
 if( op==TK_SELECT_COLUMN ){  assert( pExpr->pLeft!=0 && ExprUseXSelect(pExpr->pLeft) );  assert( pExpr->iColumn < pExpr->iTable );  assert( pExpr->iTable==pExpr->pLeft->x.pSelect->pEList->nExpr );  return sqlite3ExprAffinity(  pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr  );  }  if( op==TK_VECTOR ){  assert( ExprUseXList(pExpr) );  return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);  }  return pExpr->affExpr; } SQLITE_PRIVATE Expr *sqlite3ExprAddCollateToken(  const Parse *pParse,  Expr *pExpr,  const Token *pCollName,  int dequote ){  if( pCollName->n>0 ){  Expr *pNew = sqlite3ExprAlloc(pParse->db, TK_COLLATE, pCollName, dequote);  if( pNew ){  pNew->pLeft = pExpr;  pNew->flags |= EP_Collate|EP_Skip;  pExpr = pNew;  }  }  return pExpr; } SQLITE_PRIVATE Expr *sqlite3ExprAddCollateString(  const Parse *pParse,  Expr *pExpr,  const char *zC ){  Token s;  assert( zC!=0 );  sqlite3TokenInit(&s, (char*)zC);  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0); } SQLITE_PRIVATE Expr *sqlite3ExprSkipCollate(Expr *pExpr){  while( pExpr && ExprHasProperty(pExpr, EP_Skip) ){  assert( pExpr->op==TK_COLLATE );  pExpr = pExpr->pLeft;  }  return pExpr; } SQLITE_PRIVATE Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){  while( pExpr && ExprHasProperty(pExpr, EP_Skip|EP_Unlikely) ){  if( ExprHasProperty(pExpr, EP_Unlikely) ){  assert( ExprUseXList(pExpr) );  assert( pExpr->x.pList->nExpr>0 );  assert( pExpr->op==TK_FUNCTION );  pExpr = pExpr->x.pList->a[0].pExpr;  }else{  assert( pExpr->op==TK_COLLATE );  pExpr = pExpr->pLeft;  }  }  return pExpr; } SQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, const Expr *pExpr){  sqlite3 *db = pParse->db;  CollSeq *pColl = 0;  const Expr *p = pExpr;  while( p ){  int op = p->op;  if( op==TK_REGISTER ) op = p->op2;  if( op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER ){  assert( ExprUseYTab(p) );  if( p->y.pTab!=0 ){  int j = p->iColumn;  if( j>=0 ){  const char *zColl = sqlite3ColumnColl(&p->y.pTab->aCol[j]);  pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);  }  break;  }  }  if( op==TK_CAST || op==TK_UPLUS ){  p = p->pLeft;  continue;  }  if( op==TK_VECTOR ){  assert( ExprUseXList(p) );  p = p->x.pList->a[0].pExpr;  continue;  }  if( op==TK_COLLATE ){  assert( !ExprHasProperty(p, EP_IntValue) );  pColl = sqlite3GetCollSeq(pParse, ENC(db), 0, p->u.zToken);  break;  }  if( p->flags & EP_Collate ){  if( p->pLeft && (p->pLeft->flags & EP_Collate)!=0 ){  p = p->pLeft;  }else{  Expr *pNext = p->pRight;  assert( ExprUseXList(p) );  assert( p->x.pList==0 || p->pRight==0 );  if( p->x.pList!=0 && !db->mallocFailed ){  int i;  for(i=0; ALWAYS(i<p->x.pList->nExpr); i++){  if( ExprHasProperty(p->x.pList->a[i].pExpr, EP_Collate) ){  pNext = p->x.pList->a[i].pExpr;  break;  }  }  }  p = pNext;  }  }else{  break;  }  }  if( sqlite3CheckCollSeq(pParse, pColl) ){  pColl = 0;  }  return pColl; } SQLITE_PRIVATE CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, const Expr *pExpr){  CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);  if( p==0 ) p = pParse->db->pDfltColl;  assert( p!=0 );  return p; } SQLITE_PRIVATE int sqlite3ExprCollSeqMatch(Parse *pParse, const Expr *pE1, const Expr *pE2){  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);  CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);  return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0; } SQLITE_PRIVATE char sqlite3CompareAffinity(const Expr *pExpr, char aff2){  char aff1 = sqlite3ExprAffinity(pExpr);  if( aff1>SQLITE_AFF_NONE && aff2>SQLITE_AFF_NONE ){  if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){  return SQLITE_AFF_NUMERIC;  }else{  return SQLITE_AFF_BLOB;  }  }else{  assert( aff1<=SQLITE_AFF_NONE || aff2<=SQLITE_AFF_NONE );  return (aff1<=SQLITE_AFF_NONE ? aff2 : aff1) | SQLITE_AFF_NONE;  } } static char comparisonAffinity(const Expr *pExpr){  char aff;  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||  pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||  pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );  assert( pExpr->pLeft );  aff = sqlite3ExprAffinity(pExpr->pLeft);  if( pExpr->pRight ){  aff = sqlite3CompareAffinity(pExpr->pRight, aff);  }else if( ExprUseXSelect(pExpr) ){  aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);  }else if( aff==0 ){  aff = SQLITE_AFF_BLOB;  }  return aff; } SQLITE_PRIVATE int sqlite3IndexAffinityOk(const Expr *pExpr, char idx_affinity){  char aff = comparisonAffinity(pExpr);  if( aff<SQLITE_AFF_TEXT ){  return 1;  }  if( aff==SQLITE_AFF_TEXT ){  return idx_affinity==SQLITE_AFF_TEXT;  }  return sqlite3IsNumericAffinity(idx_affinity); } static u8 binaryCompareP5(  const Expr *pExpr1,  const Expr *pExpr2,  int jumpIfNull ){  u8 aff = (char)sqlite3ExprAffinity(pExpr2);  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;  return aff; } SQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(  Parse *pParse,  const Expr *pLeft,  const Expr *pRight ){  CollSeq *pColl;  assert( pLeft );  if( pLeft->flags & EP_Collate ){  pColl = sqlite3ExprCollSeq(pParse, pLeft);  }else if( pRight && (pRight->flags & EP_Collate)!=0 ){  pColl = sqlite3ExprCollSeq(pParse, pRight);  }else{  pColl = sqlite3ExprCollSeq(pParse, pLeft);  if( !pColl ){  pColl = sqlite3ExprCollSeq(pParse, pRight);  }  }  return pColl; } SQLITE_PRIVATE CollSeq *sqlite3ExprCompareCollSeq(Parse *pParse, const Expr *p){  if( ExprHasProperty(p, EP_Commuted) ){  return sqlite3BinaryCompareCollSeq(pParse, p->pRight, p->pLeft);  }else{  return sqlite3BinaryCompareCollSeq(pParse, p->pLeft, p->pRight);  } } static int codeCompare(  Parse *pParse,  Expr *pLeft,  Expr *pRight,  int opcode,  int in1, int in2,  int dest,  int jumpIfNull,  int isCommuted ){  int p5;  int addr;  CollSeq *p4;  if( pParse->nErr ) return 0;  if( isCommuted ){  p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);  }else{  p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);  }  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,   (void*)p4, P4_COLLSEQ);  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);  return addr; } SQLITE_PRIVATE int sqlite3ExprIsVector(const Expr *pExpr){  return sqlite3ExprVectorSize(pExpr)>1; } SQLITE_PRIVATE int sqlite3ExprVectorSize(const Expr *pExpr){  u8 op = pExpr->op;  if( op==TK_REGISTER ) op = pExpr->op2;  if( op==TK_VECTOR ){  assert( ExprUseXList(pExpr) );  return pExpr->x.pList->nExpr;  }else if( op==TK_SELECT ){  assert( ExprUseXSelect(pExpr) );  return pExpr->x.pSelect->pEList->nExpr;  }else{  return 1;  } } SQLITE_PRIVATE Expr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){  assert( i<sqlite3ExprVectorSize(pVector) || pVector->op==TK_ERROR );  if( sqlite3ExprIsVector(pVector) ){  assert( pVector->op2==0 || pVector->op==TK_REGISTER );  if( pVector->op==TK_SELECT || pVector->op2==TK_SELECT ){  assert( ExprUseXSelect(pVector) );  return pVector->x.pSelect->pEList->a[i].pExpr;  }else{  assert( ExprUseXList(pVector) );  return pVector->x.pList->a[i].pExpr;  }  }  return pVector; } SQLITE_PRIVATE Expr *sqlite3ExprForVectorField(  Parse *pParse,  Expr *pVector,  int iField,  int nField ){  Expr *pRet;  if( pVector->op==TK_SELECT ){  assert( ExprUseXSelect(pVector) );  pRet = sqlite3PExpr(pParse, TK_SELECT_COLUMN, 0, 0);  if( pRet ){  pRet->iTable = nField;  pRet->iColumn = iField;  pRet->pLeft = pVector;  }  }else{  if( pVector->op==TK_VECTOR ){  Expr **ppVector;  assert( ExprUseXList(pVector) );  ppVector = &pVector->x.pList->a[iField].pExpr;  pVector = *ppVector;  if( IN_RENAME_OBJECT ){  *ppVector = 0;  return pVector;  }  }  pRet = sqlite3ExprDup(pParse->db, pVector, 0);  }  return pRet; } static int exprCodeSubselect(Parse *pParse, Expr *pExpr){  int reg = 0;
#ifndef SQLITE_OMIT_SUBQUERY
 if( pExpr->op==TK_SELECT ){  reg = sqlite3CodeSubselect(pParse, pExpr);  }
#endif
 return reg; } static int exprVectorRegister(  Parse *pParse,  Expr *pVector,  int iField,  int regSelect,  Expr **ppExpr,  int *pRegFree ){  u8 op = pVector->op;  assert( op==TK_VECTOR || op==TK_REGISTER || op==TK_SELECT || op==TK_ERROR );  if( op==TK_REGISTER ){  *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);  return pVector->iTable+iField;  }  if( op==TK_SELECT ){  assert( ExprUseXSelect(pVector) );  *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;   return regSelect+iField;  }  if( op==TK_VECTOR ){  assert( ExprUseXList(pVector) );  *ppExpr = pVector->x.pList->a[iField].pExpr;  return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);  }  return 0; } static void codeVectorCompare(  Parse *pParse,  Expr *pExpr,  int dest,  u8 op,  u8 p5 ){  Vdbe *v = pParse->pVdbe;  Expr *pLeft = pExpr->pLeft;  Expr *pRight = pExpr->pRight;  int nLeft = sqlite3ExprVectorSize(pLeft);  int i;  int regLeft = 0;  int regRight = 0;  u8 opx = op;  int addrCmp = 0;  int addrDone = sqlite3VdbeMakeLabel(pParse);  int isCommuted = ExprHasProperty(pExpr,EP_Commuted);  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );  if( pParse->nErr ) return;  if( nLeft!=sqlite3ExprVectorSize(pRight) ){  sqlite3ErrorMsg(pParse, "row value misused");  return;  }  assert( pExpr->op==TK_EQ || pExpr->op==TK_NE   || pExpr->op==TK_IS || pExpr->op==TK_ISNOT   || pExpr->op==TK_LT || pExpr->op==TK_GT   || pExpr->op==TK_LE || pExpr->op==TK_GE  );  assert( pExpr->op==op || (pExpr->op==TK_IS && op==TK_EQ)  || (pExpr->op==TK_ISNOT && op==TK_NE) );  assert( p5==0 || pExpr->op!=op );  assert( p5==SQLITE_NULLEQ || pExpr->op==op );  if( op==TK_LE ) opx = TK_LT;  if( op==TK_GE ) opx = TK_GT;  if( op==TK_NE ) opx = TK_EQ;  regLeft = exprCodeSubselect(pParse, pLeft);  regRight = exprCodeSubselect(pParse, pRight);  sqlite3VdbeAddOp2(v, OP_Integer, 1, dest);  for(i=0; 1 ; i++){  int regFree1 = 0, regFree2 = 0;  Expr *pL = 0, *pR = 0;  int r1, r2;  assert( i>=0 && i<nLeft );  if( addrCmp ) sqlite3VdbeJumpHere(v, addrCmp);  r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);  r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);  addrCmp = sqlite3VdbeCurrentAddr(v);  codeCompare(pParse, pL, pR, opx, r1, r2, addrDone, p5, isCommuted);  testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);  testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);  testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);  testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);  testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);  testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);  sqlite3ReleaseTempReg(pParse, regFree1);  sqlite3ReleaseTempReg(pParse, regFree2);  if( (opx==TK_LT || opx==TK_GT) && i<nLeft-1 ){  addrCmp = sqlite3VdbeAddOp0(v, OP_ElseEq);  testcase(opx==TK_LT); VdbeCoverageIf(v,opx==TK_LT);  testcase(opx==TK_GT); VdbeCoverageIf(v,opx==TK_GT);  }  if( p5==SQLITE_NULLEQ ){  sqlite3VdbeAddOp2(v, OP_Integer, 0, dest);  }else{  sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, dest, r2);  }  if( i==nLeft-1 ){  break;  }  if( opx==TK_EQ ){  sqlite3VdbeAddOp2(v, OP_NotNull, dest, addrDone); VdbeCoverage(v);  }else{  assert( op==TK_LT || op==TK_GT || op==TK_LE || op==TK_GE );  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);  if( i==nLeft-2 ) opx = op;  }  }  sqlite3VdbeJumpHere(v, addrCmp);  sqlite3VdbeResolveLabel(v, addrDone);  if( op==TK_NE ){  sqlite3VdbeAddOp2(v, OP_Not, dest, dest);  } }
#if SQLITE_MAX_EXPR_DEPTH>0
SQLITE_PRIVATE int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){  int rc = SQLITE_OK;  int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH];  if( nHeight>mxHeight ){  sqlite3ErrorMsg(pParse,   "Expression tree is too large (maximum depth %d)", mxHeight  );  rc = SQLITE_ERROR;  }  return rc; } static void heightOfExpr(const Expr *p, int *pnHeight){  if( p ){  if( p->nHeight>*pnHeight ){  *pnHeight = p->nHeight;  }  } } static void heightOfExprList(const ExprList *p, int *pnHeight){  if( p ){  int i;  for(i=0; i<p->nExpr; i++){  heightOfExpr(p->a[i].pExpr, pnHeight);  }  } } static void heightOfSelect(const Select *pSelect, int *pnHeight){  const Select *p;  for(p=pSelect; p; p=p->pPrior){  heightOfExpr(p->pWhere, pnHeight);  heightOfExpr(p->pHaving, pnHeight);  heightOfExpr(p->pLimit, pnHeight);  heightOfExprList(p->pEList, pnHeight);  heightOfExprList(p->pGroupBy, pnHeight);  heightOfExprList(p->pOrderBy, pnHeight);  } } static void exprSetHeight(Expr *p){  int nHeight = 0;  heightOfExpr(p->pLeft, &nHeight);  heightOfExpr(p->pRight, &nHeight);  if( ExprUseXSelect(p) ){  heightOfSelect(p->x.pSelect, &nHeight);  }else if( p->x.pList ){  heightOfExprList(p->x.pList, &nHeight);  p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);  }  p->nHeight = nHeight + 1; } SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){  if( pParse->nErr ) return;  exprSetHeight(p);  sqlite3ExprCheckHeight(pParse, p->nHeight); } SQLITE_PRIVATE int sqlite3SelectExprHeight(const Select *p){  int nHeight = 0;  heightOfSelect(p, &nHeight);  return nHeight; }
#else
SQLITE_PRIVATE void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){  if( pParse->nErr ) return;  if( p && ExprUseXList(p) && p->x.pList ){  p->flags |= EP_Propagate & sqlite3ExprListFlags(p->x.pList);  } }
#define exprSetHeight(y)
#endif
SQLITE_PRIVATE Expr *sqlite3ExprAlloc(  sqlite3 *db,  int op,  const Token *pToken,  int dequote ){  Expr *pNew;  int nExtra = 0;  int iValue = 0;  assert( db!=0 );  if( pToken ){  if( op!=TK_INTEGER || pToken->z==0  || sqlite3GetInt32(pToken->z, &iValue)==0 ){  nExtra = pToken->n+1;  assert( iValue>=0 );  }  }  pNew = sqlite3DbMallocRawNN(db, sizeof(Expr)+nExtra);  if( pNew ){  memset(pNew, 0, sizeof(Expr));  pNew->op = (u8)op;  pNew->iAgg = -1;  if( pToken ){  if( nExtra==0 ){  pNew->flags |= EP_IntValue|EP_Leaf|(iValue?EP_IsTrue:EP_IsFalse);  pNew->u.iValue = iValue;  }else{  pNew->u.zToken = (char*)&pNew[1];  assert( pToken->z!=0 || pToken->n==0 );  if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);  pNew->u.zToken[pToken->n] = 0;  if( dequote && sqlite3Isquote(pNew->u.zToken[0]) ){  sqlite3DequoteExpr(pNew);  }  }  }
#if SQLITE_MAX_EXPR_DEPTH>0
 pNew->nHeight = 1;
#endif
 }  return pNew; } SQLITE_PRIVATE Expr *sqlite3Expr(  sqlite3 *db,  int op,  const char *zToken ){  Token x;  x.z = zToken;  x.n = sqlite3Strlen30(zToken);  return sqlite3ExprAlloc(db, op, &x, 0); } SQLITE_PRIVATE void sqlite3ExprAttachSubtrees(  sqlite3 *db,  Expr *pRoot,  Expr *pLeft,  Expr *pRight ){  if( pRoot==0 ){  assert( db->mallocFailed );  sqlite3ExprDelete(db, pLeft);  sqlite3ExprDelete(db, pRight);  }else{  if( pRight ){  pRoot->pRight = pRight;  pRoot->flags |= EP_Propagate & pRight->flags;  }  if( pLeft ){  pRoot->pLeft = pLeft;  pRoot->flags |= EP_Propagate & pLeft->flags;  }  exprSetHeight(pRoot);  } } SQLITE_PRIVATE Expr *sqlite3PExpr(  Parse *pParse,  int op,  Expr *pLeft,  Expr *pRight ){  Expr *p;  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));  if( p ){  memset(p, 0, sizeof(Expr));  p->op = op & 0xff;  p->iAgg = -1;  sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);  sqlite3ExprCheckHeight(pParse, p->nHeight);  }else{  sqlite3ExprDelete(pParse->db, pLeft);  sqlite3ExprDelete(pParse->db, pRight);  }  return p; } SQLITE_PRIVATE void sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect){  if( pExpr ){  pExpr->x.pSelect = pSelect;  ExprSetProperty(pExpr, EP_xIsSelect|EP_Subquery);  sqlite3ExprSetHeightAndFlags(pParse, pExpr);  }else{  assert( pParse->db->mallocFailed );  sqlite3SelectDelete(pParse->db, pSelect);  } } SQLITE_PRIVATE Select *sqlite3ExprListToValues(Parse *pParse, int nElem, ExprList *pEList){  int ii;  Select *pRet = 0;  assert( nElem>1 );  for(ii=0; ii<pEList->nExpr; ii++){  Select *pSel;  Expr *pExpr = pEList->a[ii].pExpr;  int nExprElem;  if( pExpr->op==TK_VECTOR ){  assert( ExprUseXList(pExpr) );  nExprElem = pExpr->x.pList->nExpr;  }else{  nExprElem = 1;  }  if( nExprElem!=nElem ){  sqlite3ErrorMsg(pParse, "IN(...) element has %d term%s - expected %d",  nExprElem, nExprElem>1?"s":"", nElem  );  break;  }  assert( ExprUseXList(pExpr) );  pSel = sqlite3SelectNew(pParse, pExpr->x.pList, 0, 0, 0, 0, 0, SF_Values,0);  pExpr->x.pList = 0;  if( pSel ){  if( pRet ){  pSel->op = TK_ALL;  pSel->pPrior = pRet;  }  pRet = pSel;  }  }  if( pRet && pRet->pPrior ){  pRet->selFlags |= SF_MultiValue;  }  sqlite3ExprListDelete(pParse->db, pEList);  return pRet; } SQLITE_PRIVATE Expr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){  sqlite3 *db = pParse->db;  if( pLeft==0 ){  return pRight;  }else if( pRight==0 ){  return pLeft;  }else if( (ExprAlwaysFalse(pLeft) || ExprAlwaysFalse(pRight))   && !IN_RENAME_OBJECT  ){  sqlite3ExprDeferredDelete(pParse, pLeft);  sqlite3ExprDeferredDelete(pParse, pRight);  return sqlite3Expr(db, TK_INTEGER, "0");  }else{  return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);  } } SQLITE_PRIVATE Expr *sqlite3ExprFunction(  Parse *pParse,  ExprList *pList,  const Token *pToken,  int eDistinct ){  Expr *pNew;  sqlite3 *db = pParse->db;  assert( pToken );  pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);  if( pNew==0 ){  sqlite3ExprListDelete(db, pList);  return 0;  }  if( pList   && pList->nExpr > pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG]   && !pParse->nested  ){  sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);  }  pNew->x.pList = pList;  ExprSetProperty(pNew, EP_HasFunc);  assert( ExprUseXList(pNew) );  sqlite3ExprSetHeightAndFlags(pParse, pNew);  if( eDistinct==SF_Distinct ) ExprSetProperty(pNew, EP_Distinct);  return pNew; } SQLITE_PRIVATE void sqlite3ExprFunctionUsable(  Parse *pParse,  const Expr *pExpr,  const FuncDef *pDef ){  assert( !IN_RENAME_OBJECT );  assert( (pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE))!=0 );  if( ExprHasProperty(pExpr, EP_FromDDL) ){  if( (pDef->funcFlags & SQLITE_FUNC_DIRECT)!=0   || (pParse->db->flags & SQLITE_TrustedSchema)==0  ){  sqlite3ErrorMsg(pParse, "unsafe use of %s()", pDef->zName);  }  } } SQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){  sqlite3 *db = pParse->db;  const char *z;  ynVar x;  if( pExpr==0 ) return;  assert( !ExprHasProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );  z = pExpr->u.zToken;  assert( z!=0 );  assert( z[0]!=0 );  assert( n==(u32)sqlite3Strlen30(z) );  if( z[1]==0 ){  assert( z[0]=='?' );  x = (ynVar)(++pParse->nVar);  }else{  int doAdd = 0;  if( z[0]=='?' ){  i64 i;  int bOk;  if( n==2 ){  i = z[1]-'0';  bOk = 1;  }else{  bOk = 0==sqlite3Atoi64(&z[1], &i, n-1, SQLITE_UTF8);  }  testcase( i==0 );  testcase( i==1 );  testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]-1 );  testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );  if( bOk==0 || i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){  sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d",  db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);  return;  }  x = (ynVar)i;  if( x>pParse->nVar ){  pParse->nVar = (int)x;  doAdd = 1;  }else if( sqlite3VListNumToName(pParse->pVList, x)==0 ){  doAdd = 1;  }  }else{  x = (ynVar)sqlite3VListNameToNum(pParse->pVList, z, n);  if( x==0 ){  x = (ynVar)(++pParse->nVar);  doAdd = 1;  }  }  if( doAdd ){  pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, n, x);  }  }  pExpr->iColumn = x;  if( x>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){  sqlite3ErrorMsg(pParse, "too many SQL variables");  } } static SQLITE_NOINLINE void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){  assert( p!=0 );  assert( !ExprUseUValue(p) || p->u.iValue>=0 );  assert( !ExprUseYWin(p) || !ExprUseYSub(p) );  assert( !ExprUseYWin(p) || p->y.pWin!=0 || db->mallocFailed );  assert( p->op!=TK_FUNCTION || !ExprUseYSub(p) );
#ifdef SQLITE_DEBUG
 if( ExprHasProperty(p, EP_Leaf) && !ExprHasProperty(p, EP_TokenOnly) ){  assert( p->pLeft==0 );  assert( p->pRight==0 );  assert( !ExprUseXSelect(p) || p->x.pSelect==0 );  assert( !ExprUseXList(p) || p->x.pList==0 );  }
#endif
 if( !ExprHasProperty(p, (EP_TokenOnly|EP_Leaf)) ){  assert( (ExprUseXList(p) && p->x.pList==0) || p->pRight==0 );  if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);  if( p->pRight ){  assert( !ExprHasProperty(p, EP_WinFunc) );  sqlite3ExprDeleteNN(db, p->pRight);  }else if( ExprUseXSelect(p) ){  assert( !ExprHasProperty(p, EP_WinFunc) );  sqlite3SelectDelete(db, p->x.pSelect);  }else{  sqlite3ExprListDelete(db, p->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(p, EP_WinFunc) ){  sqlite3WindowDelete(db, p->y.pWin);  }
#endif
 }  }  if( ExprHasProperty(p, EP_MemToken) ){  assert( !ExprHasProperty(p, EP_IntValue) );  sqlite3DbFree(db, p->u.zToken);  }  if( !ExprHasProperty(p, EP_Static) ){  sqlite3DbFreeNN(db, p);  } } SQLITE_PRIVATE void sqlite3ExprDelete(sqlite3 *db, Expr *p){  if( p ) sqlite3ExprDeleteNN(db, p); } SQLITE_PRIVATE void sqlite3ExprDeferredDelete(Parse *pParse, Expr *pExpr){  pParse->pConstExpr =  sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr); } SQLITE_PRIVATE void sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){  if( p ){  if( IN_RENAME_OBJECT ){  sqlite3RenameExprUnmap(pParse, p);  }  sqlite3ExprDeleteNN(pParse->db, p);  } } static int exprStructSize(const Expr *p){  if( ExprHasProperty(p, EP_TokenOnly) ) return EXPR_TOKENONLYSIZE;  if( ExprHasProperty(p, EP_Reduced) ) return EXPR_REDUCEDSIZE;  return EXPR_FULLSIZE; } static int dupedExprStructSize(const Expr *p, int flags){  int nSize;  assert( flags==EXPRDUP_REDUCE || flags==0 );  assert( EXPR_FULLSIZE<=0xfff );  assert( (0xfff & (EP_Reduced|EP_TokenOnly))==0 );  if( 0==flags || p->op==TK_SELECT_COLUMN
#ifndef SQLITE_OMIT_WINDOWFUNC
  || ExprHasProperty(p, EP_WinFunc)
#endif
 ){  nSize = EXPR_FULLSIZE;  }else{  assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );  assert( !ExprHasProperty(p, EP_FromJoin) );  assert( !ExprHasProperty(p, EP_MemToken) );  assert( !ExprHasVVAProperty(p, EP_NoReduce) );  if( p->pLeft || p->x.pList ){  nSize = EXPR_REDUCEDSIZE | EP_Reduced;  }else{  assert( p->pRight==0 );  nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;  }  }  return nSize; } static int dupedExprNodeSize(const Expr *p, int flags){  int nByte = dupedExprStructSize(p, flags) & 0xfff;  if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){  nByte += sqlite3Strlen30NN(p->u.zToken)+1;  }  return ROUND8(nByte); } static int dupedExprSize(const Expr *p, int flags){  int nByte = 0;  if( p ){  nByte = dupedExprNodeSize(p, flags);  if( flags&EXPRDUP_REDUCE ){  nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);  }  }  return nByte; } static Expr *exprDup(sqlite3 *db, const Expr *p, int dupFlags, u8 **pzBuffer){  Expr *pNew;  u8 *zAlloc;  u32 staticFlag;  assert( db!=0 );  assert( p );  assert( dupFlags==0 || dupFlags==EXPRDUP_REDUCE );  assert( pzBuffer==0 || dupFlags==EXPRDUP_REDUCE );  if( pzBuffer ){  zAlloc = *pzBuffer;  staticFlag = EP_Static;  assert( zAlloc!=0 );  }else{  zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));  staticFlag = 0;  }  pNew = (Expr *)zAlloc;  if( pNew ){  const unsigned nStructSize = dupedExprStructSize(p, dupFlags);  const int nNewSize = nStructSize & 0xfff;  int nToken;  if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){  nToken = sqlite3Strlen30(p->u.zToken) + 1;  }else{  nToken = 0;  }  if( dupFlags ){  assert( ExprHasProperty(p, EP_Reduced)==0 );  memcpy(zAlloc, p, nNewSize);  }else{  u32 nSize = (u32)exprStructSize(p);  memcpy(zAlloc, p, nSize);  if( nSize<EXPR_FULLSIZE ){  memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);  }  }  pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);  pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);  pNew->flags |= staticFlag;  ExprClearVVAProperties(pNew);  if( dupFlags ){  ExprSetVVAProperty(pNew, EP_Immutable);  }  if( nToken ){  char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];  memcpy(zToken, p->u.zToken, nToken);  }  if( 0==((p->flags|pNew->flags) & (EP_TokenOnly|EP_Leaf)) ){  if( ExprUseXSelect(p) ){  pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);  }else{  pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);  }  }  if( ExprHasProperty(pNew, EP_Reduced|EP_TokenOnly|EP_WinFunc) ){  zAlloc += dupedExprNodeSize(p, dupFlags);  if( !ExprHasProperty(pNew, EP_TokenOnly|EP_Leaf) ){  pNew->pLeft = p->pLeft ?  exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc) : 0;  pNew->pRight = p->pRight ?   exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc) : 0;  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(p, EP_WinFunc) ){  pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);  assert( ExprHasProperty(pNew, EP_WinFunc) );  }
#endif
 if( pzBuffer ){  *pzBuffer = zAlloc;  }  }else{  if( !ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){  if( pNew->op==TK_SELECT_COLUMN ){  pNew->pLeft = p->pLeft;  assert( p->pRight==0 || p->pRight==p->pLeft  || ExprHasProperty(p->pLeft, EP_Subquery) );  }else{  pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);  }  pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);  }  }  }  return pNew; }
#ifndef SQLITE_OMIT_CTE
SQLITE_PRIVATE With *sqlite3WithDup(sqlite3 *db, With *p){  With *pRet = 0;  if( p ){  sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);  pRet = sqlite3DbMallocZero(db, nByte);  if( pRet ){  int i;  pRet->nCte = p->nCte;  for(i=0; i<p->nCte; i++){  pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);  pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);  pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);  }  }  }  return pRet; }
#else
# define sqlite3WithDup(x,y) 0
#endif
#ifndef SQLITE_OMIT_WINDOWFUNC
static int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_WinFunc) ){  Select *pSelect = pWalker->u.pSelect;  Window *pWin = pExpr->y.pWin;  assert( pWin );  assert( IsWindowFunc(pExpr) );  assert( pWin->ppThis==0 );  sqlite3WindowLink(pSelect, pWin);  }  return WRC_Continue; } static int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){  return p==pWalker->u.pSelect ? WRC_Continue : WRC_Prune; } static void gatherSelectWindows(Select *p){  Walker w;  w.xExprCallback = gatherSelectWindowsCallback;  w.xSelectCallback = gatherSelectWindowsSelectCallback;  w.xSelectCallback2 = 0;  w.pParse = 0;  w.u.pSelect = p;  sqlite3WalkSelect(&w, p); }
#endif
SQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3 *db, const Expr *p, int flags){  assert( flags==0 || flags==EXPRDUP_REDUCE );  return p ? exprDup(db, p, flags, 0) : 0; } SQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, const ExprList *p, int flags){  ExprList *pNew;  struct ExprList_item *pItem;  const struct ExprList_item *pOldItem;  int i;  Expr *pPriorSelectColOld = 0;  Expr *pPriorSelectColNew = 0;  assert( db!=0 );  if( p==0 ) return 0;  pNew = sqlite3DbMallocRawNN(db, sqlite3DbMallocSize(db, p));  if( pNew==0 ) return 0;  pNew->nExpr = p->nExpr;  pNew->nAlloc = p->nAlloc;  pItem = pNew->a;  pOldItem = p->a;  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){  Expr *pOldExpr = pOldItem->pExpr;  Expr *pNewExpr;  pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);  if( pOldExpr   && pOldExpr->op==TK_SELECT_COLUMN   && (pNewExpr = pItem->pExpr)!=0  ){  if( pNewExpr->pRight ){  pPriorSelectColOld = pOldExpr->pRight;  pPriorSelectColNew = pNewExpr->pRight;  pNewExpr->pLeft = pNewExpr->pRight;  }else{  if( pOldExpr->pLeft!=pPriorSelectColOld ){  pPriorSelectColOld = pOldExpr->pLeft;  pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, flags);  pNewExpr->pRight = pPriorSelectColNew;  }  pNewExpr->pLeft = pPriorSelectColNew;  }  }  pItem->zEName = sqlite3DbStrDup(db, pOldItem->zEName);  pItem->sortFlags = pOldItem->sortFlags;  pItem->eEName = pOldItem->eEName;  pItem->done = 0;  pItem->bNulls = pOldItem->bNulls;  pItem->bSorterRef = pOldItem->bSorterRef;  pItem->u = pOldItem->u;  }  return pNew; }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)  || !defined(SQLITE_OMIT_SUBQUERY)

SQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, const SrcList *p, int flags){  SrcList *pNew;  int i;  int nByte;  assert( db!=0 );  if( p==0 ) return 0;  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);  pNew = sqlite3DbMallocRawNN(db, nByte );  if( pNew==0 ) return 0;  pNew->nSrc = pNew->nAlloc = p->nSrc;  for(i=0; i<p->nSrc; i++){  SrcItem *pNewItem = &pNew->a[i];  const SrcItem *pOldItem = &p->a[i];  Table *pTab;  pNewItem->pSchema = pOldItem->pSchema;  pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);  pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);  pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);  pNewItem->fg = pOldItem->fg;  pNewItem->iCursor = pOldItem->iCursor;  pNewItem->addrFillSub = pOldItem->addrFillSub;  pNewItem->regReturn = pOldItem->regReturn;  if( pNewItem->fg.isIndexedBy ){  pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);  }  pNewItem->u2 = pOldItem->u2;  if( pNewItem->fg.isCte ){  pNewItem->u2.pCteUse->nUse++;  }  if( pNewItem->fg.isTabFunc ){  pNewItem->u1.pFuncArg =  sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);  }  pTab = pNewItem->pTab = pOldItem->pTab;  if( pTab ){  pTab->nTabRef++;  }  pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);  pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);  pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);  pNewItem->colUsed = pOldItem->colUsed;  }  return pNew; } SQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, const IdList *p){  IdList *pNew;  int i;  assert( db!=0 );  if( p==0 ) return 0;  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );  if( pNew==0 ) return 0;  pNew->nId = p->nId;  pNew->a = sqlite3DbMallocRawNN(db, p->nId*sizeof(p->a[0]) );  if( pNew->a==0 ){  sqlite3DbFreeNN(db, pNew);  return 0;  }  for(i=0; i<p->nId; i++){  struct IdList_item *pNewItem = &pNew->a[i];  struct IdList_item *pOldItem = &p->a[i];  pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);  pNewItem->idx = pOldItem->idx;  }  return pNew; } SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, const Select *pDup, int flags){  Select *pRet = 0;  Select *pNext = 0;  Select **pp = &pRet;  const Select *p;  assert( db!=0 );  for(p=pDup; p; p=p->pPrior){  Select *pNew = sqlite3DbMallocRawNN(db, sizeof(*p) );  if( pNew==0 ) break;  pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);  pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);  pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);  pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);  pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);  pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);  pNew->op = p->op;  pNew->pNext = pNext;  pNew->pPrior = 0;  pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);  pNew->iLimit = 0;  pNew->iOffset = 0;  pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;  pNew->addrOpenEphm[0] = -1;  pNew->addrOpenEphm[1] = -1;  pNew->nSelectRow = p->nSelectRow;  pNew->pWith = sqlite3WithDup(db, p->pWith);
#ifndef SQLITE_OMIT_WINDOWFUNC
 pNew->pWin = 0;  pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);  if( p->pWin && db->mallocFailed==0 ) gatherSelectWindows(pNew);
#endif
 pNew->selId = p->selId;  if( db->mallocFailed ){  pNew->pNext = 0;  sqlite3SelectDelete(db, pNew);  break;  }  *pp = pNew;  pp = &pNew->pPrior;  pNext = pNew;  }  return pRet; }
#else
SQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, const Select *p, int flags){  assert( p==0 );  return 0; }
#endif
static const struct ExprList_item zeroItem = {0}; SQLITE_PRIVATE SQLITE_NOINLINE ExprList *sqlite3ExprListAppendNew(  sqlite3 *db,  Expr *pExpr ){  struct ExprList_item *pItem;  ExprList *pList;  pList = sqlite3DbMallocRawNN(db, sizeof(ExprList)+sizeof(pList->a[0])*4 );  if( pList==0 ){  sqlite3ExprDelete(db, pExpr);  return 0;  }  pList->nAlloc = 4;  pList->nExpr = 1;  pItem = &pList->a[0];  *pItem = zeroItem;  pItem->pExpr = pExpr;  return pList; } SQLITE_PRIVATE SQLITE_NOINLINE ExprList *sqlite3ExprListAppendGrow(  sqlite3 *db,  ExprList *pList,  Expr *pExpr ){  struct ExprList_item *pItem;  ExprList *pNew;  pList->nAlloc *= 2;  pNew = sqlite3DbRealloc(db, pList,   sizeof(*pList)+(pList->nAlloc-1)*sizeof(pList->a[0]));  if( pNew==0 ){  sqlite3ExprListDelete(db, pList);  sqlite3ExprDelete(db, pExpr);  return 0;  }else{  pList = pNew;  }  pItem = &pList->a[pList->nExpr++];  *pItem = zeroItem;  pItem->pExpr = pExpr;  return pList; } SQLITE_PRIVATE ExprList *sqlite3ExprListAppend(  Parse *pParse,  ExprList *pList,  Expr *pExpr ){  struct ExprList_item *pItem;  if( pList==0 ){  return sqlite3ExprListAppendNew(pParse->db,pExpr);  }  if( pList->nAlloc<pList->nExpr+1 ){  return sqlite3ExprListAppendGrow(pParse->db,pList,pExpr);  }  pItem = &pList->a[pList->nExpr++];  *pItem = zeroItem;  pItem->pExpr = pExpr;  return pList; } SQLITE_PRIVATE ExprList *sqlite3ExprListAppendVector(  Parse *pParse,  ExprList *pList,  IdList *pColumns,  Expr *pExpr ){  sqlite3 *db = pParse->db;  int n;  int i;  int iFirst = pList ? pList->nExpr : 0;  if( NEVER(pColumns==0) ) goto vector_append_error;  if( pExpr==0 ) goto vector_append_error;  if( pExpr->op!=TK_SELECT && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){  sqlite3ErrorMsg(pParse, "%d columns assigned %d values",  pColumns->nId, n);  goto vector_append_error;  }  for(i=0; i<pColumns->nId; i++){  Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns->nId);  assert( pSubExpr!=0 || db->mallocFailed );  if( pSubExpr==0 ) continue;  pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);  if( pList ){  assert( pList->nExpr==iFirst+i+1 );  pList->a[pList->nExpr-1].zEName = pColumns->a[i].zName;  pColumns->a[i].zName = 0;  }  }  if( !db->mallocFailed && pExpr->op==TK_SELECT && ALWAYS(pList!=0) ){  Expr *pFirst = pList->a[iFirst].pExpr;  assert( pFirst!=0 );  assert( pFirst->op==TK_SELECT_COLUMN );  pFirst->pRight = pExpr;  pExpr = 0;  pFirst->iTable = pColumns->nId;  } vector_append_error:  sqlite3ExprUnmapAndDelete(pParse, pExpr);  sqlite3IdListDelete(db, pColumns);  return pList; } SQLITE_PRIVATE void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){  struct ExprList_item *pItem;  if( p==0 ) return;  assert( p->nExpr>0 );  assert( SQLITE_SO_UNDEFINED<0 && SQLITE_SO_ASC==0 && SQLITE_SO_DESC>0 );  assert( iSortOrder==SQLITE_SO_UNDEFINED   || iSortOrder==SQLITE_SO_ASC   || iSortOrder==SQLITE_SO_DESC  );  assert( eNulls==SQLITE_SO_UNDEFINED   || eNulls==SQLITE_SO_ASC   || eNulls==SQLITE_SO_DESC  );  pItem = &p->a[p->nExpr-1];  assert( pItem->bNulls==0 );  if( iSortOrder==SQLITE_SO_UNDEFINED ){  iSortOrder = SQLITE_SO_ASC;  }  pItem->sortFlags = (u8)iSortOrder;  if( eNulls!=SQLITE_SO_UNDEFINED ){  pItem->bNulls = 1;  if( iSortOrder!=eNulls ){  pItem->sortFlags |= KEYINFO_ORDER_BIGNULL;  }  } } SQLITE_PRIVATE void sqlite3ExprListSetName(  Parse *pParse,  ExprList *pList,  const Token *pName,  int dequote ){  assert( pList!=0 || pParse->db->mallocFailed!=0 );  assert( pParse->eParseMode!=PARSE_MODE_UNMAP || dequote==0 );  if( pList ){  struct ExprList_item *pItem;  assert( pList->nExpr>0 );  pItem = &pList->a[pList->nExpr-1];  assert( pItem->zEName==0 );  assert( pItem->eEName==ENAME_NAME );  pItem->zEName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);  if( dequote ){  sqlite3Dequote(pItem->zEName);  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenMap(pParse, (const void*)pItem->zEName, pName);  }  }  } } SQLITE_PRIVATE void sqlite3ExprListSetSpan(  Parse *pParse,  ExprList *pList,  const char *zStart,  const char *zEnd ){  sqlite3 *db = pParse->db;  assert( pList!=0 || db->mallocFailed!=0 );  if( pList ){  struct ExprList_item *pItem = &pList->a[pList->nExpr-1];  assert( pList->nExpr>0 );  if( pItem->zEName==0 ){  pItem->zEName = sqlite3DbSpanDup(db, zStart, zEnd);  pItem->eEName = ENAME_SPAN;  }  } } SQLITE_PRIVATE void sqlite3ExprListCheckLength(  Parse *pParse,  ExprList *pEList,  const char *zObject ){  int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];  testcase( pEList && pEList->nExpr==mx );  testcase( pEList && pEList->nExpr==mx+1 );  if( pEList && pEList->nExpr>mx ){  sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);  } } static SQLITE_NOINLINE void exprListDeleteNN(sqlite3 *db, ExprList *pList){  int i = pList->nExpr;  struct ExprList_item *pItem = pList->a;  assert( pList->nExpr>0 );  do{  sqlite3ExprDelete(db, pItem->pExpr);  sqlite3DbFree(db, pItem->zEName);  pItem++;  }while( --i>0 );  sqlite3DbFreeNN(db, pList); } SQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){  if( pList ) exprListDeleteNN(db, pList); } SQLITE_PRIVATE u32 sqlite3ExprListFlags(const ExprList *pList){  int i;  u32 m = 0;  assert( pList!=0 );  for(i=0; i<pList->nExpr; i++){   Expr *pExpr = pList->a[i].pExpr;   assert( pExpr!=0 );   m |= pExpr->flags;  }  return m; } SQLITE_PRIVATE int sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){  UNUSED_PARAMETER(NotUsed);  pWalker->eCode = 0;  return WRC_Abort; } SQLITE_PRIVATE u32 sqlite3IsTrueOrFalse(const char *zIn){  if( sqlite3StrICmp(zIn, "true")==0 ) return EP_IsTrue;  if( sqlite3StrICmp(zIn, "false")==0 ) return EP_IsFalse;  return 0; } SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr *pExpr){  u32 v;  assert( pExpr->op==TK_ID || pExpr->op==TK_STRING );  if( !ExprHasProperty(pExpr, EP_Quoted|EP_IntValue)   && (v = sqlite3IsTrueOrFalse(pExpr->u.zToken))!=0  ){  pExpr->op = TK_TRUEFALSE;  ExprSetProperty(pExpr, v);  return 1;  }  return 0; } SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr *pExpr){  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);  assert( pExpr->op==TK_TRUEFALSE );  assert( !ExprHasProperty(pExpr, EP_IntValue) );  assert( sqlite3StrICmp(pExpr->u.zToken,"true")==0   || sqlite3StrICmp(pExpr->u.zToken,"false")==0 );  return pExpr->u.zToken[4]==0; } SQLITE_PRIVATE Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){  assert( pExpr!=0 );  if( pExpr->op==TK_AND || pExpr->op==TK_OR ){  Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);  Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);  if( ExprAlwaysTrue(pLeft) || ExprAlwaysFalse(pRight) ){  pExpr = pExpr->op==TK_AND ? pRight : pLeft;  }else if( ExprAlwaysTrue(pRight) || ExprAlwaysFalse(pLeft) ){  pExpr = pExpr->op==TK_AND ? pLeft : pRight;  }  }  return pExpr; } static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){  if( pWalker->eCode==2 && ExprHasProperty(pExpr, EP_FromJoin) ){  pWalker->eCode = 0;  return WRC_Abort;  }  switch( pExpr->op ){  case TK_FUNCTION:  if( (pWalker->eCode>=4 || ExprHasProperty(pExpr,EP_ConstFunc))   && !ExprHasProperty(pExpr, EP_WinFunc)  ){  if( pWalker->eCode==5 ) ExprSetProperty(pExpr, EP_FromDDL);  return WRC_Continue;  }else{  pWalker->eCode = 0;  return WRC_Abort;  }  case TK_ID:  if( sqlite3ExprIdToTrueFalse(pExpr) ){  return WRC_Prune;  }  deliberate_fall_through  case TK_COLUMN:  case TK_AGG_FUNCTION:  case TK_AGG_COLUMN:  testcase( pExpr->op==TK_ID );  testcase( pExpr->op==TK_COLUMN );  testcase( pExpr->op==TK_AGG_FUNCTION );  testcase( pExpr->op==TK_AGG_COLUMN );  if( ExprHasProperty(pExpr, EP_FixedCol) && pWalker->eCode!=2 ){  return WRC_Continue;  }  if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){  return WRC_Continue;  }  deliberate_fall_through  case TK_IF_NULL_ROW:  case TK_REGISTER:  case TK_DOT:  testcase( pExpr->op==TK_REGISTER );  testcase( pExpr->op==TK_IF_NULL_ROW );  testcase( pExpr->op==TK_DOT );  pWalker->eCode = 0;  return WRC_Abort;  case TK_VARIABLE:  if( pWalker->eCode==5 ){  pExpr->op = TK_NULL;  }else if( pWalker->eCode==4 ){  pWalker->eCode = 0;  return WRC_Abort;  }  deliberate_fall_through  default:  testcase( pExpr->op==TK_SELECT );  testcase( pExpr->op==TK_EXISTS );  return WRC_Continue;  } } static int exprIsConst(Expr *p, int initFlag, int iCur){  Walker w;  w.eCode = initFlag;  w.xExprCallback = exprNodeIsConstant;  w.xSelectCallback = sqlite3SelectWalkFail;
#ifdef SQLITE_DEBUG
 w.xSelectCallback2 = sqlite3SelectWalkAssert2;
#endif
 w.u.iCur = iCur;  sqlite3WalkExpr(&w, p);  return w.eCode; } SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr *p){  return exprIsConst(p, 1, 0); } SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr *p){  return exprIsConst(p, 2, 0); } SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr *p, int iCur){  return exprIsConst(p, 3, iCur); } static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){  ExprList *pGroupBy = pWalker->u.pGroupBy;  int i;  for(i=0; i<pGroupBy->nExpr; i++){  Expr *p = pGroupBy->a[i].pExpr;  if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){  CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);  if( sqlite3IsBinary(pColl) ){  return WRC_Prune;  }  }  }  if( ExprUseXSelect(pExpr) ){  pWalker->eCode = 0;  return WRC_Abort;  }  return exprNodeIsConstant(pWalker, pExpr); } SQLITE_PRIVATE int sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){  Walker w;  w.eCode = 1;  w.xExprCallback = exprNodeIsConstantOrGroupBy;  w.xSelectCallback = 0;  w.u.pGroupBy = pGroupBy;  w.pParse = pParse;  sqlite3WalkExpr(&w, p);  return w.eCode; } SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){  assert( isInit==0 || isInit==1 );  return exprIsConst(p, 4+isInit, 0); }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
SQLITE_PRIVATE int sqlite3ExprContainsSubquery(Expr *p){  Walker w;  w.eCode = 1;  w.xExprCallback = sqlite3ExprWalkNoop;  w.xSelectCallback = sqlite3SelectWalkFail;
#ifdef SQLITE_DEBUG
 w.xSelectCallback2 = sqlite3SelectWalkAssert2;
#endif
 sqlite3WalkExpr(&w, p);  return w.eCode==0; }
#endif
SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr *p, int *pValue){  int rc = 0;  if( NEVER(p==0) ) return 0;  assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0   || sqlite3GetInt32(p->u.zToken, &rc)==0 );  if( p->flags & EP_IntValue ){  *pValue = p->u.iValue;  return 1;  }  switch( p->op ){  case TK_UPLUS: {  rc = sqlite3ExprIsInteger(p->pLeft, pValue);  break;  }  case TK_UMINUS: {  int v = 0;  if( sqlite3ExprIsInteger(p->pLeft, &v) ){  assert( ((unsigned int)v)!=0x80000000 );  *pValue = -v;  rc = 1;  }  break;  }  default: break;  }  return rc; } SQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr *p){  u8 op;  assert( p!=0 );  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){  p = p->pLeft;  assert( p!=0 );  }  op = p->op;  if( op==TK_REGISTER ) op = p->op2;  switch( op ){  case TK_INTEGER:  case TK_STRING:  case TK_FLOAT:  case TK_BLOB:  return 0;  case TK_COLUMN:  assert( ExprUseYTab(p) );  return ExprHasProperty(p, EP_CanBeNull) ||   p->y.pTab==0 ||   (p->iColumn>=0  && p->y.pTab->aCol!=0  && p->y.pTab->aCol[p->iColumn].notNull==0);  default:  return 1;  } } SQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){  u8 op;  int unaryMinus = 0;  if( aff==SQLITE_AFF_BLOB ) return 1;  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){  if( p->op==TK_UMINUS ) unaryMinus = 1;  p = p->pLeft;  }  op = p->op;  if( op==TK_REGISTER ) op = p->op2;  switch( op ){  case TK_INTEGER: {  return aff>=SQLITE_AFF_NUMERIC;  }  case TK_FLOAT: {  return aff>=SQLITE_AFF_NUMERIC;  }  case TK_STRING: {  return !unaryMinus && aff==SQLITE_AFF_TEXT;  }  case TK_BLOB: {  return !unaryMinus;  }  case TK_COLUMN: {  assert( p->iTable>=0 );  return aff>=SQLITE_AFF_NUMERIC && p->iColumn<0;  }  default: {  return 0;  }  } } SQLITE_PRIVATE int sqlite3IsRowid(const char *z){  if( sqlite3StrICmp(z, "_ROWID_")==0 ) return 1;  if( sqlite3StrICmp(z, "ROWID")==0 ) return 1;  if( sqlite3StrICmp(z, "OID")==0 ) return 1;  return 0; }
#ifndef SQLITE_OMIT_SUBQUERY
static Select *isCandidateForInOpt(const Expr *pX){  Select *p;  SrcList *pSrc;  ExprList *pEList;  Table *pTab;  int i;  if( !ExprUseXSelect(pX) ) return 0;  if( ExprHasProperty(pX, EP_VarSelect) ) return 0;  p = pX->x.pSelect;  if( p->pPrior ) return 0;  if( p->selFlags & (SF_Distinct|SF_Aggregate) ){  testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );  testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );  return 0;  }  assert( p->pGroupBy==0 );  if( p->pLimit ) return 0;  if( p->pWhere ) return 0;  pSrc = p->pSrc;  assert( pSrc!=0 );  if( pSrc->nSrc!=1 ) return 0;  if( pSrc->a[0].pSelect ) return 0;  pTab = pSrc->a[0].pTab;  assert( pTab!=0 );  assert( !IsView(pTab) );  if( IsVirtual(pTab) ) return 0;  pEList = p->pEList;  assert( pEList!=0 );  for(i=0; i<pEList->nExpr; i++){  Expr *pRes = pEList->a[i].pExpr;  if( pRes->op!=TK_COLUMN ) return 0;  assert( pRes->iTable==pSrc->a[0].iCursor );  }  return p; }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){  int addr1;  sqlite3VdbeAddOp2(v, OP_Integer, 0, regHasNull);  addr1 = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_Column, iCur, 0, regHasNull);  sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);  VdbeComment((v, "first_entry_in(%d)", iCur));  sqlite3VdbeJumpHere(v, addr1); }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
static int sqlite3InRhsIsConstant(Expr *pIn){  Expr *pLHS;  int res;  assert( !ExprHasProperty(pIn, EP_xIsSelect) );  pLHS = pIn->pLeft;  pIn->pLeft = 0;  res = sqlite3ExprIsConstant(pIn);  pIn->pLeft = pLHS;  return res; }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3FindInIndex(  Parse *pParse,  Expr *pX,  u32 inFlags,  int *prRhsHasNull,  int *aiMap,  int *piTab ){  Select *p;  int eType = 0;  int iTab = pParse->nTab++;  int mustBeUnique;  Vdbe *v = sqlite3GetVdbe(pParse);  assert( pX->op==TK_IN );  mustBeUnique = (inFlags & IN_INDEX_LOOP)!=0;  if( prRhsHasNull && ExprUseXSelect(pX) ){  int i;  ExprList *pEList = pX->x.pSelect->pEList;  for(i=0; i<pEList->nExpr; i++){  if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) break;  }  if( i==pEList->nExpr ){  prRhsHasNull = 0;  }  }  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){  sqlite3 *db = pParse->db;  Table *pTab;  int iDb;  ExprList *pEList = p->pEList;  int nExpr = pEList->nExpr;  assert( p->pEList!=0 );  assert( p->pEList->a[0].pExpr!=0 );  assert( p->pSrc!=0 );  pTab = p->pSrc->a[0].pTab;  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iDb>=0 && iDb<SQLITE_MAX_DB );  sqlite3CodeVerifySchema(pParse, iDb);  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);  assert(v);  if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){  int iAddr = sqlite3VdbeAddOp0(v, OP_Once);  VdbeCoverage(v);  sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);  eType = IN_INDEX_ROWID;  ExplainQueryPlan((pParse, 0,  "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR",pTab->zName));  sqlite3VdbeJumpHere(v, iAddr);  }else{  Index *pIdx;  int affinity_ok = 1;  int i;  for(i=0; i<nExpr && affinity_ok; i++){  Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);  int iCol = pEList->a[i].pExpr->iColumn;  char idxaff = sqlite3TableColumnAffinity(pTab,iCol);  char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);  testcase( cmpaff==SQLITE_AFF_BLOB );  testcase( cmpaff==SQLITE_AFF_TEXT );  switch( cmpaff ){  case SQLITE_AFF_BLOB:  break;  case SQLITE_AFF_TEXT:  assert( idxaff==SQLITE_AFF_TEXT );  break;  default:  affinity_ok = sqlite3IsNumericAffinity(idxaff);  }  }  if( affinity_ok ){  for(pIdx=pTab->pIndex; pIdx && eType==0; pIdx=pIdx->pNext){  Bitmask colUsed;  Bitmask mCol;  if( pIdx->nColumn<nExpr ) continue;  if( pIdx->pPartIdxWhere!=0 ) continue;  testcase( pIdx->nColumn==BMS-2 );  testcase( pIdx->nColumn==BMS-1 );  if( pIdx->nColumn>=BMS-1 ) continue;  if( mustBeUnique ){  if( pIdx->nKeyCol>nExpr   ||(pIdx->nColumn>nExpr && !IsUniqueIndex(pIdx))  ){  continue;  }  }  colUsed = 0;  for(i=0; i<nExpr; i++){  Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);  Expr *pRhs = pEList->a[i].pExpr;  CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);  int j;  assert( pReq!=0 || pRhs->iColumn==XN_ROWID   || pParse->nErr || db->mallocFailed );  for(j=0; j<nExpr; j++){  if( pIdx->aiColumn[j]!=pRhs->iColumn ) continue;  assert( pIdx->azColl[j] );  if( pReq!=0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j])!=0 ){  continue;  }  break;  }  if( j==nExpr ) break;  mCol = MASKBIT(j);  if( mCol & colUsed ) break;  colUsed |= mCol;  if( aiMap ) aiMap[i] = j;  }  assert( i==nExpr || colUsed!=(MASKBIT(nExpr)-1) );  if( colUsed==(MASKBIT(nExpr)-1) ){  int iAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  ExplainQueryPlan((pParse, 0,  "USING INDEX %s FOR IN-OPERATOR",pIdx->zName));  sqlite3VdbeAddOp3(v, OP_OpenRead, iTab, pIdx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);  VdbeComment((v, "%s", pIdx->zName));  assert( IN_INDEX_INDEX_DESC == IN_INDEX_INDEX_ASC+1 );  eType = IN_INDEX_INDEX_ASC + pIdx->aSortOrder[0];  if( prRhsHasNull ){
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
 i64 mask = (1<<nExpr)-1;  sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed,  iTab, 0, 0, (u8*)&mask, P4_INT64);
#endif
 *prRhsHasNull = ++pParse->nMem;  if( nExpr==1 ){  sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);  }  }  sqlite3VdbeJumpHere(v, iAddr);  }  }  }  }  }  if( eType==0   && (inFlags & IN_INDEX_NOOP_OK)   && ExprUseXList(pX)   && (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr<=2)  ){  eType = IN_INDEX_NOOP;  }  if( eType==0 ){  u32 savedNQueryLoop = pParse->nQueryLoop;  int rMayHaveNull = 0;  eType = IN_INDEX_EPH;  if( inFlags & IN_INDEX_LOOP ){  pParse->nQueryLoop = 0;  }else if( prRhsHasNull ){  *prRhsHasNull = rMayHaveNull = ++pParse->nMem;  }  assert( pX->op==TK_IN );  sqlite3CodeRhsOfIN(pParse, pX, iTab);  if( rMayHaveNull ){  sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);  }  pParse->nQueryLoop = savedNQueryLoop;  }  if( aiMap && eType!=IN_INDEX_INDEX_ASC && eType!=IN_INDEX_INDEX_DESC ){  int i, n;  n = sqlite3ExprVectorSize(pX->pLeft);  for(i=0; i<n; i++) aiMap[i] = i;  }  *piTab = iTab;  return eType; }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
static char *exprINAffinity(Parse *pParse, const Expr *pExpr){  Expr *pLeft = pExpr->pLeft;  int nVal = sqlite3ExprVectorSize(pLeft);  Select *pSelect = ExprUseXSelect(pExpr) ? pExpr->x.pSelect : 0;  char *zRet;  assert( pExpr->op==TK_IN );  zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);  if( zRet ){  int i;  for(i=0; i<nVal; i++){  Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);  char a = sqlite3ExprAffinity(pA);  if( pSelect ){  zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);  }else{  zRet[i] = a;  }  }  zRet[nVal] = '\0';  }  return zRet; }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE void sqlite3SubselectError(Parse *pParse, int nActual, int nExpect){  if( pParse->nErr==0 ){  const char *zFmt = "sub-select returns %d columns - expected %d";  sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);  } }
#endif
SQLITE_PRIVATE void sqlite3VectorErrorMsg(Parse *pParse, Expr *pExpr){
#ifndef SQLITE_OMIT_SUBQUERY
 if( ExprUseXSelect(pExpr) ){  sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);  }else
#endif
 {  sqlite3ErrorMsg(pParse, "row value misused");  } }
#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE void sqlite3CodeRhsOfIN(  Parse *pParse,  Expr *pExpr,  int iTab ){  int addrOnce = 0;  int addr;  Expr *pLeft;  KeyInfo *pKeyInfo = 0;  int nVal;  Vdbe *v;  v = pParse->pVdbe;  assert( v!=0 );  if( !ExprHasProperty(pExpr, EP_VarSelect) && pParse->iSelfTab==0 ){  if( ExprHasProperty(pExpr, EP_Subrtn) ){  addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  if( ExprUseXSelect(pExpr) ){  ExplainQueryPlan((pParse, 0, "REUSE LIST SUBQUERY %d",  pExpr->x.pSelect->selId));  }  assert( ExprUseYSub(pExpr) );  sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,  pExpr->y.sub.iAddr);  sqlite3VdbeAddOp2(v, OP_OpenDup, iTab, pExpr->iTable);  sqlite3VdbeJumpHere(v, addrOnce);  return;  }  assert( !ExprUseYWin(pExpr) );  ExprSetProperty(pExpr, EP_Subrtn);  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );  pExpr->y.sub.regReturn = ++pParse->nMem;  pExpr->y.sub.iAddr =  sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;  VdbeComment((v, "return address"));  addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  }  pLeft = pExpr->pLeft;  nVal = sqlite3ExprVectorSize(pLeft);  pExpr->iTable = iTab;  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pExpr->iTable, nVal);
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
 if( ExprUseXSelect(pExpr) ){  VdbeComment((v, "Result of SELECT %u", pExpr->x.pSelect->selId));  }else{  VdbeComment((v, "RHS of IN operator"));  }
#endif
 pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);  if( ExprUseXSelect(pExpr) ){  Select *pSelect = pExpr->x.pSelect;  ExprList *pEList = pSelect->pEList;  ExplainQueryPlan((pParse, 1, "%sLIST SUBQUERY %d",  addrOnce?"":"CORRELATED ", pSelect->selId  ));  if( ALWAYS(pEList->nExpr==nVal) ){  Select *pCopy;  SelectDest dest;  int i;  int rc;  sqlite3SelectDestInit(&dest, SRT_Set, iTab);  dest.zAffSdst = exprINAffinity(pParse, pExpr);  pSelect->iLimit = 0;  testcase( pSelect->selFlags & SF_Distinct );  testcase( pKeyInfo==0 );  pCopy = sqlite3SelectDup(pParse->db, pSelect, 0);  rc = pParse->db->mallocFailed ? 1 :sqlite3Select(pParse, pCopy, &dest);  sqlite3SelectDelete(pParse->db, pCopy);  sqlite3DbFree(pParse->db, dest.zAffSdst);  if( rc ){  sqlite3KeyInfoUnref(pKeyInfo);  return;  }  assert( pKeyInfo!=0 );  assert( pEList!=0 );  assert( pEList->nExpr>0 );  assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );  for(i=0; i<nVal; i++){  Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);  pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(  pParse, p, pEList->a[i].pExpr  );  }  }  }else if( ALWAYS(pExpr->x.pList!=0) ){  char affinity;  int i;  ExprList *pList = pExpr->x.pList;  struct ExprList_item *pItem;  int r1, r2;  affinity = sqlite3ExprAffinity(pLeft);  if( affinity<=SQLITE_AFF_NONE ){  affinity = SQLITE_AFF_BLOB;  }else if( affinity==SQLITE_AFF_REAL ){  affinity = SQLITE_AFF_NUMERIC;  }  if( pKeyInfo ){  assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );  pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);  }  r1 = sqlite3GetTempReg(pParse);  r2 = sqlite3GetTempReg(pParse);  for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){  Expr *pE2 = pItem->pExpr;  if( addrOnce && !sqlite3ExprIsConstant(pE2) ){  sqlite3VdbeChangeToNoop(v, addrOnce);  ExprClearProperty(pExpr, EP_Subrtn);  addrOnce = 0;  }  sqlite3ExprCode(pParse, pE2, r1);  sqlite3VdbeAddOp4(v, OP_MakeRecord, r1, 1, r2, &affinity, 1);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r2, r1, 1);  }  sqlite3ReleaseTempReg(pParse, r1);  sqlite3ReleaseTempReg(pParse, r2);  }  if( pKeyInfo ){  sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);  }  if( addrOnce ){  sqlite3VdbeJumpHere(v, addrOnce);  assert( ExprUseYSub(pExpr) );  sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);  sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);  sqlite3ClearTempRegCache(pParse);  } }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){  int addrOnce = 0;  int rReg = 0;  Select *pSel;  SelectDest dest;  int nReg;  Expr *pLimit;  Vdbe *v = pParse->pVdbe;  assert( v!=0 );  if( pParse->nErr ) return 0;  testcase( pExpr->op==TK_EXISTS );  testcase( pExpr->op==TK_SELECT );  assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );  assert( ExprUseXSelect(pExpr) );  pSel = pExpr->x.pSelect;  if( ExprHasProperty(pExpr, EP_Subrtn) ){  ExplainQueryPlan((pParse, 0, "REUSE SUBQUERY %d", pSel->selId));  assert( ExprUseYSub(pExpr) );  sqlite3VdbeAddOp2(v, OP_Gosub, pExpr->y.sub.regReturn,  pExpr->y.sub.iAddr);  return pExpr->iTable;  }  assert( !ExprUseYWin(pExpr) );  assert( !ExprHasProperty(pExpr, EP_Reduced|EP_TokenOnly) );  ExprSetProperty(pExpr, EP_Subrtn);  pExpr->y.sub.regReturn = ++pParse->nMem;  pExpr->y.sub.iAddr =  sqlite3VdbeAddOp2(v, OP_Integer, 0, pExpr->y.sub.regReturn) + 1;  VdbeComment((v, "return address"));  if( !ExprHasProperty(pExpr, EP_VarSelect) ){  addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  }  ExplainQueryPlan((pParse, 1, "%sSCALAR SUBQUERY %d",  addrOnce?"":"CORRELATED ", pSel->selId));  nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;  sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);  pParse->nMem += nReg;  if( pExpr->op==TK_SELECT ){  dest.eDest = SRT_Mem;  dest.iSdst = dest.iSDParm;  dest.nSdst = nReg;  sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);  VdbeComment((v, "Init subquery result"));  }else{  dest.eDest = SRT_Exists;  sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);  VdbeComment((v, "Init EXISTS result"));  }  if( pSel->pLimit ){  sqlite3 *db = pParse->db;  pLimit = sqlite3Expr(db, TK_INTEGER, "0");  if( pLimit ){  pLimit->affExpr = SQLITE_AFF_NUMERIC;  pLimit = sqlite3PExpr(pParse, TK_NE,  sqlite3ExprDup(db, pSel->pLimit->pLeft, 0), pLimit);  }  sqlite3ExprDelete(db, pSel->pLimit->pLeft);  pSel->pLimit->pLeft = pLimit;  }else{  pLimit = sqlite3Expr(pParse->db, TK_INTEGER, "1");  pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);  }  pSel->iLimit = 0;  if( sqlite3Select(pParse, pSel, &dest) ){  if( pParse->nErr ){  pExpr->op2 = pExpr->op;  pExpr->op = TK_ERROR;  }  return 0;  }  pExpr->iTable = rReg = dest.iSDParm;  ExprSetVVAProperty(pExpr, EP_NoReduce);  if( addrOnce ){  sqlite3VdbeJumpHere(v, addrOnce);  }  assert( ExprUseYSub(pExpr) );  sqlite3VdbeAddOp1(v, OP_Return, pExpr->y.sub.regReturn);  sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);  sqlite3ClearTempRegCache(pParse);  return rReg; }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
SQLITE_PRIVATE int sqlite3ExprCheckIN(Parse *pParse, Expr *pIn){  int nVector = sqlite3ExprVectorSize(pIn->pLeft);  if( ExprUseXSelect(pIn) && !pParse->db->mallocFailed ){  if( nVector!=pIn->x.pSelect->pEList->nExpr ){  sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);  return 1;  }  }else if( nVector!=1 ){  sqlite3VectorErrorMsg(pParse, pIn->pLeft);  return 1;  }  return 0; }
#endif
#ifndef SQLITE_OMIT_SUBQUERY
static void sqlite3ExprCodeIN(  Parse *pParse,  Expr *pExpr,  int destIfFalse,  int destIfNull ){  int rRhsHasNull = 0;  int eType;  int rLhs;  int rLhsOrig;  Vdbe *v;  int *aiMap = 0;  char *zAff = 0;  int nVector;  int iDummy;  Expr *pLeft;  int i;  int destStep2;  int destStep6 = 0;  int addrTruthOp;  int destNotNull;  int addrTop;  int iTab = 0;  u8 okConstFactor = pParse->okConstFactor;  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );  pLeft = pExpr->pLeft;  if( sqlite3ExprCheckIN(pParse, pExpr) ) return;  zAff = exprINAffinity(pParse, pExpr);  nVector = sqlite3ExprVectorSize(pExpr->pLeft);  aiMap = (int*)sqlite3DbMallocZero(  pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1  );  if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;  v = pParse->pVdbe;  assert( v!=0 );  VdbeNoopComment((v, "begin IN expr"));  eType = sqlite3FindInIndex(pParse, pExpr,   IN_INDEX_MEMBERSHIP | IN_INDEX_NOOP_OK,   destIfFalse==destIfNull ? 0 : &rRhsHasNull,   aiMap, &iTab);  assert( pParse->nErr || nVector==1 || eType==IN_INDEX_EPH   || eType==IN_INDEX_INDEX_ASC || eType==IN_INDEX_INDEX_DESC  );
#ifdef SQLITE_DEBUG
 for(i=0; i<nVector; i++){  int j, cnt;  for(cnt=j=0; j<nVector; j++) if( aiMap[j]==i ) cnt++;  assert( cnt==1 );  }
#endif
 assert( pParse->okConstFactor==okConstFactor );  pParse->okConstFactor = 0;  rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);  pParse->okConstFactor = okConstFactor;  for(i=0; i<nVector && aiMap[i]==i; i++){}  if( i==nVector ){  rLhs = rLhsOrig;  }else{  rLhs = sqlite3GetTempRange(pParse, nVector);  for(i=0; i<nVector; i++){  sqlite3VdbeAddOp3(v, OP_Copy, rLhsOrig+i, rLhs+aiMap[i], 0);  }  }  if( eType==IN_INDEX_NOOP ){  ExprList *pList;  CollSeq *pColl;  int labelOk = sqlite3VdbeMakeLabel(pParse);  int r2, regToFree;  int regCkNull = 0;  int ii;  assert( ExprUseXList(pExpr) );  pList = pExpr->x.pList;  pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);  if( destIfNull!=destIfFalse ){  regCkNull = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_BitAnd, rLhs, rLhs, regCkNull);  }  for(ii=0; ii<pList->nExpr; ii++){  r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);  if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){  sqlite3VdbeAddOp3(v, OP_BitAnd, regCkNull, r2, regCkNull);  }  sqlite3ReleaseTempReg(pParse, regToFree);  if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){  int op = rLhs!=r2 ? OP_Eq : OP_NotNull;  sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2,  (void*)pColl, P4_COLLSEQ);  VdbeCoverageIf(v, ii<pList->nExpr-1 && op==OP_Eq);  VdbeCoverageIf(v, ii==pList->nExpr-1 && op==OP_Eq);  VdbeCoverageIf(v, ii<pList->nExpr-1 && op==OP_NotNull);  VdbeCoverageIf(v, ii==pList->nExpr-1 && op==OP_NotNull);  sqlite3VdbeChangeP5(v, zAff[0]);  }else{  int op = rLhs!=r2 ? OP_Ne : OP_IsNull;  assert( destIfNull==destIfFalse );  sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2,  (void*)pColl, P4_COLLSEQ);  VdbeCoverageIf(v, op==OP_Ne);  VdbeCoverageIf(v, op==OP_IsNull);  sqlite3VdbeChangeP5(v, zAff[0] | SQLITE_JUMPIFNULL);  }  }  if( regCkNull ){  sqlite3VdbeAddOp2(v, OP_IsNull, regCkNull, destIfNull); VdbeCoverage(v);  sqlite3VdbeGoto(v, destIfFalse);  }  sqlite3VdbeResolveLabel(v, labelOk);  sqlite3ReleaseTempReg(pParse, regCkNull);  goto sqlite3ExprCodeIN_finished;  }  if( destIfNull==destIfFalse ){  destStep2 = destIfFalse;  }else{  destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);  }  if( pParse->nErr ) goto sqlite3ExprCodeIN_finished;  for(i=0; i<nVector; i++){  Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);  if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;  if( sqlite3ExprCanBeNull(p) ){  sqlite3VdbeAddOp2(v, OP_IsNull, rLhs+i, destStep2);  VdbeCoverage(v);  }  }  if( eType==IN_INDEX_ROWID ){  sqlite3VdbeAddOp3(v, OP_SeekRowid, iTab, destIfFalse, rLhs);  VdbeCoverage(v);  addrTruthOp = sqlite3VdbeAddOp0(v, OP_Goto);  }else{  sqlite3VdbeAddOp4(v, OP_Affinity, rLhs, nVector, 0, zAff, nVector);  if( destIfFalse==destIfNull ){  sqlite3VdbeAddOp4Int(v, OP_NotFound, iTab, destIfFalse,   rLhs, nVector); VdbeCoverage(v);  goto sqlite3ExprCodeIN_finished;  }  addrTruthOp = sqlite3VdbeAddOp4Int(v, OP_Found, iTab, 0,  rLhs, nVector); VdbeCoverage(v);  }  if( rRhsHasNull && nVector==1 ){  sqlite3VdbeAddOp2(v, OP_NotNull, rRhsHasNull, destIfFalse);  VdbeCoverage(v);  }  if( destIfFalse==destIfNull ) sqlite3VdbeGoto(v, destIfFalse);  if( destStep6 ) sqlite3VdbeResolveLabel(v, destStep6);  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, destIfFalse);  VdbeCoverage(v);  if( nVector>1 ){  destNotNull = sqlite3VdbeMakeLabel(pParse);  }else{  destNotNull = destIfFalse;  }  for(i=0; i<nVector; i++){  Expr *p;  CollSeq *pColl;  int r3 = sqlite3GetTempReg(pParse);  p = sqlite3VectorFieldSubexpr(pLeft, i);  pColl = sqlite3ExprCollSeq(pParse, p);  sqlite3VdbeAddOp3(v, OP_Column, iTab, i, r3);  sqlite3VdbeAddOp4(v, OP_Ne, rLhs+i, destNotNull, r3,  (void*)pColl, P4_COLLSEQ);  VdbeCoverage(v);  sqlite3ReleaseTempReg(pParse, r3);  }  sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);  if( nVector>1 ){  sqlite3VdbeResolveLabel(v, destNotNull);  sqlite3VdbeAddOp2(v, OP_Next, iTab, addrTop+1);  VdbeCoverage(v);  sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);  }  sqlite3VdbeJumpHere(v, addrTruthOp); sqlite3ExprCodeIN_finished:  if( rLhs!=rLhsOrig ) sqlite3ReleaseTempReg(pParse, rLhs);  VdbeComment((v, "end IN expr")); sqlite3ExprCodeIN_oom_error:  sqlite3DbFree(pParse->db, aiMap);  sqlite3DbFree(pParse->db, zAff); }
#endif
#ifndef SQLITE_OMIT_FLOATING_POINT
static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){  if( ALWAYS(z!=0) ){  double value;  sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);  assert( !sqlite3IsNaN(value) );  if( negateFlag ) value = -value;  sqlite3VdbeAddOp4Dup8(v, OP_Real, 0, iMem, 0, (u8*)&value, P4_REAL);  } }
#endif
static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){  Vdbe *v = pParse->pVdbe;  if( pExpr->flags & EP_IntValue ){  int i = pExpr->u.iValue;  assert( i>=0 );  if( negFlag ) i = -i;  sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);  }else{  int c;  i64 value;  const char *z = pExpr->u.zToken;  assert( z!=0 );  c = sqlite3DecOrHexToI64(z, &value);  if( (c==3 && !negFlag) || (c==2) || (negFlag && value==SMALLEST_INT64)){
#ifdef SQLITE_OMIT_FLOATING_POINT
 sqlite3ErrorMsg(pParse, "oversized integer: %s%s", negFlag ? "-" : "", z);
#else
#ifndef SQLITE_OMIT_HEX_INTEGER
 if( sqlite3_strnicmp(z,"0x",2)==0 ){  sqlite3ErrorMsg(pParse, "hex literal too big: %s%s", negFlag?"-":"",z);  }else
#endif
 {  codeReal(v, z, negFlag, iMem);  }
#endif
 }else{  if( negFlag ){ value = c==3 ? SMALLEST_INT64 : -value; }  sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, iMem, 0, (u8*)&value, P4_INT64);  }  } } SQLITE_PRIVATE void sqlite3ExprCodeLoadIndexColumn(  Parse *pParse,  Index *pIdx,  int iTabCur,  int iIdxCol,  int regOut ){  i16 iTabCol = pIdx->aiColumn[iIdxCol];  if( iTabCol==XN_EXPR ){  assert( pIdx->aColExpr );  assert( pIdx->aColExpr->nExpr>iIdxCol );  pParse->iSelfTab = iTabCur + 1;  sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);  pParse->iSelfTab = 0;  }else{  sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,  iTabCol, regOut);  } }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
SQLITE_PRIVATE void sqlite3ExprCodeGeneratedColumn(  Parse *pParse,  Table *pTab,  Column *pCol,  int regOut ){  int iAddr;  Vdbe *v = pParse->pVdbe;  assert( v!=0 );  assert( pParse->iSelfTab!=0 );  if( pParse->iSelfTab>0 ){  iAddr = sqlite3VdbeAddOp3(v, OP_IfNullRow, pParse->iSelfTab-1, 0, regOut);  }else{  iAddr = 0;  }  sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab,pCol), regOut);  if( pCol->affinity>=SQLITE_AFF_TEXT ){  sqlite3VdbeAddOp4(v, OP_Affinity, regOut, 1, 0, &pCol->affinity, 1);  }  if( iAddr ) sqlite3VdbeJumpHere(v, iAddr); }
#endif
SQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(  Vdbe *v,  Table *pTab,  int iTabCur,  int iCol,  int regOut ){  Column *pCol;  assert( v!=0 );  if( pTab==0 ){  sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);  return;  }  if( iCol<0 || iCol==pTab->iPKey ){  sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);  }else{  int op;  int x;  if( IsVirtual(pTab) ){  op = OP_VColumn;  x = iCol;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 }else if( (pCol = &pTab->aCol[iCol])->colFlags & COLFLAG_VIRTUAL ){  Parse *pParse = sqlite3VdbeParser(v);  if( pCol->colFlags & COLFLAG_BUSY ){  sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"",  pCol->zCnName);  }else{  int savedSelfTab = pParse->iSelfTab;  pCol->colFlags |= COLFLAG_BUSY;  pParse->iSelfTab = iTabCur+1;  sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, regOut);  pParse->iSelfTab = savedSelfTab;  pCol->colFlags &= ~COLFLAG_BUSY;  }  return;
#endif
 }else if( !HasRowid(pTab) ){  testcase( iCol!=sqlite3TableColumnToStorage(pTab, iCol) );  x = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), iCol);  op = OP_Column;  }else{  x = sqlite3TableColumnToStorage(pTab,iCol);  testcase( x!=iCol );  op = OP_Column;  }  sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);  sqlite3ColumnDefault(v, pTab, iCol, regOut);  } } SQLITE_PRIVATE int sqlite3ExprCodeGetColumn(  Parse *pParse,  Table *pTab,  int iColumn,  int iTable,  int iReg,  u8 p5 ){  assert( pParse->pVdbe!=0 );  sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pTab, iTable, iColumn, iReg);  if( p5 ){  VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);  if( pOp->opcode==OP_Column ) pOp->p5 = p5;  }  return iReg; } SQLITE_PRIVATE void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){  sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg); } static void exprToRegister(Expr *pExpr, int iReg){  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);  if( NEVER(p==0) ) return;  p->op2 = p->op;  p->op = TK_REGISTER;  p->iTable = iReg;  ExprClearProperty(p, EP_Skip); } static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){  int iResult;  int nResult = sqlite3ExprVectorSize(p);  if( nResult==1 ){  iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);  }else{  *piFreeable = 0;  if( p->op==TK_SELECT ){
#if SQLITE_OMIT_SUBQUERY
 iResult = 0;
#else
 iResult = sqlite3CodeSubselect(pParse, p);
#endif
 }else{  int i;  iResult = pParse->nMem+1;  pParse->nMem += nResult;  assert( ExprUseXList(p) );  for(i=0; i<nResult; i++){  sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);  }  }  }  return iResult; } static void setDoNotMergeFlagOnCopy(Vdbe *v){  if( sqlite3VdbeGetOp(v, -1)->opcode==OP_Copy ){  sqlite3VdbeChangeP5(v, 1);  } } static int exprCodeInlineFunction(  Parse *pParse,  ExprList *pFarg,  int iFuncId,  int target ){  int nFarg;  Vdbe *v = pParse->pVdbe;  assert( v!=0 );  assert( pFarg!=0 );  nFarg = pFarg->nExpr;  assert( nFarg>0 );  switch( iFuncId ){  case INLINEFUNC_coalesce: {  int endCoalesce = sqlite3VdbeMakeLabel(pParse);  int i;  assert( nFarg>=2 );  sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);  for(i=1; i<nFarg; i++){  sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);  VdbeCoverage(v);  sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);  }  setDoNotMergeFlagOnCopy(v);  sqlite3VdbeResolveLabel(v, endCoalesce);  break;  }  case INLINEFUNC_iif: {  Expr caseExpr;  memset(&caseExpr, 0, sizeof(caseExpr));  caseExpr.op = TK_CASE;  caseExpr.x.pList = pFarg;  return sqlite3ExprCodeTarget(pParse, &caseExpr, target);  }  default: {  assert( nFarg==1 || nFarg==2 );  target = sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);  break;  }
#if !defined(SQLITE_UNTESTABLE)
 case INLINEFUNC_expr_compare: {  assert( nFarg==2 );  sqlite3VdbeAddOp2(v, OP_Integer,   sqlite3ExprCompare(0,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),   target);  break;  }  case INLINEFUNC_expr_implies_expr: {  assert( nFarg==2 );  sqlite3VdbeAddOp2(v, OP_Integer,   sqlite3ExprImpliesExpr(pParse,pFarg->a[0].pExpr, pFarg->a[1].pExpr,-1),   target);  break;  }  case INLINEFUNC_implies_nonnull_row: {  Expr *pA1;  assert( nFarg==2 );  pA1 = pFarg->a[1].pExpr;  if( pA1->op==TK_COLUMN ){  sqlite3VdbeAddOp2(v, OP_Integer,   sqlite3ExprImpliesNonNullRow(pFarg->a[0].pExpr,pA1->iTable),   target);  }else{  sqlite3VdbeAddOp2(v, OP_Null, 0, target);  }  break;  }  case INLINEFUNC_affinity: {  const char *azAff[] = { "blob", "text", "numeric", "integer", "real" };  char aff;  assert( nFarg==1 );  aff = sqlite3ExprAffinity(pFarg->a[0].pExpr);  sqlite3VdbeLoadString(v, target,  (aff<=SQLITE_AFF_NONE) ? "none" : azAff[aff-SQLITE_AFF_BLOB]);  break;  }
#endif
 }  return target; } SQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){  Vdbe *v = pParse->pVdbe;  int op;  int inReg = target;  int regFree1 = 0;  int regFree2 = 0;  int r1, r2;  Expr tempX;  int p5 = 0;  assert( target>0 && target<=pParse->nMem );  assert( v!=0 ); expr_code_doover:  if( pExpr==0 ){  op = TK_NULL;  }else{  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );  op = pExpr->op;  }  switch( op ){  case TK_AGG_COLUMN: {  AggInfo *pAggInfo = pExpr->pAggInfo;  struct AggInfo_col *pCol;  assert( pAggInfo!=0 );  assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );  pCol = &pAggInfo->aCol[pExpr->iAgg];  if( !pAggInfo->directMode ){  assert( pCol->iMem>0 );  return pCol->iMem;  }else if( pAggInfo->useSortingIdx ){  Table *pTab = pCol->pTab;  sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,  pCol->iSorterColumn, target);  if( pCol->iColumn<0 ){  VdbeComment((v,"%s.rowid",pTab->zName));  }else{  VdbeComment((v,"%s.%s",  pTab->zName, pTab->aCol[pCol->iColumn].zCnName));  if( pTab->aCol[pCol->iColumn].affinity==SQLITE_AFF_REAL ){  sqlite3VdbeAddOp1(v, OP_RealAffinity, target);  }  }  return target;  }  deliberate_fall_through  }  case TK_COLUMN: {  int iTab = pExpr->iTable;  int iReg;  if( ExprHasProperty(pExpr, EP_FixedCol) ){  int aff;  iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);  assert( ExprUseYTab(pExpr) );  if( pExpr->y.pTab ){  aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);  }else{  aff = pExpr->affExpr;  }  if( aff>SQLITE_AFF_BLOB ){  static const char zAff[] = "B\000C\000D\000E";  assert( SQLITE_AFF_BLOB=='A' );  assert( SQLITE_AFF_TEXT=='B' );  sqlite3VdbeAddOp4(v, OP_Affinity, iReg, 1, 0,  &zAff[(aff-'B')*2], P4_STATIC);  }  return iReg;  }  if( iTab<0 ){  if( pParse->iSelfTab<0 ){  Column *pCol;  Table *pTab;  int iSrc;  int iCol = pExpr->iColumn;  assert( ExprUseYTab(pExpr) );  pTab = pExpr->y.pTab;  assert( pTab!=0 );  assert( iCol>=XN_ROWID );  assert( iCol<pTab->nCol );  if( iCol<0 ){  return -1-pParse->iSelfTab;  }  pCol = pTab->aCol + iCol;  testcase( iCol!=sqlite3TableColumnToStorage(pTab,iCol) );  iSrc = sqlite3TableColumnToStorage(pTab, iCol) - pParse->iSelfTab;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pCol->colFlags & COLFLAG_GENERATED ){  if( pCol->colFlags & COLFLAG_BUSY ){  sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"",  pCol->zCnName);  return 0;  }  pCol->colFlags |= COLFLAG_BUSY;  if( pCol->colFlags & COLFLAG_NOTAVAIL ){  sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc);  }  pCol->colFlags &= ~(COLFLAG_BUSY|COLFLAG_NOTAVAIL);  return iSrc;  }else
#endif
 if( pCol->affinity==SQLITE_AFF_REAL ){  sqlite3VdbeAddOp2(v, OP_SCopy, iSrc, target);  sqlite3VdbeAddOp1(v, OP_RealAffinity, target);  return target;  }else{  return iSrc;  }  }else{  iTab = pParse->iSelfTab - 1;  }  }  assert( ExprUseYTab(pExpr) );  iReg = sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,   pExpr->iColumn, iTab, target,   pExpr->op2);  if( pExpr->y.pTab==0 && pExpr->affExpr==SQLITE_AFF_REAL ){  sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);  }  return iReg;  }  case TK_INTEGER: {  codeInteger(pParse, pExpr, 0, target);  return target;  }  case TK_TRUEFALSE: {  sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);  return target;  }
#ifndef SQLITE_OMIT_FLOATING_POINT
 case TK_FLOAT: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  codeReal(v, pExpr->u.zToken, 0, target);  return target;  }
#endif
 case TK_STRING: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3VdbeLoadString(v, target, pExpr->u.zToken);  return target;  }  default: {  assert( op==TK_NULL || op==TK_ERROR || pParse->db->mallocFailed );  sqlite3VdbeAddOp2(v, OP_Null, 0, target);  return target;  }
#ifndef SQLITE_OMIT_BLOB_LITERAL
 case TK_BLOB: {  int n;  const char *z;  char *zBlob;  assert( !ExprHasProperty(pExpr, EP_IntValue) );  assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );  assert( pExpr->u.zToken[1]=='\'' );  z = &pExpr->u.zToken[2];  n = sqlite3Strlen30(z) - 1;  assert( z[n]=='\'' );  zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);  sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);  return target;  }
#endif
 case TK_VARIABLE: {  assert( !ExprHasProperty(pExpr, EP_IntValue) );  assert( pExpr->u.zToken!=0 );  assert( pExpr->u.zToken[0]!=0 );  sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);  if( pExpr->u.zToken[1]!=0 ){  const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);  assert( pExpr->u.zToken[0]=='?' || (z && !strcmp(pExpr->u.zToken, z)) );  pParse->pVList[0] = 0;  sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);  }  return target;  }  case TK_REGISTER: {  return pExpr->iTable;  }
#ifndef SQLITE_OMIT_CAST
 case TK_CAST: {  inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);  if( inReg!=target ){  sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);  inReg = target;  }  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3VdbeAddOp2(v, OP_Cast, target,  sqlite3AffinityType(pExpr->u.zToken, 0));  return inReg;  }
#endif
 case TK_IS:  case TK_ISNOT:  op = (op==TK_IS) ? TK_EQ : TK_NE;  p5 = SQLITE_NULLEQ;  case TK_LT:  case TK_LE:  case TK_GT:  case TK_GE:  case TK_NE:  case TK_EQ: {  Expr *pLeft = pExpr->pLeft;  if( sqlite3ExprIsVector(pLeft) ){  codeVectorCompare(pParse, pExpr, target, op, p5);  }else{  r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);  sqlite3VdbeAddOp2(v, OP_Integer, 1, inReg);  codeCompare(pParse, pLeft, pExpr->pRight, op, r1, r2,  sqlite3VdbeCurrentAddr(v)+2, p5,  ExprHasProperty(pExpr,EP_Commuted));  assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);  assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);  assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);  assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);  assert(TK_EQ==OP_Eq); testcase(op==OP_Eq); VdbeCoverageIf(v,op==OP_Eq);  assert(TK_NE==OP_Ne); testcase(op==OP_Ne); VdbeCoverageIf(v,op==OP_Ne);  if( p5==SQLITE_NULLEQ ){  sqlite3VdbeAddOp2(v, OP_Integer, 0, inReg);  }else{  sqlite3VdbeAddOp3(v, OP_ZeroOrNull, r1, inReg, r2);  }  testcase( regFree1==0 );  testcase( regFree2==0 );  }  break;  }  case TK_AND:  case TK_OR:  case TK_PLUS:  case TK_STAR:  case TK_MINUS:  case TK_REM:  case TK_BITAND:  case TK_BITOR:  case TK_SLASH:  case TK_LSHIFT:  case TK_RSHIFT:  case TK_CONCAT: {  assert( TK_AND==OP_And ); testcase( op==TK_AND );  assert( TK_OR==OP_Or ); testcase( op==TK_OR );  assert( TK_PLUS==OP_Add );  testcase( op==TK_PLUS );  assert( TK_MINUS==OP_Subtract );  testcase( op==TK_MINUS );  assert( TK_REM==OP_Remainder ); testcase( op==TK_REM );  assert( TK_BITAND==OP_BitAnd ); testcase( op==TK_BITAND );  assert( TK_BITOR==OP_BitOr ); testcase( op==TK_BITOR );  assert( TK_SLASH==OP_Divide );  testcase( op==TK_SLASH );  assert( TK_LSHIFT==OP_ShiftLeft );  testcase( op==TK_LSHIFT );  assert( TK_RSHIFT==OP_ShiftRight ); testcase( op==TK_RSHIFT );  assert( TK_CONCAT==OP_Concat ); testcase( op==TK_CONCAT );  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);  sqlite3VdbeAddOp3(v, op, r2, r1, target);  testcase( regFree1==0 );  testcase( regFree2==0 );  break;  }  case TK_UMINUS: {  Expr *pLeft = pExpr->pLeft;  assert( pLeft );  if( pLeft->op==TK_INTEGER ){  codeInteger(pParse, pLeft, 1, target);  return target;
#ifndef SQLITE_OMIT_FLOATING_POINT
 }else if( pLeft->op==TK_FLOAT ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  codeReal(v, pLeft->u.zToken, 1, target);  return target;
#endif
 }else{  tempX.op = TK_INTEGER;  tempX.flags = EP_IntValue|EP_TokenOnly;  tempX.u.iValue = 0;  ExprClearVVAProperties(&tempX);  r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);  sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);  testcase( regFree2==0 );  }  break;  }  case TK_BITNOT:  case TK_NOT: {  assert( TK_BITNOT==OP_BitNot );  testcase( op==TK_BITNOT );  assert( TK_NOT==OP_Not );  testcase( op==TK_NOT );  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  testcase( regFree1==0 );  sqlite3VdbeAddOp2(v, op, r1, inReg);  break;  }  case TK_TRUTH: {  int isTrue;  int bNormal;  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  testcase( regFree1==0 );  isTrue = sqlite3ExprTruthValue(pExpr->pRight);  bNormal = pExpr->op2==TK_IS;  testcase( isTrue && bNormal);  testcase( !isTrue && bNormal);  sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);  break;  }  case TK_ISNULL:  case TK_NOTNULL: {  int addr;  assert( TK_ISNULL==OP_IsNull );  testcase( op==TK_ISNULL );  assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );  sqlite3VdbeAddOp2(v, OP_Integer, 1, target);  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  testcase( regFree1==0 );  addr = sqlite3VdbeAddOp1(v, op, r1);  VdbeCoverageIf(v, op==TK_ISNULL);  VdbeCoverageIf(v, op==TK_NOTNULL);  sqlite3VdbeAddOp2(v, OP_Integer, 0, target);  sqlite3VdbeJumpHere(v, addr);  break;  }  case TK_AGG_FUNCTION: {  AggInfo *pInfo = pExpr->pAggInfo;  if( pInfo==0   || NEVER(pExpr->iAgg<0)   || NEVER(pExpr->iAgg>=pInfo->nFunc)  ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);  }else{  return pInfo->aFunc[pExpr->iAgg].iMem;  }  break;  }  case TK_FUNCTION: {  ExprList *pFarg;  int nFarg;  FuncDef *pDef;  const char *zId;  u32 constMask = 0;  int i;  sqlite3 *db = pParse->db;  u8 enc = ENC(db);  CollSeq *pColl = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(pExpr, EP_WinFunc) ){  return pExpr->y.pWin->regResult;  }
#endif
 if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){  return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);  }  assert( !ExprHasProperty(pExpr, EP_TokenOnly) );  assert( ExprUseXList(pExpr) );  pFarg = pExpr->x.pList;  nFarg = pFarg ? pFarg->nExpr : 0;  assert( !ExprHasProperty(pExpr, EP_IntValue) );  zId = pExpr->u.zToken;  pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
 if( pDef==0 && pParse->explain ){  pDef = sqlite3FindFunction(db, "unknown", nFarg, enc, 0);  }
#endif
 if( pDef==0 || pDef->xFinalize!=0 ){  sqlite3ErrorMsg(pParse, "unknown function: %s()", zId);  break;  }  if( pDef->funcFlags & SQLITE_FUNC_INLINE ){  assert( (pDef->funcFlags & SQLITE_FUNC_UNSAFE)==0 );  assert( (pDef->funcFlags & SQLITE_FUNC_DIRECT)==0 );  return exprCodeInlineFunction(pParse, pFarg,   SQLITE_PTR_TO_INT(pDef->pUserData), target);  }else if( pDef->funcFlags & (SQLITE_FUNC_DIRECT|SQLITE_FUNC_UNSAFE) ){  sqlite3ExprFunctionUsable(pParse, pExpr, pDef);  }  for(i=0; i<nFarg; i++){  if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){  testcase( i==31 );  constMask |= MASKBIT32(i);  }  if( (pDef->funcFlags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){  pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);  }  }  if( pFarg ){  if( constMask ){  r1 = pParse->nMem+1;  pParse->nMem += nFarg;  }else{  r1 = sqlite3GetTempRange(pParse, nFarg);  }  if( (pDef->funcFlags & (SQLITE_FUNC_LENGTH|SQLITE_FUNC_TYPEOF))!=0 ){  u8 exprOp;  assert( nFarg==1 );  assert( pFarg->a[0].pExpr!=0 );  exprOp = pFarg->a[0].pExpr->op;  if( exprOp==TK_COLUMN || exprOp==TK_AGG_COLUMN ){  assert( SQLITE_FUNC_LENGTH==OPFLAG_LENGTHARG );  assert( SQLITE_FUNC_TYPEOF==OPFLAG_TYPEOFARG );  testcase( pDef->funcFlags & OPFLAG_LENGTHARG );  pFarg->a[0].pExpr->op2 =  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);  }  }  sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,  SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);  }else{  r1 = 0;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( nFarg>=2 && ExprHasProperty(pExpr, EP_InfixFunc) ){  pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);  }else if( nFarg>0 ){  pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);  }
#endif
 if( pDef->funcFlags & SQLITE_FUNC_NEEDCOLL ){  if( !pColl ) pColl = db->pDfltColl;  sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);  }
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
 if( (pDef->funcFlags & SQLITE_FUNC_OFFSET)!=0 && ALWAYS(pFarg!=0) ){  Expr *pArg = pFarg->a[0].pExpr;  if( pArg->op==TK_COLUMN ){  sqlite3VdbeAddOp3(v, OP_Offset, pArg->iTable, pArg->iColumn, target);  }else{  sqlite3VdbeAddOp2(v, OP_Null, 0, target);  }  }else
#endif
 {  sqlite3VdbeAddFunctionCall(pParse, constMask, r1, target, nFarg,   pDef, pExpr->op2);  }  if( nFarg ){  if( constMask==0 ){  sqlite3ReleaseTempRange(pParse, r1, nFarg);  }else{  sqlite3VdbeReleaseRegisters(pParse, r1, nFarg, constMask, 1);  }  }  return target;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case TK_EXISTS:  case TK_SELECT: {  int nCol;  testcase( op==TK_EXISTS );  testcase( op==TK_SELECT );  if( pParse->db->mallocFailed ){  return 0;  }else if( op==TK_SELECT   && ALWAYS( ExprUseXSelect(pExpr) )   && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1  ){  sqlite3SubselectError(pParse, nCol, 1);  }else{  return sqlite3CodeSubselect(pParse, pExpr);  }  break;  }  case TK_SELECT_COLUMN: {  int n;  if( pExpr->pLeft->iTable==0 ){  pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);  }  assert( pExpr->pLeft->op==TK_SELECT || pExpr->pLeft->op==TK_ERROR );  n = sqlite3ExprVectorSize(pExpr->pLeft);  if( pExpr->iTable!=n ){  sqlite3ErrorMsg(pParse, "%d columns assigned %d values",  pExpr->iTable, n);  }  return pExpr->pLeft->iTable + pExpr->iColumn;  }  case TK_IN: {  int destIfFalse = sqlite3VdbeMakeLabel(pParse);  int destIfNull = sqlite3VdbeMakeLabel(pParse);  sqlite3VdbeAddOp2(v, OP_Null, 0, target);  sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);  sqlite3VdbeAddOp2(v, OP_Integer, 1, target);  sqlite3VdbeResolveLabel(v, destIfFalse);  sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);  sqlite3VdbeResolveLabel(v, destIfNull);  return target;  }
#endif
 case TK_BETWEEN: {  exprCodeBetween(pParse, pExpr, target, 0, 0);  return target;  }  case TK_SPAN:  case TK_COLLATE:  case TK_UPLUS: {  pExpr = pExpr->pLeft;  goto expr_code_doover;  }  case TK_TRIGGER: {  Table *pTab;  int iCol;  int p1;  assert( ExprUseYTab(pExpr) );  pTab = pExpr->y.pTab;  iCol = pExpr->iColumn;  p1 = pExpr->iTable * (pTab->nCol+1) + 1   + sqlite3TableColumnToStorage(pTab, iCol);  assert( pExpr->iTable==0 || pExpr->iTable==1 );  assert( iCol>=-1 && iCol<pTab->nCol );  assert( pTab->iPKey<0 || iCol!=pTab->iPKey );  assert( p1>=0 && p1<(pTab->nCol*2+2) );  sqlite3VdbeAddOp2(v, OP_Param, p1, target);  VdbeComment((v, "r[%d]=%s.%s", target,  (pExpr->iTable ? "new" : "old"),  (pExpr->iColumn<0 ? "rowid" : pExpr->y.pTab->aCol[iCol].zCnName)  ));
#ifndef SQLITE_OMIT_FLOATING_POINT
 if( iCol>=0 && pTab->aCol[iCol].affinity==SQLITE_AFF_REAL ){  sqlite3VdbeAddOp1(v, OP_RealAffinity, target);  }
#endif
 break;  }  case TK_VECTOR: {  sqlite3ErrorMsg(pParse, "row value misused");  break;  }  case TK_IF_NULL_ROW: {  int addrINR;  u8 okConstFactor = pParse->okConstFactor;  addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);  pParse->okConstFactor = 0;  inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);  pParse->okConstFactor = okConstFactor;  sqlite3VdbeJumpHere(v, addrINR);  sqlite3VdbeChangeP3(v, addrINR, inReg);  break;  }  case TK_CASE: {  int endLabel;  int nextCase;  int nExpr;  int i;  ExprList *pEList;  struct ExprList_item *aListelem;  Expr opCompare;  Expr *pX;  Expr *pTest = 0;  Expr *pDel = 0;  sqlite3 *db = pParse->db;  assert( ExprUseXList(pExpr) && pExpr->x.pList!=0 );  assert(pExpr->x.pList->nExpr > 0);  pEList = pExpr->x.pList;  aListelem = pEList->a;  nExpr = pEList->nExpr;  endLabel = sqlite3VdbeMakeLabel(pParse);  if( (pX = pExpr->pLeft)!=0 ){  pDel = sqlite3ExprDup(db, pX, 0);  if( db->mallocFailed ){  sqlite3ExprDelete(db, pDel);  break;  }  testcase( pX->op==TK_COLUMN );  exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));  testcase( regFree1==0 );  memset(&opCompare, 0, sizeof(opCompare));  opCompare.op = TK_EQ;  opCompare.pLeft = pDel;  pTest = &opCompare;  regFree1 = 0;  }  for(i=0; i<nExpr-1; i=i+2){  if( pX ){  assert( pTest!=0 );  opCompare.pRight = aListelem[i].pExpr;  }else{  pTest = aListelem[i].pExpr;  }  nextCase = sqlite3VdbeMakeLabel(pParse);  testcase( pTest->op==TK_COLUMN );  sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);  testcase( aListelem[i+1].pExpr->op==TK_COLUMN );  sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);  sqlite3VdbeGoto(v, endLabel);  sqlite3VdbeResolveLabel(v, nextCase);  }  if( (nExpr&1)!=0 ){  sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);  }else{  sqlite3VdbeAddOp2(v, OP_Null, 0, target);  }  sqlite3ExprDelete(db, pDel);  setDoNotMergeFlagOnCopy(v);  sqlite3VdbeResolveLabel(v, endLabel);  break;  }
#ifndef SQLITE_OMIT_TRIGGER
 case TK_RAISE: {  assert( pExpr->affExpr==OE_Rollback   || pExpr->affExpr==OE_Abort   || pExpr->affExpr==OE_Fail   || pExpr->affExpr==OE_Ignore  );  if( !pParse->pTriggerTab && !pParse->nested ){  sqlite3ErrorMsg(pParse,   "RAISE() may only be used within a trigger-program");  return 0;  }  if( pExpr->affExpr==OE_Abort ){  sqlite3MayAbort(pParse);  }  assert( !ExprHasProperty(pExpr, EP_IntValue) );  if( pExpr->affExpr==OE_Ignore ){  sqlite3VdbeAddOp4(  v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);  VdbeCoverage(v);  }else{  sqlite3HaltConstraint(pParse,   pParse->pTriggerTab ? SQLITE_CONSTRAINT_TRIGGER : SQLITE_ERROR,   pExpr->affExpr, pExpr->u.zToken, 0, 0);  }  break;  }
#endif
 }  sqlite3ReleaseTempReg(pParse, regFree1);  sqlite3ReleaseTempReg(pParse, regFree2);  return inReg; } SQLITE_PRIVATE int sqlite3ExprCodeRunJustOnce(  Parse *pParse,  Expr *pExpr,  int regDest ){  ExprList *p;  assert( ConstFactorOk(pParse) );  p = pParse->pConstExpr;  if( regDest<0 && p ){  struct ExprList_item *pItem;  int i;  for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){  if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){  return pItem->u.iConstExprReg;  }  }  }  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);  if( pExpr!=0 && ExprHasProperty(pExpr, EP_HasFunc) ){  Vdbe *v = pParse->pVdbe;  int addr;  assert( v );  addr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  pParse->okConstFactor = 0;  if( !pParse->db->mallocFailed ){  if( regDest<0 ) regDest = ++pParse->nMem;  sqlite3ExprCode(pParse, pExpr, regDest);  }  pParse->okConstFactor = 1;  sqlite3ExprDelete(pParse->db, pExpr);  sqlite3VdbeJumpHere(v, addr);  }else{  p = sqlite3ExprListAppend(pParse, p, pExpr);  if( p ){   struct ExprList_item *pItem = &p->a[p->nExpr-1];   pItem->reusable = regDest<0;   if( regDest<0 ) regDest = ++pParse->nMem;   pItem->u.iConstExprReg = regDest;  }  pParse->pConstExpr = p;  }  return regDest; } SQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){  int r2;  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);  if( ConstFactorOk(pParse)   && ALWAYS(pExpr!=0)   && pExpr->op!=TK_REGISTER   && sqlite3ExprIsConstantNotJoin(pExpr)  ){  *pReg = 0;  r2 = sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1);  }else{  int r1 = sqlite3GetTempReg(pParse);  r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);  if( r2==r1 ){  *pReg = r1;  }else{  sqlite3ReleaseTempReg(pParse, r1);  *pReg = 0;  }  }  return r2; } SQLITE_PRIVATE void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){  int inReg;  assert( pExpr==0 || !ExprHasVVAProperty(pExpr,EP_Immutable) );  assert( target>0 && target<=pParse->nMem );  assert( pParse->pVdbe!=0 || pParse->db->mallocFailed );  if( pParse->pVdbe==0 ) return;  inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);  if( inReg!=target ){  u8 op;  if( ALWAYS(pExpr) && ExprHasProperty(pExpr,EP_Subquery) ){  op = OP_Copy;  }else{  op = OP_SCopy;  }  sqlite3VdbeAddOp2(pParse->pVdbe, op, inReg, target);  } } SQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){  sqlite3 *db = pParse->db;  pExpr = sqlite3ExprDup(db, pExpr, 0);  if( !db->mallocFailed ) sqlite3ExprCode(pParse, pExpr, target);  sqlite3ExprDelete(db, pExpr); } SQLITE_PRIVATE void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){  sqlite3ExprCodeRunJustOnce(pParse, pExpr, target);  }else{  sqlite3ExprCodeCopy(pParse, pExpr, target);  } } SQLITE_PRIVATE int sqlite3ExprCodeExprList(  Parse *pParse,  ExprList *pList,  int target,  int srcReg,  u8 flags ){  struct ExprList_item *pItem;  int i, j, n;  u8 copyOp = (flags & SQLITE_ECEL_DUP) ? OP_Copy : OP_SCopy;  Vdbe *v = pParse->pVdbe;  assert( pList!=0 );  assert( target>0 );  assert( pParse->pVdbe!=0 );  n = pList->nExpr;  if( !ConstFactorOk(pParse) ) flags &= ~SQLITE_ECEL_FACTOR;  for(pItem=pList->a, i=0; i<n; i++, pItem++){  Expr *pExpr = pItem->pExpr;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( pItem->bSorterRef ){  i--;  n--;  }else
#endif
 if( (flags & SQLITE_ECEL_REF)!=0 && (j = pItem->u.x.iOrderByCol)>0 ){  if( flags & SQLITE_ECEL_OMITREF ){  i--;  n--;  }else{  sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);  }  }else if( (flags & SQLITE_ECEL_FACTOR)!=0   && sqlite3ExprIsConstantNotJoin(pExpr)  ){  sqlite3ExprCodeRunJustOnce(pParse, pExpr, target+i);  }else{  int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);  if( inReg!=target+i ){  VdbeOp *pOp;  if( copyOp==OP_Copy   && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy   && pOp->p1+pOp->p3+1==inReg   && pOp->p2+pOp->p3+1==target+i   && pOp->p5==0  ){  pOp->p3++;  }else{  sqlite3VdbeAddOp2(v, copyOp, inReg, target+i);  }  }  }  }  return n; } static void exprCodeBetween(  Parse *pParse,  Expr *pExpr,  int dest,  void (*xJump)(Parse*,Expr*,int,int),  int jumpIfNull ){  Expr exprAnd;  Expr compLeft;  Expr compRight;  int regFree1 = 0;  Expr *pDel = 0;  sqlite3 *db = pParse->db;  memset(&compLeft, 0, sizeof(Expr));  memset(&compRight, 0, sizeof(Expr));  memset(&exprAnd, 0, sizeof(Expr));  assert( ExprUseXList(pExpr) );  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);  if( db->mallocFailed==0 ){  exprAnd.op = TK_AND;  exprAnd.pLeft = &compLeft;  exprAnd.pRight = &compRight;  compLeft.op = TK_GE;  compLeft.pLeft = pDel;  compLeft.pRight = pExpr->x.pList->a[0].pExpr;  compRight.op = TK_LE;  compRight.pLeft = pDel;  compRight.pRight = pExpr->x.pList->a[1].pExpr;  exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));  if( xJump ){  xJump(pParse, &exprAnd, dest, jumpIfNull);  }else{  pDel->flags |= EP_FromJoin;  sqlite3ExprCodeTarget(pParse, &exprAnd, dest);  }  sqlite3ReleaseTempReg(pParse, regFree1);  }  sqlite3ExprDelete(db, pDel);  testcase( xJump==sqlite3ExprIfTrue && jumpIfNull==0 && regFree1==0 );  testcase( xJump==sqlite3ExprIfTrue && jumpIfNull==0 && regFree1!=0 );  testcase( xJump==sqlite3ExprIfTrue && jumpIfNull!=0 && regFree1==0 );  testcase( xJump==sqlite3ExprIfTrue && jumpIfNull!=0 && regFree1!=0 );  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1==0 );  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull==0 && regFree1!=0 );  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1==0 );  testcase( xJump==sqlite3ExprIfFalse && jumpIfNull!=0 && regFree1!=0 );  testcase( xJump==0 ); } SQLITE_PRIVATE void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){  Vdbe *v = pParse->pVdbe;  int op = 0;  int regFree1 = 0;  int regFree2 = 0;  int r1, r2;  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );  if( NEVER(v==0) )  return;  if( NEVER(pExpr==0) ) return;  assert( !ExprHasVVAProperty(pExpr, EP_Immutable) );  op = pExpr->op;  switch( op ){  case TK_AND:  case TK_OR: {  Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);  if( pAlt!=pExpr ){  sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);  }else if( op==TK_AND ){  int d2 = sqlite3VdbeMakeLabel(pParse);  testcase( jumpIfNull==0 );  sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,   jumpIfNull^SQLITE_JUMPIFNULL);  sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);  sqlite3VdbeResolveLabel(v, d2);  }else{  testcase( jumpIfNull==0 );  sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);  sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);  }  break;  }  case TK_NOT: {  testcase( jumpIfNull==0 );  sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);  break;  }  case TK_TRUTH: {  int isNot;  int isTrue;  testcase( jumpIfNull==0 );  isNot = pExpr->op2==TK_ISNOT;  isTrue = sqlite3ExprTruthValue(pExpr->pRight);  testcase( isTrue && isNot );  testcase( !isTrue && isNot );  if( isTrue ^ isNot ){  sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,  isNot ? SQLITE_JUMPIFNULL : 0);  }else{  sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,   isNot ? SQLITE_JUMPIFNULL : 0);  }  break;  }  case TK_IS:  case TK_ISNOT:  testcase( op==TK_IS );  testcase( op==TK_ISNOT );  op = (op==TK_IS) ? TK_EQ : TK_NE;  jumpIfNull = SQLITE_NULLEQ;  deliberate_fall_through  case TK_LT:  case TK_LE:  case TK_GT:  case TK_GE:  case TK_NE:  case TK_EQ: {  if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;  testcase( jumpIfNull==0 );  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);  codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,  r1, r2, dest, jumpIfNull, ExprHasProperty(pExpr,EP_Commuted));  assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);  assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);  assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);  assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);  assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);  VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);  VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);  assert(TK_NE==OP_Ne); testcase(op==OP_Ne);  VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);  VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);  testcase( regFree1==0 );  testcase( regFree2==0 );  break;  }  case TK_ISNULL:  case TK_NOTNULL: {  assert( TK_ISNULL==OP_IsNull );  testcase( op==TK_ISNULL );  assert( TK_NOTNULL==OP_NotNull ); testcase( op==TK_NOTNULL );  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  sqlite3VdbeAddOp2(v, op, r1, dest);  VdbeCoverageIf(v, op==TK_ISNULL);  VdbeCoverageIf(v, op==TK_NOTNULL);  testcase( regFree1==0 );  break;  }  case TK_BETWEEN: {  testcase( jumpIfNull==0 );  exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);  break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case TK_IN: {  int destIfFalse = sqlite3VdbeMakeLabel(pParse);  int destIfNull = jumpIfNull ? dest : destIfFalse;  sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);  sqlite3VdbeGoto(v, dest);  sqlite3VdbeResolveLabel(v, destIfFalse);  break;  }
#endif
 default: {  default_expr:  if( ExprAlwaysTrue(pExpr) ){  sqlite3VdbeGoto(v, dest);  }else if( ExprAlwaysFalse(pExpr) ){  }else{  r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);  sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0);  VdbeCoverage(v);  testcase( regFree1==0 );  testcase( jumpIfNull==0 );  }  break;  }  }  sqlite3ReleaseTempReg(pParse, regFree1);  sqlite3ReleaseTempReg(pParse, regFree2); } SQLITE_PRIVATE void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){  Vdbe *v = pParse->pVdbe;  int op = 0;  int regFree1 = 0;  int regFree2 = 0;  int r1, r2;  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );  if( NEVER(v==0) ) return;  if( pExpr==0 ) return;  assert( !ExprHasVVAProperty(pExpr,EP_Immutable) );  op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1);  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );  assert( pExpr->op!=TK_NE || op==OP_Eq );  assert( pExpr->op!=TK_EQ || op==OP_Ne );  assert( pExpr->op!=TK_LT || op==OP_Ge );  assert( pExpr->op!=TK_LE || op==OP_Gt );  assert( pExpr->op!=TK_GT || op==OP_Le );  assert( pExpr->op!=TK_GE || op==OP_Lt );  switch( pExpr->op ){  case TK_AND:  case TK_OR: {  Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);  if( pAlt!=pExpr ){  sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);  }else if( pExpr->op==TK_AND ){  testcase( jumpIfNull==0 );  sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);  sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);  }else{  int d2 = sqlite3VdbeMakeLabel(pParse);  testcase( jumpIfNull==0 );  sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2,  jumpIfNull^SQLITE_JUMPIFNULL);  sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);  sqlite3VdbeResolveLabel(v, d2);  }  break;  }  case TK_NOT: {  testcase( jumpIfNull==0 );  sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);  break;  }  case TK_TRUTH: {  int isNot;  int isTrue;  testcase( jumpIfNull==0 );  isNot = pExpr->op2==TK_ISNOT;  isTrue = sqlite3ExprTruthValue(pExpr->pRight);  testcase( isTrue && isNot );  testcase( !isTrue && isNot );  if( isTrue ^ isNot ){  sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,   isNot ? 0 : SQLITE_JUMPIFNULL);  }else{  sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,  isNot ? 0 : SQLITE_JUMPIFNULL);  }  break;  }  case TK_IS:  case TK_ISNOT:  testcase( pExpr->op==TK_IS );  testcase( pExpr->op==TK_ISNOT );  op = (pExpr->op==TK_IS) ? TK_NE : TK_EQ;  jumpIfNull = SQLITE_NULLEQ;  deliberate_fall_through  case TK_LT:  case TK_LE:  case TK_GT:  case TK_GE:  case TK_NE:  case TK_EQ: {  if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;  testcase( jumpIfNull==0 );  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);  codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,  r1, r2, dest, jumpIfNull,ExprHasProperty(pExpr,EP_Commuted));  assert(TK_LT==OP_Lt); testcase(op==OP_Lt); VdbeCoverageIf(v,op==OP_Lt);  assert(TK_LE==OP_Le); testcase(op==OP_Le); VdbeCoverageIf(v,op==OP_Le);  assert(TK_GT==OP_Gt); testcase(op==OP_Gt); VdbeCoverageIf(v,op==OP_Gt);  assert(TK_GE==OP_Ge); testcase(op==OP_Ge); VdbeCoverageIf(v,op==OP_Ge);  assert(TK_EQ==OP_Eq); testcase(op==OP_Eq);  VdbeCoverageIf(v, op==OP_Eq && jumpIfNull!=SQLITE_NULLEQ);  VdbeCoverageIf(v, op==OP_Eq && jumpIfNull==SQLITE_NULLEQ);  assert(TK_NE==OP_Ne); testcase(op==OP_Ne);  VdbeCoverageIf(v, op==OP_Ne && jumpIfNull!=SQLITE_NULLEQ);  VdbeCoverageIf(v, op==OP_Ne && jumpIfNull==SQLITE_NULLEQ);  testcase( regFree1==0 );  testcase( regFree2==0 );  break;  }  case TK_ISNULL:  case TK_NOTNULL: {  r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);  sqlite3VdbeAddOp2(v, op, r1, dest);  testcase( op==TK_ISNULL );  VdbeCoverageIf(v, op==TK_ISNULL);  testcase( op==TK_NOTNULL ); VdbeCoverageIf(v, op==TK_NOTNULL);  testcase( regFree1==0 );  break;  }  case TK_BETWEEN: {  testcase( jumpIfNull==0 );  exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);  break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case TK_IN: {  if( jumpIfNull ){  sqlite3ExprCodeIN(pParse, pExpr, dest, dest);  }else{  int destIfNull = sqlite3VdbeMakeLabel(pParse);  sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);  sqlite3VdbeResolveLabel(v, destIfNull);  }  break;  }
#endif
 default: {  default_expr:  if( ExprAlwaysFalse(pExpr) ){  sqlite3VdbeGoto(v, dest);  }else if( ExprAlwaysTrue(pExpr) ){  }else{  r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);  sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0);  VdbeCoverage(v);  testcase( regFree1==0 );  testcase( jumpIfNull==0 );  }  break;  }  }  sqlite3ReleaseTempReg(pParse, regFree1);  sqlite3ReleaseTempReg(pParse, regFree2); } SQLITE_PRIVATE void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){  sqlite3 *db = pParse->db;  Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);  if( db->mallocFailed==0 ){  sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);  }  sqlite3ExprDelete(db, pCopy); } static int exprCompareVariable(  const Parse *pParse,  const Expr *pVar,  const Expr *pExpr ){  int res = 0;  int iVar;  sqlite3_value *pL, *pR = 0;  sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, SQLITE_AFF_BLOB, &pR);  if( pR ){  iVar = pVar->iColumn;  sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);  pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, SQLITE_AFF_BLOB);  if( pL ){  if( sqlite3_value_type(pL)==SQLITE_TEXT ){  sqlite3_value_text(pL);  }  res = 0==sqlite3MemCompare(pL, pR, 0);  }  sqlite3ValueFree(pR);  sqlite3ValueFree(pL);  }  return res; } SQLITE_PRIVATE int sqlite3ExprCompare(  const Parse *pParse,  const Expr *pA,  const Expr *pB,  int iTab ){  u32 combinedFlags;  if( pA==0 || pB==0 ){  return pB==pA ? 0 : 2;  }  if( pParse && pA->op==TK_VARIABLE && exprCompareVariable(pParse, pA, pB) ){  return 0;  }  combinedFlags = pA->flags | pB->flags;  if( combinedFlags & EP_IntValue ){  if( (pA->flags&pB->flags&EP_IntValue)!=0 && pA->u.iValue==pB->u.iValue ){  return 0;  }  return 2;  }  if( pA->op!=pB->op || pA->op==TK_RAISE ){  if( pA->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){  return 1;  }  if( pB->op==TK_COLLATE && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){  return 1;  }  return 2;  }  assert( !ExprHasProperty(pA, EP_IntValue) );  assert( !ExprHasProperty(pB, EP_IntValue) );  if( pA->u.zToken ){  if( pA->op==TK_FUNCTION || pA->op==TK_AGG_FUNCTION ){  if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;
#ifndef SQLITE_OMIT_WINDOWFUNC
 assert( pA->op==pB->op );  if( ExprHasProperty(pA,EP_WinFunc)!=ExprHasProperty(pB,EP_WinFunc) ){  return 2;  }  if( ExprHasProperty(pA,EP_WinFunc) ){  if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){  return 2;  }  }
#endif
 }else if( pA->op==TK_NULL ){  return 0;  }else if( pA->op==TK_COLLATE ){  if( sqlite3_stricmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;  }else  if( pB->u.zToken!=0   && pA->op!=TK_COLUMN   && pA->op!=TK_AGG_COLUMN   && strcmp(pA->u.zToken,pB->u.zToken)!=0  ){  return 2;  }  }  if( (pA->flags & (EP_Distinct|EP_Commuted))   != (pB->flags & (EP_Distinct|EP_Commuted)) ) return 2;  if( ALWAYS((combinedFlags & EP_TokenOnly)==0) ){  if( combinedFlags & EP_xIsSelect ) return 2;  if( (combinedFlags & EP_FixedCol)==0   && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;  if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;  if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;  if( pA->op!=TK_STRING   && pA->op!=TK_TRUEFALSE   && ALWAYS((combinedFlags & EP_Reduced)==0)  ){  if( pA->iColumn!=pB->iColumn ) return 2;  if( pA->op2!=pB->op2 && pA->op==TK_TRUTH ) return 2;  if( pA->op!=TK_IN && pA->iTable!=pB->iTable && pA->iTable!=iTab ){  return 2;  }  }  }  return 0; } SQLITE_PRIVATE int sqlite3ExprListCompare(const ExprList *pA, const ExprList *pB, int iTab){  int i;  if( pA==0 && pB==0 ) return 0;  if( pA==0 || pB==0 ) return 1;  if( pA->nExpr!=pB->nExpr ) return 1;  for(i=0; i<pA->nExpr; i++){  int res;  Expr *pExprA = pA->a[i].pExpr;  Expr *pExprB = pB->a[i].pExpr;  if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;  if( (res = sqlite3ExprCompare(0, pExprA, pExprB, iTab)) ) return res;  }  return 0; } SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr *pA,Expr *pB, int iTab){  return sqlite3ExprCompare(0,   sqlite3ExprSkipCollateAndLikely(pA),   sqlite3ExprSkipCollateAndLikely(pB),   iTab); } static int exprImpliesNotNull(  const Parse *pParse,  const Expr *p,  const Expr *pNN,  int iTab,  int seenNot ){  assert( p );  assert( pNN );  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){  return pNN->op!=TK_NULL;  }  switch( p->op ){  case TK_IN: {  if( seenNot && ExprHasProperty(p, EP_xIsSelect) ) return 0;  assert( ExprUseXSelect(p) || (p->x.pList!=0 && p->x.pList->nExpr>0) );  return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);  }  case TK_BETWEEN: {  ExprList *pList;  assert( ExprUseXList(p) );  pList = p->x.pList;  assert( pList!=0 );  assert( pList->nExpr==2 );  if( seenNot ) return 0;  if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)   || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)  ){  return 1;  }  return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);  }  case TK_EQ:  case TK_NE:  case TK_LT:  case TK_LE:  case TK_GT:  case TK_GE:  case TK_PLUS:  case TK_MINUS:  case TK_BITOR:  case TK_LSHIFT:  case TK_RSHIFT:  case TK_CONCAT:  seenNot = 1;  deliberate_fall_through  case TK_STAR:  case TK_REM:  case TK_BITAND:  case TK_SLASH: {  if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;  deliberate_fall_through  }  case TK_SPAN:  case TK_COLLATE:  case TK_UPLUS:  case TK_UMINUS: {  return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);  }  case TK_TRUTH: {  if( seenNot ) return 0;  if( p->op2!=TK_IS ) return 0;  return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);  }  case TK_BITNOT:  case TK_NOT: {  return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);  }  }  return 0; } SQLITE_PRIVATE int sqlite3ExprImpliesExpr(  const Parse *pParse,  const Expr *pE1,  const Expr *pE2,  int iTab ){  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){  return 1;  }  if( pE2->op==TK_OR   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)   || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )  ){  return 1;  }  if( pE2->op==TK_NOTNULL   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)  ){  return 1;  }  return 0; } static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){  testcase( pExpr->op==TK_AGG_COLUMN );  testcase( pExpr->op==TK_AGG_FUNCTION );  if( ExprHasProperty(pExpr, EP_FromJoin) ) return WRC_Prune;  switch( pExpr->op ){  case TK_ISNOT:  case TK_ISNULL:  case TK_NOTNULL:  case TK_IS:  case TK_OR:  case TK_VECTOR:  case TK_CASE:  case TK_IN:  case TK_FUNCTION:  case TK_TRUTH:  testcase( pExpr->op==TK_ISNOT );  testcase( pExpr->op==TK_ISNULL );  testcase( pExpr->op==TK_NOTNULL );  testcase( pExpr->op==TK_IS );  testcase( pExpr->op==TK_OR );  testcase( pExpr->op==TK_VECTOR );  testcase( pExpr->op==TK_CASE );  testcase( pExpr->op==TK_IN );  testcase( pExpr->op==TK_FUNCTION );  testcase( pExpr->op==TK_TRUTH );  return WRC_Prune;  case TK_COLUMN:  if( pWalker->u.iCur==pExpr->iTable ){  pWalker->eCode = 1;  return WRC_Abort;  }  return WRC_Prune;  case TK_AND:  if( pWalker->eCode==0 ){  sqlite3WalkExpr(pWalker, pExpr->pLeft);  if( pWalker->eCode ){  pWalker->eCode = 0;  sqlite3WalkExpr(pWalker, pExpr->pRight);  }  }  return WRC_Prune;  case TK_BETWEEN:  if( sqlite3WalkExpr(pWalker, pExpr->pLeft)==WRC_Abort ){  assert( pWalker->eCode );  return WRC_Abort;  }  return WRC_Prune;  case TK_EQ:  case TK_NE:  case TK_LT:  case TK_LE:  case TK_GT:  case TK_GE: {  Expr *pLeft = pExpr->pLeft;  Expr *pRight = pExpr->pRight;  testcase( pExpr->op==TK_EQ );  testcase( pExpr->op==TK_NE );  testcase( pExpr->op==TK_LT );  testcase( pExpr->op==TK_LE );  testcase( pExpr->op==TK_GT );  testcase( pExpr->op==TK_GE );  assert( pLeft->op!=TK_COLUMN || ExprUseYTab(pLeft) );  assert( pRight->op!=TK_COLUMN || ExprUseYTab(pRight) );  if( (pLeft->op==TK_COLUMN   && pLeft->y.pTab!=0   && IsVirtual(pLeft->y.pTab))   || (pRight->op==TK_COLUMN   && pRight->y.pTab!=0   && IsVirtual(pRight->y.pTab))  ){  return WRC_Prune;  }  deliberate_fall_through  }  default:  return WRC_Continue;  } } SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){  Walker w;  p = sqlite3ExprSkipCollateAndLikely(p);  if( p==0 ) return 0;  if( p->op==TK_NOTNULL ){  p = p->pLeft;  }else{  while( p->op==TK_AND ){  if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) return 1;  p = p->pRight;  }  }  w.xExprCallback = impliesNotNullRow;  w.xSelectCallback = 0;  w.xSelectCallback2 = 0;  w.eCode = 0;  w.u.iCur = iTab;  sqlite3WalkExpr(&w, p);  return w.eCode; } struct IdxCover {  Index *pIdx;  int iCur; }; static int exprIdxCover(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_COLUMN   && pExpr->iTable==pWalker->u.pIdxCover->iCur   && sqlite3TableColumnToIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0  ){  pWalker->eCode = 1;  return WRC_Abort;  }  return WRC_Continue; } SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(  Expr *pExpr,  int iCur,  Index *pIdx ){  Walker w;  struct IdxCover xcov;  memset(&w, 0, sizeof(w));  xcov.iCur = iCur;  xcov.pIdx = pIdx;  w.xExprCallback = exprIdxCover;  w.u.pIdxCover = &xcov;  sqlite3WalkExpr(&w, pExpr);  return !w.eCode; } struct RefSrcList {  sqlite3 *db;  SrcList *pRef;  i64 nExclude;  int *aiExclude; }; static int selectRefEnter(Walker *pWalker, Select *pSelect){  struct RefSrcList *p = pWalker->u.pRefSrcList;  SrcList *pSrc = pSelect->pSrc;  i64 i, j;  int *piNew;  if( pSrc->nSrc==0 ) return WRC_Continue;  j = p->nExclude;  p->nExclude += pSrc->nSrc;  piNew = sqlite3DbRealloc(p->db, p->aiExclude, p->nExclude*sizeof(int));  if( piNew==0 ){  p->nExclude = 0;  return WRC_Abort;  }else{  p->aiExclude = piNew;  }  for(i=0; i<pSrc->nSrc; i++, j++){   p->aiExclude[j] = pSrc->a[i].iCursor;  }  return WRC_Continue; } static void selectRefLeave(Walker *pWalker, Select *pSelect){  struct RefSrcList *p = pWalker->u.pRefSrcList;  SrcList *pSrc = pSelect->pSrc;  if( p->nExclude ){  assert( p->nExclude>=pSrc->nSrc );  p->nExclude -= pSrc->nSrc;  } } static int exprRefToSrcList(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_COLUMN   || pExpr->op==TK_AGG_COLUMN  ){  int i;  struct RefSrcList *p = pWalker->u.pRefSrcList;  SrcList *pSrc = p->pRef;  int nSrc = pSrc ? pSrc->nSrc : 0;  for(i=0; i<nSrc; i++){  if( pExpr->iTable==pSrc->a[i].iCursor ){  pWalker->eCode |= 1;  return WRC_Continue;  }  }  for(i=0; i<p->nExclude && p->aiExclude[i]!=pExpr->iTable; i++){}  if( i>=p->nExclude ){  pWalker->eCode |= 2;  }  }  return WRC_Continue; } SQLITE_PRIVATE int sqlite3ReferencesSrcList(Parse *pParse, Expr *pExpr, SrcList *pSrcList){  Walker w;  struct RefSrcList x;  memset(&w, 0, sizeof(w));  memset(&x, 0, sizeof(x));  w.xExprCallback = exprRefToSrcList;  w.xSelectCallback = selectRefEnter;  w.xSelectCallback2 = selectRefLeave;  w.u.pRefSrcList = &x;  x.db = pParse->db;  x.pRef = pSrcList;  assert( pExpr->op==TK_AGG_FUNCTION );  assert( ExprUseXList(pExpr) );  sqlite3WalkExprList(&w, pExpr->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(pExpr, EP_WinFunc) ){  sqlite3WalkExpr(&w, pExpr->y.pWin->pFilter);  }
#endif
 sqlite3DbFree(pParse->db, x.aiExclude);  if( w.eCode & 0x01 ){  return 1;  }else if( w.eCode ){  return 0;  }else{  return -1;  } } static int agginfoPersistExprCb(Walker *pWalker, Expr *pExpr){  if( ALWAYS(!ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced))   && pExpr->pAggInfo!=0  ){  AggInfo *pAggInfo = pExpr->pAggInfo;  int iAgg = pExpr->iAgg;  Parse *pParse = pWalker->pParse;  sqlite3 *db = pParse->db;  assert( pExpr->op==TK_AGG_COLUMN || pExpr->op==TK_AGG_FUNCTION );  if( pExpr->op==TK_AGG_COLUMN ){  assert( iAgg>=0 && iAgg<pAggInfo->nColumn );  if( pAggInfo->aCol[iAgg].pCExpr==pExpr ){  pExpr = sqlite3ExprDup(db, pExpr, 0);  if( pExpr ){  pAggInfo->aCol[iAgg].pCExpr = pExpr;  sqlite3ExprDeferredDelete(pParse, pExpr);  }  }  }else{  assert( iAgg>=0 && iAgg<pAggInfo->nFunc );  if( pAggInfo->aFunc[iAgg].pFExpr==pExpr ){  pExpr = sqlite3ExprDup(db, pExpr, 0);  if( pExpr ){  pAggInfo->aFunc[iAgg].pFExpr = pExpr;  sqlite3ExprDeferredDelete(pParse, pExpr);  }  }  }  }  return WRC_Continue; } SQLITE_PRIVATE void sqlite3AggInfoPersistWalkerInit(Walker *pWalker, Parse *pParse){  memset(pWalker, 0, sizeof(*pWalker));  pWalker->pParse = pParse;  pWalker->xExprCallback = agginfoPersistExprCb;  pWalker->xSelectCallback = sqlite3SelectWalkNoop; } static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){  int i;  pInfo->aCol = sqlite3ArrayAllocate(   db,   pInfo->aCol,   sizeof(pInfo->aCol[0]),   &pInfo->nColumn,   &i  );  return i; } static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){  int i;  pInfo->aFunc = sqlite3ArrayAllocate(   db,   pInfo->aFunc,   sizeof(pInfo->aFunc[0]),   &pInfo->nFunc,   &i  );  return i; } static int analyzeAggregate(Walker *pWalker, Expr *pExpr){  int i;  NameContext *pNC = pWalker->u.pNC;  Parse *pParse = pNC->pParse;  SrcList *pSrcList = pNC->pSrcList;  AggInfo *pAggInfo = pNC->uNC.pAggInfo;  assert( pNC->ncFlags & NC_UAggInfo );  switch( pExpr->op ){  case TK_AGG_COLUMN:  case TK_COLUMN: {  testcase( pExpr->op==TK_AGG_COLUMN );  testcase( pExpr->op==TK_COLUMN );  if( ALWAYS(pSrcList!=0) ){  SrcItem *pItem = pSrcList->a;  for(i=0; i<pSrcList->nSrc; i++, pItem++){  struct AggInfo_col *pCol;  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );  if( pExpr->iTable==pItem->iCursor ){  int k;  pCol = pAggInfo->aCol;  for(k=0; k<pAggInfo->nColumn; k++, pCol++){  if( pCol->iTable==pExpr->iTable &&  pCol->iColumn==pExpr->iColumn ){  break;  }  }  if( (k>=pAggInfo->nColumn)   && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0  ){  pCol = &pAggInfo->aCol[k];  assert( ExprUseYTab(pExpr) );  pCol->pTab = pExpr->y.pTab;  pCol->iTable = pExpr->iTable;  pCol->iColumn = pExpr->iColumn;  pCol->iMem = ++pParse->nMem;  pCol->iSorterColumn = -1;  pCol->pCExpr = pExpr;  if( pAggInfo->pGroupBy ){  int j, n;  ExprList *pGB = pAggInfo->pGroupBy;  struct ExprList_item *pTerm = pGB->a;  n = pGB->nExpr;  for(j=0; j<n; j++, pTerm++){  Expr *pE = pTerm->pExpr;  if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&  pE->iColumn==pExpr->iColumn ){  pCol->iSorterColumn = j;  break;  }  }  }  if( pCol->iSorterColumn<0 ){  pCol->iSorterColumn = pAggInfo->nSortingColumn++;  }  }  ExprSetVVAProperty(pExpr, EP_NoReduce);  pExpr->pAggInfo = pAggInfo;  pExpr->op = TK_AGG_COLUMN;  pExpr->iAgg = (i16)k;  break;  }  }  }  return WRC_Prune;  }  case TK_AGG_FUNCTION: {  if( (pNC->ncFlags & NC_InAggFunc)==0   && pWalker->walkerDepth==pExpr->op2  ){  struct AggInfo_func *pItem = pAggInfo->aFunc;  for(i=0; i<pAggInfo->nFunc; i++, pItem++){  if( pItem->pFExpr==pExpr ) break;  if( sqlite3ExprCompare(0, pItem->pFExpr, pExpr, -1)==0 ){  break;  }  }  if( i>=pAggInfo->nFunc ){  u8 enc = ENC(pParse->db);  i = addAggInfoFunc(pParse->db, pAggInfo);  if( i>=0 ){  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );  pItem = &pAggInfo->aFunc[i];  pItem->pFExpr = pExpr;  pItem->iMem = ++pParse->nMem;  assert( ExprUseUToken(pExpr) );  pItem->pFunc = sqlite3FindFunction(pParse->db,   pExpr->u.zToken,   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);  if( pExpr->flags & EP_Distinct ){  pItem->iDistinct = pParse->nTab++;  }else{  pItem->iDistinct = -1;  }  }  }  assert( !ExprHasProperty(pExpr, EP_TokenOnly|EP_Reduced) );  ExprSetVVAProperty(pExpr, EP_NoReduce);  pExpr->iAgg = (i16)i;  pExpr->pAggInfo = pAggInfo;  return WRC_Prune;  }else{  return WRC_Continue;  }  }  }  return WRC_Continue; } SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){  Walker w;  w.xExprCallback = analyzeAggregate;  w.xSelectCallback = sqlite3WalkerDepthIncrease;  w.xSelectCallback2 = sqlite3WalkerDepthDecrease;  w.walkerDepth = 0;  w.u.pNC = pNC;  w.pParse = 0;  assert( pNC->pSrcList!=0 );  sqlite3WalkExpr(&w, pExpr); } SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){  struct ExprList_item *pItem;  int i;  if( pList ){  for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){  sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);  }  } } SQLITE_PRIVATE int sqlite3GetTempReg(Parse *pParse){  if( pParse->nTempReg==0 ){  return ++pParse->nMem;  }  return pParse->aTempReg[--pParse->nTempReg]; } SQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse *pParse, int iReg){  if( iReg ){  sqlite3VdbeReleaseRegisters(pParse, iReg, 1, 0, 0);  if( pParse->nTempReg<ArraySize(pParse->aTempReg) ){  pParse->aTempReg[pParse->nTempReg++] = iReg;  }  } } SQLITE_PRIVATE int sqlite3GetTempRange(Parse *pParse, int nReg){  int i, n;  if( nReg==1 ) return sqlite3GetTempReg(pParse);  i = pParse->iRangeReg;  n = pParse->nRangeReg;  if( nReg<=n ){  pParse->iRangeReg += nReg;  pParse->nRangeReg -= nReg;  }else{  i = pParse->nMem+1;  pParse->nMem += nReg;  }  return i; } SQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){  if( nReg==1 ){  sqlite3ReleaseTempReg(pParse, iReg);  return;  }  sqlite3VdbeReleaseRegisters(pParse, iReg, nReg, 0, 0);  if( nReg>pParse->nRangeReg ){  pParse->nRangeReg = nReg;  pParse->iRangeReg = iReg;  } } SQLITE_PRIVATE void sqlite3ClearTempRegCache(Parse *pParse){  pParse->nTempReg = 0;  pParse->nRangeReg = 0; }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3NoTempsInRange(Parse *pParse, int iFirst, int iLast){  int i;  if( pParse->nRangeReg>0   && pParse->iRangeReg+pParse->nRangeReg > iFirst   && pParse->iRangeReg <= iLast  ){   return 0;  }  for(i=0; i<pParse->nTempReg; i++){  if( pParse->aTempReg[i]>=iFirst && pParse->aTempReg[i]<=iLast ){  return 0;  }  }  return 1; }
#endif
#ifndef SQLITE_OMIT_ALTERTABLE
static int isAlterableTable(Parse *pParse, Table *pTab){  if( 0==sqlite3StrNICmp(pTab->zName, "sqlite_", 7)
#ifndef SQLITE_OMIT_VIRTUALTABLE
  || (pTab->tabFlags & TF_Eponymous)!=0   || ( (pTab->tabFlags & TF_Shadow)!=0  && sqlite3ReadOnlyShadowTables(pParse->db)   )
#endif
 ){  sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);  return 1;  }  return 0; } static void renameTestSchema(  Parse *pParse,  const char *zDb,  int bTemp,  const char *zWhen,  int bNoDQS ){  pParse->colNamesSet = 1;  sqlite3NestedParse(pParse,  "SELECT 1 "  "FROM \"%w\"." LEGACY_SCHEMA_TABLE " "  "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"  " AND sql NOT LIKE 'create virtual%%'"  " AND sqlite_rename_test(%Q, sql, type, name, %d, %Q, %d)=NULL ",  zDb,  zDb, bTemp, zWhen, bNoDQS  );  if( bTemp==0 ){  sqlite3NestedParse(pParse,  "SELECT 1 "  "FROM temp." LEGACY_SCHEMA_TABLE " "  "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"  " AND sql NOT LIKE 'create virtual%%'"  " AND sqlite_rename_test(%Q, sql, type, name, 1, %Q, %d)=NULL ",  zDb, zWhen, bNoDQS  );  } } static void renameFixQuotes(Parse *pParse, const char *zDb, int bTemp){  sqlite3NestedParse(pParse,  "UPDATE \"%w\"." LEGACY_SCHEMA_TABLE  " SET sql = sqlite_rename_quotefix(%Q, sql)"  "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"  " AND sql NOT LIKE 'create virtual%%'" , zDb, zDb  );  if( bTemp==0 ){  sqlite3NestedParse(pParse,  "UPDATE temp." LEGACY_SCHEMA_TABLE  " SET sql = sqlite_rename_quotefix('temp', sql)"  "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"  " AND sql NOT LIKE 'create virtual%%'"  );  } } static void renameReloadSchema(Parse *pParse, int iDb, u16 p5){  Vdbe *v = pParse->pVdbe;  if( v ){  sqlite3ChangeCookie(pParse, iDb);  sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0, p5);  if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0, p5);  } } SQLITE_PRIVATE void sqlite3AlterRenameTable(  Parse *pParse,  SrcList *pSrc,  Token *pName ){  int iDb;  char *zDb;  Table *pTab;  char *zName = 0;  sqlite3 *db = pParse->db;  int nTabName;  const char *zTabName;  Vdbe *v;  VTable *pVTab = 0;  if( NEVER(db->mallocFailed) ) goto exit_rename_table;  assert( pSrc->nSrc==1 );  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);  if( !pTab ) goto exit_rename_table;  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  zDb = db->aDb[iDb].zDbSName;  zName = sqlite3NameFromToken(db, pName);  if( !zName ) goto exit_rename_table;  if( sqlite3FindTable(db, zName, zDb)   || sqlite3FindIndex(db, zName, zDb)   || sqlite3IsShadowTableOf(db, pTab, zName)  ){  sqlite3ErrorMsg(pParse,  "there is already another table or index with this name: %s", zName);  goto exit_rename_table;  }  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){  goto exit_rename_table;  }  if( SQLITE_OK!=sqlite3CheckObjectName(pParse,zName,"table",zName) ){  goto exit_rename_table;  }
#ifndef SQLITE_OMIT_VIEW
 if( IsView(pTab) ){  sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);  goto exit_rename_table;  }
#endif
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){  goto exit_rename_table;  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( sqlite3ViewGetColumnNames(pParse, pTab) ){  goto exit_rename_table;  }  if( IsVirtual(pTab) ){  pVTab = sqlite3GetVTable(db, pTab);  if( pVTab->pVtab->pModule->xRename==0 ){  pVTab = 0;  }  }
#endif
 v = sqlite3GetVdbe(pParse);  if( v==0 ){  goto exit_rename_table;  }  sqlite3MayAbort(pParse);  zTabName = pTab->zName;  nTabName = sqlite3Utf8CharLen(zTabName, -1);  sqlite3NestedParse(pParse,  "UPDATE \"%w\"." LEGACY_SCHEMA_TABLE " SET "  "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) "  "WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)"  "AND  name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"  , zDb, zDb, zTabName, zName, (iDb==1), zTabName  );  sqlite3NestedParse(pParse,  "UPDATE %Q." LEGACY_SCHEMA_TABLE " SET "  "tbl_name = %Q, "  "name = CASE "  "WHEN type='table' THEN %Q "  "WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' "  "  AND type='index' THEN "   "'sqlite_autoindex_' || %Q || substr(name,%d+18) "  "ELSE name END "  "WHERE tbl_name=%Q COLLATE nocase AND "  "(type='table' OR type='index' OR type='trigger');",  zDb,  zName, zName, zName,  nTabName, zTabName  );
#ifndef SQLITE_OMIT_AUTOINCREMENT
 if( sqlite3FindTable(db, "sqlite_sequence", zDb) ){  sqlite3NestedParse(pParse,  "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",  zDb, zName, pTab->zName);  }
#endif
 if( iDb!=1 ){  sqlite3NestedParse(pParse,  "UPDATE sqlite_temp_schema SET "  "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), "  "tbl_name = "  "CASE WHEN tbl_name=%Q COLLATE nocase AND "  " sqlite_rename_test(%Q, sql, type, name, 1, 'after rename', 0) "  "THEN %Q ELSE tbl_name END "  "WHERE type IN ('view', 'trigger')"  , zDb, zTabName, zName, zTabName, zDb, zName);  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( pVTab ){  int i = ++pParse->nMem;  sqlite3VdbeLoadString(v, i, zName);  sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);  }
#endif
 renameReloadSchema(pParse, iDb, INITFLAG_AlterRename);  renameTestSchema(pParse, zDb, iDb==1, "after rename", 0); exit_rename_table:  sqlite3SrcListDelete(db, pSrc);  sqlite3DbFree(db, zName); } static void sqlite3ErrorIfNotEmpty(  Parse *pParse,  const char *zDb,  const char *zTab,  const char *zErr ){  sqlite3NestedParse(pParse,   "SELECT raise(ABORT,%Q) FROM \"%w\".\"%w\"",   zErr, zDb, zTab  ); } SQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){  Table *pNew;  Table *pTab;  int iDb;  const char *zDb;  const char *zTab;  char *zCol;  Column *pCol;  Expr *pDflt;  sqlite3 *db;  Vdbe *v;  int r1;  db = pParse->db;  if( pParse->nErr || db->mallocFailed ) return;  pNew = pParse->pNewTable;  assert( pNew );  assert( sqlite3BtreeHoldsAllMutexes(db) );  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);  zDb = db->aDb[iDb].zDbSName;  zTab = &pNew->zName[16];  pCol = &pNew->aCol[pNew->nCol-1];  pDflt = sqlite3ColumnExpr(pNew, pCol);  pTab = sqlite3FindTable(db, zTab, zDb);  assert( pTab );
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){  return;  }
#endif
 if( pCol->colFlags & COLFLAG_PRIMKEY ){  sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");  return;  }  if( pNew->pIndex ){  sqlite3ErrorMsg(pParse,   "Cannot add a UNIQUE column");  return;  }  if( (pCol->colFlags & COLFLAG_GENERATED)==0 ){  assert( pDflt==0 || pDflt->op==TK_SPAN );  if( pDflt && pDflt->pLeft->op==TK_NULL ){  pDflt = 0;  }  assert( IsOrdinaryTable(pNew) );  if( (db->flags&SQLITE_ForeignKeys) && pNew->u.tab.pFKey && pDflt ){  sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,  "Cannot add a REFERENCES column with non-NULL default value");  }  if( pCol->notNull && !pDflt ){  sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,  "Cannot add a NOT NULL column with default value NULL");  }  if( pDflt ){  sqlite3_value *pVal = 0;  int rc;  rc = sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_BLOB, &pVal);  assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );  if( rc!=SQLITE_OK ){  assert( db->mallocFailed == 1 );  return;  }  if( !pVal ){  sqlite3ErrorIfNotEmpty(pParse, zDb, zTab,   "Cannot add a column with non-constant default");  }  sqlite3ValueFree(pVal);  }  }else if( pCol->colFlags & COLFLAG_STORED ){  sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, "cannot add a STORED column");  }  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);  if( zCol ){  char *zEnd = &zCol[pColDef->n-1];  while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){  *zEnd-- = '\0';  }  assert( IsOrdinaryTable(pTab) );  assert( IsOrdinaryTable(pNew) );  sqlite3NestedParse(pParse,  "UPDATE \"%w\"." LEGACY_SCHEMA_TABLE " SET "  "sql = printf('%%.%ds, ',sql) || %Q"  " || substr(sql,1+length(printf('%%.%ds',sql))) "  "WHERE type = 'table' AND name = %Q",  zDb, pNew->u.tab.addColOffset, zCol, pNew->u.tab.addColOffset,  zTab  );  sqlite3DbFree(db, zCol);  }  v = sqlite3GetVdbe(pParse);  if( v ){  r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);  sqlite3VdbeUsesBtree(v, iDb);  sqlite3VdbeAddOp2(v, OP_AddImm, r1, -2);  sqlite3VdbeAddOp2(v, OP_IfPos, r1, sqlite3VdbeCurrentAddr(v)+2);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, 3);  sqlite3ReleaseTempReg(pParse, r1);  renameReloadSchema(pParse, iDb, INITFLAG_AlterAdd);  if( pNew->pCheck!=0   || (pCol->notNull && (pCol->colFlags & COLFLAG_GENERATED)!=0)  ){  sqlite3NestedParse(pParse,  "SELECT CASE WHEN quick_check GLOB 'CHECK*'"  " THEN raise(ABORT,'CHECK constraint failed')"  " ELSE raise(ABORT,'NOT NULL constraint failed')"  " END"  " FROM pragma_quick_check(\"%w\",\"%w\")"  " WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'",  zTab, zDb  );  }  } } SQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){  Table *pNew;  Table *pTab;  int iDb;  int i;  int nAlloc;  sqlite3 *db = pParse->db;  assert( pParse->pNewTable==0 );  assert( sqlite3BtreeHoldsAllMutexes(db) );  if( db->mallocFailed ) goto exit_begin_add_column;  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);  if( !pTab ) goto exit_begin_add_column;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  sqlite3ErrorMsg(pParse, "virtual tables may not be altered");  goto exit_begin_add_column;  }
#endif
 if( IsView(pTab) ){  sqlite3ErrorMsg(pParse, "Cannot add a column to a view");  goto exit_begin_add_column;  }  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ){  goto exit_begin_add_column;  }  sqlite3MayAbort(pParse);  assert( IsOrdinaryTable(pTab) );  assert( pTab->u.tab.addColOffset>0 );  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));  if( !pNew ) goto exit_begin_add_column;  pParse->pNewTable = pNew;  pNew->nTabRef = 1;  pNew->nCol = pTab->nCol;  assert( pNew->nCol>0 );  nAlloc = (((pNew->nCol-1)/8)*8)+8;  assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 );  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);  pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);  if( !pNew->aCol || !pNew->zName ){  assert( db->mallocFailed );  goto exit_begin_add_column;  }  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);  for(i=0; i<pNew->nCol; i++){  Column *pCol = &pNew->aCol[i];  pCol->zCnName = sqlite3DbStrDup(db, pCol->zCnName);  pCol->hName = sqlite3StrIHash(pCol->zCnName);  }  assert( IsOrdinaryTable(pNew) );  pNew->u.tab.pDfltList = sqlite3ExprListDup(db, pTab->u.tab.pDfltList, 0);  pNew->pSchema = db->aDb[iDb].pSchema;  pNew->u.tab.addColOffset = pTab->u.tab.addColOffset;  pNew->nTabRef = 1; exit_begin_add_column:  sqlite3SrcListDelete(db, pSrc);  return; }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
static int isRealTable(Parse *pParse, Table *pTab, int bDrop){  const char *zType = 0;
#ifndef SQLITE_OMIT_VIEW
 if( IsView(pTab) ){  zType = "view";  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  zType = "virtual table";  }
#endif
 if( zType ){  sqlite3ErrorMsg(pParse, "cannot %s %s \"%s\"",  (bDrop ? "drop column from" : "rename columns of"),  zType, pTab->zName  );  return 1;  }  return 0; }
#else
# define isRealTable(x,y,z) (0)
#endif
SQLITE_PRIVATE void sqlite3AlterRenameColumn(  Parse *pParse,  SrcList *pSrc,  Token *pOld,  Token *pNew ){  sqlite3 *db = pParse->db;  Table *pTab;  int iCol;  char *zOld = 0;  char *zNew = 0;  const char *zDb;  int iSchema;  int bQuote;  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);  if( !pTab ) goto exit_rename_column;  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) goto exit_rename_column;  if( SQLITE_OK!=isRealTable(pParse, pTab, 0) ) goto exit_rename_column;  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iSchema>=0 );  zDb = db->aDb[iSchema].zDbSName;
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){  goto exit_rename_column;  }
#endif
 zOld = sqlite3NameFromToken(db, pOld);  if( !zOld ) goto exit_rename_column;  for(iCol=0; iCol<pTab->nCol; iCol++){  if( 0==sqlite3StrICmp(pTab->aCol[iCol].zCnName, zOld) ) break;  }  if( iCol==pTab->nCol ){  sqlite3ErrorMsg(pParse, "no such column: \"%s\"", zOld);  goto exit_rename_column;  }  renameTestSchema(pParse, zDb, iSchema==1, "", 0);  renameFixQuotes(pParse, zDb, iSchema==1);  sqlite3MayAbort(pParse);  zNew = sqlite3NameFromToken(db, pNew);  if( !zNew ) goto exit_rename_column;  assert( pNew->n>0 );  bQuote = sqlite3Isquote(pNew->z[0]);  sqlite3NestedParse(pParse,  "UPDATE \"%w\"." LEGACY_SCHEMA_TABLE " SET "  "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) "  "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' "  " AND (type != 'index' OR tbl_name = %Q)",  zDb,  zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,  pTab->zName  );  sqlite3NestedParse(pParse,  "UPDATE temp." LEGACY_SCHEMA_TABLE " SET "  "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) "  "WHERE type IN ('trigger', 'view')",  zDb, pTab->zName, iCol, zNew, bQuote  );  renameReloadSchema(pParse, iSchema, INITFLAG_AlterRename);  renameTestSchema(pParse, zDb, iSchema==1, "after rename", 1);  exit_rename_column:  sqlite3SrcListDelete(db, pSrc);  sqlite3DbFree(db, zOld);  sqlite3DbFree(db, zNew);  return; } struct RenameToken {  const void *p;  Token t;  RenameToken *pNext; }; typedef struct RenameCtx RenameCtx; struct RenameCtx {  RenameToken *pList;  int nList;  int iCol;  Table *pTab;  const char *zOld; };
#ifdef SQLITE_DEBUG
static void renameTokenCheckAll(Parse *pParse, const void *pPtr){  if( pParse->nErr==0 && pParse->db->mallocFailed==0 ){  const RenameToken *p;  u8 i = 0;  for(p=pParse->pRename; p; p=p->pNext){  if( p->p ){  assert( p->p!=pPtr );  i += *(u8*)(p->p);  }  }  } }
#else
# define renameTokenCheckAll(x,y)
#endif
SQLITE_PRIVATE const void *sqlite3RenameTokenMap(  Parse *pParse,  const void *pPtr,  const Token *pToken ){  RenameToken *pNew;  assert( pPtr || pParse->db->mallocFailed );  renameTokenCheckAll(pParse, pPtr);  if( ALWAYS(pParse->eParseMode!=PARSE_MODE_UNMAP) ){  pNew = sqlite3DbMallocZero(pParse->db, sizeof(RenameToken));  if( pNew ){  pNew->p = pPtr;  pNew->t = *pToken;  pNew->pNext = pParse->pRename;  pParse->pRename = pNew;  }  }  return pPtr; } SQLITE_PRIVATE void sqlite3RenameTokenRemap(Parse *pParse, const void *pTo, const void *pFrom){  RenameToken *p;  renameTokenCheckAll(pParse, pTo);  for(p=pParse->pRename; p; p=p->pNext){  if( p->p==pFrom ){  p->p = pTo;  break;  }  } } static int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){  Parse *pParse = pWalker->pParse;  sqlite3RenameTokenRemap(pParse, 0, (const void*)pExpr);  if( ExprUseYTab(pExpr) ){  sqlite3RenameTokenRemap(pParse, 0, (const void*)&pExpr->y.pTab);  }  return WRC_Continue; } static void renameWalkWith(Walker *pWalker, Select *pSelect){  With *pWith = pSelect->pWith;  if( pWith ){  Parse *pParse = pWalker->pParse;  int i;  With *pCopy = 0;  assert( pWith->nCte>0 );  if( (pWith->a[0].pSelect->selFlags & SF_Expanded)==0 ){  pCopy = sqlite3WithDup(pParse->db, pWith);  pCopy = sqlite3WithPush(pParse, pCopy, 1);  }  for(i=0; i<pWith->nCte; i++){  Select *p = pWith->a[i].pSelect;  NameContext sNC;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  if( pCopy ) sqlite3SelectPrep(sNC.pParse, p, &sNC);  if( sNC.pParse->db->mallocFailed ) return;  sqlite3WalkSelect(pWalker, p);  sqlite3RenameExprlistUnmap(pParse, pWith->a[i].pCols);  }  if( pCopy && pParse->pWith==pCopy ){  pParse->pWith = pCopy->pOuter;  }  } } static void unmapColumnIdlistNames(  Parse *pParse,  const IdList *pIdList ){  if( pIdList ){  int ii;  for(ii=0; ii<pIdList->nId; ii++){  sqlite3RenameTokenRemap(pParse, 0, (const void*)pIdList->a[ii].zName);  }  } } static int renameUnmapSelectCb(Walker *pWalker, Select *p){  Parse *pParse = pWalker->pParse;  int i;  if( pParse->nErr ) return WRC_Abort;  testcase( p->selFlags & SF_View );  testcase( p->selFlags & SF_CopyCte );  if( p->selFlags & (SF_View|SF_CopyCte) ){  return WRC_Prune;  }  if( ALWAYS(p->pEList) ){  ExprList *pList = p->pEList;  for(i=0; i<pList->nExpr; i++){  if( pList->a[i].zEName && pList->a[i].eEName==ENAME_NAME ){  sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zEName);  }  }  }  if( ALWAYS(p->pSrc) ){  SrcList *pSrc = p->pSrc;  for(i=0; i<pSrc->nSrc; i++){  sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);  sqlite3WalkExpr(pWalker, pSrc->a[i].pOn);  unmapColumnIdlistNames(pParse, pSrc->a[i].pUsing);  }  }  renameWalkWith(pWalker, p);  return WRC_Continue; } SQLITE_PRIVATE void sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){  u8 eMode = pParse->eParseMode;  Walker sWalker;  memset(&sWalker, 0, sizeof(Walker));  sWalker.pParse = pParse;  sWalker.xExprCallback = renameUnmapExprCb;  sWalker.xSelectCallback = renameUnmapSelectCb;  pParse->eParseMode = PARSE_MODE_UNMAP;  sqlite3WalkExpr(&sWalker, pExpr);  pParse->eParseMode = eMode; } SQLITE_PRIVATE void sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){  if( pEList ){  int i;  Walker sWalker;  memset(&sWalker, 0, sizeof(Walker));  sWalker.pParse = pParse;  sWalker.xExprCallback = renameUnmapExprCb;  sqlite3WalkExprList(&sWalker, pEList);  for(i=0; i<pEList->nExpr; i++){  if( ALWAYS(pEList->a[i].eEName==ENAME_NAME) ){  sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zEName);  }  }  } } static void renameTokenFree(sqlite3 *db, RenameToken *pToken){  RenameToken *pNext;  RenameToken *p;  for(p=pToken; p; p=pNext){  pNext = p->pNext;  sqlite3DbFree(db, p);  } } static RenameToken *renameTokenFind(  Parse *pParse,  struct RenameCtx *pCtx,  const void *pPtr ){  RenameToken **pp;  if( NEVER(pPtr==0) ){  return 0;  }  for(pp=&pParse->pRename; (*pp); pp=&(*pp)->pNext){  if( (*pp)->p==pPtr ){  RenameToken *pToken = *pp;  if( pCtx ){  *pp = pToken->pNext;  pToken->pNext = pCtx->pList;  pCtx->pList = pToken;  pCtx->nList++;  }  return pToken;  }  }  return 0; } static int renameColumnSelectCb(Walker *pWalker, Select *p){  if( p->selFlags & (SF_View|SF_CopyCte) ){  testcase( p->selFlags & SF_View );  testcase( p->selFlags & SF_CopyCte );  return WRC_Prune;  }  renameWalkWith(pWalker, p);  return WRC_Continue; } static int renameColumnExprCb(Walker *pWalker, Expr *pExpr){  RenameCtx *p = pWalker->u.pRename;  if( pExpr->op==TK_TRIGGER   && pExpr->iColumn==p->iCol   && pWalker->pParse->pTriggerTab==p->pTab  ){  renameTokenFind(pWalker->pParse, p, (void*)pExpr);  }else if( pExpr->op==TK_COLUMN   && pExpr->iColumn==p->iCol   && ALWAYS(ExprUseYTab(pExpr))   && p->pTab==pExpr->y.pTab  ){  renameTokenFind(pWalker->pParse, p, (void*)pExpr);  }  return WRC_Continue; } static RenameToken *renameColumnTokenNext(RenameCtx *pCtx){  RenameToken *pBest = pCtx->pList;  RenameToken *pToken;  RenameToken **pp;  for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){  if( pToken->t.z>pBest->t.z ) pBest = pToken;  }  for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);  *pp = pBest->pNext;  return pBest; } static void renameColumnParseError(  sqlite3_context *pCtx,  const char *zWhen,  sqlite3_value *pType,  sqlite3_value *pObject,  Parse *pParse ){  const char *zT = (const char*)sqlite3_value_text(pType);  const char *zN = (const char*)sqlite3_value_text(pObject);  char *zErr;  zErr = sqlite3_mprintf("error in %s %s%s%s: %s",  zT, zN, (zWhen[0] ? " " : ""), zWhen,  pParse->zErrMsg  );  sqlite3_result_error(pCtx, zErr, -1);  sqlite3_free(zErr); } static void renameColumnElistNames(  Parse *pParse,  RenameCtx *pCtx,  const ExprList *pEList,  const char *zOld ){  if( pEList ){  int i;  for(i=0; i<pEList->nExpr; i++){  const char *zName = pEList->a[i].zEName;  if( ALWAYS(pEList->a[i].eEName==ENAME_NAME)   && ALWAYS(zName!=0)   && 0==sqlite3_stricmp(zName, zOld)  ){  renameTokenFind(pParse, pCtx, (const void*)zName);  }  }  } } static void renameColumnIdlistNames(  Parse *pParse,  RenameCtx *pCtx,  const IdList *pIdList,  const char *zOld ){  if( pIdList ){  int i;  for(i=0; i<pIdList->nId; i++){  const char *zName = pIdList->a[i].zName;  if( 0==sqlite3_stricmp(zName, zOld) ){  renameTokenFind(pParse, pCtx, (const void*)zName);  }  }  } } static int renameParseSql(  Parse *p,  const char *zDb,  sqlite3 *db,  const char *zSql,  int bTemp ){  int rc;  char *zErr = 0;  db->init.iDb = bTemp ? 1 : sqlite3FindDbName(db, zDb);  memset(p, 0, sizeof(Parse));  p->eParseMode = PARSE_MODE_RENAME;  p->db = db;  p->nQueryLoop = 1;  rc = zSql ? sqlite3RunParser(p, zSql, &zErr) : SQLITE_NOMEM;  assert( p->zErrMsg==0 );  assert( rc!=SQLITE_OK || zErr==0 );  p->zErrMsg = zErr;  if( db->mallocFailed ) rc = SQLITE_NOMEM;  if( rc==SQLITE_OK   && p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0  ){  rc = SQLITE_CORRUPT_BKPT;  }
#ifdef SQLITE_DEBUG
 if( rc==SQLITE_OK ){  int nSql = sqlite3Strlen30(zSql);  RenameToken *pToken;  for(pToken=p->pRename; pToken; pToken=pToken->pNext){  assert( pToken->t.z>=zSql && &pToken->t.z[pToken->t.n]<=&zSql[nSql] );  }  }
#endif
 db->init.iDb = 0;  return rc; } static int renameEditSql(  sqlite3_context *pCtx,  RenameCtx *pRename,  const char *zSql,  const char *zNew,  int bQuote ){  i64 nNew = sqlite3Strlen30(zNew);  i64 nSql = sqlite3Strlen30(zSql);  sqlite3 *db = sqlite3_context_db_handle(pCtx);  int rc = SQLITE_OK;  char *zQuot = 0;  char *zOut;  i64 nQuot = 0;  char *zBuf1 = 0;  char *zBuf2 = 0;  if( zNew ){  zQuot = sqlite3MPrintf(db, "\"%w\" ", zNew);  if( zQuot==0 ){  return SQLITE_NOMEM;  }else{  nQuot = sqlite3Strlen30(zQuot)-1;  }  assert( nQuot>=nNew );  zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);  }else{  zOut = (char*)sqlite3DbMallocZero(db, (nSql*2+1) * 3);  if( zOut ){  zBuf1 = &zOut[nSql*2+1];  zBuf2 = &zOut[nSql*4+2];  }  }  if( zOut ){  int nOut = nSql;  memcpy(zOut, zSql, nSql);  while( pRename->pList ){  int iOff;  u32 nReplace;  const char *zReplace;  RenameToken *pBest = renameColumnTokenNext(pRename);  if( zNew ){  if( bQuote==0 && sqlite3IsIdChar(*pBest->t.z) ){  nReplace = nNew;  zReplace = zNew;  }else{  nReplace = nQuot;  zReplace = zQuot;  if( pBest->t.z[pBest->t.n]=='"' ) nReplace++;  }  }else{  memcpy(zBuf1, pBest->t.z, pBest->t.n);  zBuf1[pBest->t.n] = 0;  sqlite3Dequote(zBuf1);  sqlite3_snprintf(nSql*2, zBuf2, "%Q%s", zBuf1,  pBest->t.z[pBest->t.n]=='\'' ? " " : ""  );  zReplace = zBuf2;  nReplace = sqlite3Strlen30(zReplace);  }  iOff = pBest->t.z - zSql;  if( pBest->t.n!=nReplace ){  memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n],  nOut - (iOff + pBest->t.n)  );  nOut += nReplace - pBest->t.n;  zOut[nOut] = '\0';  }  memcpy(&zOut[iOff], zReplace, nReplace);  sqlite3DbFree(db, pBest);  }  sqlite3_result_text(pCtx, zOut, -1, SQLITE_TRANSIENT);  sqlite3DbFree(db, zOut);  }else{  rc = SQLITE_NOMEM;  }  sqlite3_free(zQuot);  return rc; } static int renameResolveTrigger(Parse *pParse){  sqlite3 *db = pParse->db;  Trigger *pNew = pParse->pNewTrigger;  TriggerStep *pStep;  NameContext sNC;  int rc = SQLITE_OK;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  assert( pNew->pTabSchema );  pParse->pTriggerTab = sqlite3FindTable(db, pNew->table,  db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName  );  pParse->eTriggerOp = pNew->op;  if( ALWAYS(pParse->pTriggerTab) ){  rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);  }  if( rc==SQLITE_OK && pNew->pWhen ){  rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);  }  for(pStep=pNew->step_list; rc==SQLITE_OK && pStep; pStep=pStep->pNext){  if( pStep->pSelect ){  sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);  if( pParse->nErr ) rc = pParse->rc;  }  if( rc==SQLITE_OK && pStep->zTarget ){  SrcList *pSrc = sqlite3TriggerStepSrc(pParse, pStep);  if( pSrc ){  int i;  for(i=0; i<pSrc->nSrc && rc==SQLITE_OK; i++){  SrcItem *p = &pSrc->a[i];  p->iCursor = pParse->nTab++;  if( p->pSelect ){  sqlite3SelectPrep(pParse, p->pSelect, 0);  sqlite3ExpandSubquery(pParse, p);  assert( i>0 );  assert( pStep->pFrom->a[i-1].pSelect );  sqlite3SelectPrep(pParse, pStep->pFrom->a[i-1].pSelect, 0);  }else{  p->pTab = sqlite3LocateTableItem(pParse, 0, p);  if( p->pTab==0 ){  rc = SQLITE_ERROR;  }else{  p->pTab->nTabRef++;  rc = sqlite3ViewGetColumnNames(pParse, p->pTab);  }  }  }  if( rc==SQLITE_OK && db->mallocFailed ){  rc = SQLITE_NOMEM;  }  sNC.pSrcList = pSrc;  if( rc==SQLITE_OK && pStep->pWhere ){  rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);  }  if( rc==SQLITE_OK ){  rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);  }  assert( !pStep->pUpsert || (!pStep->pWhere && !pStep->pExprList) );  if( pStep->pUpsert && rc==SQLITE_OK ){  Upsert *pUpsert = pStep->pUpsert;  pUpsert->pUpsertSrc = pSrc;  sNC.uNC.pUpsert = pUpsert;  sNC.ncFlags = NC_UUpsert;  rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);  if( rc==SQLITE_OK ){  ExprList *pUpsertSet = pUpsert->pUpsertSet;  rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);  }  if( rc==SQLITE_OK ){  rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);  }  if( rc==SQLITE_OK ){  rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);  }  sNC.ncFlags = 0;  }  sNC.pSrcList = 0;  sqlite3SrcListDelete(db, pSrc);  }else{  rc = SQLITE_NOMEM;  }  }  }  return rc; } static void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){  TriggerStep *pStep;  sqlite3WalkExpr(pWalker, pTrigger->pWhen);  for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){  sqlite3WalkSelect(pWalker, pStep->pSelect);  sqlite3WalkExpr(pWalker, pStep->pWhere);  sqlite3WalkExprList(pWalker, pStep->pExprList);  if( pStep->pUpsert ){  Upsert *pUpsert = pStep->pUpsert;  sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);  sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);  sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);  sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);  }  if( pStep->pFrom ){  int i;  for(i=0; i<pStep->pFrom->nSrc; i++){  sqlite3WalkSelect(pWalker, pStep->pFrom->a[i].pSelect);  }  }  } } static void renameParseCleanup(Parse *pParse){  sqlite3 *db = pParse->db;  Index *pIdx;  if( pParse->pVdbe ){  sqlite3VdbeFinalize(pParse->pVdbe);  }  sqlite3DeleteTable(db, pParse->pNewTable);  while( (pIdx = pParse->pNewIndex)!=0 ){  pParse->pNewIndex = pIdx->pNext;  sqlite3FreeIndex(db, pIdx);  }  sqlite3DeleteTrigger(db, pParse->pNewTrigger);  sqlite3DbFree(db, pParse->zErrMsg);  renameTokenFree(db, pParse->pRename);  sqlite3ParserReset(pParse); } static void renameColumnFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  sqlite3 *db = sqlite3_context_db_handle(context);  RenameCtx sCtx;  const char *zSql = (const char*)sqlite3_value_text(argv[0]);  const char *zDb = (const char*)sqlite3_value_text(argv[3]);  const char *zTable = (const char*)sqlite3_value_text(argv[4]);  int iCol = sqlite3_value_int(argv[5]);  const char *zNew = (const char*)sqlite3_value_text(argv[6]);  int bQuote = sqlite3_value_int(argv[7]);  int bTemp = sqlite3_value_int(argv[8]);  const char *zOld;  int rc;  Parse sParse;  Walker sWalker;  Index *pIdx;  int i;  Table *pTab;
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth = db->xAuth;
#endif
 UNUSED_PARAMETER(NotUsed);  if( zSql==0 ) return;  if( zTable==0 ) return;  if( zNew==0 ) return;  if( iCol<0 ) return;  sqlite3BtreeEnterAll(db);  pTab = sqlite3FindTable(db, zTable, zDb);  if( pTab==0 || iCol>=pTab->nCol ){  sqlite3BtreeLeaveAll(db);  return;  }  zOld = pTab->aCol[iCol].zCnName;  memset(&sCtx, 0, sizeof(sCtx));  sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = 0;
#endif
 rc = renameParseSql(&sParse, zDb, db, zSql, bTemp);  memset(&sWalker, 0, sizeof(Walker));  sWalker.pParse = &sParse;  sWalker.xExprCallback = renameColumnExprCb;  sWalker.xSelectCallback = renameColumnSelectCb;  sWalker.u.pRename = &sCtx;  sCtx.pTab = pTab;  if( rc!=SQLITE_OK ) goto renameColumnFunc_done;  if( sParse.pNewTable ){  if( IsView(sParse.pNewTable) ){  Select *pSelect = sParse.pNewTable->u.view.pSelect;  pSelect->selFlags &= ~SF_View;  sParse.rc = SQLITE_OK;  sqlite3SelectPrep(&sParse, pSelect, 0);  rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);  if( rc==SQLITE_OK ){  sqlite3WalkSelect(&sWalker, pSelect);  }  if( rc!=SQLITE_OK ) goto renameColumnFunc_done;  }else if( IsOrdinaryTable(sParse.pNewTable) ){  int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);  FKey *pFKey;  sCtx.pTab = sParse.pNewTable;  if( bFKOnly==0 ){  if( iCol<sParse.pNewTable->nCol ){  renameTokenFind(  &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zCnName  );  }  if( sCtx.iCol<0 ){  renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);  }  sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);  for(pIdx=sParse.pNewTable->pIndex; pIdx; pIdx=pIdx->pNext){  sqlite3WalkExprList(&sWalker, pIdx->aColExpr);  }  for(pIdx=sParse.pNewIndex; pIdx; pIdx=pIdx->pNext){  sqlite3WalkExprList(&sWalker, pIdx->aColExpr);  }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 for(i=0; i<sParse.pNewTable->nCol; i++){  Expr *pExpr = sqlite3ColumnExpr(sParse.pNewTable,  &sParse.pNewTable->aCol[i]);  sqlite3WalkExpr(&sWalker, pExpr);  }
#endif
 }  assert( IsOrdinaryTable(sParse.pNewTable) );  for(pFKey=sParse.pNewTable->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){  for(i=0; i<pFKey->nCol; i++){  if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){  renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);  }  if( 0==sqlite3_stricmp(pFKey->zTo, zTable)   && 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)  ){  renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);  }  }  }  }  }else if( sParse.pNewIndex ){  sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);  sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);  }else{  TriggerStep *pStep;  rc = renameResolveTrigger(&sParse);  if( rc!=SQLITE_OK ) goto renameColumnFunc_done;  for(pStep=sParse.pNewTrigger->step_list; pStep; pStep=pStep->pNext){  if( pStep->zTarget ){  Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);  if( pTarget==pTab ){  if( pStep->pUpsert ){  ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;  renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);  }  renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);  renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);  }  }  }  if( sParse.pTriggerTab==pTab ){  renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);  }  renameWalkTrigger(&sWalker, sParse.pNewTrigger);  }  assert( rc==SQLITE_OK );  rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote); renameColumnFunc_done:  if( rc!=SQLITE_OK ){  if( sParse.zErrMsg ){  renameColumnParseError(context, "", argv[1], argv[2], &sParse);  }else{  sqlite3_result_error_code(context, rc);  }  }  renameParseCleanup(&sParse);  renameTokenFree(db, sCtx.pList);
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = xAuth;
#endif
 sqlite3BtreeLeaveAll(db); } static int renameTableExprCb(Walker *pWalker, Expr *pExpr){  RenameCtx *p = pWalker->u.pRename;  if( pExpr->op==TK_COLUMN   && ALWAYS(ExprUseYTab(pExpr))   && p->pTab==pExpr->y.pTab  ){  renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);  }  return WRC_Continue; } static int renameTableSelectCb(Walker *pWalker, Select *pSelect){  int i;  RenameCtx *p = pWalker->u.pRename;  SrcList *pSrc = pSelect->pSrc;  if( pSelect->selFlags & (SF_View|SF_CopyCte) ){  testcase( pSelect->selFlags & SF_View );  testcase( pSelect->selFlags & SF_CopyCte );  return WRC_Prune;  }  if( NEVER(pSrc==0) ){  assert( pWalker->pParse->db->mallocFailed );  return WRC_Abort;  }  for(i=0; i<pSrc->nSrc; i++){  SrcItem *pItem = &pSrc->a[i];  if( pItem->pTab==p->pTab ){  renameTokenFind(pWalker->pParse, p, pItem->zName);  }  }  renameWalkWith(pWalker, pSelect);  return WRC_Continue; } static void renameTableFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  sqlite3 *db = sqlite3_context_db_handle(context);  const char *zDb = (const char*)sqlite3_value_text(argv[0]);  const char *zInput = (const char*)sqlite3_value_text(argv[3]);  const char *zOld = (const char*)sqlite3_value_text(argv[4]);  const char *zNew = (const char*)sqlite3_value_text(argv[5]);  int bTemp = sqlite3_value_int(argv[6]);  UNUSED_PARAMETER(NotUsed);  if( zInput && zOld && zNew ){  Parse sParse;  int rc;  int bQuote = 1;  RenameCtx sCtx;  Walker sWalker;
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth = db->xAuth;  db->xAuth = 0;
#endif
 sqlite3BtreeEnterAll(db);  memset(&sCtx, 0, sizeof(RenameCtx));  sCtx.pTab = sqlite3FindTable(db, zOld, zDb);  memset(&sWalker, 0, sizeof(Walker));  sWalker.pParse = &sParse;  sWalker.xExprCallback = renameTableExprCb;  sWalker.xSelectCallback = renameTableSelectCb;  sWalker.u.pRename = &sCtx;  rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);  if( rc==SQLITE_OK ){  int isLegacy = (db->flags & SQLITE_LegacyAlter);  if( sParse.pNewTable ){  Table *pTab = sParse.pNewTable;  if( IsView(pTab) ){  if( isLegacy==0 ){  Select *pSelect = pTab->u.view.pSelect;  NameContext sNC;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = &sParse;  assert( pSelect->selFlags & SF_View );  pSelect->selFlags &= ~SF_View;  sqlite3SelectPrep(&sParse, pTab->u.view.pSelect, &sNC);  if( sParse.nErr ){  rc = sParse.rc;  }else{  sqlite3WalkSelect(&sWalker, pTab->u.view.pSelect);  }  }  }else{
#ifndef SQLITE_OMIT_FOREIGN_KEY
 if( (isLegacy==0 || (db->flags & SQLITE_ForeignKeys))   && !IsVirtual(pTab)  ){  FKey *pFKey;  assert( IsOrdinaryTable(pTab) );  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){  if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){  renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);  }  }  }
#endif
 if( sqlite3_stricmp(zOld, pTab->zName)==0 ){  sCtx.pTab = pTab;  if( isLegacy==0 ){  sqlite3WalkExprList(&sWalker, pTab->pCheck);  }  renameTokenFind(&sParse, &sCtx, pTab->zName);  }  }  }  else if( sParse.pNewIndex ){  renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);  if( isLegacy==0 ){  sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);  }  }
#ifndef SQLITE_OMIT_TRIGGER
 else{  Trigger *pTrigger = sParse.pNewTrigger;  TriggerStep *pStep;  if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld)  && sCtx.pTab->pSchema==pTrigger->pTabSchema  ){  renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);  }  if( isLegacy==0 ){  rc = renameResolveTrigger(&sParse);  if( rc==SQLITE_OK ){  renameWalkTrigger(&sWalker, pTrigger);  for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){  if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){  renameTokenFind(&sParse, &sCtx, pStep->zTarget);  }  }  }  }  }
#endif
 }  if( rc==SQLITE_OK ){  rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);  }  if( rc!=SQLITE_OK ){  if( sParse.zErrMsg ){  renameColumnParseError(context, "", argv[1], argv[2], &sParse);  }else{  sqlite3_result_error_code(context, rc);  }  }  renameParseCleanup(&sParse);  renameTokenFree(db, sCtx.pList);  sqlite3BtreeLeaveAll(db);
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = xAuth;
#endif
 }  return; } static int renameQuotefixExprCb(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_STRING && (pExpr->flags & EP_DblQuoted) ){  renameTokenFind(pWalker->pParse, pWalker->u.pRename, (const void*)pExpr);  }  return WRC_Continue; } static void renameQuotefixFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  sqlite3 *db = sqlite3_context_db_handle(context);  char const *zDb = (const char*)sqlite3_value_text(argv[0]);  char const *zInput = (const char*)sqlite3_value_text(argv[1]);
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth = db->xAuth;  db->xAuth = 0;
#endif
 sqlite3BtreeEnterAll(db);  UNUSED_PARAMETER(NotUsed);  if( zDb && zInput ){  int rc;  Parse sParse;  rc = renameParseSql(&sParse, zDb, db, zInput, 0);  if( rc==SQLITE_OK ){  RenameCtx sCtx;  Walker sWalker;  memset(&sCtx, 0, sizeof(RenameCtx));  memset(&sWalker, 0, sizeof(Walker));  sWalker.pParse = &sParse;  sWalker.xExprCallback = renameQuotefixExprCb;  sWalker.xSelectCallback = renameColumnSelectCb;  sWalker.u.pRename = &sCtx;  if( sParse.pNewTable ){  if( IsView(sParse.pNewTable) ){  Select *pSelect = sParse.pNewTable->u.view.pSelect;  pSelect->selFlags &= ~SF_View;  sParse.rc = SQLITE_OK;  sqlite3SelectPrep(&sParse, pSelect, 0);  rc = (db->mallocFailed ? SQLITE_NOMEM : sParse.rc);  if( rc==SQLITE_OK ){  sqlite3WalkSelect(&sWalker, pSelect);  }  }else{  int i;  sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 for(i=0; i<sParse.pNewTable->nCol; i++){  sqlite3WalkExpr(&sWalker,   sqlite3ColumnExpr(sParse.pNewTable,   &sParse.pNewTable->aCol[i]));  }
#endif
 }  }else if( sParse.pNewIndex ){  sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);  sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);  }else{
#ifndef SQLITE_OMIT_TRIGGER
 rc = renameResolveTrigger(&sParse);  if( rc==SQLITE_OK ){  renameWalkTrigger(&sWalker, sParse.pNewTrigger);  }
#endif
 }  if( rc==SQLITE_OK ){  rc = renameEditSql(context, &sCtx, zInput, 0, 0);  }  renameTokenFree(db, sCtx.pList);  }  if( rc!=SQLITE_OK ){  sqlite3_result_error_code(context, rc);  }  renameParseCleanup(&sParse);  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = xAuth;
#endif
 sqlite3BtreeLeaveAll(db); } static void renameTableTest(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  sqlite3 *db = sqlite3_context_db_handle(context);  char const *zDb = (const char*)sqlite3_value_text(argv[0]);  char const *zInput = (const char*)sqlite3_value_text(argv[1]);  int bTemp = sqlite3_value_int(argv[4]);  int isLegacy = (db->flags & SQLITE_LegacyAlter);  char const *zWhen = (const char*)sqlite3_value_text(argv[5]);  int bNoDQS = sqlite3_value_int(argv[6]);
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth = db->xAuth;  db->xAuth = 0;
#endif
 UNUSED_PARAMETER(NotUsed);  if( zDb && zInput ){  int rc;  Parse sParse;  int flags = db->flags;  if( bNoDQS ) db->flags &= ~(SQLITE_DqsDML|SQLITE_DqsDDL);  rc = renameParseSql(&sParse, zDb, db, zInput, bTemp);  db->flags |= (flags & (SQLITE_DqsDML|SQLITE_DqsDDL));  if( rc==SQLITE_OK ){  if( isLegacy==0 && sParse.pNewTable && IsView(sParse.pNewTable) ){  NameContext sNC;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = &sParse;  sqlite3SelectPrep(&sParse, sParse.pNewTable->u.view.pSelect, &sNC);  if( sParse.nErr ) rc = sParse.rc;  }  else if( sParse.pNewTrigger ){  if( isLegacy==0 ){  rc = renameResolveTrigger(&sParse);  }  if( rc==SQLITE_OK ){  int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);  int i2 = sqlite3FindDbName(db, zDb);  if( i1==i2 ) sqlite3_result_int(context, 1);  }  }  }  if( rc!=SQLITE_OK && zWhen ){  renameColumnParseError(context, zWhen, argv[2], argv[3],&sParse);  }  renameParseCleanup(&sParse);  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = xAuth;
#endif
} static void dropColumnFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  sqlite3 *db = sqlite3_context_db_handle(context);  int iSchema = sqlite3_value_int(argv[0]);  const char *zSql = (const char*)sqlite3_value_text(argv[1]);  int iCol = sqlite3_value_int(argv[2]);  const char *zDb = db->aDb[iSchema].zDbSName;  int rc;  Parse sParse;  RenameToken *pCol;  Table *pTab;  const char *zEnd;  char *zNew = 0;
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth = db->xAuth;  db->xAuth = 0;
#endif
 UNUSED_PARAMETER(NotUsed);  rc = renameParseSql(&sParse, zDb, db, zSql, iSchema==1);  if( rc!=SQLITE_OK ) goto drop_column_done;  pTab = sParse.pNewTable;  if( pTab==0 || pTab->nCol==1 || iCol>=pTab->nCol ){  rc = SQLITE_CORRUPT_BKPT;  goto drop_column_done;  }  pCol = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol].zCnName);  if( iCol<pTab->nCol-1 ){  RenameToken *pEnd;  pEnd = renameTokenFind(&sParse, 0, (void*)pTab->aCol[iCol+1].zCnName);  zEnd = (const char*)pEnd->t.z;  }else{  assert( IsOrdinaryTable(pTab) );  zEnd = (const char*)&zSql[pTab->u.tab.addColOffset];  while( ALWAYS(pCol->t.z[0]!=0) && pCol->t.z[0]!=',' ) pCol->t.z--;  }  zNew = sqlite3MPrintf(db, "%.*s%s", pCol->t.z-zSql, zSql, zEnd);  sqlite3_result_text(context, zNew, -1, SQLITE_TRANSIENT);  sqlite3_free(zNew); drop_column_done:  renameParseCleanup(&sParse);
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = xAuth;
#endif
 if( rc!=SQLITE_OK ){  sqlite3_result_error_code(context, rc);  } } SQLITE_PRIVATE void sqlite3AlterDropColumn(Parse *pParse, SrcList *pSrc, const Token *pName){  sqlite3 *db = pParse->db;  Table *pTab;  int iDb;  const char *zDb;  char *zCol = 0;  int iCol;  assert( pParse->pNewTable==0 );  assert( sqlite3BtreeHoldsAllMutexes(db) );  if( NEVER(db->mallocFailed) ) goto exit_drop_column;  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);  if( !pTab ) goto exit_drop_column;  if( SQLITE_OK!=isAlterableTable(pParse, pTab) ) goto exit_drop_column;  if( SQLITE_OK!=isRealTable(pParse, pTab, 1) ) goto exit_drop_column;  zCol = sqlite3NameFromToken(db, pName);  if( zCol==0 ){  assert( db->mallocFailed );  goto exit_drop_column;  }  iCol = sqlite3ColumnIndex(pTab, zCol);  if( iCol<0 ){  sqlite3ErrorMsg(pParse, "no such column: \"%s\"", zCol);  goto exit_drop_column;  }  if( pTab->aCol[iCol].colFlags & (COLFLAG_PRIMKEY|COLFLAG_UNIQUE) ){  sqlite3ErrorMsg(pParse, "cannot drop %s column: \"%s\"",  (pTab->aCol[iCol].colFlags&COLFLAG_PRIMKEY) ? "PRIMARY KEY" : "UNIQUE",  zCol  );  goto exit_drop_column;  }  if( pTab->nCol<=1 ){  sqlite3ErrorMsg(pParse, "cannot drop column \"%s\": no other columns exist",zCol);  goto exit_drop_column;  }  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iDb>=0 );  zDb = db->aDb[iDb].zDbSName;  renameTestSchema(pParse, zDb, iDb==1, "", 0);  renameFixQuotes(pParse, zDb, iDb==1);  sqlite3NestedParse(pParse,  "UPDATE \"%w\"." LEGACY_SCHEMA_TABLE " SET "  "sql = sqlite_drop_column(%d, sql, %d) "  "WHERE (type=='table' AND tbl_name=%Q COLLATE nocase)"  , zDb, iDb, iCol, pTab->zName  );  renameReloadSchema(pParse, iDb, INITFLAG_AlterDrop);  renameTestSchema(pParse, zDb, iDb==1, "after drop column", 1);  if( pParse->nErr==0 && (pTab->aCol[iCol].colFlags & COLFLAG_VIRTUAL)==0 ){  int i;  int addr;  int reg;  int regRec;  Index *pPk = 0;  int nField = 0;  int iCur;  Vdbe *v = sqlite3GetVdbe(pParse);  iCur = pParse->nTab++;  sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenWrite);  addr = sqlite3VdbeAddOp1(v, OP_Rewind, iCur); VdbeCoverage(v);  reg = ++pParse->nMem;  if( HasRowid(pTab) ){  sqlite3VdbeAddOp2(v, OP_Rowid, iCur, reg);  pParse->nMem += pTab->nCol;  }else{  pPk = sqlite3PrimaryKeyIndex(pTab);  pParse->nMem += pPk->nColumn;  for(i=0; i<pPk->nKeyCol; i++){  sqlite3VdbeAddOp3(v, OP_Column, iCur, i, reg+i+1);  }  nField = pPk->nKeyCol;  }  regRec = ++pParse->nMem;  for(i=0; i<pTab->nCol; i++){  if( i!=iCol && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){  int regOut;  if( pPk ){  int iPos = sqlite3TableColumnToIndex(pPk, i);  int iColPos = sqlite3TableColumnToIndex(pPk, iCol);  if( iPos<pPk->nKeyCol ) continue;  regOut = reg+1+iPos-(iPos>iColPos);  }else{  regOut = reg+1+nField;  }  if( i==pTab->iPKey ){  sqlite3VdbeAddOp2(v, OP_Null, 0, regOut);  }else{  sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut);  }  nField++;  }  }  if( nField==0 ){  pParse->nMem++;  sqlite3VdbeAddOp2(v, OP_Null, 0, reg+1);  nField = 1;  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, reg+1, nField, regRec);  if( pPk ){  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iCur, regRec, reg+1, pPk->nKeyCol);  }else{  sqlite3VdbeAddOp3(v, OP_Insert, iCur, regRec, reg);  }  sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);  sqlite3VdbeAddOp2(v, OP_Next, iCur, addr+1); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr);  } exit_drop_column:  sqlite3DbFree(db, zCol);  sqlite3SrcListDelete(db, pSrc); } SQLITE_PRIVATE void sqlite3AlterFunctions(void){  static FuncDef aAlterTableFuncs[] = {  INTERNAL_FUNCTION(sqlite_rename_column, 9, renameColumnFunc),  INTERNAL_FUNCTION(sqlite_rename_table, 7, renameTableFunc),  INTERNAL_FUNCTION(sqlite_rename_test, 7, renameTableTest),  INTERNAL_FUNCTION(sqlite_drop_column, 3, dropColumnFunc),  INTERNAL_FUNCTION(sqlite_rename_quotefix,2, renameQuotefixFunc),  };  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ArraySize(aAlterTableFuncs)); }
#endif
#ifndef SQLITE_OMIT_ANALYZE
#if defined(SQLITE_ENABLE_STAT4)
# define IsStat4  1
#else
# define IsStat4  0
# undef SQLITE_STAT4_SAMPLES
# define SQLITE_STAT4_SAMPLES 1
#endif
static void openStatTable(  Parse *pParse,  int iDb,  int iStatCur,  const char *zWhere,  const char *zWhereType ){  static const struct {  const char *zName;  const char *zCols;  } aTable[] = {  { "sqlite_stat1", "tbl,idx,stat" },
#if defined(SQLITE_ENABLE_STAT4)
 { "sqlite_stat4", "tbl,idx,neq,nlt,ndlt,sample" },
#else
 { "sqlite_stat4", 0 },
#endif
 { "sqlite_stat3", 0 },  };  int i;  sqlite3 *db = pParse->db;  Db *pDb;  Vdbe *v = sqlite3GetVdbe(pParse);  u32 aRoot[ArraySize(aTable)];  u8 aCreateTbl[ArraySize(aTable)];
#ifdef SQLITE_ENABLE_STAT4
 const int nToOpen = OptimizationEnabled(db,SQLITE_Stat4) ? 2 : 1;
#else
 const int nToOpen = 1;
#endif
 if( v==0 ) return;  assert( sqlite3BtreeHoldsAllMutexes(db) );  assert( sqlite3VdbeDb(v)==db );  pDb = &db->aDb[iDb];  for(i=0; i<ArraySize(aTable); i++){  const char *zTab = aTable[i].zName;  Table *pStat;  aCreateTbl[i] = 0;  if( (pStat = sqlite3FindTable(db, zTab, pDb->zDbSName))==0 ){  if( i<nToOpen ){  sqlite3NestedParse(pParse,  "CREATE TABLE %Q.%s(%s)", pDb->zDbSName, zTab, aTable[i].zCols  );  aRoot[i] = (u32)pParse->regRoot;  aCreateTbl[i] = OPFLAG_P2ISREG;  }  }else{  aRoot[i] = pStat->tnum;  sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);  if( zWhere ){  sqlite3NestedParse(pParse,   "DELETE FROM %Q.%s WHERE %s=%Q",   pDb->zDbSName, zTab, zWhereType, zWhere  );
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 }else if( db->xPreUpdateCallback ){  sqlite3NestedParse(pParse, "DELETE FROM %Q.%s", pDb->zDbSName, zTab);
#endif
 }else{  sqlite3VdbeAddOp2(v, OP_Clear, (int)aRoot[i], iDb);  }  }  }  for(i=0; i<nToOpen; i++){  assert( i<ArraySize(aTable) );  sqlite3VdbeAddOp4Int(v, OP_OpenWrite, iStatCur+i, (int)aRoot[i], iDb, 3);  sqlite3VdbeChangeP5(v, aCreateTbl[i]);  VdbeComment((v, aTable[i].zName));  } }
#ifndef SQLITE_STAT4_SAMPLES
# define SQLITE_STAT4_SAMPLES 24
#endif
typedef struct StatAccum StatAccum; typedef struct StatSample StatSample; struct StatSample {  tRowcnt *anEq;  tRowcnt *anDLt;
#ifdef SQLITE_ENABLE_STAT4
 tRowcnt *anLt;  union {  i64 iRowid;  u8 *aRowid;  } u;  u32 nRowid;  u8 isPSample;  int iCol;  u32 iHash;
#endif
}; struct StatAccum {  sqlite3 *db;  tRowcnt nEst;  tRowcnt nRow;  int nLimit;  int nCol;  int nKeyCol;  u8 nSkipAhead;  StatSample current;
#ifdef SQLITE_ENABLE_STAT4
 tRowcnt nPSample;  int mxSample;  u32 iPrn;  StatSample *aBest;  int iMin;  int nSample;  int nMaxEqZero;  int iGet;  StatSample *a;
#endif
};
#ifdef SQLITE_ENABLE_STAT4
static void sampleClear(sqlite3 *db, StatSample *p){  assert( db!=0 );  if( p->nRowid ){  sqlite3DbFree(db, p->u.aRowid);  p->nRowid = 0;  } }
#endif
#ifdef SQLITE_ENABLE_STAT4
static void sampleSetRowid(sqlite3 *db, StatSample *p, int n, const u8 *pData){  assert( db!=0 );  if( p->nRowid ) sqlite3DbFree(db, p->u.aRowid);  p->u.aRowid = sqlite3DbMallocRawNN(db, n);  if( p->u.aRowid ){  p->nRowid = n;  memcpy(p->u.aRowid, pData, n);  }else{  p->nRowid = 0;  } }
#endif
#ifdef SQLITE_ENABLE_STAT4
static void sampleSetRowidInt64(sqlite3 *db, StatSample *p, i64 iRowid){  assert( db!=0 );  if( p->nRowid ) sqlite3DbFree(db, p->u.aRowid);  p->nRowid = 0;  p->u.iRowid = iRowid; }
#endif
#ifdef SQLITE_ENABLE_STAT4
static void sampleCopy(StatAccum *p, StatSample *pTo, StatSample *pFrom){  pTo->isPSample = pFrom->isPSample;  pTo->iCol = pFrom->iCol;  pTo->iHash = pFrom->iHash;  memcpy(pTo->anEq, pFrom->anEq, sizeof(tRowcnt)*p->nCol);  memcpy(pTo->anLt, pFrom->anLt, sizeof(tRowcnt)*p->nCol);  memcpy(pTo->anDLt, pFrom->anDLt, sizeof(tRowcnt)*p->nCol);  if( pFrom->nRowid ){  sampleSetRowid(p->db, pTo, pFrom->nRowid, pFrom->u.aRowid);  }else{  sampleSetRowidInt64(p->db, pTo, pFrom->u.iRowid);  } }
#endif
static void statAccumDestructor(void *pOld){  StatAccum *p = (StatAccum*)pOld;
#ifdef SQLITE_ENABLE_STAT4
 if( p->mxSample ){  int i;  for(i=0; i<p->nCol; i++) sampleClear(p->db, p->aBest+i);  for(i=0; i<p->mxSample; i++) sampleClear(p->db, p->a+i);  sampleClear(p->db, &p->current);  }
#endif
 sqlite3DbFree(p->db, p); } static void statInit(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  StatAccum *p;  int nCol;  int nKeyCol;  int nColUp;  int n;  sqlite3 *db = sqlite3_context_db_handle(context);
#ifdef SQLITE_ENABLE_STAT4
 int mxSample = OptimizationEnabled(db,SQLITE_Stat4) ?SQLITE_STAT4_SAMPLES :0;
#endif
 UNUSED_PARAMETER(argc);  nCol = sqlite3_value_int(argv[0]);  assert( nCol>0 );  nColUp = sizeof(tRowcnt)<8 ? (nCol+1)&~1 : nCol;  nKeyCol = sqlite3_value_int(argv[1]);  assert( nKeyCol<=nCol );  assert( nKeyCol>0 );  n = sizeof(*p)  + sizeof(tRowcnt)*nColUp  + sizeof(tRowcnt)*nColUp;
#ifdef SQLITE_ENABLE_STAT4
 if( mxSample ){  n += sizeof(tRowcnt)*nColUp  + sizeof(StatSample)*(nCol+mxSample)  + sizeof(tRowcnt)*3*nColUp*(nCol+mxSample);  }
#endif
 p = sqlite3DbMallocZero(db, n);  if( p==0 ){  sqlite3_result_error_nomem(context);  return;  }  p->db = db;  p->nEst = sqlite3_value_int64(argv[2]);  p->nRow = 0;  p->nLimit = sqlite3_value_int64(argv[3]);  p->nCol = nCol;  p->nKeyCol = nKeyCol;  p->nSkipAhead = 0;  p->current.anDLt = (tRowcnt*)&p[1];  p->current.anEq = &p->current.anDLt[nColUp];
#ifdef SQLITE_ENABLE_STAT4
 p->mxSample = p->nLimit==0 ? mxSample : 0;  if( mxSample ){  u8 *pSpace;  int i;  p->iGet = -1;  p->nPSample = (tRowcnt)(p->nEst/(mxSample/3+1) + 1);  p->current.anLt = &p->current.anEq[nColUp];  p->iPrn = 0x689e962d*(u32)nCol ^ 0xd0944565*(u32)sqlite3_value_int(argv[2]);  p->a = (struct StatSample*)&p->current.anLt[nColUp];  p->aBest = &p->a[mxSample];  pSpace = (u8*)(&p->a[mxSample+nCol]);  for(i=0; i<(mxSample+nCol); i++){  p->a[i].anEq = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);  p->a[i].anLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);  p->a[i].anDLt = (tRowcnt *)pSpace; pSpace += (sizeof(tRowcnt) * nColUp);  }  assert( (pSpace - (u8*)p)==n );  for(i=0; i<nCol; i++){  p->aBest[i].iCol = i;  }  }
#endif
 sqlite3_result_blob(context, p, sizeof(*p), statAccumDestructor); } static const FuncDef statInitFuncdef = {  4,  SQLITE_UTF8,  0,  0,  statInit,  0,  0, 0,  "stat_init",  {0} };
#ifdef SQLITE_ENABLE_STAT4
static int sampleIsBetterPost(  StatAccum *pAccum,  StatSample *pNew,  StatSample *pOld ){  int nCol = pAccum->nCol;  int i;  assert( pNew->iCol==pOld->iCol );  for(i=pNew->iCol+1; i<nCol; i++){  if( pNew->anEq[i]>pOld->anEq[i] ) return 1;  if( pNew->anEq[i]<pOld->anEq[i] ) return 0;  }  if( pNew->iHash>pOld->iHash ) return 1;  return 0; }
#endif
#ifdef SQLITE_ENABLE_STAT4
static int sampleIsBetter(  StatAccum *pAccum,  StatSample *pNew,  StatSample *pOld ){  tRowcnt nEqNew = pNew->anEq[pNew->iCol];  tRowcnt nEqOld = pOld->anEq[pOld->iCol];  assert( pOld->isPSample==0 && pNew->isPSample==0 );  assert( IsStat4 || (pNew->iCol==0 && pOld->iCol==0) );  if( (nEqNew>nEqOld) ) return 1;  if( nEqNew==nEqOld ){  if( pNew->iCol<pOld->iCol ) return 1;  return (pNew->iCol==pOld->iCol && sampleIsBetterPost(pAccum, pNew, pOld));  }  return 0; } static void sampleInsert(StatAccum *p, StatSample *pNew, int nEqZero){  StatSample *pSample = 0;  int i;  assert( IsStat4 || nEqZero==0 );  if( nEqZero>p->nMaxEqZero ){  p->nMaxEqZero = nEqZero;  }  if( pNew->isPSample==0 ){  StatSample *pUpgrade = 0;  assert( pNew->anEq[pNew->iCol]>0 );  for(i=p->nSample-1; i>=0; i--){  StatSample *pOld = &p->a[i];  if( pOld->anEq[pNew->iCol]==0 ){  if( pOld->isPSample ) return;  assert( pOld->iCol>pNew->iCol );  assert( sampleIsBetter(p, pNew, pOld) );  if( pUpgrade==0 || sampleIsBetter(p, pOld, pUpgrade) ){  pUpgrade = pOld;  }  }  }  if( pUpgrade ){  pUpgrade->iCol = pNew->iCol;  pUpgrade->anEq[pUpgrade->iCol] = pNew->anEq[pUpgrade->iCol];  goto find_new_min;  }  }  if( p->nSample>=p->mxSample ){  StatSample *pMin = &p->a[p->iMin];  tRowcnt *anEq = pMin->anEq;  tRowcnt *anLt = pMin->anLt;  tRowcnt *anDLt = pMin->anDLt;  sampleClear(p->db, pMin);  memmove(pMin, &pMin[1], sizeof(p->a[0])*(p->nSample-p->iMin-1));  pSample = &p->a[p->nSample-1];  pSample->nRowid = 0;  pSample->anEq = anEq;  pSample->anDLt = anDLt;  pSample->anLt = anLt;  p->nSample = p->mxSample-1;  }  assert( p->nSample==0   || pNew->anLt[p->nCol-1] > p->a[p->nSample-1].anLt[p->nCol-1] );  pSample = &p->a[p->nSample];  sampleCopy(p, pSample, pNew);  p->nSample++;  memset(pSample->anEq, 0, sizeof(tRowcnt)*nEqZero); find_new_min:  if( p->nSample>=p->mxSample ){  int iMin = -1;  for(i=0; i<p->mxSample; i++){  if( p->a[i].isPSample ) continue;  if( iMin<0 || sampleIsBetter(p, &p->a[iMin], &p->a[i]) ){  iMin = i;  }  }  assert( iMin>=0 );  p->iMin = iMin;  } }
#endif
#ifdef SQLITE_ENABLE_STAT4
static void samplePushPrevious(StatAccum *p, int iChng){  int i;  for(i=(p->nCol-2); i>=iChng; i--){  StatSample *pBest = &p->aBest[i];  pBest->anEq[i] = p->current.anEq[i];  if( p->nSample<p->mxSample || sampleIsBetter(p, pBest, &p->a[p->iMin]) ){  sampleInsert(p, pBest, i);  }  }  for(i=p->nSample-1; i>=0; i--){  int j;  for(j=p->nMaxEqZero; j<p->nCol; j++) assert( p->a[i].anEq[j]>0 );  }  if( iChng<p->nMaxEqZero ){  for(i=p->nSample-1; i>=0; i--){  int j;  for(j=iChng; j<p->nCol; j++){  if( p->a[i].anEq[j]==0 ) p->a[i].anEq[j] = p->current.anEq[j];  }  }  p->nMaxEqZero = iChng;  } }
#endif
static void statPush(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int i;  StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);  int iChng = sqlite3_value_int(argv[1]);  UNUSED_PARAMETER( argc );  UNUSED_PARAMETER( context );  assert( p->nCol>0 );  assert( iChng<p->nCol );  if( p->nRow==0 ){  for(i=0; i<p->nCol; i++) p->current.anEq[i] = 1;  }else{
#ifdef SQLITE_ENABLE_STAT4
 if( p->mxSample ) samplePushPrevious(p, iChng);
#endif
 for(i=0; i<iChng; i++){  p->current.anEq[i]++;  }  for(i=iChng; i<p->nCol; i++){  p->current.anDLt[i]++;
#ifdef SQLITE_ENABLE_STAT4
 if( p->mxSample ) p->current.anLt[i] += p->current.anEq[i];
#endif
 p->current.anEq[i] = 1;  }  }  p->nRow++;
#ifdef SQLITE_ENABLE_STAT4
 if( p->mxSample ){  tRowcnt nLt;  if( sqlite3_value_type(argv[2])==SQLITE_INTEGER ){  sampleSetRowidInt64(p->db, &p->current, sqlite3_value_int64(argv[2]));  }else{  sampleSetRowid(p->db, &p->current, sqlite3_value_bytes(argv[2]),   sqlite3_value_blob(argv[2]));  }  p->current.iHash = p->iPrn = p->iPrn*1103515245 + 12345;  nLt = p->current.anLt[p->nCol-1];  if( (nLt/p->nPSample)!=(nLt+1)/p->nPSample ){  p->current.isPSample = 1;  p->current.iCol = 0;  sampleInsert(p, &p->current, p->nCol-1);  p->current.isPSample = 0;  }  for(i=0; i<(p->nCol-1); i++){  p->current.iCol = i;  if( i>=iChng || sampleIsBetterPost(p, &p->current, &p->aBest[i]) ){  sampleCopy(p, &p->aBest[i], &p->current);  }  }  }else
#endif
 if( p->nLimit && p->nRow>(tRowcnt)p->nLimit*(p->nSkipAhead+1) ){  p->nSkipAhead++;  sqlite3_result_int(context, p->current.anDLt[0]>0);  } } static const FuncDef statPushFuncdef = {  2+IsStat4,  SQLITE_UTF8,  0,  0,  statPush,  0,  0, 0,  "stat_push",  {0} };
#define STAT_GET_STAT1 0
#define STAT_GET_ROWID 1
#define STAT_GET_NEQ  2
#define STAT_GET_NLT  3
#define STAT_GET_NDLT 4
static void statGet(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  StatAccum *p = (StatAccum*)sqlite3_value_blob(argv[0]);
#ifdef SQLITE_ENABLE_STAT4
 int eCall = sqlite3_value_int(argv[1]);  assert( argc==2 );  assert( eCall==STAT_GET_STAT1 || eCall==STAT_GET_NEQ   || eCall==STAT_GET_ROWID || eCall==STAT_GET_NLT   || eCall==STAT_GET_NDLT  );  assert( eCall==STAT_GET_STAT1 || p->mxSample );  if( eCall==STAT_GET_STAT1 )
#else
 assert( argc==1 );
#endif
 {  sqlite3_str sStat;  int i;  sqlite3StrAccumInit(&sStat, 0, 0, 0, (p->nKeyCol+1)*100);  sqlite3_str_appendf(&sStat, "%llu",  p->nSkipAhead ? (u64)p->nEst : (u64)p->nRow);  for(i=0; i<p->nKeyCol; i++){  u64 nDistinct = p->current.anDLt[i] + 1;  u64 iVal = (p->nRow + nDistinct - 1) / nDistinct;  sqlite3_str_appendf(&sStat, " %llu", iVal);  assert( p->current.anEq[i] );  }  sqlite3ResultStrAccum(context, &sStat);  }
#ifdef SQLITE_ENABLE_STAT4
 else if( eCall==STAT_GET_ROWID ){  if( p->iGet<0 ){  samplePushPrevious(p, 0);  p->iGet = 0;  }  if( p->iGet<p->nSample ){  StatSample *pS = p->a + p->iGet;  if( pS->nRowid==0 ){  sqlite3_result_int64(context, pS->u.iRowid);  }else{  sqlite3_result_blob(context, pS->u.aRowid, pS->nRowid,  SQLITE_TRANSIENT);  }  }  }else{  tRowcnt *aCnt = 0;  sqlite3_str sStat;  int i;  assert( p->iGet<p->nSample );  switch( eCall ){  case STAT_GET_NEQ: aCnt = p->a[p->iGet].anEq; break;  case STAT_GET_NLT: aCnt = p->a[p->iGet].anLt; break;  default: {  aCnt = p->a[p->iGet].anDLt;  p->iGet++;  break;  }  }  sqlite3StrAccumInit(&sStat, 0, 0, 0, p->nCol*100);  for(i=0; i<p->nCol; i++){  sqlite3_str_appendf(&sStat, "%llu ", (u64)aCnt[i]);  }  if( sStat.nChar ) sStat.nChar--;  sqlite3ResultStrAccum(context, &sStat);  }
#endif
#ifndef SQLITE_DEBUG
 UNUSED_PARAMETER( argc );
#endif
} static const FuncDef statGetFuncdef = {  1+IsStat4,  SQLITE_UTF8,  0,  0,  statGet,  0,  0, 0,  "stat_get",  {0} }; static void callStatGet(Parse *pParse, int regStat, int iParam, int regOut){
#ifdef SQLITE_ENABLE_STAT4
 sqlite3VdbeAddOp2(pParse->pVdbe, OP_Integer, iParam, regStat+1);
#elif SQLITE_DEBUG
 assert( iParam==STAT_GET_STAT1 );
#else
 UNUSED_PARAMETER( iParam );
#endif
 assert( regOut!=regStat && regOut!=regStat+1 );  sqlite3VdbeAddFunctionCall(pParse, 0, regStat, regOut, 1+IsStat4,   &statGetFuncdef, 0); }
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
static void analyzeVdbeCommentIndexWithColumnName(  Vdbe *v,  Index *pIdx,  int k ){  int i;  assert( k>=0 && k<pIdx->nColumn );  i = pIdx->aiColumn[k];  if( NEVER(i==XN_ROWID) ){  VdbeComment((v,"%s.rowid",pIdx->zName));  }else if( i==XN_EXPR ){  VdbeComment((v,"%s.expr(%d)",pIdx->zName, k));  }else{  VdbeComment((v,"%s.%s", pIdx->zName, pIdx->pTable->aCol[i].zCnName));  } }
#else
# define analyzeVdbeCommentIndexWithColumnName(a,b,c)
#endif
static void analyzeOneTable(  Parse *pParse,  Table *pTab,  Index *pOnlyIdx,  int iStatCur,  int iMem,  int iTab ){  sqlite3 *db = pParse->db;  Index *pIdx;  int iIdxCur;  int iTabCur;  Vdbe *v;  int i;  int jZeroRows = -1;  int iDb;  u8 needTableCnt = 1;  int regNewRowid = iMem++;  int regStat = iMem++;  int regChng = iMem++;  int regRowid = iMem++;  int regTemp = iMem++;  int regTemp2 = iMem++;  int regTabname = iMem++;  int regIdxname = iMem++;  int regStat1 = iMem++;  int regPrev = iMem;
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 Table *pStat1 = 0;
#endif
 pParse->nMem = MAX(pParse->nMem, iMem);  v = sqlite3GetVdbe(pParse);  if( v==0 || NEVER(pTab==0) ){  return;  }  if( !IsOrdinaryTable(pTab) ){  return;  }  if( sqlite3_strlike("sqlite\\_%", pTab->zName, '\\')==0 ){  return;  }  assert( sqlite3BtreeHoldsAllMutexes(db) );  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iDb>=0 );  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab->zName, 0,  db->aDb[iDb].zDbSName ) ){  return;  }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 if( db->xPreUpdateCallback ){  pStat1 = (Table*)sqlite3DbMallocZero(db, sizeof(Table) + 13);  if( pStat1==0 ) return;  pStat1->zName = (char*)&pStat1[1];  memcpy(pStat1->zName, "sqlite_stat1", 13);  pStat1->nCol = 3;  pStat1->iPKey = -1;  sqlite3VdbeAddOp4(pParse->pVdbe, OP_Noop, 0, 0, 0,(char*)pStat1,P4_DYNBLOB);  }
#endif
 sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);  iTabCur = iTab++;  iIdxCur = iTab++;  pParse->nTab = MAX(pParse->nTab, iTab);  sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);  sqlite3VdbeLoadString(v, regTabname, pTab->zName);  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  int nCol;  int addrRewind;  int addrNextRow;  const char *zIdxName;  int nColTest;  if( pOnlyIdx && pOnlyIdx!=pIdx ) continue;  if( pIdx->pPartIdxWhere==0 ) needTableCnt = 0;  if( !HasRowid(pTab) && IsPrimaryKeyIndex(pIdx) ){  nCol = pIdx->nKeyCol;  zIdxName = pTab->zName;  nColTest = nCol - 1;  }else{  nCol = pIdx->nColumn;  zIdxName = pIdx->zName;  nColTest = pIdx->uniqNotNull ? pIdx->nKeyCol-1 : nCol-1;  }  sqlite3VdbeLoadString(v, regIdxname, zIdxName);  VdbeComment((v, "Analysis for %s.%s", pTab->zName, zIdxName));  pParse->nMem = MAX(pParse->nMem, regPrev+nColTest);  assert( iDb==sqlite3SchemaToIndex(db, pIdx->pSchema) );  sqlite3VdbeAddOp3(v, OP_OpenRead, iIdxCur, pIdx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);  VdbeComment((v, "%s", pIdx->zName));  sqlite3VdbeAddOp2(v, OP_Integer, nCol, regStat+1);  assert( regRowid==regStat+2 );  sqlite3VdbeAddOp2(v, OP_Integer, pIdx->nKeyCol, regRowid);
#ifdef SQLITE_ENABLE_STAT4
 if( OptimizationEnabled(db, SQLITE_Stat4) ){  sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regTemp);  addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);  VdbeCoverage(v);  }else
#endif
 {  addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_Count, iIdxCur, regTemp, 1);  }  assert( regTemp2==regStat+4 );  sqlite3VdbeAddOp2(v, OP_Integer, db->nAnalysisLimit, regTemp2);  sqlite3VdbeAddFunctionCall(pParse, 0, regStat+1, regStat, 4,   &statInitFuncdef, 0);  sqlite3VdbeAddOp2(v, OP_Integer, 0, regChng);  addrNextRow = sqlite3VdbeCurrentAddr(v);  if( nColTest>0 ){  int endDistinctTest = sqlite3VdbeMakeLabel(pParse);  int *aGotoChng;  aGotoChng = sqlite3DbMallocRawNN(db, sizeof(int)*nColTest);  if( aGotoChng==0 ) continue;  sqlite3VdbeAddOp0(v, OP_Goto);  addrNextRow = sqlite3VdbeCurrentAddr(v);  if( nColTest==1 && pIdx->nKeyCol==1 && IsUniqueIndex(pIdx) ){  sqlite3VdbeAddOp2(v, OP_NotNull, regPrev, endDistinctTest);  VdbeCoverage(v);  }  for(i=0; i<nColTest; i++){  char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);  sqlite3VdbeAddOp2(v, OP_Integer, i, regChng);  sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regTemp);  analyzeVdbeCommentIndexWithColumnName(v,pIdx,i);  aGotoChng[i] =  sqlite3VdbeAddOp4(v, OP_Ne, regTemp, 0, regPrev+i, pColl, P4_COLLSEQ);  sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);  VdbeCoverage(v);  }  sqlite3VdbeAddOp2(v, OP_Integer, nColTest, regChng);  sqlite3VdbeGoto(v, endDistinctTest);  sqlite3VdbeJumpHere(v, addrNextRow-1);  for(i=0; i<nColTest; i++){  sqlite3VdbeJumpHere(v, aGotoChng[i]);  sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regPrev+i);  analyzeVdbeCommentIndexWithColumnName(v,pIdx,i);  }  sqlite3VdbeResolveLabel(v, endDistinctTest);  sqlite3DbFree(db, aGotoChng);  }
#ifdef SQLITE_ENABLE_STAT4
 if( OptimizationEnabled(db, SQLITE_Stat4) ){  assert( regRowid==(regStat+2) );  if( HasRowid(pTab) ){  sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, regRowid);  }else{  Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);  int j, k, regKey;  regKey = sqlite3GetTempRange(pParse, pPk->nKeyCol);  for(j=0; j<pPk->nKeyCol; j++){  k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);  assert( k>=0 && k<pIdx->nColumn );  sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, regKey+j);  analyzeVdbeCommentIndexWithColumnName(v,pIdx,k);  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, regKey, pPk->nKeyCol, regRowid);  sqlite3ReleaseTempRange(pParse, regKey, pPk->nKeyCol);  }  }
#endif
 assert( regChng==(regStat+1) );  {  sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+IsStat4,   &statPushFuncdef, 0);  if( db->nAnalysisLimit ){  int j1, j2, j3;  j1 = sqlite3VdbeAddOp1(v, OP_IsNull, regTemp); VdbeCoverage(v);  j2 = sqlite3VdbeAddOp1(v, OP_If, regTemp); VdbeCoverage(v);  j3 = sqlite3VdbeAddOp4Int(v, OP_SeekGT, iIdxCur, 0, regPrev, 1);  VdbeCoverage(v);  sqlite3VdbeJumpHere(v, j1);  sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, j2);  sqlite3VdbeJumpHere(v, j3);  }else{  sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, addrNextRow); VdbeCoverage(v);  }  }  callStatGet(pParse, regStat, STAT_GET_STAT1, regStat1);  assert( "BBB"[0]==SQLITE_AFF_TEXT );  sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, "BBB", 0);  sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);  sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 sqlite3VdbeChangeP4(v, -1, (char*)pStat1, P4_TABLE);
#endif
 sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
#ifdef SQLITE_ENABLE_STAT4
 if( OptimizationEnabled(db, SQLITE_Stat4) && db->nAnalysisLimit==0 ){  int regEq = regStat1;  int regLt = regStat1+1;  int regDLt = regStat1+2;  int regSample = regStat1+3;  int regCol = regStat1+4;  int regSampleRowid = regCol + nCol;  int addrNext;  int addrIsNull;  u8 seekOp = HasRowid(pTab) ? OP_NotExists : OP_NotFound;  pParse->nMem = MAX(pParse->nMem, regCol+nCol);  addrNext = sqlite3VdbeCurrentAddr(v);  callStatGet(pParse, regStat, STAT_GET_ROWID, regSampleRowid);  addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regSampleRowid);  VdbeCoverage(v);  callStatGet(pParse, regStat, STAT_GET_NEQ, regEq);  callStatGet(pParse, regStat, STAT_GET_NLT, regLt);  callStatGet(pParse, regStat, STAT_GET_NDLT, regDLt);  sqlite3VdbeAddOp4Int(v, seekOp, iTabCur, addrNext, regSampleRowid, 0);  VdbeCoverage(v);  for(i=0; i<nCol; i++){  sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iTabCur, i, regCol+i);  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, regCol, nCol, regSample);  sqlite3VdbeAddOp3(v, OP_MakeRecord, regTabname, 6, regTemp);  sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur+1, regNewRowid);  sqlite3VdbeAddOp3(v, OP_Insert, iStatCur+1, regTemp, regNewRowid);  sqlite3VdbeAddOp2(v, OP_Goto, 1, addrNext);  sqlite3VdbeJumpHere(v, addrIsNull);  }
#endif
 sqlite3VdbeJumpHere(v, addrRewind);  }  if( pOnlyIdx==0 && needTableCnt ){  VdbeComment((v, "%s", pTab->zName));  sqlite3VdbeAddOp2(v, OP_Count, iTabCur, regStat1);  jZeroRows = sqlite3VdbeAddOp1(v, OP_IfNot, regStat1); VdbeCoverage(v);  sqlite3VdbeAddOp2(v, OP_Null, 0, regIdxname);  assert( "BBB"[0]==SQLITE_AFF_TEXT );  sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regTemp, "BBB", 0);  sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regNewRowid);  sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regTemp, regNewRowid);  sqlite3VdbeChangeP5(v, OPFLAG_APPEND);
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 sqlite3VdbeChangeP4(v, -1, (char*)pStat1, P4_TABLE);
#endif
 sqlite3VdbeJumpHere(v, jZeroRows);  } } static void loadAnalysis(Parse *pParse, int iDb){  Vdbe *v = sqlite3GetVdbe(pParse);  if( v ){  sqlite3VdbeAddOp1(v, OP_LoadAnalysis, iDb);  } } static void analyzeDatabase(Parse *pParse, int iDb){  sqlite3 *db = pParse->db;  Schema *pSchema = db->aDb[iDb].pSchema;  HashElem *k;  int iStatCur;  int iMem;  int iTab;  sqlite3BeginWriteOperation(pParse, 0, iDb);  iStatCur = pParse->nTab;  pParse->nTab += 3;  openStatTable(pParse, iDb, iStatCur, 0, 0);  iMem = pParse->nMem+1;  iTab = pParse->nTab;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){  Table *pTab = (Table*)sqliteHashData(k);  analyzeOneTable(pParse, pTab, 0, iStatCur, iMem, iTab);  }  loadAnalysis(pParse, iDb); } static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){  int iDb;  int iStatCur;  assert( pTab!=0 );  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  sqlite3BeginWriteOperation(pParse, 0, iDb);  iStatCur = pParse->nTab;  pParse->nTab += 3;  if( pOnlyIdx ){  openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");  }else{  openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");  }  analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur,pParse->nMem+1,pParse->nTab);  loadAnalysis(pParse, iDb); } SQLITE_PRIVATE void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){  sqlite3 *db = pParse->db;  int iDb;  int i;  char *z, *zDb;  Table *pTab;  Index *pIdx;  Token *pTableName;  Vdbe *v;  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){  return;  }  assert( pName2!=0 || pName1==0 );  if( pName1==0 ){  for(i=0; i<db->nDb; i++){  if( i==1 ) continue;  analyzeDatabase(pParse, i);  }  }else if( pName2->n==0 && (iDb = sqlite3FindDb(db, pName1))>=0 ){  analyzeDatabase(pParse, iDb);  }else{  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);  if( iDb>=0 ){  zDb = pName2->n ? db->aDb[iDb].zDbSName : 0;  z = sqlite3NameFromToken(db, pTableName);  if( z ){  if( (pIdx = sqlite3FindIndex(db, z, zDb))!=0 ){  analyzeTable(pParse, pIdx->pTable, pIdx);  }else if( (pTab = sqlite3LocateTable(pParse, 0, z, zDb))!=0 ){  analyzeTable(pParse, pTab, 0);  }  sqlite3DbFree(db, z);  }  }  }  if( db->nSqlExec==0 && (v = sqlite3GetVdbe(pParse))!=0 ){  sqlite3VdbeAddOp0(v, OP_Expire);  } } typedef struct analysisInfo analysisInfo; struct analysisInfo {  sqlite3 *db;  const char *zDatabase; }; static void decodeIntArray(  char *zIntArray,  int nOut,  tRowcnt *aOut,  LogEst *aLog,  Index *pIndex ){  char *z = zIntArray;  int c;  int i;  tRowcnt v;
#ifdef SQLITE_ENABLE_STAT4
 if( z==0 ) z = "";
#else
 assert( z!=0 );
#endif
 for(i=0; *z && i<nOut; i++){  v = 0;  while( (c=z[0])>='0' && c<='9' ){  v = v*10 + c - '0';  z++;  }
#ifdef SQLITE_ENABLE_STAT4
 if( aOut ) aOut[i] = v;  if( aLog ) aLog[i] = sqlite3LogEst(v);
#else
 assert( aOut==0 );  UNUSED_PARAMETER(aOut);  assert( aLog!=0 );  aLog[i] = sqlite3LogEst(v);
#endif
 if( *z==' ' ) z++;  }
#ifndef SQLITE_ENABLE_STAT4
 assert( pIndex!=0 ); {
#else
 if( pIndex ){
#endif
 pIndex->bUnordered = 0;  pIndex->noSkipScan = 0;  while( z[0] ){  if( sqlite3_strglob("unordered*", z)==0 ){  pIndex->bUnordered = 1;  }else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){  int sz = sqlite3Atoi(z+3);  if( sz<2 ) sz = 2;  pIndex->szIdxRow = sqlite3LogEst(sz);  }else if( sqlite3_strglob("noskipscan*", z)==0 ){  pIndex->noSkipScan = 1;  }
#ifdef SQLITE_ENABLE_COSTMULT
 else if( sqlite3_strglob("costmult=[0-9]*",z)==0 ){  pIndex->pTable->costMult = sqlite3LogEst(sqlite3Atoi(z+9));  }
#endif
 while( z[0]!=0 && z[0]!=' ' ) z++;  while( z[0]==' ' ) z++;  }  } } static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){  analysisInfo *pInfo = (analysisInfo*)pData;  Index *pIndex;  Table *pTable;  const char *z;  assert( argc==3 );  UNUSED_PARAMETER2(NotUsed, argc);  if( argv==0 || argv[0]==0 || argv[2]==0 ){  return 0;  }  pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);  if( pTable==0 ){  return 0;  }  if( argv[1]==0 ){  pIndex = 0;  }else if( sqlite3_stricmp(argv[0],argv[1])==0 ){  pIndex = sqlite3PrimaryKeyIndex(pTable);  }else{  pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);  }  z = argv[2];  if( pIndex ){  tRowcnt *aiRowEst = 0;  int nCol = pIndex->nKeyCol+1;
#ifdef SQLITE_ENABLE_STAT4
 if( pIndex->aiRowEst==0 ){  pIndex->aiRowEst = (tRowcnt*)sqlite3MallocZero(sizeof(tRowcnt) * nCol);  if( pIndex->aiRowEst==0 ) sqlite3OomFault(pInfo->db);  }  aiRowEst = pIndex->aiRowEst;
#endif
 pIndex->bUnordered = 0;  decodeIntArray((char*)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);  pIndex->hasStat1 = 1;  if( pIndex->pPartIdxWhere==0 ){  pTable->nRowLogEst = pIndex->aiRowLogEst[0];  pTable->tabFlags |= TF_HasStat1;  }  }else{  Index fakeIdx;  fakeIdx.szIdxRow = pTable->szTabRow;
#ifdef SQLITE_ENABLE_COSTMULT
 fakeIdx.pTable = pTable;
#endif
 decodeIntArray((char*)z, 1, 0, &pTable->nRowLogEst, &fakeIdx);  pTable->szTabRow = fakeIdx.szIdxRow;  pTable->tabFlags |= TF_HasStat1;  }  return 0; } SQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){
#ifdef SQLITE_ENABLE_STAT4
 if( pIdx->aSample ){  int j;  for(j=0; j<pIdx->nSample; j++){  IndexSample *p = &pIdx->aSample[j];  sqlite3DbFree(db, p->p);  }  sqlite3DbFree(db, pIdx->aSample);  }  if( db && db->pnBytesFreed==0 ){  pIdx->nSample = 0;  pIdx->aSample = 0;  }
#else
 UNUSED_PARAMETER(db);  UNUSED_PARAMETER(pIdx);
#endif
}
#ifdef SQLITE_ENABLE_STAT4
static void initAvgEq(Index *pIdx){  if( pIdx ){  IndexSample *aSample = pIdx->aSample;  IndexSample *pFinal = &aSample[pIdx->nSample-1];  int iCol;  int nCol = 1;  if( pIdx->nSampleCol>1 ){  nCol = pIdx->nSampleCol-1;  pIdx->aAvgEq[nCol] = 1;  }  for(iCol=0; iCol<nCol; iCol++){  int nSample = pIdx->nSample;  int i;  tRowcnt sumEq = 0;  tRowcnt avgEq = 0;  tRowcnt nRow;  i64 nSum100 = 0;  i64 nDist100;  if( !pIdx->aiRowEst || iCol>=pIdx->nKeyCol || pIdx->aiRowEst[iCol+1]==0 ){  nRow = pFinal->anLt[iCol];  nDist100 = (i64)100 * pFinal->anDLt[iCol];  nSample--;  }else{  nRow = pIdx->aiRowEst[0];  nDist100 = ((i64)100 * pIdx->aiRowEst[0]) / pIdx->aiRowEst[iCol+1];  }  pIdx->nRowEst0 = nRow;  for(i=0; i<nSample; i++){  if( i==(pIdx->nSample-1)   || aSample[i].anDLt[iCol]!=aSample[i+1].anDLt[iCol]  ){  sumEq += aSample[i].anEq[iCol];  nSum100 += 100;  }  }  if( nDist100>nSum100 && sumEq<nRow ){  avgEq = ((i64)100 * (nRow - sumEq))/(nDist100 - nSum100);  }  if( avgEq==0 ) avgEq = 1;  pIdx->aAvgEq[iCol] = avgEq;  }  } } static Index *findIndexOrPrimaryKey(  sqlite3 *db,  const char *zName,  const char *zDb ){  Index *pIdx = sqlite3FindIndex(db, zName, zDb);  if( pIdx==0 ){  Table *pTab = sqlite3FindTable(db, zName, zDb);  if( pTab && !HasRowid(pTab) ) pIdx = sqlite3PrimaryKeyIndex(pTab);  }  return pIdx; } static int loadStatTbl(  sqlite3 *db,  const char *zSql1,  const char *zSql2,  const char *zDb ){  int rc;  sqlite3_stmt *pStmt = 0;  char *zSql;  Index *pPrevIdx = 0;  IndexSample *pSample;  assert( db->lookaside.bDisable );  zSql = sqlite3MPrintf(db, zSql1, zDb);  if( !zSql ){  return SQLITE_NOMEM_BKPT;  }  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);  sqlite3DbFree(db, zSql);  if( rc ) return rc;  while( sqlite3_step(pStmt)==SQLITE_ROW ){  int nIdxCol = 1;  char *zIndex;  Index *pIdx;  int nSample;  int nByte;  int i;  tRowcnt *pSpace;  zIndex = (char *)sqlite3_column_text(pStmt, 0);  if( zIndex==0 ) continue;  nSample = sqlite3_column_int(pStmt, 1);  pIdx = findIndexOrPrimaryKey(db, zIndex, zDb);  assert( pIdx==0 || pIdx->nSample==0 );  if( pIdx==0 ) continue;  assert( !HasRowid(pIdx->pTable) || pIdx->nColumn==pIdx->nKeyCol+1 );  if( !HasRowid(pIdx->pTable) && IsPrimaryKeyIndex(pIdx) ){  nIdxCol = pIdx->nKeyCol;  }else{  nIdxCol = pIdx->nColumn;  }  pIdx->nSampleCol = nIdxCol;  nByte = sizeof(IndexSample) * nSample;  nByte += sizeof(tRowcnt) * nIdxCol * 3 * nSample;  nByte += nIdxCol * sizeof(tRowcnt);  pIdx->aSample = sqlite3DbMallocZero(db, nByte);  if( pIdx->aSample==0 ){  sqlite3_finalize(pStmt);  return SQLITE_NOMEM_BKPT;  }  pSpace = (tRowcnt*)&pIdx->aSample[nSample];  pIdx->aAvgEq = pSpace; pSpace += nIdxCol;  pIdx->pTable->tabFlags |= TF_HasStat4;  for(i=0; i<nSample; i++){  pIdx->aSample[i].anEq = pSpace; pSpace += nIdxCol;  pIdx->aSample[i].anLt = pSpace; pSpace += nIdxCol;  pIdx->aSample[i].anDLt = pSpace; pSpace += nIdxCol;  }  assert( ((u8*)pSpace)-nByte==(u8*)(pIdx->aSample) );  }  rc = sqlite3_finalize(pStmt);  if( rc ) return rc;  zSql = sqlite3MPrintf(db, zSql2, zDb);  if( !zSql ){  return SQLITE_NOMEM_BKPT;  }  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);  sqlite3DbFree(db, zSql);  if( rc ) return rc;  while( sqlite3_step(pStmt)==SQLITE_ROW ){  char *zIndex;  Index *pIdx;  int nCol = 1;  zIndex = (char *)sqlite3_column_text(pStmt, 0);  if( zIndex==0 ) continue;  pIdx = findIndexOrPrimaryKey(db, zIndex, zDb);  if( pIdx==0 ) continue;  nCol = pIdx->nSampleCol;  if( pIdx!=pPrevIdx ){  initAvgEq(pPrevIdx);  pPrevIdx = pIdx;  }  pSample = &pIdx->aSample[pIdx->nSample];  decodeIntArray((char*)sqlite3_column_text(pStmt,1),nCol,pSample->anEq,0,0);  decodeIntArray((char*)sqlite3_column_text(pStmt,2),nCol,pSample->anLt,0,0);  decodeIntArray((char*)sqlite3_column_text(pStmt,3),nCol,pSample->anDLt,0,0);  pSample->n = sqlite3_column_bytes(pStmt, 4);  pSample->p = sqlite3DbMallocZero(db, pSample->n + 2);  if( pSample->p==0 ){  sqlite3_finalize(pStmt);  return SQLITE_NOMEM_BKPT;  }  if( pSample->n ){  memcpy(pSample->p, sqlite3_column_blob(pStmt, 4), pSample->n);  }  pIdx->nSample++;  }  rc = sqlite3_finalize(pStmt);  if( rc==SQLITE_OK ) initAvgEq(pPrevIdx);  return rc; } static int loadStat4(sqlite3 *db, const char *zDb){  int rc = SQLITE_OK;  const Table *pStat4;  assert( db->lookaside.bDisable );  if( (pStat4 = sqlite3FindTable(db, "sqlite_stat4", zDb))!=0   && IsOrdinaryTable(pStat4)  ){  rc = loadStatTbl(db,  "SELECT idx,count(*) FROM %Q.sqlite_stat4 GROUP BY idx",  "SELECT idx,neq,nlt,ndlt,sample FROM %Q.sqlite_stat4",  zDb  );  }  return rc; }
#endif
SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3 *db, int iDb){  analysisInfo sInfo;  HashElem *i;  char *zSql;  int rc = SQLITE_OK;  Schema *pSchema = db->aDb[iDb].pSchema;  const Table *pStat1;  assert( iDb>=0 && iDb<db->nDb );  assert( db->aDb[iDb].pBt!=0 );  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  for(i=sqliteHashFirst(&pSchema->tblHash); i; i=sqliteHashNext(i)){  Table *pTab = sqliteHashData(i);  pTab->tabFlags &= ~TF_HasStat1;  }  for(i=sqliteHashFirst(&pSchema->idxHash); i; i=sqliteHashNext(i)){  Index *pIdx = sqliteHashData(i);  pIdx->hasStat1 = 0;
#ifdef SQLITE_ENABLE_STAT4
 sqlite3DeleteIndexSamples(db, pIdx);  pIdx->aSample = 0;
#endif
 }  sInfo.db = db;  sInfo.zDatabase = db->aDb[iDb].zDbSName;  if( (pStat1 = sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase))   && IsOrdinaryTable(pStat1)  ){  zSql = sqlite3MPrintf(db,  "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);  if( zSql==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);  sqlite3DbFree(db, zSql);  }  }  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  for(i=sqliteHashFirst(&pSchema->idxHash); i; i=sqliteHashNext(i)){  Index *pIdx = sqliteHashData(i);  if( !pIdx->hasStat1 ) sqlite3DefaultRowEst(pIdx);  }
#ifdef SQLITE_ENABLE_STAT4
 if( rc==SQLITE_OK ){  DisableLookaside;  rc = loadStat4(db, sInfo.zDatabase);  EnableLookaside;  }  for(i=sqliteHashFirst(&pSchema->idxHash); i; i=sqliteHashNext(i)){  Index *pIdx = sqliteHashData(i);  sqlite3_free(pIdx->aiRowEst);  pIdx->aiRowEst = 0;  }
#endif
 if( rc==SQLITE_NOMEM ){  sqlite3OomFault(db);  }  return rc; }
#endif
#ifndef SQLITE_OMIT_ATTACH
static int resolveAttachExpr(NameContext *pName, Expr *pExpr) {  int rc = SQLITE_OK;  if( pExpr ){  if( pExpr->op!=TK_ID ){  rc = sqlite3ResolveExprNames(pName, pExpr);  }else{  pExpr->op = TK_STRING;  }  }  return rc; } SQLITE_PRIVATE int sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName){  return (  sqlite3StrICmp(db->aDb[iDb].zDbSName, zName)==0   || (iDb==0 && sqlite3StrICmp("main", zName)==0)  ); } static void attachFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  int i;  int rc = 0;  sqlite3 *db = sqlite3_context_db_handle(context);  const char *zName;  const char *zFile;  char *zPath = 0;  char *zErr = 0;  unsigned int flags;  Db *aNew;  Db *pNew;  char *zErrDyn = 0;  sqlite3_vfs *pVfs;  UNUSED_PARAMETER(NotUsed);  zFile = (const char *)sqlite3_value_text(argv[0]);  zName = (const char *)sqlite3_value_text(argv[1]);  if( zFile==0 ) zFile = "";  if( zName==0 ) zName = "";
#ifndef SQLITE_OMIT_DESERIALIZE
# define REOPEN_AS_MEMDB(db) (db->init.reopenMemdb)
#else
# define REOPEN_AS_MEMDB(db) (0)
#endif
 if( REOPEN_AS_MEMDB(db) ){  pVfs = sqlite3_vfs_find("memdb");  if( pVfs==0 ) return;  pNew = &db->aDb[db->init.iDb];  if( pNew->pBt ) sqlite3BtreeClose(pNew->pBt);  pNew->pBt = 0;  pNew->pSchema = 0;  rc = sqlite3BtreeOpen(pVfs, "x\0", db, &pNew->pBt, 0, SQLITE_OPEN_MAIN_DB);  }else{  if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){  zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d",  db->aLimit[SQLITE_LIMIT_ATTACHED]  );  goto attach_error;  }  for(i=0; i<db->nDb; i++){  assert( zName );  if( sqlite3DbIsNamed(db, i, zName) ){  zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);  goto attach_error;  }  }  if( db->aDb==db->aDbStatic ){  aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );  if( aNew==0 ) return;  memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);  }else{  aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );  if( aNew==0 ) return;  }  db->aDb = aNew;  pNew = &db->aDb[db->nDb];  memset(pNew, 0, sizeof(*pNew));  flags = db->openFlags;  rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);  sqlite3_result_error(context, zErr, -1);  sqlite3_free(zErr);  return;  }  assert( pVfs );  flags |= SQLITE_OPEN_MAIN_DB;  rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);  db->nDb++;  pNew->zDbSName = sqlite3DbStrDup(db, zName);  }  db->noSharedCache = 0;  if( rc==SQLITE_CONSTRAINT ){  rc = SQLITE_ERROR;  zErrDyn = sqlite3MPrintf(db, "database is already attached");  }else if( rc==SQLITE_OK ){  Pager *pPager;  pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);  if( !pNew->pSchema ){  rc = SQLITE_NOMEM_BKPT;  }else if( pNew->pSchema->file_format && pNew->pSchema->enc!=ENC(db) ){  zErrDyn = sqlite3MPrintf(db,  "attached databases must use the same text encoding as main database");  rc = SQLITE_ERROR;  }  sqlite3BtreeEnter(pNew->pBt);  pPager = sqlite3BtreePager(pNew->pBt);  sqlite3PagerLockingMode(pPager, db->dfltLockMode);  sqlite3BtreeSecureDelete(pNew->pBt,   sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
 sqlite3BtreeSetPagerFlags(pNew->pBt,  PAGER_SYNCHRONOUS_FULL | (db->flags & PAGER_FLAGS_MASK));
#endif
 sqlite3BtreeLeave(pNew->pBt);  }  pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;  if( rc==SQLITE_OK && pNew->zDbSName==0 ){  rc = SQLITE_NOMEM_BKPT;  }  sqlite3_free_filename( zPath );  if( rc==SQLITE_OK ){  sqlite3BtreeEnterAll(db);  db->init.iDb = 0;  db->mDbFlags &= ~(DBFLAG_SchemaKnownOk);  if( !REOPEN_AS_MEMDB(db) ){  rc = sqlite3Init(db, &zErrDyn);  }  sqlite3BtreeLeaveAll(db);  assert( zErrDyn==0 || rc!=SQLITE_OK );  }
#ifdef SQLITE_USER_AUTHENTICATION
 if( rc==SQLITE_OK && !REOPEN_AS_MEMDB(db) ){  u8 newAuth = 0;  rc = sqlite3UserAuthCheckLogin(db, zName, &newAuth);  if( newAuth<db->auth.authLevel ){  rc = SQLITE_AUTH_USER;  }  }
#endif
 if( rc ){  if( !REOPEN_AS_MEMDB(db) ){  int iDb = db->nDb - 1;  assert( iDb>=2 );  if( db->aDb[iDb].pBt ){  sqlite3BtreeClose(db->aDb[iDb].pBt);  db->aDb[iDb].pBt = 0;  db->aDb[iDb].pSchema = 0;  }  sqlite3ResetAllSchemasOfConnection(db);  db->nDb = iDb;  if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){  sqlite3OomFault(db);  sqlite3DbFree(db, zErrDyn);  zErrDyn = sqlite3MPrintf(db, "out of memory");  }else if( zErrDyn==0 ){  zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);  }  }  goto attach_error;  }  return; attach_error:  if( zErrDyn ){  sqlite3_result_error(context, zErrDyn, -1);  sqlite3DbFree(db, zErrDyn);  }  if( rc ) sqlite3_result_error_code(context, rc); } static void detachFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  const char *zName = (const char *)sqlite3_value_text(argv[0]);  sqlite3 *db = sqlite3_context_db_handle(context);  int i;  Db *pDb = 0;  HashElem *pEntry;  char zErr[128];  UNUSED_PARAMETER(NotUsed);  if( zName==0 ) zName = "";  for(i=0; i<db->nDb; i++){  pDb = &db->aDb[i];  if( pDb->pBt==0 ) continue;  if( sqlite3DbIsNamed(db, i, zName) ) break;  }  if( i>=db->nDb ){  sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName);  goto detach_error;  }  if( i<2 ){  sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName);  goto detach_error;  }  if( sqlite3BtreeTxnState(pDb->pBt)!=SQLITE_TXN_NONE   || sqlite3BtreeIsInBackup(pDb->pBt)  ){  sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);  goto detach_error;  }  assert( db->aDb[1].pSchema );  pEntry = sqliteHashFirst(&db->aDb[1].pSchema->trigHash);  while( pEntry ){  Trigger *pTrig = (Trigger*)sqliteHashData(pEntry);  if( pTrig->pTabSchema==pDb->pSchema ){  pTrig->pTabSchema = pTrig->pSchema;  }  pEntry = sqliteHashNext(pEntry);  }  sqlite3BtreeClose(pDb->pBt);  pDb->pBt = 0;  pDb->pSchema = 0;  sqlite3CollapseDatabaseArray(db);  return; detach_error:  sqlite3_result_error(context, zErr, -1); } static void codeAttach(  Parse *pParse,  int type,  FuncDef const *pFunc,  Expr *pAuthArg,  Expr *pFilename,  Expr *pDbname,  Expr *pKey ){  int rc;  NameContext sName;  Vdbe *v;  sqlite3* db = pParse->db;  int regArgs;  if( pParse->nErr ) goto attach_end;  memset(&sName, 0, sizeof(NameContext));  sName.pParse = pParse;  if(  SQLITE_OK!=resolveAttachExpr(&sName, pFilename) ||  SQLITE_OK!=resolveAttachExpr(&sName, pDbname) ||  SQLITE_OK!=resolveAttachExpr(&sName, pKey)  ){  goto attach_end;  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( pAuthArg ){  char *zAuthArg;  if( pAuthArg->op==TK_STRING ){  assert( !ExprHasProperty(pAuthArg, EP_IntValue) );  zAuthArg = pAuthArg->u.zToken;  }else{  zAuthArg = 0;  }  rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);  if(rc!=SQLITE_OK ){  goto attach_end;  }  }
#endif
 v = sqlite3GetVdbe(pParse);  regArgs = sqlite3GetTempRange(pParse, 4);  sqlite3ExprCode(pParse, pFilename, regArgs);  sqlite3ExprCode(pParse, pDbname, regArgs+1);  sqlite3ExprCode(pParse, pKey, regArgs+2);  assert( v || db->mallocFailed );  if( v ){  sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,   pFunc->nArg, pFunc, 0);  sqlite3VdbeAddOp1(v, OP_Expire, (type==SQLITE_ATTACH));  } attach_end:  sqlite3ExprDelete(db, pFilename);  sqlite3ExprDelete(db, pDbname);  sqlite3ExprDelete(db, pKey); } SQLITE_PRIVATE void sqlite3Detach(Parse *pParse, Expr *pDbname){  static const FuncDef detach_func = {  1,  SQLITE_UTF8,  0,  0,  detachFunc,  0,  0, 0,  "sqlite_detach",  {0}  };  codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname); } SQLITE_PRIVATE void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){  static const FuncDef attach_func = {  3,  SQLITE_UTF8,  0,  0,  attachFunc,  0,  0, 0,  "sqlite_attach",  {0}  };  codeAttach(pParse, SQLITE_ATTACH, &attach_func, p, p, pDbname, pKey); }
#endif
static int fixExprCb(Walker *p, Expr *pExpr){  DbFixer *pFix = p->u.pFix;  if( !pFix->bTemp ) ExprSetProperty(pExpr, EP_FromDDL);  if( pExpr->op==TK_VARIABLE ){  if( pFix->pParse->db->init.busy ){  pExpr->op = TK_NULL;  }else{  sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);  return WRC_Abort;  }  }  return WRC_Continue; } static int fixSelectCb(Walker *p, Select *pSelect){  DbFixer *pFix = p->u.pFix;  int i;  SrcItem *pItem;  sqlite3 *db = pFix->pParse->db;  int iDb = sqlite3FindDbName(db, pFix->zDb);  SrcList *pList = pSelect->pSrc;  if( NEVER(pList==0) ) return WRC_Continue;  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){  if( pFix->bTemp==0 ){  if( pItem->zDatabase ){  if( iDb!=sqlite3FindDbName(db, pItem->zDatabase) ){  sqlite3ErrorMsg(pFix->pParse,  "%s %T cannot reference objects in database %s",  pFix->zType, pFix->pName, pItem->zDatabase);  return WRC_Abort;  }  sqlite3DbFree(db, pItem->zDatabase);  pItem->zDatabase = 0;  pItem->fg.notCte = 1;  }  pItem->pSchema = pFix->pSchema;  pItem->fg.fromDDL = 1;  }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
 if( sqlite3WalkExpr(&pFix->w, pList->a[i].pOn) ) return WRC_Abort;
#endif
 }  if( pSelect->pWith ){  for(i=0; i<pSelect->pWith->nCte; i++){  if( sqlite3WalkSelect(p, pSelect->pWith->a[i].pSelect) ){  return WRC_Abort;  }  }  }  return WRC_Continue; } SQLITE_PRIVATE void sqlite3FixInit(  DbFixer *pFix,  Parse *pParse,  int iDb,  const char *zType,  const Token *pName ){  sqlite3 *db = pParse->db;  assert( db->nDb>iDb );  pFix->pParse = pParse;  pFix->zDb = db->aDb[iDb].zDbSName;  pFix->pSchema = db->aDb[iDb].pSchema;  pFix->zType = zType;  pFix->pName = pName;  pFix->bTemp = (iDb==1);  pFix->w.pParse = pParse;  pFix->w.xExprCallback = fixExprCb;  pFix->w.xSelectCallback = fixSelectCb;  pFix->w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;  pFix->w.walkerDepth = 0;  pFix->w.eCode = 0;  pFix->w.u.pFix = pFix; } SQLITE_PRIVATE int sqlite3FixSrcList(  DbFixer *pFix,  SrcList *pList ){  int res = 0;  if( pList ){  Select s;  memset(&s, 0, sizeof(s));  s.pSrc = pList;  res = sqlite3WalkSelect(&pFix->w, &s);  }  return res; }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE int sqlite3FixSelect(  DbFixer *pFix,  Select *pSelect ){  return sqlite3WalkSelect(&pFix->w, pSelect); } SQLITE_PRIVATE int sqlite3FixExpr(  DbFixer *pFix,  Expr *pExpr ){  return sqlite3WalkExpr(&pFix->w, pExpr); }
#endif
#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE int sqlite3FixTriggerStep(  DbFixer *pFix,  TriggerStep *pStep ){  while( pStep ){  if( sqlite3WalkSelect(&pFix->w, pStep->pSelect)   || sqlite3WalkExpr(&pFix->w, pStep->pWhere)   || sqlite3WalkExprList(&pFix->w, pStep->pExprList)   || sqlite3FixSrcList(pFix, pStep->pFrom)  ){  return 1;  }
#ifndef SQLITE_OMIT_UPSERT
 {  Upsert *pUp;  for(pUp=pStep->pUpsert; pUp; pUp=pUp->pNextUpsert){  if( sqlite3WalkExprList(&pFix->w, pUp->pUpsertTarget)   || sqlite3WalkExpr(&pFix->w, pUp->pUpsertTargetWhere)   || sqlite3WalkExprList(&pFix->w, pUp->pUpsertSet)   || sqlite3WalkExpr(&pFix->w, pUp->pUpsertWhere)  ){  return 1;  }  }  }
#endif
 pStep = pStep->pNext;  }  return 0; }
#endif
#ifndef SQLITE_OMIT_AUTHORIZATION
SQLITE_API int sqlite3_set_authorizer(  sqlite3 *db,  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),  void *pArg ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  db->xAuth = (sqlite3_xauth)xAuth;  db->pAuthArg = pArg;  if( db->xAuth ) sqlite3ExpirePreparedStatements(db, 1);  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; } static void sqliteAuthBadReturnCode(Parse *pParse){  sqlite3ErrorMsg(pParse, "authorizer malfunction");  pParse->rc = SQLITE_ERROR; } SQLITE_PRIVATE int sqlite3AuthReadCol(  Parse *pParse,  const char *zTab,  const char *zCol,  int iDb ){  sqlite3 *db = pParse->db;  char *zDb = db->aDb[iDb].zDbSName;  int rc;  if( db->init.busy ) return SQLITE_OK;  rc = db->xAuth(db->pAuthArg, SQLITE_READ, zTab,zCol,zDb,pParse->zAuthContext
#ifdef SQLITE_USER_AUTHENTICATION
  ,db->auth.zAuthUser
#endif
 );  if( rc==SQLITE_DENY ){  char *z = sqlite3_mprintf("%s.%s", zTab, zCol);  if( db->nDb>2 || iDb!=0 ) z = sqlite3_mprintf("%s.%z", zDb, z);  sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);  pParse->rc = SQLITE_AUTH;  }else if( rc!=SQLITE_IGNORE && rc!=SQLITE_OK ){  sqliteAuthBadReturnCode(pParse);  }  return rc; } SQLITE_PRIVATE void sqlite3AuthRead(  Parse *pParse,  Expr *pExpr,  Schema *pSchema,  SrcList *pTabList ){  Table *pTab = 0;  const char *zCol;  int iSrc;  int iDb;  int iCol;  assert( pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER );  assert( !IN_RENAME_OBJECT );  assert( pParse->db->xAuth!=0 );  iDb = sqlite3SchemaToIndex(pParse->db, pSchema);  if( iDb<0 ){  return;  }  if( pExpr->op==TK_TRIGGER ){  pTab = pParse->pTriggerTab;  }else{  assert( pTabList );  for(iSrc=0; iSrc<pTabList->nSrc; iSrc++){  if( pExpr->iTable==pTabList->a[iSrc].iCursor ){  pTab = pTabList->a[iSrc].pTab;  break;  }  }  }  iCol = pExpr->iColumn;  if( pTab==0 ) return;  if( iCol>=0 ){  assert( iCol<pTab->nCol );  zCol = pTab->aCol[iCol].zCnName;  }else if( pTab->iPKey>=0 ){  assert( pTab->iPKey<pTab->nCol );  zCol = pTab->aCol[pTab->iPKey].zCnName;  }else{  zCol = "ROWID";  }  assert( iDb>=0 && iDb<pParse->db->nDb );  if( SQLITE_IGNORE==sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb) ){  pExpr->op = TK_NULL;  } } SQLITE_PRIVATE int sqlite3AuthCheck(  Parse *pParse,  int code,  const char *zArg1,  const char *zArg2,  const char *zArg3 ){  sqlite3 *db = pParse->db;  int rc;  assert( !IN_RENAME_OBJECT || db->xAuth==0 );  if( db->xAuth==0 || db->init.busy || IN_SPECIAL_PARSE ){  return SQLITE_OK;  }  testcase( zArg1==0 );  testcase( zArg2==0 );  testcase( zArg3==0 );  testcase( pParse->zAuthContext==0 );  rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext
#ifdef SQLITE_USER_AUTHENTICATION
  ,db->auth.zAuthUser
#endif
 );  if( rc==SQLITE_DENY ){  sqlite3ErrorMsg(pParse, "not authorized");  pParse->rc = SQLITE_AUTH;  }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){  rc = SQLITE_DENY;  sqliteAuthBadReturnCode(pParse);  }  return rc; } SQLITE_PRIVATE void sqlite3AuthContextPush(  Parse *pParse,  AuthContext *pContext,  const char *zContext ){  assert( pParse );  pContext->pParse = pParse;  pContext->zAuthContext = pParse->zAuthContext;  pParse->zAuthContext = zContext; } SQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext *pContext){  if( pContext->pParse ){  pContext->pParse->zAuthContext = pContext->zAuthContext;  pContext->pParse = 0;  } }
#endif
#ifndef SQLITE_OMIT_SHARED_CACHE
struct TableLock {  int iDb;  Pgno iTab;  u8 isWriteLock;  const char *zLockName; }; static SQLITE_NOINLINE void lockTable(  Parse *pParse,  int iDb,  Pgno iTab,  u8 isWriteLock,  const char *zName ){  Parse *pToplevel;  int i;  int nBytes;  TableLock *p;  assert( iDb>=0 );  pToplevel = sqlite3ParseToplevel(pParse);  for(i=0; i<pToplevel->nTableLock; i++){  p = &pToplevel->aTableLock[i];  if( p->iDb==iDb && p->iTab==iTab ){  p->isWriteLock = (p->isWriteLock || isWriteLock);  return;  }  }  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);  pToplevel->aTableLock =  sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);  if( pToplevel->aTableLock ){  p = &pToplevel->aTableLock[pToplevel->nTableLock++];  p->iDb = iDb;  p->iTab = iTab;  p->isWriteLock = isWriteLock;  p->zLockName = zName;  }else{  pToplevel->nTableLock = 0;  sqlite3OomFault(pToplevel->db);  } } SQLITE_PRIVATE void sqlite3TableLock(  Parse *pParse,  int iDb,  Pgno iTab,  u8 isWriteLock,  const char *zName ){  if( iDb==1 ) return;  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;  lockTable(pParse, iDb, iTab, isWriteLock, zName); } static void codeTableLocks(Parse *pParse){  int i;  Vdbe *pVdbe = pParse->pVdbe;  assert( pVdbe!=0 );  for(i=0; i<pParse->nTableLock; i++){  TableLock *p = &pParse->aTableLock[i];  int p1 = p->iDb;  sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock,  p->zLockName, P4_STATIC);  } }
#else
 #define codeTableLocks(x)
#endif
#if SQLITE_MAX_ATTACHED>30
SQLITE_PRIVATE int sqlite3DbMaskAllZero(yDbMask m){  int i;  for(i=0; i<sizeof(yDbMask); i++) if( m[i] ) return 0;  return 1; }
#endif
SQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){  sqlite3 *db;  Vdbe *v;  assert( pParse->pToplevel==0 );  db = pParse->db;  if( pParse->nested ) return;  if( db->mallocFailed || pParse->nErr ){  if( pParse->rc==SQLITE_OK ) pParse->rc = SQLITE_ERROR;  return;  }  v = pParse->pVdbe;  if( v==0 ){  if( db->init.busy ){  pParse->rc = SQLITE_DONE;  return;  }  v = sqlite3GetVdbe(pParse);  if( v==0 ) pParse->rc = SQLITE_ERROR;  }  assert( !pParse->isMultiWrite   || sqlite3VdbeAssertMayAbort(v, pParse->mayAbort));  if( v ){  if( pParse->bReturning ){  Returning *pReturning = pParse->u1.pReturning;  int addrRewind;  int i;  int reg;  if( pReturning->nRetCol==0 ){  assert( CORRUPT_DB );  }else{  addrRewind =   sqlite3VdbeAddOp1(v, OP_Rewind, pReturning->iRetCur);  VdbeCoverage(v);  reg = pReturning->iRetReg;  for(i=0; i<pReturning->nRetCol; i++){  sqlite3VdbeAddOp3(v, OP_Column, pReturning->iRetCur, i, reg+i);  }  sqlite3VdbeAddOp2(v, OP_ResultRow, reg, i);  sqlite3VdbeAddOp2(v, OP_Next, pReturning->iRetCur, addrRewind+1);  VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addrRewind);  }  }  sqlite3VdbeAddOp0(v, OP_Halt);
#if SQLITE_USER_AUTHENTICATION
 if( pParse->nTableLock>0 && db->init.busy==0 ){  sqlite3UserAuthInit(db);  if( db->auth.authLevel<UAUTH_User ){  sqlite3ErrorMsg(pParse, "user not authenticated");  pParse->rc = SQLITE_AUTH_USER;  return;  }  }
#endif
 if( db->mallocFailed==0   && (DbMaskNonZero(pParse->cookieMask) || pParse->pConstExpr)  ){  int iDb, i;  assert( sqlite3VdbeGetOp(v, 0)->opcode==OP_Init );  sqlite3VdbeJumpHere(v, 0);  for(iDb=0; iDb<db->nDb; iDb++){  Schema *pSchema;  if( DbMaskTest(pParse->cookieMask, iDb)==0 ) continue;  sqlite3VdbeUsesBtree(v, iDb);  pSchema = db->aDb[iDb].pSchema;  sqlite3VdbeAddOp4Int(v,  OP_Transaction,  iDb,  DbMaskTest(pParse->writeMask,iDb),  pSchema->schema_cookie,  pSchema->iGeneration  );  if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);  VdbeComment((v,  "usesStmtJournal=%d", pParse->mayAbort && pParse->isMultiWrite));  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 for(i=0; i<pParse->nVtabLock; i++){  char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);  sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);  }  pParse->nVtabLock = 0;
#endif
 codeTableLocks(pParse);  sqlite3AutoincrementBegin(pParse);  if( pParse->pConstExpr ){  ExprList *pEL = pParse->pConstExpr;  pParse->okConstFactor = 0;  for(i=0; i<pEL->nExpr; i++){  int iReg = pEL->a[i].u.iConstExprReg;  if( iReg>0 ){  sqlite3ExprCode(pParse, pEL->a[i].pExpr, iReg);  }  }  }  if( pParse->bReturning ){  Returning *pRet = pParse->u1.pReturning;  if( pRet->nRetCol==0 ){  assert( CORRUPT_DB );  }else{  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pRet->iRetCur, pRet->nRetCol);  }  }  sqlite3VdbeGoto(v, 1);  }  }  if( v && pParse->nErr==0 && !db->mallocFailed ){  assert( pParse->pAinc==0 || pParse->nTab>0 );  sqlite3VdbeMakeReady(v, pParse);  pParse->rc = SQLITE_DONE;  }else{  pParse->rc = SQLITE_ERROR;  } } SQLITE_PRIVATE void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){  va_list ap;  char *zSql;  char *zErrMsg = 0;  sqlite3 *db = pParse->db;  u32 savedDbFlags = db->mDbFlags;  char saveBuf[PARSE_TAIL_SZ];  if( pParse->nErr ) return;  assert( pParse->nested<10 );  va_start(ap, zFormat);  zSql = sqlite3VMPrintf(db, zFormat, ap);  va_end(ap);  if( zSql==0 ){  if( !db->mallocFailed ) pParse->rc = SQLITE_TOOBIG;  pParse->nErr++;  return;  }  pParse->nested++;  memcpy(saveBuf, PARSE_TAIL(pParse), PARSE_TAIL_SZ);  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);  db->mDbFlags |= DBFLAG_PreferBuiltin;  sqlite3RunParser(pParse, zSql, &zErrMsg);  db->mDbFlags = savedDbFlags;  sqlite3DbFree(db, zErrMsg);  sqlite3DbFree(db, zSql);  memcpy(PARSE_TAIL(pParse), saveBuf, PARSE_TAIL_SZ);  pParse->nested--; }
#if SQLITE_USER_AUTHENTICATION
SQLITE_PRIVATE int sqlite3UserAuthTable(const char *zTable){  return sqlite3_stricmp(zTable, "sqlite_user")==0; }
#endif
SQLITE_PRIVATE Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){  Table *p = 0;  int i;  assert( zDatabase!=0 || sqlite3BtreeHoldsAllMutexes(db) );
#if SQLITE_USER_AUTHENTICATION
 if( db->auth.authLevel<UAUTH_Admin && sqlite3UserAuthTable(zName)!=0 ){  return 0;  }
#endif
 if( zDatabase ){  for(i=0; i<db->nDb; i++){  if( sqlite3StrICmp(zDatabase, db->aDb[i].zDbSName)==0 ) break;  }  if( i>=db->nDb ){  if( sqlite3StrICmp(zDatabase,"main")==0 ){  i = 0;  }else{  return 0;  }  }  p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash, zName);  if( p==0 && sqlite3StrNICmp(zName, "sqlite_", 7)==0 ){  if( i==1 ){  if( sqlite3StrICmp(zName+7, &PREFERRED_TEMP_SCHEMA_TABLE[7])==0   || sqlite3StrICmp(zName+7, &PREFERRED_SCHEMA_TABLE[7])==0   || sqlite3StrICmp(zName+7, &LEGACY_SCHEMA_TABLE[7])==0  ){  p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash,  LEGACY_TEMP_SCHEMA_TABLE);  }  }else{  if( sqlite3StrICmp(zName+7, &PREFERRED_SCHEMA_TABLE[7])==0 ){  p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash,  LEGACY_SCHEMA_TABLE);  }  }  }  }else{  p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash, zName);  if( p ) return p;  p = sqlite3HashFind(&db->aDb[0].pSchema->tblHash, zName);  if( p ) return p;  for(i=2; i<db->nDb; i++){  assert( sqlite3SchemaMutexHeld(db, i, 0) );  p = sqlite3HashFind(&db->aDb[i].pSchema->tblHash, zName);  if( p ) break;  }  if( p==0 && sqlite3StrNICmp(zName, "sqlite_", 7)==0 ){  if( sqlite3StrICmp(zName+7, &PREFERRED_SCHEMA_TABLE[7])==0 ){  p = sqlite3HashFind(&db->aDb[0].pSchema->tblHash, LEGACY_SCHEMA_TABLE);  }else if( sqlite3StrICmp(zName+7, &PREFERRED_TEMP_SCHEMA_TABLE[7])==0 ){  p = sqlite3HashFind(&db->aDb[1].pSchema->tblHash,  LEGACY_TEMP_SCHEMA_TABLE);  }  }  }  return p; } SQLITE_PRIVATE Table *sqlite3LocateTable(  Parse *pParse,  u32 flags,  const char *zName,  const char *zDbase ){  Table *p;  sqlite3 *db = pParse->db;  if( (db->mDbFlags & DBFLAG_SchemaKnownOk)==0   && SQLITE_OK!=sqlite3ReadSchema(pParse)  ){  return 0;  }  p = sqlite3FindTable(db, zName, zDbase);  if( p==0 ){
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( pParse->disableVtab==0 && db->init.busy==0 ){  Module *pMod = (Module*)sqlite3HashFind(&db->aModule, zName);  if( pMod==0 && sqlite3_strnicmp(zName, "pragma_", 7)==0 ){  pMod = sqlite3PragmaVtabRegister(db, zName);  }  if( pMod && sqlite3VtabEponymousTableInit(pParse, pMod) ){  testcase( pMod->pEpoTab==0 );  return pMod->pEpoTab;  }  }
#endif
 if( flags & LOCATE_NOERR ) return 0;  pParse->checkSchema = 1;  }else if( IsVirtual(p) && pParse->disableVtab ){  p = 0;  }  if( p==0 ){  const char *zMsg = flags & LOCATE_VIEW ? "no such view" : "no such table";  if( zDbase ){  sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);  }else{  sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);  }  }else{  assert( HasRowid(p) || p->iPKey<0 );  }  return p; } SQLITE_PRIVATE Table *sqlite3LocateTableItem(  Parse *pParse,  u32 flags,  SrcItem *p ){  const char *zDb;  assert( p->pSchema==0 || p->zDatabase==0 );  if( p->pSchema ){  int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);  zDb = pParse->db->aDb[iDb].zDbSName;  }else{  zDb = p->zDatabase;  }  return sqlite3LocateTable(pParse, flags, p->zName, zDb); } SQLITE_PRIVATE const char *sqlite3PreferredTableName(const char *zName){  if( sqlite3StrNICmp(zName, "sqlite_", 7)==0 ){  if( sqlite3StrICmp(zName+7, &LEGACY_SCHEMA_TABLE[7])==0 ){  return PREFERRED_SCHEMA_TABLE;  }  if( sqlite3StrICmp(zName+7, &LEGACY_TEMP_SCHEMA_TABLE[7])==0 ){  return PREFERRED_TEMP_SCHEMA_TABLE;  }  }  return zName; } SQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){  Index *p = 0;  int i;  assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );  for(i=OMIT_TEMPDB; i<db->nDb; i++){  int j = (i<2) ? i^1 : i;  Schema *pSchema = db->aDb[j].pSchema;  assert( pSchema );  if( zDb && sqlite3DbIsNamed(db, j, zDb)==0 ) continue;  assert( sqlite3SchemaMutexHeld(db, j, 0) );  p = sqlite3HashFind(&pSchema->idxHash, zName);  if( p ) break;  }  return p; } SQLITE_PRIVATE void sqlite3FreeIndex(sqlite3 *db, Index *p){
#ifndef SQLITE_OMIT_ANALYZE
 sqlite3DeleteIndexSamples(db, p);
#endif
 sqlite3ExprDelete(db, p->pPartIdxWhere);  sqlite3ExprListDelete(db, p->aColExpr);  sqlite3DbFree(db, p->zColAff);  if( p->isResized ) sqlite3DbFree(db, (void *)p->azColl);
#ifdef SQLITE_ENABLE_STAT4
 sqlite3_free(p->aiRowEst);
#endif
 sqlite3DbFree(db, p); } SQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){  Index *pIndex;  Hash *pHash;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  pHash = &db->aDb[iDb].pSchema->idxHash;  pIndex = sqlite3HashInsert(pHash, zIdxName, 0);  if( ALWAYS(pIndex) ){  if( pIndex->pTable->pIndex==pIndex ){  pIndex->pTable->pIndex = pIndex->pNext;  }else{  Index *p;  p = pIndex->pTable->pIndex;  while( ALWAYS(p) && p->pNext!=pIndex ){ p = p->pNext; }  if( ALWAYS(p && p->pNext==pIndex) ){  p->pNext = pIndex->pNext;  }  }  sqlite3FreeIndex(db, pIndex);  }  db->mDbFlags |= DBFLAG_SchemaChange; } SQLITE_PRIVATE void sqlite3CollapseDatabaseArray(sqlite3 *db){  int i, j;  for(i=j=2; i<db->nDb; i++){  struct Db *pDb = &db->aDb[i];  if( pDb->pBt==0 ){  sqlite3DbFree(db, pDb->zDbSName);  pDb->zDbSName = 0;  continue;  }  if( j<i ){  db->aDb[j] = db->aDb[i];  }  j++;  }  db->nDb = j;  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){  memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));  sqlite3DbFree(db, db->aDb);  db->aDb = db->aDbStatic;  } } SQLITE_PRIVATE void sqlite3ResetOneSchema(sqlite3 *db, int iDb){  int i;  assert( iDb<db->nDb );  if( iDb>=0 ){  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  DbSetProperty(db, iDb, DB_ResetWanted);  DbSetProperty(db, 1, DB_ResetWanted);  db->mDbFlags &= ~DBFLAG_SchemaKnownOk;  }  if( db->nSchemaLock==0 ){  for(i=0; i<db->nDb; i++){  if( DbHasProperty(db, i, DB_ResetWanted) ){  sqlite3SchemaClear(db->aDb[i].pSchema);  }  }  } } SQLITE_PRIVATE void sqlite3ResetAllSchemasOfConnection(sqlite3 *db){  int i;  sqlite3BtreeEnterAll(db);  for(i=0; i<db->nDb; i++){  Db *pDb = &db->aDb[i];  if( pDb->pSchema ){  if( db->nSchemaLock==0 ){  sqlite3SchemaClear(pDb->pSchema);  }else{  DbSetProperty(db, i, DB_ResetWanted);  }  }  }  db->mDbFlags &= ~(DBFLAG_SchemaChange|DBFLAG_SchemaKnownOk);  sqlite3VtabUnlockList(db);  sqlite3BtreeLeaveAll(db);  if( db->nSchemaLock==0 ){  sqlite3CollapseDatabaseArray(db);  } } SQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3 *db){  db->mDbFlags &= ~DBFLAG_SchemaChange; } SQLITE_PRIVATE void sqlite3ColumnSetExpr(  Parse *pParse,  Table *pTab,  Column *pCol,  Expr *pExpr ){  ExprList *pList;  assert( IsOrdinaryTable(pTab) );  pList = pTab->u.tab.pDfltList;  if( pCol->iDflt==0   || NEVER(pList==0)   || NEVER(pList->nExpr<pCol->iDflt)  ){  pCol->iDflt = pList==0 ? 1 : pList->nExpr+1;  pTab->u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr);  }else{  sqlite3ExprDelete(pParse->db, pList->a[pCol->iDflt-1].pExpr);  pList->a[pCol->iDflt-1].pExpr = pExpr;  } } SQLITE_PRIVATE Expr *sqlite3ColumnExpr(Table *pTab, Column *pCol){  if( pCol->iDflt==0 ) return 0;  if( NEVER(!IsOrdinaryTable(pTab)) ) return 0;  if( NEVER(pTab->u.tab.pDfltList==0) ) return 0;  if( NEVER(pTab->u.tab.pDfltList->nExpr<pCol->iDflt) ) return 0;  return pTab->u.tab.pDfltList->a[pCol->iDflt-1].pExpr; } SQLITE_PRIVATE void sqlite3ColumnSetColl(  sqlite3 *db,  Column *pCol,  const char *zColl ){  i64 nColl;  i64 n;  char *zNew;  assert( zColl!=0 );  n = sqlite3Strlen30(pCol->zCnName) + 1;  if( pCol->colFlags & COLFLAG_HASTYPE ){  n += sqlite3Strlen30(pCol->zCnName+n) + 1;  }  nColl = sqlite3Strlen30(zColl) + 1;  zNew = sqlite3DbRealloc(db, pCol->zCnName, nColl+n);  if( zNew ){  pCol->zCnName = zNew;  memcpy(pCol->zCnName + n, zColl, nColl);  pCol->colFlags |= COLFLAG_HASCOLL;  } } SQLITE_PRIVATE const char *sqlite3ColumnColl(Column *pCol){  const char *z;  if( (pCol->colFlags & COLFLAG_HASCOLL)==0 ) return 0;  z = pCol->zCnName;  while( *z ){ z++; }  if( pCol->colFlags & COLFLAG_HASTYPE ){  do{ z++; }while( *z );  }  return z+1; } SQLITE_PRIVATE void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){  int i;  Column *pCol;  assert( pTable!=0 );  if( (pCol = pTable->aCol)!=0 ){  for(i=0; i<pTable->nCol; i++, pCol++){  assert( pCol->zCnName==0 || pCol->hName==sqlite3StrIHash(pCol->zCnName) );  sqlite3DbFree(db, pCol->zCnName);  }  sqlite3DbFree(db, pTable->aCol);  if( IsOrdinaryTable(pTable) ){  sqlite3ExprListDelete(db, pTable->u.tab.pDfltList);  }  if( db==0 || db->pnBytesFreed==0 ){  pTable->aCol = 0;  pTable->nCol = 0;  if( IsOrdinaryTable(pTable) ){  pTable->u.tab.pDfltList = 0;  }  }  } } static void SQLITE_NOINLINE deleteTable(sqlite3 *db, Table *pTable){  Index *pIndex, *pNext;
#ifdef SQLITE_DEBUG
 int nLookaside = 0;  if( db && !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){  nLookaside = sqlite3LookasideUsed(db, 0);  }
#endif
 for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){  pNext = pIndex->pNext;  assert( pIndex->pSchema==pTable->pSchema   || (IsVirtual(pTable) && pIndex->idxType!=SQLITE_IDXTYPE_APPDEF) );  if( (db==0 || db->pnBytesFreed==0) && !IsVirtual(pTable) ){  char *zName = pIndex->zName;  TESTONLY ( Index *pOld = ) sqlite3HashInsert(   &pIndex->pSchema->idxHash, zName, 0  );  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );  assert( pOld==pIndex || pOld==0 );  }  sqlite3FreeIndex(db, pIndex);  }  if( IsOrdinaryTable(pTable) ){  sqlite3FkDelete(db, pTable);  }
#ifndef SQLITE_OMIT_VIRTUAL_TABLE
 else if( IsVirtual(pTable) ){  sqlite3VtabClear(db, pTable);  }
#endif
 else{  assert( IsView(pTable) );  sqlite3SelectDelete(db, pTable->u.view.pSelect);  }  sqlite3DeleteColumnNames(db, pTable);  sqlite3DbFree(db, pTable->zName);  sqlite3DbFree(db, pTable->zColAff);  sqlite3ExprListDelete(db, pTable->pCheck);  sqlite3DbFree(db, pTable);  assert( nLookaside==0 || nLookaside==sqlite3LookasideUsed(db,0) ); } SQLITE_PRIVATE void sqlite3DeleteTable(sqlite3 *db, Table *pTable){  if( !pTable ) return;  if( ((!db || db->pnBytesFreed==0) && (--pTable->nTabRef)>0) ) return;  deleteTable(db, pTable); } SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){  Table *p;  Db *pDb;  assert( db!=0 );  assert( iDb>=0 && iDb<db->nDb );  assert( zTabName );  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  testcase( zTabName[0]==0 );  pDb = &db->aDb[iDb];  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, 0);  sqlite3DeleteTable(db, p);  db->mDbFlags |= DBFLAG_SchemaChange; } SQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, const Token *pName){  char *zName;  if( pName ){  zName = sqlite3DbStrNDup(db, (const char*)pName->z, pName->n);  sqlite3Dequote(zName);  }else{  zName = 0;  }  return zName; } SQLITE_PRIVATE void sqlite3OpenSchemaTable(Parse *p, int iDb){  Vdbe *v = sqlite3GetVdbe(p);  sqlite3TableLock(p, iDb, SCHEMA_ROOT, 1, LEGACY_SCHEMA_TABLE);  sqlite3VdbeAddOp4Int(v, OP_OpenWrite, 0, SCHEMA_ROOT, iDb, 5);  if( p->nTab==0 ){  p->nTab = 1;  } } SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *db, const char *zName){  int i = -1;  if( zName ){  Db *pDb;  for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){  if( 0==sqlite3_stricmp(pDb->zDbSName, zName) ) break;  if( i==0 && 0==sqlite3_stricmp("main", zName) ) break;  }  }  return i; } SQLITE_PRIVATE int sqlite3FindDb(sqlite3 *db, Token *pName){  int i;  char *zName;  zName = sqlite3NameFromToken(db, pName);  i = sqlite3FindDbName(db, zName);  sqlite3DbFree(db, zName);  return i; } SQLITE_PRIVATE int sqlite3TwoPartName(  Parse *pParse,  Token *pName1,  Token *pName2,  Token **pUnqual ){  int iDb;  sqlite3 *db = pParse->db;  assert( pName2!=0 );  if( pName2->n>0 ){  if( db->init.busy ) {  sqlite3ErrorMsg(pParse, "corrupt database");  return -1;  }  *pUnqual = pName2;  iDb = sqlite3FindDb(db, pName1);  if( iDb<0 ){  sqlite3ErrorMsg(pParse, "unknown database %T", pName1);  return -1;  }  }else{  assert( db->init.iDb==0 || db->init.busy || IN_SPECIAL_PARSE   || (db->mDbFlags & DBFLAG_Vacuum)!=0);  iDb = db->init.iDb;  *pUnqual = pName1;  }  return iDb; } SQLITE_PRIVATE int sqlite3WritableSchema(sqlite3 *db){  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==0 );  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==   SQLITE_WriteSchema );  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==   SQLITE_Defensive );  testcase( (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==   (SQLITE_WriteSchema|SQLITE_Defensive) );  return (db->flags&(SQLITE_WriteSchema|SQLITE_Defensive))==SQLITE_WriteSchema; } SQLITE_PRIVATE int sqlite3CheckObjectName(  Parse *pParse,  const char *zName,  const char *zType,  const char *zTblName ){  sqlite3 *db = pParse->db;  if( sqlite3WritableSchema(db)   || db->init.imposterTable   || !sqlite3Config.bExtraSchemaChecks  ){  return SQLITE_OK;  }  if( db->init.busy ){  if( sqlite3_stricmp(zType, db->init.azInit[0])   || sqlite3_stricmp(zName, db->init.azInit[1])   || sqlite3_stricmp(zTblName, db->init.azInit[2])  ){  sqlite3ErrorMsg(pParse, "");  return SQLITE_ERROR;  }  }else{  if( (pParse->nested==0 && 0==sqlite3StrNICmp(zName, "sqlite_", 7))   || (sqlite3ReadOnlyShadowTables(db) && sqlite3ShadowTableName(db, zName))  ){  sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s",  zName);  return SQLITE_ERROR;  }  }  return SQLITE_OK; } SQLITE_PRIVATE Index *sqlite3PrimaryKeyIndex(Table *pTab){  Index *p;  for(p=pTab->pIndex; p && !IsPrimaryKeyIndex(p); p=p->pNext){}  return p; } SQLITE_PRIVATE i16 sqlite3TableColumnToIndex(Index *pIdx, i16 iCol){  int i;  for(i=0; i<pIdx->nColumn; i++){  if( iCol==pIdx->aiColumn[i] ) return i;  }  return -1; }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
SQLITE_PRIVATE i16 sqlite3StorageColumnToTable(Table *pTab, i16 iCol){  if( pTab->tabFlags & TF_HasVirtual ){  int i;  for(i=0; i<=iCol; i++){  if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) iCol++;  }  }  return iCol; }
#endif
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
SQLITE_PRIVATE i16 sqlite3TableColumnToStorage(Table *pTab, i16 iCol){  int i;  i16 n;  assert( iCol<pTab->nCol );  if( (pTab->tabFlags & TF_HasVirtual)==0 || iCol<0 ) return iCol;  for(i=0, n=0; i<iCol; i++){  if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) n++;  }  if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ){  return pTab->nNVCol + i - n;  }else{  return n;  } }
#endif
static void sqlite3ForceNotReadOnly(Parse *pParse){  int iReg = ++pParse->nMem;  Vdbe *v = sqlite3GetVdbe(pParse);  if( v ){  sqlite3VdbeAddOp3(v, OP_JournalMode, 0, iReg, PAGER_JOURNALMODE_QUERY);  sqlite3VdbeUsesBtree(v, 0);  } } SQLITE_PRIVATE void sqlite3StartTable(  Parse *pParse,  Token *pName1,  Token *pName2,  int isTemp,  int isView,  int isVirtual,  int noErr ){  Table *pTable;  char *zName = 0;  sqlite3 *db = pParse->db;  Vdbe *v;  int iDb;  Token *pName;  if( db->init.busy && db->init.newTnum==1 ){  iDb = db->init.iDb;  zName = sqlite3DbStrDup(db, SCHEMA_TABLE(iDb));  pName = pName1;  }else{  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);  if( iDb<0 ) return;  if( !OMIT_TEMPDB && isTemp && pName2->n>0 && iDb!=1 ){  sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");  return;  }  if( !OMIT_TEMPDB && isTemp ) iDb = 1;  zName = sqlite3NameFromToken(db, pName);  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenMap(pParse, (void*)zName, pName);  }  }  pParse->sNameToken = *pName;  if( zName==0 ) return;  if( sqlite3CheckObjectName(pParse, zName, isView?"view":"table", zName) ){  goto begin_table_error;  }  if( db->init.iDb==1 ) isTemp = 1;
#ifndef SQLITE_OMIT_AUTHORIZATION
 assert( isTemp==0 || isTemp==1 );  assert( isView==0 || isView==1 );  {  static const u8 aCode[] = {   SQLITE_CREATE_TABLE,   SQLITE_CREATE_TEMP_TABLE,   SQLITE_CREATE_VIEW,   SQLITE_CREATE_TEMP_VIEW  };  char *zDb = db->aDb[iDb].zDbSName;  if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){  goto begin_table_error;  }  if( !isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp+2*isView],   zName, 0, zDb) ){  goto begin_table_error;  }  }
#endif
 if( !IN_SPECIAL_PARSE ){  char *zDb = db->aDb[iDb].zDbSName;  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){  goto begin_table_error;  }  pTable = sqlite3FindTable(db, zName, zDb);  if( pTable ){  if( !noErr ){  sqlite3ErrorMsg(pParse, "table %T already exists", pName);  }else{  assert( !db->init.busy || CORRUPT_DB );  sqlite3CodeVerifySchema(pParse, iDb);  sqlite3ForceNotReadOnly(pParse);  }  goto begin_table_error;  }  if( sqlite3FindIndex(db, zName, zDb)!=0 ){  sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);  goto begin_table_error;  }  }  pTable = sqlite3DbMallocZero(db, sizeof(Table));  if( pTable==0 ){  assert( db->mallocFailed );  pParse->rc = SQLITE_NOMEM_BKPT;  pParse->nErr++;  goto begin_table_error;  }  pTable->zName = zName;  pTable->iPKey = -1;  pTable->pSchema = db->aDb[iDb].pSchema;  pTable->nTabRef = 1;
#ifdef SQLITE_DEFAULT_ROWEST
 pTable->nRowLogEst = sqlite3LogEst(SQLITE_DEFAULT_ROWEST);
#else
 pTable->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
#endif
 assert( pParse->pNewTable==0 );  pParse->pNewTable = pTable;  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){  int addr1;  int fileFormat;  int reg1, reg2, reg3;  static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };  sqlite3BeginWriteOperation(pParse, 1, iDb);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( isVirtual ){  sqlite3VdbeAddOp0(v, OP_VBegin);  }
#endif
 reg1 = pParse->regRowid = ++pParse->nMem;  reg2 = pParse->regRoot = ++pParse->nMem;  reg3 = ++pParse->nMem;  sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);  sqlite3VdbeUsesBtree(v, iDb);  addr1 = sqlite3VdbeAddOp1(v, OP_If, reg3); VdbeCoverage(v);  fileFormat = (db->flags & SQLITE_LegacyFileFmt)!=0 ?  1 : SQLITE_MAX_FILE_FORMAT;  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, fileFormat);  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, ENC(db));  sqlite3VdbeJumpHere(v, addr1);
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
 if( isView || isVirtual ){  sqlite3VdbeAddOp2(v, OP_Integer, 0, reg2);  }else
#endif
 {  assert( !pParse->bReturning );  pParse->u1.addrCrTab =   sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, reg2, BTREE_INTKEY);  }  sqlite3OpenSchemaTable(pParse, iDb);  sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1);  sqlite3VdbeAddOp4(v, OP_Blob, 6, reg3, 0, nullRow, P4_STATIC);  sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1);  sqlite3VdbeChangeP5(v, OPFLAG_APPEND);  sqlite3VdbeAddOp0(v, OP_Close);  }  return; begin_table_error:  pParse->checkSchema = 1;  sqlite3DbFree(db, zName);  return; }
#if SQLITE_ENABLE_HIDDEN_COLUMNS
SQLITE_PRIVATE void sqlite3ColumnPropertiesFromName(Table *pTab, Column *pCol){  if( sqlite3_strnicmp(pCol->zCnName, "__hidden__", 10)==0 ){  pCol->colFlags |= COLFLAG_HIDDEN;  if( pTab ) pTab->tabFlags |= TF_HasHidden;  }else if( pTab && pCol!=pTab->aCol && (pCol[-1].colFlags & COLFLAG_HIDDEN) ){  pTab->tabFlags |= TF_OOOHidden;  } }
#endif
#define RETURNING_TRIGGER_NAME "sqlite_returning"
static void sqlite3DeleteReturning(sqlite3 *db, Returning *pRet){  Hash *pHash;  pHash = &(db->aDb[1].pSchema->trigHash);  sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, 0);  sqlite3ExprListDelete(db, pRet->pReturnEL);  sqlite3DbFree(db, pRet); } SQLITE_PRIVATE void sqlite3AddReturning(Parse *pParse, ExprList *pList){  Returning *pRet;  Hash *pHash;  sqlite3 *db = pParse->db;  if( pParse->pNewTrigger ){  sqlite3ErrorMsg(pParse, "cannot use RETURNING in a trigger");  }else{  assert( pParse->bReturning==0 );  }  pParse->bReturning = 1;  pRet = sqlite3DbMallocZero(db, sizeof(*pRet));  if( pRet==0 ){  sqlite3ExprListDelete(db, pList);  return;  }  pParse->u1.pReturning = pRet;  pRet->pParse = pParse;  pRet->pReturnEL = pList;  sqlite3ParserAddCleanup(pParse,   (void(*)(sqlite3*,void*))sqlite3DeleteReturning, pRet);  testcase( pParse->earlyCleanup );  if( db->mallocFailed ) return;  pRet->retTrig.zName = RETURNING_TRIGGER_NAME;  pRet->retTrig.op = TK_RETURNING;  pRet->retTrig.tr_tm = TRIGGER_AFTER;  pRet->retTrig.bReturning = 1;  pRet->retTrig.pSchema = db->aDb[1].pSchema;  pRet->retTrig.pTabSchema = db->aDb[1].pSchema;  pRet->retTrig.step_list = &pRet->retTStep;  pRet->retTStep.op = TK_RETURNING;  pRet->retTStep.pTrig = &pRet->retTrig;  pRet->retTStep.pExprList = pList;  pHash = &(db->aDb[1].pSchema->trigHash);  assert( sqlite3HashFind(pHash, RETURNING_TRIGGER_NAME)==0 || pParse->nErr );  if( sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, &pRet->retTrig)  ==&pRet->retTrig ){  sqlite3OomFault(db);  } } SQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token sName, Token sType){  Table *p;  int i;  char *z;  char *zType;  Column *pCol;  sqlite3 *db = pParse->db;  u8 hName;  Column *aNew;  u8 eType = COLTYPE_CUSTOM;  u8 szEst = 1;  char affinity = SQLITE_AFF_BLOB;  if( (p = pParse->pNewTable)==0 ) return;  if( p->nCol+1>db->aLimit[SQLITE_LIMIT_COLUMN] ){  sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);  return;  }  if( !IN_RENAME_OBJECT ) sqlite3DequoteToken(&sName);  if( sType.n>=16   && sqlite3_strnicmp(sType.z+(sType.n-6),"always",6)==0  ){  sType.n -= 6;  while( ALWAYS(sType.n>0) && sqlite3Isspace(sType.z[sType.n-1]) ) sType.n--;  if( sType.n>=9   && sqlite3_strnicmp(sType.z+(sType.n-9),"generated",9)==0  ){  sType.n -= 9;  while( sType.n>0 && sqlite3Isspace(sType.z[sType.n-1]) ) sType.n--;  }  }  if( sType.n>=3 ){  sqlite3DequoteToken(&sType);  for(i=0; i<SQLITE_N_STDTYPE; i++){   if( sType.n==sqlite3StdTypeLen[i]  && sqlite3_strnicmp(sType.z, sqlite3StdType[i], sType.n)==0   ){   sType.n = 0;   eType = i+1;   affinity = sqlite3StdTypeAffinity[i];   if( affinity<=SQLITE_AFF_TEXT ) szEst = 5;   break;   }  }  }  z = sqlite3DbMallocRaw(db, (i64)sName.n + 1 + (i64)sType.n + (sType.n>0) );  if( z==0 ) return;  if( IN_RENAME_OBJECT ) sqlite3RenameTokenMap(pParse, (void*)z, &sName);  memcpy(z, sName.z, sName.n);  z[sName.n] = 0;  sqlite3Dequote(z);  hName = sqlite3StrIHash(z);  for(i=0; i<p->nCol; i++){  if( p->aCol[i].hName==hName && sqlite3StrICmp(z, p->aCol[i].zCnName)==0 ){  sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);  sqlite3DbFree(db, z);  return;  }  }  aNew = sqlite3DbRealloc(db,p->aCol,((i64)p->nCol+1)*sizeof(p->aCol[0]));  if( aNew==0 ){  sqlite3DbFree(db, z);  return;  }  p->aCol = aNew;  pCol = &p->aCol[p->nCol];  memset(pCol, 0, sizeof(p->aCol[0]));  pCol->zCnName = z;  pCol->hName = hName;  sqlite3ColumnPropertiesFromName(p, pCol);  if( sType.n==0 ){  pCol->affinity = affinity;  pCol->eCType = eType;  pCol->szEst = szEst;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( affinity==SQLITE_AFF_BLOB ){  if( 4>=sqlite3GlobalConfig.szSorterRef ){  pCol->colFlags |= COLFLAG_SORTERREF;  }  }
#endif
 }else{  zType = z + sqlite3Strlen30(z) + 1;  memcpy(zType, sType.z, sType.n);  zType[sType.n] = 0;  sqlite3Dequote(zType);  pCol->affinity = sqlite3AffinityType(zType, pCol);  pCol->colFlags |= COLFLAG_HASTYPE;  }  p->nCol++;  p->nNVCol++;  pParse->constraintName.n = 0; } SQLITE_PRIVATE void sqlite3AddNotNull(Parse *pParse, int onError){  Table *p;  Column *pCol;  p = pParse->pNewTable;  if( p==0 || NEVER(p->nCol<1) ) return;  pCol = &p->aCol[p->nCol-1];  pCol->notNull = (u8)onError;  p->tabFlags |= TF_HasNotNull;  if( pCol->colFlags & COLFLAG_UNIQUE ){  Index *pIdx;  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){  assert( pIdx->nKeyCol==1 && pIdx->onError!=OE_None );  if( pIdx->aiColumn[0]==p->nCol-1 ){  pIdx->uniqNotNull = 1;  }  }  } } SQLITE_PRIVATE char sqlite3AffinityType(const char *zIn, Column *pCol){  u32 h = 0;  char aff = SQLITE_AFF_NUMERIC;  const char *zChar = 0;  assert( zIn!=0 );  while( zIn[0] ){  h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];  zIn++;  if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){  aff = SQLITE_AFF_TEXT;  zChar = zIn;  }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){  aff = SQLITE_AFF_TEXT;  }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){  aff = SQLITE_AFF_TEXT;  }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')  && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){  aff = SQLITE_AFF_BLOB;  if( zIn[0]=='(' ) zChar = zIn;
#ifndef SQLITE_OMIT_FLOATING_POINT
 }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')  && aff==SQLITE_AFF_NUMERIC ){  aff = SQLITE_AFF_REAL;  }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')  && aff==SQLITE_AFF_NUMERIC ){  aff = SQLITE_AFF_REAL;  }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')  && aff==SQLITE_AFF_NUMERIC ){  aff = SQLITE_AFF_REAL;
#endif
 }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){  aff = SQLITE_AFF_INTEGER;  break;  }  }  if( pCol ){  int v = 0;  if( aff<SQLITE_AFF_NUMERIC ){  if( zChar ){  while( zChar[0] ){  if( sqlite3Isdigit(zChar[0]) ){  sqlite3GetInt32(zChar, &v);  break;  }  zChar++;  }  }else{  v = 16;  }  }
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( v>=sqlite3GlobalConfig.szSorterRef ){  pCol->colFlags |= COLFLAG_SORTERREF;  }
#endif
 v = v/4 + 1;  if( v>255 ) v = 255;  pCol->szEst = v;  }  return aff; } SQLITE_PRIVATE void sqlite3AddDefaultValue(  Parse *pParse,  Expr *pExpr,  const char *zStart,  const char *zEnd ){  Table *p;  Column *pCol;  sqlite3 *db = pParse->db;  p = pParse->pNewTable;  if( p!=0 ){  int isInit = db->init.busy && db->init.iDb!=1;  pCol = &(p->aCol[p->nCol-1]);  if( !sqlite3ExprIsConstantOrFunction(pExpr, isInit) ){  sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant",  pCol->zCnName);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 }else if( pCol->colFlags & COLFLAG_GENERATED ){  testcase( pCol->colFlags & COLFLAG_VIRTUAL );  testcase( pCol->colFlags & COLFLAG_STORED );  sqlite3ErrorMsg(pParse, "cannot use DEFAULT on a generated column");
#endif
 }else{  Expr x, *pDfltExpr;  memset(&x, 0, sizeof(x));  x.op = TK_SPAN;  x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);  x.pLeft = pExpr;  x.flags = EP_Skip;  pDfltExpr = sqlite3ExprDup(db, &x, EXPRDUP_REDUCE);  sqlite3DbFree(db, x.u.zToken);  sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr);  }  }  if( IN_RENAME_OBJECT ){  sqlite3RenameExprUnmap(pParse, pExpr);  }  sqlite3ExprDelete(db, pExpr); } static void sqlite3StringToId(Expr *p){  if( p->op==TK_STRING ){  p->op = TK_ID;  }else if( p->op==TK_COLLATE && p->pLeft->op==TK_STRING ){  p->pLeft->op = TK_ID;  } } static void makeColumnPartOfPrimaryKey(Parse *pParse, Column *pCol){  pCol->colFlags |= COLFLAG_PRIMKEY;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pCol->colFlags & COLFLAG_GENERATED ){  testcase( pCol->colFlags & COLFLAG_VIRTUAL );  testcase( pCol->colFlags & COLFLAG_STORED );  sqlite3ErrorMsg(pParse,  "generated columns cannot be part of the PRIMARY KEY");  }
#endif
} SQLITE_PRIVATE void sqlite3AddPrimaryKey(  Parse *pParse,  ExprList *pList,  int onError,  int autoInc,  int sortOrder ){  Table *pTab = pParse->pNewTable;  Column *pCol = 0;  int iCol = -1, i;  int nTerm;  if( pTab==0 ) goto primary_key_exit;  if( pTab->tabFlags & TF_HasPrimaryKey ){  sqlite3ErrorMsg(pParse,  "table \"%s\" has more than one primary key", pTab->zName);  goto primary_key_exit;  }  pTab->tabFlags |= TF_HasPrimaryKey;  if( pList==0 ){  iCol = pTab->nCol - 1;  pCol = &pTab->aCol[iCol];  makeColumnPartOfPrimaryKey(pParse, pCol);  nTerm = 1;  }else{  nTerm = pList->nExpr;  for(i=0; i<nTerm; i++){  Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);  assert( pCExpr!=0 );  sqlite3StringToId(pCExpr);  if( pCExpr->op==TK_ID ){  const char *zCName;  assert( !ExprHasProperty(pCExpr, EP_IntValue) );  zCName = pCExpr->u.zToken;  for(iCol=0; iCol<pTab->nCol; iCol++){  if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zCnName)==0 ){  pCol = &pTab->aCol[iCol];  makeColumnPartOfPrimaryKey(pParse, pCol);  break;  }  }  }  }  }  if( nTerm==1   && pCol   && pCol->eCType==COLTYPE_INTEGER   && sortOrder!=SQLITE_SO_DESC  ){  if( IN_RENAME_OBJECT && pList ){  Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);  sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);  }  pTab->iPKey = iCol;  pTab->keyConf = (u8)onError;  assert( autoInc==0 || autoInc==1 );  pTab->tabFlags |= autoInc*TF_Autoincrement;  if( pList ) pParse->iPkSortOrder = pList->a[0].sortFlags;  (void)sqlite3HasExplicitNulls(pParse, pList);  }else if( autoInc ){
#ifndef SQLITE_OMIT_AUTOINCREMENT
 sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an "   "INTEGER PRIMARY KEY");
#endif
 }else{  sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0,   0, sortOrder, 0, SQLITE_IDXTYPE_PRIMARYKEY);  pList = 0;  } primary_key_exit:  sqlite3ExprListDelete(pParse->db, pList);  return; } SQLITE_PRIVATE void sqlite3AddCheckConstraint(  Parse *pParse,  Expr *pCheckExpr,  const char *zStart,  const char *zEnd ){
#ifndef SQLITE_OMIT_CHECK
 Table *pTab = pParse->pNewTable;  sqlite3 *db = pParse->db;  if( pTab && !IN_DECLARE_VTAB   && !sqlite3BtreeIsReadonly(db->aDb[db->init.iDb].pBt)  ){  pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);  if( pParse->constraintName.n ){  sqlite3ExprListSetName(pParse, pTab->pCheck, &pParse->constraintName, 1);  }else{  Token t;  for(zStart++; sqlite3Isspace(zStart[0]); zStart++){}  while( sqlite3Isspace(zEnd[-1]) ){ zEnd--; }  t.z = zStart;  t.n = (int)(zEnd - t.z);  sqlite3ExprListSetName(pParse, pTab->pCheck, &t, 1);  }  }else
#endif
 {  sqlite3ExprDelete(pParse->db, pCheckExpr);  } } SQLITE_PRIVATE void sqlite3AddCollateType(Parse *pParse, Token *pToken){  Table *p;  int i;  char *zColl;  sqlite3 *db;  if( (p = pParse->pNewTable)==0 || IN_RENAME_OBJECT ) return;  i = p->nCol-1;  db = pParse->db;  zColl = sqlite3NameFromToken(db, pToken);  if( !zColl ) return;  if( sqlite3LocateCollSeq(pParse, zColl) ){  Index *pIdx;  sqlite3ColumnSetColl(db, &p->aCol[i], zColl);  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){  assert( pIdx->nKeyCol==1 );  if( pIdx->aiColumn[0]==i ){  pIdx->azColl[0] = sqlite3ColumnColl(&p->aCol[i]);  }  }  }  sqlite3DbFree(db, zColl); } SQLITE_PRIVATE void sqlite3AddGenerated(Parse *pParse, Expr *pExpr, Token *pType){
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 u8 eType = COLFLAG_VIRTUAL;  Table *pTab = pParse->pNewTable;  Column *pCol;  if( pTab==0 ){  goto generated_done;  }  pCol = &(pTab->aCol[pTab->nCol-1]);  if( IN_DECLARE_VTAB ){  sqlite3ErrorMsg(pParse, "virtual tables cannot use computed columns");  goto generated_done;  }  if( pCol->iDflt>0 ) goto generated_error;  if( pType ){  if( pType->n==7 && sqlite3StrNICmp("virtual",pType->z,7)==0 ){  }else if( pType->n==6 && sqlite3StrNICmp("stored",pType->z,6)==0 ){  eType = COLFLAG_STORED;  }else{  goto generated_error;  }  }  if( eType==COLFLAG_VIRTUAL ) pTab->nNVCol--;  pCol->colFlags |= eType;  assert( TF_HasVirtual==COLFLAG_VIRTUAL );  assert( TF_HasStored==COLFLAG_STORED );  pTab->tabFlags |= eType;  if( pCol->colFlags & COLFLAG_PRIMKEY ){  makeColumnPartOfPrimaryKey(pParse, pCol);  }  sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr);  pExpr = 0;  goto generated_done; generated_error:  sqlite3ErrorMsg(pParse, "error in generated column \"%s\"",  pCol->zCnName); generated_done:  sqlite3ExprDelete(pParse->db, pExpr);
#else
 sqlite3ErrorMsg(pParse, "generated columns not supported");  sqlite3ExprDelete(pParse->db, pExpr);
#endif
} SQLITE_PRIVATE void sqlite3ChangeCookie(Parse *pParse, int iDb){  sqlite3 *db = pParse->db;  Vdbe *v = pParse->pVdbe;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION,   (int)(1+(unsigned)db->aDb[iDb].pSchema->schema_cookie)); } static int identLength(const char *z){  int n;  for(n=0; *z; n++, z++){  if( *z=='"' ){ n++; }  }  return n + 2; } static void identPut(char *z, int *pIdx, char *zSignedIdent){  unsigned char *zIdent = (unsigned char*)zSignedIdent;  int i, j, needQuote;  i = *pIdx;  for(j=0; zIdent[j]; j++){  if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;  }  needQuote = sqlite3Isdigit(zIdent[0])  || sqlite3KeywordCode(zIdent, j)!=TK_ID  || zIdent[j]!=0  || j==0;  if( needQuote ) z[i++] = '"';  for(j=0; zIdent[j]; j++){  z[i++] = zIdent[j];  if( zIdent[j]=='"' ) z[i++] = '"';  }  if( needQuote ) z[i++] = '"';  z[i] = 0;  *pIdx = i; } static char *createTableStmt(sqlite3 *db, Table *p){  int i, k, n;  char *zStmt;  char *zSep, *zSep2, *zEnd;  Column *pCol;  n = 0;  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){  n += identLength(pCol->zCnName) + 5;  }  n += identLength(p->zName);  if( n<50 ){  zSep = "";  zSep2 = ",";  zEnd = ")";  }else{  zSep = "\n ";  zSep2 = ",\n ";  zEnd = "\n)";  }  n += 35 + 6*p->nCol;  zStmt = sqlite3DbMallocRaw(0, n);  if( zStmt==0 ){  sqlite3OomFault(db);  return 0;  }  sqlite3_snprintf(n, zStmt, "CREATE TABLE ");  k = sqlite3Strlen30(zStmt);  identPut(zStmt, &k, p->zName);  zStmt[k++] = '(';  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){  static const char * const azType[] = {   "",   " TEXT",   " NUM",   " INT",   " REAL"  };  int len;  const char *zType;  sqlite3_snprintf(n-k, &zStmt[k], zSep);  k += sqlite3Strlen30(&zStmt[k]);  zSep = zSep2;  identPut(zStmt, &k, pCol->zCnName);  assert( pCol->affinity-SQLITE_AFF_BLOB >= 0 );  assert( pCol->affinity-SQLITE_AFF_BLOB < ArraySize(azType) );  testcase( pCol->affinity==SQLITE_AFF_BLOB );  testcase( pCol->affinity==SQLITE_AFF_TEXT );  testcase( pCol->affinity==SQLITE_AFF_NUMERIC );  testcase( pCol->affinity==SQLITE_AFF_INTEGER );  testcase( pCol->affinity==SQLITE_AFF_REAL );  zType = azType[pCol->affinity - SQLITE_AFF_BLOB];  len = sqlite3Strlen30(zType);  assert( pCol->affinity==SQLITE_AFF_BLOB  || pCol->affinity==sqlite3AffinityType(zType, 0) );  memcpy(&zStmt[k], zType, len);  k += len;  assert( k<=n );  }  sqlite3_snprintf(n-k, &zStmt[k], "%s", zEnd);  return zStmt; } static int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){  char *zExtra;  int nByte;  if( pIdx->nColumn>=N ) return SQLITE_OK;  assert( pIdx->isResized==0 );  nByte = (sizeof(char*) + sizeof(LogEst) + sizeof(i16) + 1)*N;  zExtra = sqlite3DbMallocZero(db, nByte);  if( zExtra==0 ) return SQLITE_NOMEM_BKPT;  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);  pIdx->azColl = (const char**)zExtra;  zExtra += sizeof(char*)*N;  memcpy(zExtra, pIdx->aiRowLogEst, sizeof(LogEst)*(pIdx->nKeyCol+1));  pIdx->aiRowLogEst = (LogEst*)zExtra;  zExtra += sizeof(LogEst)*N;  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);  pIdx->aiColumn = (i16*)zExtra;  zExtra += sizeof(i16)*N;  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);  pIdx->aSortOrder = (u8*)zExtra;  pIdx->nColumn = N;  pIdx->isResized = 1;  return SQLITE_OK; } static void estimateTableWidth(Table *pTab){  unsigned wTable = 0;  const Column *pTabCol;  int i;  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){  wTable += pTabCol->szEst;  }  if( pTab->iPKey<0 ) wTable++;  pTab->szTabRow = sqlite3LogEst(wTable*4); } static void estimateIndexWidth(Index *pIdx){  unsigned wIndex = 0;  int i;  const Column *aCol = pIdx->pTable->aCol;  for(i=0; i<pIdx->nColumn; i++){  i16 x = pIdx->aiColumn[i];  assert( x<pIdx->pTable->nCol );  wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;  }  pIdx->szIdxRow = sqlite3LogEst(wIndex*4); } static int hasColumn(const i16 *aiCol, int nCol, int x){  while( nCol-- > 0 ){  if( x==*(aiCol++) ){  return 1;  }  }  return 0; } static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){  int i, j;  assert( nKey<=pIdx->nColumn );  assert( iCol<MAX(pPk->nColumn,pPk->nKeyCol) );  assert( pPk->idxType==SQLITE_IDXTYPE_PRIMARYKEY );  assert( pPk->pTable->tabFlags & TF_WithoutRowid );  assert( pPk->pTable==pIdx->pTable );  testcase( pPk==pIdx );  j = pPk->aiColumn[iCol];  assert( j!=XN_ROWID && j!=XN_EXPR );  for(i=0; i<nKey; i++){  assert( pIdx->aiColumn[i]>=0 || j>=0 );  if( pIdx->aiColumn[i]==j   && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0  ){  return 1;  }  }  return 0; } static void recomputeColumnsNotIndexed(Index *pIdx){  Bitmask m = 0;  int j;  Table *pTab = pIdx->pTable;  for(j=pIdx->nColumn-1; j>=0; j--){  int x = pIdx->aiColumn[j];  if( x>=0 && (pTab->aCol[x].colFlags & COLFLAG_VIRTUAL)==0 ){  testcase( x==BMS-1 );  testcase( x==BMS-2 );  if( x<BMS-1 ) m |= MASKBIT(x);  }  }  pIdx->colNotIdxed = ~m;  assert( (pIdx->colNotIdxed>>63)==1 ); } static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){  Index *pIdx;  Index *pPk;  int nPk;  int nExtra;  int i, j;  sqlite3 *db = pParse->db;  Vdbe *v = pParse->pVdbe;  if( !db->init.imposterTable ){  for(i=0; i<pTab->nCol; i++){  if( (pTab->aCol[i].colFlags & COLFLAG_PRIMKEY)!=0   && (pTab->aCol[i].notNull==OE_None)  ){  pTab->aCol[i].notNull = OE_Abort;  }  }  pTab->tabFlags |= TF_HasNotNull;  }  assert( !pParse->bReturning );  if( pParse->u1.addrCrTab ){  assert( v );  sqlite3VdbeChangeP3(v, pParse->u1.addrCrTab, BTREE_BLOBKEY);  }  if( pTab->iPKey>=0 ){  ExprList *pList;  Token ipkToken;  sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zCnName);  pList = sqlite3ExprListAppend(pParse, 0,  sqlite3ExprAlloc(db, TK_ID, &ipkToken, 0));  if( pList==0 ){  pTab->tabFlags &= ~TF_WithoutRowid;  return;  }  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);  }  pList->a[0].sortFlags = pParse->iPkSortOrder;  assert( pParse->pNewTable==pTab );  pTab->iPKey = -1;  sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,   SQLITE_IDXTYPE_PRIMARYKEY);  if( db->mallocFailed || pParse->nErr ){  pTab->tabFlags &= ~TF_WithoutRowid;  return;  }  pPk = sqlite3PrimaryKeyIndex(pTab);  assert( pPk->nKeyCol==1 );  }else{  pPk = sqlite3PrimaryKeyIndex(pTab);  assert( pPk!=0 );  for(i=j=1; i<pPk->nKeyCol; i++){  if( isDupColumn(pPk, j, pPk, i) ){  pPk->nColumn--;  }else{  testcase( hasColumn(pPk->aiColumn, j, pPk->aiColumn[i]) );  pPk->azColl[j] = pPk->azColl[i];  pPk->aSortOrder[j] = pPk->aSortOrder[i];  pPk->aiColumn[j++] = pPk->aiColumn[i];  }  }  pPk->nKeyCol = j;  }  assert( pPk!=0 );  pPk->isCovering = 1;  if( !db->init.imposterTable ) pPk->uniqNotNull = 1;  nPk = pPk->nColumn = pPk->nKeyCol;  if( v && pPk->tnum>0 ){  assert( db->init.busy==0 );  sqlite3VdbeChangeOpcode(v, (int)pPk->tnum, OP_Goto);  }  pPk->tnum = pTab->tnum;  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  int n;  if( IsPrimaryKeyIndex(pIdx) ) continue;  for(i=n=0; i<nPk; i++){  if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){  testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );  n++;  }  }  if( n==0 ){  pIdx->nColumn = pIdx->nKeyCol;  continue;  }  if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;  for(i=0, j=pIdx->nKeyCol; i<nPk; i++){  if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){  testcase( hasColumn(pIdx->aiColumn, pIdx->nKeyCol, pPk->aiColumn[i]) );  pIdx->aiColumn[j] = pPk->aiColumn[i];  pIdx->azColl[j] = pPk->azColl[i];  if( pPk->aSortOrder[i] ){  pIdx->bAscKeyBug = 1;  }  j++;  }  }  assert( pIdx->nColumn>=pIdx->nKeyCol+n );  assert( pIdx->nColumn>=j );  }  nExtra = 0;  for(i=0; i<pTab->nCol; i++){  if( !hasColumn(pPk->aiColumn, nPk, i)   && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ) nExtra++;  }  if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;  for(i=0, j=nPk; i<pTab->nCol; i++){  if( !hasColumn(pPk->aiColumn, j, i)   && (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0  ){  assert( j<pPk->nColumn );  pPk->aiColumn[j] = i;  pPk->azColl[j] = sqlite3StrBINARY;  j++;  }  }  assert( pPk->nColumn==j );  assert( pTab->nNVCol<=j );  recomputeColumnsNotIndexed(pPk); }
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE int sqlite3IsShadowTableOf(sqlite3 *db, Table *pTab, const char *zName){  int nName;  Module *pMod;  if( !IsVirtual(pTab) ) return 0;  nName = sqlite3Strlen30(pTab->zName);  if( sqlite3_strnicmp(zName, pTab->zName, nName)!=0 ) return 0;  if( zName[nName]!='_' ) return 0;  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);  if( pMod==0 ) return 0;  if( pMod->pModule->iVersion<3 ) return 0;  if( pMod->pModule->xShadowName==0 ) return 0;  return pMod->pModule->xShadowName(zName+nName+1); }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE void sqlite3MarkAllShadowTablesOf(sqlite3 *db, Table *pTab){  int nName;  Module *pMod;  HashElem *k;  assert( IsVirtual(pTab) );  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->u.vtab.azArg[0]);  if( pMod==0 ) return;  if( NEVER(pMod->pModule==0) ) return;  if( pMod->pModule->iVersion<3 ) return;  if( pMod->pModule->xShadowName==0 ) return;  assert( pTab->zName!=0 );  nName = sqlite3Strlen30(pTab->zName);  for(k=sqliteHashFirst(&pTab->pSchema->tblHash); k; k=sqliteHashNext(k)){  Table *pOther = sqliteHashData(k);  assert( pOther->zName!=0 );  if( !IsOrdinaryTable(pOther) ) continue;  if( pOther->tabFlags & TF_Shadow ) continue;  if( sqlite3StrNICmp(pOther->zName, pTab->zName, nName)==0   && pOther->zName[nName]=='_'   && pMod->pModule->xShadowName(pOther->zName+nName+1)  ){  pOther->tabFlags |= TF_Shadow;  }  } }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
SQLITE_PRIVATE int sqlite3ShadowTableName(sqlite3 *db, const char *zName){  char *zTail;  Table *pTab;  zTail = strrchr(zName, '_');  if( zTail==0 ) return 0;  *zTail = 0;  pTab = sqlite3FindTable(db, zName, 0);  *zTail = '_';  if( pTab==0 ) return 0;  if( !IsVirtual(pTab) ) return 0;  return sqlite3IsShadowTableOf(db, pTab, zName); }
#endif
#ifdef SQLITE_DEBUG
static int markImmutableExprStep(Walker *pWalker, Expr *pExpr){  ExprSetVVAProperty(pExpr, EP_Immutable);  return WRC_Continue; } static void markExprListImmutable(ExprList *pList){  if( pList ){  Walker w;  memset(&w, 0, sizeof(w));  w.xExprCallback = markImmutableExprStep;  w.xSelectCallback = sqlite3SelectWalkNoop;  w.xSelectCallback2 = 0;  sqlite3WalkExprList(&w, pList);  } }
#else
#define markExprListImmutable(X)
#endif
SQLITE_PRIVATE void sqlite3EndTable(  Parse *pParse,  Token *pCons,  Token *pEnd,  u32 tabOpts,  Select *pSelect ){  Table *p;  sqlite3 *db = pParse->db;  int iDb;  Index *pIdx;  if( pEnd==0 && pSelect==0 ){  return;  }  p = pParse->pNewTable;  if( p==0 ) return;  if( pSelect==0 && sqlite3ShadowTableName(db, p->zName) ){  p->tabFlags |= TF_Shadow;  }  if( db->init.busy ){  if( pSelect || (!IsOrdinaryTable(p) && db->init.newTnum) ){  sqlite3ErrorMsg(pParse, "");  return;  }  p->tnum = db->init.newTnum;  if( p->tnum==1 ) p->tabFlags |= TF_Readonly;  }  if( tabOpts & TF_Strict ){  int ii;  p->tabFlags |= TF_Strict;  for(ii=0; ii<p->nCol; ii++){  Column *pCol = &p->aCol[ii];  if( pCol->eCType==COLTYPE_CUSTOM ){  if( pCol->colFlags & COLFLAG_HASTYPE ){  sqlite3ErrorMsg(pParse,  "unknown datatype for %s.%s: \"%s\"",  p->zName, pCol->zCnName, sqlite3ColumnType(pCol, "")  );  }else{  sqlite3ErrorMsg(pParse, "missing datatype for %s.%s",  p->zName, pCol->zCnName);  }  return;  }else if( pCol->eCType==COLTYPE_ANY ){  pCol->affinity = SQLITE_AFF_BLOB;  }  if( (pCol->colFlags & COLFLAG_PRIMKEY)!=0   && p->iPKey!=ii   && pCol->notNull == OE_None  ){  pCol->notNull = OE_Abort;  p->tabFlags |= TF_HasNotNull;  }  }  }  assert( (p->tabFlags & TF_HasPrimaryKey)==0   || p->iPKey>=0 || sqlite3PrimaryKeyIndex(p)!=0 );  assert( (p->tabFlags & TF_HasPrimaryKey)!=0   || (p->iPKey<0 && sqlite3PrimaryKeyIndex(p)==0) );  if( tabOpts & TF_WithoutRowid ){  if( (p->tabFlags & TF_Autoincrement) ){  sqlite3ErrorMsg(pParse,  "AUTOINCREMENT not allowed on WITHOUT ROWID tables");  return;  }  if( (p->tabFlags & TF_HasPrimaryKey)==0 ){  sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p->zName);  return;  }  p->tabFlags |= TF_WithoutRowid | TF_NoVisibleRowid;  convertToWithoutRowidTable(pParse, p);  }  iDb = sqlite3SchemaToIndex(db, p->pSchema);
#ifndef SQLITE_OMIT_CHECK
 if( p->pCheck ){  sqlite3ResolveSelfReference(pParse, p, NC_IsCheck, 0, p->pCheck);  if( pParse->nErr ){  sqlite3ExprListDelete(db, p->pCheck);  p->pCheck = 0;  }else{  markExprListImmutable(p->pCheck);  }  }
#endif
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( p->tabFlags & TF_HasGenerated ){  int ii, nNG = 0;  testcase( p->tabFlags & TF_HasVirtual );  testcase( p->tabFlags & TF_HasStored );  for(ii=0; ii<p->nCol; ii++){  u32 colFlags = p->aCol[ii].colFlags;  if( (colFlags & COLFLAG_GENERATED)!=0 ){  Expr *pX = sqlite3ColumnExpr(p, &p->aCol[ii]);  testcase( colFlags & COLFLAG_VIRTUAL );  testcase( colFlags & COLFLAG_STORED );  if( sqlite3ResolveSelfReference(pParse, p, NC_GenCol, pX, 0) ){  sqlite3ColumnSetExpr(pParse, p, &p->aCol[ii],   sqlite3ExprAlloc(db, TK_NULL, 0, 0));  }  }else{  nNG++;  }  }  if( nNG==0 ){  sqlite3ErrorMsg(pParse, "must have at least one non-generated column");  return;  }  }
#endif
 estimateTableWidth(p);  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){  estimateIndexWidth(pIdx);  }  if( !db->init.busy ){  int n;  Vdbe *v;  char *zType;  char *zType2;  char *zStmt;  v = sqlite3GetVdbe(pParse);  if( NEVER(v==0) ) return;  sqlite3VdbeAddOp1(v, OP_Close, 0);  if( IsOrdinaryTable(p) ){  zType = "table";  zType2 = "TABLE";
#ifndef SQLITE_OMIT_VIEW
 }else{  zType = "view";  zType2 = "VIEW";
#endif
 }  if( pSelect ){  SelectDest dest;  int regYield;  int addrTop;  int regRec;  int regRowid;  int addrInsLoop;  Table *pSelTab;  regYield = ++pParse->nMem;  regRec = ++pParse->nMem;  regRowid = ++pParse->nMem;  assert(pParse->nTab==1);  sqlite3MayAbort(pParse);  sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);  sqlite3VdbeChangeP5(v, OPFLAG_P2ISREG);  pParse->nTab = 2;  addrTop = sqlite3VdbeCurrentAddr(v) + 1;  sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);  if( pParse->nErr ) return;  pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, SQLITE_AFF_BLOB);  if( pSelTab==0 ) return;  assert( p->aCol==0 );  p->nCol = p->nNVCol = pSelTab->nCol;  p->aCol = pSelTab->aCol;  pSelTab->nCol = 0;  pSelTab->aCol = 0;  sqlite3DeleteTable(db, pSelTab);  sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);  sqlite3Select(pParse, pSelect, &dest);  if( pParse->nErr ) return;  sqlite3VdbeEndCoroutine(v, regYield);  sqlite3VdbeJumpHere(v, addrTop - 1);  addrInsLoop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_MakeRecord, dest.iSdst, dest.nSdst, regRec);  sqlite3TableAffinity(v, p, 0);  sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);  sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);  sqlite3VdbeGoto(v, addrInsLoop);  sqlite3VdbeJumpHere(v, addrInsLoop);  sqlite3VdbeAddOp1(v, OP_Close, 1);  }  if( pSelect ){  zStmt = createTableStmt(db, p);  }else{  Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;  n = (int)(pEnd2->z - pParse->sNameToken.z);  if( pEnd2->z[0]!=';' ) n += pEnd2->n;  zStmt = sqlite3MPrintf(db,  "CREATE %s %.*s", zType2, n, pParse->sNameToken.z  );  }  sqlite3NestedParse(pParse,  "UPDATE %Q." LEGACY_SCHEMA_TABLE  " SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q"  " WHERE rowid=#%d",  db->aDb[iDb].zDbSName,  zType,  p->zName,  p->zName,  pParse->regRoot,  zStmt,  pParse->regRowid  );  sqlite3DbFree(db, zStmt);  sqlite3ChangeCookie(pParse, iDb);
#ifndef SQLITE_OMIT_AUTOINCREMENT
 if( (p->tabFlags & TF_Autoincrement)!=0 && !IN_SPECIAL_PARSE ){  Db *pDb = &db->aDb[iDb];  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( pDb->pSchema->pSeqTab==0 ){  sqlite3NestedParse(pParse,  "CREATE TABLE %Q.sqlite_sequence(name,seq)",  pDb->zDbSName  );  }  }
#endif
 sqlite3VdbeAddParseSchemaOp(v, iDb,   sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p->zName),0);  }  if( db->init.busy ){  Table *pOld;  Schema *pSchema = p->pSchema;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  assert( HasRowid(p) || p->iPKey<0 );  pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);  if( pOld ){  assert( p==pOld );  sqlite3OomFault(db);  return;  }  pParse->pNewTable = 0;  db->mDbFlags |= DBFLAG_SchemaChange;  assert( !pParse->nested );
#ifndef SQLITE_OMIT_AUTOINCREMENT
 if( strcmp(p->zName, "sqlite_sequence")==0 ){  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  p->pSchema->pSeqTab = p;  }
#endif
 }
#ifndef SQLITE_OMIT_ALTERTABLE
 if( !pSelect && IsOrdinaryTable(p) ){  assert( pCons && pEnd );  if( pCons->z==0 ){  pCons = pEnd;  }  p->u.tab.addColOffset = 13 + (int)(pCons->z - pParse->sNameToken.z);  }
#endif
}
#ifndef SQLITE_OMIT_VIEW
SQLITE_PRIVATE void sqlite3CreateView(  Parse *pParse,  Token *pBegin,  Token *pName1,  Token *pName2,  ExprList *pCNames,  Select *pSelect,  int isTemp,  int noErr ){  Table *p;  int n;  const char *z;  Token sEnd;  DbFixer sFix;  Token *pName = 0;  int iDb;  sqlite3 *db = pParse->db;  if( pParse->nVar>0 ){  sqlite3ErrorMsg(pParse, "parameters are not allowed in views");  goto create_view_fail;  }  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);  p = pParse->pNewTable;  if( p==0 || pParse->nErr ) goto create_view_fail;
#ifndef SQLITE_ALLOW_ROWID_IN_VIEW
 p->tabFlags |= TF_NoVisibleRowid;
#endif
 sqlite3TwoPartName(pParse, pName1, pName2, &pName);  iDb = sqlite3SchemaToIndex(db, p->pSchema);  sqlite3FixInit(&sFix, pParse, iDb, "view", pName);  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;  pSelect->selFlags |= SF_View;  if( IN_RENAME_OBJECT ){  p->u.view.pSelect = pSelect;  pSelect = 0;  }else{  p->u.view.pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);  }  p->pCheck = sqlite3ExprListDup(db, pCNames, EXPRDUP_REDUCE);  p->eTabType = TABTYP_VIEW;  if( db->mallocFailed ) goto create_view_fail;  sEnd = pParse->sLastToken;  assert( sEnd.z[0]!=0 || sEnd.n==0 );  if( sEnd.z[0]!=';' ){  sEnd.z += sEnd.n;  }  sEnd.n = 0;  n = (int)(sEnd.z - pBegin->z);  assert( n>0 );  z = pBegin->z;  while( sqlite3Isspace(z[n-1]) ){ n--; }  sEnd.z = &z[n-1];  sEnd.n = 1;  sqlite3EndTable(pParse, 0, &sEnd, 0, 0); create_view_fail:  sqlite3SelectDelete(db, pSelect);  if( IN_RENAME_OBJECT ){  sqlite3RenameExprlistUnmap(pParse, pCNames);  }  sqlite3ExprListDelete(db, pCNames);  return; }
#endif
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){  Table *pSelTab;  Select *pSel;  int nErr = 0;  int n;  sqlite3 *db = pParse->db;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 int rc;
#endif
#ifndef SQLITE_OMIT_AUTHORIZATION
 sqlite3_xauth xAuth;
#endif
 assert( pTable );
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTable) ){  db->nSchemaLock++;  rc = sqlite3VtabCallConnect(pParse, pTable);  db->nSchemaLock--;  return rc;  }
#endif
#ifndef SQLITE_OMIT_VIEW
 if( pTable->nCol>0 ) return 0;  if( pTable->nCol<0 ){  sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);  return 1;  }  assert( pTable->nCol>=0 );  assert( IsView(pTable) );  pSel = sqlite3SelectDup(db, pTable->u.view.pSelect, 0);  if( pSel ){  u8 eParseMode = pParse->eParseMode;  pParse->eParseMode = PARSE_MODE_NORMAL;  n = pParse->nTab;  sqlite3SrcListAssignCursors(pParse, pSel->pSrc);  pTable->nCol = -1;  DisableLookaside;
#ifndef SQLITE_OMIT_AUTHORIZATION
 xAuth = db->xAuth;  db->xAuth = 0;  pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);  db->xAuth = xAuth;
#else
 pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, SQLITE_AFF_NONE);
#endif
 pParse->nTab = n;  if( pSelTab==0 ){  pTable->nCol = 0;  nErr++;  }else if( pTable->pCheck ){  sqlite3ColumnsFromExprList(pParse, pTable->pCheck,   &pTable->nCol, &pTable->aCol);  if( db->mallocFailed==0   && pParse->nErr==0   && pTable->nCol==pSel->pEList->nExpr  ){  sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel,   SQLITE_AFF_NONE);  }  }else{  assert( pTable->aCol==0 );  pTable->nCol = pSelTab->nCol;  pTable->aCol = pSelTab->aCol;  pTable->tabFlags |= (pSelTab->tabFlags & COLFLAG_NOINSERT);  pSelTab->nCol = 0;  pSelTab->aCol = 0;  assert( sqlite3SchemaMutexHeld(db, 0, pTable->pSchema) );  }  pTable->nNVCol = pTable->nCol;  sqlite3DeleteTable(db, pSelTab);  sqlite3SelectDelete(db, pSel);  EnableLookaside;  pParse->eParseMode = eParseMode;  } else {  nErr++;  }  pTable->pSchema->schemaFlags |= DB_UnresetViews;  if( db->mallocFailed ){  sqlite3DeleteColumnNames(db, pTable);  }
#endif
 return nErr; }
#endif
#ifndef SQLITE_OMIT_VIEW
static void sqliteViewResetAll(sqlite3 *db, int idx){  HashElem *i;  assert( sqlite3SchemaMutexHeld(db, idx, 0) );  if( !DbHasProperty(db, idx, DB_UnresetViews) ) return;  for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){  Table *pTab = sqliteHashData(i);  if( IsView(pTab) ){  sqlite3DeleteColumnNames(db, pTab);  }  }  DbClearProperty(db, idx, DB_UnresetViews); }
#else
# define sqliteViewResetAll(A,B)
#endif
#ifndef SQLITE_OMIT_AUTOVACUUM
SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3 *db, int iDb, Pgno iFrom, Pgno iTo){  HashElem *pElem;  Hash *pHash;  Db *pDb;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  pDb = &db->aDb[iDb];  pHash = &pDb->pSchema->tblHash;  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){  Table *pTab = sqliteHashData(pElem);  if( pTab->tnum==iFrom ){  pTab->tnum = iTo;  }  }  pHash = &pDb->pSchema->idxHash;  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){  Index *pIdx = sqliteHashData(pElem);  if( pIdx->tnum==iFrom ){  pIdx->tnum = iTo;  }  } }
#endif
static void destroyRootPage(Parse *pParse, int iTable, int iDb){  Vdbe *v = sqlite3GetVdbe(pParse);  int r1 = sqlite3GetTempReg(pParse);  if( iTable<2 ) sqlite3ErrorMsg(pParse, "corrupt schema");  sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);  sqlite3MayAbort(pParse);
#ifndef SQLITE_OMIT_AUTOVACUUM
 sqlite3NestedParse(pParse,   "UPDATE %Q." LEGACY_SCHEMA_TABLE   " SET rootpage=%d WHERE #%d AND rootpage=#%d",   pParse->db->aDb[iDb].zDbSName, iTable, r1, r1);
#endif
 sqlite3ReleaseTempReg(pParse, r1); } static void destroyTable(Parse *pParse, Table *pTab){  Pgno iTab = pTab->tnum;  Pgno iDestroyed = 0;  while( 1 ){  Index *pIdx;  Pgno iLargest = 0;  if( iDestroyed==0 || iTab<iDestroyed ){  iLargest = iTab;  }  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  Pgno iIdx = pIdx->tnum;  assert( pIdx->pSchema==pTab->pSchema );  if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){  iLargest = iIdx;  }  }  if( iLargest==0 ){  return;  }else{  int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  assert( iDb>=0 && iDb<pParse->db->nDb );  destroyRootPage(pParse, iLargest, iDb);  iDestroyed = iLargest;  }  } } static void sqlite3ClearStatTables(  Parse *pParse,  int iDb,  const char *zType,  const char *zName ){  int i;  const char *zDbName = pParse->db->aDb[iDb].zDbSName;  for(i=1; i<=4; i++){  char zTab[24];  sqlite3_snprintf(sizeof(zTab),zTab,"sqlite_stat%d",i);  if( sqlite3FindTable(pParse->db, zTab, zDbName) ){  sqlite3NestedParse(pParse,  "DELETE FROM %Q.%s WHERE %s=%Q",  zDbName, zTab, zType, zName  );  }  } } SQLITE_PRIVATE void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){  Vdbe *v;  sqlite3 *db = pParse->db;  Trigger *pTrigger;  Db *pDb = &db->aDb[iDb];  v = sqlite3GetVdbe(pParse);  assert( v!=0 );  sqlite3BeginWriteOperation(pParse, 1, iDb);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  sqlite3VdbeAddOp0(v, OP_VBegin);  }
#endif
 pTrigger = sqlite3TriggerList(pParse, pTab);  while( pTrigger ){  assert( pTrigger->pSchema==pTab->pSchema ||  pTrigger->pSchema==db->aDb[1].pSchema );  sqlite3DropTriggerPtr(pParse, pTrigger);  pTrigger = pTrigger->pNext;  }
#ifndef SQLITE_OMIT_AUTOINCREMENT
 if( pTab->tabFlags & TF_Autoincrement ){  sqlite3NestedParse(pParse,  "DELETE FROM %Q.sqlite_sequence WHERE name=%Q",  pDb->zDbSName, pTab->zName  );  }
#endif
 sqlite3NestedParse(pParse,  "DELETE FROM %Q." LEGACY_SCHEMA_TABLE  " WHERE tbl_name=%Q and type!='trigger'",  pDb->zDbSName, pTab->zName);  if( !isView && !IsVirtual(pTab) ){  destroyTable(pParse, pTab);  }  if( IsVirtual(pTab) ){  sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab->zName, 0);  sqlite3MayAbort(pParse);  }  sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);  sqlite3ChangeCookie(pParse, iDb);  sqliteViewResetAll(db, iDb); } SQLITE_PRIVATE int sqlite3ReadOnlyShadowTables(sqlite3 *db){
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( (db->flags & SQLITE_Defensive)!=0   && db->pVtabCtx==0   && db->nVdbeExec==0   && !sqlite3VtabInSync(db)  ){  return 1;  }
#endif
 return 0; } static int tableMayNotBeDropped(sqlite3 *db, Table *pTab){  if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){  if( sqlite3StrNICmp(pTab->zName+7, "stat", 4)==0 ) return 0;  if( sqlite3StrNICmp(pTab->zName+7, "parameters", 10)==0 ) return 0;  return 1;  }  if( (pTab->tabFlags & TF_Shadow)!=0 && sqlite3ReadOnlyShadowTables(db) ){  return 1;  }  if( pTab->tabFlags & TF_Eponymous ){  return 1;  }  return 0; } SQLITE_PRIVATE void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){  Table *pTab;  Vdbe *v;  sqlite3 *db = pParse->db;  int iDb;  if( db->mallocFailed ){  goto exit_drop_table;  }  assert( pParse->nErr==0 );  assert( pName->nSrc==1 );  if( sqlite3ReadSchema(pParse) ) goto exit_drop_table;  if( noErr ) db->suppressErr++;  assert( isView==0 || isView==LOCATE_VIEW );  pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);  if( noErr ) db->suppressErr--;  if( pTab==0 ){  if( noErr ){  sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);  sqlite3ForceNotReadOnly(pParse);  }  goto exit_drop_table;  }  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iDb>=0 && iDb<db->nDb );  if( IsVirtual(pTab) && sqlite3ViewGetColumnNames(pParse, pTab) ){  goto exit_drop_table;  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 {  int code;  const char *zTab = SCHEMA_TABLE(iDb);  const char *zDb = db->aDb[iDb].zDbSName;  const char *zArg2 = 0;  if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){  goto exit_drop_table;  }  if( isView ){  if( !OMIT_TEMPDB && iDb==1 ){  code = SQLITE_DROP_TEMP_VIEW;  }else{  code = SQLITE_DROP_VIEW;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 }else if( IsVirtual(pTab) ){  code = SQLITE_DROP_VTABLE;  zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;
#endif
 }else{  if( !OMIT_TEMPDB && iDb==1 ){  code = SQLITE_DROP_TEMP_TABLE;  }else{  code = SQLITE_DROP_TABLE;  }  }  if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){  goto exit_drop_table;  }  if( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb) ){  goto exit_drop_table;  }  }
#endif
 if( tableMayNotBeDropped(db, pTab) ){  sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);  goto exit_drop_table;  }
#ifndef SQLITE_OMIT_VIEW
 if( isView && !IsView(pTab) ){  sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);  goto exit_drop_table;  }  if( !isView && IsView(pTab) ){  sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);  goto exit_drop_table;  }
#endif
 v = sqlite3GetVdbe(pParse);  if( v ){  sqlite3BeginWriteOperation(pParse, 1, iDb);  if( !isView ){  sqlite3ClearStatTables(pParse, iDb, "tbl", pTab->zName);  sqlite3FkDropTable(pParse, pName, pTab);  }  sqlite3CodeDropTable(pParse, pTab, iDb, isView);  } exit_drop_table:  sqlite3SrcListDelete(db, pName); } SQLITE_PRIVATE void sqlite3CreateForeignKey(  Parse *pParse,  ExprList *pFromCol,  Token *pTo,  ExprList *pToCol,  int flags ){  sqlite3 *db = pParse->db;
#ifndef SQLITE_OMIT_FOREIGN_KEY
 FKey *pFKey = 0;  FKey *pNextTo;  Table *p = pParse->pNewTable;  i64 nByte;  int i;  int nCol;  char *z;  assert( pTo!=0 );  if( p==0 || IN_DECLARE_VTAB ) goto fk_end;  if( pFromCol==0 ){  int iCol = p->nCol-1;  if( NEVER(iCol<0) ) goto fk_end;  if( pToCol && pToCol->nExpr!=1 ){  sqlite3ErrorMsg(pParse, "foreign key on %s"   " should reference only one column of table %T",   p->aCol[iCol].zCnName, pTo);  goto fk_end;  }  nCol = 1;  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){  sqlite3ErrorMsg(pParse,  "number of columns in foreign key does not match the number of "  "columns in the referenced table");  goto fk_end;  }else{  nCol = pFromCol->nExpr;  }  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;  if( pToCol ){  for(i=0; i<pToCol->nExpr; i++){  nByte += sqlite3Strlen30(pToCol->a[i].zEName) + 1;  }  }  pFKey = sqlite3DbMallocZero(db, nByte );  if( pFKey==0 ){  goto fk_end;  }  pFKey->pFrom = p;  assert( IsOrdinaryTable(p) );  pFKey->pNextFrom = p->u.tab.pFKey;  z = (char*)&pFKey->aCol[nCol];  pFKey->zTo = z;  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenMap(pParse, (void*)z, pTo);  }  memcpy(z, pTo->z, pTo->n);  z[pTo->n] = 0;  sqlite3Dequote(z);  z += pTo->n+1;  pFKey->nCol = nCol;  if( pFromCol==0 ){  pFKey->aCol[0].iFrom = p->nCol-1;  }else{  for(i=0; i<nCol; i++){  int j;  for(j=0; j<p->nCol; j++){  if( sqlite3StrICmp(p->aCol[j].zCnName, pFromCol->a[i].zEName)==0 ){  pFKey->aCol[i].iFrom = j;  break;  }  }  if( j>=p->nCol ){  sqlite3ErrorMsg(pParse,  "unknown column \"%s\" in foreign key definition",  pFromCol->a[i].zEName);  goto fk_end;  }  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zEName);  }  }  }  if( pToCol ){  for(i=0; i<nCol; i++){  int n = sqlite3Strlen30(pToCol->a[i].zEName);  pFKey->aCol[i].zCol = z;  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zEName);  }  memcpy(z, pToCol->a[i].zEName, n);  z[n] = 0;  z += n+1;  }  }  pFKey->isDeferred = 0;  pFKey->aAction[0] = (u8)(flags & 0xff);  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);  assert( sqlite3SchemaMutexHeld(db, 0, p->pSchema) );  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash,  pFKey->zTo, (void *)pFKey  );  if( pNextTo==pFKey ){  sqlite3OomFault(db);  goto fk_end;  }  if( pNextTo ){  assert( pNextTo->pPrevTo==0 );  pFKey->pNextTo = pNextTo;  pNextTo->pPrevTo = pFKey;  }  assert( IsOrdinaryTable(p) );  p->u.tab.pFKey = pFKey;  pFKey = 0; fk_end:  sqlite3DbFree(db, pFKey);
#endif
 sqlite3ExprListDelete(db, pFromCol);  sqlite3ExprListDelete(db, pToCol); } SQLITE_PRIVATE void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){
#ifndef SQLITE_OMIT_FOREIGN_KEY
 Table *pTab;  FKey *pFKey;  if( (pTab = pParse->pNewTable)==0 ) return;  if( NEVER(!IsOrdinaryTable(pTab)) ) return;  if( (pFKey = pTab->u.tab.pFKey)==0 ) return;  assert( isDeferred==0 || isDeferred==1 );  pFKey->isDeferred = (u8)isDeferred;
#endif
} static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){  Table *pTab = pIndex->pTable;  int iTab = pParse->nTab++;  int iIdx = pParse->nTab++;  int iSorter;  int addr1;  int addr2;  Pgno tnum;  int iPartIdxLabel;  Vdbe *v;  KeyInfo *pKey;  int regRecord;  sqlite3 *db = pParse->db;  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0,  db->aDb[iDb].zDbSName ) ){  return;  }
#endif
 sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);  v = sqlite3GetVdbe(pParse);  if( v==0 ) return;  if( memRootPage>=0 ){  tnum = (Pgno)memRootPage;  }else{  tnum = pIndex->tnum;  }  pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);  assert( pKey!=0 || db->mallocFailed || pParse->nErr );  iSorter = pParse->nTab++;  sqlite3VdbeAddOp4(v, OP_SorterOpen, iSorter, 0, pIndex->nKeyCol, (char*)  sqlite3KeyInfoRef(pKey), P4_KEYINFO);  sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);  addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0); VdbeCoverage(v);  regRecord = sqlite3GetTempReg(pParse);  sqlite3MultiWrite(pParse);  sqlite3GenerateIndexKey(pParse,pIndex,iTab,regRecord,0,&iPartIdxLabel,0,0);  sqlite3VdbeAddOp2(v, OP_SorterInsert, iSorter, regRecord);  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);  sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr1);  if( memRootPage<0 ) sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, (int)tnum, iDb,  (char *)pKey, P4_KEYINFO);  sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR|((memRootPage>=0)?OPFLAG_P2ISREG:0));  addr1 = sqlite3VdbeAddOp2(v, OP_SorterSort, iSorter, 0); VdbeCoverage(v);  if( IsUniqueIndex(pIndex) ){  int j2 = sqlite3VdbeGoto(v, 1);  addr2 = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeVerifyAbortable(v, OE_Abort);  sqlite3VdbeAddOp4Int(v, OP_SorterCompare, iSorter, j2, regRecord,   pIndex->nKeyCol); VdbeCoverage(v);  sqlite3UniqueConstraint(pParse, OE_Abort, pIndex);  sqlite3VdbeJumpHere(v, j2);  }else{  sqlite3MayAbort(pParse);  addr2 = sqlite3VdbeCurrentAddr(v);  }  sqlite3VdbeAddOp3(v, OP_SorterData, iSorter, regRecord, iIdx);  if( !pIndex->bAscKeyBug ){  sqlite3VdbeAddOp1(v, OP_SeekEnd, iIdx);  }  sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord);  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);  sqlite3ReleaseTempReg(pParse, regRecord);  sqlite3VdbeAddOp2(v, OP_SorterNext, iSorter, addr2); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr1);  sqlite3VdbeAddOp1(v, OP_Close, iTab);  sqlite3VdbeAddOp1(v, OP_Close, iIdx);  sqlite3VdbeAddOp1(v, OP_Close, iSorter); } SQLITE_PRIVATE Index *sqlite3AllocateIndexObject(  sqlite3 *db,  i16 nCol,  int nExtra,  char **ppExtra ){  Index *p;  int nByte;  nByte = ROUND8(sizeof(Index)) +  ROUND8(sizeof(char*)*nCol) +  ROUND8(sizeof(LogEst)*(nCol+1) +   sizeof(i16)*nCol +   sizeof(u8)*nCol);  p = sqlite3DbMallocZero(db, nByte + nExtra);  if( p ){  char *pExtra = ((char*)p)+ROUND8(sizeof(Index));  p->azColl = (const char**)pExtra; pExtra += ROUND8(sizeof(char*)*nCol);  p->aiRowLogEst = (LogEst*)pExtra; pExtra += sizeof(LogEst)*(nCol+1);  p->aiColumn = (i16*)pExtra;  pExtra += sizeof(i16)*nCol;  p->aSortOrder = (u8*)pExtra;  p->nColumn = nCol;  p->nKeyCol = nCol - 1;  *ppExtra = ((char*)p) + nByte;  }  return p; } SQLITE_PRIVATE int sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){  if( pList ){  int i;  for(i=0; i<pList->nExpr; i++){  if( pList->a[i].bNulls ){  u8 sf = pList->a[i].sortFlags;  sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s",  (sf==0 || sf==3) ? "FIRST" : "LAST"  );  return 1;  }  }  }  return 0; } SQLITE_PRIVATE void sqlite3CreateIndex(  Parse *pParse,  Token *pName1,  Token *pName2,  SrcList *pTblName,  ExprList *pList,  int onError,  Token *pStart,  Expr *pPIWhere,  int sortOrder,  int ifNotExist,  u8 idxType ){  Table *pTab = 0;  Index *pIndex = 0;  char *zName = 0;  int nName;  int i, j;  DbFixer sFix;  int sortOrderMask;  sqlite3 *db = pParse->db;  Db *pDb;  int iDb;  Token *pName = 0;  struct ExprList_item *pListItem;  int nExtra = 0;  int nExtraCol;  char *zExtra = 0;  Index *pPk = 0;  if( db->mallocFailed || pParse->nErr>0 ){  goto exit_create_index;  }  if( IN_DECLARE_VTAB && idxType!=SQLITE_IDXTYPE_PRIMARYKEY ){  goto exit_create_index;  }  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){  goto exit_create_index;  }  if( sqlite3HasExplicitNulls(pParse, pList) ){  goto exit_create_index;  }  if( pTblName!=0 ){  assert( pName1 && pName2 );  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);  if( iDb<0 ) goto exit_create_index;  assert( pName && pName->z );
#ifndef SQLITE_OMIT_TEMPDB
 if( !db->init.busy ){  pTab = sqlite3SrcListLookup(pParse, pTblName);  if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){  iDb = 1;  }  }
#endif
 sqlite3FixInit(&sFix, pParse, iDb, "index", pName);  if( sqlite3FixSrcList(&sFix, pTblName) ){  assert(0);  }  pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);  assert( db->mallocFailed==0 || pTab==0 );  if( pTab==0 ) goto exit_create_index;  if( iDb==1 && db->aDb[iDb].pSchema!=pTab->pSchema ){  sqlite3ErrorMsg(pParse,   "cannot create a TEMP index on non-TEMP table \"%s\"",   pTab->zName);  goto exit_create_index;  }  if( !HasRowid(pTab) ) pPk = sqlite3PrimaryKeyIndex(pTab);  }else{  assert( pName==0 );  assert( pStart==0 );  pTab = pParse->pNewTable;  if( !pTab ) goto exit_create_index;  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  }  pDb = &db->aDb[iDb];  assert( pTab!=0 );  assert( pParse->nErr==0 );  if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0   && db->init.busy==0   && pTblName!=0
#if SQLITE_USER_AUTHENTICATION
  && sqlite3UserAuthTable(pTab->zName)==0
#endif
 ){  sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);  goto exit_create_index;  }
#ifndef SQLITE_OMIT_VIEW
 if( IsView(pTab) ){  sqlite3ErrorMsg(pParse, "views may not be indexed");  goto exit_create_index;  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");  goto exit_create_index;  }
#endif
 if( pName ){  zName = sqlite3NameFromToken(db, pName);  if( zName==0 ) goto exit_create_index;  assert( pName->z!=0 );  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName,"index",pTab->zName) ){  goto exit_create_index;  }  if( !IN_RENAME_OBJECT ){  if( !db->init.busy ){  if( sqlite3FindTable(db, zName, 0)!=0 ){  sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);  goto exit_create_index;  }  }  if( sqlite3FindIndex(db, zName, pDb->zDbSName)!=0 ){  if( !ifNotExist ){  sqlite3ErrorMsg(pParse, "index %s already exists", zName);  }else{  assert( !db->init.busy );  sqlite3CodeVerifySchema(pParse, iDb);  sqlite3ForceNotReadOnly(pParse);  }  goto exit_create_index;  }  }  }else{  int n;  Index *pLoop;  for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}  zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);  if( zName==0 ){  goto exit_create_index;  }  if( IN_SPECIAL_PARSE ) zName[7]++;  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( !IN_RENAME_OBJECT ){  const char *zDb = pDb->zDbSName;  if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){  goto exit_create_index;  }  i = SQLITE_CREATE_INDEX;  if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;  if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){  goto exit_create_index;  }  }
#endif
 if( pList==0 ){  Token prevCol;  Column *pCol = &pTab->aCol[pTab->nCol-1];  pCol->colFlags |= COLFLAG_UNIQUE;  sqlite3TokenInit(&prevCol, pCol->zCnName);  pList = sqlite3ExprListAppend(pParse, 0,  sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));  if( pList==0 ) goto exit_create_index;  assert( pList->nExpr==1 );  sqlite3ExprListSetSortOrder(pList, sortOrder, SQLITE_SO_UNDEFINED);  }else{  sqlite3ExprListCheckLength(pParse, pList, "index");  if( pParse->nErr ) goto exit_create_index;  }  for(i=0; i<pList->nExpr; i++){  Expr *pExpr = pList->a[i].pExpr;  assert( pExpr!=0 );  if( pExpr->op==TK_COLLATE ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));  }  }  nName = sqlite3Strlen30(zName);  nExtraCol = pPk ? pPk->nKeyCol : 1;  assert( pList->nExpr + nExtraCol <= 32767 );  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,  nName + nExtra + 1, &zExtra);  if( db->mallocFailed ){  goto exit_create_index;  }  assert( EIGHT_BYTE_ALIGNMENT(pIndex->aiRowLogEst) );  assert( EIGHT_BYTE_ALIGNMENT(pIndex->azColl) );  pIndex->zName = zExtra;  zExtra += nName + 1;  memcpy(pIndex->zName, zName, nName+1);  pIndex->pTable = pTab;  pIndex->onError = (u8)onError;  pIndex->uniqNotNull = onError!=OE_None;  pIndex->idxType = idxType;  pIndex->pSchema = db->aDb[iDb].pSchema;  pIndex->nKeyCol = pList->nExpr;  if( pPIWhere ){  sqlite3ResolveSelfReference(pParse, pTab, NC_PartIdx, pPIWhere, 0);  pIndex->pPartIdxWhere = pPIWhere;  pPIWhere = 0;  }  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( pDb->pSchema->file_format>=4 ){  sortOrderMask = -1;  }else{  sortOrderMask = 0;  }  pListItem = pList->a;  if( IN_RENAME_OBJECT ){  pIndex->aColExpr = pList;  pList = 0;  }  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){  Expr *pCExpr;  int requestedSortOrder;  const char *zColl;  sqlite3StringToId(pListItem->pExpr);  sqlite3ResolveSelfReference(pParse, pTab, NC_IdxExpr, pListItem->pExpr, 0);  if( pParse->nErr ) goto exit_create_index;  pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);  if( pCExpr->op!=TK_COLUMN ){  if( pTab==pParse->pNewTable ){  sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and "  "UNIQUE constraints");  goto exit_create_index;  }  if( pIndex->aColExpr==0 ){  pIndex->aColExpr = pList;  pList = 0;  }  j = XN_EXPR;  pIndex->aiColumn[i] = XN_EXPR;  pIndex->uniqNotNull = 0;  }else{  j = pCExpr->iColumn;  assert( j<=0x7fff );  if( j<0 ){  j = pTab->iPKey;  }else{  if( pTab->aCol[j].notNull==0 ){  pIndex->uniqNotNull = 0;  }  if( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL ){  pIndex->bHasVCol = 1;  }  }  pIndex->aiColumn[i] = (i16)j;  }  zColl = 0;  if( pListItem->pExpr->op==TK_COLLATE ){  int nColl;  assert( !ExprHasProperty(pListItem->pExpr, EP_IntValue) );  zColl = pListItem->pExpr->u.zToken;  nColl = sqlite3Strlen30(zColl) + 1;  assert( nExtra>=nColl );  memcpy(zExtra, zColl, nColl);  zColl = zExtra;  zExtra += nColl;  nExtra -= nColl;  }else if( j>=0 ){  zColl = sqlite3ColumnColl(&pTab->aCol[j]);  }  if( !zColl ) zColl = sqlite3StrBINARY;  if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){  goto exit_create_index;  }  pIndex->azColl[i] = zColl;  requestedSortOrder = pListItem->sortFlags & sortOrderMask;  pIndex->aSortOrder[i] = (u8)requestedSortOrder;  }  if( pPk ){  for(j=0; j<pPk->nKeyCol; j++){  int x = pPk->aiColumn[j];  assert( x>=0 );  if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){  pIndex->nColumn--;  }else{  testcase( hasColumn(pIndex->aiColumn,pIndex->nKeyCol,x) );  pIndex->aiColumn[i] = x;  pIndex->azColl[i] = pPk->azColl[j];  pIndex->aSortOrder[i] = pPk->aSortOrder[j];  i++;  }  }  assert( i==pIndex->nColumn );  }else{  pIndex->aiColumn[i] = XN_ROWID;  pIndex->azColl[i] = sqlite3StrBINARY;  }  sqlite3DefaultRowEst(pIndex);  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);  assert( HasRowid(pTab)  || pTab->iPKey<0 || sqlite3TableColumnToIndex(pIndex, pTab->iPKey)>=0 );  recomputeColumnsNotIndexed(pIndex);  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){  pIndex->isCovering = 1;  for(j=0; j<pTab->nCol; j++){  if( j==pTab->iPKey ) continue;  if( sqlite3TableColumnToIndex(pIndex,j)>=0 ) continue;  pIndex->isCovering = 0;  break;  }  }  if( pTab==pParse->pNewTable ){  Index *pIdx;  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  int k;  assert( IsUniqueIndex(pIdx) );  assert( pIdx->idxType!=SQLITE_IDXTYPE_APPDEF );  assert( IsUniqueIndex(pIndex) );  if( pIdx->nKeyCol!=pIndex->nKeyCol ) continue;  for(k=0; k<pIdx->nKeyCol; k++){  const char *z1;  const char *z2;  assert( pIdx->aiColumn[k]>=0 );  if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;  z1 = pIdx->azColl[k];  z2 = pIndex->azColl[k];  if( sqlite3StrICmp(z1, z2) ) break;  }  if( k==pIdx->nKeyCol ){  if( pIdx->onError!=pIndex->onError ){  if( !(pIdx->onError==OE_Default || pIndex->onError==OE_Default) ){  sqlite3ErrorMsg(pParse,  "conflicting ON CONFLICT clauses specified", 0);  }  if( pIdx->onError==OE_Default ){  pIdx->onError = pIndex->onError;  }  }  if( idxType==SQLITE_IDXTYPE_PRIMARYKEY ) pIdx->idxType = idxType;  if( IN_RENAME_OBJECT ){  pIndex->pNext = pParse->pNewIndex;  pParse->pNewIndex = pIndex;  pIndex = 0;  }  goto exit_create_index;  }  }  }  if( !IN_RENAME_OBJECT ){  assert( pParse->nErr==0 );  if( db->init.busy ){  Index *p;  assert( !IN_SPECIAL_PARSE );  assert( sqlite3SchemaMutexHeld(db, 0, pIndex->pSchema) );  if( pTblName!=0 ){  pIndex->tnum = db->init.newTnum;  if( sqlite3IndexHasDuplicateRootPage(pIndex) ){  sqlite3ErrorMsg(pParse, "invalid rootpage");  pParse->rc = SQLITE_CORRUPT_BKPT;  goto exit_create_index;  }  }  p = sqlite3HashInsert(&pIndex->pSchema->idxHash,  pIndex->zName, pIndex);  if( p ){  assert( p==pIndex );  sqlite3OomFault(db);  goto exit_create_index;  }  db->mDbFlags |= DBFLAG_SchemaChange;  }  else if( HasRowid(pTab) || pTblName!=0 ){  Vdbe *v;  char *zStmt;  int iMem = ++pParse->nMem;  v = sqlite3GetVdbe(pParse);  if( v==0 ) goto exit_create_index;  sqlite3BeginWriteOperation(pParse, 1, iDb);  pIndex->tnum = (Pgno)sqlite3VdbeAddOp0(v, OP_Noop);  sqlite3VdbeAddOp3(v, OP_CreateBtree, iDb, iMem, BTREE_BLOBKEY);  assert( pName!=0 || pStart==0 );  if( pStart ){  int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;  if( pName->z[n-1]==';' ) n--;  zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s",  onError==OE_None ? "" : " UNIQUE", n, pName->z);  }else{  zStmt = 0;  }  sqlite3NestedParse(pParse,  "INSERT INTO %Q." LEGACY_SCHEMA_TABLE " VALUES('index',%Q,%Q,#%d,%Q);",  db->aDb[iDb].zDbSName,  pIndex->zName,  pTab->zName,  iMem,  zStmt  );  sqlite3DbFree(db, zStmt);  if( pTblName ){  sqlite3RefillIndex(pParse, pIndex, iMem);  sqlite3ChangeCookie(pParse, iDb);  sqlite3VdbeAddParseSchemaOp(v, iDb,  sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex->zName), 0);  sqlite3VdbeAddOp2(v, OP_Expire, 0, 1);  }  sqlite3VdbeJumpHere(v, (int)pIndex->tnum);  }  }  if( db->init.busy || pTblName==0 ){  pIndex->pNext = pTab->pIndex;  pTab->pIndex = pIndex;  pIndex = 0;  }  else if( IN_RENAME_OBJECT ){  assert( pParse->pNewIndex==0 );  pParse->pNewIndex = pIndex;  pIndex = 0;  } exit_create_index:  if( pIndex ) sqlite3FreeIndex(db, pIndex);  if( pTab ){  Index **ppFrom;  Index *pThis;  for(ppFrom=&pTab->pIndex; (pThis = *ppFrom)!=0; ppFrom=&pThis->pNext){  Index *pNext;  if( pThis->onError!=OE_Replace ) continue;  while( (pNext = pThis->pNext)!=0 && pNext->onError!=OE_Replace ){  *ppFrom = pNext;  pThis->pNext = pNext->pNext;  pNext->pNext = pThis;  ppFrom = &pNext->pNext;  }  break;  }
#ifdef SQLITE_DEBUG
 for(pThis = pTab->pIndex; pThis; pThis=pThis->pNext){  assert( pThis->onError!=OE_Replace   || pThis->pNext==0   || pThis->pNext->onError==OE_Replace );  }
#endif
 }  sqlite3ExprDelete(db, pPIWhere);  sqlite3ExprListDelete(db, pList);  sqlite3SrcListDelete(db, pTblName);  sqlite3DbFree(db, zName); } SQLITE_PRIVATE void sqlite3DefaultRowEst(Index *pIdx){  static const LogEst aVal[] = { 33, 32, 30, 28, 26 };  LogEst *a = pIdx->aiRowLogEst;  LogEst x;  int nCopy = MIN(ArraySize(aVal), pIdx->nKeyCol);  int i;  assert( !pIdx->hasStat1 );  x = pIdx->pTable->nRowLogEst;  assert( 99==sqlite3LogEst(1000) );  if( x<99 ){  pIdx->pTable->nRowLogEst = x = 99;  }  if( pIdx->pPartIdxWhere!=0 ){ x -= 10; assert( 10==sqlite3LogEst(2) ); }  a[0] = x;  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));  for(i=nCopy+1; i<=pIdx->nKeyCol; i++){  a[i] = 23; assert( 23==sqlite3LogEst(5) );  }  assert( 0==sqlite3LogEst(1) );  if( IsUniqueIndex(pIdx) ) a[pIdx->nKeyCol] = 0; } SQLITE_PRIVATE void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){  Index *pIndex;  Vdbe *v;  sqlite3 *db = pParse->db;  int iDb;  assert( pParse->nErr==0 );  if( db->mallocFailed ){  goto exit_drop_index;  }  assert( pName->nSrc==1 );  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){  goto exit_drop_index;  }  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);  if( pIndex==0 ){  if( !ifExists ){  sqlite3ErrorMsg(pParse, "no such index: %S", pName->a);  }else{  sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);  sqlite3ForceNotReadOnly(pParse);  }  pParse->checkSchema = 1;  goto exit_drop_index;  }  if( pIndex->idxType!=SQLITE_IDXTYPE_APPDEF ){  sqlite3ErrorMsg(pParse, "index associated with UNIQUE "  "or PRIMARY KEY constraint cannot be dropped", 0);  goto exit_drop_index;  }  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);
#ifndef SQLITE_OMIT_AUTHORIZATION
 {  int code = SQLITE_DROP_INDEX;  Table *pTab = pIndex->pTable;  const char *zDb = db->aDb[iDb].zDbSName;  const char *zTab = SCHEMA_TABLE(iDb);  if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){  goto exit_drop_index;  }  if( !OMIT_TEMPDB && iDb==1 ) code = SQLITE_DROP_TEMP_INDEX;  if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){  goto exit_drop_index;  }  }
#endif
 v = sqlite3GetVdbe(pParse);  if( v ){  sqlite3BeginWriteOperation(pParse, 1, iDb);  sqlite3NestedParse(pParse,   "DELETE FROM %Q." LEGACY_SCHEMA_TABLE " WHERE name=%Q AND type='index'",   db->aDb[iDb].zDbSName, pIndex->zName  );  sqlite3ClearStatTables(pParse, iDb, "idx", pIndex->zName);  sqlite3ChangeCookie(pParse, iDb);  destroyRootPage(pParse, pIndex->tnum, iDb);  sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0);  } exit_drop_index:  sqlite3SrcListDelete(db, pName); } SQLITE_PRIVATE void *sqlite3ArrayAllocate(  sqlite3 *db,  void *pArray,  int szEntry,  int *pnEntry,  int *pIdx ){  char *z;  sqlite3_int64 n = *pIdx = *pnEntry;  if( (n & (n-1))==0 ){  sqlite3_int64 sz = (n==0) ? 1 : 2*n;  void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);  if( pNew==0 ){  *pIdx = -1;  return pArray;  }  pArray = pNew;  }  z = (char*)pArray;  memset(&z[n * szEntry], 0, szEntry);  ++*pnEntry;  return pArray; } SQLITE_PRIVATE IdList *sqlite3IdListAppend(Parse *pParse, IdList *pList, Token *pToken){  sqlite3 *db = pParse->db;  int i;  if( pList==0 ){  pList = sqlite3DbMallocZero(db, sizeof(IdList) );  if( pList==0 ) return 0;  }  pList->a = sqlite3ArrayAllocate(  db,  pList->a,  sizeof(pList->a[0]),  &pList->nId,  &i  );  if( i<0 ){  sqlite3IdListDelete(db, pList);  return 0;  }  pList->a[i].zName = sqlite3NameFromToken(db, pToken);  if( IN_RENAME_OBJECT && pList->a[i].zName ){  sqlite3RenameTokenMap(pParse, (void*)pList->a[i].zName, pToken);  }  return pList; } SQLITE_PRIVATE void sqlite3IdListDelete(sqlite3 *db, IdList *pList){  int i;  if( pList==0 ) return;  for(i=0; i<pList->nId; i++){  sqlite3DbFree(db, pList->a[i].zName);  }  sqlite3DbFree(db, pList->a);  sqlite3DbFreeNN(db, pList); } SQLITE_PRIVATE int sqlite3IdListIndex(IdList *pList, const char *zName){  int i;  if( pList==0 ) return -1;  for(i=0; i<pList->nId; i++){  if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;  }  return -1; }
#ifndef SQLITE_MAX_SRCLIST
# define SQLITE_MAX_SRCLIST 200
#endif
SQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(  Parse *pParse,  SrcList *pSrc,  int nExtra,  int iStart ){  int i;  assert( iStart>=0 );  assert( nExtra>=1 );  assert( pSrc!=0 );  assert( iStart<=pSrc->nSrc );  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){  SrcList *pNew;  sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;  sqlite3 *db = pParse->db;  if( pSrc->nSrc+nExtra>=SQLITE_MAX_SRCLIST ){  sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d",  SQLITE_MAX_SRCLIST);  return 0;  }  if( nAlloc>SQLITE_MAX_SRCLIST ) nAlloc = SQLITE_MAX_SRCLIST;  pNew = sqlite3DbRealloc(db, pSrc,   sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );  if( pNew==0 ){  assert( db->mallocFailed );  return 0;  }  pSrc = pNew;  pSrc->nAlloc = nAlloc;  }  for(i=pSrc->nSrc-1; i>=iStart; i--){  pSrc->a[i+nExtra] = pSrc->a[i];  }  pSrc->nSrc += nExtra;  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);  for(i=iStart; i<iStart+nExtra; i++){  pSrc->a[i].iCursor = -1;  }  return pSrc; } SQLITE_PRIVATE SrcList *sqlite3SrcListAppend(  Parse *pParse,  SrcList *pList,  Token *pTable,  Token *pDatabase ){  SrcItem *pItem;  sqlite3 *db;  assert( pDatabase==0 || pTable!=0 );  assert( pParse!=0 );  assert( pParse->db!=0 );  db = pParse->db;  if( pList==0 ){  pList = sqlite3DbMallocRawNN(pParse->db, sizeof(SrcList) );  if( pList==0 ) return 0;  pList->nAlloc = 1;  pList->nSrc = 1;  memset(&pList->a[0], 0, sizeof(pList->a[0]));  pList->a[0].iCursor = -1;  }else{  SrcList *pNew = sqlite3SrcListEnlarge(pParse, pList, 1, pList->nSrc);  if( pNew==0 ){  sqlite3SrcListDelete(db, pList);  return 0;  }else{  pList = pNew;  }  }  pItem = &pList->a[pList->nSrc-1];  if( pDatabase && pDatabase->z==0 ){  pDatabase = 0;  }  if( pDatabase ){  pItem->zName = sqlite3NameFromToken(db, pDatabase);  pItem->zDatabase = sqlite3NameFromToken(db, pTable);  }else{  pItem->zName = sqlite3NameFromToken(db, pTable);  pItem->zDatabase = 0;  }  return pList; } SQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){  int i;  SrcItem *pItem;  assert( pList || pParse->db->mallocFailed );  if( ALWAYS(pList) ){  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){  if( pItem->iCursor>=0 ) continue;  pItem->iCursor = pParse->nTab++;  if( pItem->pSelect ){  sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);  }  }  } } SQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){  int i;  SrcItem *pItem;  if( pList==0 ) return;  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){  if( pItem->zDatabase ) sqlite3DbFreeNN(db, pItem->zDatabase);  sqlite3DbFree(db, pItem->zName);  if( pItem->zAlias ) sqlite3DbFreeNN(db, pItem->zAlias);  if( pItem->fg.isIndexedBy ) sqlite3DbFree(db, pItem->u1.zIndexedBy);  if( pItem->fg.isTabFunc ) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);  sqlite3DeleteTable(db, pItem->pTab);  if( pItem->pSelect ) sqlite3SelectDelete(db, pItem->pSelect);  if( pItem->pOn ) sqlite3ExprDelete(db, pItem->pOn);  if( pItem->pUsing ) sqlite3IdListDelete(db, pItem->pUsing);  }  sqlite3DbFreeNN(db, pList); } SQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(  Parse *pParse,  SrcList *p,  Token *pTable,  Token *pDatabase,  Token *pAlias,  Select *pSubquery,  Expr *pOn,  IdList *pUsing ){  SrcItem *pItem;  sqlite3 *db = pParse->db;  if( !p && (pOn || pUsing) ){  sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s",  (pOn ? "ON" : "USING")  );  goto append_from_error;  }  p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);  if( p==0 ){  goto append_from_error;  }  assert( p->nSrc>0 );  pItem = &p->a[p->nSrc-1];  assert( (pTable==0)==(pDatabase==0) );  assert( pItem->zName==0 || pDatabase!=0 );  if( IN_RENAME_OBJECT && pItem->zName ){  Token *pToken = (ALWAYS(pDatabase) && pDatabase->z) ? pDatabase : pTable;  sqlite3RenameTokenMap(pParse, pItem->zName, pToken);  }  assert( pAlias!=0 );  if( pAlias->n ){  pItem->zAlias = sqlite3NameFromToken(db, pAlias);  }  pItem->pSelect = pSubquery;  pItem->pOn = pOn;  pItem->pUsing = pUsing;  return p;  append_from_error:  assert( p==0 );  sqlite3ExprDelete(db, pOn);  sqlite3IdListDelete(db, pUsing);  sqlite3SelectDelete(db, pSubquery);  return 0; } SQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){  assert( pIndexedBy!=0 );  if( p && pIndexedBy->n>0 ){  SrcItem *pItem;  assert( p->nSrc>0 );  pItem = &p->a[p->nSrc-1];  assert( pItem->fg.notIndexed==0 );  assert( pItem->fg.isIndexedBy==0 );  assert( pItem->fg.isTabFunc==0 );  if( pIndexedBy->n==1 && !pIndexedBy->z ){  pItem->fg.notIndexed = 1;  }else{  pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);  pItem->fg.isIndexedBy = 1;  assert( pItem->fg.isCte==0 );  }  } } SQLITE_PRIVATE SrcList *sqlite3SrcListAppendList(Parse *pParse, SrcList *p1, SrcList *p2){  assert( p1 && p1->nSrc==1 );  if( p2 ){  SrcList *pNew = sqlite3SrcListEnlarge(pParse, p1, p2->nSrc, 1);  if( pNew==0 ){  sqlite3SrcListDelete(pParse->db, p2);  }else{  p1 = pNew;  memcpy(&p1->a[1], p2->a, p2->nSrc*sizeof(SrcItem));  sqlite3DbFree(pParse->db, p2);  }  }  return p1; } SQLITE_PRIVATE void sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){  if( p ){  SrcItem *pItem = &p->a[p->nSrc-1];  assert( pItem->fg.notIndexed==0 );  assert( pItem->fg.isIndexedBy==0 );  assert( pItem->fg.isTabFunc==0 );  pItem->u1.pFuncArg = pList;  pItem->fg.isTabFunc = 1;  }else{  sqlite3ExprListDelete(pParse->db, pList);  } } SQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p){  if( p ){  int i;  for(i=p->nSrc-1; i>0; i--){  p->a[i].fg.jointype = p->a[i-1].fg.jointype;  }  p->a[0].fg.jointype = 0;  } } SQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type){  sqlite3 *db;  Vdbe *v;  int i;  assert( pParse!=0 );  db = pParse->db;  assert( db!=0 );  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, "BEGIN", 0, 0) ){  return;  }  v = sqlite3GetVdbe(pParse);  if( !v ) return;  if( type!=TK_DEFERRED ){  for(i=0; i<db->nDb; i++){  int eTxnType;  Btree *pBt = db->aDb[i].pBt;  if( pBt && sqlite3BtreeIsReadonly(pBt) ){  eTxnType = 0;  }else if( type==TK_EXCLUSIVE ){  eTxnType = 2;  }else{  eTxnType = 1;  }  sqlite3VdbeAddOp2(v, OP_Transaction, i, eTxnType);  sqlite3VdbeUsesBtree(v, i);  }  }  sqlite3VdbeAddOp0(v, OP_AutoCommit); } SQLITE_PRIVATE void sqlite3EndTransaction(Parse *pParse, int eType){  Vdbe *v;  int isRollback;  assert( pParse!=0 );  assert( pParse->db!=0 );  assert( eType==TK_COMMIT || eType==TK_END || eType==TK_ROLLBACK );  isRollback = eType==TK_ROLLBACK;  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION,   isRollback ? "ROLLBACK" : "COMMIT", 0, 0) ){  return;  }  v = sqlite3GetVdbe(pParse);  if( v ){  sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, isRollback);  } } SQLITE_PRIVATE void sqlite3Savepoint(Parse *pParse, int op, Token *pName){  char *zName = sqlite3NameFromToken(pParse->db, pName);  if( zName ){  Vdbe *v = sqlite3GetVdbe(pParse);
#ifndef SQLITE_OMIT_AUTHORIZATION
 static const char * const az[] = { "BEGIN", "RELEASE", "ROLLBACK" };  assert( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 );
#endif
 if( !v || sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0) ){  sqlite3DbFree(pParse->db, zName);  return;  }  sqlite3VdbeAddOp4(v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC);  } } SQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *pParse){  sqlite3 *db = pParse->db;  if( db->aDb[1].pBt==0 && !pParse->explain ){  int rc;  Btree *pBt;  static const int flags =  SQLITE_OPEN_READWRITE |  SQLITE_OPEN_CREATE |  SQLITE_OPEN_EXCLUSIVE |  SQLITE_OPEN_DELETEONCLOSE |  SQLITE_OPEN_TEMP_DB;  rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pBt, 0, flags);  if( rc!=SQLITE_OK ){  sqlite3ErrorMsg(pParse, "unable to open a temporary database "  "file for storing temporary tables");  pParse->rc = rc;  return 1;  }  db->aDb[1].pBt = pBt;  assert( db->aDb[1].pSchema );  if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, 0, 0) ){  sqlite3OomFault(db);  return 1;  }  }  return 0; } static void sqlite3CodeVerifySchemaAtToplevel(Parse *pToplevel, int iDb){  assert( iDb>=0 && iDb<pToplevel->db->nDb );  assert( pToplevel->db->aDb[iDb].pBt!=0 || iDb==1 );  assert( iDb<SQLITE_MAX_DB );  assert( sqlite3SchemaMutexHeld(pToplevel->db, iDb, 0) );  if( DbMaskTest(pToplevel->cookieMask, iDb)==0 ){  DbMaskSet(pToplevel->cookieMask, iDb);  if( !OMIT_TEMPDB && iDb==1 ){  sqlite3OpenTempDatabase(pToplevel);  }  } } SQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse *pParse, int iDb){  sqlite3CodeVerifySchemaAtToplevel(sqlite3ParseToplevel(pParse), iDb); } SQLITE_PRIVATE void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){  sqlite3 *db = pParse->db;  int i;  for(i=0; i<db->nDb; i++){  Db *pDb = &db->aDb[i];  if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zDbSName)) ){  sqlite3CodeVerifySchema(pParse, i);  }  } } SQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){  Parse *pToplevel = sqlite3ParseToplevel(pParse);  sqlite3CodeVerifySchemaAtToplevel(pToplevel, iDb);  DbMaskSet(pToplevel->writeMask, iDb);  pToplevel->isMultiWrite |= setStatement; } SQLITE_PRIVATE void sqlite3MultiWrite(Parse *pParse){  Parse *pToplevel = sqlite3ParseToplevel(pParse);  pToplevel->isMultiWrite = 1; } SQLITE_PRIVATE void sqlite3MayAbort(Parse *pParse){  Parse *pToplevel = sqlite3ParseToplevel(pParse);  pToplevel->mayAbort = 1; } SQLITE_PRIVATE void sqlite3HaltConstraint(  Parse *pParse,  int errCode,  int onError,  char *p4,  i8 p4type,  u8 p5Errmsg ){  Vdbe *v;  assert( pParse->pVdbe!=0 );  v = sqlite3GetVdbe(pParse);  assert( (errCode&0xff)==SQLITE_CONSTRAINT || pParse->nested );  if( onError==OE_Abort ){  sqlite3MayAbort(pParse);  }  sqlite3VdbeAddOp4(v, OP_Halt, errCode, onError, 0, p4, p4type);  sqlite3VdbeChangeP5(v, p5Errmsg); } SQLITE_PRIVATE void sqlite3UniqueConstraint(  Parse *pParse,  int onError,  Index *pIdx ){  char *zErr;  int j;  StrAccum errMsg;  Table *pTab = pIdx->pTable;  sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0,  pParse->db->aLimit[SQLITE_LIMIT_LENGTH]);  if( pIdx->aColExpr ){  sqlite3_str_appendf(&errMsg, "index '%q'", pIdx->zName);  }else{  for(j=0; j<pIdx->nKeyCol; j++){  char *zCol;  assert( pIdx->aiColumn[j]>=0 );  zCol = pTab->aCol[pIdx->aiColumn[j]].zCnName;  if( j ) sqlite3_str_append(&errMsg, ", ", 2);  sqlite3_str_appendall(&errMsg, pTab->zName);  sqlite3_str_append(&errMsg, ".", 1);  sqlite3_str_appendall(&errMsg, zCol);  }  }  zErr = sqlite3StrAccumFinish(&errMsg);  sqlite3HaltConstraint(pParse,  IsPrimaryKeyIndex(pIdx) ? SQLITE_CONSTRAINT_PRIMARYKEY  : SQLITE_CONSTRAINT_UNIQUE,  onError, zErr, P4_DYNAMIC, P5_ConstraintUnique); } SQLITE_PRIVATE void sqlite3RowidConstraint(  Parse *pParse,  int onError,  Table *pTab ){  char *zMsg;  int rc;  if( pTab->iPKey>=0 ){  zMsg = sqlite3MPrintf(pParse->db, "%s.%s", pTab->zName,  pTab->aCol[pTab->iPKey].zCnName);  rc = SQLITE_CONSTRAINT_PRIMARYKEY;  }else{  zMsg = sqlite3MPrintf(pParse->db, "%s.rowid", pTab->zName);  rc = SQLITE_CONSTRAINT_ROWID;  }  sqlite3HaltConstraint(pParse, rc, onError, zMsg, P4_DYNAMIC,  P5_ConstraintUnique); }
#ifndef SQLITE_OMIT_REINDEX
static int collationMatch(const char *zColl, Index *pIndex){  int i;  assert( zColl!=0 );  for(i=0; i<pIndex->nColumn; i++){  const char *z = pIndex->azColl[i];  assert( z!=0 || pIndex->aiColumn[i]<0 );  if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){  return 1;  }  }  return 0; }
#endif
#ifndef SQLITE_OMIT_REINDEX
static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){  if( !IsVirtual(pTab) ){  Index *pIndex;  for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){  if( zColl==0 || collationMatch(zColl, pIndex) ){  int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  sqlite3BeginWriteOperation(pParse, 0, iDb);  sqlite3RefillIndex(pParse, pIndex, -1);  }  }  } }
#endif
#ifndef SQLITE_OMIT_REINDEX
static void reindexDatabases(Parse *pParse, char const *zColl){  Db *pDb;  int iDb;  sqlite3 *db = pParse->db;  HashElem *k;  Table *pTab;  assert( sqlite3BtreeHoldsAllMutexes(db) );  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){  assert( pDb!=0 );  for(k=sqliteHashFirst(&pDb->pSchema->tblHash); k; k=sqliteHashNext(k)){  pTab = (Table*)sqliteHashData(k);  reindexTable(pParse, pTab, zColl);  }  } }
#endif
#ifndef SQLITE_OMIT_REINDEX
SQLITE_PRIVATE void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){  CollSeq *pColl;  char *z;  const char *zDb;  Table *pTab;  Index *pIndex;  int iDb;  sqlite3 *db = pParse->db;  Token *pObjName;  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){  return;  }  if( pName1==0 ){  reindexDatabases(pParse, 0);  return;  }else if( NEVER(pName2==0) || pName2->z==0 ){  char *zColl;  assert( pName1->z );  zColl = sqlite3NameFromToken(pParse->db, pName1);  if( !zColl ) return;  pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);  if( pColl ){  reindexDatabases(pParse, zColl);  sqlite3DbFree(db, zColl);  return;  }  sqlite3DbFree(db, zColl);  }  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);  if( iDb<0 ) return;  z = sqlite3NameFromToken(db, pObjName);  if( z==0 ) return;  zDb = db->aDb[iDb].zDbSName;  pTab = sqlite3FindTable(db, z, zDb);  if( pTab ){  reindexTable(pParse, pTab, 0);  sqlite3DbFree(db, z);  return;  }  pIndex = sqlite3FindIndex(db, z, zDb);  sqlite3DbFree(db, z);  if( pIndex ){  sqlite3BeginWriteOperation(pParse, 0, iDb);  sqlite3RefillIndex(pParse, pIndex, -1);  return;  }  sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed"); }
#endif
SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){  int i;  int nCol = pIdx->nColumn;  int nKey = pIdx->nKeyCol;  KeyInfo *pKey;  if( pParse->nErr ) return 0;  if( pIdx->uniqNotNull ){  pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol-nKey);  }else{  pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);  }  if( pKey ){  assert( sqlite3KeyInfoIsWriteable(pKey) );  for(i=0; i<nCol; i++){  const char *zColl = pIdx->azColl[i];  pKey->aColl[i] = zColl==sqlite3StrBINARY ? 0 :  sqlite3LocateCollSeq(pParse, zColl);  pKey->aSortFlags[i] = pIdx->aSortOrder[i];  assert( 0==(pKey->aSortFlags[i] & KEYINFO_ORDER_BIGNULL) );  }  if( pParse->nErr ){  assert( pParse->rc==SQLITE_ERROR_MISSING_COLLSEQ );  if( pIdx->bNoQuery==0 ){  pIdx->bNoQuery = 1;  pParse->rc = SQLITE_ERROR_RETRY;  }  sqlite3KeyInfoUnref(pKey);  pKey = 0;  }  }  return pKey; }
#ifndef SQLITE_OMIT_CTE
SQLITE_PRIVATE Cte *sqlite3CteNew(  Parse *pParse,  Token *pName,  ExprList *pArglist,  Select *pQuery,  u8 eM10d ){  Cte *pNew;  sqlite3 *db = pParse->db;  pNew = sqlite3DbMallocZero(db, sizeof(*pNew));  assert( pNew!=0 || db->mallocFailed );  if( db->mallocFailed ){  sqlite3ExprListDelete(db, pArglist);  sqlite3SelectDelete(db, pQuery);  }else{  pNew->pSelect = pQuery;  pNew->pCols = pArglist;  pNew->zName = sqlite3NameFromToken(pParse->db, pName);  pNew->eM10d = eM10d;  }  return pNew; } static void cteClear(sqlite3 *db, Cte *pCte){  assert( pCte!=0 );  sqlite3ExprListDelete(db, pCte->pCols);  sqlite3SelectDelete(db, pCte->pSelect);  sqlite3DbFree(db, pCte->zName); } SQLITE_PRIVATE void sqlite3CteDelete(sqlite3 *db, Cte *pCte){  assert( pCte!=0 );  cteClear(db, pCte);  sqlite3DbFree(db, pCte); } SQLITE_PRIVATE With *sqlite3WithAdd(  Parse *pParse,  With *pWith,  Cte *pCte ){  sqlite3 *db = pParse->db;  With *pNew;  char *zName;  if( pCte==0 ){  return pWith;  }  zName = pCte->zName;  if( zName && pWith ){  int i;  for(i=0; i<pWith->nCte; i++){  if( sqlite3StrICmp(zName, pWith->a[i].zName)==0 ){  sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);  }  }  }  if( pWith ){  sqlite3_int64 nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);  pNew = sqlite3DbRealloc(db, pWith, nByte);  }else{  pNew = sqlite3DbMallocZero(db, sizeof(*pWith));  }  assert( (pNew!=0 && zName!=0) || db->mallocFailed );  if( db->mallocFailed ){  sqlite3CteDelete(db, pCte);  pNew = pWith;  }else{  pNew->a[pNew->nCte++] = *pCte;  sqlite3DbFree(db, pCte);  }  return pNew; } SQLITE_PRIVATE void sqlite3WithDelete(sqlite3 *db, With *pWith){  if( pWith ){  int i;  for(i=0; i<pWith->nCte; i++){  cteClear(db, &pWith->a[i]);  }  sqlite3DbFree(db, pWith);  } }
#endif
static void callCollNeeded(sqlite3 *db, int enc, const char *zName){  assert( !db->xCollNeeded || !db->xCollNeeded16 );  if( db->xCollNeeded ){  char *zExternal = sqlite3DbStrDup(db, zName);  if( !zExternal ) return;  db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);  sqlite3DbFree(db, zExternal);  }
#ifndef SQLITE_OMIT_UTF16
 if( db->xCollNeeded16 ){  char const *zExternal;  sqlite3_value *pTmp = sqlite3ValueNew(db);  sqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC);  zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE);  if( zExternal ){  db->xCollNeeded16(db->pCollNeededArg, db, (int)ENC(db), zExternal);  }  sqlite3ValueFree(pTmp);  }
#endif
} static int synthCollSeq(sqlite3 *db, CollSeq *pColl){  CollSeq *pColl2;  char *z = pColl->zName;  int i;  static const u8 aEnc[] = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 };  for(i=0; i<3; i++){  pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);  if( pColl2->xCmp!=0 ){  memcpy(pColl, pColl2, sizeof(CollSeq));  pColl->xDel = 0;  return SQLITE_OK;  }  }  return SQLITE_ERROR; } SQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){  if( pColl && pColl->xCmp==0 ){  const char *zName = pColl->zName;  sqlite3 *db = pParse->db;  CollSeq *p = sqlite3GetCollSeq(pParse, ENC(db), pColl, zName);  if( !p ){  return SQLITE_ERROR;  }  assert( p==pColl );  }  return SQLITE_OK; } static CollSeq *findCollSeqEntry(  sqlite3 *db,  const char *zName,  int create ){  CollSeq *pColl;  pColl = sqlite3HashFind(&db->aCollSeq, zName);  if( 0==pColl && create ){  int nName = sqlite3Strlen30(zName) + 1;  pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName);  if( pColl ){  CollSeq *pDel = 0;  pColl[0].zName = (char*)&pColl[3];  pColl[0].enc = SQLITE_UTF8;  pColl[1].zName = (char*)&pColl[3];  pColl[1].enc = SQLITE_UTF16LE;  pColl[2].zName = (char*)&pColl[3];  pColl[2].enc = SQLITE_UTF16BE;  memcpy(pColl[0].zName, zName, nName);  pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, pColl);  assert( pDel==0 || pDel==pColl );  if( pDel!=0 ){  sqlite3OomFault(db);  sqlite3DbFree(db, pDel);  pColl = 0;  }  }  }  return pColl; } SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(  sqlite3 *db,  u8 enc,  const char *zName,  int create ){  CollSeq *pColl;  assert( SQLITE_UTF8==1 && SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );  assert( enc>=SQLITE_UTF8 && enc<=SQLITE_UTF16BE );  if( zName ){  pColl = findCollSeqEntry(db, zName, create);  if( pColl ) pColl += enc-1;  }else{  pColl = db->pDfltColl;  }  return pColl; } SQLITE_PRIVATE void sqlite3SetTextEncoding(sqlite3 *db, u8 enc){  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );  db->enc = enc;  db->pDfltColl = sqlite3FindCollSeq(db, enc, sqlite3StrBINARY, 0); } SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(  Parse *pParse,  u8 enc,  CollSeq *pColl,  const char *zName ){  CollSeq *p;  sqlite3 *db = pParse->db;  p = pColl;  if( !p ){  p = sqlite3FindCollSeq(db, enc, zName, 0);  }  if( !p || !p->xCmp ){  callCollNeeded(db, enc, zName);  p = sqlite3FindCollSeq(db, enc, zName, 0);  }  if( p && !p->xCmp && synthCollSeq(db, p) ){  p = 0;  }  assert( !p || p->xCmp );  if( p==0 ){  sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);  pParse->rc = SQLITE_ERROR_MISSING_COLLSEQ;  }  return p; } SQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName){  sqlite3 *db = pParse->db;  u8 enc = ENC(db);  u8 initbusy = db->init.busy;  CollSeq *pColl;  pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);  if( !initbusy && (!pColl || !pColl->xCmp) ){  pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName);  }  return pColl; }
#define FUNC_PERFECT_MATCH 6
static int matchQuality(  FuncDef *p,  int nArg,  u8 enc ){  int match;  assert( p->nArg>=-1 );  if( p->nArg!=nArg ){  if( nArg==(-2) ) return (p->xSFunc==0) ? 0 : FUNC_PERFECT_MATCH;  if( p->nArg>=0 ) return 0;  }  if( p->nArg==nArg ){  match = 4;  }else{  match = 1;  }  if( enc==(p->funcFlags & SQLITE_FUNC_ENCMASK) ){  match += 2;  }else if( (enc & p->funcFlags & 2)!=0 ){  match += 1;  }  return match; } SQLITE_PRIVATE FuncDef *sqlite3FunctionSearch(  int h,  const char *zFunc ){  FuncDef *p;  for(p=sqlite3BuiltinFunctions.a[h]; p; p=p->u.pHash){  assert( p->funcFlags & SQLITE_FUNC_BUILTIN );  if( sqlite3StrICmp(p->zName, zFunc)==0 ){  return p;  }  }  return 0; } SQLITE_PRIVATE void sqlite3InsertBuiltinFuncs(  FuncDef *aDef,  int nDef ){  int i;  for(i=0; i<nDef; i++){  FuncDef *pOther;  const char *zName = aDef[i].zName;  int nName = sqlite3Strlen30(zName);  int h = SQLITE_FUNC_HASH(zName[0], nName);  assert( zName[0]>='a' && zName[0]<='z' );  assert( aDef[i].funcFlags & SQLITE_FUNC_BUILTIN );  pOther = sqlite3FunctionSearch(h, zName);  if( pOther ){  assert( pOther!=&aDef[i] && pOther->pNext!=&aDef[i] );  aDef[i].pNext = pOther->pNext;  pOther->pNext = &aDef[i];  }else{  aDef[i].pNext = 0;  aDef[i].u.pHash = sqlite3BuiltinFunctions.a[h];  sqlite3BuiltinFunctions.a[h] = &aDef[i];  }  } } SQLITE_PRIVATE FuncDef *sqlite3FindFunction(  sqlite3 *db,  const char *zName,  int nArg,  u8 enc,  u8 createFlag ){  FuncDef *p;  FuncDef *pBest = 0;  int bestScore = 0;  int h;  int nName;  assert( nArg>=(-2) );  assert( nArg>=(-1) || createFlag==0 );  nName = sqlite3Strlen30(zName);  p = (FuncDef*)sqlite3HashFind(&db->aFunc, zName);  while( p ){  int score = matchQuality(p, nArg, enc);  if( score>bestScore ){  pBest = p;  bestScore = score;  }  p = p->pNext;  }  if( !createFlag && (pBest==0 || (db->mDbFlags & DBFLAG_PreferBuiltin)!=0) ){  bestScore = 0;  h = SQLITE_FUNC_HASH(sqlite3UpperToLower[(u8)zName[0]], nName);  p = sqlite3FunctionSearch(h, zName);  while( p ){  int score = matchQuality(p, nArg, enc);  if( score>bestScore ){  pBest = p;  bestScore = score;  }  p = p->pNext;  }  }  if( createFlag && bestScore<FUNC_PERFECT_MATCH &&  (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){  FuncDef *pOther;  u8 *z;  pBest->zName = (const char*)&pBest[1];  pBest->nArg = (u16)nArg;  pBest->funcFlags = enc;  memcpy((char*)&pBest[1], zName, nName+1);  for(z=(u8*)pBest->zName; *z; z++) *z = sqlite3UpperToLower[*z];  pOther = (FuncDef*)sqlite3HashInsert(&db->aFunc, pBest->zName, pBest);  if( pOther==pBest ){  sqlite3DbFree(db, pBest);  sqlite3OomFault(db);  return 0;  }else{  pBest->pNext = pOther;  }  }  if( pBest && (pBest->xSFunc || createFlag) ){  return pBest;  }  return 0; } SQLITE_PRIVATE void sqlite3SchemaClear(void *p){  Hash temp1;  Hash temp2;  HashElem *pElem;  Schema *pSchema = (Schema *)p;  temp1 = pSchema->tblHash;  temp2 = pSchema->trigHash;  sqlite3HashInit(&pSchema->trigHash);  sqlite3HashClear(&pSchema->idxHash);  for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){  sqlite3DeleteTrigger(0, (Trigger*)sqliteHashData(pElem));  }  sqlite3HashClear(&temp2);  sqlite3HashInit(&pSchema->tblHash);  for(pElem=sqliteHashFirst(&temp1); pElem; pElem=sqliteHashNext(pElem)){  Table *pTab = sqliteHashData(pElem);  sqlite3DeleteTable(0, pTab);  }  sqlite3HashClear(&temp1);  sqlite3HashClear(&pSchema->fkeyHash);  pSchema->pSeqTab = 0;  if( pSchema->schemaFlags & DB_SchemaLoaded ){  pSchema->iGeneration++;  }  pSchema->schemaFlags &= ~(DB_SchemaLoaded|DB_ResetWanted); } SQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){  Schema * p;  if( pBt ){  p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaClear);  }else{  p = (Schema *)sqlite3DbMallocZero(0, sizeof(Schema));  }  if( !p ){  sqlite3OomFault(db);  }else if ( 0==p->file_format ){  sqlite3HashInit(&p->tblHash);  sqlite3HashInit(&p->idxHash);  sqlite3HashInit(&p->trigHash);  sqlite3HashInit(&p->fkeyHash);  p->enc = SQLITE_UTF8;  }  return p; } SQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){  SrcItem *pItem = pSrc->a;  Table *pTab;  assert( pItem && pSrc->nSrc>=1 );  pTab = sqlite3LocateTableItem(pParse, 0, pItem);  sqlite3DeleteTable(pParse->db, pItem->pTab);  pItem->pTab = pTab;  if( pTab ){  pTab->nTabRef++;  if( pItem->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pItem) ){  pTab = 0;  }  }  return pTab; } static int tabIsReadOnly(Parse *pParse, Table *pTab){  sqlite3 *db;  if( IsVirtual(pTab) ){  return sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0;  }  if( (pTab->tabFlags & (TF_Readonly|TF_Shadow))==0 ) return 0;  db = pParse->db;  if( (pTab->tabFlags & TF_Readonly)!=0 ){  return sqlite3WritableSchema(db)==0 && pParse->nested==0;  }  assert( pTab->tabFlags & TF_Shadow );  return sqlite3ReadOnlyShadowTables(db); } SQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){  if( tabIsReadOnly(pParse, pTab) ){  sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);  return 1;  }
#ifndef SQLITE_OMIT_VIEW
 if( !viewOk && IsView(pTab) ){  sqlite3ErrorMsg(pParse,"cannot modify %s because it is a view",pTab->zName);  return 1;  }
#endif
 return 0; }
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
SQLITE_PRIVATE void sqlite3MaterializeView(  Parse *pParse,  Table *pView,  Expr *pWhere,  ExprList *pOrderBy,  Expr *pLimit,  int iCur ){  SelectDest dest;  Select *pSel;  SrcList *pFrom;  sqlite3 *db = pParse->db;  int iDb = sqlite3SchemaToIndex(db, pView->pSchema);  pWhere = sqlite3ExprDup(db, pWhere, 0);  pFrom = sqlite3SrcListAppend(pParse, 0, 0, 0);  if( pFrom ){  assert( pFrom->nSrc==1 );  pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName);  pFrom->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);  assert( pFrom->a[0].pOn==0 );  assert( pFrom->a[0].pUsing==0 );  }  pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, pOrderBy,  SF_IncludeHidden, pLimit);  sqlite3SelectDestInit(&dest, SRT_EphemTab, iCur);  sqlite3Select(pParse, pSel, &dest);  sqlite3SelectDelete(db, pSel); }
#endif
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)
SQLITE_PRIVATE Expr *sqlite3LimitWhere(  Parse *pParse,  SrcList *pSrc,  Expr *pWhere,  ExprList *pOrderBy,  Expr *pLimit,  char *zStmtType ){  sqlite3 *db = pParse->db;  Expr *pLhs = NULL;  Expr *pInClause = NULL;  ExprList *pEList = NULL;  SrcList *pSelectSrc = NULL;  Select *pSelect = NULL;  Table *pTab;  if( pOrderBy && pLimit==0 ) {  sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on %s", zStmtType);  sqlite3ExprDelete(pParse->db, pWhere);  sqlite3ExprListDelete(pParse->db, pOrderBy);  return 0;  }  if( pLimit == 0 ) {  return pWhere;  }  pTab = pSrc->a[0].pTab;  if( HasRowid(pTab) ){  pLhs = sqlite3PExpr(pParse, TK_ROW, 0, 0);  pEList = sqlite3ExprListAppend(  pParse, 0, sqlite3PExpr(pParse, TK_ROW, 0, 0)  );  }else{  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  if( pPk->nKeyCol==1 ){  const char *zName = pTab->aCol[pPk->aiColumn[0]].zCnName;  pLhs = sqlite3Expr(db, TK_ID, zName);  pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ID, zName));  }else{  int i;  for(i=0; i<pPk->nKeyCol; i++){  Expr *p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zCnName);  pEList = sqlite3ExprListAppend(pParse, pEList, p);  }  pLhs = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);  if( pLhs ){  pLhs->x.pList = sqlite3ExprListDup(db, pEList, 0);  }  }  }  pSrc->a[0].pTab = 0;  pSelectSrc = sqlite3SrcListDup(db, pSrc, 0);  pSrc->a[0].pTab = pTab;  if( pSrc->a[0].fg.isIndexedBy ){  assert( pSrc->a[0].fg.isCte==0 );  pSrc->a[0].u2.pIBIndex = 0;  pSrc->a[0].fg.isIndexedBy = 0;  sqlite3DbFree(db, pSrc->a[0].u1.zIndexedBy);  }else if( pSrc->a[0].fg.isCte ){  pSrc->a[0].u2.pCteUse->nUse++;  }  pSelect = sqlite3SelectNew(pParse, pEList, pSelectSrc, pWhere, 0 ,0,  pOrderBy,0,pLimit  );  pInClause = sqlite3PExpr(pParse, TK_IN, pLhs, 0);  sqlite3PExprAddSelect(pParse, pInClause, pSelect);  return pInClause; }
#endif
SQLITE_PRIVATE void sqlite3DeleteFrom(  Parse *pParse,  SrcList *pTabList,  Expr *pWhere,  ExprList *pOrderBy,  Expr *pLimit ){  Vdbe *v;  Table *pTab;  int i;  WhereInfo *pWInfo;  Index *pIdx;  int iTabCur;  int iDataCur = 0;  int iIdxCur = 0;  int nIdx;  sqlite3 *db;  AuthContext sContext;  NameContext sNC;  int iDb;  int memCnt = 0;  int rcauth;  int eOnePass;  int aiCurOnePass[2];  u8 *aToOpen = 0;  Index *pPk;  int iPk = 0;  i16 nPk = 1;  int iKey;  i16 nKey;  int iEphCur = 0;  int iRowSet = 0;  int addrBypass = 0;  int addrLoop = 0;  int addrEphOpen = 0;  int bComplex;
#ifndef SQLITE_OMIT_TRIGGER
 int isView;  Trigger *pTrigger;
#endif
 memset(&sContext, 0, sizeof(sContext));  db = pParse->db;  if( pParse->nErr || db->mallocFailed ){  goto delete_from_cleanup;  }  assert( pTabList->nSrc==1 );  pTab = sqlite3SrcListLookup(pParse, pTabList);  if( pTab==0 ) goto delete_from_cleanup;
#ifndef SQLITE_OMIT_TRIGGER
 pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);  isView = IsView(pTab);
#else
# define pTrigger 0
# define isView 0
#endif
 bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( !isView ){  pWhere = sqlite3LimitWhere(  pParse, pTabList, pWhere, pOrderBy, pLimit, "DELETE"  );  pOrderBy = 0;  pLimit = 0;  }
#endif
 if( sqlite3ViewGetColumnNames(pParse, pTab) ){  goto delete_from_cleanup;  }  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){  goto delete_from_cleanup;  }  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iDb<db->nDb );  rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0,  db->aDb[iDb].zDbSName);  assert( rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE );  if( rcauth==SQLITE_DENY ){  goto delete_from_cleanup;  }  assert(!isView || pTrigger);  assert( pTabList->nSrc==1 );  iTabCur = pTabList->a[0].iCursor = pParse->nTab++;  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){  pParse->nTab++;  }  if( isView ){  sqlite3AuthContextPush(pParse, &sContext, pTab->zName);  }  v = sqlite3GetVdbe(pParse);  if( v==0 ){  goto delete_from_cleanup;  }  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);  sqlite3BeginWriteOperation(pParse, bComplex, iDb);
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
 if( isView ){  sqlite3MaterializeView(pParse, pTab,  pWhere, pOrderBy, pLimit, iTabCur  );  iDataCur = iIdxCur = iTabCur;  pOrderBy = 0;  pLimit = 0;  }
#endif
 memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  sNC.pSrcList = pTabList;  if( sqlite3ResolveExprNames(&sNC, pWhere) ){  goto delete_from_cleanup;  }  if( (db->flags & SQLITE_CountRows)!=0   && !pParse->nested   && !pParse->pTriggerTab   && !pParse->bReturning  ){  memCnt = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 0, memCnt);  }
#ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION
 if( rcauth==SQLITE_OK   && pWhere==0   && !bComplex   && !IsVirtual(pTab)
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
  && db->xPreUpdateCallback==0
#endif
 ){  assert( !isView );  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);  if( HasRowid(pTab) ){  sqlite3VdbeAddOp4(v, OP_Clear, pTab->tnum, iDb, memCnt ? memCnt : -1,  pTab->zName, P4_STATIC);  }  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  assert( pIdx->pSchema==pTab->pSchema );  sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);  if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){  sqlite3VdbeChangeP3(v, -1, memCnt ? memCnt : -1);  }  }  }else
#endif
 {  u16 wcf = WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK;  if( sNC.ncFlags & NC_VarSelect ) bComplex = 1;  wcf |= (bComplex ? 0 : WHERE_ONEPASS_MULTIROW);  if( HasRowid(pTab) ){  pPk = 0;  nPk = 1;  iRowSet = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Null, 0, iRowSet);  }else{  pPk = sqlite3PrimaryKeyIndex(pTab);  assert( pPk!=0 );  nPk = pPk->nKeyCol;  iPk = pParse->nMem+1;  pParse->nMem += nPk;  iEphCur = pParse->nTab++;  addrEphOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEphCur, nPk);  sqlite3VdbeSetP4KeyInfo(pParse, pPk);  }  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, wcf, iTabCur+1);  if( pWInfo==0 ) goto delete_from_cleanup;  eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);  assert( IsVirtual(pTab)==0 || eOnePass!=ONEPASS_MULTI );  assert( IsVirtual(pTab) || bComplex || eOnePass!=ONEPASS_OFF );  if( eOnePass!=ONEPASS_SINGLE ) sqlite3MultiWrite(pParse);  if( sqlite3WhereUsesDeferredSeek(pWInfo) ){  sqlite3VdbeAddOp1(v, OP_FinishSeek, iTabCur);  }  if( memCnt ){  sqlite3VdbeAddOp2(v, OP_AddImm, memCnt, 1);  }  if( pPk ){  for(i=0; i<nPk; i++){  assert( pPk->aiColumn[i]>=0 );  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,  pPk->aiColumn[i], iPk+i);  }  iKey = iPk;  }else{  iKey = ++pParse->nMem;  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);  }  if( eOnePass!=ONEPASS_OFF ){  nKey = nPk;  aToOpen = sqlite3DbMallocRawNN(db, nIdx+2);  if( aToOpen==0 ){  sqlite3WhereEnd(pWInfo);  goto delete_from_cleanup;  }  memset(aToOpen, 1, nIdx+1);  aToOpen[nIdx+1] = 0;  if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;  if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;  if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);  addrBypass = sqlite3VdbeMakeLabel(pParse);  }else{  if( pPk ){  iKey = ++pParse->nMem;  nKey = 0;  sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, iKey,  sqlite3IndexAffinityStr(pParse->db, pPk), nPk);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEphCur, iKey, iPk, nPk);  }else{  nKey = 1;  sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);  }  sqlite3WhereEnd(pWInfo);  }  if( !isView ){  int iAddrOnce = 0;  if( eOnePass==ONEPASS_MULTI ){  iAddrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  }  testcase( IsVirtual(pTab) );  sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, OPFLAG_FORDELETE,   iTabCur, aToOpen, &iDataCur, &iIdxCur);  assert( pPk || IsVirtual(pTab) || iDataCur==iTabCur );  assert( pPk || IsVirtual(pTab) || iIdxCur==iDataCur+1 );  if( eOnePass==ONEPASS_MULTI ){  sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);  }  }  if( eOnePass!=ONEPASS_OFF ){  assert( nKey==nPk );  if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){  assert( pPk!=0 || IsView(pTab) );  sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, addrBypass, iKey, nKey);  VdbeCoverage(v);  }  }else if( pPk ){  addrLoop = sqlite3VdbeAddOp1(v, OP_Rewind, iEphCur); VdbeCoverage(v);  if( IsVirtual(pTab) ){  sqlite3VdbeAddOp3(v, OP_Column, iEphCur, 0, iKey);  }else{  sqlite3VdbeAddOp2(v, OP_RowData, iEphCur, iKey);  }  assert( nKey==0 );  }else{  addrLoop = sqlite3VdbeAddOp3(v, OP_RowSetRead, iRowSet, 0, iKey);  VdbeCoverage(v);  assert( nKey==1 );  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);  sqlite3VtabMakeWritable(pParse, pTab);  assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );  sqlite3MayAbort(pParse);  if( eOnePass==ONEPASS_SINGLE ){  sqlite3VdbeAddOp1(v, OP_Close, iTabCur);  if( sqlite3IsToplevel(pParse) ){  pParse->isMultiWrite = 0;  }  }  sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iKey, pVTab, P4_VTAB);  sqlite3VdbeChangeP5(v, OE_Abort);  }else
#endif
 {  int count = (pParse->nested==0);  sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,  iKey, nKey, count, OE_Default, eOnePass, aiCurOnePass[1]);  }  if( eOnePass!=ONEPASS_OFF ){  sqlite3VdbeResolveLabel(v, addrBypass);  sqlite3WhereEnd(pWInfo);  }else if( pPk ){  sqlite3VdbeAddOp2(v, OP_Next, iEphCur, addrLoop+1); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addrLoop);  }else{  sqlite3VdbeGoto(v, addrLoop);  sqlite3VdbeJumpHere(v, addrLoop);  }  }  if( pParse->nested==0 && pParse->pTriggerTab==0 ){  sqlite3AutoincrementEnd(pParse);  }  if( memCnt ){  sqlite3VdbeAddOp2(v, OP_ChngCntRow, memCnt, 1);  sqlite3VdbeSetNumCols(v, 1);  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows deleted", SQLITE_STATIC);  } delete_from_cleanup:  sqlite3AuthContextPop(&sContext);  sqlite3SrcListDelete(db, pTabList);  sqlite3ExprDelete(db, pWhere);
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)
 sqlite3ExprListDelete(db, pOrderBy);  sqlite3ExprDelete(db, pLimit);
#endif
 sqlite3DbFree(db, aToOpen);  return; }
#ifdef isView
 #undef isView
#endif
#ifdef pTrigger
 #undef pTrigger
#endif
SQLITE_PRIVATE void sqlite3GenerateRowDelete(  Parse *pParse,  Table *pTab,  Trigger *pTrigger,  int iDataCur,  int iIdxCur,  int iPk,  i16 nPk,  u8 count,  u8 onconf,  u8 eMode,  int iIdxNoSeek ){  Vdbe *v = pParse->pVdbe;  int iOld = 0;  int iLabel;  u8 opSeek;  assert( v );  VdbeModuleComment((v, "BEGIN: GenRowDel(%d,%d,%d,%d)",   iDataCur, iIdxCur, iPk, (int)nPk));  iLabel = sqlite3VdbeMakeLabel(pParse);  opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;  if( eMode==ONEPASS_OFF ){  sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);  VdbeCoverageIf(v, opSeek==OP_NotExists);  VdbeCoverageIf(v, opSeek==OP_NotFound);  }  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){  u32 mask;  int iCol;  int addrStart;  mask = sqlite3TriggerColmask(  pParse, pTrigger, 0, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onconf  );  mask |= sqlite3FkOldmask(pParse, pTab);  iOld = pParse->nMem+1;  pParse->nMem += (1 + pTab->nCol);  sqlite3VdbeAddOp2(v, OP_Copy, iPk, iOld);  for(iCol=0; iCol<pTab->nCol; iCol++){  testcase( mask!=0xffffffff && iCol==31 );  testcase( mask!=0xffffffff && iCol==32 );  if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){  int kk = sqlite3TableColumnToStorage(pTab, iCol);  sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);  }  }  addrStart = sqlite3VdbeCurrentAddr(v);  sqlite3CodeRowTrigger(pParse, pTrigger,  TK_DELETE, 0, TRIGGER_BEFORE, pTab, iOld, onconf, iLabel  );  if( addrStart<sqlite3VdbeCurrentAddr(v) ){  sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);  VdbeCoverageIf(v, opSeek==OP_NotExists);  VdbeCoverageIf(v, opSeek==OP_NotFound);  testcase( iIdxNoSeek>=0 );  iIdxNoSeek = -1;  }  sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);  }  if( !IsView(pTab) ){  u8 p5 = 0;  sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,iIdxNoSeek);  sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, (count?OPFLAG_NCHANGE:0));  if( pParse->nested==0 || 0==sqlite3_stricmp(pTab->zName, "sqlite_stat1") ){  sqlite3VdbeAppendP4(v, (char*)pTab, P4_TABLE);  }  if( eMode!=ONEPASS_OFF ){  sqlite3VdbeChangeP5(v, OPFLAG_AUXDELETE);  }  if( iIdxNoSeek>=0 && iIdxNoSeek!=iDataCur ){  sqlite3VdbeAddOp1(v, OP_Delete, iIdxNoSeek);  }  if( eMode==ONEPASS_MULTI ) p5 |= OPFLAG_SAVEPOSITION;  sqlite3VdbeChangeP5(v, p5);  }  sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);  sqlite3CodeRowTrigger(pParse, pTrigger,  TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel  );  sqlite3VdbeResolveLabel(v, iLabel);  VdbeModuleComment((v, "END: GenRowDel()")); } SQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(  Parse *pParse,  Table *pTab,  int iDataCur,  int iIdxCur,  int *aRegIdx,  int iIdxNoSeek ){  int i;  int r1 = -1;  int iPartIdxLabel;  Index *pIdx;  Index *pPrior = 0;  Vdbe *v;  Index *pPk;  v = pParse->pVdbe;  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);  for(i=0, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){  assert( iIdxCur+i!=iDataCur || pPk==pIdx );  if( aRegIdx!=0 && aRegIdx[i]==0 ) continue;  if( pIdx==pPk ) continue;  if( iIdxCur+i==iIdxNoSeek ) continue;  VdbeModuleComment((v, "GenRowIdxDel for %s", pIdx->zName));  r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,  &iPartIdxLabel, pPrior, r1);  sqlite3VdbeAddOp3(v, OP_IdxDelete, iIdxCur+i, r1,  pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);  sqlite3VdbeChangeP5(v, 1);  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);  pPrior = pIdx;  } } SQLITE_PRIVATE int sqlite3GenerateIndexKey(  Parse *pParse,  Index *pIdx,  int iDataCur,  int regOut,  int prefixOnly,  int *piPartIdxLabel,  Index *pPrior,  int regPrior ){  Vdbe *v = pParse->pVdbe;  int j;  int regBase;  int nCol;  if( piPartIdxLabel ){  if( pIdx->pPartIdxWhere ){  *piPartIdxLabel = sqlite3VdbeMakeLabel(pParse);  pParse->iSelfTab = iDataCur + 1;  sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel,  SQLITE_JUMPIFNULL);  pParse->iSelfTab = 0;  pPrior = 0;  }else{  *piPartIdxLabel = 0;  }  }  nCol = (prefixOnly && pIdx->uniqNotNull) ? pIdx->nKeyCol : pIdx->nColumn;  regBase = sqlite3GetTempRange(pParse, nCol);  if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) pPrior = 0;  for(j=0; j<nCol; j++){  if( pPrior   && pPrior->aiColumn[j]==pIdx->aiColumn[j]   && pPrior->aiColumn[j]!=XN_EXPR  ){  continue;  }  sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j);  if( pIdx->aiColumn[j]>=0 ){  sqlite3VdbeDeletePriorOpcode(v, OP_RealAffinity);  }  }  if( regOut ){  sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regOut);  }  sqlite3ReleaseTempRange(pParse, regBase, nCol);  return regBase; } SQLITE_PRIVATE void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){  if( iLabel ){  sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);  } }
#ifndef SQLITE_OMIT_FLOATING_POINT
#endif
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){  VdbeOp *pOp;  assert( context->pVdbe!=0 );  pOp = &context->pVdbe->aOp[context->iOp-1];  assert( pOp->opcode==OP_CollSeq );  assert( pOp->p4type==P4_COLLSEQ );  return pOp->p4.pColl; } static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){  assert( context->isError<=0 );  context->isError = -1;  context->skipFlag = 1; } static void minmaxFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int i;  int mask;  int iBest;  CollSeq *pColl;  assert( argc>1 );  mask = sqlite3_user_data(context)==0 ? 0 : -1;  pColl = sqlite3GetFuncCollSeq(context);  assert( pColl );  assert( mask==-1 || mask==0 );  iBest = 0;  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  for(i=1; i<argc; i++){  if( sqlite3_value_type(argv[i])==SQLITE_NULL ) return;  if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){  testcase( mask==0 );  iBest = i;  }  }  sqlite3_result_value(context, argv[iBest]); } static void typeofFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  static const char *azType[] = { "integer", "real", "text", "blob", "null" };  int i = sqlite3_value_type(argv[0]) - 1;  UNUSED_PARAMETER(NotUsed);  assert( i>=0 && i<ArraySize(azType) );  assert( SQLITE_INTEGER==1 );  assert( SQLITE_FLOAT==2 );  assert( SQLITE_TEXT==3 );  assert( SQLITE_BLOB==4 );  assert( SQLITE_NULL==5 );  sqlite3_result_text(context, azType[i], -1, SQLITE_STATIC); } static void lengthFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  assert( argc==1 );  UNUSED_PARAMETER(argc);  switch( sqlite3_value_type(argv[0]) ){  case SQLITE_BLOB:  case SQLITE_INTEGER:  case SQLITE_FLOAT: {  sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));  break;  }  case SQLITE_TEXT: {  const unsigned char *z = sqlite3_value_text(argv[0]);  const unsigned char *z0;  unsigned char c;  if( z==0 ) return;  z0 = z;  while( (c = *z)!=0 ){  z++;  if( c>=0xc0 ){  while( (*z & 0xc0)==0x80 ){ z++; z0++; }  }  }  sqlite3_result_int(context, (int)(z-z0));  break;  }  default: {  sqlite3_result_null(context);  break;  }  } } static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  assert( argc==1 );  UNUSED_PARAMETER(argc);  switch( sqlite3_value_type(argv[0]) ){  case SQLITE_INTEGER: {  i64 iVal = sqlite3_value_int64(argv[0]);  if( iVal<0 ){  if( iVal==SMALLEST_INT64 ){  sqlite3_result_error(context, "integer overflow", -1);  return;  }  iVal = -iVal;  }  sqlite3_result_int64(context, iVal);  break;  }  case SQLITE_NULL: {  sqlite3_result_null(context);  break;  }  default: {  double rVal = sqlite3_value_double(argv[0]);  if( rVal<0 ) rVal = -rVal;  sqlite3_result_double(context, rVal);  break;  }  } } static void instrFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *zHaystack;  const unsigned char *zNeedle;  int nHaystack;  int nNeedle;  int typeHaystack, typeNeedle;  int N = 1;  int isText;  unsigned char firstChar;  sqlite3_value *pC1 = 0;  sqlite3_value *pC2 = 0;  UNUSED_PARAMETER(argc);  typeHaystack = sqlite3_value_type(argv[0]);  typeNeedle = sqlite3_value_type(argv[1]);  if( typeHaystack==SQLITE_NULL || typeNeedle==SQLITE_NULL ) return;  nHaystack = sqlite3_value_bytes(argv[0]);  nNeedle = sqlite3_value_bytes(argv[1]);  if( nNeedle>0 ){  if( typeHaystack==SQLITE_BLOB && typeNeedle==SQLITE_BLOB ){  zHaystack = sqlite3_value_blob(argv[0]);  zNeedle = sqlite3_value_blob(argv[1]);  isText = 0;  }else if( typeHaystack!=SQLITE_BLOB && typeNeedle!=SQLITE_BLOB ){  zHaystack = sqlite3_value_text(argv[0]);  zNeedle = sqlite3_value_text(argv[1]);  isText = 1;  }else{  pC1 = sqlite3_value_dup(argv[0]);  zHaystack = sqlite3_value_text(pC1);  if( zHaystack==0 ) goto endInstrOOM;  nHaystack = sqlite3_value_bytes(pC1);  pC2 = sqlite3_value_dup(argv[1]);  zNeedle = sqlite3_value_text(pC2);  if( zNeedle==0 ) goto endInstrOOM;  nNeedle = sqlite3_value_bytes(pC2);  isText = 1;  }  if( zNeedle==0 || (nHaystack && zHaystack==0) ) goto endInstrOOM;  firstChar = zNeedle[0];  while( nNeedle<=nHaystack   && (zHaystack[0]!=firstChar || memcmp(zHaystack, zNeedle, nNeedle)!=0)  ){  N++;  do{  nHaystack--;  zHaystack++;  }while( isText && (zHaystack[0]&0xc0)==0x80 );  }  if( nNeedle>nHaystack ) N = 0;  }  sqlite3_result_int(context, N); endInstr:  sqlite3_value_free(pC1);  sqlite3_value_free(pC2);  return; endInstrOOM:  sqlite3_result_error_nomem(context);  goto endInstr; } static void printfFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  PrintfArguments x;  StrAccum str;  const char *zFormat;  int n;  sqlite3 *db = sqlite3_context_db_handle(context);  if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){  x.nArg = argc-1;  x.nUsed = 0;  x.apArg = argv+1;  sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);  str.printfFlags = SQLITE_PRINTF_SQLFUNC;  sqlite3_str_appendf(&str, zFormat, &x);  n = str.nChar;  sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,  SQLITE_DYNAMIC);  } } static void substrFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *z;  const unsigned char *z2;  int len;  int p0type;  i64 p1, p2;  int negP2 = 0;  assert( argc==3 || argc==2 );  if( sqlite3_value_type(argv[1])==SQLITE_NULL   || (argc==3 && sqlite3_value_type(argv[2])==SQLITE_NULL)  ){  return;  }  p0type = sqlite3_value_type(argv[0]);  p1 = sqlite3_value_int(argv[1]);  if( p0type==SQLITE_BLOB ){  len = sqlite3_value_bytes(argv[0]);  z = sqlite3_value_blob(argv[0]);  if( z==0 ) return;  assert( len==sqlite3_value_bytes(argv[0]) );  }else{  z = sqlite3_value_text(argv[0]);  if( z==0 ) return;  len = 0;  if( p1<0 ){  for(z2=z; *z2; len++){  SQLITE_SKIP_UTF8(z2);  }  }  }
#ifdef SQLITE_SUBSTR_COMPATIBILITY
 if( p1==0 ) p1 = 1;
#endif
 if( argc==3 ){  p2 = sqlite3_value_int(argv[2]);  if( p2<0 ){  p2 = -p2;  negP2 = 1;  }  }else{  p2 = sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH];  }  if( p1<0 ){  p1 += len;  if( p1<0 ){  p2 += p1;  if( p2<0 ) p2 = 0;  p1 = 0;  }  }else if( p1>0 ){  p1--;  }else if( p2>0 ){  p2--;  }  if( negP2 ){  p1 -= p2;  if( p1<0 ){  p2 += p1;  p1 = 0;  }  }  assert( p1>=0 && p2>=0 );  if( p0type!=SQLITE_BLOB ){  while( *z && p1 ){  SQLITE_SKIP_UTF8(z);  p1--;  }  for(z2=z; *z2 && p2; p2--){  SQLITE_SKIP_UTF8(z2);  }  sqlite3_result_text64(context, (char*)z, z2-z, SQLITE_TRANSIENT,  SQLITE_UTF8);  }else{  if( p1+p2>len ){  p2 = len-p1;  if( p2<0 ) p2 = 0;  }  sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, SQLITE_TRANSIENT);  } }
#ifndef SQLITE_OMIT_FLOATING_POINT
static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  int n = 0;  double r;  char *zBuf;  assert( argc==1 || argc==2 );  if( argc==2 ){  if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) return;  n = sqlite3_value_int(argv[1]);  if( n>30 ) n = 30;  if( n<0 ) n = 0;  }  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  r = sqlite3_value_double(argv[0]);  if( r<-4503599627370496.0 || r>+4503599627370496.0 ){  }else if( n==0 ){  r = (double)((sqlite_int64)(r+(r<0?-0.5:+0.5)));  }else{  zBuf = sqlite3_mprintf("%.*f",n,r);  if( zBuf==0 ){  sqlite3_result_error_nomem(context);  return;  }  sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), SQLITE_UTF8);  sqlite3_free(zBuf);  }  sqlite3_result_double(context, r); }
#endif
static void *contextMalloc(sqlite3_context *context, i64 nByte){  char *z;  sqlite3 *db = sqlite3_context_db_handle(context);  assert( nByte>0 );  testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH] );  testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH]+1 );  if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){  sqlite3_result_error_toobig(context);  z = 0;  }else{  z = sqlite3Malloc(nByte);  if( !z ){  sqlite3_result_error_nomem(context);  }  }  return z; } static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  char *z1;  const char *z2;  int i, n;  UNUSED_PARAMETER(argc);  z2 = (char*)sqlite3_value_text(argv[0]);  n = sqlite3_value_bytes(argv[0]);  assert( z2==(char*)sqlite3_value_text(argv[0]) );  if( z2 ){  z1 = contextMalloc(context, ((i64)n)+1);  if( z1 ){  for(i=0; i<n; i++){  z1[i] = (char)sqlite3Toupper(z2[i]);  }  sqlite3_result_text(context, z1, n, sqlite3_free);  }  } } static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  char *z1;  const char *z2;  int i, n;  UNUSED_PARAMETER(argc);  z2 = (char*)sqlite3_value_text(argv[0]);  n = sqlite3_value_bytes(argv[0]);  assert( z2==(char*)sqlite3_value_text(argv[0]) );  if( z2 ){  z1 = contextMalloc(context, ((i64)n)+1);  if( z1 ){  for(i=0; i<n; i++){  z1[i] = sqlite3Tolower(z2[i]);  }  sqlite3_result_text(context, z1, n, sqlite3_free);  }  } }
#define noopFunc versionFunc
static void randomFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  sqlite_int64 r;  UNUSED_PARAMETER2(NotUsed, NotUsed2);  sqlite3_randomness(sizeof(r), &r);  if( r<0 ){  r = -(r & LARGEST_INT64);  }  sqlite3_result_int64(context, r); } static void randomBlob(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  sqlite3_int64 n;  unsigned char *p;  assert( argc==1 );  UNUSED_PARAMETER(argc);  n = sqlite3_value_int64(argv[0]);  if( n<1 ){  n = 1;  }  p = contextMalloc(context, n);  if( p ){  sqlite3_randomness(n, p);  sqlite3_result_blob(context, (char*)p, n, sqlite3_free);  } } static void last_insert_rowid(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  sqlite3 *db = sqlite3_context_db_handle(context);  UNUSED_PARAMETER2(NotUsed, NotUsed2);  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db)); } static void changes(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  sqlite3 *db = sqlite3_context_db_handle(context);  UNUSED_PARAMETER2(NotUsed, NotUsed2);  sqlite3_result_int64(context, sqlite3_changes64(db)); } static void total_changes(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  sqlite3 *db = sqlite3_context_db_handle(context);  UNUSED_PARAMETER2(NotUsed, NotUsed2);  sqlite3_result_int64(context, sqlite3_total_changes64(db)); } struct compareInfo {  u8 matchAll;  u8 matchOne;  u8 matchSet;  u8 noCase; };
#if defined(SQLITE_EBCDIC)
# define sqlite3Utf8Read(A) (*((*A)++))
# define Utf8Read(A)  (*(A++))
#else
# define Utf8Read(A)  (A[0]<0x80?*(A++):sqlite3Utf8Read(&A))
#endif
static const struct compareInfo globInfo = { '*', '?', '[', 0 }; static const struct compareInfo likeInfoNorm = { '%', '_', 0, 1 }; static const struct compareInfo likeInfoAlt = { '%', '_', 0, 0 };
#define SQLITE_MATCH  0
#define SQLITE_NOMATCH  1
#define SQLITE_NOWILDCARDMATCH  2
static int patternCompare(  const u8 *zPattern,  const u8 *zString,  const struct compareInfo *pInfo,  u32 matchOther ){  u32 c, c2;  u32 matchOne = pInfo->matchOne;  u32 matchAll = pInfo->matchAll;  u8 noCase = pInfo->noCase;  const u8 *zEscaped = 0;  while( (c = Utf8Read(zPattern))!=0 ){  if( c==matchAll ){  while( (c=Utf8Read(zPattern)) == matchAll   || (c == matchOne && matchOne!=0) ){  if( c==matchOne && sqlite3Utf8Read(&zString)==0 ){  return SQLITE_NOWILDCARDMATCH;  }  }  if( c==0 ){  return SQLITE_MATCH;  }else if( c==matchOther ){  if( pInfo->matchSet==0 ){  c = sqlite3Utf8Read(&zPattern);  if( c==0 ) return SQLITE_NOWILDCARDMATCH;  }else{  assert( matchOther<0x80 );  while( *zString ){  int bMatch = patternCompare(&zPattern[-1],zString,pInfo,matchOther);  if( bMatch!=SQLITE_NOMATCH ) return bMatch;  SQLITE_SKIP_UTF8(zString);  }  return SQLITE_NOWILDCARDMATCH;  }  }  if( c<=0x80 ){  char zStop[3];  int bMatch;  if( noCase ){  zStop[0] = sqlite3Toupper(c);  zStop[1] = sqlite3Tolower(c);  zStop[2] = 0;  }else{  zStop[0] = c;  zStop[1] = 0;  }  while(1){  zString += strcspn((const char*)zString, zStop);  if( zString[0]==0 ) break;  zString++;  bMatch = patternCompare(zPattern,zString,pInfo,matchOther);  if( bMatch!=SQLITE_NOMATCH ) return bMatch;  }  }else{  int bMatch;  while( (c2 = Utf8Read(zString))!=0 ){  if( c2!=c ) continue;  bMatch = patternCompare(zPattern,zString,pInfo,matchOther);  if( bMatch!=SQLITE_NOMATCH ) return bMatch;  }  }  return SQLITE_NOWILDCARDMATCH;  }  if( c==matchOther ){  if( pInfo->matchSet==0 ){  c = sqlite3Utf8Read(&zPattern);  if( c==0 ) return SQLITE_NOMATCH;  zEscaped = zPattern;  }else{  u32 prior_c = 0;  int seen = 0;  int invert = 0;  c = sqlite3Utf8Read(&zString);  if( c==0 ) return SQLITE_NOMATCH;  c2 = sqlite3Utf8Read(&zPattern);  if( c2=='^' ){  invert = 1;  c2 = sqlite3Utf8Read(&zPattern);  }  if( c2==']' ){  if( c==']' ) seen = 1;  c2 = sqlite3Utf8Read(&zPattern);  }  while( c2 && c2!=']' ){  if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){  c2 = sqlite3Utf8Read(&zPattern);  if( c>=prior_c && c<=c2 ) seen = 1;  prior_c = 0;  }else{  if( c==c2 ){  seen = 1;  }  prior_c = c2;  }  c2 = sqlite3Utf8Read(&zPattern);  }  if( c2==0 || (seen ^ invert)==0 ){  return SQLITE_NOMATCH;  }  continue;  }  }  c2 = Utf8Read(zString);  if( c==c2 ) continue;  if( noCase && sqlite3Tolower(c)==sqlite3Tolower(c2) && c<0x80 && c2<0x80 ){  continue;  }  if( c==matchOne && zPattern!=zEscaped && c2!=0 ) continue;  return SQLITE_NOMATCH;  }  return *zString==0 ? SQLITE_MATCH : SQLITE_NOMATCH; } SQLITE_API int sqlite3_strglob(const char *zGlobPattern, const char *zString){  return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '['); } SQLITE_API int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc){  return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc); }
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_like_count = 0;
#endif
static void likeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *zA, *zB;  u32 escape;  int nPat;  sqlite3 *db = sqlite3_context_db_handle(context);  struct compareInfo *pInfo = sqlite3_user_data(context);  struct compareInfo backupInfo;
#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 if( sqlite3_value_type(argv[0])==SQLITE_BLOB   || sqlite3_value_type(argv[1])==SQLITE_BLOB  ){
#ifdef SQLITE_TEST
 sqlite3_like_count++;
#endif
 sqlite3_result_int(context, 0);  return;  }
#endif
 nPat = sqlite3_value_bytes(argv[0]);  testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] );  testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]+1 );  if( nPat > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){  sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);  return;  }  if( argc==3 ){  const unsigned char *zEsc = sqlite3_value_text(argv[2]);  if( zEsc==0 ) return;  if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){  sqlite3_result_error(context,  "ESCAPE expression must be a single character", -1);  return;  }  escape = sqlite3Utf8Read(&zEsc);  if( escape==pInfo->matchAll || escape==pInfo->matchOne ){  memcpy(&backupInfo, pInfo, sizeof(backupInfo));  pInfo = &backupInfo;  if( escape==pInfo->matchAll ) pInfo->matchAll = 0;  if( escape==pInfo->matchOne ) pInfo->matchOne = 0;  }  }else{  escape = pInfo->matchSet;  }  zB = sqlite3_value_text(argv[0]);  zA = sqlite3_value_text(argv[1]);  if( zA && zB ){
#ifdef SQLITE_TEST
 sqlite3_like_count++;
#endif
 sqlite3_result_int(context,  patternCompare(zB, zA, pInfo, escape)==SQLITE_MATCH);  } } static void nullifFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  CollSeq *pColl = sqlite3GetFuncCollSeq(context);  UNUSED_PARAMETER(NotUsed);  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){  sqlite3_result_value(context, argv[0]);  } } static void versionFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  sqlite3_result_text(context, sqlite3_libversion(), -1, SQLITE_STATIC); } static void sourceidFunc(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  sqlite3_result_text(context, sqlite3_sourceid(), -1, SQLITE_STATIC); } static void errlogFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  UNUSED_PARAMETER(argc);  UNUSED_PARAMETER(context);  sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1])); }
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
static void compileoptionusedFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const char *zOptName;  assert( argc==1 );  UNUSED_PARAMETER(argc);  if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){  sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));  } }
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
static void compileoptiongetFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int n;  assert( argc==1 );  UNUSED_PARAMETER(argc);  n = sqlite3_value_int(argv[0]);  sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, SQLITE_STATIC); }
#endif
static const char hexdigits[] = {  '0', '1', '2', '3', '4', '5', '6', '7',  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' }; static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){  assert( argc==1 );  UNUSED_PARAMETER(argc);  switch( sqlite3_value_type(argv[0]) ){  case SQLITE_FLOAT: {  double r1, r2;  char zBuf[50];  r1 = sqlite3_value_double(argv[0]);  sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.15g", r1);  sqlite3AtoF(zBuf, &r2, 20, SQLITE_UTF8);  if( r1!=r2 ){  sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.20e", r1);  }  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  break;  }  case SQLITE_INTEGER: {  sqlite3_result_value(context, argv[0]);  break;  }  case SQLITE_BLOB: {  char *zText = 0;  char const *zBlob = sqlite3_value_blob(argv[0]);  int nBlob = sqlite3_value_bytes(argv[0]);  assert( zBlob==sqlite3_value_blob(argv[0]) );  zText = (char *)contextMalloc(context, (2*(i64)nBlob)+4);  if( zText ){  int i;  for(i=0; i<nBlob; i++){  zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];  zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];  }  zText[(nBlob*2)+2] = '\'';  zText[(nBlob*2)+3] = '\0';  zText[0] = 'X';  zText[1] = '\'';  sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);  sqlite3_free(zText);  }  break;  }  case SQLITE_TEXT: {  int i,j;  u64 n;  const unsigned char *zArg = sqlite3_value_text(argv[0]);  char *z;  if( zArg==0 ) return;  for(i=0, n=0; zArg[i]; i++){ if( zArg[i]=='\'' ) n++; }  z = contextMalloc(context, ((i64)i)+((i64)n)+3);  if( z ){  z[0] = '\'';  for(i=0, j=1; zArg[i]; i++){  z[j++] = zArg[i];  if( zArg[i]=='\'' ){  z[j++] = '\'';  }  }  z[j++] = '\'';  z[j] = 0;  sqlite3_result_text(context, z, j, sqlite3_free);  }  break;  }  default: {  assert( sqlite3_value_type(argv[0])==SQLITE_NULL );  sqlite3_result_text(context, "NULL", 4, SQLITE_STATIC);  break;  }  } } static void unicodeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *z = sqlite3_value_text(argv[0]);  (void)argc;  if( z && z[0] ) sqlite3_result_int(context, sqlite3Utf8Read(&z)); } static void charFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  unsigned char *z, *zOut;  int i;  zOut = z = sqlite3_malloc64( argc*4+1 );  if( z==0 ){  sqlite3_result_error_nomem(context);  return;  }  for(i=0; i<argc; i++){  sqlite3_int64 x;  unsigned c;  x = sqlite3_value_int64(argv[i]);  if( x<0 || x>0x10ffff ) x = 0xfffd;  c = (unsigned)(x & 0x1fffff);  if( c<0x00080 ){  *zOut++ = (u8)(c&0xFF);  }else if( c<0x00800 ){  *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);  *zOut++ = 0x80 + (u8)(c & 0x3F);  }else if( c<0x10000 ){  *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);  *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);  *zOut++ = 0x80 + (u8)(c & 0x3F);  }else{  *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);  *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);  *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);  *zOut++ = 0x80 + (u8)(c & 0x3F);  }   }  sqlite3_result_text64(context, (char*)z, zOut-z, sqlite3_free, SQLITE_UTF8); } static void hexFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int i, n;  const unsigned char *pBlob;  char *zHex, *z;  assert( argc==1 );  UNUSED_PARAMETER(argc);  pBlob = sqlite3_value_blob(argv[0]);  n = sqlite3_value_bytes(argv[0]);  assert( pBlob==sqlite3_value_blob(argv[0]) );  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);  if( zHex ){  for(i=0; i<n; i++, pBlob++){  unsigned char c = *pBlob;  *(z++) = hexdigits[(c>>4)&0xf];  *(z++) = hexdigits[c&0xf];  }  *z = 0;  sqlite3_result_text(context, zHex, n*2, sqlite3_free);  } } static void zeroblobFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  i64 n;  int rc;  assert( argc==1 );  UNUSED_PARAMETER(argc);  n = sqlite3_value_int64(argv[0]);  if( n<0 ) n = 0;  rc = sqlite3_result_zeroblob64(context, n);  if( rc ){  sqlite3_result_error_code(context, rc);  } } static void replaceFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *zStr;  const unsigned char *zPattern;  const unsigned char *zRep;  unsigned char *zOut;  int nStr;  int nPattern;  int nRep;  i64 nOut;  int loopLimit;  int i, j;  unsigned cntExpand;  sqlite3 *db = sqlite3_context_db_handle(context);  assert( argc==3 );  UNUSED_PARAMETER(argc);  zStr = sqlite3_value_text(argv[0]);  if( zStr==0 ) return;  nStr = sqlite3_value_bytes(argv[0]);  assert( zStr==sqlite3_value_text(argv[0]) );  zPattern = sqlite3_value_text(argv[1]);  if( zPattern==0 ){  assert( sqlite3_value_type(argv[1])==SQLITE_NULL  || sqlite3_context_db_handle(context)->mallocFailed );  return;  }  if( zPattern[0]==0 ){  assert( sqlite3_value_type(argv[1])!=SQLITE_NULL );  sqlite3_result_value(context, argv[0]);  return;  }  nPattern = sqlite3_value_bytes(argv[1]);  assert( zPattern==sqlite3_value_text(argv[1]) );  zRep = sqlite3_value_text(argv[2]);  if( zRep==0 ) return;  nRep = sqlite3_value_bytes(argv[2]);  assert( zRep==sqlite3_value_text(argv[2]) );  nOut = nStr + 1;  assert( nOut<SQLITE_MAX_LENGTH );  zOut = contextMalloc(context, (i64)nOut);  if( zOut==0 ){  return;  }  loopLimit = nStr - nPattern;  cntExpand = 0;  for(i=j=0; i<=loopLimit; i++){  if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){  zOut[j++] = zStr[i];  }else{  if( nRep>nPattern ){  nOut += nRep - nPattern;  testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );  testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );  if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){  sqlite3_result_error_toobig(context);  sqlite3_free(zOut);  return;  }  cntExpand++;  if( (cntExpand&(cntExpand-1))==0 ){  u8 *zOld;  zOld = zOut;  zOut = sqlite3Realloc(zOut, (int)nOut + (nOut - nStr - 1));  if( zOut==0 ){  sqlite3_result_error_nomem(context);  sqlite3_free(zOld);  return;  }  }  }  memcpy(&zOut[j], zRep, nRep);  j += nRep;  i += nPattern-1;  }  }  assert( j+nStr-i+1<=nOut );  memcpy(&zOut[j], &zStr[i], nStr-i);  j += nStr - i;  assert( j<=nOut );  zOut[j] = 0;  sqlite3_result_text(context, (char*)zOut, j, sqlite3_free); } static void trimFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *zIn;  const unsigned char *zCharSet;  unsigned int nIn;  int flags;  int i;  unsigned int *aLen = 0;  unsigned char **azChar = 0;  int nChar;  if( sqlite3_value_type(argv[0])==SQLITE_NULL ){  return;  }  zIn = sqlite3_value_text(argv[0]);  if( zIn==0 ) return;  nIn = (unsigned)sqlite3_value_bytes(argv[0]);  assert( zIn==sqlite3_value_text(argv[0]) );  if( argc==1 ){  static const unsigned lenOne[] = { 1 };  static unsigned char * const azOne[] = { (u8*)" " };  nChar = 1;  aLen = (unsigned*)lenOne;  azChar = (unsigned char **)azOne;  zCharSet = 0;  }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){  return;  }else{  const unsigned char *z;  for(z=zCharSet, nChar=0; *z; nChar++){  SQLITE_SKIP_UTF8(z);  }  if( nChar>0 ){  azChar = contextMalloc(context,   ((i64)nChar)*(sizeof(char*)+sizeof(unsigned)));  if( azChar==0 ){  return;  }  aLen = (unsigned*)&azChar[nChar];  for(z=zCharSet, nChar=0; *z; nChar++){  azChar[nChar] = (unsigned char *)z;  SQLITE_SKIP_UTF8(z);  aLen[nChar] = (unsigned)(z - azChar[nChar]);  }  }  }  if( nChar>0 ){  flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context));  if( flags & 1 ){  while( nIn>0 ){  unsigned int len = 0;  for(i=0; i<nChar; i++){  len = aLen[i];  if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) break;  }  if( i>=nChar ) break;  zIn += len;  nIn -= len;  }  }  if( flags & 2 ){  while( nIn>0 ){  unsigned int len = 0;  for(i=0; i<nChar; i++){  len = aLen[i];  if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break;  }  if( i>=nChar ) break;  nIn -= len;  }  }  if( zCharSet ){  sqlite3_free(azChar);  }  }  sqlite3_result_text(context, (char*)zIn, nIn, SQLITE_TRANSIENT); }
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
static void unknownFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){ }
#endif
#ifdef SQLITE_SOUNDEX
static void soundexFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  char zResult[8];  const u8 *zIn;  int i, j;  static const unsigned char iCode[] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,  1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,  0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,  1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,  };  assert( argc==1 );  zIn = (u8*)sqlite3_value_text(argv[0]);  if( zIn==0 ) zIn = (u8*)"";  for(i=0; zIn[i] && !sqlite3Isalpha(zIn[i]); i++){}  if( zIn[i] ){  u8 prevcode = iCode[zIn[i]&0x7f];  zResult[0] = sqlite3Toupper(zIn[i]);  for(j=1; j<4 && zIn[i]; i++){  int code = iCode[zIn[i]&0x7f];  if( code>0 ){  if( code!=prevcode ){  prevcode = code;  zResult[j++] = code + '0';  }  }else{  prevcode = 0;  }  }  while( j<4 ){  zResult[j++] = '0';  }  zResult[j] = 0;  sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT);  }else{  sqlite3_result_text(context, "?000", 4, SQLITE_STATIC);  } }
#endif
#ifndef SQLITE_OMIT_LOAD_EXTENSION
static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){  const char *zFile = (const char *)sqlite3_value_text(argv[0]);  const char *zProc;  sqlite3 *db = sqlite3_context_db_handle(context);  char *zErrMsg = 0;  if( (db->flags & SQLITE_LoadExtFunc)==0 ){  sqlite3_result_error(context, "not authorized", -1);  return;  }  if( argc==2 ){  zProc = (const char *)sqlite3_value_text(argv[1]);  }else{  zProc = 0;  }  if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){  sqlite3_result_error(context, zErrMsg, -1);  sqlite3_free(zErrMsg);  } }
#endif
typedef struct SumCtx SumCtx; struct SumCtx {  double rSum;  i64 iSum;  i64 cnt;  u8 overflow;  u8 approx; }; static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){  SumCtx *p;  int type;  assert( argc==1 );  UNUSED_PARAMETER(argc);  p = sqlite3_aggregate_context(context, sizeof(*p));  type = sqlite3_value_numeric_type(argv[0]);  if( p && type!=SQLITE_NULL ){  p->cnt++;  if( type==SQLITE_INTEGER ){  i64 v = sqlite3_value_int64(argv[0]);  p->rSum += v;  if( (p->approx|p->overflow)==0 && sqlite3AddInt64(&p->iSum, v) ){  p->approx = p->overflow = 1;  }  }else{  p->rSum += sqlite3_value_double(argv[0]);  p->approx = 1;  }  } }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void sumInverse(sqlite3_context *context, int argc, sqlite3_value**argv){  SumCtx *p;  int type;  assert( argc==1 );  UNUSED_PARAMETER(argc);  p = sqlite3_aggregate_context(context, sizeof(*p));  type = sqlite3_value_numeric_type(argv[0]);  if( ALWAYS(p) && type!=SQLITE_NULL ){  assert( p->cnt>0 );  p->cnt--;  assert( type==SQLITE_INTEGER || p->approx );  if( type==SQLITE_INTEGER && p->approx==0 ){  i64 v = sqlite3_value_int64(argv[0]);  p->rSum -= v;  p->iSum -= v;  }else{  p->rSum -= sqlite3_value_double(argv[0]);  }  } }
#else
# define sumInverse 0
#endif
static void sumFinalize(sqlite3_context *context){  SumCtx *p;  p = sqlite3_aggregate_context(context, 0);  if( p && p->cnt>0 ){  if( p->overflow ){  sqlite3_result_error(context,"integer overflow",-1);  }else if( p->approx ){  sqlite3_result_double(context, p->rSum);  }else{  sqlite3_result_int64(context, p->iSum);  }  } } static void avgFinalize(sqlite3_context *context){  SumCtx *p;  p = sqlite3_aggregate_context(context, 0);  if( p && p->cnt>0 ){  sqlite3_result_double(context, p->rSum/(double)p->cnt);  } } static void totalFinalize(sqlite3_context *context){  SumCtx *p;  p = sqlite3_aggregate_context(context, 0);  sqlite3_result_double(context, p ? p->rSum : (double)0); } typedef struct CountCtx CountCtx; struct CountCtx {  i64 n;
#ifdef SQLITE_DEBUG
 int bInverse;
#endif
}; static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){  CountCtx *p;  p = sqlite3_aggregate_context(context, sizeof(*p));  if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){  p->n++;  }
#ifndef SQLITE_OMIT_DEPRECATED
 assert( argc==1 || p==0 || p->n>0x7fffffff || p->bInverse  || p->n==sqlite3_aggregate_count(context) );
#endif
} static void countFinalize(sqlite3_context *context){  CountCtx *p;  p = sqlite3_aggregate_context(context, 0);  sqlite3_result_int64(context, p ? p->n : 0); }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void countInverse(sqlite3_context *ctx, int argc, sqlite3_value **argv){  CountCtx *p;  p = sqlite3_aggregate_context(ctx, sizeof(*p));  if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && ALWAYS(p) ){  p->n--;
#ifdef SQLITE_DEBUG
 p->bInverse = 1;
#endif
 } }
#else
# define countInverse 0
#endif
static void minmaxStep(  sqlite3_context *context,  int NotUsed,  sqlite3_value **argv ){  Mem *pArg = (Mem *)argv[0];  Mem *pBest;  UNUSED_PARAMETER(NotUsed);  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));  if( !pBest ) return;  if( sqlite3_value_type(pArg)==SQLITE_NULL ){  if( pBest->flags ) sqlite3SkipAccumulatorLoad(context);  }else if( pBest->flags ){  int max;  int cmp;  CollSeq *pColl = sqlite3GetFuncCollSeq(context);  max = sqlite3_user_data(context)!=0;  cmp = sqlite3MemCompare(pBest, pArg, pColl);  if( (max && cmp<0) || (!max && cmp>0) ){  sqlite3VdbeMemCopy(pBest, pArg);  }else{  sqlite3SkipAccumulatorLoad(context);  }  }else{  pBest->db = sqlite3_context_db_handle(context);  sqlite3VdbeMemCopy(pBest, pArg);  } } static void minMaxValueFinalize(sqlite3_context *context, int bValue){  sqlite3_value *pRes;  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);  if( pRes ){  if( pRes->flags ){  sqlite3_result_value(context, pRes);  }  if( bValue==0 ) sqlite3VdbeMemRelease(pRes);  } }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void minMaxValue(sqlite3_context *context){  minMaxValueFinalize(context, 1); }
#else
# define minMaxValue 0
#endif
static void minMaxFinalize(sqlite3_context *context){  minMaxValueFinalize(context, 0); } typedef struct {  StrAccum str;
#ifndef SQLITE_OMIT_WINDOWFUNC
 int nAccum;  int nFirstSepLength;  int *pnSepLengths;
#endif
} GroupConcatCtx; static void groupConcatStep(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const char *zVal;  GroupConcatCtx *pGCC;  const char *zSep;  int nVal, nSep;  assert( argc==1 || argc==2 );  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));  if( pGCC ){  sqlite3 *db = sqlite3_context_db_handle(context);  int firstTerm = pGCC->str.mxAlloc==0;  pGCC->str.mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];  if( argc==1 ){  if( !firstTerm ){  sqlite3_str_appendchar(&pGCC->str, 1, ',');  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 else{  pGCC->nFirstSepLength = 1;  }
#endif
 }else if( !firstTerm ){  zSep = (char*)sqlite3_value_text(argv[1]);  nSep = sqlite3_value_bytes(argv[1]);  if( zSep ){  sqlite3_str_append(&pGCC->str, zSep, nSep);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 else{  nSep = 0;  }  if( nSep != pGCC->nFirstSepLength || pGCC->pnSepLengths != 0 ){  int *pnsl = pGCC->pnSepLengths;  if( pnsl == 0 ){  pnsl = (int*)sqlite3_malloc64((pGCC->nAccum+1) * sizeof(int));  if( pnsl!=0 ){  int i = 0, nA = pGCC->nAccum-1;  while( i<nA ) pnsl[i++] = pGCC->nFirstSepLength;  }  }else{  pnsl = (int*)sqlite3_realloc64(pnsl, pGCC->nAccum * sizeof(int));  }  if( pnsl!=0 ){  if( ALWAYS(pGCC->nAccum>0) ){  pnsl[pGCC->nAccum-1] = nSep;  }  pGCC->pnSepLengths = pnsl;  }else{  sqlite3StrAccumSetError(&pGCC->str, SQLITE_NOMEM);  }  }
#endif
 }
#ifndef SQLITE_OMIT_WINDOWFUNC
 else{  pGCC->nFirstSepLength = sqlite3_value_bytes(argv[1]);  }  pGCC->nAccum += 1;
#endif
 zVal = (char*)sqlite3_value_text(argv[0]);  nVal = sqlite3_value_bytes(argv[0]);  if( zVal ) sqlite3_str_append(&pGCC->str, zVal, nVal);  } }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void groupConcatInverse(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GroupConcatCtx *pGCC;  assert( argc==1 || argc==2 );  (void)argc;  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;  pGCC = (GroupConcatCtx*)sqlite3_aggregate_context(context, sizeof(*pGCC));  if( ALWAYS(pGCC) ){  int nVS;  (void)sqlite3_value_text(argv[0]);  nVS = sqlite3_value_bytes(argv[0]);  pGCC->nAccum -= 1;  if( pGCC->pnSepLengths!=0 ){  assert(pGCC->nAccum >= 0);  if( pGCC->nAccum>0 ){  nVS += *pGCC->pnSepLengths;  memmove(pGCC->pnSepLengths, pGCC->pnSepLengths+1,   (pGCC->nAccum-1)*sizeof(int));  }  }else{  nVS += pGCC->nFirstSepLength;  }  if( nVS>=(int)pGCC->str.nChar ){  pGCC->str.nChar = 0;  }else{  pGCC->str.nChar -= nVS;  memmove(pGCC->str.zText, &pGCC->str.zText[nVS], pGCC->str.nChar);  }  if( pGCC->str.nChar==0 ){  pGCC->str.mxAlloc = 0;  sqlite3_free(pGCC->pnSepLengths);  pGCC->pnSepLengths = 0;  }  } }
#else
# define groupConcatInverse 0
#endif
static void groupConcatFinalize(sqlite3_context *context){  GroupConcatCtx *pGCC  = (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);  if( pGCC ){  sqlite3ResultStrAccum(context, &pGCC->str);
#ifndef SQLITE_OMIT_WINDOWFUNC
 sqlite3_free(pGCC->pnSepLengths);
#endif
 } }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void groupConcatValue(sqlite3_context *context){  GroupConcatCtx *pGCC  = (GroupConcatCtx*)sqlite3_aggregate_context(context, 0);  if( pGCC ){  StrAccum *pAccum = &pGCC->str;  if( pAccum->accError==SQLITE_TOOBIG ){  sqlite3_result_error_toobig(context);  }else if( pAccum->accError==SQLITE_NOMEM ){  sqlite3_result_error_nomem(context);  }else{  const char *zText = sqlite3_str_value(pAccum);  sqlite3_result_text(context, zText, pAccum->nChar, SQLITE_TRANSIENT);  }  } }
#else
# define groupConcatValue 0
#endif
SQLITE_PRIVATE void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db){  int rc = sqlite3_overload_function(db, "MATCH", 2);  assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );  if( rc==SQLITE_NOMEM ){  sqlite3OomFault(db);  } } SQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){  struct compareInfo *pInfo;  int flags;  if( caseSensitive ){  pInfo = (struct compareInfo*)&likeInfoAlt;  flags = SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE;  }else{  pInfo = (struct compareInfo*)&likeInfoNorm;  flags = SQLITE_FUNC_LIKE;  }  sqlite3CreateFunc(db, "like", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);  sqlite3CreateFunc(db, "like", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);  sqlite3FindFunction(db, "like", 2, SQLITE_UTF8, 0)->funcFlags |= flags;  sqlite3FindFunction(db, "like", 3, SQLITE_UTF8, 0)->funcFlags |= flags; } SQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){  FuncDef *pDef;  int nExpr;  assert( pExpr!=0 );  assert( pExpr->op==TK_FUNCTION );  assert( ExprUseXList(pExpr) );  if( !pExpr->x.pList ){  return 0;  }  nExpr = pExpr->x.pList->nExpr;  assert( !ExprHasProperty(pExpr, EP_IntValue) );  pDef = sqlite3FindFunction(db, pExpr->u.zToken, nExpr, SQLITE_UTF8, 0);
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
 if( pDef==0 ) return 0;
#endif
 if( NEVER(pDef==0) || (pDef->funcFlags & SQLITE_FUNC_LIKE)==0 ){  return 0;  }  memcpy(aWc, pDef->pUserData, 3);  assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll );  assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne );  assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet );  if( nExpr<3 ){  aWc[3] = 0;  }else{  Expr *pEscape = pExpr->x.pList->a[2].pExpr;  char *zEscape;  if( pEscape->op!=TK_STRING ) return 0;  assert( !ExprHasProperty(pEscape, EP_IntValue) );  zEscape = pEscape->u.zToken;  if( zEscape[0]==0 || zEscape[1]!=0 ) return 0;  if( zEscape[0]==aWc[0] ) return 0;  if( zEscape[0]==aWc[1] ) return 0;  aWc[3] = zEscape[0];  }  *pIsNocase = (pDef->funcFlags & SQLITE_FUNC_CASE)==0;  return 1; }
#ifndef M_PI
# define M_PI  3.141592653589793238462643383279502884
#endif
#ifndef M_LN10
# define M_LN10 2.302585092994045684017991454684364208
#endif
#ifndef M_LN2
# define M_LN2 0.693147180559945309417232121458176568
#endif
#ifdef SQLITE_ENABLE_MATH_FUNCTIONS
static void ceilingFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  assert( argc==1 );  switch( sqlite3_value_numeric_type(argv[0]) ){  case SQLITE_INTEGER: {   sqlite3_result_int64(context, sqlite3_value_int64(argv[0]));   break;  }  case SQLITE_FLOAT: {   double (*x)(double) = (double(*)(double))sqlite3_user_data(context);   sqlite3_result_double(context, x(sqlite3_value_double(argv[0])));   break;  }  default: {   break;  }  } } static double xCeil(double x){ return ceil(x); } static double xFloor(double x){ return floor(x); } static void logFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  double x, b, ans;  assert( argc==1 || argc==2 );  switch( sqlite3_value_numeric_type(argv[0]) ){  case SQLITE_INTEGER:  case SQLITE_FLOAT:  x = sqlite3_value_double(argv[0]);  if( x<=0.0 ) return;  break;  default:  return;  }  if( argc==2 ){  switch( sqlite3_value_numeric_type(argv[0]) ){  case SQLITE_INTEGER:  case SQLITE_FLOAT:  b = log(x);  if( b<=0.0 ) return;  x = sqlite3_value_double(argv[1]);  if( x<=0.0 ) return;  break;   default:  return;  }  ans = log(x)/b;  }else{  ans = log(x);  switch( SQLITE_PTR_TO_INT(sqlite3_user_data(context)) ){  case 1:  ans *= 1.0/M_LN10;  break;  case 2:  ans *= 1.0/M_LN2;  break;  default:  break;  }  }  sqlite3_result_double(context, ans); } static double degToRad(double x){ return x*(M_PI/180.0); } static double radToDeg(double x){ return x*(180.0/M_PI); } static void math1Func(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int type0;  double v0, ans;  double (*x)(double);  assert( argc==1 );  type0 = sqlite3_value_numeric_type(argv[0]);  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;  v0 = sqlite3_value_double(argv[0]);  x = (double(*)(double))sqlite3_user_data(context);  ans = x(v0);  sqlite3_result_double(context, ans); } static void math2Func(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int type0, type1;  double v0, v1, ans;  double (*x)(double,double);  assert( argc==2 );  type0 = sqlite3_value_numeric_type(argv[0]);  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;  type1 = sqlite3_value_numeric_type(argv[1]);  if( type1!=SQLITE_INTEGER && type1!=SQLITE_FLOAT ) return;  v0 = sqlite3_value_double(argv[0]);  v1 = sqlite3_value_double(argv[1]);  x = (double(*)(double,double))sqlite3_user_data(context);  ans = x(v0, v1);  sqlite3_result_double(context, ans); } static void piFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  assert( argc==0 );  sqlite3_result_double(context, M_PI); }
#endif
static void signFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int type0;  double x;  UNUSED_PARAMETER(argc);  assert( argc==1 );  type0 = sqlite3_value_numeric_type(argv[0]);  if( type0!=SQLITE_INTEGER && type0!=SQLITE_FLOAT ) return;  x = sqlite3_value_double(argv[0]);  sqlite3_result_int(context, x<0.0 ? -1 : x>0.0 ? +1 : 0); } SQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(void){  static FuncDef aBuiltinFunc[] = {
#if !defined(SQLITE_UNTESTABLE)
 TEST_FUNC(implies_nonnull_row, 2, INLINEFUNC_implies_nonnull_row, 0),  TEST_FUNC(expr_compare, 2, INLINEFUNC_expr_compare, 0),  TEST_FUNC(expr_implies_expr, 2, INLINEFUNC_expr_implies_expr, 0),  TEST_FUNC(affinity, 1, INLINEFUNC_affinity, 0),
#endif
#ifdef SQLITE_SOUNDEX
 FUNCTION(soundex, 1, 0, 0, soundexFunc ),
#endif
#ifndef SQLITE_OMIT_LOAD_EXTENSION
 SFUNCTION(load_extension, 1, 0, 0, loadExt ),  SFUNCTION(load_extension, 2, 0, 0, loadExt ),
#endif
#if SQLITE_USER_AUTHENTICATION
 FUNCTION(sqlite_crypt, 2, 0, 0, sqlite3CryptFunc ),
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
 DFUNCTION(sqlite_compileoption_used,1, 0, 0, compileoptionusedFunc ),  DFUNCTION(sqlite_compileoption_get, 1, 0, 0, compileoptiongetFunc ),
#endif
 INLINE_FUNC(unlikely, 1, INLINEFUNC_unlikely, SQLITE_FUNC_UNLIKELY),  INLINE_FUNC(likelihood, 2, INLINEFUNC_unlikely, SQLITE_FUNC_UNLIKELY),  INLINE_FUNC(likely, 1, INLINEFUNC_unlikely, SQLITE_FUNC_UNLIKELY),
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
 FUNCTION2(sqlite_offset, 1, 0, 0, noopFunc, SQLITE_FUNC_OFFSET|   SQLITE_FUNC_TYPEOF),
#endif
 FUNCTION(ltrim, 1, 1, 0, trimFunc  ),  FUNCTION(ltrim, 2, 1, 0, trimFunc  ),  FUNCTION(rtrim, 1, 2, 0, trimFunc  ),  FUNCTION(rtrim, 2, 2, 0, trimFunc  ),  FUNCTION(trim, 1, 3, 0, trimFunc  ),  FUNCTION(trim, 2, 3, 0, trimFunc  ),  FUNCTION(min, -1, 0, 1, minmaxFunc  ),  FUNCTION(min, 0, 0, 1, 0 ),  WAGGREGATE(min, 1, 0, 1, minmaxStep, minMaxFinalize, minMaxValue, 0,   SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER ),  FUNCTION(max, -1, 1, 1, minmaxFunc  ),  FUNCTION(max, 0, 1, 1, 0 ),  WAGGREGATE(max, 1, 1, 1, minmaxStep, minMaxFinalize, minMaxValue, 0,   SQLITE_FUNC_MINMAX|SQLITE_FUNC_ANYORDER ),  FUNCTION2(typeof, 1, 0, 0, typeofFunc, SQLITE_FUNC_TYPEOF),  FUNCTION2(length, 1, 0, 0, lengthFunc, SQLITE_FUNC_LENGTH),  FUNCTION(instr, 2, 0, 0, instrFunc ),  FUNCTION(printf, -1, 0, 0, printfFunc  ),  FUNCTION(unicode, 1, 0, 0, unicodeFunc ),  FUNCTION(char, -1, 0, 0, charFunc  ),  FUNCTION(abs, 1, 0, 0, absFunc ),
#ifndef SQLITE_OMIT_FLOATING_POINT
 FUNCTION(round, 1, 0, 0, roundFunc ),  FUNCTION(round, 2, 0, 0, roundFunc ),
#endif
 FUNCTION(upper, 1, 0, 0, upperFunc ),  FUNCTION(lower, 1, 0, 0, lowerFunc ),  FUNCTION(hex, 1, 0, 0, hexFunc ),  INLINE_FUNC(ifnull, 2, INLINEFUNC_coalesce, 0 ),  VFUNCTION(random, 0, 0, 0, randomFunc  ),  VFUNCTION(randomblob, 1, 0, 0, randomBlob  ),  FUNCTION(nullif, 2, 0, 1, nullifFunc  ),  DFUNCTION(sqlite_version, 0, 0, 0, versionFunc ),  DFUNCTION(sqlite_source_id, 0, 0, 0, sourceidFunc  ),  FUNCTION(sqlite_log, 2, 0, 0, errlogFunc  ),  FUNCTION(quote, 1, 0, 0, quoteFunc ),  VFUNCTION(last_insert_rowid, 0, 0, 0, last_insert_rowid),  VFUNCTION(changes, 0, 0, 0, changes ),  VFUNCTION(total_changes, 0, 0, 0, total_changes ),  FUNCTION(replace, 3, 0, 0, replaceFunc ),  FUNCTION(zeroblob, 1, 0, 0, zeroblobFunc  ),  FUNCTION(substr, 2, 0, 0, substrFunc  ),  FUNCTION(substr, 3, 0, 0, substrFunc  ),  FUNCTION(substring, 2, 0, 0, substrFunc  ),  FUNCTION(substring, 3, 0, 0, substrFunc  ),  WAGGREGATE(sum, 1,0,0, sumStep, sumFinalize, sumFinalize, sumInverse, 0),  WAGGREGATE(total, 1,0,0, sumStep,totalFinalize,totalFinalize,sumInverse, 0),  WAGGREGATE(avg, 1,0,0, sumStep, avgFinalize, avgFinalize, sumInverse, 0),  WAGGREGATE(count, 0,0,0, countStep,  countFinalize, countFinalize, countInverse,  SQLITE_FUNC_COUNT|SQLITE_FUNC_ANYORDER ),  WAGGREGATE(count, 1,0,0, countStep,  countFinalize, countFinalize, countInverse, SQLITE_FUNC_ANYORDER ),  WAGGREGATE(group_concat, 1, 0, 0, groupConcatStep,  groupConcatFinalize, groupConcatValue, groupConcatInverse, 0),  WAGGREGATE(group_concat, 2, 0, 0, groupConcatStep,  groupConcatFinalize, groupConcatValue, groupConcatInverse, 0),  LIKEFUNC(glob, 2, &globInfo, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),
#ifdef SQLITE_CASE_SENSITIVE_LIKE
 LIKEFUNC(like, 2, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),  LIKEFUNC(like, 3, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),
#else
 LIKEFUNC(like, 2, &likeInfoNorm, SQLITE_FUNC_LIKE),  LIKEFUNC(like, 3, &likeInfoNorm, SQLITE_FUNC_LIKE),
#endif
#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION
 FUNCTION(unknown, -1, 0, 0, unknownFunc ),
#endif
 FUNCTION(coalesce, 1, 0, 0, 0 ),  FUNCTION(coalesce, 0, 0, 0, 0 ),
#ifdef SQLITE_ENABLE_MATH_FUNCTIONS
 MFUNCTION(ceil, 1, xCeil, ceilingFunc ),  MFUNCTION(ceiling, 1, xCeil, ceilingFunc ),  MFUNCTION(floor, 1, xFloor, ceilingFunc ),
#if SQLITE_HAVE_C99_MATH_FUNCS
 MFUNCTION(trunc, 1, trunc, ceilingFunc ),
#endif
 FUNCTION(ln, 1, 0, 0, logFunc  ),  FUNCTION(log, 1, 1, 0, logFunc  ),  FUNCTION(log10, 1, 1, 0, logFunc  ),  FUNCTION(log2, 1, 2, 0, logFunc  ),  FUNCTION(log, 2, 0, 0, logFunc  ),  MFUNCTION(exp, 1, exp, math1Func  ),  MFUNCTION(pow, 2, pow, math2Func  ),  MFUNCTION(power, 2, pow, math2Func  ),  MFUNCTION(mod, 2, fmod, math2Func  ),  MFUNCTION(acos, 1, acos, math1Func  ),  MFUNCTION(asin, 1, asin, math1Func  ),  MFUNCTION(atan, 1, atan, math1Func  ),  MFUNCTION(atan2, 2, atan2, math2Func  ),  MFUNCTION(cos, 1, cos, math1Func  ),  MFUNCTION(sin, 1, sin, math1Func  ),  MFUNCTION(tan, 1, tan, math1Func  ),  MFUNCTION(cosh, 1, cosh, math1Func  ),  MFUNCTION(sinh, 1, sinh, math1Func  ),  MFUNCTION(tanh, 1, tanh, math1Func  ),
#if SQLITE_HAVE_C99_MATH_FUNCS
 MFUNCTION(acosh, 1, acosh, math1Func  ),  MFUNCTION(asinh, 1, asinh, math1Func  ),  MFUNCTION(atanh, 1, atanh, math1Func  ),
#endif
 MFUNCTION(sqrt, 1, sqrt, math1Func  ),  MFUNCTION(radians, 1, degToRad, math1Func  ),  MFUNCTION(degrees, 1, radToDeg, math1Func  ),  FUNCTION(pi, 0, 0, 0, piFunc ),
#endif
 FUNCTION(sign, 1, 0, 0, signFunc ),  INLINE_FUNC(coalesce, -1, INLINEFUNC_coalesce, 0 ),  INLINE_FUNC(iif, 3, INLINEFUNC_iif, 0 ),  };
#ifndef SQLITE_OMIT_ALTERTABLE
 sqlite3AlterFunctions();
#endif
 sqlite3WindowFunctions();  sqlite3RegisterDateTimeFunctions();  sqlite3InsertBuiltinFuncs(aBuiltinFunc, ArraySize(aBuiltinFunc));
#if 0
 {  int i;  FuncDef *p;  for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){  printf("FUNC-HASH %02d:", i);  for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash){  int n = sqlite3Strlen30(p->zName);  int h = p->zName[0] + n;  assert( p->funcFlags & SQLITE_FUNC_BUILTIN );  printf(" %s(%d)", p->zName, h);  }  printf("\n");  }  }
#endif
}
#ifndef SQLITE_OMIT_FOREIGN_KEY
#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE int sqlite3FkLocateIndex(  Parse *pParse,  Table *pParent,  FKey *pFKey,  Index **ppIdx,  int **paiCol ){  Index *pIdx = 0;  int *aiCol = 0;  int nCol = pFKey->nCol;  char *zKey = pFKey->aCol[0].zCol;  assert( ppIdx && *ppIdx==0 );  assert( !paiCol || *paiCol==0 );  assert( pParse );  if( nCol==1 ){  if( pParent->iPKey>=0 ){  if( !zKey ) return 0;  if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zCnName, zKey) ){  return 0;  }  }  }else if( paiCol ){  assert( nCol>1 );  aiCol = (int *)sqlite3DbMallocRawNN(pParse->db, nCol*sizeof(int));  if( !aiCol ) return 1;  *paiCol = aiCol;  }  for(pIdx=pParent->pIndex; pIdx; pIdx=pIdx->pNext){  if( pIdx->nKeyCol==nCol && IsUniqueIndex(pIdx) && pIdx->pPartIdxWhere==0 ){  if( zKey==0 ){  if( IsPrimaryKeyIndex(pIdx) ){  if( aiCol ){  int i;  for(i=0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;  }  break;  }  }else{  int i, j;  for(i=0; i<nCol; i++){  i16 iCol = pIdx->aiColumn[i];  const char *zDfltColl;  char *zIdxCol;  if( iCol<0 ) break;  zDfltColl = sqlite3ColumnColl(&pParent->aCol[iCol]);  if( !zDfltColl ) zDfltColl = sqlite3StrBINARY;  if( sqlite3StrICmp(pIdx->azColl[i], zDfltColl) ) break;  zIdxCol = pParent->aCol[iCol].zCnName;  for(j=0; j<nCol; j++){  if( sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol)==0 ){  if( aiCol ) aiCol[i] = pFKey->aCol[j].iFrom;  break;  }  }  if( j==nCol ) break;  }  if( i==nCol ) break;  }  }  }  if( !pIdx ){  if( !pParse->disableTriggers ){  sqlite3ErrorMsg(pParse,   "foreign key mismatch - \"%w\" referencing \"%w\"",   pFKey->pFrom->zName, pFKey->zTo);  }  sqlite3DbFree(pParse->db, aiCol);  return 1;  }  *ppIdx = pIdx;  return 0; } static void fkLookupParent(  Parse *pParse,  int iDb,  Table *pTab,  Index *pIdx,  FKey *pFKey,  int *aiCol,  int regData,  int nIncr,  int isIgnore ){  int i;  Vdbe *v = sqlite3GetVdbe(pParse);  int iCur = pParse->nTab - 1;  int iOk = sqlite3VdbeMakeLabel(pParse);  sqlite3VdbeVerifyAbortable(v,  (!pFKey->isDeferred  && !(pParse->db->flags & SQLITE_DeferFKs)  && !pParse->pToplevel  && !pParse->isMultiWrite) ? OE_Abort : OE_Ignore);  if( nIncr<0 ){  sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, iOk);  VdbeCoverage(v);  }  for(i=0; i<pFKey->nCol; i++){  int iReg = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i]) + regData + 1;  sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iOk); VdbeCoverage(v);  }  if( isIgnore==0 ){  if( pIdx==0 ){  int iMustBeInt;  int regTemp = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_SCopy,  sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[0])+1+regData, regTemp);  iMustBeInt = sqlite3VdbeAddOp2(v, OP_MustBeInt, regTemp, 0);  VdbeCoverage(v);  if( pTab==pFKey->pFrom && nIncr==1 ){  sqlite3VdbeAddOp3(v, OP_Eq, regData, iOk, regTemp); VdbeCoverage(v);  sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);  }  sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenRead);  sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regTemp); VdbeCoverage(v);  sqlite3VdbeGoto(v, iOk);  sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);  sqlite3VdbeJumpHere(v, iMustBeInt);  sqlite3ReleaseTempReg(pParse, regTemp);  }else{  int nCol = pFKey->nCol;  int regTemp = sqlite3GetTempRange(pParse, nCol);  int regRec = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_OpenRead, iCur, pIdx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);  for(i=0; i<nCol; i++){  sqlite3VdbeAddOp2(v, OP_Copy,   sqlite3TableColumnToStorage(pFKey->pFrom, aiCol[i])+1+regData,   regTemp+i);  }  if( pTab==pFKey->pFrom && nIncr==1 ){  int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;  for(i=0; i<nCol; i++){  int iChild = sqlite3TableColumnToStorage(pFKey->pFrom,aiCol[i])  +1+regData;  int iParent = 1+regData;  iParent += sqlite3TableColumnToStorage(pIdx->pTable,   pIdx->aiColumn[i]);  assert( pIdx->aiColumn[i]>=0 );  assert( aiCol[i]!=pTab->iPKey );  if( pIdx->aiColumn[i]==pTab->iPKey ){  iParent = regData;  }  sqlite3VdbeAddOp3(v, OP_Ne, iChild, iJump, iParent); VdbeCoverage(v);  sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);  }  sqlite3VdbeGoto(v, iOk);  }  sqlite3VdbeAddOp4(v, OP_MakeRecord, regTemp, nCol, regRec,  sqlite3IndexAffinityStr(pParse->db,pIdx), nCol);  sqlite3VdbeAddOp4Int(v, OP_Found, iCur, iOk, regRec, 0); VdbeCoverage(v);  sqlite3ReleaseTempReg(pParse, regRec);  sqlite3ReleaseTempRange(pParse, regTemp, nCol);  }  }  if( !pFKey->isDeferred && !(pParse->db->flags & SQLITE_DeferFKs)   && !pParse->pToplevel   && !pParse->isMultiWrite  ){  assert( nIncr==1 );  sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,  OE_Abort, 0, P4_STATIC, P5_ConstraintFK);  }else{  if( nIncr>0 && pFKey->isDeferred==0 ){  sqlite3MayAbort(pParse);  }  sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);  }  sqlite3VdbeResolveLabel(v, iOk);  sqlite3VdbeAddOp1(v, OP_Close, iCur); } static Expr *exprTableRegister(  Parse *pParse,  Table *pTab,  int regBase,  i16 iCol ){  Expr *pExpr;  Column *pCol;  const char *zColl;  sqlite3 *db = pParse->db;  pExpr = sqlite3Expr(db, TK_REGISTER, 0);  if( pExpr ){  if( iCol>=0 && iCol!=pTab->iPKey ){  pCol = &pTab->aCol[iCol];  pExpr->iTable = regBase + sqlite3TableColumnToStorage(pTab,iCol) + 1;  pExpr->affExpr = pCol->affinity;  zColl = sqlite3ColumnColl(pCol);  if( zColl==0 ) zColl = db->pDfltColl->zName;  pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);  }else{  pExpr->iTable = regBase;  pExpr->affExpr = SQLITE_AFF_INTEGER;  }  }  return pExpr; } static Expr *exprTableColumn(  sqlite3 *db,  Table *pTab,  int iCursor,  i16 iCol ){  Expr *pExpr = sqlite3Expr(db, TK_COLUMN, 0);  if( pExpr ){  assert( ExprUseYTab(pExpr) );  pExpr->y.pTab = pTab;  pExpr->iTable = iCursor;  pExpr->iColumn = iCol;  }  return pExpr; } static void fkScanChildren(  Parse *pParse,  SrcList *pSrc,  Table *pTab,  Index *pIdx,  FKey *pFKey,  int *aiCol,  int regData,  int nIncr ){  sqlite3 *db = pParse->db;  int i;  Expr *pWhere = 0;  NameContext sNameContext;  WhereInfo *pWInfo;  int iFkIfZero = 0;  Vdbe *v = sqlite3GetVdbe(pParse);  assert( pIdx==0 || pIdx->pTable==pTab );  assert( pIdx==0 || pIdx->nKeyCol==pFKey->nCol );  assert( pIdx!=0 || pFKey->nCol==1 );  assert( pIdx!=0 || HasRowid(pTab) );  if( nIncr<0 ){  iFkIfZero = sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, 0);  VdbeCoverage(v);  }  for(i=0; i<pFKey->nCol; i++){  Expr *pLeft;  Expr *pRight;  Expr *pEq;  i16 iCol;  const char *zCol;  iCol = pIdx ? pIdx->aiColumn[i] : -1;  pLeft = exprTableRegister(pParse, pTab, regData, iCol);  iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;  assert( iCol>=0 );  zCol = pFKey->pFrom->aCol[iCol].zCnName;  pRight = sqlite3Expr(db, TK_ID, zCol);  pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight);  pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);  }  if( pTab==pFKey->pFrom && nIncr>0 ){  Expr *pNe;  Expr *pLeft;  Expr *pRight;  if( HasRowid(pTab) ){  pLeft = exprTableRegister(pParse, pTab, regData, -1);  pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);  pNe = sqlite3PExpr(pParse, TK_NE, pLeft, pRight);  }else{  Expr *pEq, *pAll = 0;  assert( pIdx!=0 );  for(i=0; i<pIdx->nKeyCol; i++){  i16 iCol = pIdx->aiColumn[i];  assert( iCol>=0 );  pLeft = exprTableRegister(pParse, pTab, regData, iCol);  pRight = sqlite3Expr(db, TK_ID, pTab->aCol[iCol].zCnName);  pEq = sqlite3PExpr(pParse, TK_IS, pLeft, pRight);  pAll = sqlite3ExprAnd(pParse, pAll, pEq);  }  pNe = sqlite3PExpr(pParse, TK_NOT, pAll, 0);  }  pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);  }  memset(&sNameContext, 0, sizeof(NameContext));  sNameContext.pSrcList = pSrc;  sNameContext.pParse = pParse;  sqlite3ResolveExprNames(&sNameContext, pWhere);  if( pParse->nErr==0 ){  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0);  sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);  if( pWInfo ){  sqlite3WhereEnd(pWInfo);  }  }  sqlite3ExprDelete(db, pWhere);  if( iFkIfZero ){  sqlite3VdbeJumpHereOrPopInst(v, iFkIfZero);  } } SQLITE_PRIVATE FKey *sqlite3FkReferences(Table *pTab){  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName); } static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){  if( p ){  TriggerStep *pStep = p->step_list;  sqlite3ExprDelete(dbMem, pStep->pWhere);  sqlite3ExprListDelete(dbMem, pStep->pExprList);  sqlite3SelectDelete(dbMem, pStep->pSelect);  sqlite3ExprDelete(dbMem, p->pWhen);  sqlite3DbFree(dbMem, p);  } } SQLITE_PRIVATE void sqlite3FkClearTriggerCache(sqlite3 *db, int iDb){  HashElem *k;  Hash *pHash = &db->aDb[iDb].pSchema->tblHash;  for(k=sqliteHashFirst(pHash); k; k=sqliteHashNext(k)){  Table *pTab = sqliteHashData(k);  FKey *pFKey;  if( !IsOrdinaryTable(pTab) ) continue;  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){  fkTriggerDelete(db, pFKey->apTrigger[0]); pFKey->apTrigger[0] = 0;  fkTriggerDelete(db, pFKey->apTrigger[1]); pFKey->apTrigger[1] = 0;  }  } } SQLITE_PRIVATE void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){  sqlite3 *db = pParse->db;  if( (db->flags&SQLITE_ForeignKeys) && IsOrdinaryTable(pTab) ){  int iSkip = 0;  Vdbe *v = sqlite3GetVdbe(pParse);  assert( v );  assert( IsOrdinaryTable(pTab) );  if( sqlite3FkReferences(pTab)==0 ){  FKey *p;  for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){  if( p->isDeferred || (db->flags & SQLITE_DeferFKs) ) break;  }  if( !p ) return;  iSkip = sqlite3VdbeMakeLabel(pParse);  sqlite3VdbeAddOp2(v, OP_FkIfZero, 1, iSkip); VdbeCoverage(v);  }  pParse->disableTriggers = 1;  sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0, 0, 0);  pParse->disableTriggers = 0;  if( (db->flags & SQLITE_DeferFKs)==0 ){  sqlite3VdbeVerifyAbortable(v, OE_Abort);  sqlite3VdbeAddOp2(v, OP_FkIfZero, 0, sqlite3VdbeCurrentAddr(v)+2);  VdbeCoverage(v);  sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_FOREIGNKEY,  OE_Abort, 0, P4_STATIC, P5_ConstraintFK);  }  if( iSkip ){  sqlite3VdbeResolveLabel(v, iSkip);  }  } } static int fkChildIsModified(  Table *pTab,  FKey *p,  int *aChange,  int bChngRowid ){  int i;  for(i=0; i<p->nCol; i++){  int iChildKey = p->aCol[i].iFrom;  if( aChange[iChildKey]>=0 ) return 1;  if( iChildKey==pTab->iPKey && bChngRowid ) return 1;  }  return 0; } static int fkParentIsModified(  Table *pTab,  FKey *p,  int *aChange,  int bChngRowid ){  int i;  for(i=0; i<p->nCol; i++){  char *zKey = p->aCol[i].zCol;  int iKey;  for(iKey=0; iKey<pTab->nCol; iKey++){  if( aChange[iKey]>=0 || (iKey==pTab->iPKey && bChngRowid) ){  Column *pCol = &pTab->aCol[iKey];  if( zKey ){  if( 0==sqlite3StrICmp(pCol->zCnName, zKey) ) return 1;  }else if( pCol->colFlags & COLFLAG_PRIMKEY ){  return 1;  }  }  }  }  return 0; } static int isSetNullAction(Parse *pParse, FKey *pFKey){  Parse *pTop = sqlite3ParseToplevel(pParse);  if( pTop->pTriggerPrg ){  Trigger *p = pTop->pTriggerPrg->pTrigger;  if( (p==pFKey->apTrigger[0] && pFKey->aAction[0]==OE_SetNull)   || (p==pFKey->apTrigger[1] && pFKey->aAction[1]==OE_SetNull)  ){  return 1;  }  }  return 0; } SQLITE_PRIVATE void sqlite3FkCheck(  Parse *pParse,  Table *pTab,  int regOld,  int regNew,  int *aChange,  int bChngRowid ){  sqlite3 *db = pParse->db;  FKey *pFKey;  int iDb;  const char *zDb;  int isIgnoreErrors = pParse->disableTriggers;  assert( (regOld==0)!=(regNew==0) );  if( (db->flags&SQLITE_ForeignKeys)==0 ) return;  if( !IsOrdinaryTable(pTab) ) return;  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  zDb = db->aDb[iDb].zDbSName;  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){  Table *pTo;  Index *pIdx = 0;  int *aiFree = 0;  int *aiCol;  int iCol;  int i;  int bIgnore = 0;  if( aChange   && sqlite3_stricmp(pTab->zName, pFKey->zTo)!=0   && fkChildIsModified(pTab, pFKey, aChange, bChngRowid)==0  ){  continue;  }  if( pParse->disableTriggers ){  pTo = sqlite3FindTable(db, pFKey->zTo, zDb);  }else{  pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);  }  if( !pTo || sqlite3FkLocateIndex(pParse, pTo, pFKey, &pIdx, &aiFree) ){  assert( isIgnoreErrors==0 || (regOld!=0 && regNew==0) );  if( !isIgnoreErrors || db->mallocFailed ) return;  if( pTo==0 ){  Vdbe *v = sqlite3GetVdbe(pParse);  int iJump = sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1;  for(i=0; i<pFKey->nCol; i++){  int iFromCol, iReg;  iFromCol = pFKey->aCol[i].iFrom;  iReg = sqlite3TableColumnToStorage(pFKey->pFrom,iFromCol) + regOld+1;  sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iJump); VdbeCoverage(v);  }  sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, -1);  }  continue;  }  assert( pFKey->nCol==1 || (aiFree && pIdx) );  if( aiFree ){  aiCol = aiFree;  }else{  iCol = pFKey->aCol[0].iFrom;  aiCol = &iCol;  }  for(i=0; i<pFKey->nCol; i++){  if( aiCol[i]==pTab->iPKey ){  aiCol[i] = -1;  }  assert( pIdx==0 || pIdx->aiColumn[i]>=0 );
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( db->xAuth ){  int rcauth;  char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zCnName;  rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);  bIgnore = (rcauth==SQLITE_IGNORE);  }
#endif
 }  sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);  pParse->nTab++;  if( regOld!=0 ){  fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore);  }  if( regNew!=0 && !isSetNullAction(pParse, pFKey) ){  fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1, bIgnore);  }  sqlite3DbFree(db, aiFree);  }  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){  Index *pIdx = 0;  SrcList *pSrc;  int *aiCol = 0;  if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){  continue;  }  if( !pFKey->isDeferred && !(db->flags & SQLITE_DeferFKs)   && !pParse->pToplevel && !pParse->isMultiWrite  ){  assert( regOld==0 && regNew!=0 );  continue;  }  if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){  if( !isIgnoreErrors || db->mallocFailed ) return;  continue;  }  assert( aiCol || pFKey->nCol==1 );  pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);  if( pSrc ){  SrcItem *pItem = pSrc->a;  pItem->pTab = pFKey->pFrom;  pItem->zName = pFKey->pFrom->zName;  pItem->pTab->nTabRef++;  pItem->iCursor = pParse->nTab++;  if( regNew!=0 ){  fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);  }  if( regOld!=0 ){  int eAction = pFKey->aAction[aChange!=0];  fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);  if( !pFKey->isDeferred && eAction!=OE_Cascade && eAction!=OE_SetNull ){  sqlite3MayAbort(pParse);  }  }  pItem->zName = 0;  sqlite3SrcListDelete(db, pSrc);  }  sqlite3DbFree(db, aiCol);  } }
#define COLUMN_MASK(x) (((x)>31) ? 0xffffffff : ((u32)1<<(x)))
SQLITE_PRIVATE u32 sqlite3FkOldmask(  Parse *pParse,  Table *pTab ){  u32 mask = 0;  if( pParse->db->flags&SQLITE_ForeignKeys && IsOrdinaryTable(pTab) ){  FKey *p;  int i;  for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){  for(i=0; i<p->nCol; i++) mask |= COLUMN_MASK(p->aCol[i].iFrom);  }  for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){  Index *pIdx = 0;  sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, 0);  if( pIdx ){  for(i=0; i<pIdx->nKeyCol; i++){  assert( pIdx->aiColumn[i]>=0 );  mask |= COLUMN_MASK(pIdx->aiColumn[i]);  }  }  }  }  return mask; } SQLITE_PRIVATE int sqlite3FkRequired(  Parse *pParse,  Table *pTab,  int *aChange,  int chngRowid ){  int eRet = 1;  int bHaveFK = 0;  if( pParse->db->flags&SQLITE_ForeignKeys && IsOrdinaryTable(pTab) ){  if( !aChange ){  bHaveFK = (sqlite3FkReferences(pTab) || pTab->u.tab.pFKey);  }else{  FKey *p;  for(p=pTab->u.tab.pFKey; p; p=p->pNextFrom){  if( fkChildIsModified(pTab, p, aChange, chngRowid) ){  if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) eRet = 2;  bHaveFK = 1;  }  }  for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){  if( fkParentIsModified(pTab, p, aChange, chngRowid) ){  if( p->aAction[1]!=OE_None ) return 2;  bHaveFK = 1;  }  }  }  }  return bHaveFK ? eRet : 0; } static Trigger *fkActionTrigger(  Parse *pParse,  Table *pTab,  FKey *pFKey,  ExprList *pChanges ){  sqlite3 *db = pParse->db;  int action;  Trigger *pTrigger;  int iAction = (pChanges!=0);  action = pFKey->aAction[iAction];  if( action==OE_Restrict && (db->flags & SQLITE_DeferFKs) ){  return 0;  }  pTrigger = pFKey->apTrigger[iAction];  if( action!=OE_None && !pTrigger ){  char const *zFrom;  int nFrom;  Index *pIdx = 0;  int *aiCol = 0;  TriggerStep *pStep = 0;  Expr *pWhere = 0;  ExprList *pList = 0;  Select *pSelect = 0;  int i;  Expr *pWhen = 0;  if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;  assert( aiCol || pFKey->nCol==1 );  for(i=0; i<pFKey->nCol; i++){  Token tOld = { "old", 3 };  Token tNew = { "new", 3 };  Token tFromCol;  Token tToCol;  int iFromCol;  Expr *pEq;  iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;  assert( iFromCol>=0 );  assert( pIdx!=0 || (pTab->iPKey>=0 && pTab->iPKey<pTab->nCol) );  assert( pIdx==0 || pIdx->aiColumn[i]>=0 );  sqlite3TokenInit(&tToCol,   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zCnName);  sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zCnName);  pEq = sqlite3PExpr(pParse, TK_EQ,  sqlite3PExpr(pParse, TK_DOT,  sqlite3ExprAlloc(db, TK_ID, &tOld, 0),  sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),  sqlite3ExprAlloc(db, TK_ID, &tFromCol, 0)  );  pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);  if( pChanges ){  pEq = sqlite3PExpr(pParse, TK_IS,  sqlite3PExpr(pParse, TK_DOT,  sqlite3ExprAlloc(db, TK_ID, &tOld, 0),  sqlite3ExprAlloc(db, TK_ID, &tToCol, 0)),  sqlite3PExpr(pParse, TK_DOT,  sqlite3ExprAlloc(db, TK_ID, &tNew, 0),  sqlite3ExprAlloc(db, TK_ID, &tToCol, 0))  );  pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);  }  if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){  Expr *pNew;  if( action==OE_Cascade ){  pNew = sqlite3PExpr(pParse, TK_DOT,  sqlite3ExprAlloc(db, TK_ID, &tNew, 0),  sqlite3ExprAlloc(db, TK_ID, &tToCol, 0));  }else if( action==OE_SetDflt ){  Column *pCol = pFKey->pFrom->aCol + iFromCol;  Expr *pDflt;  if( pCol->colFlags & COLFLAG_GENERATED ){  testcase( pCol->colFlags & COLFLAG_VIRTUAL );  testcase( pCol->colFlags & COLFLAG_STORED );  pDflt = 0;  }else{  pDflt = sqlite3ColumnExpr(pFKey->pFrom, pCol);  }  if( pDflt ){  pNew = sqlite3ExprDup(db, pDflt, 0);  }else{  pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);  }  }else{  pNew = sqlite3ExprAlloc(db, TK_NULL, 0, 0);  }  pList = sqlite3ExprListAppend(pParse, pList, pNew);  sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);  }  }  sqlite3DbFree(db, aiCol);  zFrom = pFKey->pFrom->zName;  nFrom = sqlite3Strlen30(zFrom);  if( action==OE_Restrict ){  Token tFrom;  Expr *pRaise;  tFrom.z = zFrom;  tFrom.n = nFrom;  pRaise = sqlite3Expr(db, TK_RAISE, "FOREIGN KEY constraint failed");  if( pRaise ){  pRaise->affExpr = OE_Abort;  }  pSelect = sqlite3SelectNew(pParse,  sqlite3ExprListAppend(pParse, 0, pRaise),  sqlite3SrcListAppend(pParse, 0, &tFrom, 0),  pWhere,  0, 0, 0, 0, 0  );  pWhere = 0;  }  DisableLookaside;  pTrigger = (Trigger *)sqlite3DbMallocZero(db,  sizeof(Trigger) +  sizeof(TriggerStep) +  nFrom + 1  );  if( pTrigger ){  pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];  pStep->zTarget = (char *)&pStep[1];  memcpy((char *)pStep->zTarget, zFrom, nFrom);  pStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);  pStep->pExprList = sqlite3ExprListDup(db, pList, EXPRDUP_REDUCE);  pStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);  if( pWhen ){  pWhen = sqlite3PExpr(pParse, TK_NOT, pWhen, 0);  pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);  }  }  EnableLookaside;  sqlite3ExprDelete(db, pWhere);  sqlite3ExprDelete(db, pWhen);  sqlite3ExprListDelete(db, pList);  sqlite3SelectDelete(db, pSelect);  if( db->mallocFailed==1 ){  fkTriggerDelete(db, pTrigger);  return 0;  }  assert( pStep!=0 );  assert( pTrigger!=0 );  switch( action ){  case OE_Restrict:  pStep->op = TK_SELECT;  break;  case OE_Cascade:  if( !pChanges ){  pStep->op = TK_DELETE;  break;  }   deliberate_fall_through  default:  pStep->op = TK_UPDATE;  }  pStep->pTrig = pTrigger;  pTrigger->pSchema = pTab->pSchema;  pTrigger->pTabSchema = pTab->pSchema;  pFKey->apTrigger[iAction] = pTrigger;  pTrigger->op = (pChanges ? TK_UPDATE : TK_DELETE);  }  return pTrigger; } SQLITE_PRIVATE void sqlite3FkActions(  Parse *pParse,  Table *pTab,  ExprList *pChanges,  int regOld,  int *aChange,  int bChngRowid ){  if( pParse->db->flags&SQLITE_ForeignKeys ){  FKey *pFKey;  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){  if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){  Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);  if( pAct ){  sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, OE_Abort, 0);  }  }  }  } }
#endif
SQLITE_PRIVATE void sqlite3FkDelete(sqlite3 *db, Table *pTab){  FKey *pFKey;  FKey *pNext;  assert( IsOrdinaryTable(pTab) );  for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pNext){  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, pTab->pSchema) );  if( !db || db->pnBytesFreed==0 ){  if( pFKey->pPrevTo ){  pFKey->pPrevTo->pNextTo = pFKey->pNextTo;  }else{  void *p = (void *)pFKey->pNextTo;  const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);  sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, p);  }  if( pFKey->pNextTo ){  pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;  }  }  assert( pFKey->isDeferred==0 || pFKey->isDeferred==1 );
#ifndef SQLITE_OMIT_TRIGGER
 fkTriggerDelete(db, pFKey->apTrigger[0]);  fkTriggerDelete(db, pFKey->apTrigger[1]);
#endif
 pNext = pFKey->pNextFrom;  sqlite3DbFree(db, pFKey);  } }
#endif
SQLITE_PRIVATE void sqlite3OpenTable(  Parse *pParse,  int iCur,  int iDb,  Table *pTab,  int opcode ){  Vdbe *v;  assert( !IsVirtual(pTab) );  assert( pParse->pVdbe!=0 );  v = pParse->pVdbe;  assert( opcode==OP_OpenWrite || opcode==OP_OpenRead );  sqlite3TableLock(pParse, iDb, pTab->tnum,   (opcode==OP_OpenWrite)?1:0, pTab->zName);  if( HasRowid(pTab) ){  sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nNVCol);  VdbeComment((v, "%s", pTab->zName));  }else{  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  assert( pPk!=0 );  assert( pPk->tnum==pTab->tnum || CORRUPT_DB );  sqlite3VdbeAddOp3(v, opcode, iCur, pPk->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pPk);  VdbeComment((v, "%s", pTab->zName));  } } SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){  if( !pIdx->zColAff ){  int n;  Table *pTab = pIdx->pTable;  pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);  if( !pIdx->zColAff ){  sqlite3OomFault(db);  return 0;  }  for(n=0; n<pIdx->nColumn; n++){  i16 x = pIdx->aiColumn[n];  char aff;  if( x>=0 ){  aff = pTab->aCol[x].affinity;  }else if( x==XN_ROWID ){  aff = SQLITE_AFF_INTEGER;  }else{  assert( x==XN_EXPR );  assert( pIdx->aColExpr!=0 );  aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);  }  if( aff<SQLITE_AFF_BLOB ) aff = SQLITE_AFF_BLOB;  if( aff>SQLITE_AFF_NUMERIC) aff = SQLITE_AFF_NUMERIC;  pIdx->zColAff[n] = aff;  }  pIdx->zColAff[n] = 0;  }  return pIdx->zColAff; } SQLITE_PRIVATE void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){  int i, j;  char *zColAff;  if( pTab->tabFlags & TF_Strict ){  if( iReg==0 ){  VdbeOp *pPrev;  sqlite3VdbeAppendP4(v, pTab, P4_TABLE);  pPrev = sqlite3VdbeGetOp(v, -1);  assert( pPrev!=0 );  assert( pPrev->opcode==OP_MakeRecord || sqlite3VdbeDb(v)->mallocFailed );  pPrev->opcode = OP_TypeCheck;  sqlite3VdbeAddOp3(v, OP_MakeRecord, pPrev->p1, pPrev->p2, pPrev->p3);  }else{  sqlite3VdbeAddOp2(v, OP_TypeCheck, iReg, pTab->nNVCol);  sqlite3VdbeAppendP4(v, pTab, P4_TABLE);  }  return;  }  zColAff = pTab->zColAff;  if( zColAff==0 ){  sqlite3 *db = sqlite3VdbeDb(v);  zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol+1);  if( !zColAff ){  sqlite3OomFault(db);  return;  }  for(i=j=0; i<pTab->nCol; i++){  assert( pTab->aCol[i].affinity!=0 );  if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){  zColAff[j++] = pTab->aCol[i].affinity;  }  }  do{  zColAff[j--] = 0;  }while( j>=0 && zColAff[j]<=SQLITE_AFF_BLOB );  pTab->zColAff = zColAff;  }  assert( zColAff!=0 );  i = sqlite3Strlen30NN(zColAff);  if( i ){  if( iReg ){  sqlite3VdbeAddOp4(v, OP_Affinity, iReg, i, 0, zColAff, i);  }else{  assert( sqlite3VdbeGetOp(v, -1)->opcode==OP_MakeRecord  || sqlite3VdbeDb(v)->mallocFailed );  sqlite3VdbeChangeP4(v, -1, zColAff, i);  }  } } static int readsTable(Parse *p, int iDb, Table *pTab){  Vdbe *v = sqlite3GetVdbe(p);  int i;  int iEnd = sqlite3VdbeCurrentAddr(v);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;
#endif
 for(i=1; i<iEnd; i++){  VdbeOp *pOp = sqlite3VdbeGetOp(v, i);  assert( pOp!=0 );  if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){  Index *pIndex;  Pgno tnum = pOp->p2;  if( tnum==pTab->tnum ){  return 1;  }  for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){  if( tnum==pIndex->tnum ){  return 1;  }  }  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( pOp->opcode==OP_VOpen && pOp->p4.pVtab==pVTab ){  assert( pOp->p4.pVtab!=0 );  assert( pOp->p4type==P4_VTAB );  return 1;  }
#endif
 }  return 0; } static int exprColumnFlagUnion(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 ){  assert( pExpr->iColumn < pWalker->u.pTab->nCol );  pWalker->eCode |= pWalker->u.pTab->aCol[pExpr->iColumn].colFlags;  }  return WRC_Continue; }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
SQLITE_PRIVATE void sqlite3ComputeGeneratedColumns(  Parse *pParse,  int iRegStore,  Table *pTab ){  int i;  Walker w;  Column *pRedo;  int eProgress;  VdbeOp *pOp;  assert( pTab->tabFlags & TF_HasGenerated );  testcase( pTab->tabFlags & TF_HasVirtual );  testcase( pTab->tabFlags & TF_HasStored );  sqlite3TableAffinity(pParse->pVdbe, pTab, iRegStore);  if( (pTab->tabFlags & TF_HasStored)!=0 ){  pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);  if( pOp->opcode==OP_Affinity ){  int ii, jj;  char *zP4 = pOp->p4.z;  assert( zP4!=0 );  assert( pOp->p4type==P4_DYNAMIC );  for(ii=jj=0; zP4[jj]; ii++){  if( pTab->aCol[ii].colFlags & COLFLAG_VIRTUAL ){  continue;  }  if( pTab->aCol[ii].colFlags & COLFLAG_STORED ){  zP4[jj] = SQLITE_AFF_NONE;  }  jj++;  }  }else if( pOp->opcode==OP_TypeCheck ){  pOp->p3 = 1;  }  }  for(i=0; i<pTab->nCol; i++){  if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){  testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );  testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );  pTab->aCol[i].colFlags |= COLFLAG_NOTAVAIL;  }  }  w.u.pTab = pTab;  w.xExprCallback = exprColumnFlagUnion;  w.xSelectCallback = 0;  w.xSelectCallback2 = 0;  pParse->iSelfTab = -iRegStore;  do{  eProgress = 0;  pRedo = 0;  for(i=0; i<pTab->nCol; i++){  Column *pCol = pTab->aCol + i;  if( (pCol->colFlags & COLFLAG_NOTAVAIL)!=0 ){  int x;  pCol->colFlags |= COLFLAG_BUSY;  w.eCode = 0;  sqlite3WalkExpr(&w, sqlite3ColumnExpr(pTab, pCol));  pCol->colFlags &= ~COLFLAG_BUSY;  if( w.eCode & COLFLAG_NOTAVAIL ){  pRedo = pCol;  continue;  }  eProgress = 1;  assert( pCol->colFlags & COLFLAG_GENERATED );  x = sqlite3TableColumnToStorage(pTab, i) + iRegStore;  sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, x);  pCol->colFlags &= ~COLFLAG_NOTAVAIL;  }  }  }while( pRedo && eProgress );  if( pRedo ){  sqlite3ErrorMsg(pParse, "generated column loop on \"%s\"", pRedo->zCnName);  }  pParse->iSelfTab = 0; }
#endif
#ifndef SQLITE_OMIT_AUTOINCREMENT
static int autoIncBegin(  Parse *pParse,  int iDb,  Table *pTab ){  int memId = 0;  assert( pParse->db->aDb[iDb].pSchema!=0 );  if( (pTab->tabFlags & TF_Autoincrement)!=0   && (pParse->db->mDbFlags & DBFLAG_Vacuum)==0  ){  Parse *pToplevel = sqlite3ParseToplevel(pParse);  AutoincInfo *pInfo;  Table *pSeqTab = pParse->db->aDb[iDb].pSchema->pSeqTab;  if( pSeqTab==0   || !HasRowid(pSeqTab)   || NEVER(IsVirtual(pSeqTab))   || pSeqTab->nCol!=2  ){  pParse->nErr++;  pParse->rc = SQLITE_CORRUPT_SEQUENCE;  return 0;  }  pInfo = pToplevel->pAinc;  while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }  if( pInfo==0 ){  pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));  sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, pInfo);  testcase( pParse->earlyCleanup );  if( pParse->db->mallocFailed ) return 0;  pInfo->pNext = pToplevel->pAinc;  pToplevel->pAinc = pInfo;  pInfo->pTab = pTab;  pInfo->iDb = iDb;  pToplevel->nMem++;  pInfo->regCtr = ++pToplevel->nMem;  pToplevel->nMem +=2;  }  memId = pInfo->regCtr;  }  return memId; } SQLITE_PRIVATE void sqlite3AutoincrementBegin(Parse *pParse){  AutoincInfo *p;  sqlite3 *db = pParse->db;  Db *pDb;  int memId;  Vdbe *v = pParse->pVdbe;  assert( pParse->pTriggerTab==0 );  assert( sqlite3IsToplevel(pParse) );  assert( v );  for(p = pParse->pAinc; p; p = p->pNext){  static const int iLn = VDBE_OFFSET_LINENO(2);  static const VdbeOpList autoInc[] = {  {OP_Null, 0, 0, 0},  {OP_Rewind, 0, 10, 0},  {OP_Column, 0, 0, 0},  {OP_Ne, 0, 9, 0},  {OP_Rowid, 0, 0, 0},  {OP_Column, 0, 1, 0},  {OP_AddImm, 0, 0, 0},  {OP_Copy, 0, 0, 0},  {OP_Goto, 0, 11, 0},  {OP_Next, 0, 2, 0},  {OP_Integer, 0, 0, 0},  {OP_Close, 0, 0, 0}  };  VdbeOp *aOp;  pDb = &db->aDb[p->iDb];  memId = p->regCtr;  assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );  sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenRead);  sqlite3VdbeLoadString(v, memId-1, p->pTab->zName);  aOp = sqlite3VdbeAddOpList(v, ArraySize(autoInc), autoInc, iLn);  if( aOp==0 ) break;  aOp[0].p2 = memId;  aOp[0].p3 = memId+2;  aOp[2].p3 = memId;  aOp[3].p1 = memId-1;  aOp[3].p3 = memId;  aOp[3].p5 = SQLITE_JUMPIFNULL;  aOp[4].p2 = memId+1;  aOp[5].p3 = memId;  aOp[6].p1 = memId;  aOp[7].p2 = memId+2;  aOp[7].p1 = memId;  aOp[10].p2 = memId;  if( pParse->nTab==0 ) pParse->nTab = 1;  } } static void autoIncStep(Parse *pParse, int memId, int regRowid){  if( memId>0 ){  sqlite3VdbeAddOp2(pParse->pVdbe, OP_MemMax, memId, regRowid);  } } static SQLITE_NOINLINE void autoIncrementEnd(Parse *pParse){  AutoincInfo *p;  Vdbe *v = pParse->pVdbe;  sqlite3 *db = pParse->db;  assert( v );  for(p = pParse->pAinc; p; p = p->pNext){  static const int iLn = VDBE_OFFSET_LINENO(2);  static const VdbeOpList autoIncEnd[] = {  {OP_NotNull, 0, 2, 0},  {OP_NewRowid, 0, 0, 0},  {OP_MakeRecord, 0, 2, 0},  {OP_Insert, 0, 0, 0},  {OP_Close, 0, 0, 0}  };  VdbeOp *aOp;  Db *pDb = &db->aDb[p->iDb];  int iRec;  int memId = p->regCtr;  iRec = sqlite3GetTempReg(pParse);  assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );  sqlite3VdbeAddOp3(v, OP_Le, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId);  VdbeCoverage(v);  sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);  aOp = sqlite3VdbeAddOpList(v, ArraySize(autoIncEnd), autoIncEnd, iLn);  if( aOp==0 ) break;  aOp[0].p1 = memId+1;  aOp[1].p2 = memId+1;  aOp[2].p1 = memId-1;  aOp[2].p3 = iRec;  aOp[3].p2 = iRec;  aOp[3].p3 = memId+1;  aOp[3].p5 = OPFLAG_APPEND;  sqlite3ReleaseTempReg(pParse, iRec);  } } SQLITE_PRIVATE void sqlite3AutoincrementEnd(Parse *pParse){  if( pParse->pAinc ) autoIncrementEnd(pParse); }
#else
# define autoIncBegin(A,B,C) (0)
# define autoIncStep(A,B,C)
#endif
static int xferOptimization(  Parse *pParse,  Table *pDest,  Select *pSelect,  int onError,  int iDbDest ); SQLITE_PRIVATE void sqlite3Insert(  Parse *pParse,  SrcList *pTabList,  Select *pSelect,  IdList *pColumn,  int onError,  Upsert *pUpsert ){  sqlite3 *db;  Table *pTab;  int i, j;  Vdbe *v;  Index *pIdx;  int nColumn;  int nHidden = 0;  int iDataCur = 0;  int iIdxCur = 0;  int ipkColumn = -1;  int endOfLoop;  int srcTab = 0;  int addrInsTop = 0;  int addrCont = 0;  SelectDest dest;  int iDb;  u8 useTempTable = 0;  u8 appendFlag = 0;  u8 withoutRowid;  u8 bIdListInOrder;  ExprList *pList = 0;  int iRegStore;  int regFromSelect = 0;  int regAutoinc = 0;  int regRowCount = 0;  int regIns;  int regRowid;  int regData;  int *aRegIdx = 0;
#ifndef SQLITE_OMIT_TRIGGER
 int isView;  Trigger *pTrigger;  int tmask;
#endif
 db = pParse->db;  if( pParse->nErr || db->mallocFailed ){  goto insert_cleanup;  }  dest.iSDParm = 0;  if( pSelect && (pSelect->selFlags & SF_Values)!=0 && pSelect->pPrior==0 ){  pList = pSelect->pEList;  pSelect->pEList = 0;  sqlite3SelectDelete(db, pSelect);  pSelect = 0;  }  assert( pTabList->nSrc==1 );  pTab = sqlite3SrcListLookup(pParse, pTabList);  if( pTab==0 ){  goto insert_cleanup;  }  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  assert( iDb<db->nDb );  if( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab->zName, 0,   db->aDb[iDb].zDbSName) ){  goto insert_cleanup;  }  withoutRowid = !HasRowid(pTab);
#ifndef SQLITE_OMIT_TRIGGER
 pTrigger = sqlite3TriggersExist(pParse, pTab, TK_INSERT, 0, &tmask);  isView = IsView(pTab);
#else
# define pTrigger 0
# define tmask 0
# define isView 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif
 assert( (pTrigger && tmask) || (pTrigger==0 && tmask==0) );  if( sqlite3ViewGetColumnNames(pParse, pTab) ){  goto insert_cleanup;  }  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){  goto insert_cleanup;  }  v = sqlite3GetVdbe(pParse);  if( v==0 ) goto insert_cleanup;  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);  sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);
#ifndef SQLITE_OMIT_XFER_OPT
 if( pColumn==0 && xferOptimization(pParse, pTab, pSelect, onError, iDb) ){  assert( !pTrigger );  assert( pList==0 );  goto insert_end;  }
#endif
 regAutoinc = autoIncBegin(pParse, iDb, pTab);  regRowid = regIns = pParse->nMem+1;  pParse->nMem += pTab->nCol + 1;  if( IsVirtual(pTab) ){  regRowid++;  pParse->nMem++;  }  regData = regRowid+1;  bIdListInOrder = (pTab->tabFlags & (TF_OOOHidden|TF_HasStored))==0;  if( pColumn ){  for(i=0; i<pColumn->nId; i++){  pColumn->a[i].idx = -1;  }  for(i=0; i<pColumn->nId; i++){  for(j=0; j<pTab->nCol; j++){  if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zCnName)==0 ){  pColumn->a[i].idx = j;  if( i!=j ) bIdListInOrder = 0;  if( j==pTab->iPKey ){  ipkColumn = i; assert( !withoutRowid );  }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pTab->aCol[j].colFlags & (COLFLAG_STORED|COLFLAG_VIRTUAL) ){  sqlite3ErrorMsg(pParse,   "cannot INSERT into generated column \"%s\"",   pTab->aCol[j].zCnName);  goto insert_cleanup;  }
#endif
 break;  }  }  if( j>=pTab->nCol ){  if( sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid ){  ipkColumn = i;  bIdListInOrder = 0;  }else{  sqlite3ErrorMsg(pParse, "table %S has no column named %s",  pTabList->a, pColumn->a[i].zName);  pParse->checkSchema = 1;  goto insert_cleanup;  }  }  }  }  if( pSelect ){  int regYield;  int addrTop;  int rc;  regYield = ++pParse->nMem;  addrTop = sqlite3VdbeCurrentAddr(v) + 1;  sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);  sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);  dest.iSdst = bIdListInOrder ? regData : 0;  dest.nSdst = pTab->nCol;  rc = sqlite3Select(pParse, pSelect, &dest);  regFromSelect = dest.iSdst;  if( rc || db->mallocFailed || pParse->nErr ) goto insert_cleanup;  sqlite3VdbeEndCoroutine(v, regYield);  sqlite3VdbeJumpHere(v, addrTop - 1);  assert( pSelect->pEList );  nColumn = pSelect->pEList->nExpr;  if( pTrigger || readsTable(pParse, iDb, pTab) ){  useTempTable = 1;  }  if( useTempTable ){  int regRec;  int regTempRowid;  int addrL;  srcTab = pParse->nTab++;  regRec = sqlite3GetTempReg(pParse);  regTempRowid = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, srcTab, nColumn);  addrL = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm); VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_MakeRecord, regFromSelect, nColumn, regRec);  sqlite3VdbeAddOp2(v, OP_NewRowid, srcTab, regTempRowid);  sqlite3VdbeAddOp3(v, OP_Insert, srcTab, regRec, regTempRowid);  sqlite3VdbeGoto(v, addrL);  sqlite3VdbeJumpHere(v, addrL);  sqlite3ReleaseTempReg(pParse, regRec);  sqlite3ReleaseTempReg(pParse, regTempRowid);  }  }else{  NameContext sNC;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  srcTab = -1;  assert( useTempTable==0 );  if( pList ){  nColumn = pList->nExpr;  if( sqlite3ResolveExprListNames(&sNC, pList) ){  goto insert_cleanup;  }  }else{  nColumn = 0;  }  }  if( pColumn==0 && nColumn>0 ){  ipkColumn = pTab->iPKey;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( ipkColumn>=0 && (pTab->tabFlags & TF_HasGenerated)!=0 ){  testcase( pTab->tabFlags & TF_HasVirtual );  testcase( pTab->tabFlags & TF_HasStored );  for(i=ipkColumn-1; i>=0; i--){  if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){  testcase( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL );  testcase( pTab->aCol[i].colFlags & COLFLAG_STORED );  ipkColumn--;  }  }  }
#endif
 assert( TF_HasHidden==COLFLAG_HIDDEN );  assert( TF_HasGenerated==COLFLAG_GENERATED );  assert( COLFLAG_NOINSERT==(COLFLAG_GENERATED|COLFLAG_HIDDEN) );  if( (pTab->tabFlags & (TF_HasGenerated|TF_HasHidden))!=0 ){  for(i=0; i<pTab->nCol; i++){  if( pTab->aCol[i].colFlags & COLFLAG_NOINSERT ) nHidden++;  }  }  if( nColumn!=(pTab->nCol-nHidden) ){  sqlite3ErrorMsg(pParse,   "table %S has %d columns but %d values were supplied",   pTabList->a, pTab->nCol-nHidden, nColumn);   goto insert_cleanup;  }  }  if( pColumn!=0 && nColumn!=pColumn->nId ){  sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);  goto insert_cleanup;  }  if( (db->flags & SQLITE_CountRows)!=0   && !pParse->nested   && !pParse->pTriggerTab   && !pParse->bReturning  ){  regRowCount = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);  }  if( !isView ){  int nIdx;  nIdx = sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, -1, 0,  &iDataCur, &iIdxCur);  aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));  if( aRegIdx==0 ){  goto insert_cleanup;  }  for(i=0, pIdx=pTab->pIndex; i<nIdx; pIdx=pIdx->pNext, i++){  assert( pIdx );  aRegIdx[i] = ++pParse->nMem;  pParse->nMem += pIdx->nColumn;  }  aRegIdx[i] = ++pParse->nMem;  }
#ifndef SQLITE_OMIT_UPSERT
 if( pUpsert ){  Upsert *pNx;  if( IsVirtual(pTab) ){  sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"",  pTab->zName);  goto insert_cleanup;  }  if( IsView(pTab) ){  sqlite3ErrorMsg(pParse, "cannot UPSERT a view");  goto insert_cleanup;  }  if( sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget) ){  goto insert_cleanup;  }  pTabList->a[0].iCursor = iDataCur;  pNx = pUpsert;  do{  pNx->pUpsertSrc = pTabList;  pNx->regData = regData;  pNx->iDataCur = iDataCur;  pNx->iIdxCur = iIdxCur;  if( pNx->pUpsertTarget ){  if( sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx) ){  goto insert_cleanup;  }  }  pNx = pNx->pNextUpsert;  }while( pNx!=0 );  }
#endif
 if( useTempTable ){  addrInsTop = sqlite3VdbeAddOp1(v, OP_Rewind, srcTab); VdbeCoverage(v);  addrCont = sqlite3VdbeCurrentAddr(v);  }else if( pSelect ){  sqlite3VdbeReleaseRegisters(pParse, regData, pTab->nCol, 0, 0);  addrInsTop = addrCont = sqlite3VdbeAddOp1(v, OP_Yield, dest.iSDParm);  VdbeCoverage(v);  if( ipkColumn>=0 ){  sqlite3VdbeAddOp2(v, OP_Copy, regFromSelect+ipkColumn, regRowid);  }  }  nHidden = 0;  iRegStore = regData; assert( regData==regRowid+1 );  for(i=0; i<pTab->nCol; i++, iRegStore++){  int k;  u32 colFlags;  assert( i>=nHidden );  if( i==pTab->iPKey ){  sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);  continue;  }  if( ((colFlags = pTab->aCol[i].colFlags) & COLFLAG_NOINSERT)!=0 ){  nHidden++;  if( (colFlags & COLFLAG_VIRTUAL)!=0 ){  iRegStore--;  continue;  }else if( (colFlags & COLFLAG_STORED)!=0 ){  if( tmask & TRIGGER_BEFORE ){  sqlite3VdbeAddOp1(v, OP_SoftNull, iRegStore);  }  continue;  }else if( pColumn==0 ){  sqlite3ExprCodeFactorable(pParse,  sqlite3ColumnExpr(pTab, &pTab->aCol[i]),  iRegStore);  continue;  }  }  if( pColumn ){  for(j=0; j<pColumn->nId && pColumn->a[j].idx!=i; j++){}  if( j>=pColumn->nId ){  sqlite3ExprCodeFactorable(pParse,  sqlite3ColumnExpr(pTab, &pTab->aCol[i]),  iRegStore);  continue;  }  k = j;  }else if( nColumn==0 ){  sqlite3ExprCodeFactorable(pParse,  sqlite3ColumnExpr(pTab, &pTab->aCol[i]),  iRegStore);  continue;  }else{  k = i - nHidden;  }  if( useTempTable ){  sqlite3VdbeAddOp3(v, OP_Column, srcTab, k, iRegStore);  }else if( pSelect ){  if( regFromSelect!=regData ){  sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+k, iRegStore);  }  }else{  sqlite3ExprCode(pParse, pList->a[k].pExpr, iRegStore);  }  }  endOfLoop = sqlite3VdbeMakeLabel(pParse);  if( tmask & TRIGGER_BEFORE ){  int regCols = sqlite3GetTempRange(pParse, pTab->nCol+1);  if( ipkColumn<0 ){  sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);  }else{  int addr1;  assert( !withoutRowid );  if( useTempTable ){  sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regCols);  }else{  assert( pSelect==0 );  sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);  }  addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regCols); VdbeCoverage(v);  sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);  sqlite3VdbeJumpHere(v, addr1);  sqlite3VdbeAddOp1(v, OP_MustBeInt, regCols); VdbeCoverage(v);  }  assert( pTab->nNVCol>0 );  sqlite3VdbeAddOp3(v, OP_Copy, regRowid+1, regCols+1, pTab->nNVCol-1);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pTab->tabFlags & TF_HasGenerated ){  testcase( pTab->tabFlags & TF_HasVirtual );  testcase( pTab->tabFlags & TF_HasStored );  sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab);  }
#endif
 if( !isView ){  sqlite3TableAffinity(v, pTab, regCols+1);  }  sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_BEFORE,  pTab, regCols-pTab->nCol-1, onError, endOfLoop);  sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);  }  if( !isView ){  if( IsVirtual(pTab) ){  sqlite3VdbeAddOp2(v, OP_Null, 0, regIns);  }  if( ipkColumn>=0 ){  if( useTempTable ){  sqlite3VdbeAddOp3(v, OP_Column, srcTab, ipkColumn, regRowid);  }else if( pSelect ){  }else{  Expr *pIpk = pList->a[ipkColumn].pExpr;  if( pIpk->op==TK_NULL && !IsVirtual(pTab) ){  sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);  appendFlag = 1;  }else{  sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);  }  }  if( !appendFlag ){  int addr1;  if( !IsVirtual(pTab) ){  addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid); VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);  sqlite3VdbeJumpHere(v, addr1);  }else{  addr1 = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, addr1+2); VdbeCoverage(v);  }  sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid); VdbeCoverage(v);  }  }else if( IsVirtual(pTab) || withoutRowid ){  sqlite3VdbeAddOp2(v, OP_Null, 0, regRowid);  }else{  sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);  appendFlag = 1;  }  autoIncStep(pParse, regAutoinc, regRowid);
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pTab->tabFlags & TF_HasGenerated ){  sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab);  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);  sqlite3VtabMakeWritable(pParse, pTab);  sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol+2, regIns, pVTab, P4_VTAB);  sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);  sqlite3MayAbort(pParse);  }else
#endif
 {  int isReplace = 0;  int bUseSeek;  sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,  regIns, 0, ipkColumn>=0, onError, endOfLoop, &isReplace, 0, pUpsert  );  sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);  bUseSeek = (isReplace==0 || !sqlite3VdbeHasSubProgram(v));  sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,  regIns, aRegIdx, 0, appendFlag, bUseSeek  );  }
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
 }else if( pParse->bReturning ){  sqlite3VdbeAddOp2(v, OP_Integer, -1, regRowid);
#endif
 }  if( regRowCount ){  sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);  }  if( pTrigger ){  sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_AFTER,  pTab, regData-2-pTab->nCol, onError, endOfLoop);  }  sqlite3VdbeResolveLabel(v, endOfLoop);  if( useTempTable ){  sqlite3VdbeAddOp2(v, OP_Next, srcTab, addrCont); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addrInsTop);  sqlite3VdbeAddOp1(v, OP_Close, srcTab);  }else if( pSelect ){  sqlite3VdbeGoto(v, addrCont);
#ifdef SQLITE_DEBUG
 if( sqlite3VdbeGetOp(v, addrCont-1)->opcode==OP_ReleaseReg ){  assert( sqlite3VdbeGetOp(v, addrCont)->opcode==OP_Yield );  sqlite3VdbeChangeP5(v, 1);  }
#endif
 sqlite3VdbeJumpHere(v, addrInsTop);  }
#ifndef SQLITE_OMIT_XFER_OPT
insert_end:
#endif
 if( pParse->nested==0 && pParse->pTriggerTab==0 ){  sqlite3AutoincrementEnd(pParse);  }  if( regRowCount ){  sqlite3VdbeAddOp2(v, OP_ChngCntRow, regRowCount, 1);  sqlite3VdbeSetNumCols(v, 1);  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows inserted", SQLITE_STATIC);  } insert_cleanup:  sqlite3SrcListDelete(db, pTabList);  sqlite3ExprListDelete(db, pList);  sqlite3UpsertDelete(db, pUpsert);  sqlite3SelectDelete(db, pSelect);  sqlite3IdListDelete(db, pColumn);  sqlite3DbFree(db, aRegIdx); }
#ifdef isView
 #undef isView
#endif
#ifdef pTrigger
 #undef pTrigger
#endif
#ifdef tmask
 #undef tmask
#endif
#define CKCNSTRNT_COLUMN  0x01
#define CKCNSTRNT_ROWID 0x02
static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_COLUMN ){  assert( pExpr->iColumn>=0 || pExpr->iColumn==-1 );  if( pExpr->iColumn>=0 ){  if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){  pWalker->eCode |= CKCNSTRNT_COLUMN;  }  }else{  pWalker->eCode |= CKCNSTRNT_ROWID;  }  }  return WRC_Continue; } SQLITE_PRIVATE int sqlite3ExprReferencesUpdatedColumn(  Expr *pExpr,  int *aiChng,  int chngRowid ){  Walker w;  memset(&w, 0, sizeof(w));  w.eCode = 0;  w.xExprCallback = checkConstraintExprNode;  w.u.aiCol = aiChng;  sqlite3WalkExpr(&w, pExpr);  if( !chngRowid ){  testcase( (w.eCode & CKCNSTRNT_ROWID)!=0 );  w.eCode &= ~CKCNSTRNT_ROWID;  }  testcase( w.eCode==0 );  testcase( w.eCode==CKCNSTRNT_COLUMN );  testcase( w.eCode==CKCNSTRNT_ROWID );  testcase( w.eCode==(CKCNSTRNT_ROWID|CKCNSTRNT_COLUMN) );  return w.eCode!=0; } typedef struct IndexListTerm IndexListTerm; typedef struct IndexIterator IndexIterator; struct IndexIterator {  int eType;  int i;  union {  struct {  Index *pIdx;  } lx;  struct {  int nIdx;  IndexListTerm *aIdx;  } ax;  } u; }; struct IndexListTerm {  Index *p;  int ix; }; static Index *indexIteratorFirst(IndexIterator *pIter, int *pIx){  assert( pIter->i==0 );  if( pIter->eType ){  *pIx = pIter->u.ax.aIdx[0].ix;  return pIter->u.ax.aIdx[0].p;  }else{  *pIx = 0;  return pIter->u.lx.pIdx;  } } static Index *indexIteratorNext(IndexIterator *pIter, int *pIx){  if( pIter->eType ){  int i = ++pIter->i;  if( i>=pIter->u.ax.nIdx ){  *pIx = i;  return 0;  }  *pIx = pIter->u.ax.aIdx[i].ix;  return pIter->u.ax.aIdx[i].p;  }else{  ++(*pIx);  pIter->u.lx.pIdx = pIter->u.lx.pIdx->pNext;  return pIter->u.lx.pIdx;  } } SQLITE_PRIVATE void sqlite3GenerateConstraintChecks(  Parse *pParse,  Table *pTab,  int *aRegIdx,  int iDataCur,  int iIdxCur,  int regNewData,  int regOldData,  u8 pkChng,  u8 overrideError,  int ignoreDest,  int *pbMayReplace,  int *aiChng,  Upsert *pUpsert ){  Vdbe *v;  Index *pIdx;  Index *pPk = 0;  sqlite3 *db;  int i;  int ix;  int nCol;  int onError;  int seenReplace = 0;  int nPkField;  Upsert *pUpsertClause = 0;  u8 isUpdate;  u8 bAffinityDone = 0;  int upsertIpkReturn = 0;  int upsertIpkDelay = 0;  int ipkTop = 0;  int ipkBottom = 0;  int regTrigCnt;  int addrRecheck = 0;  int lblRecheckOk = 0;  Trigger *pTrigger;  int nReplaceTrig = 0;  IndexIterator sIdxIter;  isUpdate = regOldData!=0;  db = pParse->db;  v = pParse->pVdbe;  assert( v!=0 );  assert( !IsView(pTab) );  nCol = pTab->nCol;  if( HasRowid(pTab) ){  pPk = 0;  nPkField = 1;  }else{  pPk = sqlite3PrimaryKeyIndex(pTab);  nPkField = pPk->nKeyCol;  }  VdbeModuleComment((v, "BEGIN: GenCnstCks(%d,%d,%d,%d,%d)",   iDataCur, iIdxCur, regNewData, regOldData, pkChng));  if( pTab->tabFlags & TF_HasNotNull ){  int b2ndPass = 0;  int nSeenReplace = 0;  int nGenerated = 0;  while(1){  for(i=0; i<nCol; i++){  int iReg;  Column *pCol = &pTab->aCol[i];  int isGenerated;  onError = pCol->notNull;  if( onError==OE_None ) continue;  if( i==pTab->iPKey ){  continue;  }  isGenerated = pCol->colFlags & COLFLAG_GENERATED;  if( isGenerated && !b2ndPass ){  nGenerated++;  continue;  }  if( aiChng && aiChng[i]<0 && !isGenerated ){  continue;  }  if( overrideError!=OE_Default ){  onError = overrideError;  }else if( onError==OE_Default ){  onError = OE_Abort;  }  if( onError==OE_Replace ){  if( b2ndPass   || pCol->iDflt==0  ){  testcase( pCol->colFlags & COLFLAG_VIRTUAL );  testcase( pCol->colFlags & COLFLAG_STORED );  testcase( pCol->colFlags & COLFLAG_GENERATED );  onError = OE_Abort;  }else{  assert( !isGenerated );  }  }else if( b2ndPass && !isGenerated ){  continue;  }  assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail  || onError==OE_Ignore || onError==OE_Replace );  testcase( i!=sqlite3TableColumnToStorage(pTab, i) );  iReg = sqlite3TableColumnToStorage(pTab, i) + regNewData + 1;  switch( onError ){  case OE_Replace: {  int addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, iReg);  VdbeCoverage(v);  assert( (pCol->colFlags & COLFLAG_GENERATED)==0 );  nSeenReplace++;  sqlite3ExprCodeCopy(pParse,   sqlite3ColumnExpr(pTab, pCol), iReg);  sqlite3VdbeJumpHere(v, addr1);  break;  }  case OE_Abort:  sqlite3MayAbort(pParse);   deliberate_fall_through  case OE_Rollback:  case OE_Fail: {  char *zMsg = sqlite3MPrintf(db, "%s.%s", pTab->zName,  pCol->zCnName);  sqlite3VdbeAddOp3(v, OP_HaltIfNull, SQLITE_CONSTRAINT_NOTNULL,  onError, iReg);  sqlite3VdbeAppendP4(v, zMsg, P4_DYNAMIC);  sqlite3VdbeChangeP5(v, P5_ConstraintNotNull);  VdbeCoverage(v);  break;  }  default: {  assert( onError==OE_Ignore );  sqlite3VdbeAddOp2(v, OP_IsNull, iReg, ignoreDest);  VdbeCoverage(v);  break;  }  }  }  if( nGenerated==0 && nSeenReplace==0 ){  break;  }  if( b2ndPass ) break;  b2ndPass = 1;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( nSeenReplace>0 && (pTab->tabFlags & TF_HasGenerated)!=0 ){  sqlite3ComputeGeneratedColumns(pParse, regNewData+1, pTab);  }
#endif
 }  }
#ifndef SQLITE_OMIT_CHECK
 if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){  ExprList *pCheck = pTab->pCheck;  pParse->iSelfTab = -(regNewData+1);  onError = overrideError!=OE_Default ? overrideError : OE_Abort;  for(i=0; i<pCheck->nExpr; i++){  int allOk;  Expr *pCopy;  Expr *pExpr = pCheck->a[i].pExpr;  if( aiChng   && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)  ){  continue;  }  if( bAffinityDone==0 ){  sqlite3TableAffinity(v, pTab, regNewData+1);  bAffinityDone = 1;  }  allOk = sqlite3VdbeMakeLabel(pParse);  sqlite3VdbeVerifyAbortable(v, onError);  pCopy = sqlite3ExprDup(db, pExpr, 0);  if( !db->mallocFailed ){  sqlite3ExprIfTrue(pParse, pCopy, allOk, SQLITE_JUMPIFNULL);  }  sqlite3ExprDelete(db, pCopy);  if( onError==OE_Ignore ){  sqlite3VdbeGoto(v, ignoreDest);  }else{  char *zName = pCheck->a[i].zEName;  assert( zName!=0 || pParse->db->mallocFailed );  if( onError==OE_Replace ) onError = OE_Abort;  sqlite3HaltConstraint(pParse, SQLITE_CONSTRAINT_CHECK,  onError, zName, P4_TRANSIENT,  P5_ConstraintCheck);  }  sqlite3VdbeResolveLabel(v, allOk);  }  pParse->iSelfTab = 0;  }
#endif
 sIdxIter.eType = 0;  sIdxIter.i = 0;  sIdxIter.u.ax.aIdx = 0;  sIdxIter.u.lx.pIdx = pTab->pIndex;  if( pUpsert ){  if( pUpsert->pUpsertTarget==0 ){  assert( pUpsert->pNextUpsert==0 );  if( pUpsert->isDoUpdate==0 ){  overrideError = OE_Ignore;  pUpsert = 0;  }else{  overrideError = OE_Update;  }  }else if( pTab->pIndex!=0 ){  int nIdx, jj;  u64 nByte;  Upsert *pTerm;  u8 *bUsed;  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){   assert( aRegIdx[nIdx]>0 );  }  sIdxIter.eType = 1;  sIdxIter.u.ax.nIdx = nIdx;  nByte = (sizeof(IndexListTerm)+1)*nIdx + nIdx;  sIdxIter.u.ax.aIdx = sqlite3DbMallocZero(db, nByte);  if( sIdxIter.u.ax.aIdx==0 ) return;  bUsed = (u8*)&sIdxIter.u.ax.aIdx[nIdx];  pUpsert->pToFree = sIdxIter.u.ax.aIdx;  for(i=0, pTerm=pUpsert; pTerm; pTerm=pTerm->pNextUpsert){  if( pTerm->pUpsertTarget==0 ) break;  if( pTerm->pUpsertIdx==0 ) continue;  jj = 0;  pIdx = pTab->pIndex;  while( ALWAYS(pIdx!=0) && pIdx!=pTerm->pUpsertIdx ){   pIdx = pIdx->pNext;   jj++;  }  if( bUsed[jj] ) continue;  bUsed[jj] = 1;  sIdxIter.u.ax.aIdx[i].p = pIdx;  sIdxIter.u.ax.aIdx[i].ix = jj;  i++;  }  for(jj=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, jj++){  if( bUsed[jj] ) continue;  sIdxIter.u.ax.aIdx[i].p = pIdx;  sIdxIter.u.ax.aIdx[i].ix = jj;  i++;  }  assert( i==nIdx );  }  }  if( (db->flags & (SQLITE_RecTriggers|SQLITE_ForeignKeys))==0 ){  pTrigger = 0;  regTrigCnt = 0;  }else{  if( db->flags&SQLITE_RecTriggers ){  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);  regTrigCnt = pTrigger!=0 || sqlite3FkRequired(pParse, pTab, 0, 0);  }else{  pTrigger = 0;  regTrigCnt = sqlite3FkRequired(pParse, pTab, 0, 0);  }  if( regTrigCnt ){  regTrigCnt = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 0, regTrigCnt);  VdbeComment((v, "trigger count"));  lblRecheckOk = sqlite3VdbeMakeLabel(pParse);  addrRecheck = lblRecheckOk;  }  }  if( pkChng && pPk==0 ){  int addrRowidOk = sqlite3VdbeMakeLabel(pParse);  onError = pTab->keyConf;  if( overrideError!=OE_Default ){  onError = overrideError;  }else if( onError==OE_Default ){  onError = OE_Abort;  }  if( pUpsert ){  pUpsertClause = sqlite3UpsertOfIndex(pUpsert,0);  if( pUpsertClause!=0 ){  if( pUpsertClause->isDoUpdate==0 ){  onError = OE_Ignore;  }else{  onError = OE_Update;  }  }  if( pUpsertClause!=pUpsert ){  upsertIpkDelay = sqlite3VdbeAddOp0(v, OP_Goto);  }  }  if( onError==OE_Replace   && onError!=overrideError   && pTab->pIndex   && !upsertIpkDelay  ){  ipkTop = sqlite3VdbeAddOp0(v, OP_Goto)+1;  VdbeComment((v, "defer IPK REPLACE until last"));  }  if( isUpdate ){  sqlite3VdbeAddOp3(v, OP_Eq, regNewData, addrRowidOk, regOldData);  sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);  VdbeCoverage(v);  }  VdbeNoopComment((v, "uniqueness check for ROWID"));  sqlite3VdbeVerifyAbortable(v, onError);  sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, addrRowidOk, regNewData);  VdbeCoverage(v);  switch( onError ){  default: {  onError = OE_Abort;   deliberate_fall_through  }  case OE_Rollback:  case OE_Abort:  case OE_Fail: {  testcase( onError==OE_Rollback );  testcase( onError==OE_Abort );  testcase( onError==OE_Fail );  sqlite3RowidConstraint(pParse, onError, pTab);  break;  }  case OE_Replace: {  if( regTrigCnt ){  sqlite3MultiWrite(pParse);  sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,   regNewData, 1, 0, OE_Replace, 1, -1);  sqlite3VdbeAddOp2(v, OP_AddImm, regTrigCnt, 1);  nReplaceTrig++;  }else{
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 assert( HasRowid(pTab) );  sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, OPFLAG_ISNOOP);  sqlite3VdbeAppendP4(v, pTab, P4_TABLE);
#endif
 if( pTab->pIndex ){  sqlite3MultiWrite(pParse);  sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,-1);  }  }  seenReplace = 1;  break;  }
#ifndef SQLITE_OMIT_UPSERT
 case OE_Update: {  sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, 0, iDataCur);   deliberate_fall_through  }
#endif
 case OE_Ignore: {  testcase( onError==OE_Ignore );  sqlite3VdbeGoto(v, ignoreDest);  break;  }  }  sqlite3VdbeResolveLabel(v, addrRowidOk);  if( pUpsert && pUpsertClause!=pUpsert ){  upsertIpkReturn = sqlite3VdbeAddOp0(v, OP_Goto);  }else if( ipkTop ){  ipkBottom = sqlite3VdbeAddOp0(v, OP_Goto);  sqlite3VdbeJumpHere(v, ipkTop-1);  }  }  for(pIdx = indexIteratorFirst(&sIdxIter, &ix);  pIdx;  pIdx = indexIteratorNext(&sIdxIter, &ix)  ){  int regIdx;  int regR;  int iThisCur;  int addrUniqueOk;  int addrConflictCk;  if( aRegIdx[ix]==0 ) continue;  if( pUpsert ){  pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx);  if( upsertIpkDelay && pUpsertClause==pUpsert ){  sqlite3VdbeJumpHere(v, upsertIpkDelay);  }  }  addrUniqueOk = sqlite3VdbeMakeLabel(pParse);  if( bAffinityDone==0 ){  sqlite3TableAffinity(v, pTab, regNewData+1);  bAffinityDone = 1;  }  VdbeNoopComment((v, "prep index %s", pIdx->zName));  iThisCur = iIdxCur+ix;  if( pIdx->pPartIdxWhere ){  sqlite3VdbeAddOp2(v, OP_Null, 0, aRegIdx[ix]);  pParse->iSelfTab = -(regNewData+1);  sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk,  SQLITE_JUMPIFNULL);  pParse->iSelfTab = 0;  }  regIdx = aRegIdx[ix]+1;  for(i=0; i<pIdx->nColumn; i++){  int iField = pIdx->aiColumn[i];  int x;  if( iField==XN_EXPR ){  pParse->iSelfTab = -(regNewData+1);  sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);  pParse->iSelfTab = 0;  VdbeComment((v, "%s column %d", pIdx->zName, i));  }else if( iField==XN_ROWID || iField==pTab->iPKey ){  x = regNewData;  sqlite3VdbeAddOp2(v, OP_IntCopy, x, regIdx+i);  VdbeComment((v, "rowid"));  }else{  testcase( sqlite3TableColumnToStorage(pTab, iField)!=iField );  x = sqlite3TableColumnToStorage(pTab, iField) + regNewData + 1;  sqlite3VdbeAddOp2(v, OP_SCopy, x, regIdx+i);  VdbeComment((v, "%s", pTab->aCol[iField].zCnName));  }  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn, aRegIdx[ix]);  VdbeComment((v, "for %s", pIdx->zName));
#ifdef SQLITE_ENABLE_NULL_TRIM
 if( pIdx->idxType==SQLITE_IDXTYPE_PRIMARYKEY ){  sqlite3SetMakeRecordP5(v, pIdx->pTable);  }
#endif
 sqlite3VdbeReleaseRegisters(pParse, regIdx, pIdx->nColumn, 0, 0);  if( isUpdate && pPk==pIdx && pkChng==0 ){  sqlite3VdbeResolveLabel(v, addrUniqueOk);  continue;  }  onError = pIdx->onError;  if( onError==OE_None ){  sqlite3VdbeResolveLabel(v, addrUniqueOk);  continue;  }  if( overrideError!=OE_Default ){  onError = overrideError;  }else if( onError==OE_Default ){  onError = OE_Abort;  }  if( pUpsertClause ){  if( pUpsertClause->isDoUpdate==0 ){  onError = OE_Ignore;  }else{  onError = OE_Update;  }  }  assert( IsOrdinaryTable(pTab) );
#ifndef SQLITE_ENABLE_PREUPDATE_HOOK
 if( (ix==0 && pIdx->pNext==0)   && pPk==pIdx   && onError==OE_Replace   && ( 0==(db->flags&SQLITE_RecTriggers) ||  0==sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0))   && ( 0==(db->flags&SQLITE_ForeignKeys) ||   (0==pTab->u.tab.pFKey && 0==sqlite3FkReferences(pTab)))  ){  sqlite3VdbeResolveLabel(v, addrUniqueOk);  continue;  }
#endif
 sqlite3VdbeVerifyAbortable(v, onError);  addrConflictCk =  sqlite3VdbeAddOp4Int(v, OP_NoConflict, iThisCur, addrUniqueOk,   regIdx, pIdx->nKeyCol); VdbeCoverage(v);  regR = pIdx==pPk ? regIdx : sqlite3GetTempRange(pParse, nPkField);  if( isUpdate || onError==OE_Replace ){  if( HasRowid(pTab) ){  sqlite3VdbeAddOp2(v, OP_IdxRowid, iThisCur, regR);  if( isUpdate ){  sqlite3VdbeAddOp3(v, OP_Eq, regR, addrUniqueOk, regOldData);  sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);  VdbeCoverage(v);  }  }else{  int x;  if( pIdx!=pPk ){  for(i=0; i<pPk->nKeyCol; i++){  assert( pPk->aiColumn[i]>=0 );  x = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);  sqlite3VdbeAddOp3(v, OP_Column, iThisCur, x, regR+i);  VdbeComment((v, "%s.%s", pTab->zName,   pTab->aCol[pPk->aiColumn[i]].zCnName));  }  }  if( isUpdate ){  int addrJump = sqlite3VdbeCurrentAddr(v)+pPk->nKeyCol;  int op = OP_Ne;  int regCmp = (IsPrimaryKeyIndex(pIdx) ? regIdx : regR);  for(i=0; i<pPk->nKeyCol; i++){  char *p4 = (char*)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);  x = pPk->aiColumn[i];  assert( x>=0 );  if( i==(pPk->nKeyCol-1) ){  addrJump = addrUniqueOk;  op = OP_Eq;  }  x = sqlite3TableColumnToStorage(pTab, x);  sqlite3VdbeAddOp4(v, op,  regOldData+1+x, addrJump, regCmp+i, p4, P4_COLLSEQ  );  sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);  VdbeCoverageIf(v, op==OP_Eq);  VdbeCoverageIf(v, op==OP_Ne);  }  }  }  }  assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail  || onError==OE_Ignore || onError==OE_Replace || onError==OE_Update );  switch( onError ){  case OE_Rollback:  case OE_Abort:  case OE_Fail: {  testcase( onError==OE_Rollback );  testcase( onError==OE_Abort );  testcase( onError==OE_Fail );  sqlite3UniqueConstraint(pParse, onError, pIdx);  break;  }
#ifndef SQLITE_OMIT_UPSERT
 case OE_Update: {  sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix);   deliberate_fall_through  }
#endif
 case OE_Ignore: {  testcase( onError==OE_Ignore );  sqlite3VdbeGoto(v, ignoreDest);  break;  }  default: {  int nConflictCk;  assert( onError==OE_Replace );  nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk;  assert( nConflictCk>0 || db->mallocFailed );  testcase( nConflictCk<=0 );  testcase( nConflictCk>1 );  if( regTrigCnt ){  sqlite3MultiWrite(pParse);  nReplaceTrig++;  }  if( pTrigger && isUpdate ){  sqlite3VdbeAddOp1(v, OP_CursorLock, iDataCur);  }  sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,  regR, nPkField, 0, OE_Replace,  (pIdx==pPk ? ONEPASS_SINGLE : ONEPASS_OFF), iThisCur);  if( pTrigger && isUpdate ){  sqlite3VdbeAddOp1(v, OP_CursorUnlock, iDataCur);  }  if( regTrigCnt ){  int addrBypass;  sqlite3VdbeAddOp2(v, OP_AddImm, regTrigCnt, 1);  addrBypass = sqlite3VdbeAddOp0(v, OP_Goto);  VdbeComment((v, "bypass recheck"));  sqlite3VdbeResolveLabel(v, lblRecheckOk);  lblRecheckOk = sqlite3VdbeMakeLabel(pParse);  if( pIdx->pPartIdxWhere ){  sqlite3VdbeAddOp2(v, OP_IsNull, regIdx-1, lblRecheckOk);  VdbeCoverage(v);  }  while( nConflictCk>0 ){  VdbeOp x;  x = *sqlite3VdbeGetOp(v, addrConflictCk);  if( x.opcode!=OP_IdxRowid ){  int p2;  const char *zP4;  if( sqlite3OpcodeProperty[x.opcode]&OPFLG_JUMP ){  p2 = lblRecheckOk;  }else{  p2 = x.p2;  }  zP4 = x.p4type==P4_INT32 ? SQLITE_INT_TO_PTR(x.p4.i) : x.p4.z;  sqlite3VdbeAddOp4(v, x.opcode, x.p1, p2, x.p3, zP4, x.p4type);  sqlite3VdbeChangeP5(v, x.p5);  VdbeCoverageIf(v, p2!=x.p2);  }  nConflictCk--;  addrConflictCk++;  }  sqlite3UniqueConstraint(pParse, OE_Abort, pIdx);  sqlite3VdbeJumpHere(v, addrBypass);  }  seenReplace = 1;  break;  }  }  sqlite3VdbeResolveLabel(v, addrUniqueOk);  if( regR!=regIdx ) sqlite3ReleaseTempRange(pParse, regR, nPkField);  if( pUpsertClause   && upsertIpkReturn   && sqlite3UpsertNextIsIPK(pUpsertClause)  ){  sqlite3VdbeGoto(v, upsertIpkDelay+1);  sqlite3VdbeJumpHere(v, upsertIpkReturn);  upsertIpkReturn = 0;  }  }  if( ipkTop ){  sqlite3VdbeGoto(v, ipkTop);  VdbeComment((v, "Do IPK REPLACE"));  assert( ipkBottom>0 );  sqlite3VdbeJumpHere(v, ipkBottom);  }  testcase( regTrigCnt!=0 && nReplaceTrig==0 );  assert( regTrigCnt!=0 || nReplaceTrig==0 );  if( nReplaceTrig ){  sqlite3VdbeAddOp2(v, OP_IfNot, regTrigCnt, lblRecheckOk);VdbeCoverage(v);  if( !pPk ){  if( isUpdate ){  sqlite3VdbeAddOp3(v, OP_Eq, regNewData, addrRecheck, regOldData);  sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);  VdbeCoverage(v);  }  sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, addrRecheck, regNewData);  VdbeCoverage(v);  sqlite3RowidConstraint(pParse, OE_Abort, pTab);  }else{  sqlite3VdbeGoto(v, addrRecheck);  }  sqlite3VdbeResolveLabel(v, lblRecheckOk);  }  if( HasRowid(pTab) ){  int regRec = aRegIdx[ix];  sqlite3VdbeAddOp3(v, OP_MakeRecord, regNewData+1, pTab->nNVCol, regRec);  sqlite3SetMakeRecordP5(v, pTab);  if( !bAffinityDone ){  sqlite3TableAffinity(v, pTab, 0);  }  }  *pbMayReplace = seenReplace;  VdbeModuleComment((v, "END: GenCnstCks(%d)", seenReplace)); }
#ifdef SQLITE_ENABLE_NULL_TRIM
SQLITE_PRIVATE void sqlite3SetMakeRecordP5(Vdbe *v, Table *pTab){  u16 i;  if( pTab->pSchema->file_format<2 ) return;  for(i=pTab->nCol-1; i>0; i--){  if( pTab->aCol[i].iDflt!=0 ) break;  if( pTab->aCol[i].colFlags & COLFLAG_PRIMKEY ) break;  }  sqlite3VdbeChangeP5(v, i+1); }
#endif
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
static void codeWithoutRowidPreupdate(  Parse *pParse,  Table *pTab,  int iCur,  int regData ){  Vdbe *v = pParse->pVdbe;  int r = sqlite3GetTempReg(pParse);  assert( !HasRowid(pTab) );  assert( 0==(pParse->db->mDbFlags & DBFLAG_Vacuum) || CORRUPT_DB );  sqlite3VdbeAddOp2(v, OP_Integer, 0, r);  sqlite3VdbeAddOp4(v, OP_Insert, iCur, regData, r, (char*)pTab, P4_TABLE);  sqlite3VdbeChangeP5(v, OPFLAG_ISNOOP);  sqlite3ReleaseTempReg(pParse, r); }
#else
# define codeWithoutRowidPreupdate(a,b,c,d)
#endif
SQLITE_PRIVATE void sqlite3CompleteInsertion(  Parse *pParse,  Table *pTab,  int iDataCur,  int iIdxCur,  int regNewData,  int *aRegIdx,  int update_flags,  int appendBias,  int useSeekResult ){  Vdbe *v;  Index *pIdx;  u8 pik_flags;  int i;  assert( update_flags==0   || update_flags==OPFLAG_ISUPDATE   || update_flags==(OPFLAG_ISUPDATE|OPFLAG_SAVEPOSITION)  );  v = pParse->pVdbe;  assert( v!=0 );  assert( !IsView(pTab) );  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){  assert( pIdx->onError!=OE_Replace   || pIdx->pNext==0   || pIdx->pNext->onError==OE_Replace );  if( aRegIdx[i]==0 ) continue;  if( pIdx->pPartIdxWhere ){  sqlite3VdbeAddOp2(v, OP_IsNull, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);  VdbeCoverage(v);  }  pik_flags = (useSeekResult ? OPFLAG_USESEEKRESULT : 0);  if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){  pik_flags |= OPFLAG_NCHANGE;  pik_flags |= (update_flags & OPFLAG_SAVEPOSITION);  if( update_flags==0 ){  codeWithoutRowidPreupdate(pParse, pTab, iIdxCur+i, aRegIdx[i]);  }  }  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iIdxCur+i, aRegIdx[i],   aRegIdx[i]+1,   pIdx->uniqNotNull ? pIdx->nKeyCol: pIdx->nColumn);  sqlite3VdbeChangeP5(v, pik_flags);  }  if( !HasRowid(pTab) ) return;  if( pParse->nested ){  pik_flags = 0;  }else{  pik_flags = OPFLAG_NCHANGE;  pik_flags |= (update_flags?update_flags:OPFLAG_LASTROWID);  }  if( appendBias ){  pik_flags |= OPFLAG_APPEND;  }  if( useSeekResult ){  pik_flags |= OPFLAG_USESEEKRESULT;  }  sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);  if( !pParse->nested ){  sqlite3VdbeAppendP4(v, pTab, P4_TABLE);  }  sqlite3VdbeChangeP5(v, pik_flags); } SQLITE_PRIVATE int sqlite3OpenTableAndIndices(  Parse *pParse,  Table *pTab,  int op,  u8 p5,  int iBase,  u8 *aToOpen,  int *piDataCur,  int *piIdxCur ){  int i;  int iDb;  int iDataCur;  Index *pIdx;  Vdbe *v;  assert( op==OP_OpenRead || op==OP_OpenWrite );  assert( op==OP_OpenWrite || p5==0 );  if( IsVirtual(pTab) ){  *piDataCur = *piIdxCur = -999;  return 0;  }  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  v = pParse->pVdbe;  assert( v!=0 );  if( iBase<0 ) iBase = pParse->nTab;  iDataCur = iBase++;  if( piDataCur ) *piDataCur = iDataCur;  if( HasRowid(pTab) && (aToOpen==0 || aToOpen[0]) ){  sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);  }else{  sqlite3TableLock(pParse, iDb, pTab->tnum, op==OP_OpenWrite, pTab->zName);  }  if( piIdxCur ) *piIdxCur = iBase;  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){  int iIdxCur = iBase++;  assert( pIdx->pSchema==pTab->pSchema );  if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){  if( piDataCur ) *piDataCur = iIdxCur;  p5 = 0;  }  if( aToOpen==0 || aToOpen[i+1] ){  sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);  sqlite3VdbeChangeP5(v, p5);  VdbeComment((v, "%s", pIdx->zName));  }  }  if( iBase>pParse->nTab ) pParse->nTab = iBase;  return i; }
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_xferopt_count;
#endif
#ifndef SQLITE_OMIT_XFER_OPT
static int xferCompatibleIndex(Index *pDest, Index *pSrc){  int i;  assert( pDest && pSrc );  assert( pDest->pTable!=pSrc->pTable );  if( pDest->nKeyCol!=pSrc->nKeyCol || pDest->nColumn!=pSrc->nColumn ){  return 0;  }  if( pDest->onError!=pSrc->onError ){  return 0;  }  for(i=0; i<pSrc->nKeyCol; i++){  if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){  return 0;  }  if( pSrc->aiColumn[i]==XN_EXPR ){  assert( pSrc->aColExpr!=0 && pDest->aColExpr!=0 );  if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,   pDest->aColExpr->a[i].pExpr, -1)!=0 ){  return 0;  }  }  if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){  return 0;  }  if( sqlite3_stricmp(pSrc->azColl[i],pDest->azColl[i])!=0 ){  return 0;  }  }  if( sqlite3ExprCompare(0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){  return 0;  }  return 1; } static int xferOptimization(  Parse *pParse,  Table *pDest,  Select *pSelect,  int onError,  int iDbDest ){  sqlite3 *db = pParse->db;  ExprList *pEList;  Table *pSrc;  Index *pSrcIdx, *pDestIdx;  SrcItem *pItem;  int i;  int iDbSrc;  int iSrc, iDest;  int addr1, addr2;  int emptyDestTest = 0;  int emptySrcTest = 0;  Vdbe *v;  int regAutoinc;  int destHasUniqueIdx = 0;  int regData, regRowid;  if( pSelect==0 ){  return 0;  }  if( pParse->pWith || pSelect->pWith ){  return 0;  }  if( sqlite3TriggerList(pParse, pDest) ){  return 0;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pDest) ){  return 0;  }
#endif
 if( onError==OE_Default ){  if( pDest->iPKey>=0 ) onError = pDest->keyConf;  if( onError==OE_Default ) onError = OE_Abort;  }  assert(pSelect->pSrc);  if( pSelect->pSrc->nSrc!=1 ){  return 0;  }  if( pSelect->pSrc->a[0].pSelect ){  return 0;  }  if( pSelect->pWhere ){  return 0;  }  if( pSelect->pOrderBy ){  return 0;  }  if( pSelect->pGroupBy ){  return 0;  }  if( pSelect->pLimit ){  return 0;  }  if( pSelect->pPrior ){  return 0;  }  if( pSelect->selFlags & SF_Distinct ){  return 0;  }  pEList = pSelect->pEList;  assert( pEList!=0 );  if( pEList->nExpr!=1 ){  return 0;  }  assert( pEList->a[0].pExpr );  if( pEList->a[0].pExpr->op!=TK_ASTERISK ){  return 0;  }  pItem = pSelect->pSrc->a;  pSrc = sqlite3LocateTableItem(pParse, 0, pItem);  if( pSrc==0 ){  return 0;  }  if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){  testcase( pSrc!=pDest );  return 0;  }  if( HasRowid(pDest)!=HasRowid(pSrc) ){  return 0;  }  if( !IsOrdinaryTable(pSrc) ){  return 0;  }  if( pDest->nCol!=pSrc->nCol ){  return 0;  }  if( pDest->iPKey!=pSrc->iPKey ){  return 0;  }  if( (pDest->tabFlags & TF_Strict)!=0 && (pSrc->tabFlags & TF_Strict)==0 ){  return 0;  }  for(i=0; i<pDest->nCol; i++){  Column *pDestCol = &pDest->aCol[i];  Column *pSrcCol = &pSrc->aCol[i];
#ifdef SQLITE_ENABLE_HIDDEN_COLUMNS
 if( (db->mDbFlags & DBFLAG_Vacuum)==0   && (pDestCol->colFlags | pSrcCol->colFlags) & COLFLAG_HIDDEN  ){  return 0;  }
#endif
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( (pDestCol->colFlags & COLFLAG_GENERATED) !=  (pSrcCol->colFlags & COLFLAG_GENERATED) ){  return 0;  }  if( (pDestCol->colFlags & COLFLAG_GENERATED)!=0 ){  if( sqlite3ExprCompare(0,   sqlite3ColumnExpr(pSrc, pSrcCol),   sqlite3ColumnExpr(pDest, pDestCol), -1)!=0 ){  testcase( pDestCol->colFlags & COLFLAG_VIRTUAL );  testcase( pDestCol->colFlags & COLFLAG_STORED );  return 0;  }  }
#endif
 if( pDestCol->affinity!=pSrcCol->affinity ){  return 0;  }  if( sqlite3_stricmp(sqlite3ColumnColl(pDestCol),  sqlite3ColumnColl(pSrcCol))!=0 ){  return 0;  }  if( pDestCol->notNull && !pSrcCol->notNull ){  return 0;  }  if( (pDestCol->colFlags & COLFLAG_GENERATED)==0 && i>0 ){  Expr *pDestExpr = sqlite3ColumnExpr(pDest, pDestCol);  Expr *pSrcExpr = sqlite3ColumnExpr(pSrc, pSrcCol);  assert( pDestExpr==0 || pDestExpr->op==TK_SPAN );  assert( pDestExpr==0 || !ExprHasProperty(pDestExpr, EP_IntValue) );  assert( pSrcExpr==0 || pSrcExpr->op==TK_SPAN );  assert( pSrcExpr==0 || !ExprHasProperty(pSrcExpr, EP_IntValue) );  if( (pDestExpr==0)!=(pSrcExpr==0)   || (pDestExpr!=0 && strcmp(pDestExpr->u.zToken,   pSrcExpr->u.zToken)!=0)  ){  return 0;  }  }  }  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){  if( IsUniqueIndex(pDestIdx) ){  destHasUniqueIdx = 1;  }  for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){  if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;  }  if( pSrcIdx==0 ){  return 0;  }  if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema   && sqlite3FaultSim(411)==SQLITE_OK ){  return 0;  }  }
#ifndef SQLITE_OMIT_CHECK
 if( pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1) ){  return 0;  }
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
 assert( IsOrdinaryTable(pDest) );  if( (db->flags & SQLITE_ForeignKeys)!=0 && pDest->u.tab.pFKey!=0 ){  return 0;  }
#endif
 if( (db->flags & SQLITE_CountRows)!=0 ){  return 0;  }
#ifdef SQLITE_TEST
 sqlite3_xferopt_count++;
#endif
 iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);  v = sqlite3GetVdbe(pParse);  sqlite3CodeVerifySchema(pParse, iDbSrc);  iSrc = pParse->nTab++;  iDest = pParse->nTab++;  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);  regData = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_Null, 0, regData);  regRowid = sqlite3GetTempReg(pParse);  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);  assert( HasRowid(pDest) || destHasUniqueIdx );  if( (db->mDbFlags & DBFLAG_Vacuum)==0 && (  (pDest->iPKey<0 && pDest->pIndex!=0)   || destHasUniqueIdx   || (onError!=OE_Abort && onError!=OE_Rollback)  )){  addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0); VdbeCoverage(v);  emptyDestTest = sqlite3VdbeAddOp0(v, OP_Goto);  sqlite3VdbeJumpHere(v, addr1);  }  if( HasRowid(pSrc) ){  u8 insFlags;  sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead);  emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);  if( pDest->iPKey>=0 ){  addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);  if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){  sqlite3VdbeVerifyAbortable(v, onError);  addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);  VdbeCoverage(v);  sqlite3RowidConstraint(pParse, onError, pDest);  sqlite3VdbeJumpHere(v, addr2);  }  autoIncStep(pParse, regAutoinc, regRowid);  }else if( pDest->pIndex==0 && !(db->mDbFlags & DBFLAG_VacuumInto) ){  addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid);  }else{  addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);  assert( (pDest->tabFlags & TF_Autoincrement)==0 );  }  if( db->mDbFlags & DBFLAG_Vacuum ){  sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);  insFlags = OPFLAG_APPEND|OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;  }else{  insFlags = OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND|OPFLAG_PREFORMAT;  }
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){  sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);  insFlags &= ~OPFLAG_PREFORMAT;  }else
#endif
 {  sqlite3VdbeAddOp3(v, OP_RowCell, iDest, iSrc, regRowid);  }  sqlite3VdbeAddOp3(v, OP_Insert, iDest, regData, regRowid);  if( (db->mDbFlags & DBFLAG_Vacuum)==0 ){  sqlite3VdbeChangeP4(v, -1, (char*)pDest, P4_TABLE);  }  sqlite3VdbeChangeP5(v, insFlags);  sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1); VdbeCoverage(v);  sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);  sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);  }else{  sqlite3TableLock(pParse, iDbDest, pDest->tnum, 1, pDest->zName);  sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);  }  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){  u8 idxInsFlags = 0;  for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){  if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;  }  assert( pSrcIdx );  sqlite3VdbeAddOp3(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc);  sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);  VdbeComment((v, "%s", pSrcIdx->zName));  sqlite3VdbeAddOp3(v, OP_OpenWrite, iDest, pDestIdx->tnum, iDbDest);  sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);  sqlite3VdbeChangeP5(v, OPFLAG_BULKCSR);  VdbeComment((v, "%s", pDestIdx->zName));  addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0); VdbeCoverage(v);  if( db->mDbFlags & DBFLAG_Vacuum ){  for(i=0; i<pSrcIdx->nColumn; i++){  const char *zColl = pSrcIdx->azColl[i];  if( sqlite3_stricmp(sqlite3StrBINARY, zColl) ) break;  }  if( i==pSrcIdx->nColumn ){  idxInsFlags = OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT;  sqlite3VdbeAddOp1(v, OP_SeekEnd, iDest);  sqlite3VdbeAddOp2(v, OP_RowCell, iDest, iSrc);  }  }else if( !HasRowid(pSrc) && pDestIdx->idxType==SQLITE_IDXTYPE_PRIMARYKEY ){  idxInsFlags |= OPFLAG_NCHANGE;  }  if( idxInsFlags!=(OPFLAG_USESEEKRESULT|OPFLAG_PREFORMAT) ){  sqlite3VdbeAddOp3(v, OP_RowData, iSrc, regData, 1);  if( (db->mDbFlags & DBFLAG_Vacuum)==0   && !HasRowid(pDest)   && IsPrimaryKeyIndex(pDestIdx)  ){  codeWithoutRowidPreupdate(pParse, pDest, iDest, regData);  }  }  sqlite3VdbeAddOp2(v, OP_IdxInsert, iDest, regData);  sqlite3VdbeChangeP5(v, idxInsFlags|OPFLAG_APPEND);  sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr1);  sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);  sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);  }  if( emptySrcTest ) sqlite3VdbeJumpHere(v, emptySrcTest);  sqlite3ReleaseTempReg(pParse, regRowid);  sqlite3ReleaseTempReg(pParse, regData);  if( emptyDestTest ){  sqlite3AutoincrementEnd(pParse);  sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, 0);  sqlite3VdbeJumpHere(v, emptyDestTest);  sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);  return 0;  }else{  return 1;  } }
#endif
SQLITE_API int sqlite3_exec(  sqlite3 *db,  const char *zSql,  sqlite3_callback xCallback,  void *pArg,  char **pzErrMsg ){  int rc = SQLITE_OK;  const char *zLeftover;  sqlite3_stmt *pStmt = 0;  char **azCols = 0;  int callbackIsInit;  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;  if( zSql==0 ) zSql = "";  sqlite3_mutex_enter(db->mutex);  sqlite3Error(db, SQLITE_OK);  while( rc==SQLITE_OK && zSql[0] ){  int nCol = 0;  char **azVals = 0;  pStmt = 0;  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);  assert( rc==SQLITE_OK || pStmt==0 );  if( rc!=SQLITE_OK ){  continue;  }  if( !pStmt ){  zSql = zLeftover;  continue;  }  callbackIsInit = 0;  while( 1 ){  int i;  rc = sqlite3_step(pStmt);  if( xCallback && (SQLITE_ROW==rc ||  (SQLITE_DONE==rc && !callbackIsInit   && db->flags&SQLITE_NullCallback)) ){  if( !callbackIsInit ){  nCol = sqlite3_column_count(pStmt);  azCols = sqlite3DbMallocRaw(db, (2*nCol+1)*sizeof(const char*));  if( azCols==0 ){  goto exec_out;  }  for(i=0; i<nCol; i++){  azCols[i] = (char *)sqlite3_column_name(pStmt, i);  assert( azCols[i]!=0 );  }  callbackIsInit = 1;  }  if( rc==SQLITE_ROW ){  azVals = &azCols[nCol];  for(i=0; i<nCol; i++){  azVals[i] = (char *)sqlite3_column_text(pStmt, i);  if( !azVals[i] && sqlite3_column_type(pStmt, i)!=SQLITE_NULL ){  sqlite3OomFault(db);  goto exec_out;  }  }  azVals[i] = 0;  }  if( xCallback(pArg, nCol, azVals, azCols) ){  rc = SQLITE_ABORT;  sqlite3VdbeFinalize((Vdbe *)pStmt);  pStmt = 0;  sqlite3Error(db, SQLITE_ABORT);  goto exec_out;  }  }  if( rc!=SQLITE_ROW ){  rc = sqlite3VdbeFinalize((Vdbe *)pStmt);  pStmt = 0;  zSql = zLeftover;  while( sqlite3Isspace(zSql[0]) ) zSql++;  break;  }  }  sqlite3DbFree(db, azCols);  azCols = 0;  } exec_out:  if( pStmt ) sqlite3VdbeFinalize((Vdbe *)pStmt);  sqlite3DbFree(db, azCols);  rc = sqlite3ApiExit(db, rc);  if( rc!=SQLITE_OK && pzErrMsg ){  *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));  if( *pzErrMsg==0 ){  rc = SQLITE_NOMEM_BKPT;  sqlite3Error(db, SQLITE_NOMEM);  }  }else if( pzErrMsg ){  *pzErrMsg = 0;  }  assert( (rc&db->errMask)==rc );  sqlite3_mutex_leave(db->mutex);  return rc; }
#ifndef SQLITE_CORE
 #define SQLITE_CORE 1
#endif
#ifndef SQLITE3EXT_H
#define SQLITE3EXT_H
struct sqlite3_api_routines {  void * (*aggregate_context)(sqlite3_context*,int nBytes);  int (*aggregate_count)(sqlite3_context*);  int (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));  int (*bind_double)(sqlite3_stmt*,int,double);  int (*bind_int)(sqlite3_stmt*,int,int);  int (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);  int (*bind_null)(sqlite3_stmt*,int);  int (*bind_parameter_count)(sqlite3_stmt*);  int (*bind_parameter_index)(sqlite3_stmt*,const char*zName);  const char * (*bind_parameter_name)(sqlite3_stmt*,int);  int (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));  int (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));  int (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);  int (*busy_handler)(sqlite3*,int(*)(void*,int),void*);  int (*busy_timeout)(sqlite3*,int ms);  int (*changes)(sqlite3*);  int (*close)(sqlite3*);  int (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,   int eTextRep,const char*));  int (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,   int eTextRep,const void*));  const void * (*column_blob)(sqlite3_stmt*,int iCol);  int (*column_bytes)(sqlite3_stmt*,int iCol);  int (*column_bytes16)(sqlite3_stmt*,int iCol);  int (*column_count)(sqlite3_stmt*pStmt);  const char * (*column_database_name)(sqlite3_stmt*,int);  const void * (*column_database_name16)(sqlite3_stmt*,int);  const char * (*column_decltype)(sqlite3_stmt*,int i);  const void * (*column_decltype16)(sqlite3_stmt*,int);  double (*column_double)(sqlite3_stmt*,int iCol);  int (*column_int)(sqlite3_stmt*,int iCol);  sqlite_int64 (*column_int64)(sqlite3_stmt*,int iCol);  const char * (*column_name)(sqlite3_stmt*,int);  const void * (*column_name16)(sqlite3_stmt*,int);  const char * (*column_origin_name)(sqlite3_stmt*,int);  const void * (*column_origin_name16)(sqlite3_stmt*,int);  const char * (*column_table_name)(sqlite3_stmt*,int);  const void * (*column_table_name16)(sqlite3_stmt*,int);  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);  const void * (*column_text16)(sqlite3_stmt*,int iCol);  int (*column_type)(sqlite3_stmt*,int iCol);  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);  int (*complete)(const char*sql);  int (*complete16)(const void*sql);  int (*create_collation)(sqlite3*,const char*,int,void*,   int(*)(void*,int,const void*,int,const void*));  int (*create_collation16)(sqlite3*,const void*,int,void*,   int(*)(void*,int,const void*,int,const void*));  int (*create_function)(sqlite3*,const char*,int,int,void*,  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*));  int (*create_function16)(sqlite3*,const void*,int,int,void*,  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*));  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);  int (*data_count)(sqlite3_stmt*pStmt);  sqlite3 * (*db_handle)(sqlite3_stmt*);  int (*declare_vtab)(sqlite3*,const char*);  int (*enable_shared_cache)(int);  int (*errcode)(sqlite3*db);  const char * (*errmsg)(sqlite3*);  const void * (*errmsg16)(sqlite3*);  int (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);  int (*expired)(sqlite3_stmt*);  int (*finalize)(sqlite3_stmt*pStmt);  void (*free)(void*);  void (*free_table)(char**result);  int (*get_autocommit)(sqlite3*);  void * (*get_auxdata)(sqlite3_context*,int);  int (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);  int (*global_recover)(void);  void (*interruptx)(sqlite3*);  sqlite_int64 (*last_insert_rowid)(sqlite3*);  const char * (*libversion)(void);  int (*libversion_number)(void);  void *(*malloc)(int);  char * (*mprintf)(const char*,...);  int (*open)(const char*,sqlite3**);  int (*open16)(const void*,sqlite3**);  int (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);  int (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);  void (*progress_handler)(sqlite3*,int,int(*)(void*),void*);  void *(*realloc)(void*,int);  int (*reset)(sqlite3_stmt*pStmt);  void (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));  void (*result_double)(sqlite3_context*,double);  void (*result_error)(sqlite3_context*,const char*,int);  void (*result_error16)(sqlite3_context*,const void*,int);  void (*result_int)(sqlite3_context*,int);  void (*result_int64)(sqlite3_context*,sqlite_int64);  void (*result_null)(sqlite3_context*);  void (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));  void (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));  void (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));  void (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));  void (*result_value)(sqlite3_context*,sqlite3_value*);  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);  int (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,   const char*,const char*),void*);  void (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));  char * (*xsnprintf)(int,char*,const char*,...);  int (*step)(sqlite3_stmt*);  int (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,  char const**,char const**,int*,int*,int*);  void (*thread_cleanup)(void);  int (*total_changes)(sqlite3*);  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);  int (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,   sqlite_int64),void*);  void * (*user_data)(sqlite3_context*);  const void * (*value_blob)(sqlite3_value*);  int (*value_bytes)(sqlite3_value*);  int (*value_bytes16)(sqlite3_value*);  double (*value_double)(sqlite3_value*);  int (*value_int)(sqlite3_value*);  sqlite_int64 (*value_int64)(sqlite3_value*);  int (*value_numeric_type)(sqlite3_value*);  const unsigned char * (*value_text)(sqlite3_value*);  const void * (*value_text16)(sqlite3_value*);  const void * (*value_text16be)(sqlite3_value*);  const void * (*value_text16le)(sqlite3_value*);  int (*value_type)(sqlite3_value*);  char *(*vmprintf)(const char*,va_list);  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);  int (*clear_bindings)(sqlite3_stmt*);  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,  void (*xDestroy)(void *));  int (*bind_zeroblob)(sqlite3_stmt*,int,int);  int (*blob_bytes)(sqlite3_blob*);  int (*blob_close)(sqlite3_blob*);  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,   int,sqlite3_blob**);  int (*blob_read)(sqlite3_blob*,void*,int,int);  int (*blob_write)(sqlite3_blob*,const void*,int,int);  int (*create_collation_v2)(sqlite3*,const char*,int,void*,   int(*)(void*,int,const void*,int,const void*),   void(*)(void*));  int (*file_control)(sqlite3*,const char*,int,void*);  sqlite3_int64 (*memory_highwater)(int);  sqlite3_int64 (*memory_used)(void);  sqlite3_mutex *(*mutex_alloc)(int);  void (*mutex_enter)(sqlite3_mutex*);  void (*mutex_free)(sqlite3_mutex*);  void (*mutex_leave)(sqlite3_mutex*);  int (*mutex_try)(sqlite3_mutex*);  int (*open_v2)(const char*,sqlite3**,int,const char*);  int (*release_memory)(int);  void (*result_error_nomem)(sqlite3_context*);  void (*result_error_toobig)(sqlite3_context*);  int (*sleep)(int);  void (*soft_heap_limit)(int);  sqlite3_vfs *(*vfs_find)(const char*);  int (*vfs_register)(sqlite3_vfs*,int);  int (*vfs_unregister)(sqlite3_vfs*);  int (*xthreadsafe)(void);  void (*result_zeroblob)(sqlite3_context*,int);  void (*result_error_code)(sqlite3_context*,int);  int (*test_control)(int, ...);  void (*randomness)(int,void*);  sqlite3 *(*context_db_handle)(sqlite3_context*);  int (*extended_result_codes)(sqlite3*,int);  int (*limit)(sqlite3*,int,int);  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);  const char *(*sql)(sqlite3_stmt*);  int (*status)(int,int*,int*,int);  int (*backup_finish)(sqlite3_backup*);  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);  int (*backup_pagecount)(sqlite3_backup*);  int (*backup_remaining)(sqlite3_backup*);  int (*backup_step)(sqlite3_backup*,int);  const char *(*compileoption_get)(int);  int (*compileoption_used)(const char*);  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*),  void(*xDestroy)(void*));  int (*db_config)(sqlite3*,int,...);  sqlite3_mutex *(*db_mutex)(sqlite3*);  int (*db_status)(sqlite3*,int,int*,int*,int);  int (*extended_errcode)(sqlite3*);  void (*log)(int,const char*,...);  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);  const char *(*sourceid)(void);  int (*stmt_status)(sqlite3_stmt*,int,int);  int (*strnicmp)(const char*,const char*,int);  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);  int (*wal_autocheckpoint)(sqlite3*,int);  int (*wal_checkpoint)(sqlite3*,const char*);  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);  int (*vtab_config)(sqlite3*,int op,...);  int (*vtab_on_conflict)(sqlite3*);  int (*close_v2)(sqlite3*);  const char *(*db_filename)(sqlite3*,const char*);  int (*db_readonly)(sqlite3*,const char*);  int (*db_release_memory)(sqlite3*);  const char *(*errstr)(int);  int (*stmt_busy)(sqlite3_stmt*);  int (*stmt_readonly)(sqlite3_stmt*);  int (*stricmp)(const char*,const char*);  int (*uri_boolean)(const char*,const char*,int);  sqlite3_int64 (*uri_int64)(const char*,const char*,sqlite3_int64);  const char *(*uri_parameter)(const char*,const char*);  char *(*xvsnprintf)(int,char*,const char*,va_list);  int (*wal_checkpoint_v2)(sqlite3*,const char*,int,int*,int*);  int (*auto_extension)(void(*)(void));  int (*bind_blob64)(sqlite3_stmt*,int,const void*,sqlite3_uint64,   void(*)(void*));  int (*bind_text64)(sqlite3_stmt*,int,const char*,sqlite3_uint64,  void(*)(void*),unsigned char);  int (*cancel_auto_extension)(void(*)(void));  int (*load_extension)(sqlite3*,const char*,const char*,char**);  void *(*malloc64)(sqlite3_uint64);  sqlite3_uint64 (*msize)(void*);  void *(*realloc64)(void*,sqlite3_uint64);  void (*reset_auto_extension)(void);  void (*result_blob64)(sqlite3_context*,const void*,sqlite3_uint64,  void(*)(void*));  void (*result_text64)(sqlite3_context*,const char*,sqlite3_uint64,   void(*)(void*), unsigned char);  int (*strglob)(const char*,const char*);  sqlite3_value *(*value_dup)(const sqlite3_value*);  void (*value_free)(sqlite3_value*);  int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);  int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);  unsigned int (*value_subtype)(sqlite3_value*);  void (*result_subtype)(sqlite3_context*,unsigned int);  int (*status64)(int,sqlite3_int64*,sqlite3_int64*,int);  int (*strlike)(const char*,const char*,unsigned int);  int (*db_cacheflush)(sqlite3*);  int (*system_errno)(sqlite3*);  int (*trace_v2)(sqlite3*,unsigned,int(*)(unsigned,void*,void*,void*),void*);  char *(*expanded_sql)(sqlite3_stmt*);  void (*set_last_insert_rowid)(sqlite3*,sqlite3_int64);  int (*prepare_v3)(sqlite3*,const char*,int,unsigned int,  sqlite3_stmt**,const char**);  int (*prepare16_v3)(sqlite3*,const void*,int,unsigned int,  sqlite3_stmt**,const void**);  int (*bind_pointer)(sqlite3_stmt*,int,void*,const char*,void(*)(void*));  void (*result_pointer)(sqlite3_context*,void*,const char*,void(*)(void*));  void *(*value_pointer)(sqlite3_value*,const char*);  int (*vtab_nochange)(sqlite3_context*);  int (*value_nochange)(sqlite3_value*);  const char *(*vtab_collation)(sqlite3_index_info*,int);  int (*keyword_count)(void);  int (*keyword_name)(int,const char**,int*);  int (*keyword_check)(const char*,int);  sqlite3_str *(*str_new)(sqlite3*);  char *(*str_finish)(sqlite3_str*);  void (*str_appendf)(sqlite3_str*, const char *zFormat, ...);  void (*str_vappendf)(sqlite3_str*, const char *zFormat, va_list);  void (*str_append)(sqlite3_str*, const char *zIn, int N);  void (*str_appendall)(sqlite3_str*, const char *zIn);  void (*str_appendchar)(sqlite3_str*, int N, char C);  void (*str_reset)(sqlite3_str*);  int (*str_errcode)(sqlite3_str*);  int (*str_length)(sqlite3_str*);  char *(*str_value)(sqlite3_str*);  int (*create_window_function)(sqlite3*,const char*,int,int,void*,  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*),  void (*xValue)(sqlite3_context*),  void (*xInv)(sqlite3_context*,int,sqlite3_value**),  void(*xDestroy)(void*));  const char *(*normalized_sql)(sqlite3_stmt*);  int (*stmt_isexplain)(sqlite3_stmt*);  int (*value_frombind)(sqlite3_value*);  int (*drop_modules)(sqlite3*,const char**);  sqlite3_int64 (*hard_heap_limit64)(sqlite3_int64);  const char *(*uri_key)(const char*,int);  const char *(*filename_database)(const char*);  const char *(*filename_journal)(const char*);  const char *(*filename_wal)(const char*);  char *(*create_filename)(const char*,const char*,const char*,   int,const char**);  void (*free_filename)(char*);  sqlite3_file *(*database_file_object)(const char*);  int (*txn_state)(sqlite3*,const char*);  sqlite3_int64 (*changes64)(sqlite3*);  sqlite3_int64 (*total_changes64)(sqlite3*);  int (*autovacuum_pages)(sqlite3*,   unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),   void*, void(*)(void*)); }; typedef int (*sqlite3_loadext_entry)(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pThunk );
#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
#define sqlite3_aggregate_context sqlite3_api->aggregate_context
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_aggregate_count sqlite3_api->aggregate_count
#endif
#define sqlite3_bind_blob sqlite3_api->bind_blob
#define sqlite3_bind_double sqlite3_api->bind_double
#define sqlite3_bind_int  sqlite3_api->bind_int
#define sqlite3_bind_int64  sqlite3_api->bind_int64
#define sqlite3_bind_null sqlite3_api->bind_null
#define sqlite3_bind_parameter_count  sqlite3_api->bind_parameter_count
#define sqlite3_bind_parameter_index  sqlite3_api->bind_parameter_index
#define sqlite3_bind_parameter_name sqlite3_api->bind_parameter_name
#define sqlite3_bind_text sqlite3_api->bind_text
#define sqlite3_bind_text16 sqlite3_api->bind_text16
#define sqlite3_bind_value  sqlite3_api->bind_value
#define sqlite3_busy_handler  sqlite3_api->busy_handler
#define sqlite3_busy_timeout  sqlite3_api->busy_timeout
#define sqlite3_changes sqlite3_api->changes
#define sqlite3_close sqlite3_api->close
#define sqlite3_collation_needed  sqlite3_api->collation_needed
#define sqlite3_collation_needed16  sqlite3_api->collation_needed16
#define sqlite3_column_blob sqlite3_api->column_blob
#define sqlite3_column_bytes  sqlite3_api->column_bytes
#define sqlite3_column_bytes16  sqlite3_api->column_bytes16
#define sqlite3_column_count  sqlite3_api->column_count
#define sqlite3_column_database_name  sqlite3_api->column_database_name
#define sqlite3_column_database_name16 sqlite3_api->column_database_name16
#define sqlite3_column_decltype sqlite3_api->column_decltype
#define sqlite3_column_decltype16 sqlite3_api->column_decltype16
#define sqlite3_column_double sqlite3_api->column_double
#define sqlite3_column_int  sqlite3_api->column_int
#define sqlite3_column_int64  sqlite3_api->column_int64
#define sqlite3_column_name sqlite3_api->column_name
#define sqlite3_column_name16 sqlite3_api->column_name16
#define sqlite3_column_origin_name  sqlite3_api->column_origin_name
#define sqlite3_column_origin_name16  sqlite3_api->column_origin_name16
#define sqlite3_column_table_name sqlite3_api->column_table_name
#define sqlite3_column_table_name16 sqlite3_api->column_table_name16
#define sqlite3_column_text sqlite3_api->column_text
#define sqlite3_column_text16 sqlite3_api->column_text16
#define sqlite3_column_type sqlite3_api->column_type
#define sqlite3_column_value  sqlite3_api->column_value
#define sqlite3_commit_hook sqlite3_api->commit_hook
#define sqlite3_complete  sqlite3_api->complete
#define sqlite3_complete16  sqlite3_api->complete16
#define sqlite3_create_collation  sqlite3_api->create_collation
#define sqlite3_create_collation16  sqlite3_api->create_collation16
#define sqlite3_create_function sqlite3_api->create_function
#define sqlite3_create_function16 sqlite3_api->create_function16
#define sqlite3_create_module sqlite3_api->create_module
#define sqlite3_create_module_v2  sqlite3_api->create_module_v2
#define sqlite3_data_count  sqlite3_api->data_count
#define sqlite3_db_handle sqlite3_api->db_handle
#define sqlite3_declare_vtab  sqlite3_api->declare_vtab
#define sqlite3_enable_shared_cache sqlite3_api->enable_shared_cache
#define sqlite3_errcode sqlite3_api->errcode
#define sqlite3_errmsg  sqlite3_api->errmsg
#define sqlite3_errmsg16  sqlite3_api->errmsg16
#define sqlite3_exec  sqlite3_api->exec
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_expired sqlite3_api->expired
#endif
#define sqlite3_finalize  sqlite3_api->finalize
#define sqlite3_free  sqlite3_api->free
#define sqlite3_free_table  sqlite3_api->free_table
#define sqlite3_get_autocommit  sqlite3_api->get_autocommit
#define sqlite3_get_auxdata sqlite3_api->get_auxdata
#define sqlite3_get_table sqlite3_api->get_table
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_global_recover  sqlite3_api->global_recover
#endif
#define sqlite3_interrupt sqlite3_api->interruptx
#define sqlite3_last_insert_rowid sqlite3_api->last_insert_rowid
#define sqlite3_libversion  sqlite3_api->libversion
#define sqlite3_libversion_number sqlite3_api->libversion_number
#define sqlite3_malloc  sqlite3_api->malloc
#define sqlite3_mprintf sqlite3_api->mprintf
#define sqlite3_open  sqlite3_api->open
#define sqlite3_open16  sqlite3_api->open16
#define sqlite3_prepare sqlite3_api->prepare
#define sqlite3_prepare16 sqlite3_api->prepare16
#define sqlite3_prepare_v2  sqlite3_api->prepare_v2
#define sqlite3_prepare16_v2  sqlite3_api->prepare16_v2
#define sqlite3_profile sqlite3_api->profile
#define sqlite3_progress_handler  sqlite3_api->progress_handler
#define sqlite3_realloc sqlite3_api->realloc
#define sqlite3_reset sqlite3_api->reset
#define sqlite3_result_blob sqlite3_api->result_blob
#define sqlite3_result_double sqlite3_api->result_double
#define sqlite3_result_error  sqlite3_api->result_error
#define sqlite3_result_error16  sqlite3_api->result_error16
#define sqlite3_result_int  sqlite3_api->result_int
#define sqlite3_result_int64  sqlite3_api->result_int64
#define sqlite3_result_null sqlite3_api->result_null
#define sqlite3_result_text sqlite3_api->result_text
#define sqlite3_result_text16 sqlite3_api->result_text16
#define sqlite3_result_text16be sqlite3_api->result_text16be
#define sqlite3_result_text16le sqlite3_api->result_text16le
#define sqlite3_result_value  sqlite3_api->result_value
#define sqlite3_rollback_hook sqlite3_api->rollback_hook
#define sqlite3_set_authorizer  sqlite3_api->set_authorizer
#define sqlite3_set_auxdata sqlite3_api->set_auxdata
#define sqlite3_snprintf  sqlite3_api->xsnprintf
#define sqlite3_step  sqlite3_api->step
#define sqlite3_table_column_metadata sqlite3_api->table_column_metadata
#define sqlite3_thread_cleanup  sqlite3_api->thread_cleanup
#define sqlite3_total_changes sqlite3_api->total_changes
#define sqlite3_trace sqlite3_api->trace
#ifndef SQLITE_OMIT_DEPRECATED
#define sqlite3_transfer_bindings sqlite3_api->transfer_bindings
#endif
#define sqlite3_update_hook sqlite3_api->update_hook
#define sqlite3_user_data sqlite3_api->user_data
#define sqlite3_value_blob  sqlite3_api->value_blob
#define sqlite3_value_bytes sqlite3_api->value_bytes
#define sqlite3_value_bytes16 sqlite3_api->value_bytes16
#define sqlite3_value_double  sqlite3_api->value_double
#define sqlite3_value_int sqlite3_api->value_int
#define sqlite3_value_int64 sqlite3_api->value_int64
#define sqlite3_value_numeric_type  sqlite3_api->value_numeric_type
#define sqlite3_value_text  sqlite3_api->value_text
#define sqlite3_value_text16  sqlite3_api->value_text16
#define sqlite3_value_text16be  sqlite3_api->value_text16be
#define sqlite3_value_text16le  sqlite3_api->value_text16le
#define sqlite3_value_type  sqlite3_api->value_type
#define sqlite3_vmprintf  sqlite3_api->vmprintf
#define sqlite3_vsnprintf sqlite3_api->xvsnprintf
#define sqlite3_overload_function sqlite3_api->overload_function
#define sqlite3_prepare_v2  sqlite3_api->prepare_v2
#define sqlite3_prepare16_v2  sqlite3_api->prepare16_v2
#define sqlite3_clear_bindings  sqlite3_api->clear_bindings
#define sqlite3_bind_zeroblob sqlite3_api->bind_zeroblob
#define sqlite3_blob_bytes  sqlite3_api->blob_bytes
#define sqlite3_blob_close  sqlite3_api->blob_close
#define sqlite3_blob_open sqlite3_api->blob_open
#define sqlite3_blob_read sqlite3_api->blob_read
#define sqlite3_blob_write  sqlite3_api->blob_write
#define sqlite3_create_collation_v2 sqlite3_api->create_collation_v2
#define sqlite3_file_control  sqlite3_api->file_control
#define sqlite3_memory_highwater  sqlite3_api->memory_highwater
#define sqlite3_memory_used sqlite3_api->memory_used
#define sqlite3_mutex_alloc sqlite3_api->mutex_alloc
#define sqlite3_mutex_enter sqlite3_api->mutex_enter
#define sqlite3_mutex_free  sqlite3_api->mutex_free
#define sqlite3_mutex_leave sqlite3_api->mutex_leave
#define sqlite3_mutex_try sqlite3_api->mutex_try
#define sqlite3_open_v2 sqlite3_api->open_v2
#define sqlite3_release_memory  sqlite3_api->release_memory
#define sqlite3_result_error_nomem  sqlite3_api->result_error_nomem
#define sqlite3_result_error_toobig sqlite3_api->result_error_toobig
#define sqlite3_sleep sqlite3_api->sleep
#define sqlite3_soft_heap_limit sqlite3_api->soft_heap_limit
#define sqlite3_vfs_find  sqlite3_api->vfs_find
#define sqlite3_vfs_register  sqlite3_api->vfs_register
#define sqlite3_vfs_unregister  sqlite3_api->vfs_unregister
#define sqlite3_threadsafe  sqlite3_api->xthreadsafe
#define sqlite3_result_zeroblob sqlite3_api->result_zeroblob
#define sqlite3_result_error_code sqlite3_api->result_error_code
#define sqlite3_test_control  sqlite3_api->test_control
#define sqlite3_randomness  sqlite3_api->randomness
#define sqlite3_context_db_handle sqlite3_api->context_db_handle
#define sqlite3_extended_result_codes sqlite3_api->extended_result_codes
#define sqlite3_limit sqlite3_api->limit
#define sqlite3_next_stmt sqlite3_api->next_stmt
#define sqlite3_sql sqlite3_api->sql
#define sqlite3_status  sqlite3_api->status
#define sqlite3_backup_finish sqlite3_api->backup_finish
#define sqlite3_backup_init sqlite3_api->backup_init
#define sqlite3_backup_pagecount  sqlite3_api->backup_pagecount
#define sqlite3_backup_remaining  sqlite3_api->backup_remaining
#define sqlite3_backup_step sqlite3_api->backup_step
#define sqlite3_compileoption_get sqlite3_api->compileoption_get
#define sqlite3_compileoption_used  sqlite3_api->compileoption_used
#define sqlite3_create_function_v2  sqlite3_api->create_function_v2
#define sqlite3_db_config sqlite3_api->db_config
#define sqlite3_db_mutex  sqlite3_api->db_mutex
#define sqlite3_db_status sqlite3_api->db_status
#define sqlite3_extended_errcode  sqlite3_api->extended_errcode
#define sqlite3_log sqlite3_api->log
#define sqlite3_soft_heap_limit64 sqlite3_api->soft_heap_limit64
#define sqlite3_sourceid  sqlite3_api->sourceid
#define sqlite3_stmt_status sqlite3_api->stmt_status
#define sqlite3_strnicmp  sqlite3_api->strnicmp
#define sqlite3_unlock_notify sqlite3_api->unlock_notify
#define sqlite3_wal_autocheckpoint  sqlite3_api->wal_autocheckpoint
#define sqlite3_wal_checkpoint  sqlite3_api->wal_checkpoint
#define sqlite3_wal_hook  sqlite3_api->wal_hook
#define sqlite3_blob_reopen sqlite3_api->blob_reopen
#define sqlite3_vtab_config sqlite3_api->vtab_config
#define sqlite3_vtab_on_conflict  sqlite3_api->vtab_on_conflict
#define sqlite3_close_v2  sqlite3_api->close_v2
#define sqlite3_db_filename sqlite3_api->db_filename
#define sqlite3_db_readonly sqlite3_api->db_readonly
#define sqlite3_db_release_memory sqlite3_api->db_release_memory
#define sqlite3_errstr  sqlite3_api->errstr
#define sqlite3_stmt_busy sqlite3_api->stmt_busy
#define sqlite3_stmt_readonly sqlite3_api->stmt_readonly
#define sqlite3_stricmp sqlite3_api->stricmp
#define sqlite3_uri_boolean sqlite3_api->uri_boolean
#define sqlite3_uri_int64 sqlite3_api->uri_int64
#define sqlite3_uri_parameter sqlite3_api->uri_parameter
#define sqlite3_uri_vsnprintf sqlite3_api->xvsnprintf
#define sqlite3_wal_checkpoint_v2 sqlite3_api->wal_checkpoint_v2
#define sqlite3_auto_extension  sqlite3_api->auto_extension
#define sqlite3_bind_blob64 sqlite3_api->bind_blob64
#define sqlite3_bind_text64 sqlite3_api->bind_text64
#define sqlite3_cancel_auto_extension sqlite3_api->cancel_auto_extension
#define sqlite3_load_extension  sqlite3_api->load_extension
#define sqlite3_malloc64  sqlite3_api->malloc64
#define sqlite3_msize sqlite3_api->msize
#define sqlite3_realloc64 sqlite3_api->realloc64
#define sqlite3_reset_auto_extension  sqlite3_api->reset_auto_extension
#define sqlite3_result_blob64 sqlite3_api->result_blob64
#define sqlite3_result_text64 sqlite3_api->result_text64
#define sqlite3_strglob sqlite3_api->strglob
#define sqlite3_value_dup sqlite3_api->value_dup
#define sqlite3_value_free  sqlite3_api->value_free
#define sqlite3_result_zeroblob64 sqlite3_api->result_zeroblob64
#define sqlite3_bind_zeroblob64 sqlite3_api->bind_zeroblob64
#define sqlite3_value_subtype sqlite3_api->value_subtype
#define sqlite3_result_subtype  sqlite3_api->result_subtype
#define sqlite3_status64  sqlite3_api->status64
#define sqlite3_strlike sqlite3_api->strlike
#define sqlite3_db_cacheflush sqlite3_api->db_cacheflush
#define sqlite3_system_errno  sqlite3_api->system_errno
#define sqlite3_trace_v2  sqlite3_api->trace_v2
#define sqlite3_expanded_sql  sqlite3_api->expanded_sql
#define sqlite3_set_last_insert_rowid sqlite3_api->set_last_insert_rowid
#define sqlite3_prepare_v3  sqlite3_api->prepare_v3
#define sqlite3_prepare16_v3  sqlite3_api->prepare16_v3
#define sqlite3_bind_pointer  sqlite3_api->bind_pointer
#define sqlite3_result_pointer  sqlite3_api->result_pointer
#define sqlite3_value_pointer sqlite3_api->value_pointer
#define sqlite3_vtab_nochange sqlite3_api->vtab_nochange
#define sqlite3_value_nochange  sqlite3_api->value_nochange
#define sqlite3_vtab_collation  sqlite3_api->vtab_collation
#define sqlite3_keyword_count sqlite3_api->keyword_count
#define sqlite3_keyword_name  sqlite3_api->keyword_name
#define sqlite3_keyword_check sqlite3_api->keyword_check
#define sqlite3_str_new sqlite3_api->str_new
#define sqlite3_str_finish  sqlite3_api->str_finish
#define sqlite3_str_appendf sqlite3_api->str_appendf
#define sqlite3_str_vappendf  sqlite3_api->str_vappendf
#define sqlite3_str_append  sqlite3_api->str_append
#define sqlite3_str_appendall sqlite3_api->str_appendall
#define sqlite3_str_appendchar  sqlite3_api->str_appendchar
#define sqlite3_str_reset sqlite3_api->str_reset
#define sqlite3_str_errcode sqlite3_api->str_errcode
#define sqlite3_str_length  sqlite3_api->str_length
#define sqlite3_str_value sqlite3_api->str_value
#define sqlite3_create_window_function sqlite3_api->create_window_function
#define sqlite3_normalized_sql  sqlite3_api->normalized_sql
#define sqlite3_stmt_isexplain  sqlite3_api->stmt_isexplain
#define sqlite3_value_frombind  sqlite3_api->value_frombind
#define sqlite3_drop_modules  sqlite3_api->drop_modules
#define sqlite3_hard_heap_limit64 sqlite3_api->hard_heap_limit64
#define sqlite3_uri_key sqlite3_api->uri_key
#define sqlite3_filename_database sqlite3_api->filename_database
#define sqlite3_filename_journal  sqlite3_api->filename_journal
#define sqlite3_filename_wal  sqlite3_api->filename_wal
#define sqlite3_create_filename sqlite3_api->create_filename
#define sqlite3_free_filename sqlite3_api->free_filename
#define sqlite3_database_file_object  sqlite3_api->database_file_object
#define sqlite3_txn_state sqlite3_api->txn_state
#define sqlite3_changes64 sqlite3_api->changes64
#define sqlite3_total_changes64 sqlite3_api->total_changes64
#define sqlite3_autovacuum_pages  sqlite3_api->autovacuum_pages
#endif
#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
# define SQLITE_EXTENSION_INIT1  const sqlite3_api_routines *sqlite3_api=0;
# define SQLITE_EXTENSION_INIT2(v) sqlite3_api=v;
# define SQLITE_EXTENSION_INIT3   extern const sqlite3_api_routines *sqlite3_api;

#else
# define SQLITE_EXTENSION_INIT1
# define SQLITE_EXTENSION_INIT2(v) (void)v;
# define SQLITE_EXTENSION_INIT3
#endif
#endif
#ifndef SQLITE_OMIT_LOAD_EXTENSION
#ifndef SQLITE_ENABLE_COLUMN_METADATA
# define sqlite3_column_database_name  0
# define sqlite3_column_database_name16 0
# define sqlite3_column_table_name 0
# define sqlite3_column_table_name16 0
# define sqlite3_column_origin_name  0
# define sqlite3_column_origin_name16  0
#endif
#ifdef SQLITE_OMIT_AUTHORIZATION
# define sqlite3_set_authorizer  0
#endif
#ifdef SQLITE_OMIT_UTF16
# define sqlite3_bind_text16 0
# define sqlite3_collation_needed16  0
# define sqlite3_column_decltype16 0
# define sqlite3_column_name16 0
# define sqlite3_column_text16 0
# define sqlite3_complete16  0
# define sqlite3_create_collation16  0
# define sqlite3_create_function16 0
# define sqlite3_errmsg16  0
# define sqlite3_open16  0
# define sqlite3_prepare16 0
# define sqlite3_prepare16_v2  0
# define sqlite3_prepare16_v3  0
# define sqlite3_result_error16  0
# define sqlite3_result_text16 0
# define sqlite3_result_text16be 0
# define sqlite3_result_text16le 0
# define sqlite3_value_text16  0
# define sqlite3_value_text16be  0
# define sqlite3_value_text16le  0
# define sqlite3_column_database_name16 0
# define sqlite3_column_table_name16 0
# define sqlite3_column_origin_name16  0
#endif
#ifdef SQLITE_OMIT_COMPLETE
# define sqlite3_complete 0
# define sqlite3_complete16 0
#endif
#ifdef SQLITE_OMIT_DECLTYPE
# define sqlite3_column_decltype16 0
# define sqlite3_column_decltype 0
#endif
#ifdef SQLITE_OMIT_PROGRESS_CALLBACK
# define sqlite3_progress_handler 0
#endif
#ifdef SQLITE_OMIT_VIRTUALTABLE
# define sqlite3_create_module 0
# define sqlite3_create_module_v2 0
# define sqlite3_declare_vtab 0
# define sqlite3_vtab_config 0
# define sqlite3_vtab_on_conflict 0
# define sqlite3_vtab_collation 0
#endif
#ifdef SQLITE_OMIT_SHARED_CACHE
# define sqlite3_enable_shared_cache 0
#endif
#if defined(SQLITE_OMIT_TRACE) || defined(SQLITE_OMIT_DEPRECATED)
# define sqlite3_profile  0
# define sqlite3_trace  0
#endif
#ifdef SQLITE_OMIT_GET_TABLE
# define sqlite3_free_table 0
# define sqlite3_get_table  0
#endif
#ifdef SQLITE_OMIT_INCRBLOB
#define sqlite3_bind_zeroblob 0
#define sqlite3_blob_bytes  0
#define sqlite3_blob_close  0
#define sqlite3_blob_open 0
#define sqlite3_blob_read 0
#define sqlite3_blob_write  0
#define sqlite3_blob_reopen 0
#endif
#if defined(SQLITE_OMIT_TRACE)
# define sqlite3_trace_v2 0
#endif
static const sqlite3_api_routines sqlite3Apis = {  sqlite3_aggregate_context,
#ifndef SQLITE_OMIT_DEPRECATED
 sqlite3_aggregate_count,
#else
 0,
#endif
 sqlite3_bind_blob,  sqlite3_bind_double,  sqlite3_bind_int,  sqlite3_bind_int64,  sqlite3_bind_null,  sqlite3_bind_parameter_count,  sqlite3_bind_parameter_index,  sqlite3_bind_parameter_name,  sqlite3_bind_text,  sqlite3_bind_text16,  sqlite3_bind_value,  sqlite3_busy_handler,  sqlite3_busy_timeout,  sqlite3_changes,  sqlite3_close,  sqlite3_collation_needed,  sqlite3_collation_needed16,  sqlite3_column_blob,  sqlite3_column_bytes,  sqlite3_column_bytes16,  sqlite3_column_count,  sqlite3_column_database_name,  sqlite3_column_database_name16,  sqlite3_column_decltype,  sqlite3_column_decltype16,  sqlite3_column_double,  sqlite3_column_int,  sqlite3_column_int64,  sqlite3_column_name,  sqlite3_column_name16,  sqlite3_column_origin_name,  sqlite3_column_origin_name16,  sqlite3_column_table_name,  sqlite3_column_table_name16,  sqlite3_column_text,  sqlite3_column_text16,  sqlite3_column_type,  sqlite3_column_value,  sqlite3_commit_hook,  sqlite3_complete,  sqlite3_complete16,  sqlite3_create_collation,  sqlite3_create_collation16,  sqlite3_create_function,  sqlite3_create_function16,  sqlite3_create_module,  sqlite3_data_count,  sqlite3_db_handle,  sqlite3_declare_vtab,  sqlite3_enable_shared_cache,  sqlite3_errcode,  sqlite3_errmsg,  sqlite3_errmsg16,  sqlite3_exec,
#ifndef SQLITE_OMIT_DEPRECATED
 sqlite3_expired,
#else
 0,
#endif
 sqlite3_finalize,  sqlite3_free,  sqlite3_free_table,  sqlite3_get_autocommit,  sqlite3_get_auxdata,  sqlite3_get_table,  0,  sqlite3_interrupt,  sqlite3_last_insert_rowid,  sqlite3_libversion,  sqlite3_libversion_number,  sqlite3_malloc,  sqlite3_mprintf,  sqlite3_open,  sqlite3_open16,  sqlite3_prepare,  sqlite3_prepare16,  sqlite3_profile,  sqlite3_progress_handler,  sqlite3_realloc,  sqlite3_reset,  sqlite3_result_blob,  sqlite3_result_double,  sqlite3_result_error,  sqlite3_result_error16,  sqlite3_result_int,  sqlite3_result_int64,  sqlite3_result_null,  sqlite3_result_text,  sqlite3_result_text16,  sqlite3_result_text16be,  sqlite3_result_text16le,  sqlite3_result_value,  sqlite3_rollback_hook,  sqlite3_set_authorizer,  sqlite3_set_auxdata,  sqlite3_snprintf,  sqlite3_step,  sqlite3_table_column_metadata,
#ifndef SQLITE_OMIT_DEPRECATED
 sqlite3_thread_cleanup,
#else
 0,
#endif
 sqlite3_total_changes,  sqlite3_trace,
#ifndef SQLITE_OMIT_DEPRECATED
 sqlite3_transfer_bindings,
#else
 0,
#endif
 sqlite3_update_hook,  sqlite3_user_data,  sqlite3_value_blob,  sqlite3_value_bytes,  sqlite3_value_bytes16,  sqlite3_value_double,  sqlite3_value_int,  sqlite3_value_int64,  sqlite3_value_numeric_type,  sqlite3_value_text,  sqlite3_value_text16,  sqlite3_value_text16be,  sqlite3_value_text16le,  sqlite3_value_type,  sqlite3_vmprintf,  sqlite3_overload_function,  sqlite3_prepare_v2,  sqlite3_prepare16_v2,  sqlite3_clear_bindings,  sqlite3_create_module_v2,  sqlite3_bind_zeroblob,  sqlite3_blob_bytes,  sqlite3_blob_close,  sqlite3_blob_open,  sqlite3_blob_read,  sqlite3_blob_write,  sqlite3_create_collation_v2,  sqlite3_file_control,  sqlite3_memory_highwater,  sqlite3_memory_used,
#ifdef SQLITE_MUTEX_OMIT
 0,  0,  0,  0,  0,
#else
 sqlite3_mutex_alloc,  sqlite3_mutex_enter,  sqlite3_mutex_free,  sqlite3_mutex_leave,  sqlite3_mutex_try,
#endif
 sqlite3_open_v2,  sqlite3_release_memory,  sqlite3_result_error_nomem,  sqlite3_result_error_toobig,  sqlite3_sleep,  sqlite3_soft_heap_limit,  sqlite3_vfs_find,  sqlite3_vfs_register,  sqlite3_vfs_unregister,  sqlite3_threadsafe,  sqlite3_result_zeroblob,  sqlite3_result_error_code,  sqlite3_test_control,  sqlite3_randomness,  sqlite3_context_db_handle,  sqlite3_extended_result_codes,  sqlite3_limit,  sqlite3_next_stmt,  sqlite3_sql,  sqlite3_status,  sqlite3_backup_finish,  sqlite3_backup_init,  sqlite3_backup_pagecount,  sqlite3_backup_remaining,  sqlite3_backup_step,
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
 sqlite3_compileoption_get,  sqlite3_compileoption_used,
#else
 0,  0,
#endif
 sqlite3_create_function_v2,  sqlite3_db_config,  sqlite3_db_mutex,  sqlite3_db_status,  sqlite3_extended_errcode,  sqlite3_log,  sqlite3_soft_heap_limit64,  sqlite3_sourceid,  sqlite3_stmt_status,  sqlite3_strnicmp,
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
 sqlite3_unlock_notify,
#else
 0,
#endif
#ifndef SQLITE_OMIT_WAL
 sqlite3_wal_autocheckpoint,  sqlite3_wal_checkpoint,  sqlite3_wal_hook,
#else
 0,  0,  0,
#endif
 sqlite3_blob_reopen,  sqlite3_vtab_config,  sqlite3_vtab_on_conflict,  sqlite3_close_v2,  sqlite3_db_filename,  sqlite3_db_readonly,  sqlite3_db_release_memory,  sqlite3_errstr,  sqlite3_stmt_busy,  sqlite3_stmt_readonly,  sqlite3_stricmp,  sqlite3_uri_boolean,  sqlite3_uri_int64,  sqlite3_uri_parameter,  sqlite3_vsnprintf,  sqlite3_wal_checkpoint_v2,  sqlite3_auto_extension,  sqlite3_bind_blob64,  sqlite3_bind_text64,  sqlite3_cancel_auto_extension,  sqlite3_load_extension,  sqlite3_malloc64,  sqlite3_msize,  sqlite3_realloc64,  sqlite3_reset_auto_extension,  sqlite3_result_blob64,  sqlite3_result_text64,  sqlite3_strglob,  (sqlite3_value*(*)(const sqlite3_value*))sqlite3_value_dup,  sqlite3_value_free,  sqlite3_result_zeroblob64,  sqlite3_bind_zeroblob64,  sqlite3_value_subtype,  sqlite3_result_subtype,  sqlite3_status64,  sqlite3_strlike,  sqlite3_db_cacheflush,  sqlite3_system_errno,  sqlite3_trace_v2,  sqlite3_expanded_sql,  sqlite3_set_last_insert_rowid,  sqlite3_prepare_v3,  sqlite3_prepare16_v3,  sqlite3_bind_pointer,  sqlite3_result_pointer,  sqlite3_value_pointer,  sqlite3_vtab_nochange,  sqlite3_value_nochange,  sqlite3_vtab_collation,  sqlite3_keyword_count,  sqlite3_keyword_name,  sqlite3_keyword_check,  sqlite3_str_new,  sqlite3_str_finish,  sqlite3_str_appendf,  sqlite3_str_vappendf,  sqlite3_str_append,  sqlite3_str_appendall,  sqlite3_str_appendchar,  sqlite3_str_reset,  sqlite3_str_errcode,  sqlite3_str_length,  sqlite3_str_value,  sqlite3_create_window_function,
#ifdef SQLITE_ENABLE_NORMALIZE
 sqlite3_normalized_sql,
#else
 0,
#endif
 sqlite3_stmt_isexplain,  sqlite3_value_frombind,
#ifndef SQLITE_OMIT_VIRTUALTABLE
 sqlite3_drop_modules,
#else
 0,
#endif
 sqlite3_hard_heap_limit64,  sqlite3_uri_key,  sqlite3_filename_database,  sqlite3_filename_journal,  sqlite3_filename_wal,  sqlite3_create_filename,  sqlite3_free_filename,  sqlite3_database_file_object,  sqlite3_txn_state,  sqlite3_changes64,  sqlite3_total_changes64,  sqlite3_autovacuum_pages, };
#if SQLITE_OS_WIN
# define DirSep(X) ((X)=='/'||(X)=='\\')
#else
# define DirSep(X) ((X)=='/')
#endif
static int sqlite3LoadExtension(  sqlite3 *db,  const char *zFile,  const char *zProc,  char **pzErrMsg ){  sqlite3_vfs *pVfs = db->pVfs;  void *handle;  sqlite3_loadext_entry xInit;  char *zErrmsg = 0;  const char *zEntry;  char *zAltEntry = 0;  void **aHandle;  u64 nMsg = strlen(zFile);  int ii;  int rc;  static const char *azEndings[] = {
#if SQLITE_OS_WIN
  "dll"
#elif defined(__APPLE__)
  "dylib"
#else
  "so"
#endif
 };  if( pzErrMsg ) *pzErrMsg = 0;  if( (db->flags & SQLITE_LoadExtension)==0 ){  if( pzErrMsg ){  *pzErrMsg = sqlite3_mprintf("not authorized");  }  return SQLITE_ERROR;  }  zEntry = zProc ? zProc : "sqlite3_extension_init";  if( nMsg>SQLITE_MAX_PATHLEN ) goto extension_not_found;  handle = sqlite3OsDlOpen(pVfs, zFile);
#if SQLITE_OS_UNIX || SQLITE_OS_WIN
 for(ii=0; ii<ArraySize(azEndings) && handle==0; ii++){  char *zAltFile = sqlite3_mprintf("%s.%s", zFile, azEndings[ii]);  if( zAltFile==0 ) return SQLITE_NOMEM_BKPT;  handle = sqlite3OsDlOpen(pVfs, zAltFile);  sqlite3_free(zAltFile);  }
#endif
 if( handle==0 ) goto extension_not_found;  xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);  if( xInit==0 && zProc==0 ){  int iFile, iEntry, c;  int ncFile = sqlite3Strlen30(zFile);  zAltEntry = sqlite3_malloc64(ncFile+30);  if( zAltEntry==0 ){  sqlite3OsDlClose(pVfs, handle);  return SQLITE_NOMEM_BKPT;  }  memcpy(zAltEntry, "sqlite3_", 8);  for(iFile=ncFile-1; iFile>=0 && !DirSep(zFile[iFile]); iFile--){}  iFile++;  if( sqlite3_strnicmp(zFile+iFile, "lib", 3)==0 ) iFile += 3;  for(iEntry=8; (c = zFile[iFile])!=0 && c!='.'; iFile++){  if( sqlite3Isalpha(c) ){  zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];  }  }  memcpy(zAltEntry+iEntry, "_init", 6);  zEntry = zAltEntry;  xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);  }  if( xInit==0 ){  if( pzErrMsg ){  nMsg += strlen(zEntry) + 300;  *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);  if( zErrmsg ){  assert( nMsg<0x7fffffff );  sqlite3_snprintf((int)nMsg, zErrmsg,  "no entry point [%s] in shared library [%s]", zEntry, zFile);  sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);  }  }  sqlite3OsDlClose(pVfs, handle);  sqlite3_free(zAltEntry);  return SQLITE_ERROR;  }  sqlite3_free(zAltEntry);  rc = xInit(db, &zErrmsg, &sqlite3Apis);  if( rc ){  if( rc==SQLITE_OK_LOAD_PERMANENTLY ) return SQLITE_OK;  if( pzErrMsg ){  *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);  }  sqlite3_free(zErrmsg);  sqlite3OsDlClose(pVfs, handle);  return SQLITE_ERROR;  }  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));  if( aHandle==0 ){  return SQLITE_NOMEM_BKPT;  }  if( db->nExtension>0 ){  memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);  }  sqlite3DbFree(db, db->aExtension);  db->aExtension = aHandle;  db->aExtension[db->nExtension++] = handle;  return SQLITE_OK; extension_not_found:  if( pzErrMsg ){  nMsg += 300;  *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);  if( zErrmsg ){  assert( nMsg<0x7fffffff );  sqlite3_snprintf((int)nMsg, zErrmsg,  "unable to open shared library [%.*s]", SQLITE_MAX_PATHLEN, zFile);  sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);  }  }  return SQLITE_ERROR; } SQLITE_API int sqlite3_load_extension(  sqlite3 *db,  const char *zFile,  const char *zProc,  char **pzErrMsg ){  int rc;  sqlite3_mutex_enter(db->mutex);  rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db){  int i;  assert( sqlite3_mutex_held(db->mutex) );  for(i=0; i<db->nExtension; i++){  sqlite3OsDlClose(db->pVfs, db->aExtension[i]);  }  sqlite3DbFree(db, db->aExtension); } SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff){  sqlite3_mutex_enter(db->mutex);  if( onoff ){  db->flags |= SQLITE_LoadExtension|SQLITE_LoadExtFunc;  }else{  db->flags &= ~(u64)(SQLITE_LoadExtension|SQLITE_LoadExtFunc);  }  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; }
#endif
typedef struct sqlite3AutoExtList sqlite3AutoExtList; static SQLITE_WSD struct sqlite3AutoExtList {  u32 nExt;  void (**aExt)(void); } sqlite3Autoext = { 0, 0 };
#ifdef SQLITE_OMIT_WSD
# define wsdAutoextInit  sqlite3AutoExtList *x = &GLOBAL(sqlite3AutoExtList,sqlite3Autoext)

# define wsdAutoext x[0]
#else
# define wsdAutoextInit
# define wsdAutoext sqlite3Autoext
#endif
SQLITE_API int sqlite3_auto_extension(  void (*xInit)(void) ){  int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_AUTOINIT
 rc = sqlite3_initialize();  if( rc ){  return rc;  }else
#endif
 {  u32 i;
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
 wsdAutoextInit;  sqlite3_mutex_enter(mutex);  for(i=0; i<wsdAutoext.nExt; i++){  if( wsdAutoext.aExt[i]==xInit ) break;  }  if( i==wsdAutoext.nExt ){  u64 nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);  void (**aNew)(void);  aNew = sqlite3_realloc64(wsdAutoext.aExt, nByte);  if( aNew==0 ){  rc = SQLITE_NOMEM_BKPT;  }else{  wsdAutoext.aExt = aNew;  wsdAutoext.aExt[wsdAutoext.nExt] = xInit;  wsdAutoext.nExt++;  }  }  sqlite3_mutex_leave(mutex);  assert( (rc&0xff)==rc );  return rc;  } } SQLITE_API int sqlite3_cancel_auto_extension(  void (*xInit)(void) ){
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
 int i;  int n = 0;  wsdAutoextInit;  sqlite3_mutex_enter(mutex);  for(i=(int)wsdAutoext.nExt-1; i>=0; i--){  if( wsdAutoext.aExt[i]==xInit ){  wsdAutoext.nExt--;  wsdAutoext.aExt[i] = wsdAutoext.aExt[wsdAutoext.nExt];  n++;  break;  }  }  sqlite3_mutex_leave(mutex);  return n; } SQLITE_API void sqlite3_reset_auto_extension(void){
#ifndef SQLITE_OMIT_AUTOINIT
 if( sqlite3_initialize()==SQLITE_OK )
#endif
 {
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
 wsdAutoextInit;  sqlite3_mutex_enter(mutex);  sqlite3_free(wsdAutoext.aExt);  wsdAutoext.aExt = 0;  wsdAutoext.nExt = 0;  sqlite3_mutex_leave(mutex);  } } SQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db){  u32 i;  int go = 1;  int rc;  sqlite3_loadext_entry xInit;  wsdAutoextInit;  if( wsdAutoext.nExt==0 ){  return;  }  for(i=0; go; i++){  char *zErrmsg;
#if SQLITE_THREADSAFE
 sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN);
#endif
#ifdef SQLITE_OMIT_LOAD_EXTENSION
 const sqlite3_api_routines *pThunk = 0;
#else
 const sqlite3_api_routines *pThunk = &sqlite3Apis;
#endif
 sqlite3_mutex_enter(mutex);  if( i>=wsdAutoext.nExt ){  xInit = 0;  go = 0;  }else{  xInit = (sqlite3_loadext_entry)wsdAutoext.aExt[i];  }  sqlite3_mutex_leave(mutex);  zErrmsg = 0;  if( xInit && (rc = xInit(db, &zErrmsg, pThunk))!=0 ){  sqlite3ErrorWithMsg(db, rc,  "automatic extension loading failed: %s", zErrmsg);  go = 0;  }  sqlite3_free(zErrmsg);  } }
#if !defined(SQLITE_ENABLE_LOCKING_STYLE)
# if defined(__APPLE__)
# define SQLITE_ENABLE_LOCKING_STYLE 1
# else
# define SQLITE_ENABLE_LOCKING_STYLE 0
# endif
#endif
#define PragTyp_ACTIVATE_EXTENSIONS 0
#define PragTyp_ANALYSIS_LIMIT  1
#define PragTyp_HEADER_VALUE  2
#define PragTyp_AUTO_VACUUM 3
#define PragTyp_FLAG  4
#define PragTyp_BUSY_TIMEOUT  5
#define PragTyp_CACHE_SIZE  6
#define PragTyp_CACHE_SPILL 7
#define PragTyp_CASE_SENSITIVE_LIKE 8
#define PragTyp_COLLATION_LIST  9
#define PragTyp_COMPILE_OPTIONS  10
#define PragTyp_DATA_STORE_DIRECTORY 11
#define PragTyp_DATABASE_LIST  12
#define PragTyp_DEFAULT_CACHE_SIZE 13
#define PragTyp_ENCODING 14
#define PragTyp_FOREIGN_KEY_CHECK  15
#define PragTyp_FOREIGN_KEY_LIST 16
#define PragTyp_FUNCTION_LIST  17
#define PragTyp_HARD_HEAP_LIMIT  18
#define PragTyp_INCREMENTAL_VACUUM 19
#define PragTyp_INDEX_INFO 20
#define PragTyp_INDEX_LIST 21
#define PragTyp_INTEGRITY_CHECK  22
#define PragTyp_JOURNAL_MODE 23
#define PragTyp_JOURNAL_SIZE_LIMIT 24
#define PragTyp_LOCK_PROXY_FILE  25
#define PragTyp_LOCKING_MODE 26
#define PragTyp_PAGE_COUNT 27
#define PragTyp_MMAP_SIZE  28
#define PragTyp_MODULE_LIST  29
#define PragTyp_OPTIMIZE 30
#define PragTyp_PAGE_SIZE  31
#define PragTyp_PRAGMA_LIST  32
#define PragTyp_SECURE_DELETE  33
#define PragTyp_SHRINK_MEMORY  34
#define PragTyp_SOFT_HEAP_LIMIT  35
#define PragTyp_SYNCHRONOUS  36
#define PragTyp_TABLE_INFO 37
#define PragTyp_TABLE_LIST 38
#define PragTyp_TEMP_STORE 39
#define PragTyp_TEMP_STORE_DIRECTORY 40
#define PragTyp_THREADS  41
#define PragTyp_WAL_AUTOCHECKPOINT 42
#define PragTyp_WAL_CHECKPOINT 43
#define PragTyp_LOCK_STATUS  44
#define PragTyp_STATS  45
#define PragFlg_NeedSchema 0x01
#define PragFlg_NoColumns 0x02
#define PragFlg_NoColumns1 0x04
#define PragFlg_ReadOnly  0x08
#define PragFlg_Result0 0x10
#define PragFlg_Result1 0x20
#define PragFlg_SchemaOpt 0x40
#define PragFlg_SchemaReq 0x80
static const char *const pragCName[] = {  "seq",  "table",  "from",  "to",  "on_update",  "on_delete",  "match",  "name",  "type",  "notnull",  "dflt_value",  "pk",  "hidden",  "name",  "type",  "ncol",  "wr",  "strict",  "cid",  "name",  "desc",  "coll",  "key",  "builtin",  "type",  "enc",  "narg",  "flags",  "idx",  "wdth",  "hght",  "flgs",  "name",  "unique",  "origin",  "partial",  "rowid",  "parent",  "fkid",  "name",  "file",  "log",  "checkpointed",  "status", }; typedef struct PragmaName {  const char *const zName;  u8 ePragTyp;  u8 mPragFlg;  u8 iPragCName;  u8 nPragCName;  u64 iArg; } PragmaName; static const PragmaName aPragmaName[] = {
#if defined(SQLITE_ENABLE_CEROD)
 { "activate_extensions",  PragTyp_ACTIVATE_EXTENSIONS,  0,  0, 0,  0 },
#endif
 { "analysis_limit",  PragTyp_ANALYSIS_LIMIT,  PragFlg_Result0,  0, 0,  0 },
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
 { "application_id",  PragTyp_HEADER_VALUE,  PragFlg_NoColumns1|PragFlg_Result0,  0, 0,  BTREE_APPLICATION_ID },
#endif
#if !defined(SQLITE_OMIT_AUTOVACUUM)
 { "auto_vacuum",  PragTyp_AUTO_VACUUM,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_AUTOMATIC_INDEX)
 { "automatic_index",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_AutoIndex },
#endif
#endif
 { "busy_timeout",  PragTyp_BUSY_TIMEOUT,  PragFlg_Result0,  56, 1,  0 },
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "cache_size",  PragTyp_CACHE_SIZE,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "cache_spill",  PragTyp_CACHE_SPILL,  PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA)
 { "case_sensitive_like",  PragTyp_CASE_SENSITIVE_LIKE,  PragFlg_NoColumns,  0, 0,  0 },
#endif
 { "cell_size_check",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_CellSizeCk },
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "checkpoint_fullfsync",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_CkptFullFSync },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
 { "collation_list",  PragTyp_COLLATION_LIST,  PragFlg_Result0,  38, 2,  0 },
#endif
#if !defined(SQLITE_OMIT_COMPILEOPTION_DIAGS)
 { "compile_options",  PragTyp_COMPILE_OPTIONS,  PragFlg_Result0,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "count_changes",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_CountRows },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && SQLITE_OS_WIN
 { "data_store_directory",  PragTyp_DATA_STORE_DIRECTORY,  PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
 { "data_version",  PragTyp_HEADER_VALUE,  PragFlg_ReadOnly|PragFlg_Result0,  0, 0,  BTREE_DATA_VERSION },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
 { "database_list",  PragTyp_DATABASE_LIST,  PragFlg_NeedSchema|PragFlg_Result0,  47, 3,  0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)
 { "default_cache_size",  PragTyp_DEFAULT_CACHE_SIZE,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,  55, 1,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
 { "defer_foreign_keys",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_DeferFKs },
#endif
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "empty_result_callbacks",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_NullCallback },
#endif
#if !defined(SQLITE_OMIT_UTF16)
 { "encoding",  PragTyp_ENCODING,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
 { "foreign_key_check",  PragTyp_FOREIGN_KEY_CHECK,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1|PragFlg_SchemaOpt,  43, 4,  0 },
#endif
#if !defined(SQLITE_OMIT_FOREIGN_KEY)
 { "foreign_key_list",  PragTyp_FOREIGN_KEY_LIST,  PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,  0, 8,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)
 { "foreign_keys",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_ForeignKeys },
#endif
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
 { "freelist_count",  PragTyp_HEADER_VALUE,  PragFlg_ReadOnly|PragFlg_Result0,  0, 0,  BTREE_FREE_PAGE_COUNT },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "full_column_names",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_FullColNames },  { "fullfsync",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_FullFSync },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
#if !defined(SQLITE_OMIT_INTROSPECTION_PRAGMAS)
 { "function_list",  PragTyp_FUNCTION_LIST,  PragFlg_Result0,  27, 6,  0 },
#endif
#endif
 { "hard_heap_limit",  PragTyp_HARD_HEAP_LIMIT,  PragFlg_Result0,  0, 0,  0 },
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if !defined(SQLITE_OMIT_CHECK)
 { "ignore_check_constraints",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_IgnoreChecks },
#endif
#endif
#if !defined(SQLITE_OMIT_AUTOVACUUM)
 { "incremental_vacuum",  PragTyp_INCREMENTAL_VACUUM,  PragFlg_NeedSchema|PragFlg_NoColumns,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
 { "index_info",  PragTyp_INDEX_INFO,  PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,  21, 3,  0 },  { "index_list",  PragTyp_INDEX_LIST,  PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,  38, 5,  0 },  { "index_xinfo",  PragTyp_INDEX_INFO,  PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,  21, 6,  1 },
#endif
#if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
 { "integrity_check",  PragTyp_INTEGRITY_CHECK,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1|PragFlg_SchemaOpt,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "journal_mode",  PragTyp_JOURNAL_MODE,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq,  0, 0,  0 },  { "journal_size_limit",  PragTyp_JOURNAL_SIZE_LIMIT,  PragFlg_Result0|PragFlg_SchemaReq,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "legacy_alter_table",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_LegacyAlter },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && SQLITE_ENABLE_LOCKING_STYLE
 { "lock_proxy_file",  PragTyp_LOCK_PROXY_FILE,  PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 { "lock_status",  PragTyp_LOCK_STATUS,  PragFlg_Result0,  53, 2,  0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "locking_mode",  PragTyp_LOCKING_MODE,  PragFlg_Result0|PragFlg_SchemaReq,  0, 0,  0 },  { "max_page_count",  PragTyp_PAGE_COUNT,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq,  0, 0,  0 },  { "mmap_size",  PragTyp_MMAP_SIZE,  0,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
#if !defined(SQLITE_OMIT_VIRTUALTABLE)
#if !defined(SQLITE_OMIT_INTROSPECTION_PRAGMAS)
 { "module_list",  PragTyp_MODULE_LIST,  PragFlg_Result0,  9, 1,  0 },
#endif
#endif
#endif
 { "optimize",  PragTyp_OPTIMIZE,  PragFlg_Result1|PragFlg_NeedSchema,  0, 0,  0 },
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "page_count",  PragTyp_PAGE_COUNT,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq,  0, 0,  0 },  { "page_size",  PragTyp_PAGE_SIZE,  PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if defined(SQLITE_DEBUG)
 { "parser_trace",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_ParserTrace },
#endif
#endif
#if !defined(SQLITE_OMIT_INTROSPECTION_PRAGMAS)
 { "pragma_list",  PragTyp_PRAGMA_LIST,  PragFlg_Result0,  9, 1,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "query_only",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_QueryOnly },
#endif
#if !defined(SQLITE_OMIT_INTEGRITY_CHECK)
 { "quick_check",  PragTyp_INTEGRITY_CHECK,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_Result1|PragFlg_SchemaOpt,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "read_uncommitted",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_ReadUncommit },  { "recursive_triggers",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_RecTriggers },  { "reverse_unordered_selects",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_ReverseOrder },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
 { "schema_version",  PragTyp_HEADER_VALUE,  PragFlg_NoColumns1|PragFlg_Result0,  0, 0,  BTREE_SCHEMA_VERSION },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "secure_delete",  PragTyp_SECURE_DELETE,  PragFlg_Result0,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "short_column_names",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_ShortColNames },
#endif
 { "shrink_memory",  PragTyp_SHRINK_MEMORY,  PragFlg_NoColumns,  0, 0,  0 },  { "soft_heap_limit",  PragTyp_SOFT_HEAP_LIMIT,  PragFlg_Result0,  0, 0,  0 },
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if defined(SQLITE_DEBUG)
 { "sql_trace",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_SqlTrace },
#endif
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS) && defined(SQLITE_DEBUG)
 { "stats",  PragTyp_STATS,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq,  33, 5,  0 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "synchronous",  PragTyp_SYNCHRONOUS,  PragFlg_NeedSchema|PragFlg_Result0|PragFlg_SchemaReq|PragFlg_NoColumns1,  0, 0,  0 },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_PRAGMAS)
 { "table_info",  PragTyp_TABLE_INFO,  PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,  8, 6,  0 },  { "table_list",  PragTyp_TABLE_LIST,  PragFlg_NeedSchema|PragFlg_Result1,  15, 6,  0 },  { "table_xinfo",  PragTyp_TABLE_INFO,  PragFlg_NeedSchema|PragFlg_Result1|PragFlg_SchemaOpt,  8, 7,  1 },
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 { "temp_store",  PragTyp_TEMP_STORE,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  0 },  { "temp_store_directory",  PragTyp_TEMP_STORE_DIRECTORY,  PragFlg_NoColumns1,  0, 0,  0 },
#endif
 { "threads",  PragTyp_THREADS,  PragFlg_Result0,  0, 0,  0 },
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "trusted_schema",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_TrustedSchema },
#endif
#if !defined(SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS)
 { "user_version",  PragTyp_HEADER_VALUE,  PragFlg_NoColumns1|PragFlg_Result0,  0, 0,  BTREE_USER_VERSION },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
#if defined(SQLITE_DEBUG)
 { "vdbe_addoptrace",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_VdbeAddopTrace },  { "vdbe_debug",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_SqlTrace|SQLITE_VdbeListing|SQLITE_VdbeTrace },  { "vdbe_eqp",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_VdbeEQP },  { "vdbe_listing",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_VdbeListing },  { "vdbe_trace",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_VdbeTrace },
#endif
#endif
#if !defined(SQLITE_OMIT_WAL)
 { "wal_autocheckpoint",  PragTyp_WAL_AUTOCHECKPOINT,  0,  0, 0,  0 },  { "wal_checkpoint",  PragTyp_WAL_CHECKPOINT,  PragFlg_NeedSchema,  50, 3,  0 },
#endif
#if !defined(SQLITE_OMIT_FLAG_PRAGMAS)
 { "writable_schema",  PragTyp_FLAG,  PragFlg_Result0|PragFlg_NoColumns1,  0, 0,  SQLITE_WriteSchema|SQLITE_NoSchemaError },
#endif
}; static u8 getSafetyLevel(const char *z, int omitFull, u8 dflt){  static const char zText[] = "onoffalseyestruextrafull";  static const u8 iOffset[] = {0, 1, 2, 4, 9, 12, 15, 20};  static const u8 iLength[] = {2, 2, 3, 5, 3, 4, 5, 4};  static const u8 iValue[] = {1, 0, 0, 0, 1, 1, 3, 2};  int i, n;  if( sqlite3Isdigit(*z) ){  return (u8)sqlite3Atoi(z);  }  n = sqlite3Strlen30(z);  for(i=0; i<ArraySize(iLength); i++){  if( iLength[i]==n && sqlite3StrNICmp(&zText[iOffset[i]],z,n)==0   && (!omitFull || iValue[i]<=1)  ){  return iValue[i];  }  }  return dflt; } SQLITE_PRIVATE u8 sqlite3GetBoolean(const char *z, u8 dflt){  return getSafetyLevel(z,1,dflt)!=0; }
#if !defined(SQLITE_OMIT_PRAGMA)
static int getLockingMode(const char *z){  if( z ){  if( 0==sqlite3StrICmp(z, "exclusive") ) return PAGER_LOCKINGMODE_EXCLUSIVE;  if( 0==sqlite3StrICmp(z, "normal") ) return PAGER_LOCKINGMODE_NORMAL;  }  return PAGER_LOCKINGMODE_QUERY; }
#ifndef SQLITE_OMIT_AUTOVACUUM
static int getAutoVacuum(const char *z){  int i;  if( 0==sqlite3StrICmp(z, "none") ) return BTREE_AUTOVACUUM_NONE;  if( 0==sqlite3StrICmp(z, "full") ) return BTREE_AUTOVACUUM_FULL;  if( 0==sqlite3StrICmp(z, "incremental") ) return BTREE_AUTOVACUUM_INCR;  i = sqlite3Atoi(z);  return (u8)((i>=0&&i<=2)?i:0); }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
static int getTempStore(const char *z){  if( z[0]>='0' && z[0]<='2' ){  return z[0] - '0';  }else if( sqlite3StrICmp(z, "file")==0 ){  return 1;  }else if( sqlite3StrICmp(z, "memory")==0 ){  return 2;  }else{  return 0;  } }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
static int invalidateTempStorage(Parse *pParse){  sqlite3 *db = pParse->db;  if( db->aDb[1].pBt!=0 ){  if( !db->autoCommit   || sqlite3BtreeTxnState(db->aDb[1].pBt)!=SQLITE_TXN_NONE  ){  sqlite3ErrorMsg(pParse, "temporary storage cannot be changed "  "from within a transaction");  return SQLITE_ERROR;  }  sqlite3BtreeClose(db->aDb[1].pBt);  db->aDb[1].pBt = 0;  sqlite3ResetAllSchemasOfConnection(db);  }  return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
static int changeTempStorage(Parse *pParse, const char *zStorageType){  int ts = getTempStore(zStorageType);  sqlite3 *db = pParse->db;  if( db->temp_store==ts ) return SQLITE_OK;  if( invalidateTempStorage( pParse ) != SQLITE_OK ){  return SQLITE_ERROR;  }  db->temp_store = (u8)ts;  return SQLITE_OK; }
#endif
static void setPragmaResultColumnNames(  Vdbe *v,  const PragmaName *pPragma ){  u8 n = pPragma->nPragCName;  sqlite3VdbeSetNumCols(v, n==0 ? 1 : n);  if( n==0 ){  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, pPragma->zName, SQLITE_STATIC);  }else{  int i, j;  for(i=0, j=pPragma->iPragCName; i<n; i++, j++){  sqlite3VdbeSetColName(v, i, COLNAME_NAME, pragCName[j], SQLITE_STATIC);  }  } } static void returnSingleInt(Vdbe *v, i64 value){  sqlite3VdbeAddOp4Dup8(v, OP_Int64, 0, 1, 0, (const u8*)&value, P4_INT64);  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1); } static void returnSingleText(  Vdbe *v,  const char *zValue ){  if( zValue ){  sqlite3VdbeLoadString(v, 1, (const char*)zValue);  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);  } }
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
static void setAllPagerFlags(sqlite3 *db){  if( db->autoCommit ){  Db *pDb = db->aDb;  int n = db->nDb;  assert( SQLITE_FullFSync==PAGER_FULLFSYNC );  assert( SQLITE_CkptFullFSync==PAGER_CKPT_FULLFSYNC );  assert( SQLITE_CacheSpill==PAGER_CACHESPILL );  assert( (PAGER_FULLFSYNC | PAGER_CKPT_FULLFSYNC | PAGER_CACHESPILL)   == PAGER_FLAGS_MASK );  assert( (pDb->safety_level & PAGER_SYNCHRONOUS_MASK)==pDb->safety_level );  while( (n--) > 0 ){  if( pDb->pBt ){  sqlite3BtreeSetPagerFlags(pDb->pBt,   pDb->safety_level | (db->flags & PAGER_FLAGS_MASK) );  }  pDb++;  }  } }
#else
# define setAllPagerFlags(X)
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
static const char *actionName(u8 action){  const char *zName;  switch( action ){  case OE_SetNull: zName = "SET NULL"; break;  case OE_SetDflt: zName = "SET DEFAULT";  break;  case OE_Cascade: zName = "CASCADE";  break;  case OE_Restrict: zName = "RESTRICT"; break;  default: zName = "NO ACTION";  assert( action==OE_None ); break;  }  return zName; }
#endif
SQLITE_PRIVATE const char *sqlite3JournalModename(int eMode){  static char * const azModeName[] = {  "delete", "persist", "off", "truncate", "memory"
#ifndef SQLITE_OMIT_WAL
  , "wal"
#endif
 };  assert( PAGER_JOURNALMODE_DELETE==0 );  assert( PAGER_JOURNALMODE_PERSIST==1 );  assert( PAGER_JOURNALMODE_OFF==2 );  assert( PAGER_JOURNALMODE_TRUNCATE==3 );  assert( PAGER_JOURNALMODE_MEMORY==4 );  assert( PAGER_JOURNALMODE_WAL==5 );  assert( eMode>=0 && eMode<=ArraySize(azModeName) );  if( eMode==ArraySize(azModeName) ) return 0;  return azModeName[eMode]; } static const PragmaName *pragmaLocate(const char *zName){  int upr, lwr, mid = 0, rc;  lwr = 0;  upr = ArraySize(aPragmaName)-1;  while( lwr<=upr ){  mid = (lwr+upr)/2;  rc = sqlite3_stricmp(zName, aPragmaName[mid].zName);  if( rc==0 ) break;  if( rc<0 ){  upr = mid - 1;  }else{  lwr = mid + 1;  }  }  return lwr>upr ? 0 : &aPragmaName[mid]; } static void pragmaFunclistLine(  Vdbe *v,  FuncDef *p,  int isBuiltin,  int showInternFuncs ){  for(; p; p=p->pNext){  const char *zType;  static const u32 mask =  SQLITE_DETERMINISTIC |  SQLITE_DIRECTONLY |  SQLITE_SUBTYPE |  SQLITE_INNOCUOUS |  SQLITE_FUNC_INTERNAL  ;  static const char *azEnc[] = { 0, "utf8", "utf16le", "utf16be" };  assert( SQLITE_FUNC_ENCMASK==0x3 );  assert( strcmp(azEnc[SQLITE_UTF8],"utf8")==0 );  assert( strcmp(azEnc[SQLITE_UTF16LE],"utf16le")==0 );  assert( strcmp(azEnc[SQLITE_UTF16BE],"utf16be")==0 );  if( p->xSFunc==0 ) continue;  if( (p->funcFlags & SQLITE_FUNC_INTERNAL)!=0   && showInternFuncs==0  ){  continue;  }  if( p->xValue!=0 ){  zType = "w";  }else if( p->xFinalize!=0 ){  zType = "a";  }else{  zType = "s";  }  sqlite3VdbeMultiLoad(v, 1, "sissii",   p->zName, isBuiltin,   zType, azEnc[p->funcFlags&SQLITE_FUNC_ENCMASK],   p->nArg,   (p->funcFlags & mask) ^ SQLITE_INNOCUOUS  );  } } static int integrityCheckResultRow(Vdbe *v){  int addr;  sqlite3VdbeAddOp2(v, OP_ResultRow, 3, 1);  addr = sqlite3VdbeAddOp3(v, OP_IfPos, 1, sqlite3VdbeCurrentAddr(v)+2, 1);  VdbeCoverage(v);  sqlite3VdbeAddOp0(v, OP_Halt);  return addr; } SQLITE_PRIVATE void sqlite3Pragma(  Parse *pParse,  Token *pId1,  Token *pId2,  Token *pValue,  int minusFlag ){  char *zLeft = 0;  char *zRight = 0;  const char *zDb = 0;  Token *pId;  char *aFcntl[4];  int iDb;  int rc;  sqlite3 *db = pParse->db;  Db *pDb;  Vdbe *v = sqlite3GetVdbe(pParse);  const PragmaName *pPragma;  if( v==0 ) return;  sqlite3VdbeRunOnlyOnce(v);  pParse->nMem = 2;  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);  if( iDb<0 ) return;  pDb = &db->aDb[iDb];  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){  return;  }  zLeft = sqlite3NameFromToken(db, pId);  if( !zLeft ) return;  if( minusFlag ){  zRight = sqlite3MPrintf(db, "-%T", pValue);  }else{  zRight = sqlite3NameFromToken(db, pValue);  }  assert( pId2 );  zDb = pId2->n>0 ? pDb->zDbSName : 0;  if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){  goto pragma_out;  }  aFcntl[0] = 0;  aFcntl[1] = zLeft;  aFcntl[2] = zRight;  aFcntl[3] = 0;  db->busyHandler.nBusy = 0;  rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_PRAGMA, (void*)aFcntl);  if( rc==SQLITE_OK ){  sqlite3VdbeSetNumCols(v, 1);  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, aFcntl[0], SQLITE_TRANSIENT);  returnSingleText(v, aFcntl[0]);  sqlite3_free(aFcntl[0]);  goto pragma_out;  }  if( rc!=SQLITE_NOTFOUND ){  if( aFcntl[0] ){  sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);  sqlite3_free(aFcntl[0]);  }  pParse->nErr++;  pParse->rc = rc;  goto pragma_out;  }  pPragma = pragmaLocate(zLeft);  if( pPragma==0 ){  goto pragma_out;  }  if( (pPragma->mPragFlg & PragFlg_NeedSchema)!=0 ){  if( sqlite3ReadSchema(pParse) ) goto pragma_out;  }  if( (pPragma->mPragFlg & PragFlg_NoColumns)==0   && ((pPragma->mPragFlg & PragFlg_NoColumns1)==0 || zRight==0)  ){  setPragmaResultColumnNames(v, pPragma);  }  switch( pPragma->ePragTyp ){
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS) && !defined(SQLITE_OMIT_DEPRECATED)
 case PragTyp_DEFAULT_CACHE_SIZE: {  static const int iLn = VDBE_OFFSET_LINENO(2);  static const VdbeOpList getCacheSize[] = {  { OP_Transaction, 0, 0, 0},  { OP_ReadCookie, 0, 1, BTREE_DEFAULT_CACHE_SIZE},  { OP_IfPos, 1, 8, 0},  { OP_Integer, 0, 2, 0},  { OP_Subtract, 1, 2, 1},  { OP_IfPos, 1, 8, 0},  { OP_Integer, 0, 1, 0},  { OP_Noop, 0, 0, 0},  { OP_ResultRow, 1, 1, 0},  };  VdbeOp *aOp;  sqlite3VdbeUsesBtree(v, iDb);  if( !zRight ){  pParse->nMem += 2;  sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(getCacheSize));  aOp = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize, iLn);  if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;  aOp[0].p1 = iDb;  aOp[1].p1 = iDb;  aOp[6].p1 = SQLITE_DEFAULT_CACHE_SIZE;  }else{  int size = sqlite3AbsInt32(sqlite3Atoi(zRight));  sqlite3BeginWriteOperation(pParse, 0, iDb);  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, size);  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  pDb->pSchema->cache_size = size;  sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);  }  break;  }
#endif
#if !defined(SQLITE_OMIT_PAGER_PRAGMAS)
 case PragTyp_PAGE_SIZE: {  Btree *pBt = pDb->pBt;  assert( pBt!=0 );  if( !zRight ){  int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;  returnSingleInt(v, size);  }else{  db->nextPagesize = sqlite3Atoi(zRight);  if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,0,0) ){  sqlite3OomFault(db);  }  }  break;  }  case PragTyp_SECURE_DELETE: {  Btree *pBt = pDb->pBt;  int b = -1;  assert( pBt!=0 );  if( zRight ){  if( sqlite3_stricmp(zRight, "fast")==0 ){  b = 2;  }else{  b = sqlite3GetBoolean(zRight, 0);  }  }  if( pId2->n==0 && b>=0 ){  int ii;  for(ii=0; ii<db->nDb; ii++){  sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);  }  }  b = sqlite3BtreeSecureDelete(pBt, b);  returnSingleInt(v, b);  break;  }  case PragTyp_PAGE_COUNT: {  int iReg;  i64 x = 0;  sqlite3CodeVerifySchema(pParse, iDb);  iReg = ++pParse->nMem;  if( sqlite3Tolower(zLeft[0])=='p' ){  sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);  }else{  if( zRight && sqlite3DecOrHexToI64(zRight,&x)==0 ){  if( x<0 ) x = 0;  else if( x>0xfffffffe ) x = 0xfffffffe;  }else{  x = 0;  }  sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, (int)x);  }  sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);  break;  }  case PragTyp_LOCKING_MODE: {  const char *zRet = "normal";  int eMode = getLockingMode(zRight);  if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){  eMode = db->dfltLockMode;  }else{  Pager *pPager;  if( pId2->n==0 ){  int ii;  assert(pDb==&db->aDb[0]);  for(ii=2; ii<db->nDb; ii++){  pPager = sqlite3BtreePager(db->aDb[ii].pBt);  sqlite3PagerLockingMode(pPager, eMode);  }  db->dfltLockMode = (u8)eMode;  }  pPager = sqlite3BtreePager(pDb->pBt);  eMode = sqlite3PagerLockingMode(pPager, eMode);  }  assert( eMode==PAGER_LOCKINGMODE_NORMAL  || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );  if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){  zRet = "exclusive";  }  returnSingleText(v, zRet);  break;  }  case PragTyp_JOURNAL_MODE: {  int eMode;  int ii;  if( zRight==0 ){  eMode = PAGER_JOURNALMODE_QUERY;  }else{  const char *zMode;  int n = sqlite3Strlen30(zRight);  for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){  if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;  }  if( !zMode ){  eMode = PAGER_JOURNALMODE_QUERY;  }  if( eMode==PAGER_JOURNALMODE_OFF && (db->flags & SQLITE_Defensive)!=0 ){  eMode = PAGER_JOURNALMODE_QUERY;  }  }  if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){  iDb = 0;  pId2->n = 1;  }  for(ii=db->nDb-1; ii>=0; ii--){  if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){  sqlite3VdbeUsesBtree(v, ii);  sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);  }  }  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);  break;  }  case PragTyp_JOURNAL_SIZE_LIMIT: {  Pager *pPager = sqlite3BtreePager(pDb->pBt);  i64 iLimit = -2;  if( zRight ){  sqlite3DecOrHexToI64(zRight, &iLimit);  if( iLimit<-1 ) iLimit = -1;  }  iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);  returnSingleInt(v, iLimit);  break;  }
#endif
#ifndef SQLITE_OMIT_AUTOVACUUM
 case PragTyp_AUTO_VACUUM: {  Btree *pBt = pDb->pBt;  assert( pBt!=0 );  if( !zRight ){  returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));  }else{  int eAuto = getAutoVacuum(zRight);  assert( eAuto>=0 && eAuto<=2 );  db->nextAutovac = (u8)eAuto;  rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);  if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){  static const int iLn = VDBE_OFFSET_LINENO(2);  static const VdbeOpList setMeta6[] = {  { OP_Transaction, 0, 1, 0},  { OP_ReadCookie, 0, 1, BTREE_LARGEST_ROOT_PAGE},  { OP_If, 1, 0, 0},  { OP_Halt, SQLITE_OK, OE_Abort, 0},  { OP_SetCookie, 0, BTREE_INCR_VACUUM, 0},  };  VdbeOp *aOp;  int iAddr = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setMeta6));  aOp = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6, iLn);  if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;  aOp[0].p1 = iDb;  aOp[1].p1 = iDb;  aOp[2].p2 = iAddr+4;  aOp[4].p1 = iDb;  aOp[4].p3 = eAuto - 1;  sqlite3VdbeUsesBtree(v, iDb);  }  }  break;  }
#endif
#ifndef SQLITE_OMIT_AUTOVACUUM
 case PragTyp_INCREMENTAL_VACUUM: {  int iLimit, addr;  if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){  iLimit = 0x7fffffff;  }  sqlite3BeginWriteOperation(pParse, 0, iDb);  sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);  addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb); VdbeCoverage(v);  sqlite3VdbeAddOp1(v, OP_ResultRow, 1);  sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);  sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr);  break;  }
#endif
#ifndef SQLITE_OMIT_PAGER_PRAGMAS
 case PragTyp_CACHE_SIZE: {  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( !zRight ){  returnSingleInt(v, pDb->pSchema->cache_size);  }else{  int size = sqlite3Atoi(zRight);  pDb->pSchema->cache_size = size;  sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);  }  break;  }  case PragTyp_CACHE_SPILL: {  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( !zRight ){  returnSingleInt(v,   (db->flags & SQLITE_CacheSpill)==0 ? 0 :  sqlite3BtreeSetSpillSize(pDb->pBt,0));  }else{  int size = 1;  if( sqlite3GetInt32(zRight, &size) ){  sqlite3BtreeSetSpillSize(pDb->pBt, size);  }  if( sqlite3GetBoolean(zRight, size!=0) ){  db->flags |= SQLITE_CacheSpill;  }else{  db->flags &= ~(u64)SQLITE_CacheSpill;  }  setAllPagerFlags(db);  }  break;  }  case PragTyp_MMAP_SIZE: {  sqlite3_int64 sz;
#if SQLITE_MAX_MMAP_SIZE>0
 assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( zRight ){  int ii;  sqlite3DecOrHexToI64(zRight, &sz);  if( sz<0 ) sz = sqlite3GlobalConfig.szMmap;  if( pId2->n==0 ) db->szMmap = sz;  for(ii=db->nDb-1; ii>=0; ii--){  if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){  sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);  }  }  }  sz = -1;  rc = sqlite3_file_control(db, zDb, SQLITE_FCNTL_MMAP_SIZE, &sz);
#else
 sz = 0;  rc = SQLITE_OK;
#endif
 if( rc==SQLITE_OK ){  returnSingleInt(v, sz);  }else if( rc!=SQLITE_NOTFOUND ){  pParse->nErr++;  pParse->rc = rc;  }  break;  }  case PragTyp_TEMP_STORE: {  if( !zRight ){  returnSingleInt(v, db->temp_store);  }else{  changeTempStorage(pParse, zRight);  }  break;  }  case PragTyp_TEMP_STORE_DIRECTORY: {  if( !zRight ){  returnSingleText(v, sqlite3_temp_directory);  }else{
#ifndef SQLITE_OMIT_WSD
 if( zRight[0] ){  int res;  rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);  if( rc!=SQLITE_OK || res==0 ){  sqlite3ErrorMsg(pParse, "not a writable directory");  goto pragma_out;  }  }  if( SQLITE_TEMP_STORE==0   || (SQLITE_TEMP_STORE==1 && db->temp_store<=1)   || (SQLITE_TEMP_STORE==2 && db->temp_store==1)  ){  invalidateTempStorage(pParse);  }  sqlite3_free(sqlite3_temp_directory);  if( zRight[0] ){  sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);  }else{  sqlite3_temp_directory = 0;  }
#endif
 }  break;  }
#if SQLITE_OS_WIN
 case PragTyp_DATA_STORE_DIRECTORY: {  if( !zRight ){  returnSingleText(v, sqlite3_data_directory);  }else{
#ifndef SQLITE_OMIT_WSD
 if( zRight[0] ){  int res;  rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);  if( rc!=SQLITE_OK || res==0 ){  sqlite3ErrorMsg(pParse, "not a writable directory");  goto pragma_out;  }  }  sqlite3_free(sqlite3_data_directory);  if( zRight[0] ){  sqlite3_data_directory = sqlite3_mprintf("%s", zRight);  }else{  sqlite3_data_directory = 0;  }
#endif
 }  break;  }
#endif
#if SQLITE_ENABLE_LOCKING_STYLE
 case PragTyp_LOCK_PROXY_FILE: {  if( !zRight ){  Pager *pPager = sqlite3BtreePager(pDb->pBt);  char *proxy_file_path = NULL;  sqlite3_file *pFile = sqlite3PagerFile(pPager);  sqlite3OsFileControlHint(pFile, SQLITE_GET_LOCKPROXYFILE,   &proxy_file_path);  returnSingleText(v, proxy_file_path);  }else{  Pager *pPager = sqlite3BtreePager(pDb->pBt);  sqlite3_file *pFile = sqlite3PagerFile(pPager);  int res;  if( zRight[0] ){  res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,   zRight);  } else {  res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE,   NULL);  }  if( res!=SQLITE_OK ){  sqlite3ErrorMsg(pParse, "failed to set lock proxy file");  goto pragma_out;  }  }  break;  }
#endif
 case PragTyp_SYNCHRONOUS: {  if( !zRight ){  returnSingleInt(v, pDb->safety_level-1);  }else{  if( !db->autoCommit ){  sqlite3ErrorMsg(pParse,  "Safety level may not be changed inside a transaction");  }else if( iDb!=1 ){  int iLevel = (getSafetyLevel(zRight,0,1)+1) & PAGER_SYNCHRONOUS_MASK;  if( iLevel==0 ) iLevel = 1;  pDb->safety_level = iLevel;  pDb->bSyncSet = 1;  setAllPagerFlags(db);  }  }  break;  }
#endif
#ifndef SQLITE_OMIT_FLAG_PRAGMAS
 case PragTyp_FLAG: {  if( zRight==0 ){  setPragmaResultColumnNames(v, pPragma);  returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );  }else{  u64 mask = pPragma->iArg;  if( db->autoCommit==0 ){  mask &= ~(SQLITE_ForeignKeys);  }
#if SQLITE_USER_AUTHENTICATION
 if( db->auth.authLevel==UAUTH_User ){  mask &= ~(SQLITE_WriteSchema);  }
#endif
 if( sqlite3GetBoolean(zRight, 0) ){  db->flags |= mask;  }else{  db->flags &= ~mask;  if( mask==SQLITE_DeferFKs ) db->nDeferredImmCons = 0;  if( (mask & SQLITE_WriteSchema)!=0   && sqlite3_stricmp(zRight, "reset")==0  ){  sqlite3ResetAllSchemasOfConnection(db);  }  }  sqlite3VdbeAddOp0(v, OP_Expire);  setAllPagerFlags(db);  }  break;  }
#endif
#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS
 case PragTyp_TABLE_INFO: if( zRight ){  Table *pTab;  sqlite3CodeVerifyNamedSchema(pParse, zDb);  pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);  if( pTab ){  int i, k;  int nHidden = 0;  Column *pCol;  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  pParse->nMem = 7;  sqlite3ViewGetColumnNames(pParse, pTab);  for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){  int isHidden = 0;  const Expr *pColExpr;  if( pCol->colFlags & COLFLAG_NOINSERT ){  if( pPragma->iArg==0 ){  nHidden++;  continue;  }  if( pCol->colFlags & COLFLAG_VIRTUAL ){  isHidden = 2;  }else if( pCol->colFlags & COLFLAG_STORED ){  isHidden = 3;  }else{ assert( pCol->colFlags & COLFLAG_HIDDEN );  isHidden = 1;  }  }  if( (pCol->colFlags & COLFLAG_PRIMKEY)==0 ){  k = 0;  }else if( pPk==0 ){  k = 1;  }else{  for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}  }  pColExpr = sqlite3ColumnExpr(pTab,pCol);  assert( pColExpr==0 || pColExpr->op==TK_SPAN || isHidden>=2 );  assert( pColExpr==0 || !ExprHasProperty(pColExpr, EP_IntValue)  || isHidden>=2 );  sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? "issisii" : "issisi",   i-nHidden,   pCol->zCnName,   sqlite3ColumnType(pCol,""),   pCol->notNull ? 1 : 0,   (isHidden>=2 || pColExpr==0) ? 0 : pColExpr->u.zToken,   k,   isHidden);  }  }  }  break;  case PragTyp_TABLE_LIST: {  int ii;  pParse->nMem = 6;  sqlite3CodeVerifyNamedSchema(pParse, zDb);  for(ii=0; ii<db->nDb; ii++){  HashElem *k;  Hash *pHash;  int initNCol;  if( zDb && sqlite3_stricmp(zDb, db->aDb[ii].zDbSName)!=0 ) continue;  pHash = &db->aDb[ii].pSchema->tblHash;  initNCol = sqliteHashCount(pHash);  while( initNCol-- ){  for(k=sqliteHashFirst(pHash); 1; k=sqliteHashNext(k) ){  Table *pTab;  if( k==0 ){ initNCol = 0; break; }  pTab = sqliteHashData(k);  if( pTab->nCol==0 ){  char *zSql = sqlite3MPrintf(db, "SELECT*FROM\"%w\"", pTab->zName);  if( zSql ){  sqlite3_stmt *pDummy = 0;  (void)sqlite3_prepare(db, zSql, -1, &pDummy, 0);  (void)sqlite3_finalize(pDummy);  sqlite3DbFree(db, zSql);  }  pHash = &db->aDb[ii].pSchema->tblHash;  break;  }  }  }  for(k=sqliteHashFirst(pHash); k; k=sqliteHashNext(k) ){  Table *pTab = sqliteHashData(k);  const char *zType;  if( zRight && sqlite3_stricmp(zRight, pTab->zName)!=0 ) continue;  if( IsView(pTab) ){  zType = "view";  }else if( IsVirtual(pTab) ){  zType = "virtual";  }else if( pTab->tabFlags & TF_Shadow ){  zType = "shadow";  }else{  zType = "table";  }  sqlite3VdbeMultiLoad(v, 1, "sssiii",   db->aDb[ii].zDbSName,   sqlite3PreferredTableName(pTab->zName),   zType,   pTab->nCol,   (pTab->tabFlags & TF_WithoutRowid)!=0,   (pTab->tabFlags & TF_Strict)!=0  );  }  }  }  break;
#ifdef SQLITE_DEBUG
 case PragTyp_STATS: {  Index *pIdx;  HashElem *i;  pParse->nMem = 5;  sqlite3CodeVerifySchema(pParse, iDb);  for(i=sqliteHashFirst(&pDb->pSchema->tblHash); i; i=sqliteHashNext(i)){  Table *pTab = sqliteHashData(i);  sqlite3VdbeMultiLoad(v, 1, "ssiii",   sqlite3PreferredTableName(pTab->zName),   0,   pTab->szTabRow,   pTab->nRowLogEst,   pTab->tabFlags);  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  sqlite3VdbeMultiLoad(v, 2, "siiiX",   pIdx->zName,   pIdx->szIdxRow,   pIdx->aiRowLogEst[0],   pIdx->hasStat1);  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 5);  }  }  }  break;
#endif
 case PragTyp_INDEX_INFO: if( zRight ){  Index *pIdx;  Table *pTab;  pIdx = sqlite3FindIndex(db, zRight, zDb);  if( pIdx==0 ){  pTab = sqlite3LocateTable(pParse, LOCATE_NOERR, zRight, zDb);  if( pTab && !HasRowid(pTab) ){  pIdx = sqlite3PrimaryKeyIndex(pTab);  }  }  if( pIdx ){  int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);  int i;  int mx;  if( pPragma->iArg ){  mx = pIdx->nColumn;  pParse->nMem = 6;  }else{  mx = pIdx->nKeyCol;  pParse->nMem = 3;  }  pTab = pIdx->pTable;  sqlite3CodeVerifySchema(pParse, iIdxDb);  assert( pParse->nMem<=pPragma->nPragCName );  for(i=0; i<mx; i++){  i16 cnum = pIdx->aiColumn[i];  sqlite3VdbeMultiLoad(v, 1, "iisX", i, cnum,   cnum<0 ? 0 : pTab->aCol[cnum].zCnName);  if( pPragma->iArg ){  sqlite3VdbeMultiLoad(v, 4, "isiX",  pIdx->aSortOrder[i],  pIdx->azColl[i],  i<pIdx->nKeyCol);  }  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, pParse->nMem);  }  }  }  break;  case PragTyp_INDEX_LIST: if( zRight ){  Index *pIdx;  Table *pTab;  int i;  pTab = sqlite3FindTable(db, zRight, zDb);  if( pTab ){  int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);  pParse->nMem = 5;  sqlite3CodeVerifySchema(pParse, iTabDb);  for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){  const char *azOrigin[] = { "c", "u", "pk" };  sqlite3VdbeMultiLoad(v, 1, "isisi",   i,   pIdx->zName,   IsUniqueIndex(pIdx),   azOrigin[pIdx->idxType],   pIdx->pPartIdxWhere!=0);  }  }  }  break;  case PragTyp_DATABASE_LIST: {  int i;  pParse->nMem = 3;  for(i=0; i<db->nDb; i++){  if( db->aDb[i].pBt==0 ) continue;  assert( db->aDb[i].zDbSName!=0 );  sqlite3VdbeMultiLoad(v, 1, "iss",   i,   db->aDb[i].zDbSName,   sqlite3BtreeGetFilename(db->aDb[i].pBt));  }  }  break;  case PragTyp_COLLATION_LIST: {  int i = 0;  HashElem *p;  pParse->nMem = 2;  for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){  CollSeq *pColl = (CollSeq *)sqliteHashData(p);  sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);  }  }  break;
#ifndef SQLITE_OMIT_INTROSPECTION_PRAGMAS
 case PragTyp_FUNCTION_LIST: {  int i;  HashElem *j;  FuncDef *p;  int showInternFunc = (db->mDbFlags & DBFLAG_InternalFunc)!=0;  pParse->nMem = 6;  for(i=0; i<SQLITE_FUNC_HASH_SZ; i++){  for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){  assert( p->funcFlags & SQLITE_FUNC_BUILTIN );  pragmaFunclistLine(v, p, 1, showInternFunc);  }  }  for(j=sqliteHashFirst(&db->aFunc); j; j=sqliteHashNext(j)){  p = (FuncDef*)sqliteHashData(j);  assert( (p->funcFlags & SQLITE_FUNC_BUILTIN)==0 );  pragmaFunclistLine(v, p, 0, showInternFunc);  }  }  break;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 case PragTyp_MODULE_LIST: {  HashElem *j;  pParse->nMem = 1;  for(j=sqliteHashFirst(&db->aModule); j; j=sqliteHashNext(j)){  Module *pMod = (Module*)sqliteHashData(j);  sqlite3VdbeMultiLoad(v, 1, "s", pMod->zName);  }  }  break;
#endif
 case PragTyp_PRAGMA_LIST: {  int i;  for(i=0; i<ArraySize(aPragmaName); i++){  sqlite3VdbeMultiLoad(v, 1, "s", aPragmaName[i].zName);  }  }  break;
#endif
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
 case PragTyp_FOREIGN_KEY_LIST: if( zRight ){  FKey *pFK;  Table *pTab;  pTab = sqlite3FindTable(db, zRight, zDb);  if( pTab && IsOrdinaryTable(pTab) ){  pFK = pTab->u.tab.pFKey;  if( pFK ){  int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);  int i = 0;  pParse->nMem = 8;  sqlite3CodeVerifySchema(pParse, iTabDb);  while(pFK){  int j;  for(j=0; j<pFK->nCol; j++){  sqlite3VdbeMultiLoad(v, 1, "iissssss",   i,   j,   pFK->zTo,   pTab->aCol[pFK->aCol[j].iFrom].zCnName,   pFK->aCol[j].zCol,   actionName(pFK->aAction[1]),   actionName(pFK->aAction[0]),   "NONE");  }  ++i;  pFK = pFK->pNextFrom;  }  }  }  }  break;
#endif
#ifndef SQLITE_OMIT_FOREIGN_KEY
#ifndef SQLITE_OMIT_TRIGGER
 case PragTyp_FOREIGN_KEY_CHECK: {  FKey *pFK;  Table *pTab;  Table *pParent;  Index *pIdx;  int i;  int j;  HashElem *k;  int x;  int regResult;  int regKey;  int regRow;  int addrTop;  int addrOk;  int *aiCols;  regResult = pParse->nMem+1;  pParse->nMem += 4;  regKey = ++pParse->nMem;  regRow = ++pParse->nMem;  k = sqliteHashFirst(&db->aDb[iDb].pSchema->tblHash);  while( k ){  if( zRight ){  pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);  k = 0;  }else{  pTab = (Table*)sqliteHashData(k);  k = sqliteHashNext(k);  }  if( pTab==0 || !IsOrdinaryTable(pTab) || pTab->u.tab.pFKey==0 ) continue;  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  zDb = db->aDb[iDb].zDbSName;  sqlite3CodeVerifySchema(pParse, iDb);  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);  if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;  sqlite3OpenTable(pParse, 0, iDb, pTab, OP_OpenRead);  sqlite3VdbeLoadString(v, regResult, pTab->zName);  assert( IsOrdinaryTable(pTab) );  for(i=1, pFK=pTab->u.tab.pFKey; pFK; i++, pFK=pFK->pNextFrom){  pParent = sqlite3FindTable(db, pFK->zTo, zDb);  if( pParent==0 ) continue;  pIdx = 0;  sqlite3TableLock(pParse, iDb, pParent->tnum, 0, pParent->zName);  x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);  if( x==0 ){  if( pIdx==0 ){  sqlite3OpenTable(pParse, i, iDb, pParent, OP_OpenRead);  }else{  sqlite3VdbeAddOp3(v, OP_OpenRead, i, pIdx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);  }  }else{  k = 0;  break;  }  }  assert( pParse->nErr>0 || pFK==0 );  if( pFK ) break;  if( pParse->nTab<i ) pParse->nTab = i;  addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, 0); VdbeCoverage(v);  assert( IsOrdinaryTable(pTab) );  for(i=1, pFK=pTab->u.tab.pFKey; pFK; i++, pFK=pFK->pNextFrom){  pParent = sqlite3FindTable(db, pFK->zTo, zDb);  pIdx = 0;  aiCols = 0;  if( pParent ){  x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);  assert( x==0 || db->mallocFailed );  }  addrOk = sqlite3VdbeMakeLabel(pParse);  if( regRow+pFK->nCol>pParse->nMem ) pParse->nMem = regRow+pFK->nCol;  for(j=0; j<pFK->nCol; j++){  int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;  sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);  sqlite3VdbeAddOp2(v, OP_IsNull, regRow+j, addrOk); VdbeCoverage(v);  }  if( pIdx ){  sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, pFK->nCol, regKey,  sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);  sqlite3VdbeAddOp4Int(v, OP_Found, i, addrOk, regKey, 0);  VdbeCoverage(v);  }else if( pParent ){  int jmp = sqlite3VdbeCurrentAddr(v)+2;  sqlite3VdbeAddOp3(v, OP_SeekRowid, i, jmp, regRow); VdbeCoverage(v);  sqlite3VdbeGoto(v, addrOk);  assert( pFK->nCol==1 || db->mallocFailed );  }  if( HasRowid(pTab) ){  sqlite3VdbeAddOp2(v, OP_Rowid, 0, regResult+1);  }else{  sqlite3VdbeAddOp2(v, OP_Null, 0, regResult+1);  }  sqlite3VdbeMultiLoad(v, regResult+2, "siX", pFK->zTo, i-1);  sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, 4);  sqlite3VdbeResolveLabel(v, addrOk);  sqlite3DbFree(db, aiCols);  }  sqlite3VdbeAddOp2(v, OP_Next, 0, addrTop+1); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addrTop);  }  }  break;
#endif
#endif
#ifndef SQLITE_OMIT_CASE_SENSITIVE_LIKE_PRAGMA
 case PragTyp_CASE_SENSITIVE_LIKE: {  if( zRight ){  sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));  }  }  break;
#endif
#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX
# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100
#endif
#ifndef SQLITE_OMIT_INTEGRITY_CHECK
 case PragTyp_INTEGRITY_CHECK: {  int i, j, addr, mxErr;  Table *pObjTab = 0;  int isQuick = (sqlite3Tolower(zLeft[0])=='q');  assert( iDb>=0 );  assert( iDb==0 || pId2->z );  if( pId2->z==0 ) iDb = -1;  pParse->nMem = 6;  mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;  if( zRight ){  if( sqlite3GetInt32(zRight, &mxErr) ){  if( mxErr<=0 ){  mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;  }  }else{  pObjTab = sqlite3LocateTable(pParse, 0, zRight,  iDb>=0 ? db->aDb[iDb].zDbSName : 0);  }  }  sqlite3VdbeAddOp2(v, OP_Integer, mxErr-1, 1);  for(i=0; i<db->nDb; i++){  HashElem *x;  Hash *pTbls;  int *aRoot;  int cnt = 0;  int mxIdx = 0;  if( OMIT_TEMPDB && i==1 ) continue;  if( iDb>=0 && i!=iDb ) continue;  sqlite3CodeVerifySchema(pParse, i);  assert( sqlite3SchemaMutexHeld(db, i, 0) );  pTbls = &db->aDb[i].pSchema->tblHash;  for(cnt=0, x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){  Table *pTab = sqliteHashData(x);  Index *pIdx;  int nIdx;  if( pObjTab && pObjTab!=pTab ) continue;  if( HasRowid(pTab) ) cnt++;  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }  if( nIdx>mxIdx ) mxIdx = nIdx;  }  if( cnt==0 ) continue;  if( pObjTab ) cnt++;  aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));  if( aRoot==0 ) break;  cnt = 0;  if( pObjTab ) aRoot[++cnt] = 0;  for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){  Table *pTab = sqliteHashData(x);  Index *pIdx;  if( pObjTab && pObjTab!=pTab ) continue;  if( HasRowid(pTab) ) aRoot[++cnt] = pTab->tnum;  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  aRoot[++cnt] = pIdx->tnum;  }  }  aRoot[0] = cnt;  pParse->nMem = MAX( pParse->nMem, 8+mxIdx );  sqlite3ClearTempRegCache(pParse);  sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);  sqlite3VdbeChangeP5(v, (u8)i);  addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2); VdbeCoverage(v);  sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,   sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zDbSName),   P4_DYNAMIC);  sqlite3VdbeAddOp3(v, OP_Concat, 2, 3, 3);  integrityCheckResultRow(v);  sqlite3VdbeJumpHere(v, addr);  for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){  Table *pTab = sqliteHashData(x);  Index *pIdx, *pPk;  Index *pPrior = 0;  int loopTop;  int iDataCur, iIdxCur;  int r1 = -1;  int bStrict;  if( !IsOrdinaryTable(pTab) ) continue;  if( pObjTab && pObjTab!=pTab ) continue;  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);  sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenRead, 0,   1, 0, &iDataCur, &iIdxCur);  sqlite3VdbeAddOp2(v, OP_Integer, 0, 7);  for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){  sqlite3VdbeAddOp2(v, OP_Integer, 0, 8+j);  }  assert( pParse->nMem>=8+j );  assert( sqlite3NoTempsInRange(pParse,1,7+j) );  sqlite3VdbeAddOp2(v, OP_Rewind, iDataCur, 0); VdbeCoverage(v);  loopTop = sqlite3VdbeAddOp2(v, OP_AddImm, 7, 1);  if( !isQuick ){  sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);  sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);  VdbeComment((v, "(right-most column)"));  }  bStrict = (pTab->tabFlags & TF_Strict)!=0;  for(j=0; j<pTab->nCol; j++){  char *zErr;  Column *pCol = pTab->aCol + j;  int doError, jmp2;  if( j==pTab->iPKey ) continue;  if( pCol->notNull==0 && !bStrict ) continue;  doError = bStrict ? sqlite3VdbeMakeLabel(pParse) : 0;  sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);  if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){  sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);  }  if( pCol->notNull ){  jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);  zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab->zName,  pCol->zCnName);  sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);  if( bStrict && pCol->eCType!=COLTYPE_ANY ){  sqlite3VdbeGoto(v, doError);  }else{  integrityCheckResultRow(v);  }  sqlite3VdbeJumpHere(v, jmp2);  }  if( (pTab->tabFlags & TF_Strict)!=0   && pCol->eCType!=COLTYPE_ANY  ){  jmp2 = sqlite3VdbeAddOp3(v, OP_IsNullOrType, 3, 0,   sqlite3StdTypeMap[pCol->eCType-1]);  VdbeCoverage(v);  zErr = sqlite3MPrintf(db, "non-%s value in %s.%s",  sqlite3StdType[pCol->eCType-1],  pTab->zName, pTab->aCol[j].zCnName);  sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);  sqlite3VdbeResolveLabel(v, doError);  integrityCheckResultRow(v);  sqlite3VdbeJumpHere(v, jmp2);  }  }  if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){  ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);  if( db->mallocFailed==0 ){  int addrCkFault = sqlite3VdbeMakeLabel(pParse);  int addrCkOk = sqlite3VdbeMakeLabel(pParse);  char *zErr;  int k;  pParse->iSelfTab = iDataCur + 1;  for(k=pCheck->nExpr-1; k>0; k--){  sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);  }  sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk,  SQLITE_JUMPIFNULL);  sqlite3VdbeResolveLabel(v, addrCkFault);  pParse->iSelfTab = 0;  zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s",  pTab->zName);  sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);  integrityCheckResultRow(v);  sqlite3VdbeResolveLabel(v, addrCkOk);  }  sqlite3ExprListDelete(db, pCheck);  }  if( !isQuick ){  for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){  int jmp2, jmp3, jmp4, jmp5;  int ckUniq = sqlite3VdbeMakeLabel(pParse);  if( pPk==pIdx ) continue;  r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,   pPrior, r1);  pPrior = pIdx;  sqlite3VdbeAddOp2(v, OP_AddImm, 8+j, 1);  jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, iIdxCur+j, ckUniq, r1,  pIdx->nColumn); VdbeCoverage(v);  sqlite3VdbeLoadString(v, 3, "row ");  sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);  sqlite3VdbeLoadString(v, 4, " missing from index ");  sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);  jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);  sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 3);  jmp4 = integrityCheckResultRow(v);  sqlite3VdbeJumpHere(v, jmp2);  if( IsUniqueIndex(pIdx) ){  int uniqOk = sqlite3VdbeMakeLabel(pParse);  int jmp6;  int kk;  for(kk=0; kk<pIdx->nKeyCol; kk++){  int iCol = pIdx->aiColumn[kk];  assert( iCol!=XN_ROWID && iCol<pTab->nCol );  if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;  sqlite3VdbeAddOp2(v, OP_IsNull, r1+kk, uniqOk);  VdbeCoverage(v);  }  jmp6 = sqlite3VdbeAddOp1(v, OP_Next, iIdxCur+j); VdbeCoverage(v);  sqlite3VdbeGoto(v, uniqOk);  sqlite3VdbeJumpHere(v, jmp6);  sqlite3VdbeAddOp4Int(v, OP_IdxGT, iIdxCur+j, uniqOk, r1,   pIdx->nKeyCol); VdbeCoverage(v);  sqlite3VdbeLoadString(v, 3, "non-unique entry in index ");  sqlite3VdbeGoto(v, jmp5);  sqlite3VdbeResolveLabel(v, uniqOk);  }  sqlite3VdbeJumpHere(v, jmp4);  sqlite3ResolvePartIdxLabel(pParse, jmp3);  }  }  sqlite3VdbeAddOp2(v, OP_Next, iDataCur, loopTop); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, loopTop-1);  if( !isQuick ){  sqlite3VdbeLoadString(v, 2, "wrong # of entries in index ");  for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){  if( pPk==pIdx ) continue;  sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);  addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);  sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);  sqlite3VdbeLoadString(v, 4, pIdx->zName);  sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);  integrityCheckResultRow(v);  sqlite3VdbeJumpHere(v, addr);  }  }  }  }  {  static const int iLn = VDBE_OFFSET_LINENO(2);  static const VdbeOpList endCode[] = {  { OP_AddImm, 1, 0, 0},  { OP_IfNotZero, 1, 4, 0},  { OP_String8, 0, 3, 0},  { OP_ResultRow, 3, 1, 0},  { OP_Halt, 0, 0, 0},  { OP_String8, 0, 3, 0},  { OP_Goto, 0, 3, 0},  };  VdbeOp *aOp;  aOp = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode, iLn);  if( aOp ){  aOp[0].p2 = 1-mxErr;  aOp[2].p4type = P4_STATIC;  aOp[2].p4.z = "ok";  aOp[5].p4type = P4_STATIC;  aOp[5].p4.z = (char*)sqlite3ErrStr(SQLITE_CORRUPT);  }  sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);  }  }  break;
#endif
#ifndef SQLITE_OMIT_UTF16
 case PragTyp_ENCODING: {  static const struct EncName {  char *zName;  u8 enc;  } encnames[] = {  { "UTF8", SQLITE_UTF8 },  { "UTF-8", SQLITE_UTF8 },  { "UTF-16le", SQLITE_UTF16LE  },  { "UTF-16be", SQLITE_UTF16BE  },  { "UTF16le", SQLITE_UTF16LE  },  { "UTF16be", SQLITE_UTF16BE  },  { "UTF-16", 0 },  { "UTF16", 0 },  { 0, 0 }  };  const struct EncName *pEnc;  if( !zRight ){  if( sqlite3ReadSchema(pParse) ) goto pragma_out;  assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );  assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );  assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );  returnSingleText(v, encnames[ENC(pParse->db)].zName);  }else{  if( (db->mDbFlags & DBFLAG_EncodingFixed)==0 ){  for(pEnc=&encnames[0]; pEnc->zName; pEnc++){  if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){  u8 enc = pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;  SCHEMA_ENC(db) = enc;  sqlite3SetTextEncoding(db, enc);  break;  }  }  if( !pEnc->zName ){  sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);  }  }  }  }  break;
#endif
#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS
 case PragTyp_HEADER_VALUE: {  int iCookie = pPragma->iArg;  sqlite3VdbeUsesBtree(v, iDb);  if( zRight && (pPragma->mPragFlg & PragFlg_ReadOnly)==0 ){  static const VdbeOpList setCookie[] = {  { OP_Transaction, 0, 1, 0},  { OP_SetCookie, 0, 0, 0},  };  VdbeOp *aOp;  sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(setCookie));  aOp = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie, 0);  if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;  aOp[0].p1 = iDb;  aOp[1].p1 = iDb;  aOp[1].p2 = iCookie;  aOp[1].p3 = sqlite3Atoi(zRight);  aOp[1].p5 = 1;  }else{  static const VdbeOpList readCookie[] = {  { OP_Transaction, 0, 0, 0},  { OP_ReadCookie, 0, 1, 0},  { OP_ResultRow, 1, 1, 0}  };  VdbeOp *aOp;  sqlite3VdbeVerifyNoMallocRequired(v, ArraySize(readCookie));  aOp = sqlite3VdbeAddOpList(v, ArraySize(readCookie),readCookie,0);  if( ONLY_IF_REALLOC_STRESS(aOp==0) ) break;  aOp[0].p1 = iDb;  aOp[1].p1 = iDb;  aOp[1].p3 = iCookie;  sqlite3VdbeReusable(v);  }  }  break;
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
 case PragTyp_COMPILE_OPTIONS: {  int i = 0;  const char *zOpt;  pParse->nMem = 1;  while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){  sqlite3VdbeLoadString(v, 1, zOpt);  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);  }  sqlite3VdbeReusable(v);  }  break;
#endif
#ifndef SQLITE_OMIT_WAL
 case PragTyp_WAL_CHECKPOINT: {  int iBt = (pId2->z?iDb:SQLITE_MAX_DB);  int eMode = SQLITE_CHECKPOINT_PASSIVE;  if( zRight ){  if( sqlite3StrICmp(zRight, "full")==0 ){  eMode = SQLITE_CHECKPOINT_FULL;  }else if( sqlite3StrICmp(zRight, "restart")==0 ){  eMode = SQLITE_CHECKPOINT_RESTART;  }else if( sqlite3StrICmp(zRight, "truncate")==0 ){  eMode = SQLITE_CHECKPOINT_TRUNCATE;  }  }  pParse->nMem = 3;  sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);  sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);  }  break;  case PragTyp_WAL_AUTOCHECKPOINT: {  if( zRight ){  sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));  }  returnSingleInt(v,   db->xWalCallback==sqlite3WalDefaultHook ?   SQLITE_PTR_TO_INT(db->pWalArg) : 0);  }  break;
#endif
 case PragTyp_SHRINK_MEMORY: {  sqlite3_db_release_memory(db);  break;  }  case PragTyp_OPTIMIZE: {  int iDbLast;  int iTabCur;  HashElem *k;  Schema *pSchema;  Table *pTab;  Index *pIdx;  LogEst szThreshold;  char *zSubSql;  u32 opMask;  if( zRight ){  opMask = (u32)sqlite3Atoi(zRight);  if( (opMask & 0x02)==0 ) break;  }else{  opMask = 0xfffe;  }  iTabCur = pParse->nTab++;  for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){  if( iDb==1 ) continue;  sqlite3CodeVerifySchema(pParse, iDb);  pSchema = db->aDb[iDb].pSchema;  for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){  pTab = (Table*)sqliteHashData(k);  if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;  szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  if( !pIdx->hasStat1 ){  szThreshold = 0;  break;  }  }  if( szThreshold ){  sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);  sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur,   sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);  VdbeCoverage(v);  }  zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"",   db->aDb[iDb].zDbSName, pTab->zName);  if( opMask & 0x01 ){  int r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp4(v, OP_String8, 0, r1, 0, zSubSql, P4_DYNAMIC);  sqlite3VdbeAddOp2(v, OP_ResultRow, r1, 1);  }else{  sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);  }  }  }  sqlite3VdbeAddOp0(v, OP_Expire);  break;  }  default: {  assert( pPragma->ePragTyp==PragTyp_BUSY_TIMEOUT );  if( zRight ){  sqlite3_busy_timeout(db, sqlite3Atoi(zRight));  }  returnSingleInt(v, db->busyTimeout);  break;  }  case PragTyp_SOFT_HEAP_LIMIT: {  sqlite3_int64 N;  if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){  sqlite3_soft_heap_limit64(N);  }  returnSingleInt(v, sqlite3_soft_heap_limit64(-1));  break;  }  case PragTyp_HARD_HEAP_LIMIT: {  sqlite3_int64 N;  if( zRight && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK ){  sqlite3_int64 iPrior = sqlite3_hard_heap_limit64(-1);  if( N>0 && (iPrior==0 || iPrior>N) ) sqlite3_hard_heap_limit64(N);  }  returnSingleInt(v, sqlite3_hard_heap_limit64(-1));  break;  }  case PragTyp_THREADS: {  sqlite3_int64 N;  if( zRight   && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK   && N>=0  ){  sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, (int)(N&0x7fffffff));  }  returnSingleInt(v, sqlite3_limit(db, SQLITE_LIMIT_WORKER_THREADS, -1));  break;  }  case PragTyp_ANALYSIS_LIMIT: {  sqlite3_int64 N;  if( zRight   && sqlite3DecOrHexToI64(zRight, &N)==SQLITE_OK   && N>=0  ){  db->nAnalysisLimit = (int)(N&0x7fffffff);  }  returnSingleInt(v, db->nAnalysisLimit);  break;  }
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 case PragTyp_LOCK_STATUS: {  static const char *const azLockName[] = {  "unlocked", "shared", "reserved", "pending", "exclusive"  };  int i;  pParse->nMem = 2;  for(i=0; i<db->nDb; i++){  Btree *pBt;  const char *zState = "unknown";  int j;  if( db->aDb[i].zDbSName==0 ) continue;  pBt = db->aDb[i].pBt;  if( pBt==0 || sqlite3BtreePager(pBt)==0 ){  zState = "closed";  }else if( sqlite3_file_control(db, i ? db->aDb[i].zDbSName : 0,   SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){   zState = azLockName[j];  }  sqlite3VdbeMultiLoad(v, 1, "ss", db->aDb[i].zDbSName, zState);  }  break;  }
#endif
#if defined(SQLITE_ENABLE_CEROD)
 case PragTyp_ACTIVATE_EXTENSIONS: if( zRight ){  if( sqlite3StrNICmp(zRight, "cerod-", 6)==0 ){  sqlite3_activate_cerod(&zRight[6]);  }  }  break;
#endif
 }  if( (pPragma->mPragFlg & PragFlg_NoColumns1) && zRight ){  sqlite3VdbeVerifyNoResultRow(v);  } pragma_out:  sqlite3DbFree(db, zLeft);  sqlite3DbFree(db, zRight); }
#ifndef SQLITE_OMIT_VIRTUALTABLE
typedef struct PragmaVtab PragmaVtab; typedef struct PragmaVtabCursor PragmaVtabCursor; struct PragmaVtab {  sqlite3_vtab base;  sqlite3 *db;  const PragmaName *pName;  u8 nHidden;  u8 iHidden; }; struct PragmaVtabCursor {  sqlite3_vtab_cursor base;  sqlite3_stmt *pPragma;  sqlite_int64 iRowid;  char *azArg[2]; }; static int pragmaVtabConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  const PragmaName *pPragma = (const PragmaName*)pAux;  PragmaVtab *pTab = 0;  int rc;  int i, j;  char cSep = '(';  StrAccum acc;  char zBuf[200];  UNUSED_PARAMETER(argc);  UNUSED_PARAMETER(argv);  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);  sqlite3_str_appendall(&acc, "CREATE TABLE x");  for(i=0, j=pPragma->iPragCName; i<pPragma->nPragCName; i++, j++){  sqlite3_str_appendf(&acc, "%c\"%s\"", cSep, pragCName[j]);  cSep = ',';  }  if( i==0 ){  sqlite3_str_appendf(&acc, "(\"%s\"", pPragma->zName);  i++;  }  j = 0;  if( pPragma->mPragFlg & PragFlg_Result1 ){  sqlite3_str_appendall(&acc, ",arg HIDDEN");  j++;  }  if( pPragma->mPragFlg & (PragFlg_SchemaOpt|PragFlg_SchemaReq) ){  sqlite3_str_appendall(&acc, ",schema HIDDEN");  j++;  }  sqlite3_str_append(&acc, ")", 1);  sqlite3StrAccumFinish(&acc);  assert( strlen(zBuf) < sizeof(zBuf)-1 );  rc = sqlite3_declare_vtab(db, zBuf);  if( rc==SQLITE_OK ){  pTab = (PragmaVtab*)sqlite3_malloc(sizeof(PragmaVtab));  if( pTab==0 ){  rc = SQLITE_NOMEM;  }else{  memset(pTab, 0, sizeof(PragmaVtab));  pTab->pName = pPragma;  pTab->db = db;  pTab->iHidden = i;  pTab->nHidden = j;  }  }else{  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  }  *ppVtab = (sqlite3_vtab*)pTab;  return rc; } static int pragmaVtabDisconnect(sqlite3_vtab *pVtab){  PragmaVtab *pTab = (PragmaVtab*)pVtab;  sqlite3_free(pTab);  return SQLITE_OK; } static int pragmaVtabBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){  PragmaVtab *pTab = (PragmaVtab*)tab;  const struct sqlite3_index_constraint *pConstraint;  int i, j;  int seen[2];  pIdxInfo->estimatedCost = (double)1;  if( pTab->nHidden==0 ){ return SQLITE_OK; }  pConstraint = pIdxInfo->aConstraint;  seen[0] = 0;  seen[1] = 0;  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){  if( pConstraint->usable==0 ) continue;  if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;  if( pConstraint->iColumn < pTab->iHidden ) continue;  j = pConstraint->iColumn - pTab->iHidden;  assert( j < 2 );  seen[j] = i+1;  }  if( seen[0]==0 ){  pIdxInfo->estimatedCost = (double)2147483647;  pIdxInfo->estimatedRows = 2147483647;  return SQLITE_OK;  }  j = seen[0]-1;  pIdxInfo->aConstraintUsage[j].argvIndex = 1;  pIdxInfo->aConstraintUsage[j].omit = 1;  if( seen[1]==0 ) return SQLITE_OK;  pIdxInfo->estimatedCost = (double)20;  pIdxInfo->estimatedRows = 20;  j = seen[1]-1;  pIdxInfo->aConstraintUsage[j].argvIndex = 2;  pIdxInfo->aConstraintUsage[j].omit = 1;  return SQLITE_OK; } static int pragmaVtabOpen(sqlite3_vtab *pVtab, sqlite3_vtab_cursor **ppCursor){  PragmaVtabCursor *pCsr;  pCsr = (PragmaVtabCursor*)sqlite3_malloc(sizeof(*pCsr));  if( pCsr==0 ) return SQLITE_NOMEM;  memset(pCsr, 0, sizeof(PragmaVtabCursor));  pCsr->base.pVtab = pVtab;  *ppCursor = &pCsr->base;  return SQLITE_OK; } static void pragmaVtabCursorClear(PragmaVtabCursor *pCsr){  int i;  sqlite3_finalize(pCsr->pPragma);  pCsr->pPragma = 0;  for(i=0; i<ArraySize(pCsr->azArg); i++){  sqlite3_free(pCsr->azArg[i]);  pCsr->azArg[i] = 0;  } } static int pragmaVtabClose(sqlite3_vtab_cursor *cur){  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)cur;  pragmaVtabCursorClear(pCsr);  sqlite3_free(pCsr);  return SQLITE_OK; } static int pragmaVtabNext(sqlite3_vtab_cursor *pVtabCursor){  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;  int rc = SQLITE_OK;  pCsr->iRowid++;  assert( pCsr->pPragma );  if( SQLITE_ROW!=sqlite3_step(pCsr->pPragma) ){  rc = sqlite3_finalize(pCsr->pPragma);  pCsr->pPragma = 0;  pragmaVtabCursorClear(pCsr);  }  return rc; } static int pragmaVtabFilter(  sqlite3_vtab_cursor *pVtabCursor,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);  int rc;  int i, j;  StrAccum acc;  char *zSql;  UNUSED_PARAMETER(idxNum);  UNUSED_PARAMETER(idxStr);  pragmaVtabCursorClear(pCsr);  j = (pTab->pName->mPragFlg & PragFlg_Result1)!=0 ? 0 : 1;  for(i=0; i<argc; i++, j++){  const char *zText = (const char*)sqlite3_value_text(argv[i]);  assert( j<ArraySize(pCsr->azArg) );  assert( pCsr->azArg[j]==0 );  if( zText ){  pCsr->azArg[j] = sqlite3_mprintf("%s", zText);  if( pCsr->azArg[j]==0 ){  return SQLITE_NOMEM;  }  }  }  sqlite3StrAccumInit(&acc, 0, 0, 0, pTab->db->aLimit[SQLITE_LIMIT_SQL_LENGTH]);  sqlite3_str_appendall(&acc, "PRAGMA ");  if( pCsr->azArg[1] ){  sqlite3_str_appendf(&acc, "%Q.", pCsr->azArg[1]);  }  sqlite3_str_appendall(&acc, pTab->pName->zName);  if( pCsr->azArg[0] ){  sqlite3_str_appendf(&acc, "=%Q", pCsr->azArg[0]);  }  zSql = sqlite3StrAccumFinish(&acc);  if( zSql==0 ) return SQLITE_NOMEM;  rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pPragma, 0);  sqlite3_free(zSql);  if( rc!=SQLITE_OK ){  pTab->base.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab->db));  return rc;  }  return pragmaVtabNext(pVtabCursor); } static int pragmaVtabEof(sqlite3_vtab_cursor *pVtabCursor){  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;  return (pCsr->pPragma==0); } static int pragmaVtabColumn(  sqlite3_vtab_cursor *pVtabCursor,  sqlite3_context *ctx,  int i ){  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);  if( i<pTab->iHidden ){  sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pPragma, i));  }else{  sqlite3_result_text(ctx, pCsr->azArg[i-pTab->iHidden],-1,SQLITE_TRANSIENT);  }  return SQLITE_OK; } static int pragmaVtabRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *p){  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;  *p = pCsr->iRowid;  return SQLITE_OK; } static const sqlite3_module pragmaVtabModule = {  0,  0,  pragmaVtabConnect,  pragmaVtabBestIndex,  pragmaVtabDisconnect,  0,  pragmaVtabOpen,  pragmaVtabClose,  pragmaVtabFilter,  pragmaVtabNext,  pragmaVtabEof,  pragmaVtabColumn,  pragmaVtabRowid,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }; SQLITE_PRIVATE Module *sqlite3PragmaVtabRegister(sqlite3 *db, const char *zName){  const PragmaName *pName;  assert( sqlite3_strnicmp(zName, "pragma_", 7)==0 );  pName = pragmaLocate(zName+7);  if( pName==0 ) return 0;  if( (pName->mPragFlg & (PragFlg_Result0|PragFlg_Result1))==0 ) return 0;  assert( sqlite3HashFind(&db->aModule, zName)==0 );  return sqlite3VtabCreateModule(db, zName, &pragmaVtabModule, (void*)pName, 0); }
#endif
#endif
static void corruptSchema(  InitData *pData,  char **azObj,  const char *zExtra ){  sqlite3 *db = pData->db;  if( db->mallocFailed ){  pData->rc = SQLITE_NOMEM_BKPT;  }else if( pData->pzErrMsg[0]!=0 ){  }else if( pData->mInitFlags & (INITFLAG_AlterMask) ){  static const char *azAlterType[] = {   "rename",   "drop column",   "add column"  };  *pData->pzErrMsg = sqlite3MPrintf(db,  "error in %s %s after %s: %s", azObj[0], azObj[1],  azAlterType[(pData->mInitFlags&INITFLAG_AlterMask)-1],  zExtra  );  pData->rc = SQLITE_ERROR;  }else if( db->flags & SQLITE_WriteSchema ){  pData->rc = SQLITE_CORRUPT_BKPT;  }else{  char *z;  const char *zObj = azObj[1] ? azObj[1] : "?";  z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);  if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);  *pData->pzErrMsg = z;  pData->rc = SQLITE_CORRUPT_BKPT;  } } SQLITE_PRIVATE int sqlite3IndexHasDuplicateRootPage(Index *pIndex){  Index *p;  for(p=pIndex->pTable->pIndex; p; p=p->pNext){  if( p->tnum==pIndex->tnum && p!=pIndex ) return 1;  }  return 0; } static int sqlite3Prepare(  sqlite3 *db,  const char *zSql,  int nBytes,  u32 prepFlags,  Vdbe *pReprepare,  sqlite3_stmt **ppStmt,  const char **pzTail ); SQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){  InitData *pData = (InitData*)pInit;  sqlite3 *db = pData->db;  int iDb = pData->iDb;  assert( argc==5 );  UNUSED_PARAMETER2(NotUsed, argc);  assert( sqlite3_mutex_held(db->mutex) );  db->mDbFlags |= DBFLAG_EncodingFixed;  if( argv==0 ) return 0;  pData->nInitRow++;  if( db->mallocFailed ){  corruptSchema(pData, argv, 0);  return 1;  }  assert( iDb>=0 && iDb<db->nDb );  if( argv[3]==0 ){  corruptSchema(pData, argv, 0);  }else if( argv[4]   && 'c'==sqlite3UpperToLower[(unsigned char)argv[4][0]]   && 'r'==sqlite3UpperToLower[(unsigned char)argv[4][1]] ){  int rc;  u8 saved_iDb = db->init.iDb;  sqlite3_stmt *pStmt;  TESTONLY(int rcp);  assert( db->init.busy );  db->init.iDb = iDb;  if( sqlite3GetUInt32(argv[3], &db->init.newTnum)==0   || (db->init.newTnum>pData->mxPage && pData->mxPage>0)  ){  if( sqlite3Config.bExtraSchemaChecks ){  corruptSchema(pData, argv, "invalid rootpage");  }  }  db->init.orphanTrigger = 0;  db->init.azInit = (const char**)argv;  pStmt = 0;  TESTONLY(rcp = ) sqlite3Prepare(db, argv[4], -1, 0, 0, &pStmt, 0);  rc = db->errCode;  assert( (rc&0xFF)==(rcp&0xFF) );  db->init.iDb = saved_iDb;  if( SQLITE_OK!=rc ){  if( db->init.orphanTrigger ){  assert( iDb==1 );  }else{  if( rc > pData->rc ) pData->rc = rc;  if( rc==SQLITE_NOMEM ){  sqlite3OomFault(db);  }else if( rc!=SQLITE_INTERRUPT && (rc&0xFF)!=SQLITE_LOCKED ){  corruptSchema(pData, argv, sqlite3_errmsg(db));  }  }  }  db->init.azInit = sqlite3StdType;  sqlite3_finalize(pStmt);  }else if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){  corruptSchema(pData, argv, 0);  }else{  Index *pIndex;  pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);  if( pIndex==0 ){  corruptSchema(pData, argv, "orphan index");  }else  if( sqlite3GetUInt32(argv[3],&pIndex->tnum)==0   || pIndex->tnum<2   || pIndex->tnum>pData->mxPage   || sqlite3IndexHasDuplicateRootPage(pIndex)  ){  if( sqlite3Config.bExtraSchemaChecks ){  corruptSchema(pData, argv, "invalid rootpage");  }  }  }  return 0; } SQLITE_PRIVATE int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg, u32 mFlags){  int rc;  int i;
#ifndef SQLITE_OMIT_DEPRECATED
 int size;
#endif
 Db *pDb;  char const *azArg[6];  int meta[5];  InitData initData;  const char *zSchemaTabName;  int openedTransaction = 0;  int mask = ((db->mDbFlags & DBFLAG_EncodingFixed) | ~DBFLAG_EncodingFixed);  assert( (db->mDbFlags & DBFLAG_SchemaKnownOk)==0 );  assert( iDb>=0 && iDb<db->nDb );  assert( db->aDb[iDb].pSchema );  assert( sqlite3_mutex_held(db->mutex) );  assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );  db->init.busy = 1;  azArg[0] = "table";  azArg[1] = zSchemaTabName = SCHEMA_TABLE(iDb);  azArg[2] = azArg[1];  azArg[3] = "1";  azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,"  "rootpage int,sql text)";  azArg[5] = 0;  initData.db = db;  initData.iDb = iDb;  initData.rc = SQLITE_OK;  initData.pzErrMsg = pzErrMsg;  initData.mInitFlags = mFlags;  initData.nInitRow = 0;  initData.mxPage = 0;  sqlite3InitCallback(&initData, 5, (char **)azArg, 0);  db->mDbFlags &= mask;  if( initData.rc ){  rc = initData.rc;  goto error_out;  }  pDb = &db->aDb[iDb];  if( pDb->pBt==0 ){  assert( iDb==1 );  DbSetProperty(db, 1, DB_SchemaLoaded);  rc = SQLITE_OK;  goto error_out;  }  sqlite3BtreeEnter(pDb->pBt);  if( sqlite3BtreeTxnState(pDb->pBt)==SQLITE_TXN_NONE ){  rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);  if( rc!=SQLITE_OK ){  sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));  goto initone_error_out;  }  openedTransaction = 1;  }  for(i=0; i<ArraySize(meta); i++){  sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);  }  if( (db->flags & SQLITE_ResetDatabase)!=0 ){  memset(meta, 0, sizeof(meta));  }  pDb->pSchema->schema_cookie = meta[BTREE_SCHEMA_VERSION-1];  if( meta[BTREE_TEXT_ENCODING-1] ){  if( iDb==0 && (db->mDbFlags & DBFLAG_EncodingFixed)==0 ){  u8 encoding;
#ifndef SQLITE_OMIT_UTF16
 encoding = (u8)meta[BTREE_TEXT_ENCODING-1] & 3;  if( encoding==0 ) encoding = SQLITE_UTF8;
#else
 encoding = SQLITE_UTF8;
#endif
 sqlite3SetTextEncoding(db, encoding);  }else{  if( (meta[BTREE_TEXT_ENCODING-1] & 3)!=ENC(db) ){  sqlite3SetString(pzErrMsg, db, "attached databases must use the same"  " text encoding as main database");  rc = SQLITE_ERROR;  goto initone_error_out;  }  }  }  pDb->pSchema->enc = ENC(db);  if( pDb->pSchema->cache_size==0 ){
#ifndef SQLITE_OMIT_DEPRECATED
 size = sqlite3AbsInt32(meta[BTREE_DEFAULT_CACHE_SIZE-1]);  if( size==0 ){ size = SQLITE_DEFAULT_CACHE_SIZE; }  pDb->pSchema->cache_size = size;
#else
 pDb->pSchema->cache_size = SQLITE_DEFAULT_CACHE_SIZE;
#endif
 sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);  }  pDb->pSchema->file_format = (u8)meta[BTREE_FILE_FORMAT-1];  if( pDb->pSchema->file_format==0 ){  pDb->pSchema->file_format = 1;  }  if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){  sqlite3SetString(pzErrMsg, db, "unsupported file format");  rc = SQLITE_ERROR;  goto initone_error_out;  }  if( iDb==0 && meta[BTREE_FILE_FORMAT-1]>=4 ){  db->flags &= ~(u64)SQLITE_LegacyFileFmt;  }  assert( db->init.busy );  initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);  {  char *zSql;  zSql = sqlite3MPrintf(db,  "SELECT*FROM\"%w\".%s ORDER BY rowid",  db->aDb[iDb].zDbSName, zSchemaTabName);
#ifndef SQLITE_OMIT_AUTHORIZATION
 {  sqlite3_xauth xAuth;  xAuth = db->xAuth;  db->xAuth = 0;
#endif
 rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
#ifndef SQLITE_OMIT_AUTHORIZATION
 db->xAuth = xAuth;  }
#endif
 if( rc==SQLITE_OK ) rc = initData.rc;  sqlite3DbFree(db, zSql);
#ifndef SQLITE_OMIT_ANALYZE
 if( rc==SQLITE_OK ){  sqlite3AnalysisLoad(db, iDb);  }
#endif
 }  assert( pDb == &(db->aDb[iDb]) );  if( db->mallocFailed ){  rc = SQLITE_NOMEM_BKPT;  sqlite3ResetAllSchemasOfConnection(db);  pDb = &db->aDb[iDb];  }else  if( rc==SQLITE_OK || (db->flags&SQLITE_NoSchemaError)){  DbSetProperty(db, iDb, DB_SchemaLoaded);  rc = SQLITE_OK;  } initone_error_out:  if( openedTransaction ){  sqlite3BtreeCommit(pDb->pBt);  }  sqlite3BtreeLeave(pDb->pBt); error_out:  if( rc ){  if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){  sqlite3OomFault(db);  }  sqlite3ResetOneSchema(db, iDb);  }  db->init.busy = 0;  return rc; } SQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){  int i, rc;  int commit_internal = !(db->mDbFlags&DBFLAG_SchemaChange);  assert( sqlite3_mutex_held(db->mutex) );  assert( sqlite3BtreeHoldsMutex(db->aDb[0].pBt) );  assert( db->init.busy==0 );  ENC(db) = SCHEMA_ENC(db);  assert( db->nDb>0 );  if( !DbHasProperty(db, 0, DB_SchemaLoaded) ){  rc = sqlite3InitOne(db, 0, pzErrMsg, 0);  if( rc ) return rc;  }  for(i=db->nDb-1; i>0; i--){  assert( i==1 || sqlite3BtreeHoldsMutex(db->aDb[i].pBt) );  if( !DbHasProperty(db, i, DB_SchemaLoaded) ){  rc = sqlite3InitOne(db, i, pzErrMsg, 0);  if( rc ) return rc;  }  }  if( commit_internal ){  sqlite3CommitInternalChanges(db);  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse){  int rc = SQLITE_OK;  sqlite3 *db = pParse->db;  assert( sqlite3_mutex_held(db->mutex) );  if( !db->init.busy ){  rc = sqlite3Init(db, &pParse->zErrMsg);  if( rc!=SQLITE_OK ){  pParse->rc = rc;  pParse->nErr++;  }else if( db->noSharedCache ){  db->mDbFlags |= DBFLAG_SchemaKnownOk;  }  }  return rc; } static void schemaIsValid(Parse *pParse){  sqlite3 *db = pParse->db;  int iDb;  int rc;  int cookie;  assert( pParse->checkSchema );  assert( sqlite3_mutex_held(db->mutex) );  for(iDb=0; iDb<db->nDb; iDb++){  int openedTransaction = 0;  Btree *pBt = db->aDb[iDb].pBt;  if( pBt==0 ) continue;  if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_NONE ){  rc = sqlite3BtreeBeginTrans(pBt, 0, 0);  if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){  sqlite3OomFault(db);  pParse->rc = SQLITE_NOMEM;  }  if( rc!=SQLITE_OK ) return;  openedTransaction = 1;  }  sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){  sqlite3ResetOneSchema(db, iDb);  pParse->rc = SQLITE_SCHEMA;  }  if( openedTransaction ){  sqlite3BtreeCommit(pBt);  }  } } SQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){  int i = -32768;  assert( sqlite3_mutex_held(db->mutex) );  if( pSchema ){  for(i=0; 1; i++){  assert( i<db->nDb );  if( db->aDb[i].pSchema==pSchema ){  break;  }  }  assert( i>=0 && i<db->nDb );  }  return i; } SQLITE_PRIVATE void sqlite3ParserReset(Parse *pParse){  sqlite3 *db = pParse->db;  while( pParse->pCleanup ){  ParseCleanup *pCleanup = pParse->pCleanup;  pParse->pCleanup = pCleanup->pNext;  pCleanup->xCleanup(db, pCleanup->pPtr);  sqlite3DbFreeNN(db, pCleanup);  }  sqlite3DbFree(db, pParse->aLabel);  if( pParse->pConstExpr ){  sqlite3ExprListDelete(db, pParse->pConstExpr);  }  if( db ){  assert( db->lookaside.bDisable >= pParse->disableLookaside );  db->lookaside.bDisable -= pParse->disableLookaside;  db->lookaside.sz = db->lookaside.bDisable ? 0 : db->lookaside.szTrue;  }  pParse->disableLookaside = 0; } SQLITE_PRIVATE void *sqlite3ParserAddCleanup(  Parse *pParse,  void (*xCleanup)(sqlite3*,void*),  void *pPtr ){  ParseCleanup *pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));  if( pCleanup ){  pCleanup->pNext = pParse->pCleanup;  pParse->pCleanup = pCleanup;  pCleanup->pPtr = pPtr;  pCleanup->xCleanup = xCleanup;  }else{  xCleanup(pParse->db, pPtr);  pPtr = 0;
#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
 pParse->earlyCleanup = 1;
#endif
 }  return pPtr; } static int sqlite3Prepare(  sqlite3 *db,  const char *zSql,  int nBytes,  u32 prepFlags,  Vdbe *pReprepare,  sqlite3_stmt **ppStmt,  const char **pzTail ){  char *zErrMsg = 0;  int rc = SQLITE_OK;  int i;  Parse sParse;  memset(&sParse, 0, PARSE_HDR_SZ);  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);  sParse.pReprepare = pReprepare;  assert( ppStmt && *ppStmt==0 );  assert( sqlite3_mutex_held(db->mutex) );  if( prepFlags & SQLITE_PREPARE_PERSISTENT ){  sParse.disableLookaside++;  DisableLookaside;  }  sParse.disableVtab = (prepFlags & SQLITE_PREPARE_NO_VTAB)!=0;  if( !db->noSharedCache ){  for(i=0; i<db->nDb; i++) {  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  assert( sqlite3BtreeHoldsMutex(pBt) );  rc = sqlite3BtreeSchemaLocked(pBt);  if( rc ){  const char *zDb = db->aDb[i].zDbSName;  sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);  testcase( db->flags & SQLITE_ReadUncommit );  goto end_prepare;  }  }  }  }  sqlite3VtabUnlockList(db);  sParse.db = db;  if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){  char *zSqlCopy;  int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];  testcase( nBytes==mxLen );  testcase( nBytes==mxLen+1 );  if( nBytes>mxLen ){  sqlite3ErrorWithMsg(db, SQLITE_TOOBIG, "statement too long");  rc = sqlite3ApiExit(db, SQLITE_TOOBIG);  goto end_prepare;  }  zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);  if( zSqlCopy ){  sqlite3RunParser(&sParse, zSqlCopy, &zErrMsg);  sParse.zTail = &zSql[sParse.zTail-zSqlCopy];  sqlite3DbFree(db, zSqlCopy);  }else{  sParse.zTail = &zSql[nBytes];  }  }else{  sqlite3RunParser(&sParse, zSql, &zErrMsg);  }  assert( 0==sParse.nQueryLoop );  if( pzTail ){  *pzTail = sParse.zTail;  }  if( db->init.busy==0 ){  sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);  }  if( db->mallocFailed ){  sParse.rc = SQLITE_NOMEM_BKPT;  sParse.checkSchema = 0;  }  if( sParse.rc!=SQLITE_OK && sParse.rc!=SQLITE_DONE ){  if( sParse.checkSchema && db->init.busy==0 ){  schemaIsValid(&sParse);  }  if( sParse.pVdbe ){  sqlite3VdbeFinalize(sParse.pVdbe);  }  assert( 0==(*ppStmt) );  rc = sParse.rc;  if( zErrMsg ){  sqlite3ErrorWithMsg(db, rc, "%s", zErrMsg);  sqlite3DbFree(db, zErrMsg);  }else{  sqlite3Error(db, rc);  }  }else{  assert( zErrMsg==0 );  *ppStmt = (sqlite3_stmt*)sParse.pVdbe;  rc = SQLITE_OK;  sqlite3ErrorClear(db);  }  while( sParse.pTriggerPrg ){  TriggerPrg *pT = sParse.pTriggerPrg;  sParse.pTriggerPrg = pT->pNext;  sqlite3DbFree(db, pT);  } end_prepare:  sqlite3ParserReset(&sParse);  return rc; } static int sqlite3LockAndPrepare(  sqlite3 *db,  const char *zSql,  int nBytes,  u32 prepFlags,  Vdbe *pOld,  sqlite3_stmt **ppStmt,  const char **pzTail ){  int rc;  int cnt = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;
#endif
 *ppStmt = 0;  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){  return SQLITE_MISUSE_BKPT;  }  sqlite3_mutex_enter(db->mutex);  sqlite3BtreeEnterAll(db);  do{  rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);  assert( rc==SQLITE_OK || *ppStmt==0 );  if( rc==SQLITE_OK || db->mallocFailed ) break;  }while( rc==SQLITE_ERROR_RETRY   || (rc==SQLITE_SCHEMA && (sqlite3ResetOneSchema(db,-1), cnt++)==0) );  sqlite3BtreeLeaveAll(db);  rc = sqlite3ApiExit(db, rc);  assert( (rc&db->errMask)==rc );  db->busyHandler.nBusy = 0;  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p){  int rc;  sqlite3_stmt *pNew;  const char *zSql;  sqlite3 *db;  u8 prepFlags;  assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );  zSql = sqlite3_sql((sqlite3_stmt *)p);  assert( zSql!=0 );  db = sqlite3VdbeDb(p);  assert( sqlite3_mutex_held(db->mutex) );  prepFlags = sqlite3VdbePrepareFlags(p);  rc = sqlite3LockAndPrepare(db, zSql, -1, prepFlags, p, &pNew, 0);  if( rc ){  if( rc==SQLITE_NOMEM ){  sqlite3OomFault(db);  }  assert( pNew==0 );  return rc;  }else{  assert( pNew!=0 );  }  sqlite3VdbeSwap((Vdbe*)pNew, p);  sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);  sqlite3VdbeResetStepResult((Vdbe*)pNew);  sqlite3VdbeFinalize((Vdbe*)pNew);  return SQLITE_OK; } SQLITE_API int sqlite3_prepare(  sqlite3 *db,  const char *zSql,  int nBytes,  sqlite3_stmt **ppStmt,  const char **pzTail ){  int rc;  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  return rc; } SQLITE_API int sqlite3_prepare_v2(  sqlite3 *db,  const char *zSql,  int nBytes,  sqlite3_stmt **ppStmt,  const char **pzTail ){  int rc;  rc = sqlite3LockAndPrepare(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,0,   ppStmt,pzTail);  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  return rc; } SQLITE_API int sqlite3_prepare_v3(  sqlite3 *db,  const char *zSql,  int nBytes,  unsigned int prepFlags,  sqlite3_stmt **ppStmt,  const char **pzTail ){  int rc;  rc = sqlite3LockAndPrepare(db,zSql,nBytes,   SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),   0,ppStmt,pzTail);  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  return rc; }
#ifndef SQLITE_OMIT_UTF16
static int sqlite3Prepare16(  sqlite3 *db,  const void *zSql,  int nBytes,  u32 prepFlags,  sqlite3_stmt **ppStmt,  const void **pzTail ){  char *zSql8;  const char *zTail8 = 0;  int rc = SQLITE_OK;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;
#endif
 *ppStmt = 0;  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){  return SQLITE_MISUSE_BKPT;  }  if( nBytes>=0 ){  int sz;  const char *z = (const char*)zSql;  for(sz=0; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){}  nBytes = sz;  }  sqlite3_mutex_enter(db->mutex);  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);  if( zSql8 ){  rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);  }  if( zTail8 && pzTail ){  int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));  *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);  }  sqlite3DbFree(db, zSql8);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_prepare16(  sqlite3 *db,  const void *zSql,  int nBytes,  sqlite3_stmt **ppStmt,  const void **pzTail ){  int rc;  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  return rc; } SQLITE_API int sqlite3_prepare16_v2(  sqlite3 *db,  const void *zSql,  int nBytes,  sqlite3_stmt **ppStmt,  const void **pzTail ){  int rc;  rc = sqlite3Prepare16(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,ppStmt,pzTail);  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  return rc; } SQLITE_API int sqlite3_prepare16_v3(  sqlite3 *db,  const void *zSql,  int nBytes,  unsigned int prepFlags,  sqlite3_stmt **ppStmt,  const void **pzTail ){  int rc;  rc = sqlite3Prepare16(db,zSql,nBytes,   SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),   ppStmt,pzTail);  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  return rc; }
#endif
typedef struct DistinctCtx DistinctCtx; struct DistinctCtx {  u8 isTnct;  u8 eTnctType;  int tabTnct;  int addrTnct; }; typedef struct SortCtx SortCtx; struct SortCtx {  ExprList *pOrderBy;  int nOBSat;  int iECursor;  int regReturn;  int labelBkOut;  int addrSortIndex;  int labelDone;  int labelOBLopt;  u8 sortFlags;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 u8 nDefer;  struct DeferredCsr {  Table *pTab;  int iCsr;  int nKey;  } aDefer[4];
#endif
 struct RowLoadInfo *pDeferredRowLoad; };
#define SORTFLAG_UseSorter 0x01
static void clearSelect(sqlite3 *db, Select *p, int bFree){  while( p ){  Select *pPrior = p->pPrior;  sqlite3ExprListDelete(db, p->pEList);  sqlite3SrcListDelete(db, p->pSrc);  sqlite3ExprDelete(db, p->pWhere);  sqlite3ExprListDelete(db, p->pGroupBy);  sqlite3ExprDelete(db, p->pHaving);  sqlite3ExprListDelete(db, p->pOrderBy);  sqlite3ExprDelete(db, p->pLimit);  if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){  sqlite3WindowListDelete(db, p->pWinDefn);  }  while( p->pWin ){  assert( p->pWin->ppThis==&p->pWin );  sqlite3WindowUnlinkFromSelect(p->pWin);  }
#endif
 if( bFree ) sqlite3DbFreeNN(db, p);  p = pPrior;  bFree = 1;  } } SQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){  pDest->eDest = (u8)eDest;  pDest->iSDParm = iParm;  pDest->iSDParm2 = 0;  pDest->zAffSdst = 0;  pDest->iSdst = 0;  pDest->nSdst = 0; } SQLITE_PRIVATE Select *sqlite3SelectNew(  Parse *pParse,  ExprList *pEList,  SrcList *pSrc,  Expr *pWhere,  ExprList *pGroupBy,  Expr *pHaving,  ExprList *pOrderBy,  u32 selFlags,  Expr *pLimit ){  Select *pNew, *pAllocated;  Select standin;  pAllocated = pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );  if( pNew==0 ){  assert( pParse->db->mallocFailed );  pNew = &standin;  }  if( pEList==0 ){  pEList = sqlite3ExprListAppend(pParse, 0,   sqlite3Expr(pParse->db,TK_ASTERISK,0));  }  pNew->pEList = pEList;  pNew->op = TK_SELECT;  pNew->selFlags = selFlags;  pNew->iLimit = 0;  pNew->iOffset = 0;  pNew->selId = ++pParse->nSelect;  pNew->addrOpenEphm[0] = -1;  pNew->addrOpenEphm[1] = -1;  pNew->nSelectRow = 0;  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));  pNew->pSrc = pSrc;  pNew->pWhere = pWhere;  pNew->pGroupBy = pGroupBy;  pNew->pHaving = pHaving;  pNew->pOrderBy = pOrderBy;  pNew->pPrior = 0;  pNew->pNext = 0;  pNew->pLimit = pLimit;  pNew->pWith = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
 pNew->pWin = 0;  pNew->pWinDefn = 0;
#endif
 if( pParse->db->mallocFailed ) {  clearSelect(pParse->db, pNew, pNew!=&standin);  pAllocated = 0;  }else{  assert( pNew->pSrc!=0 || pParse->nErr>0 );  }  return pAllocated; } SQLITE_PRIVATE void sqlite3SelectDelete(sqlite3 *db, Select *p){  if( OK_IF_ALWAYS_TRUE(p) ) clearSelect(db, p, 1); } static Select *findRightmost(Select *p){  while( p->pNext ) p = p->pNext;  return p; } SQLITE_PRIVATE int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){  int jointype = 0;  Token *apAll[3];  Token *p;  static const char zKeyText[] = "naturaleftouterightfullinnercross";  static const struct {  u8 i;  u8 nChar;  u8 code;  } aKeyword[] = {  { 0, 7, JT_NATURAL },  { 6, 4, JT_LEFT|JT_OUTER },  { 10, 5, JT_OUTER },  { 14, 5, JT_RIGHT|JT_OUTER  },  { 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER },  { 23, 5, JT_INNER },  { 28, 5, JT_INNER|JT_CROSS  },  };  int i, j;  apAll[0] = pA;  apAll[1] = pB;  apAll[2] = pC;  for(i=0; i<3 && apAll[i]; i++){  p = apAll[i];  for(j=0; j<ArraySize(aKeyword); j++){  if( p->n==aKeyword[j].nChar  && sqlite3StrNICmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){  jointype |= aKeyword[j].code;  break;  }  }  testcase( j==0 || j==1 || j==2 || j==3 || j==4 || j==5 || j==6 );  if( j>=ArraySize(aKeyword) ){  jointype |= JT_ERROR;  break;  }  }  if(   (jointype & (JT_INNER|JT_OUTER))==(JT_INNER|JT_OUTER) ||   (jointype & JT_ERROR)!=0  ){  const char *zSp = " ";  assert( pB!=0 );  if( pC==0 ){ zSp++; }  sqlite3ErrorMsg(pParse, "unknown or unsupported join type: "   "%T %T%s%T", pA, pB, zSp, pC);  jointype = JT_INNER;  }else if( (jointype & JT_OUTER)!=0   && (jointype & (JT_LEFT|JT_RIGHT))!=JT_LEFT ){  sqlite3ErrorMsg(pParse,  "RIGHT and FULL OUTER JOINs are not currently supported");  jointype = JT_INNER;  }  return jointype; } SQLITE_PRIVATE int sqlite3ColumnIndex(Table *pTab, const char *zCol){  int i;  u8 h = sqlite3StrIHash(zCol);  Column *pCol;  for(pCol=pTab->aCol, i=0; i<pTab->nCol; pCol++, i++){  if( pCol->hName==h && sqlite3StrICmp(pCol->zCnName, zCol)==0 ) return i;  }  return -1; } static int tableAndColumnIndex(  SrcList *pSrc,  int N,  const char *zCol,  int *piTab,  int *piCol,  int bIgnoreHidden ){  int i;  int iCol;  assert( (piTab==0)==(piCol==0) );  for(i=0; i<N; i++){  iCol = sqlite3ColumnIndex(pSrc->a[i].pTab, zCol);  if( iCol>=0   && (bIgnoreHidden==0 || IsHiddenColumn(&pSrc->a[i].pTab->aCol[iCol])==0)  ){  if( piTab ){  *piTab = i;  *piCol = iCol;  }  return 1;  }  }  return 0; } static void addWhereTerm(  Parse *pParse,  SrcList *pSrc,  int iLeft,  int iColLeft,  int iRight,  int iColRight,  int isOuterJoin,  Expr **ppWhere ){  sqlite3 *db = pParse->db;  Expr *pE1;  Expr *pE2;  Expr *pEq;  assert( iLeft<iRight );  assert( pSrc->nSrc>iRight );  assert( pSrc->a[iLeft].pTab );  assert( pSrc->a[iRight].pTab );  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);  pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2);  assert( pE2!=0 || pEq==0 );  if( pEq && isOuterJoin ){  ExprSetProperty(pEq, EP_FromJoin);  assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );  ExprSetVVAProperty(pEq, EP_NoReduce);  pEq->iRightJoinTable = pE2->iTable;  }  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq); } SQLITE_PRIVATE void sqlite3SetJoinExpr(Expr *p, int iTable){  while( p ){  ExprSetProperty(p, EP_FromJoin);  assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );  ExprSetVVAProperty(p, EP_NoReduce);  p->iRightJoinTable = iTable;  if( p->op==TK_FUNCTION ){  assert( ExprUseXList(p) );  if( p->x.pList ){  int i;  for(i=0; i<p->x.pList->nExpr; i++){  sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);  }  }  }  sqlite3SetJoinExpr(p->pLeft, iTable);  p = p->pRight;  } } static void unsetJoinExpr(Expr *p, int iTable){  while( p ){  if( ExprHasProperty(p, EP_FromJoin)   && (iTable<0 || p->iRightJoinTable==iTable) ){  ExprClearProperty(p, EP_FromJoin);  }  if( p->op==TK_COLUMN && p->iTable==iTable ){  ExprClearProperty(p, EP_CanBeNull);  }  if( p->op==TK_FUNCTION ){  assert( ExprUseXList(p) );  if( p->x.pList ){  int i;  for(i=0; i<p->x.pList->nExpr; i++){  unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);  }  }  }  unsetJoinExpr(p->pLeft, iTable);  p = p->pRight;  } } static int sqliteProcessJoin(Parse *pParse, Select *p){  SrcList *pSrc;  int i, j;  SrcItem *pLeft;  SrcItem *pRight;  pSrc = p->pSrc;  pLeft = &pSrc->a[0];  pRight = &pLeft[1];  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){  Table *pRightTab = pRight->pTab;  int isOuter;  if( NEVER(pLeft->pTab==0 || pRightTab==0) ) continue;  isOuter = (pRight->fg.jointype & JT_OUTER)!=0;  if( pRight->fg.jointype & JT_NATURAL ){  if( pRight->pOn || pRight->pUsing ){  sqlite3ErrorMsg(pParse, "a NATURAL join may not have "   "an ON or USING clause", 0);  return 1;  }  for(j=0; j<pRightTab->nCol; j++){  char *zName;  int iLeft;  int iLeftCol;  if( IsHiddenColumn(&pRightTab->aCol[j]) ) continue;  zName = pRightTab->aCol[j].zCnName;  if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol, 1) ){  addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,  isOuter, &p->pWhere);  }  }  }  if( pRight->pOn && pRight->pUsing ){  sqlite3ErrorMsg(pParse, "cannot have both ON and USING "  "clauses in the same join");  return 1;  }  if( pRight->pOn ){  if( isOuter ) sqlite3SetJoinExpr(pRight->pOn, pRight->iCursor);  p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);  pRight->pOn = 0;  }  if( pRight->pUsing ){  IdList *pList = pRight->pUsing;  for(j=0; j<pList->nId; j++){  char *zName;  int iLeft;  int iLeftCol;  int iRightCol;  zName = pList->a[j].zName;  iRightCol = sqlite3ColumnIndex(pRightTab, zName);  if( iRightCol<0   || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol, 0)  ){  sqlite3ErrorMsg(pParse, "cannot join using column %s - column "  "not present in both tables", zName);  return 1;  }  addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,   isOuter, &p->pWhere);  }  }  }  return 0; } typedef struct RowLoadInfo RowLoadInfo; struct RowLoadInfo {  int regResult;  u8 ecelFlags;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 ExprList *pExtra;  int regExtraResult;
#endif
}; static void innerLoopLoadRow(  Parse *pParse,  Select *pSelect,  RowLoadInfo *pInfo ){  sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,  0, pInfo->ecelFlags);
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( pInfo->pExtra ){  sqlite3ExprCodeExprList(pParse, pInfo->pExtra, pInfo->regExtraResult, 0, 0);  sqlite3ExprListDelete(pParse->db, pInfo->pExtra);  }
#endif
} static int makeSorterRecord(  Parse *pParse,  SortCtx *pSort,  Select *pSelect,  int regBase,  int nBase ){  int nOBSat = pSort->nOBSat;  Vdbe *v = pParse->pVdbe;  int regOut = ++pParse->nMem;  if( pSort->pDeferredRowLoad ){  innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase+nOBSat, nBase-nOBSat, regOut);  return regOut; } static void pushOntoSorter(  Parse *pParse,  SortCtx *pSort,  Select *pSelect,  int regData,  int regOrigData,  int nData,  int nPrefixReg ){  Vdbe *v = pParse->pVdbe;  int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter)==0);  int nExpr = pSort->pOrderBy->nExpr;  int nBase = nExpr + bSeq + nData;  int regBase;  int regRecord = 0;  int nOBSat = pSort->nOBSat;  int op;  int iLimit;  int iSkip = 0;  assert( bSeq==0 || bSeq==1 );  assert( nData==1 || regData==regOrigData || regOrigData==0 );  if( nPrefixReg ){  assert( nPrefixReg==nExpr+bSeq );  regBase = regData - nPrefixReg;  }else{  regBase = pParse->nMem + 1;  pParse->nMem += nBase;  }  assert( pSelect->iOffset==0 || pSelect->iLimit!=0 );  iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,  SQLITE_ECEL_DUP | (regOrigData? SQLITE_ECEL_REF : 0));  if( bSeq ){  sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase+nExpr);  }  if( nPrefixReg==0 && nData>0 ){  sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);  }  if( nOBSat>0 ){  int regPrevKey;  int addrFirst;  int addrJmp;  VdbeOp *pOp;  int nKey;  KeyInfo *pKI;  regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);  regPrevKey = pParse->nMem+1;  pParse->nMem += pSort->nOBSat;  nKey = nExpr - pSort->nOBSat + bSeq;  if( bSeq ){  addrFirst = sqlite3VdbeAddOp1(v, OP_IfNot, regBase+nExpr);  }else{  addrFirst = sqlite3VdbeAddOp1(v, OP_SequenceTest, pSort->iECursor);  }  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);  pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);  if( pParse->db->mallocFailed ) return;  pOp->p2 = nKey + nData;  pKI = pOp->p4.pKeyInfo;  memset(pKI->aSortFlags, 0, pKI->nKeyField);  sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);  testcase( pKI->nAllField > pKI->nKeyField+2 );  pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,   pKI->nAllField-pKI->nKeyField-1);  pOp = 0;  addrJmp = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp3(v, OP_Jump, addrJmp+1, 0, addrJmp+1); VdbeCoverage(v);  pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);  pSort->regReturn = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);  sqlite3VdbeAddOp1(v, OP_ResetSorter, pSort->iECursor);  if( iLimit ){  sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, pSort->labelDone);  VdbeCoverage(v);  }  sqlite3VdbeJumpHere(v, addrFirst);  sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);  sqlite3VdbeJumpHere(v, addrJmp);  }  if( iLimit ){  int iCsr = pSort->iECursor;  sqlite3VdbeAddOp2(v, OP_IfNotZero, iLimit, sqlite3VdbeCurrentAddr(v)+4);  VdbeCoverage(v);  sqlite3VdbeAddOp2(v, OP_Last, iCsr, 0);  iSkip = sqlite3VdbeAddOp4Int(v, OP_IdxLE,   iCsr, 0, regBase+nOBSat, nExpr-nOBSat);  VdbeCoverage(v);  sqlite3VdbeAddOp1(v, OP_Delete, iCsr);  }  if( regRecord==0 ){  regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);  }  if( pSort->sortFlags & SORTFLAG_UseSorter ){  op = OP_SorterInsert;  }else{  op = OP_IdxInsert;  }  sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,   regBase+nOBSat, nBase-nOBSat);  if( iSkip ){  sqlite3VdbeChangeP2(v, iSkip,   pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));  } } static void codeOffset(  Vdbe *v,  int iOffset,  int iContinue ){  if( iOffset>0 ){  sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);  VdbeComment((v, "OFFSET"));  } } static int codeDistinct(  Parse *pParse,  int eTnctType,  int iTab,  int addrRepeat,  ExprList *pEList,  int regElem ){  int iRet = 0;  int nResultCol = pEList->nExpr;  Vdbe *v = pParse->pVdbe;  switch( eTnctType ){  case WHERE_DISTINCT_ORDERED: {  int i;  int iJump;  int regPrev;  iRet = regPrev = pParse->nMem+1;  pParse->nMem += nResultCol;  iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;  for(i=0; i<nResultCol; i++){  CollSeq *pColl = sqlite3ExprCollSeq(pParse, pEList->a[i].pExpr);  if( i<nResultCol-1 ){  sqlite3VdbeAddOp3(v, OP_Ne, regElem+i, iJump, regPrev+i);  VdbeCoverage(v);  }else{  sqlite3VdbeAddOp3(v, OP_Eq, regElem+i, addrRepeat, regPrev+i);  VdbeCoverage(v);   }  sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);  sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);  }  assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );  sqlite3VdbeAddOp3(v, OP_Copy, regElem, regPrev, nResultCol-1);  break;  }  case WHERE_DISTINCT_UNIQUE: {  break;  }  default: {  int r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, regElem, nResultCol);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_MakeRecord, regElem, nResultCol, r1);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, regElem, nResultCol);  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);  sqlite3ReleaseTempReg(pParse, r1);  iRet = iTab;  break;  }  }  return iRet; } static void fixDistinctOpenEph(  Parse *pParse,  int eTnctType,  int iVal,  int iOpenEphAddr ){  if( pParse->nErr==0   && (eTnctType==WHERE_DISTINCT_UNIQUE || eTnctType==WHERE_DISTINCT_ORDERED)  ){  Vdbe *v = pParse->pVdbe;  sqlite3VdbeChangeToNoop(v, iOpenEphAddr);  if( sqlite3VdbeGetOp(v, iOpenEphAddr+1)->opcode==OP_Explain ){  sqlite3VdbeChangeToNoop(v, iOpenEphAddr+1);  }  if( eTnctType==WHERE_DISTINCT_ORDERED ){  VdbeOp *pOp = sqlite3VdbeGetOp(v, iOpenEphAddr);  pOp->opcode = OP_Null;  pOp->p1 = 1;  pOp->p2 = iVal;  }  } }
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
static void selectExprDefer(  Parse *pParse,  SortCtx *pSort,  ExprList *pEList,  ExprList **ppExtra ){  int i;  int nDefer = 0;  ExprList *pExtra = 0;  for(i=0; i<pEList->nExpr; i++){  struct ExprList_item *pItem = &pEList->a[i];  if( pItem->u.x.iOrderByCol==0 ){  Expr *pExpr = pItem->pExpr;  Table *pTab;  if( pExpr->op==TK_COLUMN   && pExpr->iColumn>=0   && ALWAYS( ExprUseYTab(pExpr) )   && (pTab = pExpr->y.pTab)!=0   && IsOrdinaryTable(pTab)   && (pTab->aCol[pExpr->iColumn].colFlags & COLFLAG_SORTERREF)!=0  ){  int j;  for(j=0; j<nDefer; j++){  if( pSort->aDefer[j].iCsr==pExpr->iTable ) break;  }  if( j==nDefer ){  if( nDefer==ArraySize(pSort->aDefer) ){  continue;  }else{  int nKey = 1;  int k;  Index *pPk = 0;  if( !HasRowid(pTab) ){  pPk = sqlite3PrimaryKeyIndex(pTab);  nKey = pPk->nKeyCol;  }  for(k=0; k<nKey; k++){  Expr *pNew = sqlite3PExpr(pParse, TK_COLUMN, 0, 0);  if( pNew ){  pNew->iTable = pExpr->iTable;  assert( ExprUseYTab(pNew) );  pNew->y.pTab = pExpr->y.pTab;  pNew->iColumn = pPk ? pPk->aiColumn[k] : -1;  pExtra = sqlite3ExprListAppend(pParse, pExtra, pNew);  }  }  pSort->aDefer[nDefer].pTab = pExpr->y.pTab;  pSort->aDefer[nDefer].iCsr = pExpr->iTable;  pSort->aDefer[nDefer].nKey = nKey;  nDefer++;  }  }  pItem->bSorterRef = 1;  }  }  }  pSort->nDefer = (u8)nDefer;  *ppExtra = pExtra; }
#endif
static void selectInnerLoop(  Parse *pParse,  Select *p,  int srcTab,  SortCtx *pSort,  DistinctCtx *pDistinct,  SelectDest *pDest,  int iContinue,  int iBreak ){  Vdbe *v = pParse->pVdbe;  int i;  int hasDistinct;  int eDest = pDest->eDest;  int iParm = pDest->iSDParm;  int nResultCol;  int nPrefixReg = 0;  RowLoadInfo sRowLoadInfo;  int regResult;  int regOrig;  assert( v );  assert( p->pEList!=0 );  hasDistinct = pDistinct ? pDistinct->eTnctType : WHERE_DISTINCT_NOOP;  if( pSort && pSort->pOrderBy==0 ) pSort = 0;  if( pSort==0 && !hasDistinct ){  assert( iContinue!=0 );  codeOffset(v, p->iOffset, iContinue);  }  nResultCol = p->pEList->nExpr;  if( pDest->iSdst==0 ){  if( pSort ){  nPrefixReg = pSort->pOrderBy->nExpr;  if( !(pSort->sortFlags & SORTFLAG_UseSorter) ) nPrefixReg++;  pParse->nMem += nPrefixReg;  }  pDest->iSdst = pParse->nMem+1;  pParse->nMem += nResultCol;  }else if( pDest->iSdst+nResultCol > pParse->nMem ){  pParse->nMem += nResultCol;  }  pDest->nSdst = nResultCol;  regOrig = regResult = pDest->iSdst;  if( srcTab>=0 ){  for(i=0; i<nResultCol; i++){  sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);  VdbeComment((v, "%s", p->pEList->a[i].zEName));  }  }else if( eDest!=SRT_Exists ){
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 ExprList *pExtra = 0;
#endif
 u8 ecelFlags;  ExprList *pEList;  if( eDest==SRT_Mem || eDest==SRT_Output || eDest==SRT_Coroutine ){  ecelFlags = SQLITE_ECEL_DUP;  }else{  ecelFlags = 0;  }  if( pSort && hasDistinct==0 && eDest!=SRT_EphemTab && eDest!=SRT_Table ){  ecelFlags |= (SQLITE_ECEL_OMITREF|SQLITE_ECEL_REF);  for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){  int j;  if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){  p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;  }  }
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 selectExprDefer(pParse, pSort, p->pEList, &pExtra);  if( pExtra && pParse->db->mallocFailed==0 ){  VdbeOp *pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);  pOp->p2 += (pExtra->nExpr - pSort->nDefer);  pOp->p4.pKeyInfo->nAllField += (pExtra->nExpr - pSort->nDefer);  pParse->nMem += pExtra->nExpr;  }
#endif
 pEList = p->pEList;  for(i=0; i<pEList->nExpr; i++){  if( pEList->a[i].u.x.iOrderByCol>0
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
  || pEList->a[i].bSorterRef
#endif
 ){  nResultCol--;  regOrig = 0;  }  }  testcase( regOrig );  testcase( eDest==SRT_Set );  testcase( eDest==SRT_Mem );  testcase( eDest==SRT_Coroutine );  testcase( eDest==SRT_Output );  assert( eDest==SRT_Set || eDest==SRT_Mem   || eDest==SRT_Coroutine || eDest==SRT_Output   || eDest==SRT_Upfrom );  }  sRowLoadInfo.regResult = regResult;  sRowLoadInfo.ecelFlags = ecelFlags;
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 sRowLoadInfo.pExtra = pExtra;  sRowLoadInfo.regExtraResult = regResult + nResultCol;  if( pExtra ) nResultCol += pExtra->nExpr;
#endif
 if( p->iLimit   && (ecelFlags & SQLITE_ECEL_OMITREF)!=0   && nPrefixReg>0  ){  assert( pSort!=0 );  assert( hasDistinct==0 );  pSort->pDeferredRowLoad = &sRowLoadInfo;  regOrig = 0;  }else{  innerLoopLoadRow(pParse, p, &sRowLoadInfo);  }  }  if( hasDistinct ){  int eType = pDistinct->eTnctType;  int iTab = pDistinct->tabTnct;  assert( nResultCol==p->pEList->nExpr );  iTab = codeDistinct(pParse, eType, iTab, iContinue, p->pEList, regResult);  fixDistinctOpenEph(pParse, eType, iTab, pDistinct->addrTnct);  if( pSort==0 ){  codeOffset(v, p->iOffset, iContinue);  }  }  switch( eDest ){
#ifndef SQLITE_OMIT_COMPOUND_SELECT
 case SRT_Union: {  int r1;  r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);  sqlite3ReleaseTempReg(pParse, r1);  break;  }  case SRT_Except: {  sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nResultCol);  break;  }
#endif
 case SRT_Fifo:  case SRT_DistFifo:  case SRT_Table:  case SRT_EphemTab: {  int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);  testcase( eDest==SRT_Table );  testcase( eDest==SRT_EphemTab );  testcase( eDest==SRT_Fifo );  testcase( eDest==SRT_DistFifo );  sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1+nPrefixReg);
#ifndef SQLITE_OMIT_CTE
 if( eDest==SRT_DistFifo ){  int addr = sqlite3VdbeCurrentAddr(v) + 4;  sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, addr, r1, 0);  VdbeCoverage(v);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm+1, r1,regResult,nResultCol);  assert( pSort==0 );  }
#endif
 if( pSort ){  assert( regResult==regOrig );  pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);  }else{  int r2 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);  sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);  sqlite3VdbeChangeP5(v, OPFLAG_APPEND);  sqlite3ReleaseTempReg(pParse, r2);  }  sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);  break;  }  case SRT_Upfrom: {  if( pSort ){  pushOntoSorter(  pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);  }else{  int i2 = pDest->iSDParm2;  int r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_IsNull, regResult, iBreak); VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_MakeRecord,  regResult+(i2<0), nResultCol-(i2<0), r1);  if( i2<0 ){  sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regResult);  }else{  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, i2);  }  }  break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case SRT_Set: {  if( pSort ){  pushOntoSorter(  pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);  }else{  int r1 = sqlite3GetTempReg(pParse);  assert( sqlite3Strlen30(pDest->zAffSdst)==nResultCol );  sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol,  r1, pDest->zAffSdst, nResultCol);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);  sqlite3ReleaseTempReg(pParse, r1);  }  break;  }  case SRT_Exists: {  sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);  break;  }  case SRT_Mem: {  if( pSort ){  assert( nResultCol<=pDest->nSdst );  pushOntoSorter(  pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);  }else{  assert( nResultCol==pDest->nSdst );  assert( regResult==iParm );  }  break;  }
#endif
 case SRT_Coroutine:  case SRT_Output: {  testcase( eDest==SRT_Coroutine );  testcase( eDest==SRT_Output );  if( pSort ){  pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,   nPrefixReg);  }else if( eDest==SRT_Coroutine ){  sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);  }else{  sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nResultCol);  }  break;  }
#ifndef SQLITE_OMIT_CTE
 case SRT_DistQueue:  case SRT_Queue: {  int nKey;  int r1, r2, r3;  int addrTest = 0;  ExprList *pSO;  pSO = pDest->pOrderBy;  assert( pSO );  nKey = pSO->nExpr;  r1 = sqlite3GetTempReg(pParse);  r2 = sqlite3GetTempRange(pParse, nKey+2);  r3 = r2+nKey+1;  if( eDest==SRT_DistQueue ){  addrTest = sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, 0,  regResult, nResultCol);  VdbeCoverage(v);  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r3);  if( eDest==SRT_DistQueue ){  sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm+1, r3);  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);  }  for(i=0; i<nKey; i++){  sqlite3VdbeAddOp2(v, OP_SCopy,  regResult + pSO->a[i].u.x.iOrderByCol - 1,  r2+i);  }  sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2+nKey);  sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey+2, r1);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, r2, nKey+2);  if( addrTest ) sqlite3VdbeJumpHere(v, addrTest);  sqlite3ReleaseTempReg(pParse, r1);  sqlite3ReleaseTempRange(pParse, r2, nKey+2);  break;  }
#endif
#if !defined(SQLITE_OMIT_TRIGGER)
 default: {  assert( eDest==SRT_Discard );  break;  }
#endif
 }  if( pSort==0 && p->iLimit ){  sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);  } } SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);  if( p ){  p->aSortFlags = (u8*)&p->aColl[N+X];  p->nKeyField = (u16)N;  p->nAllField = (u16)(N+X);  p->enc = ENC(db);  p->db = db;  p->nRef = 1;  memset(&p[1], 0, nExtra);  }else{  sqlite3OomFault(db);  }  return p; } SQLITE_PRIVATE void sqlite3KeyInfoUnref(KeyInfo *p){  if( p ){  assert( p->nRef>0 );  p->nRef--;  if( p->nRef==0 ) sqlite3DbFreeNN(p->db, p);  } } SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoRef(KeyInfo *p){  if( p ){  assert( p->nRef>0 );  p->nRef++;  }  return p; }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3KeyInfoIsWriteable(KeyInfo *p){ return p->nRef==1; }
#endif
SQLITE_PRIVATE KeyInfo *sqlite3KeyInfoFromExprList(  Parse *pParse,  ExprList *pList,  int iStart,  int nExtra ){  int nExpr;  KeyInfo *pInfo;  struct ExprList_item *pItem;  sqlite3 *db = pParse->db;  int i;  nExpr = pList->nExpr;  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);  if( pInfo ){  assert( sqlite3KeyInfoIsWriteable(pInfo) );  for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){  pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);  pInfo->aSortFlags[i-iStart] = pItem->sortFlags;  }  }  return pInfo; } SQLITE_PRIVATE const char *sqlite3SelectOpName(int id){  char *z;  switch( id ){  case TK_ALL:  z = "UNION ALL";  break;  case TK_INTERSECT: z = "INTERSECT";  break;  case TK_EXCEPT: z = "EXCEPT"; break;  default:  z = "UNION";  break;  }  return z; }
#ifndef SQLITE_OMIT_EXPLAIN
static void explainTempTable(Parse *pParse, const char *zUsage){  ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s", zUsage)); }
# define explainSetInteger(a, b) a = b
#else
# define explainTempTable(y,z)
# define explainSetInteger(y,z)
#endif
static void generateSortTail(  Parse *pParse,  Select *p,  SortCtx *pSort,  int nColumn,  SelectDest *pDest ){  Vdbe *v = pParse->pVdbe;  int addrBreak = pSort->labelDone;  int addrContinue = sqlite3VdbeMakeLabel(pParse);  int addr;  int addrOnce = 0;  int iTab;  ExprList *pOrderBy = pSort->pOrderBy;  int eDest = pDest->eDest;  int iParm = pDest->iSDParm;  int regRow;  int regRowid;  int iCol;  int nKey;  int iSortTab;  int i;  int bSeq;  int nRefKey = 0;  struct ExprList_item *aOutEx = p->pEList->a;  assert( addrBreak<0 );  if( pSort->labelBkOut ){  sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);  sqlite3VdbeGoto(v, addrBreak);  sqlite3VdbeResolveLabel(v, pSort->labelBkOut);  }
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 for(i=0; i<pSort->nDefer; i++){  Table *pTab = pSort->aDefer[i].pTab;  int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  sqlite3OpenTable(pParse, pSort->aDefer[i].iCsr, iDb, pTab, OP_OpenRead);  nRefKey = MAX(nRefKey, pSort->aDefer[i].nKey);  }
#endif
 iTab = pSort->iECursor;  if( eDest==SRT_Output || eDest==SRT_Coroutine || eDest==SRT_Mem ){  regRowid = 0;  regRow = pDest->iSdst;  }else{  regRowid = sqlite3GetTempReg(pParse);  if( eDest==SRT_EphemTab || eDest==SRT_Table ){  regRow = sqlite3GetTempReg(pParse);  nColumn = 0;  }else{  regRow = sqlite3GetTempRange(pParse, nColumn);  }  }  nKey = pOrderBy->nExpr - pSort->nOBSat;  if( pSort->sortFlags & SORTFLAG_UseSorter ){  int regSortOut = ++pParse->nMem;  iSortTab = pParse->nTab++;  if( pSort->labelBkOut ){  addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  }  sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut,  nKey+1+nColumn+nRefKey);  if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);  addr = 1 + sqlite3VdbeAddOp2(v, OP_SorterSort, iTab, addrBreak);  VdbeCoverage(v);  codeOffset(v, p->iOffset, addrContinue);  sqlite3VdbeAddOp3(v, OP_SorterData, iTab, regSortOut, iSortTab);  bSeq = 0;  }else{  addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak); VdbeCoverage(v);  codeOffset(v, p->iOffset, addrContinue);  iSortTab = iTab;  bSeq = 1;  }  for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++){
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( aOutEx[i].bSorterRef ) continue;
#endif
 if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;  }
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( pSort->nDefer ){  int iKey = iCol+1;  int regKey = sqlite3GetTempRange(pParse, nRefKey);  for(i=0; i<pSort->nDefer; i++){  int iCsr = pSort->aDefer[i].iCsr;  Table *pTab = pSort->aDefer[i].pTab;  int nKey = pSort->aDefer[i].nKey;  sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);  if( HasRowid(pTab) ){  sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey);  sqlite3VdbeAddOp3(v, OP_SeekRowid, iCsr,  sqlite3VdbeCurrentAddr(v)+1, regKey);  }else{  int k;  int iJmp;  assert( sqlite3PrimaryKeyIndex(pTab)->nKeyCol==nKey );  for(k=0; k<nKey; k++){  sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey+k);  }  iJmp = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp4Int(v, OP_SeekGE, iCsr, iJmp+2, regKey, nKey);  sqlite3VdbeAddOp4Int(v, OP_IdxLE, iCsr, iJmp+3, regKey, nKey);  sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);  }  }  sqlite3ReleaseTempRange(pParse, regKey, nRefKey);  }
#endif
 for(i=nColumn-1; i>=0; i--){
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 if( aOutEx[i].bSorterRef ){  sqlite3ExprCode(pParse, aOutEx[i].pExpr, regRow+i);  }else
#endif
 {  int iRead;  if( aOutEx[i].u.x.iOrderByCol ){  iRead = aOutEx[i].u.x.iOrderByCol-1;  }else{  iRead = iCol--;  }  sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);  VdbeComment((v, "%s", aOutEx[i].zEName));  }  }  switch( eDest ){  case SRT_Table:  case SRT_EphemTab: {  sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey+bSeq, regRow);  sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);  sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);  sqlite3VdbeChangeP5(v, OPFLAG_APPEND);  break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case SRT_Set: {  assert( nColumn==sqlite3Strlen30(pDest->zAffSdst) );  sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, nColumn, regRowid,  pDest->zAffSdst, nColumn);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, regRowid, regRow, nColumn);  break;  }  case SRT_Mem: {  break;  }
#endif
 case SRT_Upfrom: {  int i2 = pDest->iSDParm2;  int r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_MakeRecord,regRow+(i2<0),nColumn-(i2<0),r1);  if( i2<0 ){  sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, regRow);  }else{  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regRow, i2);  }  break;  }  default: {  assert( eDest==SRT_Output || eDest==SRT_Coroutine );  testcase( eDest==SRT_Output );  testcase( eDest==SRT_Coroutine );  if( eDest==SRT_Output ){  sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iSdst, nColumn);  }else{  sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);  }  break;  }  }  if( regRowid ){  if( eDest==SRT_Set ){  sqlite3ReleaseTempRange(pParse, regRow, nColumn);  }else{  sqlite3ReleaseTempReg(pParse, regRow);  }  sqlite3ReleaseTempReg(pParse, regRowid);  }  sqlite3VdbeResolveLabel(v, addrContinue);  if( pSort->sortFlags & SORTFLAG_UseSorter ){  sqlite3VdbeAddOp2(v, OP_SorterNext, iTab, addr); VdbeCoverage(v);  }else{  sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); VdbeCoverage(v);  }  if( pSort->regReturn ) sqlite3VdbeAddOp1(v, OP_Return, pSort->regReturn);  sqlite3VdbeResolveLabel(v, addrBreak); }
#ifdef SQLITE_ENABLE_COLUMN_METADATA
# define columnType(A,B,C,D,E) columnTypeImpl(A,B,C,D,E)
#else
# define columnType(A,B,C,D,E) columnTypeImpl(A,B)
#endif
static const char *columnTypeImpl(  NameContext *pNC,
#ifndef SQLITE_ENABLE_COLUMN_METADATA
 Expr *pExpr
#else
 Expr *pExpr,  const char **pzOrigDb,  const char **pzOrigTab,  const char **pzOrigCol
#endif
){  char const *zType = 0;  int j;
#ifdef SQLITE_ENABLE_COLUMN_METADATA
 char const *zOrigDb = 0;  char const *zOrigTab = 0;  char const *zOrigCol = 0;
#endif
 assert( pExpr!=0 );  assert( pNC->pSrcList!=0 );  switch( pExpr->op ){  case TK_COLUMN: {  Table *pTab = 0;  Select *pS = 0;  int iCol = pExpr->iColumn;  while( pNC && !pTab ){  SrcList *pTabList = pNC->pSrcList;  for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);  if( j<pTabList->nSrc ){  pTab = pTabList->a[j].pTab;  pS = pTabList->a[j].pSelect;  }else{  pNC = pNC->pNext;  }  }  if( pTab==0 ){  break;  }  assert( pTab && ExprUseYTab(pExpr) && pExpr->y.pTab==pTab );  if( pS ){  if( iCol<pS->pEList->nExpr
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
  && iCol>=0
#else
  && ALWAYS(iCol>=0)
#endif
 ){  NameContext sNC;  Expr *p = pS->pEList->a[iCol].pExpr;  sNC.pSrcList = pS->pSrc;  sNC.pNext = pNC;  sNC.pParse = pNC->pParse;  zType = columnType(&sNC, p,&zOrigDb,&zOrigTab,&zOrigCol);  }  }else{  assert( !pS );
#ifdef SQLITE_ENABLE_COLUMN_METADATA
 if( iCol<0 ) iCol = pTab->iPKey;  assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );  if( iCol<0 ){  zType = "INTEGER";  zOrigCol = "rowid";  }else{  zOrigCol = pTab->aCol[iCol].zCnName;  zType = sqlite3ColumnType(&pTab->aCol[iCol],0);  }  zOrigTab = pTab->zName;  if( pNC->pParse && pTab->pSchema ){  int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);  zOrigDb = pNC->pParse->db->aDb[iDb].zDbSName;  }
#else
 assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );  if( iCol<0 ){  zType = "INTEGER";  }else{  zType = sqlite3ColumnType(&pTab->aCol[iCol],0);  }
#endif
 }  break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case TK_SELECT: {  NameContext sNC;  Select *pS;  Expr *p;  assert( ExprUseXSelect(pExpr) );  pS = pExpr->x.pSelect;  p = pS->pEList->a[0].pExpr;  sNC.pSrcList = pS->pSrc;  sNC.pNext = pNC;  sNC.pParse = pNC->pParse;  zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);  break;  }
#endif
 }
#ifdef SQLITE_ENABLE_COLUMN_METADATA
 if( pzOrigDb ){  assert( pzOrigTab && pzOrigCol );  *pzOrigDb = zOrigDb;  *pzOrigTab = zOrigTab;  *pzOrigCol = zOrigCol;  }
#endif
 return zType; } static void generateColumnTypes(  Parse *pParse,  SrcList *pTabList,  ExprList *pEList ){
#ifndef SQLITE_OMIT_DECLTYPE
 Vdbe *v = pParse->pVdbe;  int i;  NameContext sNC;  sNC.pSrcList = pTabList;  sNC.pParse = pParse;  sNC.pNext = 0;  for(i=0; i<pEList->nExpr; i++){  Expr *p = pEList->a[i].pExpr;  const char *zType;
#ifdef SQLITE_ENABLE_COLUMN_METADATA
 const char *zOrigDb = 0;  const char *zOrigTab = 0;  const char *zOrigCol = 0;  zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);  sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);  sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);  sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);
#else
 zType = columnType(&sNC, p, 0, 0, 0);
#endif
 sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);  }
#endif
} SQLITE_PRIVATE void sqlite3GenerateColumnNames(  Parse *pParse,  Select *pSelect ){  Vdbe *v = pParse->pVdbe;  int i;  Table *pTab;  SrcList *pTabList;  ExprList *pEList;  sqlite3 *db = pParse->db;  int fullName;  int srcName;
#ifndef SQLITE_OMIT_EXPLAIN
 if( pParse->explain ){  return;  }
#endif
 if( pParse->colNamesSet ) return;  while( pSelect->pPrior ) pSelect = pSelect->pPrior;  SELECTTRACE(1,pParse,pSelect,("generating column names\n"));  pTabList = pSelect->pSrc;  pEList = pSelect->pEList;  assert( v!=0 );  assert( pTabList!=0 );  pParse->colNamesSet = 1;  fullName = (db->flags & SQLITE_FullColNames)!=0;  srcName = (db->flags & SQLITE_ShortColNames)!=0 || fullName;  sqlite3VdbeSetNumCols(v, pEList->nExpr);  for(i=0; i<pEList->nExpr; i++){  Expr *p = pEList->a[i].pExpr;  assert( p!=0 );  assert( p->op!=TK_AGG_COLUMN );  assert( p->op!=TK_COLUMN  || (ExprUseYTab(p) && p->y.pTab!=0) );  if( pEList->a[i].zEName && pEList->a[i].eEName==ENAME_NAME ){  char *zName = pEList->a[i].zEName;  sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);  }else if( srcName && p->op==TK_COLUMN ){  char *zCol;  int iCol = p->iColumn;  pTab = p->y.pTab;  assert( pTab!=0 );  if( iCol<0 ) iCol = pTab->iPKey;  assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );  if( iCol<0 ){  zCol = "rowid";  }else{  zCol = pTab->aCol[iCol].zCnName;  }  if( fullName ){  char *zName = 0;  zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);  sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);  }else{  sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);  }  }else{  const char *z = pEList->a[i].zEName;  z = z==0 ? sqlite3MPrintf(db, "column%d", i+1) : sqlite3DbStrDup(db, z);  sqlite3VdbeSetColName(v, i, COLNAME_NAME, z, SQLITE_DYNAMIC);  }  }  generateColumnTypes(pParse, pTabList, pEList); } SQLITE_PRIVATE int sqlite3ColumnsFromExprList(  Parse *pParse,  ExprList *pEList,  i16 *pnCol,  Column **paCol ){  sqlite3 *db = pParse->db;  int i, j;  u32 cnt;  Column *aCol, *pCol;  int nCol;  char *zName;  int nName;  Hash ht;  Table *pTab;  sqlite3HashInit(&ht);  if( pEList ){  nCol = pEList->nExpr;  aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);  testcase( aCol==0 );  if( NEVER(nCol>32767) ) nCol = 32767;  }else{  nCol = 0;  aCol = 0;  }  assert( nCol==(i16)nCol );  *pnCol = nCol;  *paCol = aCol;  for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){  if( (zName = pEList->a[i].zEName)!=0 && pEList->a[i].eEName==ENAME_NAME ){  }else{  Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);  while( ALWAYS(pColExpr!=0) && pColExpr->op==TK_DOT ){  pColExpr = pColExpr->pRight;  assert( pColExpr!=0 );  }  if( pColExpr->op==TK_COLUMN   && ALWAYS( ExprUseYTab(pColExpr) )   && (pTab = pColExpr->y.pTab)!=0  ){  int iCol = pColExpr->iColumn;  if( iCol<0 ) iCol = pTab->iPKey;  zName = iCol>=0 ? pTab->aCol[iCol].zCnName : "rowid";  }else if( pColExpr->op==TK_ID ){  assert( !ExprHasProperty(pColExpr, EP_IntValue) );  zName = pColExpr->u.zToken;  }else{  zName = pEList->a[i].zEName;  }  }  if( zName && !sqlite3IsTrueOrFalse(zName) ){  zName = sqlite3DbStrDup(db, zName);  }else{  zName = sqlite3MPrintf(db,"column%d",i+1);  }  cnt = 0;  while( zName && sqlite3HashFind(&ht, zName)!=0 ){  nName = sqlite3Strlen30(zName);  if( nName>0 ){  for(j=nName-1; j>0 && sqlite3Isdigit(zName[j]); j--){}  if( zName[j]==':' ) nName = j;  }  zName = sqlite3MPrintf(db, "%.*z:%u", nName, zName, ++cnt);  if( cnt>3 ) sqlite3_randomness(sizeof(cnt), &cnt);  }  pCol->zCnName = zName;  pCol->hName = sqlite3StrIHash(zName);  sqlite3ColumnPropertiesFromName(0, pCol);  if( zName && sqlite3HashInsert(&ht, zName, pCol)==pCol ){  sqlite3OomFault(db);  }  }  sqlite3HashClear(&ht);  if( db->mallocFailed ){  for(j=0; j<i; j++){  sqlite3DbFree(db, aCol[j].zCnName);  }  sqlite3DbFree(db, aCol);  *paCol = 0;  *pnCol = 0;  return SQLITE_NOMEM_BKPT;  }  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(  Parse *pParse,  Table *pTab,  Select *pSelect,  char aff ){  sqlite3 *db = pParse->db;  NameContext sNC;  Column *pCol;  CollSeq *pColl;  int i;  Expr *p;  struct ExprList_item *a;  assert( pSelect!=0 );  assert( (pSelect->selFlags & SF_Resolved)!=0 );  assert( pTab->nCol==pSelect->pEList->nExpr || db->mallocFailed );  if( db->mallocFailed ) return;  memset(&sNC, 0, sizeof(sNC));  sNC.pSrcList = pSelect->pSrc;  a = pSelect->pEList->a;  for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){  const char *zType;  i64 n, m;  pTab->tabFlags |= (pCol->colFlags & COLFLAG_NOINSERT);  p = a[i].pExpr;  zType = columnType(&sNC, p, 0, 0, 0);  pCol->affinity = sqlite3ExprAffinity(p);  if( zType ){  m = sqlite3Strlen30(zType);  n = sqlite3Strlen30(pCol->zCnName);  pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, n+m+2);  if( pCol->zCnName ){  memcpy(&pCol->zCnName[n+1], zType, m+1);  pCol->colFlags |= COLFLAG_HASTYPE;  }else{  testcase( pCol->colFlags & COLFLAG_HASTYPE );  pCol->colFlags &= ~(COLFLAG_HASTYPE|COLFLAG_HASCOLL);  }  }  if( pCol->affinity<=SQLITE_AFF_NONE ) pCol->affinity = aff;  pColl = sqlite3ExprCollSeq(pParse, p);  if( pColl ){  assert( pTab->pIndex==0 );  sqlite3ColumnSetColl(db, pCol, pColl->zName);  }  }  pTab->szTabRow = 1; } SQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){  Table *pTab;  sqlite3 *db = pParse->db;  u64 savedFlags;  savedFlags = db->flags;  db->flags &= ~(u64)SQLITE_FullColNames;  db->flags |= SQLITE_ShortColNames;  sqlite3SelectPrep(pParse, pSelect, 0);  db->flags = savedFlags;  if( pParse->nErr ) return 0;  while( pSelect->pPrior ) pSelect = pSelect->pPrior;  pTab = sqlite3DbMallocZero(db, sizeof(Table) );  if( pTab==0 ){  return 0;  }  pTab->nTabRef = 1;  pTab->zName = 0;  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);  pTab->iPKey = -1;  if( db->mallocFailed ){  sqlite3DeleteTable(db, pTab);  return 0;  }  return pTab; } SQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse *pParse){  if( pParse->pVdbe ){  return pParse->pVdbe;  }  if( pParse->pToplevel==0   && OptimizationEnabled(pParse->db,SQLITE_FactorOutConst)  ){  pParse->okConstFactor = 1;  }  return sqlite3VdbeCreate(pParse); } static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){  Vdbe *v = 0;  int iLimit = 0;  int iOffset;  int n;  Expr *pLimit = p->pLimit;  if( p->iLimit ) return;  if( pLimit ){  assert( pLimit->op==TK_LIMIT );  assert( pLimit->pLeft!=0 );  p->iLimit = iLimit = ++pParse->nMem;  v = sqlite3GetVdbe(pParse);  assert( v!=0 );  if( sqlite3ExprIsInteger(pLimit->pLeft, &n) ){  sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);  VdbeComment((v, "LIMIT counter"));  if( n==0 ){  sqlite3VdbeGoto(v, iBreak);  }else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){  p->nSelectRow = sqlite3LogEst((u64)n);  p->selFlags |= SF_FixedLimit;  }  }else{  sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);  sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);  VdbeComment((v, "LIMIT counter"));  sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);  }  if( pLimit->pRight ){  p->iOffset = iOffset = ++pParse->nMem;  pParse->nMem++;  sqlite3ExprCode(pParse, pLimit->pRight, iOffset);  sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);  VdbeComment((v, "OFFSET counter"));  sqlite3VdbeAddOp3(v, OP_OffsetLimit, iLimit, iOffset+1, iOffset);  VdbeComment((v, "LIMIT+OFFSET"));  }  } }
#ifndef SQLITE_OMIT_COMPOUND_SELECT
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){  CollSeq *pRet;  if( p->pPrior ){  pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);  }else{  pRet = 0;  }  assert( iCol>=0 );  if( pRet==0 && ALWAYS(iCol<p->pEList->nExpr) ){  pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);  }  return pRet; } static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){  ExprList *pOrderBy = p->pOrderBy;  int nOrderBy = ALWAYS(pOrderBy!=0) ? pOrderBy->nExpr : 0;  sqlite3 *db = pParse->db;  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);  if( pRet ){  int i;  for(i=0; i<nOrderBy; i++){  struct ExprList_item *pItem = &pOrderBy->a[i];  Expr *pTerm = pItem->pExpr;  CollSeq *pColl;  if( pTerm->flags & EP_Collate ){  pColl = sqlite3ExprCollSeq(pParse, pTerm);  }else{  pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);  if( pColl==0 ) pColl = db->pDfltColl;  pOrderBy->a[i].pExpr =  sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);  }  assert( sqlite3KeyInfoIsWriteable(pRet) );  pRet->aColl[i] = pColl;  pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;  }  }  return pRet; }
#ifndef SQLITE_OMIT_CTE
static void generateWithRecursiveQuery(  Parse *pParse,  Select *p,  SelectDest *pDest ){  SrcList *pSrc = p->pSrc;  int nCol = p->pEList->nExpr;  Vdbe *v = pParse->pVdbe;  Select *pSetup;  Select *pFirstRec;  int addrTop;  int addrCont, addrBreak;  int iCurrent = 0;  int regCurrent;  int iQueue;  int iDistinct = 0;  int eDest = SRT_Fifo;  SelectDest destQueue;  int i;  int rc;  ExprList *pOrderBy;  Expr *pLimit;  int regLimit, regOffset;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( p->pWin ){  sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");  return;  }
#endif
 if( sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0) ) return;  addrBreak = sqlite3VdbeMakeLabel(pParse);  p->nSelectRow = 320;  computeLimitRegisters(pParse, p, addrBreak);  pLimit = p->pLimit;  regLimit = p->iLimit;  regOffset = p->iOffset;  p->pLimit = 0;  p->iLimit = p->iOffset = 0;  pOrderBy = p->pOrderBy;  for(i=0; ALWAYS(i<pSrc->nSrc); i++){  if( pSrc->a[i].fg.isRecursive ){  iCurrent = pSrc->a[i].iCursor;  break;  }  }  iQueue = pParse->nTab++;  if( p->op==TK_UNION ){  eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;  iDistinct = pParse->nTab++;  }else{  eDest = pOrderBy ? SRT_Queue : SRT_Fifo;  }  sqlite3SelectDestInit(&destQueue, eDest, iQueue);  regCurrent = ++pParse->nMem;  sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);  if( pOrderBy ){  KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);  sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr+2, 0,  (char*)pKeyInfo, P4_KEYINFO);  destQueue.pOrderBy = pOrderBy;  }else{  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);  }  VdbeComment((v, "Queue table"));  if( iDistinct ){  p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);  p->selFlags |= SF_UsesEphemeral;  }  p->pOrderBy = 0;  for(pFirstRec=p; ALWAYS(pFirstRec!=0); pFirstRec=pFirstRec->pPrior){  if( pFirstRec->selFlags & SF_Aggregate ){  sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");  goto end_of_recursive_query;  }  pFirstRec->op = TK_ALL;  if( (pFirstRec->pPrior->selFlags & SF_Recursive)==0 ) break;  }  pSetup = pFirstRec->pPrior;  pSetup->pNext = 0;  ExplainQueryPlan((pParse, 1, "SETUP"));  rc = sqlite3Select(pParse, pSetup, &destQueue);  pSetup->pNext = p;  if( rc ) goto end_of_recursive_query;  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);  sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent);  if( pOrderBy ){  sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr+1, regCurrent);  }else{  sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);  }  sqlite3VdbeAddOp1(v, OP_Delete, iQueue);  addrCont = sqlite3VdbeMakeLabel(pParse);  codeOffset(v, regOffset, addrCont);  selectInnerLoop(pParse, p, iCurrent,  0, 0, pDest, addrCont, addrBreak);  if( regLimit ){  sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);  VdbeCoverage(v);  }  sqlite3VdbeResolveLabel(v, addrCont);  pFirstRec->pPrior = 0;  ExplainQueryPlan((pParse, 1, "RECURSIVE STEP"));  sqlite3Select(pParse, p, &destQueue);  assert( pFirstRec->pPrior==0 );  pFirstRec->pPrior = pSetup;  sqlite3VdbeGoto(v, addrTop);  sqlite3VdbeResolveLabel(v, addrBreak); end_of_recursive_query:  sqlite3ExprListDelete(pParse->db, p->pOrderBy);  p->pOrderBy = pOrderBy;  p->pLimit = pLimit;  return; }
#endif
static int multiSelectOrderBy(  Parse *pParse,  Select *p,  SelectDest *pDest ); static int multiSelectValues(  Parse *pParse,  Select *p,  SelectDest *pDest ){  int nRow = 1;  int rc = 0;  int bShowAll = p->pLimit==0;  assert( p->selFlags & SF_MultiValue );  do{  assert( p->selFlags & SF_Values );  assert( p->op==TK_ALL || (p->op==TK_SELECT && p->pPrior==0) );  assert( p->pNext==0 || p->pEList->nExpr==p->pNext->pEList->nExpr );
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( p->pWin ) return -1;
#endif
 if( p->pPrior==0 ) break;  assert( p->pPrior->pNext==p );  p = p->pPrior;  nRow += bShowAll;  }while(1);  ExplainQueryPlan((pParse, 0, "SCAN %d CONSTANT ROW%s", nRow,  nRow==1 ? "" : "S"));  while( p ){  selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);  if( !bShowAll ) break;  p->nSelectRow = nRow;  p = p->pNext;  }  return rc; } static int hasAnchor(Select *p){  while( p && (p->selFlags & SF_Recursive)!=0 ){ p = p->pPrior; }  return p!=0; } static int multiSelect(  Parse *pParse,  Select *p,  SelectDest *pDest ){  int rc = SQLITE_OK;  Select *pPrior;  Vdbe *v;  SelectDest dest;  Select *pDelete = 0;  sqlite3 *db;  assert( p && p->pPrior );  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );  assert( p->selFlags & SF_Compound );  db = pParse->db;  pPrior = p->pPrior;  dest = *pDest;  assert( pPrior->pOrderBy==0 );  assert( pPrior->pLimit==0 );  v = sqlite3GetVdbe(pParse);  assert( v!=0 );  if( dest.eDest==SRT_EphemTab ){  assert( p->pEList );  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);  dest.eDest = SRT_Table;  }  if( p->selFlags & SF_MultiValue ){  rc = multiSelectValues(pParse, p, &dest);  if( rc>=0 ) goto multi_select_end;  rc = SQLITE_OK;  }  assert( p->pEList && pPrior->pEList );  assert( p->pEList->nExpr==pPrior->pEList->nExpr );
#ifndef SQLITE_OMIT_CTE
 if( (p->selFlags & SF_Recursive)!=0 && hasAnchor(p) ){  generateWithRecursiveQuery(pParse, p, &dest);  }else
#endif
 if( p->pOrderBy ){  return multiSelectOrderBy(pParse, p, pDest);  }else{
#ifndef SQLITE_OMIT_EXPLAIN
 if( pPrior->pPrior==0 ){  ExplainQueryPlan((pParse, 1, "COMPOUND QUERY"));  ExplainQueryPlan((pParse, 1, "LEFT-MOST SUBQUERY"));  }
#endif
 switch( p->op ){  case TK_ALL: {  int addr = 0;  int nLimit = 0;  assert( !pPrior->pLimit );  pPrior->iLimit = p->iLimit;  pPrior->iOffset = p->iOffset;  pPrior->pLimit = p->pLimit;  SELECTTRACE(1, pParse, p, ("multiSelect UNION ALL left...\n"));  rc = sqlite3Select(pParse, pPrior, &dest);  pPrior->pLimit = 0;  if( rc ){  goto multi_select_end;  }  p->pPrior = 0;  p->iLimit = pPrior->iLimit;  p->iOffset = pPrior->iOffset;  if( p->iLimit ){  addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);  VdbeComment((v, "Jump ahead if LIMIT reached"));  if( p->iOffset ){  sqlite3VdbeAddOp3(v, OP_OffsetLimit,  p->iLimit, p->iOffset+1, p->iOffset);  }  }  ExplainQueryPlan((pParse, 1, "UNION ALL"));  SELECTTRACE(1, pParse, p, ("multiSelect UNION ALL right...\n"));  rc = sqlite3Select(pParse, p, &dest);  testcase( rc!=SQLITE_OK );  pDelete = p->pPrior;  p->pPrior = pPrior;  p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);  if( p->pLimit   && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit)   && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)  ){  p->nSelectRow = sqlite3LogEst((u64)nLimit);  }  if( addr ){  sqlite3VdbeJumpHere(v, addr);  }  break;  }  case TK_EXCEPT:  case TK_UNION: {  int unionTab;  u8 op = 0;  int priorOp;  Expr *pLimit;  int addr;  SelectDest uniondest;  testcase( p->op==TK_EXCEPT );  testcase( p->op==TK_UNION );  priorOp = SRT_Union;  if( dest.eDest==priorOp ){  assert( p->pLimit==0 );  unionTab = dest.iSDParm;  }else{  unionTab = pParse->nTab++;  assert( p->pOrderBy==0 );  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);  assert( p->addrOpenEphm[0] == -1 );  p->addrOpenEphm[0] = addr;  findRightmost(p)->selFlags |= SF_UsesEphemeral;  assert( p->pEList );  }  assert( !pPrior->pOrderBy );  sqlite3SelectDestInit(&uniondest, priorOp, unionTab);  SELECTTRACE(1, pParse, p, ("multiSelect EXCEPT/UNION left...\n"));  rc = sqlite3Select(pParse, pPrior, &uniondest);  if( rc ){  goto multi_select_end;  }  if( p->op==TK_EXCEPT ){  op = SRT_Except;  }else{  assert( p->op==TK_UNION );  op = SRT_Union;  }  p->pPrior = 0;  pLimit = p->pLimit;  p->pLimit = 0;  uniondest.eDest = op;  ExplainQueryPlan((pParse, 1, "%s USING TEMP B-TREE",  sqlite3SelectOpName(p->op)));  SELECTTRACE(1, pParse, p, ("multiSelect EXCEPT/UNION right...\n"));  rc = sqlite3Select(pParse, p, &uniondest);  testcase( rc!=SQLITE_OK );  assert( p->pOrderBy==0 );  pDelete = p->pPrior;  p->pPrior = pPrior;  p->pOrderBy = 0;  if( p->op==TK_UNION ){  p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);  }  sqlite3ExprDelete(db, p->pLimit);  p->pLimit = pLimit;  p->iLimit = 0;  p->iOffset = 0;  assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );  assert( p->pEList || db->mallocFailed );  if( dest.eDest!=priorOp && db->mallocFailed==0 ){  int iCont, iBreak, iStart;  iBreak = sqlite3VdbeMakeLabel(pParse);  iCont = sqlite3VdbeMakeLabel(pParse);  computeLimitRegisters(pParse, p, iBreak);  sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);  iStart = sqlite3VdbeCurrentAddr(v);  selectInnerLoop(pParse, p, unionTab,  0, 0, &dest, iCont, iBreak);  sqlite3VdbeResolveLabel(v, iCont);  sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);  sqlite3VdbeResolveLabel(v, iBreak);  sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);  }  break;  }  default: assert( p->op==TK_INTERSECT ); {  int tab1, tab2;  int iCont, iBreak, iStart;  Expr *pLimit;  int addr;  SelectDest intersectdest;  int r1;  tab1 = pParse->nTab++;  tab2 = pParse->nTab++;  assert( p->pOrderBy==0 );  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);  assert( p->addrOpenEphm[0] == -1 );  p->addrOpenEphm[0] = addr;  findRightmost(p)->selFlags |= SF_UsesEphemeral;  assert( p->pEList );  sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);  SELECTTRACE(1, pParse, p, ("multiSelect INTERSECT left...\n"));  rc = sqlite3Select(pParse, pPrior, &intersectdest);  if( rc ){  goto multi_select_end;  }  addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);  assert( p->addrOpenEphm[1] == -1 );  p->addrOpenEphm[1] = addr;  p->pPrior = 0;  pLimit = p->pLimit;  p->pLimit = 0;  intersectdest.iSDParm = tab2;  ExplainQueryPlan((pParse, 1, "%s USING TEMP B-TREE",  sqlite3SelectOpName(p->op)));  SELECTTRACE(1, pParse, p, ("multiSelect INTERSECT right...\n"));  rc = sqlite3Select(pParse, p, &intersectdest);  testcase( rc!=SQLITE_OK );  pDelete = p->pPrior;  p->pPrior = pPrior;  if( p->nSelectRow>pPrior->nSelectRow ){  p->nSelectRow = pPrior->nSelectRow;  }  sqlite3ExprDelete(db, p->pLimit);  p->pLimit = pLimit;  if( rc ) break;  assert( p->pEList );  iBreak = sqlite3VdbeMakeLabel(pParse);  iCont = sqlite3VdbeMakeLabel(pParse);  computeLimitRegisters(pParse, p, iBreak);  sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);  r1 = sqlite3GetTempReg(pParse);  iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);  sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);  VdbeCoverage(v);  sqlite3ReleaseTempReg(pParse, r1);  selectInnerLoop(pParse, p, tab1,  0, 0, &dest, iCont, iBreak);  sqlite3VdbeResolveLabel(v, iCont);  sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);  sqlite3VdbeResolveLabel(v, iBreak);  sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);  sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);  break;  }  }
 #ifndef SQLITE_OMIT_EXPLAIN
 if( p->pNext==0 ){  ExplainQueryPlanPop(pParse);  }
 #endif
 }  if( pParse->nErr ) goto multi_select_end;  if( p->selFlags & SF_UsesEphemeral ){  int i;  KeyInfo *pKeyInfo;  Select *pLoop;  CollSeq **apColl;  int nCol;  assert( p->pNext==0 );  assert( p->pEList!=0 );  nCol = p->pEList->nExpr;  pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);  if( !pKeyInfo ){  rc = SQLITE_NOMEM_BKPT;  goto multi_select_end;  }  for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){  *apColl = multiSelectCollSeq(pParse, p, i);  if( 0==*apColl ){  *apColl = db->pDfltColl;  }  }  for(pLoop=p; pLoop; pLoop=pLoop->pPrior){  for(i=0; i<2; i++){  int addr = pLoop->addrOpenEphm[i];  if( addr<0 ){  assert( pLoop->addrOpenEphm[1]<0 );  break;  }  sqlite3VdbeChangeP2(v, addr, nCol);  sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),  P4_KEYINFO);  pLoop->addrOpenEphm[i] = -1;  }  }  sqlite3KeyInfoUnref(pKeyInfo);  } multi_select_end:  pDest->iSdst = dest.iSdst;  pDest->nSdst = dest.nSdst;  if( pDelete ){  sqlite3ParserAddCleanup(pParse,  (void(*)(sqlite3*,void*))sqlite3SelectDelete,  pDelete);  }  return rc; }
#endif
SQLITE_PRIVATE void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){  if( p->selFlags & SF_Values ){  sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");  }else{  sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s"  " do not have the same number of result columns",  sqlite3SelectOpName(p->op));  } } static int generateOutputSubroutine(  Parse *pParse,  Select *p,  SelectDest *pIn,  SelectDest *pDest,  int regReturn,  int regPrev,  KeyInfo *pKeyInfo,  int iBreak ){  Vdbe *v = pParse->pVdbe;  int iContinue;  int addr;  addr = sqlite3VdbeCurrentAddr(v);  iContinue = sqlite3VdbeMakeLabel(pParse);  if( regPrev ){  int addr1, addr2;  addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);  addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,  (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);  sqlite3VdbeAddOp3(v, OP_Jump, addr2+2, iContinue, addr2+2); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr1);  sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev+1, pIn->nSdst-1);  sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);  }  if( pParse->db->mallocFailed ) return 0;  codeOffset(v, p->iOffset, iContinue);  assert( pDest->eDest!=SRT_Exists );  assert( pDest->eDest!=SRT_Table );  switch( pDest->eDest ){  case SRT_EphemTab: {  int r1 = sqlite3GetTempReg(pParse);  int r2 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, r1);  sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iSDParm, r2);  sqlite3VdbeAddOp3(v, OP_Insert, pDest->iSDParm, r1, r2);  sqlite3VdbeChangeP5(v, OPFLAG_APPEND);  sqlite3ReleaseTempReg(pParse, r2);  sqlite3ReleaseTempReg(pParse, r1);  break;  }
#ifndef SQLITE_OMIT_SUBQUERY
 case SRT_Set: {  int r1;  testcase( pIn->nSdst>1 );  r1 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst,  r1, pDest->zAffSdst, pIn->nSdst);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pDest->iSDParm, r1,   pIn->iSdst, pIn->nSdst);  sqlite3ReleaseTempReg(pParse, r1);  break;  }  case SRT_Mem: {  testcase( pIn->nSdst>1 );  sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);  break;  }
#endif
 case SRT_Coroutine: {  if( pDest->iSdst==0 ){  pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);  pDest->nSdst = pIn->nSdst;  }  sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);  sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);  break;  }  default: {  assert( pDest->eDest==SRT_Output );  sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iSdst, pIn->nSdst);  break;  }  }  if( p->iLimit ){  sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);  }  sqlite3VdbeResolveLabel(v, iContinue);  sqlite3VdbeAddOp1(v, OP_Return, regReturn);  return addr; }
#ifndef SQLITE_OMIT_COMPOUND_SELECT
static int multiSelectOrderBy(  Parse *pParse,  Select *p,  SelectDest *pDest ){  int i, j;  Select *pPrior;  Vdbe *v;  SelectDest destA;  SelectDest destB;  int regAddrA;  int regAddrB;  int addrSelectA;  int addrSelectB;  int regOutA;  int regOutB;  int addrOutA;  int addrOutB = 0;  int addrEofA;  int addrEofA_noB;  int addrEofB;  int addrAltB;  int addrAeqB;  int addrAgtB;  int regLimitA;  int regLimitB;  int regPrev;  int savedLimit;  int savedOffset;  int labelCmpr;  int labelEnd;  int addr1;  int op;  KeyInfo *pKeyDup = 0;  KeyInfo *pKeyMerge;  sqlite3 *db;  ExprList *pOrderBy;  int nOrderBy;  u32 *aPermute;  assert( p->pOrderBy!=0 );  assert( pKeyDup==0 );  db = pParse->db;  v = pParse->pVdbe;  assert( v!=0 );  labelEnd = sqlite3VdbeMakeLabel(pParse);  labelCmpr = sqlite3VdbeMakeLabel(pParse);  op = p->op;  pPrior = p->pPrior;  assert( pPrior->pOrderBy==0 );  pOrderBy = p->pOrderBy;  assert( pOrderBy );  nOrderBy = pOrderBy->nExpr;  if( op!=TK_ALL ){  for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){  struct ExprList_item *pItem;  for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){  assert( pItem!=0 );  assert( pItem->u.x.iOrderByCol>0 );  if( pItem->u.x.iOrderByCol==i ) break;  }  if( j==nOrderBy ){  Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);  if( pNew==0 ) return SQLITE_NOMEM_BKPT;  pNew->flags |= EP_IntValue;  pNew->u.iValue = i;  p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);  if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;  }  }  }  aPermute = sqlite3DbMallocRawNN(db, sizeof(u32)*(nOrderBy + 1));  if( aPermute ){  struct ExprList_item *pItem;  aPermute[0] = nOrderBy;  for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){  assert( pItem!=0 );  assert( pItem->u.x.iOrderByCol>0 );  assert( pItem->u.x.iOrderByCol<=p->pEList->nExpr );  aPermute[i] = pItem->u.x.iOrderByCol - 1;  }  pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);  }else{  pKeyMerge = 0;  }  p->pOrderBy = pOrderBy;  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);  if( op==TK_ALL ){  regPrev = 0;  }else{  int nExpr = p->pEList->nExpr;  assert( nOrderBy>=nExpr || db->mallocFailed );  regPrev = pParse->nMem+1;  pParse->nMem += nExpr+1;  sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);  pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);  if( pKeyDup ){  assert( sqlite3KeyInfoIsWriteable(pKeyDup) );  for(i=0; i<nExpr; i++){  pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);  pKeyDup->aSortFlags[i] = 0;  }  }  }  p->pPrior = 0;  pPrior->pNext = 0;  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");  if( pPrior->pPrior==0 ){  sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");  }  computeLimitRegisters(pParse, p, labelEnd);  if( p->iLimit && op==TK_ALL ){  regLimitA = ++pParse->nMem;  regLimitB = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit,  regLimitA);  sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);  }else{  regLimitA = regLimitB = 0;  }  sqlite3ExprDelete(db, p->pLimit);  p->pLimit = 0;  regAddrA = ++pParse->nMem;  regAddrB = ++pParse->nMem;  regOutA = ++pParse->nMem;  regOutB = ++pParse->nMem;  sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);  sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);  ExplainQueryPlan((pParse, 1, "MERGE (%s)", sqlite3SelectOpName(p->op)));  addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);  VdbeComment((v, "left SELECT"));  pPrior->iLimit = regLimitA;  ExplainQueryPlan((pParse, 1, "LEFT"));  sqlite3Select(pParse, pPrior, &destA);  sqlite3VdbeEndCoroutine(v, regAddrA);  sqlite3VdbeJumpHere(v, addr1);  addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);  VdbeComment((v, "right SELECT"));  savedLimit = p->iLimit;  savedOffset = p->iOffset;  p->iLimit = regLimitB;  p->iOffset = 0;  ExplainQueryPlan((pParse, 1, "RIGHT"));  sqlite3Select(pParse, p, &destB);  p->iLimit = savedLimit;  p->iOffset = savedOffset;  sqlite3VdbeEndCoroutine(v, regAddrB);  VdbeNoopComment((v, "Output routine for A"));  addrOutA = generateOutputSubroutine(pParse,   p, &destA, pDest, regOutA,   regPrev, pKeyDup, labelEnd);  if( op==TK_ALL || op==TK_UNION ){  VdbeNoopComment((v, "Output routine for B"));  addrOutB = generateOutputSubroutine(pParse,   p, &destB, pDest, regOutB,   regPrev, pKeyDup, labelEnd);  }  sqlite3KeyInfoUnref(pKeyDup);  if( op==TK_EXCEPT || op==TK_INTERSECT ){  addrEofA_noB = addrEofA = labelEnd;  }else{  VdbeNoopComment((v, "eof-A subroutine"));  addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);  addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);   VdbeCoverage(v);  sqlite3VdbeGoto(v, addrEofA);  p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);  }  if( op==TK_INTERSECT ){  addrEofB = addrEofA;  if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;  }else{  VdbeNoopComment((v, "eof-B subroutine"));  addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);  sqlite3VdbeGoto(v, addrEofB);  }  VdbeNoopComment((v, "A-lt-B subroutine"));  addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);  sqlite3VdbeGoto(v, labelCmpr);  if( op==TK_ALL ){  addrAeqB = addrAltB;  }else if( op==TK_INTERSECT ){  addrAeqB = addrAltB;  addrAltB++;  }else{  VdbeNoopComment((v, "A-eq-B subroutine"));  addrAeqB =  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);  sqlite3VdbeGoto(v, labelCmpr);  }  VdbeNoopComment((v, "A-gt-B subroutine"));  addrAgtB = sqlite3VdbeCurrentAddr(v);  if( op==TK_ALL || op==TK_UNION ){  sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);  }  sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);  sqlite3VdbeGoto(v, labelCmpr);  sqlite3VdbeJumpHere(v, addr1);  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);  sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);  sqlite3VdbeResolveLabel(v, labelCmpr);  sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);  sqlite3VdbeAddOp4(v, OP_Compare, destA.iSdst, destB.iSdst, nOrderBy,   (char*)pKeyMerge, P4_KEYINFO);  sqlite3VdbeChangeP5(v, OPFLAG_PERMUTE);  sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); VdbeCoverage(v);  sqlite3VdbeResolveLabel(v, labelEnd);  if( p->pPrior ){  sqlite3SelectDelete(db, p->pPrior);  }  p->pPrior = pPrior;  pPrior->pNext = p;  sqlite3ExprListDelete(db, pPrior->pOrderBy);  pPrior->pOrderBy = 0;  ExplainQueryPlanPop(pParse);  return pParse->nErr!=0; }
#endif
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
typedef struct SubstContext {  Parse *pParse;  int iTable;  int iNewTable;  int isLeftJoin;  ExprList *pEList; } SubstContext; static void substExprList(SubstContext*, ExprList*); static void substSelect(SubstContext*, Select*, int); static Expr *substExpr(  SubstContext *pSubst,  Expr *pExpr ){  if( pExpr==0 ) return 0;  if( ExprHasProperty(pExpr, EP_FromJoin)   && pExpr->iRightJoinTable==pSubst->iTable  ){  pExpr->iRightJoinTable = pSubst->iNewTable;  }  if( pExpr->op==TK_COLUMN   && pExpr->iTable==pSubst->iTable   && !ExprHasProperty(pExpr, EP_FixedCol)  ){
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
 if( pExpr->iColumn<0 ){  pExpr->op = TK_NULL;  }else
#endif
 {  Expr *pNew;  Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;  Expr ifNullRow;  assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );  assert( pExpr->pRight==0 );  if( sqlite3ExprIsVector(pCopy) ){  sqlite3VectorErrorMsg(pSubst->pParse, pCopy);  }else{  sqlite3 *db = pSubst->pParse->db;  if( pSubst->isLeftJoin && pCopy->op!=TK_COLUMN ){  memset(&ifNullRow, 0, sizeof(ifNullRow));  ifNullRow.op = TK_IF_NULL_ROW;  ifNullRow.pLeft = pCopy;  ifNullRow.iTable = pSubst->iNewTable;  ifNullRow.flags = EP_IfNullRow;  pCopy = &ifNullRow;  }  testcase( ExprHasProperty(pCopy, EP_Subquery) );  pNew = sqlite3ExprDup(db, pCopy, 0);  if( db->mallocFailed ){  sqlite3ExprDelete(db, pNew);  return pExpr;  }  if( pSubst->isLeftJoin ){  ExprSetProperty(pNew, EP_CanBeNull);  }  if( ExprHasProperty(pExpr,EP_FromJoin) ){  sqlite3SetJoinExpr(pNew, pExpr->iRightJoinTable);  }  sqlite3ExprDelete(db, pExpr);  pExpr = pNew;  if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){  CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);  pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,  (pColl ? pColl->zName : "BINARY")  );  }  ExprClearProperty(pExpr, EP_Collate);  }  }  }else{  if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){  pExpr->iTable = pSubst->iNewTable;  }  pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);  pExpr->pRight = substExpr(pSubst, pExpr->pRight);  if( ExprUseXSelect(pExpr) ){  substSelect(pSubst, pExpr->x.pSelect, 1);  }else{  substExprList(pSubst, pExpr->x.pList);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( ExprHasProperty(pExpr, EP_WinFunc) ){  Window *pWin = pExpr->y.pWin;  pWin->pFilter = substExpr(pSubst, pWin->pFilter);  substExprList(pSubst, pWin->pPartition);  substExprList(pSubst, pWin->pOrderBy);  }
#endif
 }  return pExpr; } static void substExprList(  SubstContext *pSubst,  ExprList *pList ){  int i;  if( pList==0 ) return;  for(i=0; i<pList->nExpr; i++){  pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);  } } static void substSelect(  SubstContext *pSubst,  Select *p,  int doPrior ){  SrcList *pSrc;  SrcItem *pItem;  int i;  if( !p ) return;  do{  substExprList(pSubst, p->pEList);  substExprList(pSubst, p->pGroupBy);  substExprList(pSubst, p->pOrderBy);  p->pHaving = substExpr(pSubst, p->pHaving);  p->pWhere = substExpr(pSubst, p->pWhere);  pSrc = p->pSrc;  assert( pSrc!=0 );  for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){  substSelect(pSubst, pItem->pSelect, 1);  if( pItem->fg.isTabFunc ){  substExprList(pSubst, pItem->u1.pFuncArg);  }  }  }while( doPrior && (p = p->pPrior)!=0 ); }
#endif
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
static int recomputeColumnsUsedExpr(Walker *pWalker, Expr *pExpr){  SrcItem *pItem;  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;  pItem = pWalker->u.pSrcItem;  if( pItem->iCursor!=pExpr->iTable ) return WRC_Continue;  if( pExpr->iColumn<0 ) return WRC_Continue;  pItem->colUsed |= sqlite3ExprColUsed(pExpr);  return WRC_Continue; } static void recomputeColumnsUsed(  Select *pSelect,  SrcItem *pSrcItem ){  Walker w;  if( NEVER(pSrcItem->pTab==0) ) return;  memset(&w, 0, sizeof(w));  w.xExprCallback = recomputeColumnsUsedExpr;  w.xSelectCallback = sqlite3SelectWalkNoop;  w.u.pSrcItem = pSrcItem;  pSrcItem->colUsed = 0;  sqlite3WalkSelect(&w, pSelect); }
#endif
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
static void srclistRenumberCursors(  Parse *pParse,  int *aCsrMap,  SrcList *pSrc,  int iExcept ){  int i;  SrcItem *pItem;  for(i=0, pItem=pSrc->a; i<pSrc->nSrc; i++, pItem++){  if( i!=iExcept ){  Select *p;  assert( pItem->iCursor < aCsrMap[0] );  if( !pItem->fg.isRecursive || aCsrMap[pItem->iCursor+1]==0 ){  aCsrMap[pItem->iCursor+1] = pParse->nTab++;  }  pItem->iCursor = aCsrMap[pItem->iCursor+1];  for(p=pItem->pSelect; p; p=p->pPrior){  srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);  }  }  } } static void renumberCursorDoMapping(Walker *pWalker, int *piCursor){  int *aCsrMap = pWalker->u.aiCol;  int iCsr = *piCursor;  if( iCsr < aCsrMap[0] && aCsrMap[iCsr+1]>0 ){  *piCursor = aCsrMap[iCsr+1];  } } static int renumberCursorsCb(Walker *pWalker, Expr *pExpr){  int op = pExpr->op;  if( op==TK_COLUMN || op==TK_IF_NULL_ROW ){  renumberCursorDoMapping(pWalker, &pExpr->iTable);  }  if( ExprHasProperty(pExpr, EP_FromJoin) ){  renumberCursorDoMapping(pWalker, &pExpr->iRightJoinTable);  }  return WRC_Continue; } static void renumberCursors(  Parse *pParse,  Select *p,  int iExcept,  int *aCsrMap ){  Walker w;  srclistRenumberCursors(pParse, aCsrMap, p->pSrc, iExcept);  memset(&w, 0, sizeof(w));  w.u.aiCol = aCsrMap;  w.xExprCallback = renumberCursorsCb;  w.xSelectCallback = sqlite3SelectWalkNoop;  sqlite3WalkSelect(&w, p); }
#endif
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
static int flattenSubquery(  Parse *pParse,  Select *p,  int iFrom,  int isAgg ){  const char *zSavedAuthContext = pParse->zAuthContext;  Select *pParent;  Select *pSub;  Select *pSub1;  SrcList *pSrc;  SrcList *pSubSrc;  int iParent;  int iNewParent = -1;  int isLeftJoin = 0;  int i;  Expr *pWhere;  SrcItem *pSubitem;  sqlite3 *db = pParse->db;  Walker w;  int *aCsrMap = 0;  assert( p!=0 );  assert( p->pPrior==0 );  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;  pSrc = p->pSrc;  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );  pSubitem = &pSrc->a[iFrom];  iParent = pSubitem->iCursor;  pSub = pSubitem->pSelect;  assert( pSub!=0 );
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( p->pWin || pSub->pWin ) return 0;
#endif
 pSubSrc = pSub->pSrc;  assert( pSubSrc );  if( pSub->pLimit && p->pLimit ) return 0;  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){  return 0;  }  if( pSubSrc->nSrc==0 ) return 0;  if( pSub->selFlags & SF_Distinct ) return 0;  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){   return 0;  }  if( p->pOrderBy && pSub->pOrderBy ){   return 0;  }  if( isAgg && pSub->pOrderBy ) return 0;  if( pSub->pLimit && p->pWhere ) return 0;  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){   return 0;  }  if( pSub->selFlags & (SF_Recursive) ){  return 0;  }  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){  isLeftJoin = 1;  if( pSubSrc->nSrc>1   || isAgg   || IsVirtual(pSubSrc->a[0].pTab)   || (p->selFlags & SF_Distinct)!=0  ){  return 0;  }  }
#ifdef SQLITE_EXTRA_IFNULLROW
 else if( iFrom>0 && !isAgg ){  isLeftJoin = -1;  }
#endif
 if( pSub->pPrior ){  if( pSub->pOrderBy ){  return 0;  }  if( isAgg || (p->selFlags & SF_Distinct)!=0 || isLeftJoin>0 ){  return 0;  }  for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){  testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );  testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );  assert( pSub->pSrc!=0 );  assert( (pSub->selFlags & SF_Recursive)==0 );  assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );  if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0   || (pSub1->pPrior && pSub1->op!=TK_ALL)   || pSub1->pSrc->nSrc<1
#ifndef SQLITE_OMIT_WINDOWFUNC
  || pSub1->pWin
#endif
 ){  return 0;  }  testcase( pSub1->pSrc->nSrc>1 );  }  if( p->pOrderBy ){  int ii;  for(ii=0; ii<p->pOrderBy->nExpr; ii++){  if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;  }  }  if( (p->selFlags & SF_Recursive) ) return 0;  if( pSrc->nSrc>1 ){  if( pParse->nSelect>500 ) return 0;  aCsrMap = sqlite3DbMallocZero(db, ((i64)pParse->nTab+1)*sizeof(int));  if( aCsrMap ) aCsrMap[0] = pParse->nTab;  }  }  SELECTTRACE(1,pParse,p,("flatten %u.%p from term %d\n",   pSub->selId, pSub, iFrom));  pParse->zAuthContext = pSubitem->zName;  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);  testcase( i==SQLITE_DENY );  pParse->zAuthContext = zSavedAuthContext;  pSub1 = pSubitem->pSelect;  sqlite3DbFree(db, pSubitem->zDatabase);  sqlite3DbFree(db, pSubitem->zName);  sqlite3DbFree(db, pSubitem->zAlias);  pSubitem->zDatabase = 0;  pSubitem->zName = 0;  pSubitem->zAlias = 0;  pSubitem->pSelect = 0;  assert( pSubitem->pOn==0 );  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){  Select *pNew;  ExprList *pOrderBy = p->pOrderBy;  Expr *pLimit = p->pLimit;  Select *pPrior = p->pPrior;  Table *pItemTab = pSubitem->pTab;  pSubitem->pTab = 0;  p->pOrderBy = 0;  p->pPrior = 0;  p->pLimit = 0;  pNew = sqlite3SelectDup(db, p, 0);  p->pLimit = pLimit;  p->pOrderBy = pOrderBy;  p->op = TK_ALL;  pSubitem->pTab = pItemTab;  if( pNew==0 ){  p->pPrior = pPrior;  }else{  pNew->selId = ++pParse->nSelect;  if( aCsrMap && ALWAYS(db->mallocFailed==0) ){  renumberCursors(pParse, pNew, iFrom, aCsrMap);  }  pNew->pPrior = pPrior;  if( pPrior ) pPrior->pNext = pNew;  pNew->pNext = p;  p->pPrior = pNew;  SELECTTRACE(2,pParse,p,("compound-subquery flattener"  " creates %u as peer\n",pNew->selId));  }  assert( pSubitem->pSelect==0 );  }  sqlite3DbFree(db, aCsrMap);  if( db->mallocFailed ){  pSubitem->pSelect = pSub1;  return 1;  }  if( ALWAYS(pSubitem->pTab!=0) ){  Table *pTabToDel = pSubitem->pTab;  if( pTabToDel->nTabRef==1 ){  Parse *pToplevel = sqlite3ParseToplevel(pParse);  sqlite3ParserAddCleanup(pToplevel,   (void(*)(sqlite3*,void*))sqlite3DeleteTable,   pTabToDel);  testcase( pToplevel->earlyCleanup );  }else{  pTabToDel->nTabRef--;  }  pSubitem->pTab = 0;  }  pSub = pSub1;  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){  int nSubSrc;  u8 jointype = 0;  assert( pSub!=0 );  pSubSrc = pSub->pSrc;  nSubSrc = pSubSrc->nSrc;  pSrc = pParent->pSrc;  if( pParent==p ){  jointype = pSubitem->fg.jointype;  }  if( nSubSrc>1 ){  pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);  if( pSrc==0 ) break;  pParent->pSrc = pSrc;  }  for(i=0; i<nSubSrc; i++){  sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);  assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );  pSrc->a[i+iFrom] = pSubSrc->a[i];  iNewParent = pSubSrc->a[i].iCursor;  memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));  }  pSrc->a[iFrom].fg.jointype = jointype;  if( pSub->pOrderBy && (pParent->selFlags & SF_NoopOrderBy)==0 ){  ExprList *pOrderBy = pSub->pOrderBy;  for(i=0; i<pOrderBy->nExpr; i++){  pOrderBy->a[i].u.x.iOrderByCol = 0;  }  assert( pParent->pOrderBy==0 );  pParent->pOrderBy = pOrderBy;  pSub->pOrderBy = 0;  }  pWhere = pSub->pWhere;  pSub->pWhere = 0;  if( isLeftJoin>0 ){  sqlite3SetJoinExpr(pWhere, iNewParent);  }  if( pWhere ){  if( pParent->pWhere ){  pParent->pWhere = sqlite3PExpr(pParse, TK_AND, pWhere, pParent->pWhere);  }else{  pParent->pWhere = pWhere;  }  }  if( db->mallocFailed==0 ){  SubstContext x;  x.pParse = pParse;  x.iTable = iParent;  x.iNewTable = iNewParent;  x.isLeftJoin = isLeftJoin;  x.pEList = pSub->pEList;  substSelect(&x, pParent, 0);  }  pParent->selFlags |= pSub->selFlags & SF_Compound;  assert( (pSub->selFlags & SF_Distinct)==0 );  if( pSub->pLimit ){  pParent->pLimit = pSub->pLimit;  pSub->pLimit = 0;  }  for(i=0; i<nSubSrc; i++){  recomputeColumnsUsed(pParent, &pSrc->a[i+iFrom]);  }  }  sqlite3AggInfoPersistWalkerInit(&w, pParse);  sqlite3WalkSelect(&w,pSub1);  sqlite3SelectDelete(db, pSub1);
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x100 ){  SELECTTRACE(0x100,pParse,p,("After flattening:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 return 1; }
#endif
typedef struct WhereConst WhereConst; struct WhereConst {  Parse *pParse;  u8 *pOomFault;  int nConst;  int nChng;  int bHasAffBlob;  Expr **apExpr; }; static void constInsert(  WhereConst *pConst,  Expr *pColumn,  Expr *pValue,  Expr *pExpr ){  int i;  assert( pColumn->op==TK_COLUMN );  assert( sqlite3ExprIsConstant(pValue) );  if( ExprHasProperty(pColumn, EP_FixedCol) ) return;  if( sqlite3ExprAffinity(pValue)!=0 ) return;  if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr)) ){  return;  }  for(i=0; i<pConst->nConst; i++){  const Expr *pE2 = pConst->apExpr[i*2];  assert( pE2->op==TK_COLUMN );  if( pE2->iTable==pColumn->iTable   && pE2->iColumn==pColumn->iColumn  ){  return;  }  }  if( sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){  pConst->bHasAffBlob = 1;  }  pConst->nConst++;  pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,   pConst->nConst*2*sizeof(Expr*));  if( pConst->apExpr==0 ){  pConst->nConst = 0;  }else{  pConst->apExpr[pConst->nConst*2-2] = pColumn;  pConst->apExpr[pConst->nConst*2-1] = pValue;  } } static void findConstInWhere(WhereConst *pConst, Expr *pExpr){  Expr *pRight, *pLeft;  if( NEVER(pExpr==0) ) return;  if( ExprHasProperty(pExpr, EP_FromJoin) ) return;  if( pExpr->op==TK_AND ){  findConstInWhere(pConst, pExpr->pRight);  findConstInWhere(pConst, pExpr->pLeft);  return;  }  if( pExpr->op!=TK_EQ ) return;  pRight = pExpr->pRight;  pLeft = pExpr->pLeft;  assert( pRight!=0 );  assert( pLeft!=0 );  if( pRight->op==TK_COLUMN && sqlite3ExprIsConstant(pLeft) ){  constInsert(pConst,pRight,pLeft,pExpr);  }  if( pLeft->op==TK_COLUMN && sqlite3ExprIsConstant(pRight) ){  constInsert(pConst,pLeft,pRight,pExpr);  } } static int propagateConstantExprRewriteOne(  WhereConst *pConst,  Expr *pExpr,  int bIgnoreAffBlob ){  int i;  if( pConst->pOomFault[0] ) return WRC_Prune;  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;  if( ExprHasProperty(pExpr, EP_FixedCol|EP_FromJoin) ){  testcase( ExprHasProperty(pExpr, EP_FixedCol) );  testcase( ExprHasProperty(pExpr, EP_FromJoin) );  return WRC_Continue;  }  for(i=0; i<pConst->nConst; i++){  Expr *pColumn = pConst->apExpr[i*2];  if( pColumn==pExpr ) continue;  if( pColumn->iTable!=pExpr->iTable ) continue;  if( pColumn->iColumn!=pExpr->iColumn ) continue;  if( bIgnoreAffBlob && sqlite3ExprAffinity(pColumn)==SQLITE_AFF_BLOB ){  break;  }  pConst->nChng++;  ExprClearProperty(pExpr, EP_Leaf);  ExprSetProperty(pExpr, EP_FixedCol);  assert( pExpr->pLeft==0 );  pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);  if( pConst->pParse->db->mallocFailed ) return WRC_Prune;  break;  }  return WRC_Prune; } static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){  WhereConst *pConst = pWalker->u.pConst;  assert( TK_GT==TK_EQ+1 );  assert( TK_LE==TK_EQ+2 );  assert( TK_LT==TK_EQ+3 );  assert( TK_GE==TK_EQ+4 );  if( pConst->bHasAffBlob ){  if( (pExpr->op>=TK_EQ && pExpr->op<=TK_GE)   || pExpr->op==TK_IS  ){  propagateConstantExprRewriteOne(pConst, pExpr->pLeft, 0);  if( pConst->pOomFault[0] ) return WRC_Prune;  if( sqlite3ExprAffinity(pExpr->pLeft)!=SQLITE_AFF_TEXT ){  propagateConstantExprRewriteOne(pConst, pExpr->pRight, 0);  }  }  }  return propagateConstantExprRewriteOne(pConst, pExpr, pConst->bHasAffBlob); } static int propagateConstants(  Parse *pParse,  Select *p ){  WhereConst x;  Walker w;  int nChng = 0;  x.pParse = pParse;  x.pOomFault = &pParse->db->mallocFailed;  do{  x.nConst = 0;  x.nChng = 0;  x.apExpr = 0;  x.bHasAffBlob = 0;  findConstInWhere(&x, p->pWhere);  if( x.nConst ){  memset(&w, 0, sizeof(w));  w.pParse = pParse;  w.xExprCallback = propagateConstantExprRewrite;  w.xSelectCallback = sqlite3SelectWalkNoop;  w.xSelectCallback2 = 0;  w.walkerDepth = 0;  w.u.pConst = &x;  sqlite3WalkExpr(&w, p->pWhere);  sqlite3DbFree(x.pParse->db, x.apExpr);  nChng += x.nChng;  }  }while( x.nChng );  return nChng; }
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
# if !defined(SQLITE_OMIT_WINDOWFUNC)
static int pushDownWindowCheck(Parse *pParse, Select *pSubq, Expr *pExpr){  assert( pSubq->pWin->pPartition );  assert( (pSubq->selFlags & SF_MultiPart)==0 );  assert( pSubq->pPrior==0 );  return sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq->pWin->pPartition); }
# endif
#endif
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
static int pushDownWhereTerms(  Parse *pParse,  Select *pSubq,  Expr *pWhere,  int iCursor,  int isLeftJoin ){  Expr *pNew;  int nChng = 0;  if( pWhere==0 ) return 0;  if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ) return 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pSubq->pPrior ){  Select *pSel;  for(pSel=pSubq; pSel; pSel=pSel->pPrior){  if( pSel->pWin ) return 0;  }  }else{  if( pSubq->pWin && pSubq->pWin->pPartition==0 ) return 0;  }
#endif
#ifdef SQLITE_DEBUG
 {  Select *pX;  for(pX=pSubq; pX; pX=pX->pPrior){  assert( (pX->selFlags & (SF_Recursive))==0 );  }  }
#endif
 if( pSubq->pLimit!=0 ){  return 0;  }  while( pWhere->op==TK_AND ){  nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight,  iCursor, isLeftJoin);  pWhere = pWhere->pLeft;  }  if( isLeftJoin   && (ExprHasProperty(pWhere,EP_FromJoin)==0   || pWhere->iRightJoinTable!=iCursor)  ){  return 0;  }  if( ExprHasProperty(pWhere,EP_FromJoin) && pWhere->iRightJoinTable!=iCursor ){  return 0;  }  if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){  nChng++;  pSubq->selFlags |= SF_PushDown;  while( pSubq ){  SubstContext x;  pNew = sqlite3ExprDup(pParse->db, pWhere, 0);  unsetJoinExpr(pNew, -1);  x.pParse = pParse;  x.iTable = iCursor;  x.iNewTable = iCursor;  x.isLeftJoin = 0;  x.pEList = pSubq->pEList;  pNew = substExpr(&x, pNew);
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pSubq->pWin && 0==pushDownWindowCheck(pParse, pSubq, pNew) ){  sqlite3ExprDelete(pParse->db, pNew);  nChng--;  break;  }
#endif
 if( pSubq->selFlags & SF_Aggregate ){  pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);  }else{  pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);  }  pSubq = pSubq->pPrior;  }  }  return nChng; }
#endif
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){  int eRet = WHERE_ORDERBY_NORMAL;  ExprList *pEList;  const char *zFunc;  ExprList *pOrderBy;  u8 sortFlags = 0;  assert( *ppMinMax==0 );  assert( pFunc->op==TK_AGG_FUNCTION );  assert( !IsWindowFunc(pFunc) );  assert( ExprUseXList(pFunc) );  pEList = pFunc->x.pList;  if( pEList==0   || pEList->nExpr!=1   || ExprHasProperty(pFunc, EP_WinFunc)   || OptimizationDisabled(db, SQLITE_MinMaxOpt)  ){  return eRet;  }  assert( !ExprHasProperty(pFunc, EP_IntValue) );  zFunc = pFunc->u.zToken;  if( sqlite3StrICmp(zFunc, "min")==0 ){  eRet = WHERE_ORDERBY_MIN;  if( sqlite3ExprCanBeNull(pEList->a[0].pExpr) ){  sortFlags = KEYINFO_ORDER_BIGNULL;  }  }else if( sqlite3StrICmp(zFunc, "max")==0 ){  eRet = WHERE_ORDERBY_MAX;  sortFlags = KEYINFO_ORDER_DESC;  }else{  return eRet;  }  *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);  assert( pOrderBy!=0 || db->mallocFailed );  if( pOrderBy ) pOrderBy->a[0].sortFlags = sortFlags;  return eRet; } static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){  Table *pTab;  Expr *pExpr;  assert( !p->pGroupBy );  if( p->pWhere   || p->pEList->nExpr!=1   || p->pSrc->nSrc!=1   || p->pSrc->a[0].pSelect   || pAggInfo->nFunc!=1  ){  return 0;  }  pTab = p->pSrc->a[0].pTab;  assert( pTab!=0 );  assert( !IsView(pTab) );  if( !IsOrdinaryTable(pTab) ) return 0;  pExpr = p->pEList->a[0].pExpr;  assert( pExpr!=0 );  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;  if( pExpr->pAggInfo!=pAggInfo ) return 0;  if( (pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT)==0 ) return 0;  assert( pAggInfo->aFunc[0].pFExpr==pExpr );  testcase( ExprHasProperty(pExpr, EP_Distinct) );  testcase( ExprHasProperty(pExpr, EP_WinFunc) );  if( ExprHasProperty(pExpr, EP_Distinct|EP_WinFunc) ) return 0;  return pTab; } SQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, SrcItem *pFrom){  Table *pTab = pFrom->pTab;  char *zIndexedBy = pFrom->u1.zIndexedBy;  Index *pIdx;  assert( pTab!=0 );  assert( pFrom->fg.isIndexedBy!=0 );  for(pIdx=pTab->pIndex;  pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy);  pIdx=pIdx->pNext  );  if( !pIdx ){  sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, 0);  pParse->checkSchema = 1;  return SQLITE_ERROR;  }  assert( pFrom->fg.isCte==0 );  pFrom->u2.pIBIndex = pIdx;  return SQLITE_OK; } static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){  int i;  Select *pNew;  Select *pX;  sqlite3 *db;  struct ExprList_item *a;  SrcList *pNewSrc;  Parse *pParse;  Token dummy;  if( p->pPrior==0 ) return WRC_Continue;  if( p->pOrderBy==0 ) return WRC_Continue;  for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}  if( pX==0 ) return WRC_Continue;  a = p->pOrderBy->a;
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( a[0].u.x.iOrderByCol ) return WRC_Continue;
#endif
 for(i=p->pOrderBy->nExpr-1; i>=0; i--){  if( a[i].pExpr->flags & EP_Collate ) break;  }  if( i<0 ) return WRC_Continue;  pParse = pWalker->pParse;  db = pParse->db;  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );  if( pNew==0 ) return WRC_Abort;  memset(&dummy, 0, sizeof(dummy));  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);  if( pNewSrc==0 ) return WRC_Abort;  *pNew = *p;  p->pSrc = pNewSrc;  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));  p->op = TK_SELECT;  p->pWhere = 0;  pNew->pGroupBy = 0;  pNew->pHaving = 0;  pNew->pOrderBy = 0;  p->pPrior = 0;  p->pNext = 0;  p->pWith = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
 p->pWinDefn = 0;
#endif
 p->selFlags &= ~SF_Compound;  assert( (p->selFlags & SF_Converted)==0 );  p->selFlags |= SF_Converted;  assert( pNew->pPrior!=0 );  pNew->pPrior->pNext = pNew;  pNew->pLimit = 0;  return WRC_Continue; } static int cannotBeFunction(Parse *pParse, SrcItem *pFrom){  if( pFrom->fg.isTabFunc ){  sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom->zName);  return 1;  }  return 0; }
#ifndef SQLITE_OMIT_CTE
static struct Cte *searchWith(  With *pWith,  SrcItem *pItem,  With **ppContext ){  const char *zName = pItem->zName;  With *p;  assert( pItem->zDatabase==0 );  assert( zName!=0 );  for(p=pWith; p; p=p->pOuter){  int i;  for(i=0; i<p->nCte; i++){  if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){  *ppContext = p;  return &p->a[i];  }  }  if( p->bView ) break;  }  return 0; } SQLITE_PRIVATE With *sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){  if( pWith ){  if( bFree ){  pWith = (With*)sqlite3ParserAddCleanup(pParse,  (void(*)(sqlite3*,void*))sqlite3WithDelete,  pWith);  if( pWith==0 ) return 0;  }  if( pParse->nErr==0 ){  assert( pParse->pWith!=pWith );  pWith->pOuter = pParse->pWith;  pParse->pWith = pWith;  }  }  return pWith; } static int resolveFromTermToCte(  Parse *pParse,  Walker *pWalker,  SrcItem *pFrom ){  Cte *pCte;  With *pWith;  assert( pFrom->pTab==0 );  if( pParse->pWith==0 ){  return 0;  }  if( pParse->nErr ){  return 0;  }  if( pFrom->zDatabase!=0 ){  return 0;  }  if( pFrom->fg.notCte ){  return 0;  }  pCte = searchWith(pParse->pWith, pFrom, &pWith);  if( pCte ){  sqlite3 *db = pParse->db;  Table *pTab;  ExprList *pEList;  Select *pSel;  Select *pLeft;  Select *pRecTerm;  int bMayRecursive;  With *pSavedWith;  int iRecTab = -1;  CteUse *pCteUse;  if( pCte->zCteErr ){  sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);  return 2;  }  if( cannotBeFunction(pParse, pFrom) ) return 2;  assert( pFrom->pTab==0 );  pTab = sqlite3DbMallocZero(db, sizeof(Table));  if( pTab==0 ) return 2;  pCteUse = pCte->pUse;  if( pCteUse==0 ){  pCte->pUse = pCteUse = sqlite3DbMallocZero(db, sizeof(pCteUse[0]));  if( pCteUse==0   || sqlite3ParserAddCleanup(pParse,sqlite3DbFree,pCteUse)==0  ){  sqlite3DbFree(db, pTab);  return 2;  }  pCteUse->eM10d = pCte->eM10d;  }  pFrom->pTab = pTab;  pTab->nTabRef = 1;  pTab->zName = sqlite3DbStrDup(db, pCte->zName);  pTab->iPKey = -1;  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );  pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;  pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);  if( db->mallocFailed ) return 2;  pFrom->pSelect->selFlags |= SF_CopyCte;  assert( pFrom->pSelect );  if( pFrom->fg.isIndexedBy ){  sqlite3ErrorMsg(pParse, "no such index: \"%s\"", pFrom->u1.zIndexedBy);  return 2;  }  pFrom->fg.isCte = 1;  pFrom->u2.pCteUse = pCteUse;  pCteUse->nUse++;  if( pCteUse->nUse>=2 && pCteUse->eM10d==M10d_Any ){  pCteUse->eM10d = M10d_Yes;  }  pRecTerm = pSel = pFrom->pSelect;  bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );  while( bMayRecursive && pRecTerm->op==pSel->op ){  int i;  SrcList *pSrc = pRecTerm->pSrc;  assert( pRecTerm->pPrior!=0 );  for(i=0; i<pSrc->nSrc; i++){  SrcItem *pItem = &pSrc->a[i];  if( pItem->zDatabase==0   && pItem->zName!=0   && 0==sqlite3StrICmp(pItem->zName, pCte->zName)  ){  pItem->pTab = pTab;  pTab->nTabRef++;  pItem->fg.isRecursive = 1;  if( pRecTerm->selFlags & SF_Recursive ){  sqlite3ErrorMsg(pParse,   "multiple references to recursive table: %s", pCte->zName  );  return 2;  }  pRecTerm->selFlags |= SF_Recursive;  if( iRecTab<0 ) iRecTab = pParse->nTab++;  pItem->iCursor = iRecTab;  }  }  if( (pRecTerm->selFlags & SF_Recursive)==0 ) break;  pRecTerm = pRecTerm->pPrior;  }  pCte->zCteErr = "circular reference: %s";  pSavedWith = pParse->pWith;  pParse->pWith = pWith;  if( pSel->selFlags & SF_Recursive ){  int rc;  assert( pRecTerm!=0 );  assert( (pRecTerm->selFlags & SF_Recursive)==0 );  assert( pRecTerm->pNext!=0 );  assert( (pRecTerm->pNext->selFlags & SF_Recursive)!=0 );  assert( pRecTerm->pWith==0 );  pRecTerm->pWith = pSel->pWith;  rc = sqlite3WalkSelect(pWalker, pRecTerm);  pRecTerm->pWith = 0;  if( rc ){  pParse->pWith = pSavedWith;  return 2;  }  }else{  if( sqlite3WalkSelect(pWalker, pSel) ){  pParse->pWith = pSavedWith;  return 2;  }  }  pParse->pWith = pWith;  for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);  pEList = pLeft->pEList;  if( pCte->pCols ){  if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){  sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",  pCte->zName, pEList->nExpr, pCte->pCols->nExpr  );  pParse->pWith = pSavedWith;  return 2;  }  pEList = pCte->pCols;  }  sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);  if( bMayRecursive ){  if( pSel->selFlags & SF_Recursive ){  pCte->zCteErr = "multiple recursive references: %s";  }else{  pCte->zCteErr = "recursive reference in a subquery: %s";  }  sqlite3WalkSelect(pWalker, pSel);  }  pCte->zCteErr = 0;  pParse->pWith = pSavedWith;  return 1;  }  return 0; }
#endif
#ifndef SQLITE_OMIT_CTE
SQLITE_PRIVATE void sqlite3SelectPopWith(Walker *pWalker, Select *p){  Parse *pParse = pWalker->pParse;  if( OK_IF_ALWAYS_TRUE(pParse->pWith) && p->pPrior==0 ){  With *pWith = findRightmost(p)->pWith;  if( pWith!=0 ){  assert( pParse->pWith==pWith || pParse->nErr );  pParse->pWith = pWith->pOuter;  }  } }
#endif
SQLITE_PRIVATE int sqlite3ExpandSubquery(Parse *pParse, SrcItem *pFrom){  Select *pSel = pFrom->pSelect;  Table *pTab;  assert( pSel );  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));  if( pTab==0 ) return SQLITE_NOMEM;  pTab->nTabRef = 1;  if( pFrom->zAlias ){  pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);  }else{  pTab->zName = sqlite3MPrintf(pParse->db, "subquery_%u", pSel->selId);  }  while( pSel->pPrior ){ pSel = pSel->pPrior; }  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);  pTab->iPKey = -1;  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );
#ifndef SQLITE_ALLOW_ROWID_IN_VIEW
 pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;
#else
 pTab->tabFlags |= TF_Ephemeral;
#endif
 return pParse->nErr ? SQLITE_ERROR : SQLITE_OK; } static int selectExpander(Walker *pWalker, Select *p){  Parse *pParse = pWalker->pParse;  int i, j, k, rc;  SrcList *pTabList;  ExprList *pEList;  SrcItem *pFrom;  sqlite3 *db = pParse->db;  Expr *pE, *pRight, *pExpr;  u16 selFlags = p->selFlags;  u32 elistFlags = 0;  p->selFlags |= SF_Expanded;  if( db->mallocFailed ){  return WRC_Abort;  }  assert( p->pSrc!=0 );  if( (selFlags & SF_Expanded)!=0 ){  return WRC_Prune;  }  if( pWalker->eCode ){  p->selId = ++pParse->nSelect;  }  pTabList = p->pSrc;  pEList = p->pEList;  if( pParse->pWith && (p->selFlags & SF_View) ){  if( p->pWith==0 ){  p->pWith = (With*)sqlite3DbMallocZero(db, sizeof(With));  if( p->pWith==0 ){  return WRC_Abort;  }  }  p->pWith->bView = 1;  }  sqlite3WithPush(pParse, p->pWith, 0);  sqlite3SrcListAssignCursors(pParse, pTabList);  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){  Table *pTab;  assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );  if( pFrom->pTab ) continue;  assert( pFrom->fg.isRecursive==0 );  if( pFrom->zName==0 ){
#ifndef SQLITE_OMIT_SUBQUERY
 Select *pSel = pFrom->pSelect;  assert( pSel!=0 );  assert( pFrom->pTab==0 );  if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;  if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;
#endif
#ifndef SQLITE_OMIT_CTE
 }else if( (rc = resolveFromTermToCte(pParse, pWalker, pFrom))!=0 ){  if( rc>1 ) return WRC_Abort;  pTab = pFrom->pTab;  assert( pTab!=0 );
#endif
 }else{  assert( pFrom->pTab==0 );  pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);  if( pTab==0 ) return WRC_Abort;  if( pTab->nTabRef>=0xffff ){  sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535",   pTab->zName);  pFrom->pTab = 0;  return WRC_Abort;  }  pTab->nTabRef++;  if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){  return WRC_Abort;  }
#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)
 if( !IsOrdinaryTable(pTab) ){  i16 nCol;  u8 eCodeOrig = pWalker->eCode;  if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;  assert( pFrom->pSelect==0 );  if( IsView(pTab) ){  if( (db->flags & SQLITE_EnableView)==0   && pTab->pSchema!=db->aDb[1].pSchema  ){  sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited",  pTab->zName);  }  pFrom->pSelect = sqlite3SelectDup(db, pTab->u.view.pSelect, 0);  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 else if( ALWAYS(IsVirtual(pTab))   && pFrom->fg.fromDDL   && ALWAYS(pTab->u.vtab.p!=0)   && pTab->u.vtab.p->eVtabRisk > ((db->flags & SQLITE_TrustedSchema)!=0)  ){  sqlite3ErrorMsg(pParse, "unsafe use of virtual table \"%s\"",  pTab->zName);  }  assert( SQLITE_VTABRISK_Normal==1 && SQLITE_VTABRISK_High==2 );
#endif
 nCol = pTab->nCol;  pTab->nCol = -1;  pWalker->eCode = 1;  sqlite3WalkSelect(pWalker, pFrom->pSelect);  pWalker->eCode = eCodeOrig;  pTab->nCol = nCol;  }
#endif
 }  if( pFrom->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pFrom) ){  return WRC_Abort;  }  }  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){  return WRC_Abort;  }  for(k=0; k<pEList->nExpr; k++){  pE = pEList->a[k].pExpr;  if( pE->op==TK_ASTERISK ) break;  assert( pE->op!=TK_DOT || pE->pRight!=0 );  assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );  if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;  elistFlags |= pE->flags;  }  if( k<pEList->nExpr ){  struct ExprList_item *a = pEList->a;  ExprList *pNew = 0;  int flags = pParse->db->flags;  int longNames = (flags & SQLITE_FullColNames)!=0  && (flags & SQLITE_ShortColNames)==0;  for(k=0; k<pEList->nExpr; k++){  pE = a[k].pExpr;  elistFlags |= pE->flags;  pRight = pE->pRight;  assert( pE->op!=TK_DOT || pRight!=0 );  if( pE->op!=TK_ASTERISK   && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)  ){  pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);  if( pNew ){  pNew->a[pNew->nExpr-1].zEName = a[k].zEName;  pNew->a[pNew->nExpr-1].eEName = a[k].eEName;  a[k].zEName = 0;  }  a[k].pExpr = 0;  }else{  int tableSeen = 0;  char *zTName = 0;  if( pE->op==TK_DOT ){  assert( pE->pLeft!=0 );  assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );  zTName = pE->pLeft->u.zToken;  }  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){  Table *pTab = pFrom->pTab;  Select *pSub = pFrom->pSelect;  char *zTabName = pFrom->zAlias;  const char *zSchemaName = 0;  int iDb;  if( zTabName==0 ){  zTabName = pTab->zName;  }  if( db->mallocFailed ) break;  if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){  pSub = 0;  if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){  continue;  }  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : "*";  }  for(j=0; j<pTab->nCol; j++){  char *zName = pTab->aCol[j].zCnName;  char *zColname;  char *zToFree;  Token sColname;  assert( zName );  if( zTName && pSub   && sqlite3MatchEName(&pSub->pEList->a[j], 0, zTName, 0)==0  ){  continue;  }  if( (p->selFlags & SF_IncludeHidden)==0   && IsHiddenColumn(&pTab->aCol[j])  ){  continue;  }  tableSeen = 1;  if( i>0 && zTName==0 ){  if( (pFrom->fg.jointype & JT_NATURAL)!=0  && tableAndColumnIndex(pTabList, i, zName, 0, 0, 1)  ){  continue;  }  if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){  continue;  }  }  pRight = sqlite3Expr(db, TK_ID, zName);  zColname = zName;  zToFree = 0;  if( longNames || pTabList->nSrc>1 ){  Expr *pLeft;  pLeft = sqlite3Expr(db, TK_ID, zTabName);  pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);  if( zSchemaName ){  pLeft = sqlite3Expr(db, TK_ID, zSchemaName);  pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);  }  if( longNames ){  zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);  zToFree = zColname;  }  }else{  pExpr = pRight;  }  pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);  sqlite3TokenInit(&sColname, zColname);  sqlite3ExprListSetName(pParse, pNew, &sColname, 0);  if( pNew && (p->selFlags & SF_NestedFrom)!=0 && !IN_RENAME_OBJECT ){  struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];  sqlite3DbFree(db, pX->zEName);  if( pSub ){  pX->zEName = sqlite3DbStrDup(db, pSub->pEList->a[j].zEName);  testcase( pX->zEName==0 );  }else{  pX->zEName = sqlite3MPrintf(db, "%s.%s.%s",   zSchemaName, zTabName, zColname);  testcase( pX->zEName==0 );  }  pX->eEName = ENAME_TAB;  }  sqlite3DbFree(db, zToFree);  }  }  if( !tableSeen ){  if( zTName ){  sqlite3ErrorMsg(pParse, "no such table: %s", zTName);  }else{  sqlite3ErrorMsg(pParse, "no tables specified");  }  }  }  }  sqlite3ExprListDelete(db, pEList);  p->pEList = pNew;  }  if( p->pEList ){  if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){  sqlite3ErrorMsg(pParse, "too many columns in result set");  return WRC_Abort;  }  if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){  p->selFlags |= SF_ComplexResult;  }  }  return WRC_Continue; }
#if SQLITE_DEBUG
SQLITE_PRIVATE void sqlite3SelectWalkAssert2(Walker *NotUsed, Select *NotUsed2){  UNUSED_PARAMETER2(NotUsed, NotUsed2);  assert( 0 ); }
#endif
static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){  Walker w;  w.xExprCallback = sqlite3ExprWalkNoop;  w.pParse = pParse;  if( OK_IF_ALWAYS_TRUE(pParse->hasCompound) ){  w.xSelectCallback = convertCompoundSelectToSubquery;  w.xSelectCallback2 = 0;  sqlite3WalkSelect(&w, pSelect);  }  w.xSelectCallback = selectExpander;  w.xSelectCallback2 = sqlite3SelectPopWith;  w.eCode = 0;  sqlite3WalkSelect(&w, pSelect); }
#ifndef SQLITE_OMIT_SUBQUERY
static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){  Parse *pParse;  int i;  SrcList *pTabList;  SrcItem *pFrom;  assert( p->selFlags & SF_Resolved );  if( p->selFlags & SF_HasTypeInfo ) return;  p->selFlags |= SF_HasTypeInfo;  pParse = pWalker->pParse;  pTabList = p->pSrc;  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){  Table *pTab = pFrom->pTab;  assert( pTab!=0 );  if( (pTab->tabFlags & TF_Ephemeral)!=0 ){  Select *pSel = pFrom->pSelect;  if( pSel ){  while( pSel->pPrior ) pSel = pSel->pPrior;  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,   SQLITE_AFF_NONE);  }  }  } }
#endif
static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){
#ifndef SQLITE_OMIT_SUBQUERY
 Walker w;  w.xSelectCallback = sqlite3SelectWalkNoop;  w.xSelectCallback2 = selectAddSubqueryTypeInfo;  w.xExprCallback = sqlite3ExprWalkNoop;  w.pParse = pParse;  sqlite3WalkSelect(&w, pSelect);
#endif
} SQLITE_PRIVATE void sqlite3SelectPrep(  Parse *pParse,  Select *p,  NameContext *pOuterNC ){  assert( p!=0 || pParse->db->mallocFailed );  if( pParse->db->mallocFailed ) return;  if( p->selFlags & SF_HasTypeInfo ) return;  sqlite3SelectExpand(pParse, p);  if( pParse->nErr || pParse->db->mallocFailed ) return;  sqlite3ResolveSelectNames(pParse, p, pOuterNC);  if( pParse->nErr || pParse->db->mallocFailed ) return;  sqlite3SelectAddTypeInfo(pParse, p); } static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){  Vdbe *v = pParse->pVdbe;  int i;  struct AggInfo_func *pFunc;  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;  if( nReg==0 ) return;  if( pParse->nErr || pParse->db->mallocFailed ) return;
#ifdef SQLITE_DEBUG
 assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );  for(i=0; i<pAggInfo->nColumn; i++){  assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg   && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );  }  for(i=0; i<pAggInfo->nFunc; i++){  assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg   && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );  }
#endif
 sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){  if( pFunc->iDistinct>=0 ){  Expr *pE = pFunc->pFExpr;  assert( ExprUseXList(pE) );  if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){  sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "   "argument");  pFunc->iDistinct = -1;  }else{  KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);  pFunc->iDistAddr = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,  pFunc->iDistinct, 0, 0, (char*)pKeyInfo, P4_KEYINFO);  ExplainQueryPlan((pParse, 0, "USE TEMP B-TREE FOR %s(DISTINCT)",  pFunc->pFunc->zName));  }  }  } } static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){  Vdbe *v = pParse->pVdbe;  int i;  struct AggInfo_func *pF;  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){  ExprList *pList;  assert( ExprUseXList(pF->pFExpr) );  pList = pF->pFExpr->x.pList;  sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);  sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);  } } static void updateAccumulator(  Parse *pParse,  int regAcc,  AggInfo *pAggInfo,  int eDistinctType ){  Vdbe *v = pParse->pVdbe;  int i;  int regHit = 0;  int addrHitTest = 0;  struct AggInfo_func *pF;  struct AggInfo_col *pC;  pAggInfo->directMode = 1;  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){  int nArg;  int addrNext = 0;  int regAgg;  ExprList *pList;  assert( ExprUseXList(pF->pFExpr) );  assert( !IsWindowFunc(pF->pFExpr) );  pList = pF->pFExpr->x.pList;  if( ExprHasProperty(pF->pFExpr, EP_WinFunc) ){  Expr *pFilter = pF->pFExpr->y.pWin->pFilter;  if( pAggInfo->nAccumulator   && (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)   && regAcc  ){  if( regHit==0 ) regHit = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Copy, regAcc, regHit);  }  addrNext = sqlite3VdbeMakeLabel(pParse);  sqlite3ExprIfFalse(pParse, pFilter, addrNext, SQLITE_JUMPIFNULL);  }  if( pList ){  nArg = pList->nExpr;  regAgg = sqlite3GetTempRange(pParse, nArg);  sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);  }else{  nArg = 0;  regAgg = 0;  }  if( pF->iDistinct>=0 && pList ){  if( addrNext==0 ){  addrNext = sqlite3VdbeMakeLabel(pParse);  }  pF->iDistinct = codeDistinct(pParse, eDistinctType,  pF->iDistinct, addrNext, pList, regAgg);  }  if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){  CollSeq *pColl = 0;  struct ExprList_item *pItem;  int j;  assert( pList!=0 );  for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){  pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);  }  if( !pColl ){  pColl = pParse->db->pDfltColl;  }  if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;  sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0, (char *)pColl, P4_COLLSEQ);  }  sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, pF->iMem);  sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);  sqlite3VdbeChangeP5(v, (u8)nArg);  sqlite3ReleaseTempRange(pParse, regAgg, nArg);  if( addrNext ){  sqlite3VdbeResolveLabel(v, addrNext);  }  }  if( regHit==0 && pAggInfo->nAccumulator ){  regHit = regAcc;  }  if( regHit ){  addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);  }  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){  sqlite3ExprCode(pParse, pC->pCExpr, pC->iMem);  }  pAggInfo->directMode = 0;  if( addrHitTest ){  sqlite3VdbeJumpHereOrPopInst(v, addrHitTest);  } }
#ifndef SQLITE_OMIT_EXPLAIN
static void explainSimpleCount(  Parse *pParse,  Table *pTab,  Index *pIdx ){  if( pParse->explain==2 ){  int bCover = (pIdx!=0 && (HasRowid(pTab) || !IsPrimaryKeyIndex(pIdx)));  sqlite3VdbeExplain(pParse, 0, "SCAN %s%s%s",  pTab->zName,  bCover ? " USING COVERING INDEX " : "",  bCover ? pIdx->zName : ""  );  } }
#else
# define explainSimpleCount(a,b,c)
#endif
static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){  if( pExpr->op!=TK_AND ){  Select *pS = pWalker->u.pSelect;  if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy)   && ExprAlwaysFalse(pExpr)==0   && pExpr->pAggInfo==0  ){  sqlite3 *db = pWalker->pParse->db;  Expr *pNew = sqlite3Expr(db, TK_INTEGER, "1");  if( pNew ){  Expr *pWhere = pS->pWhere;  SWAP(Expr, *pNew, *pExpr);  pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);  pS->pWhere = pNew;  pWalker->eCode = 1;  }  }  return WRC_Prune;  }  return WRC_Continue; } static void havingToWhere(Parse *pParse, Select *p){  Walker sWalker;  memset(&sWalker, 0, sizeof(sWalker));  sWalker.pParse = pParse;  sWalker.xExprCallback = havingToWhereExprCb;  sWalker.u.pSelect = p;  sqlite3WalkExpr(&sWalker, p->pHaving);
#if SELECTTRACE_ENABLED
 if( sWalker.eCode && (sqlite3SelectTrace & 0x100)!=0 ){  SELECTTRACE(0x100,pParse,p,("Move HAVING terms into WHERE:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
} static SrcItem *isSelfJoinView(  SrcList *pTabList,  SrcItem *pThis ){  SrcItem *pItem;  assert( pThis->pSelect!=0 );  if( pThis->pSelect->selFlags & SF_PushDown ) return 0;  for(pItem = pTabList->a; pItem<pThis; pItem++){  Select *pS1;  if( pItem->pSelect==0 ) continue;  if( pItem->fg.viaCoroutine ) continue;  if( pItem->zName==0 ) continue;  assert( pItem->pTab!=0 );  assert( pThis->pTab!=0 );  if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) continue;  if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;  pS1 = pItem->pSelect;  if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){  continue;  }  if( pItem->pSelect->selFlags & SF_PushDown ){  continue;  }  return pItem;  }  return 0; } static void agginfoFree(sqlite3 *db, AggInfo *p){  sqlite3DbFree(db, p->aCol);  sqlite3DbFree(db, p->aFunc);  sqlite3DbFreeNN(db, p); }
#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
static int countOfViewOptimization(Parse *pParse, Select *p){  Select *pSub, *pPrior;  Expr *pExpr;  Expr *pCount;  sqlite3 *db;  if( (p->selFlags & SF_Aggregate)==0 ) return 0;  if( p->pEList->nExpr!=1 ) return 0;  if( p->pWhere ) return 0;  if( p->pGroupBy ) return 0;  pExpr = p->pEList->a[0].pExpr;  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;  assert( ExprUseUToken(pExpr) );  if( sqlite3_stricmp(pExpr->u.zToken,"count") ) return 0;  assert( ExprUseXList(pExpr) );  if( pExpr->x.pList!=0 ) return 0;  if( p->pSrc->nSrc!=1 ) return 0;  pSub = p->pSrc->a[0].pSelect;  if( pSub==0 ) return 0;  if( pSub->pPrior==0 ) return 0;  do{  if( pSub->op!=TK_ALL && pSub->pPrior ) return 0;  if( pSub->pWhere ) return 0;  if( pSub->pLimit ) return 0;  if( pSub->selFlags & SF_Aggregate ) return 0;  pSub = pSub->pPrior;  }while( pSub );  db = pParse->db;  pCount = pExpr;  pExpr = 0;  pSub = p->pSrc->a[0].pSelect;  p->pSrc->a[0].pSelect = 0;  sqlite3SrcListDelete(db, p->pSrc);  p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*p->pSrc));  while( pSub ){  Expr *pTerm;  pPrior = pSub->pPrior;  pSub->pPrior = 0;  pSub->pNext = 0;  pSub->selFlags |= SF_Aggregate;  pSub->selFlags &= ~SF_Compound;  pSub->nSelectRow = 0;  sqlite3ExprListDelete(db, pSub->pEList);  pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;  pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);  pTerm = sqlite3PExpr(pParse, TK_SELECT, 0, 0);  sqlite3PExprAddSelect(pParse, pTerm, pSub);  if( pExpr==0 ){  pExpr = pTerm;  }else{  pExpr = sqlite3PExpr(pParse, TK_PLUS, pTerm, pExpr);  }  pSub = pPrior;  }  p->pEList->a[0].pExpr = pExpr;  p->selFlags &= ~SF_Aggregate;
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x400 ){  SELECTTRACE(0x400,pParse,p,("After count-of-view optimization:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 return 1; }
#endif
SQLITE_PRIVATE int sqlite3Select(  Parse *pParse,  Select *p,  SelectDest *pDest ){  int i, j;  WhereInfo *pWInfo;  Vdbe *v;  int isAgg;  ExprList *pEList = 0;  SrcList *pTabList;  Expr *pWhere;  ExprList *pGroupBy;  Expr *pHaving;  AggInfo *pAggInfo = 0;  int rc = 1;  DistinctCtx sDistinct;  SortCtx sSort;  int iEnd;  sqlite3 *db;  ExprList *pMinMaxOrderBy = 0;  u8 minMaxFlag;  db = pParse->db;  v = sqlite3GetVdbe(pParse);  if( p==0 || db->mallocFailed || pParse->nErr ){  return 1;  }  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;
#if SELECTTRACE_ENABLED
 SELECTTRACE(1,pParse,p, ("begin processing:\n", pParse->addrExplain));  if( sqlite3SelectTrace & 0x100 ){  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );  if( IgnorableDistinct(pDest) ){  assert(pDest->eDest==SRT_Exists  || pDest->eDest==SRT_Union ||   pDest->eDest==SRT_Except  || pDest->eDest==SRT_Discard ||   pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_DistFifo );  if( p->pOrderBy ){
#if SELECTTRACE_ENABLED
 SELECTTRACE(1,pParse,p, ("dropping superfluous ORDER BY:\n"));  if( sqlite3SelectTrace & 0x100 ){  sqlite3TreeViewExprList(0, p->pOrderBy, 0, "ORDERBY");  }
#endif
 sqlite3ParserAddCleanup(pParse,  (void(*)(sqlite3*,void*))sqlite3ExprListDelete,  p->pOrderBy);  testcase( pParse->earlyCleanup );  p->pOrderBy = 0;  }  p->selFlags &= ~SF_Distinct;  p->selFlags |= SF_NoopOrderBy;  }  sqlite3SelectPrep(pParse, p, 0);  if( pParse->nErr || db->mallocFailed ){  goto select_end;  }  assert( p->pEList!=0 );
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x104 ){  SELECTTRACE(0x104,pParse,p, ("after name resolution:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 if( p->selFlags & SF_UFSrcCheck ){  SrcItem *p0 = &p->pSrc->a[0];  for(i=1; i<p->pSrc->nSrc; i++){  SrcItem *p1 = &p->pSrc->a[i];  if( p0->pTab==p1->pTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){  sqlite3ErrorMsg(pParse,  "target object/alias may not appear in FROM clause: %s",  p0->zAlias ? p0->zAlias : p0->pTab->zName  );  goto select_end;  }  }  p->selFlags &= ~SF_UFSrcCheck;  }  if( pDest->eDest==SRT_Output ){  sqlite3GenerateColumnNames(pParse, p);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( sqlite3WindowRewrite(pParse, p) ){  assert( db->mallocFailed || pParse->nErr>0 );  goto select_end;  }
#if SELECTTRACE_ENABLED
 if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){  SELECTTRACE(0x104,pParse,p, ("after window rewrite:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
#endif
 pTabList = p->pSrc;  isAgg = (p->selFlags & SF_Aggregate)!=0;  memset(&sSort, 0, sizeof(sSort));  sSort.pOrderBy = p->pOrderBy;
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
 for(i=0; !p->pPrior && i<pTabList->nSrc; i++){  SrcItem *pItem = &pTabList->a[i];  Select *pSub = pItem->pSelect;  Table *pTab = pItem->pTab;  assert( pTab!=0 );  if( (pItem->fg.jointype & JT_LEFT)!=0   && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)   && OptimizationEnabled(db, SQLITE_SimplifyJoin)  ){  SELECTTRACE(0x100,pParse,p,  ("LEFT-JOIN simplifies to JOIN on term %d\n",i));  pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);  unsetJoinExpr(p->pWhere, pItem->iCursor);  }  if( pSub==0 ) continue;  if( pTab->nCol!=pSub->pEList->nExpr ){  sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d",  pTab->nCol, pTab->zName, pSub->pEList->nExpr);  goto select_end;  }  if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;  assert( pSub->pGroupBy==0 );  if( pSub->pOrderBy!=0   && (p->pOrderBy!=0 || pTabList->nSrc>1)   && pSub->pLimit==0   && (pSub->selFlags & SF_OrderByReqd)==0   && (p->selFlags & SF_OrderByReqd)==0   && OptimizationEnabled(db, SQLITE_OmitOrderBy)  ){  SELECTTRACE(0x100,pParse,p,  ("omit superfluous ORDER BY on %r FROM-clause subquery\n",i+1));  sqlite3ExprListDelete(db, pSub->pOrderBy);  pSub->pOrderBy = 0;  }  if( pSub->pOrderBy!=0   && i==0   && (p->selFlags & SF_ComplexResult)!=0   && (pTabList->nSrc==1   || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  ){  continue;  }  if( flattenSubquery(pParse, p, i, isAgg) ){  if( pParse->nErr ) goto select_end;  i = -1;  }  pTabList = p->pSrc;  if( db->mallocFailed ) goto select_end;  if( !IgnorableOrderby(pDest) ){  sSort.pOrderBy = p->pOrderBy;  }  }
#endif
#ifndef SQLITE_OMIT_COMPOUND_SELECT
 if( p->pPrior ){  rc = multiSelect(pParse, p, pDest);
#if SELECTTRACE_ENABLED
 SELECTTRACE(0x1,pParse,p,("end compound-select processing\n"));  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 if( p->pNext==0 ) ExplainQueryPlanPop(pParse);  return rc;  }
#endif
 if( p->pWhere!=0   && p->pWhere->op==TK_AND   && OptimizationEnabled(db, SQLITE_PropagateConst)   && propagateConstants(pParse, p)  ){
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x100 ){  SELECTTRACE(0x100,pParse,p,("After constant propagation:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 }else{  SELECTTRACE(0x100,pParse,p,("Constant propagation not helpful\n"));  }
#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION
 if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)   && countOfViewOptimization(pParse, p)  ){  if( db->mallocFailed ) goto select_end;  pEList = p->pEList;  pTabList = p->pSrc;  }
#endif
 for(i=0; i<pTabList->nSrc; i++){  SrcItem *pItem = &pTabList->a[i];  SrcItem *pPrior;  SelectDest dest;  Select *pSub;
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
 const char *zSavedAuthContext;
#endif
 if( pItem->colUsed==0 && pItem->zName!=0 ){  sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, "", pItem->zDatabase);  }
#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
 pSub = pItem->pSelect;  if( pSub==0 ) continue;  assert( pItem->addrFillSub==0 );  pParse->nHeight += sqlite3SelectExprHeight(p);  if( OptimizationEnabled(db, SQLITE_PushDown)   && (pItem->fg.isCte==0   || (pItem->u2.pCteUse->eM10d!=M10d_Yes && pItem->u2.pCteUse->nUse<2))   && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,   (pItem->fg.jointype & JT_OUTER)!=0)  ){
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x100 ){  SELECTTRACE(0x100,pParse,p,  ("After WHERE-clause push-down into subquery %d:\n", pSub->selId));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 assert( pItem->pSelect && (pItem->pSelect->selFlags & SF_PushDown)!=0 );  }else{  SELECTTRACE(0x100,pParse,p,("Push-down not possible\n"));  }  zSavedAuthContext = pParse->zAuthContext;  pParse->zAuthContext = pItem->zName;  if( i==0   && (pTabList->nSrc==1  || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)   && (pItem->fg.isCte==0 || pItem->u2.pCteUse->eM10d!=M10d_Yes)  ){  int addrTop = sqlite3VdbeCurrentAddr(v)+1;  pItem->regReturn = ++pParse->nMem;  sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);  VdbeComment((v, "%!S", pItem));  pItem->addrFillSub = addrTop;  sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);  ExplainQueryPlan((pParse, 1, "CO-ROUTINE %!S", pItem));  sqlite3Select(pParse, pSub, &dest);  pItem->pTab->nRowLogEst = pSub->nSelectRow;  pItem->fg.viaCoroutine = 1;  pItem->regResult = dest.iSdst;  sqlite3VdbeEndCoroutine(v, pItem->regReturn);  sqlite3VdbeJumpHere(v, addrTop-1);  sqlite3ClearTempRegCache(pParse);  }else if( pItem->fg.isCte && pItem->u2.pCteUse->addrM9e>0 ){  CteUse *pCteUse = pItem->u2.pCteUse;  sqlite3VdbeAddOp2(v, OP_Gosub, pCteUse->regRtn, pCteUse->addrM9e);  if( pItem->iCursor!=pCteUse->iCur ){  sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pCteUse->iCur);  VdbeComment((v, "%!S", pItem));  }  pSub->nSelectRow = pCteUse->nRowEst;  }else if( (pPrior = isSelfJoinView(pTabList, pItem))!=0 ){  if( pPrior->addrFillSub ){  sqlite3VdbeAddOp2(v, OP_Gosub, pPrior->regReturn, pPrior->addrFillSub);  }  sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);  pSub->nSelectRow = pPrior->pSelect->nSelectRow;  }else{  int topAddr;  int onceAddr = 0;  int retAddr;  pItem->regReturn = ++pParse->nMem;  topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);  pItem->addrFillSub = topAddr+1;  if( pItem->fg.isCorrelated==0 ){  onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  VdbeComment((v, "materialize %!S", pItem));  }else{  VdbeNoopComment((v, "materialize %!S", pItem));  }  sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);  ExplainQueryPlan((pParse, 1, "MATERIALIZE %!S", pItem));  sqlite3Select(pParse, pSub, &dest);  pItem->pTab->nRowLogEst = pSub->nSelectRow;  if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);  retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);  VdbeComment((v, "end %!S", pItem));  sqlite3VdbeChangeP1(v, topAddr, retAddr);  sqlite3ClearTempRegCache(pParse);  if( pItem->fg.isCte && pItem->fg.isCorrelated==0 ){  CteUse *pCteUse = pItem->u2.pCteUse;  pCteUse->addrM9e = pItem->addrFillSub;  pCteUse->regRtn = pItem->regReturn;  pCteUse->iCur = pItem->iCursor;  pCteUse->nRowEst = pSub->nSelectRow;  }  }  if( db->mallocFailed ) goto select_end;  pParse->nHeight -= sqlite3SelectExprHeight(p);  pParse->zAuthContext = zSavedAuthContext;
#endif
 }  pEList = p->pEList;  pWhere = p->pWhere;  pGroupBy = p->pGroupBy;  pHaving = p->pHaving;  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x400 ){  SELECTTRACE(0x400,pParse,p,("After all FROM-clause analysis:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0
#ifndef SQLITE_OMIT_WINDOWFUNC
  && p->pWin==0
#endif
 ){  p->selFlags &= ~SF_Distinct;  pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);  p->selFlags |= SF_Aggregate;  assert( sDistinct.isTnct );
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x400 ){  SELECTTRACE(0x400,pParse,p,("Transform DISTINCT into GROUP BY:\n"));  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 }  if( sSort.pOrderBy ){  KeyInfo *pKeyInfo;  pKeyInfo = sqlite3KeyInfoFromExprList(  pParse, sSort.pOrderBy, 0, pEList->nExpr);  sSort.iECursor = pParse->nTab++;  sSort.addrSortIndex =  sqlite3VdbeAddOp4(v, OP_OpenEphemeral,  sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,  (char*)pKeyInfo, P4_KEYINFO  );  }else{  sSort.addrSortIndex = -1;  }  if( pDest->eDest==SRT_EphemTab ){  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);  }  iEnd = sqlite3VdbeMakeLabel(pParse);  if( (p->selFlags & SF_FixedLimit)==0 ){  p->nSelectRow = 320;  }  computeLimitRegisters(pParse, p, iEnd);  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){  sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);  sSort.sortFlags |= SORTFLAG_UseSorter;  }  if( p->selFlags & SF_Distinct ){  sDistinct.tabTnct = pParse->nTab++;  sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,   sDistinct.tabTnct, 0, 0,   (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),   P4_KEYINFO);  sqlite3VdbeChangeP5(v, BTREE_UNORDERED);  sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;  }else{  sDistinct.eTnctType = WHERE_DISTINCT_NOOP;  }  if( !isAgg && pGroupBy==0 ){  u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)   | (p->selFlags & SF_FixedLimit);
#ifndef SQLITE_OMIT_WINDOWFUNC
 Window *pWin = p->pWin;  if( pWin ){  sqlite3WindowCodeInit(pParse, p);  }
#endif
 assert( WHERE_USE_LIMIT==SF_FixedLimit );  SELECTTRACE(1,pParse,p,("WhereBegin\n"));  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,   p->pEList, wctrlFlags, p->nSelectRow);  if( pWInfo==0 ) goto select_end;  if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){  p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);  }  if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){  sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);  }  if( sSort.pOrderBy ){  sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);  sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);  if( sSort.nOBSat==sSort.pOrderBy->nExpr ){  sSort.pOrderBy = 0;  }  }  SELECTTRACE(1,pParse,p,("WhereBegin returns\n"));  if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){  sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);  }  assert( p->pEList==pEList );
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( pWin ){  int addrGosub = sqlite3VdbeMakeLabel(pParse);  int iCont = sqlite3VdbeMakeLabel(pParse);  int iBreak = sqlite3VdbeMakeLabel(pParse);  int regGosub = ++pParse->nMem;  sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);  sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);  sqlite3VdbeResolveLabel(v, addrGosub);  VdbeNoopComment((v, "inner-loop subroutine"));  sSort.labelOBLopt = 0;  selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);  sqlite3VdbeResolveLabel(v, iCont);  sqlite3VdbeAddOp1(v, OP_Return, regGosub);  VdbeComment((v, "end inner-loop subroutine"));  sqlite3VdbeResolveLabel(v, iBreak);  }else
#endif
 {  selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,  sqlite3WhereContinueLabel(pWInfo),  sqlite3WhereBreakLabel(pWInfo));  SELECTTRACE(1,pParse,p,("WhereEnd\n"));  sqlite3WhereEnd(pWInfo);  }  }else{  NameContext sNC;  int iAMem;  int iBMem;  int iUseFlag;  int iAbortFlag;  int groupBySort;  int addrEnd;  int sortPTab = 0;  int sortOut = 0;  int orderByGrp = 0;  if( pGroupBy ){  int k;  struct ExprList_item *pItem;  for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){  pItem->u.x.iAlias = 0;  }  for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){  pItem->u.x.iAlias = 0;  }  assert( 66==sqlite3LogEst(100) );  if( p->nSelectRow>66 ) p->nSelectRow = 66;  if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){  int ii;  for(ii=0; ii<pGroupBy->nExpr; ii++){  u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;  pGroupBy->a[ii].sortFlags = sortFlags;  }  if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){  orderByGrp = 1;  }  }  }else{  assert( 0==sqlite3LogEst(1) );  p->nSelectRow = 0;  }  addrEnd = sqlite3VdbeMakeLabel(pParse);  pAggInfo = sqlite3DbMallocZero(db, sizeof(*pAggInfo) );  if( pAggInfo ){  sqlite3ParserAddCleanup(pParse,  (void(*)(sqlite3*,void*))agginfoFree, pAggInfo);  testcase( pParse->earlyCleanup );  }  if( db->mallocFailed ){  goto select_end;  }  pAggInfo->selId = p->selId;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  sNC.pSrcList = pTabList;  sNC.uNC.pAggInfo = pAggInfo;  VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )  pAggInfo->mnReg = pParse->nMem+1;  pAggInfo->nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;  pAggInfo->pGroupBy = pGroupBy;  sqlite3ExprAnalyzeAggList(&sNC, pEList);  sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);  if( pHaving ){  if( pGroupBy ){  assert( pWhere==p->pWhere );  assert( pHaving==p->pHaving );  assert( pGroupBy==p->pGroupBy );  havingToWhere(pParse, p);  pWhere = p->pWhere;  }  sqlite3ExprAnalyzeAggregates(&sNC, pHaving);  }  pAggInfo->nAccumulator = pAggInfo->nColumn;  if( p->pGroupBy==0 && p->pHaving==0 && pAggInfo->nFunc==1 ){  minMaxFlag = minMaxQuery(db, pAggInfo->aFunc[0].pFExpr, &pMinMaxOrderBy);  }else{  minMaxFlag = WHERE_ORDERBY_NORMAL;  }  for(i=0; i<pAggInfo->nFunc; i++){  Expr *pExpr = pAggInfo->aFunc[i].pFExpr;  assert( ExprUseXList(pExpr) );  sNC.ncFlags |= NC_InAggFunc;  sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);
#ifndef SQLITE_OMIT_WINDOWFUNC
 assert( !IsWindowFunc(pExpr) );  if( ExprHasProperty(pExpr, EP_WinFunc) ){  sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);  }
#endif
 sNC.ncFlags &= ~NC_InAggFunc;  }  pAggInfo->mxReg = pParse->nMem;  if( db->mallocFailed ) goto select_end;
#if SELECTTRACE_ENABLED
 if( sqlite3SelectTrace & 0x400 ){  int ii;  SELECTTRACE(0x400,pParse,p,("After aggregate analysis %p:\n", pAggInfo));  sqlite3TreeViewSelect(0, p, 0);  if( minMaxFlag ){  sqlite3DebugPrintf("MIN/MAX Optimization (0x%02x) adds:\n", minMaxFlag);  sqlite3TreeViewExprList(0, pMinMaxOrderBy, 0, "ORDERBY");  }  for(ii=0; ii<pAggInfo->nColumn; ii++){  sqlite3DebugPrintf("agg-column[%d] iMem=%d\n",  ii, pAggInfo->aCol[ii].iMem);  sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pCExpr, 0);  }  for(ii=0; ii<pAggInfo->nFunc; ii++){  sqlite3DebugPrintf("agg-func[%d]: iMem=%d\n",  ii, pAggInfo->aFunc[ii].iMem);  sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pFExpr, 0);  }  }
#endif
 if( pGroupBy ){  KeyInfo *pKeyInfo;  int addr1;  int addrOutputRow;  int regOutputRow;  int addrSetAbort;  int addrTopOfLoop;  int addrSortingIdx;  int addrReset;  int regReset;  ExprList *pDistinct = 0;  u16 distFlag = 0;  int eDist = WHERE_DISTINCT_NOOP;  if( pAggInfo->nFunc==1   && pAggInfo->aFunc[0].iDistinct>=0   && ALWAYS(pAggInfo->aFunc[0].pFExpr!=0)   && ALWAYS(ExprUseXList(pAggInfo->aFunc[0].pFExpr))   && pAggInfo->aFunc[0].pFExpr->x.pList!=0  ){  Expr *pExpr = pAggInfo->aFunc[0].pFExpr->x.pList->a[0].pExpr;  pExpr = sqlite3ExprDup(db, pExpr, 0);  pDistinct = sqlite3ExprListDup(db, pGroupBy, 0);  pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr);  distFlag = pDistinct ? (WHERE_WANT_DISTINCT|WHERE_AGG_DISTINCT) : 0;  }  pAggInfo->sortingIdx = pParse->nTab++;  pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy,  0, pAggInfo->nColumn);  addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen,  pAggInfo->sortingIdx, pAggInfo->nSortingColumn,  0, (char*)pKeyInfo, P4_KEYINFO);  iUseFlag = ++pParse->nMem;  iAbortFlag = ++pParse->nMem;  regOutputRow = ++pParse->nMem;  addrOutputRow = sqlite3VdbeMakeLabel(pParse);  regReset = ++pParse->nMem;  addrReset = sqlite3VdbeMakeLabel(pParse);  iAMem = pParse->nMem + 1;  pParse->nMem += pGroupBy->nExpr;  iBMem = pParse->nMem + 1;  pParse->nMem += pGroupBy->nExpr;  sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);  VdbeComment((v, "clear abort flag"));  sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);  sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);  SELECTTRACE(1,pParse,p,("WhereBegin\n"));  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct,  WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0) | distFlag, 0  );  if( pWInfo==0 ){  sqlite3ExprListDelete(db, pDistinct);  goto select_end;  }  eDist = sqlite3WhereIsDistinct(pWInfo);  SELECTTRACE(1,pParse,p,("WhereBegin returns\n"));  if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){  groupBySort = 0;  }else{  int regBase;  int regRecord;  int nCol;  int nGroupBy;  explainTempTable(pParse,  (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?  "DISTINCT" : "GROUP BY");  groupBySort = 1;  nGroupBy = pGroupBy->nExpr;  nCol = nGroupBy;  j = nGroupBy;  for(i=0; i<pAggInfo->nColumn; i++){  if( pAggInfo->aCol[i].iSorterColumn>=j ){  nCol++;  j++;  }  }  regBase = sqlite3GetTempRange(pParse, nCol);  sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);  j = nGroupBy;  for(i=0; i<pAggInfo->nColumn; i++){  struct AggInfo_col *pCol = &pAggInfo->aCol[i];  if( pCol->iSorterColumn>=j ){  int r1 = j + regBase;  sqlite3ExprCodeGetColumnOfTable(v,   pCol->pTab, pCol->iTable, pCol->iColumn, r1);  j++;  }  }  regRecord = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);  sqlite3VdbeAddOp2(v, OP_SorterInsert, pAggInfo->sortingIdx, regRecord);  sqlite3ReleaseTempReg(pParse, regRecord);  sqlite3ReleaseTempRange(pParse, regBase, nCol);  SELECTTRACE(1,pParse,p,("WhereEnd\n"));  sqlite3WhereEnd(pWInfo);  pAggInfo->sortingIdxPTab = sortPTab = pParse->nTab++;  sortOut = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);  sqlite3VdbeAddOp2(v, OP_SorterSort, pAggInfo->sortingIdx, addrEnd);  VdbeComment((v, "GROUP BY sort")); VdbeCoverage(v);  pAggInfo->useSortingIdx = 1;  }  if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder)   && (groupBySort || sqlite3WhereIsSorted(pWInfo))  ){  sSort.pOrderBy = 0;  sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);  }  addrTopOfLoop = sqlite3VdbeCurrentAddr(v);  if( groupBySort ){  sqlite3VdbeAddOp3(v, OP_SorterData, pAggInfo->sortingIdx,  sortOut, sortPTab);  }  for(j=0; j<pGroupBy->nExpr; j++){  if( groupBySort ){  sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);  }else{  pAggInfo->directMode = 1;  sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);  }  }  sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,  (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);  addr1 = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);  sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);  sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);  VdbeComment((v, "output one row"));  sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);  VdbeComment((v, "check abort flag"));  sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);  VdbeComment((v, "reset accumulator"));  sqlite3VdbeJumpHere(v, addr1);  updateAccumulator(pParse, iUseFlag, pAggInfo, eDist);  sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);  VdbeComment((v, "indicate data in accumulator"));  if( groupBySort ){  sqlite3VdbeAddOp2(v, OP_SorterNext, pAggInfo->sortingIdx,addrTopOfLoop);  VdbeCoverage(v);  }else{  SELECTTRACE(1,pParse,p,("WhereEnd\n"));  sqlite3WhereEnd(pWInfo);  sqlite3VdbeChangeToNoop(v, addrSortingIdx);  }  sqlite3ExprListDelete(db, pDistinct);  sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);  VdbeComment((v, "output final row"));  sqlite3VdbeGoto(v, addrEnd);  addrSetAbort = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);  VdbeComment((v, "set abort flag"));  sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);  sqlite3VdbeResolveLabel(v, addrOutputRow);  addrOutputRow = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);  VdbeCoverage(v);  VdbeComment((v, "Groupby result generator entry point"));  sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);  finalizeAggFunctions(pParse, pAggInfo);  sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);  selectInnerLoop(pParse, p, -1, &sSort,  &sDistinct, pDest,  addrOutputRow+1, addrSetAbort);  sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);  VdbeComment((v, "end groupby result generator"));  sqlite3VdbeResolveLabel(v, addrReset);  resetAccumulator(pParse, pAggInfo);  sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);  VdbeComment((v, "indicate accumulator empty"));  sqlite3VdbeAddOp1(v, OP_Return, regReset);  if( eDist!=WHERE_DISTINCT_NOOP ){  struct AggInfo_func *pF = &pAggInfo->aFunc[0];  fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);  }  }  else {  Table *pTab;  if( (pTab = isSimpleCount(p, pAggInfo))!=0 ){  const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);  const int iCsr = pParse->nTab++;  Index *pIdx;  KeyInfo *pKeyInfo = 0;  Index *pBest = 0;  Pgno iRoot = pTab->tnum;  sqlite3CodeVerifySchema(pParse, iDb);  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);  if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);  if( !p->pSrc->a[0].fg.notIndexed ){  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  if( pIdx->bUnordered==0   && pIdx->szIdxRow<pTab->szTabRow   && pIdx->pPartIdxWhere==0   && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)  ){  pBest = pIdx;  }  }  }  if( pBest ){  iRoot = pBest->tnum;  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);  }  sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, (int)iRoot, iDb, 1);  if( pKeyInfo ){  sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);  }  sqlite3VdbeAddOp2(v, OP_Count, iCsr, pAggInfo->aFunc[0].iMem);  sqlite3VdbeAddOp1(v, OP_Close, iCsr);  explainSimpleCount(pParse, pTab, pBest);  }else{  int regAcc = 0;  ExprList *pDistinct = 0;  u16 distFlag = 0;  int eDist;  if( pAggInfo->nAccumulator ){  for(i=0; i<pAggInfo->nFunc; i++){  if( ExprHasProperty(pAggInfo->aFunc[i].pFExpr, EP_WinFunc) ){  continue;  }  if( pAggInfo->aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ){  break;  }  }  if( i==pAggInfo->nFunc ){  regAcc = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);  }  }else if( pAggInfo->nFunc==1 && pAggInfo->aFunc[0].iDistinct>=0 ){  assert( ExprUseXList(pAggInfo->aFunc[0].pFExpr) );  pDistinct = pAggInfo->aFunc[0].pFExpr->x.pList;  distFlag = pDistinct ? (WHERE_WANT_DISTINCT|WHERE_AGG_DISTINCT) : 0;  }  assert( p->pGroupBy==0 );  resetAccumulator(pParse, pAggInfo);  assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );  assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );  SELECTTRACE(1,pParse,p,("WhereBegin\n"));  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,   pDistinct, minMaxFlag|distFlag, 0);  if( pWInfo==0 ){  goto select_end;  }  SELECTTRACE(1,pParse,p,("WhereBegin returns\n"));  eDist = sqlite3WhereIsDistinct(pWInfo);  updateAccumulator(pParse, regAcc, pAggInfo, eDist);  if( eDist!=WHERE_DISTINCT_NOOP ){  struct AggInfo_func *pF = &pAggInfo->aFunc[0];  fixDistinctOpenEph(pParse, eDist, pF->iDistinct, pF->iDistAddr);  }  if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);  if( minMaxFlag ){  sqlite3WhereMinMaxOptEarlyOut(v, pWInfo);  }  SELECTTRACE(1,pParse,p,("WhereEnd\n"));  sqlite3WhereEnd(pWInfo);  finalizeAggFunctions(pParse, pAggInfo);  }  sSort.pOrderBy = 0;  sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);  selectInnerLoop(pParse, p, -1, 0, 0,  pDest, addrEnd, addrEnd);  }  sqlite3VdbeResolveLabel(v, addrEnd);  }  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){  explainTempTable(pParse, "DISTINCT");  }  if( sSort.pOrderBy ){  explainTempTable(pParse,   sSort.nOBSat>0 ? "RIGHT PART OF ORDER BY":"ORDER BY");  assert( p->pEList==pEList );  generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);  }  sqlite3VdbeResolveLabel(v, iEnd);  rc = (pParse->nErr>0); select_end:  assert( db->mallocFailed==0 || db->mallocFailed==1 );  pParse->nErr += db->mallocFailed;  sqlite3ExprListDelete(db, pMinMaxOrderBy);
#ifdef SQLITE_DEBUG
 if( pAggInfo && !db->mallocFailed ){  for(i=0; i<pAggInfo->nColumn; i++){  Expr *pExpr = pAggInfo->aCol[i].pCExpr;  assert( pExpr!=0 );  assert( pExpr->pAggInfo==pAggInfo );  assert( pExpr->iAgg==i );  }  for(i=0; i<pAggInfo->nFunc; i++){  Expr *pExpr = pAggInfo->aFunc[i].pFExpr;  assert( pExpr!=0 );  assert( pExpr->pAggInfo==pAggInfo );  assert( pExpr->iAgg==i );  }  }
#endif
#if SELECTTRACE_ENABLED
 SELECTTRACE(0x1,pParse,p,("end processing\n"));  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){  sqlite3TreeViewSelect(0, p, 0);  }
#endif
 ExplainQueryPlanPop(pParse);  return rc; }
#ifndef SQLITE_OMIT_GET_TABLE
typedef struct TabResult {  char **azResult;  char *zErrMsg;  u32 nAlloc;  u32 nRow;  u32 nColumn;  u32 nData;  int rc; } TabResult; static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){  TabResult *p = (TabResult*)pArg;  int need;  int i;  char *z;  if( p->nRow==0 && argv!=0 ){  need = nCol*2;  }else{  need = nCol;  }  if( p->nData + need > p->nAlloc ){  char **azNew;  p->nAlloc = p->nAlloc*2 + need;  azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );  if( azNew==0 ) goto malloc_failed;  p->azResult = azNew;  }  if( p->nRow==0 ){  p->nColumn = nCol;  for(i=0; i<nCol; i++){  z = sqlite3_mprintf("%s", colv[i]);  if( z==0 ) goto malloc_failed;  p->azResult[p->nData++] = z;  }  }else if( (int)p->nColumn!=nCol ){  sqlite3_free(p->zErrMsg);  p->zErrMsg = sqlite3_mprintf(   "sqlite3_get_table() called with two or more incompatible queries"  );  p->rc = SQLITE_ERROR;  return 1;  }  if( argv!=0 ){  for(i=0; i<nCol; i++){  if( argv[i]==0 ){  z = 0;  }else{  int n = sqlite3Strlen30(argv[i])+1;  z = sqlite3_malloc64( n );  if( z==0 ) goto malloc_failed;  memcpy(z, argv[i], n);  }  p->azResult[p->nData++] = z;  }  p->nRow++;  }  return 0; malloc_failed:  p->rc = SQLITE_NOMEM_BKPT;  return 1; } SQLITE_API int sqlite3_get_table(  sqlite3 *db,  const char *zSql,  char ***pazResult,  int *pnRow,  int *pnColumn,  char **pzErrMsg ){  int rc;  TabResult res;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || pazResult==0 ) return SQLITE_MISUSE_BKPT;
#endif
 *pazResult = 0;  if( pnColumn ) *pnColumn = 0;  if( pnRow ) *pnRow = 0;  if( pzErrMsg ) *pzErrMsg = 0;  res.zErrMsg = 0;  res.nRow = 0;  res.nColumn = 0;  res.nData = 1;  res.nAlloc = 20;  res.rc = SQLITE_OK;  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );  if( res.azResult==0 ){   db->errCode = SQLITE_NOMEM;   return SQLITE_NOMEM_BKPT;  }  res.azResult[0] = 0;  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);  assert( sizeof(res.azResult[0])>= sizeof(res.nData) );  res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);  if( (rc&0xff)==SQLITE_ABORT ){  sqlite3_free_table(&res.azResult[1]);  if( res.zErrMsg ){  if( pzErrMsg ){  sqlite3_free(*pzErrMsg);  *pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);  }  sqlite3_free(res.zErrMsg);  }  db->errCode = res.rc;  return res.rc;  }  sqlite3_free(res.zErrMsg);  if( rc!=SQLITE_OK ){  sqlite3_free_table(&res.azResult[1]);  return rc;  }  if( res.nAlloc>res.nData ){  char **azNew;  azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );  if( azNew==0 ){  sqlite3_free_table(&res.azResult[1]);  db->errCode = SQLITE_NOMEM;  return SQLITE_NOMEM_BKPT;  }  res.azResult = azNew;  }  *pazResult = &res.azResult[1];  if( pnColumn ) *pnColumn = res.nColumn;  if( pnRow ) *pnRow = res.nRow;  return rc; } SQLITE_API void sqlite3_free_table(  char **azResult ){  if( azResult ){  int i, n;  azResult--;  assert( azResult!=0 );  n = SQLITE_PTR_TO_INT(azResult[0]);  for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }  sqlite3_free(azResult);  } }
#endif
#ifndef SQLITE_OMIT_TRIGGER
SQLITE_PRIVATE void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){  while( pTriggerStep ){  TriggerStep * pTmp = pTriggerStep;  pTriggerStep = pTriggerStep->pNext;  sqlite3ExprDelete(db, pTmp->pWhere);  sqlite3ExprListDelete(db, pTmp->pExprList);  sqlite3SelectDelete(db, pTmp->pSelect);  sqlite3IdListDelete(db, pTmp->pIdList);  sqlite3UpsertDelete(db, pTmp->pUpsert);  sqlite3SrcListDelete(db, pTmp->pFrom);  sqlite3DbFree(db, pTmp->zSpan);  sqlite3DbFree(db, pTmp);  } } SQLITE_PRIVATE Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){  Schema *pTmpSchema;  Trigger *pList;  HashElem *p;  if( pParse->disableTriggers ){  return 0;  }  pTmpSchema = pParse->db->aDb[1].pSchema;  p = sqliteHashFirst(&pTmpSchema->trigHash);  pList = pTab->pTrigger;  while( p ){  Trigger *pTrig = (Trigger *)sqliteHashData(p);  if( pTrig->pTabSchema==pTab->pSchema   && pTrig->table   && 0==sqlite3StrICmp(pTrig->table, pTab->zName)   && pTrig->pTabSchema!=pTmpSchema  ){  pTrig->pNext = pList;  pList = pTrig;  }else if( pTrig->op==TK_RETURNING
#ifndef SQLITE_OMIT_VIRTUALTABLE
 && pParse->db->pVtabCtx==0
#endif
 ){  assert( pParse->bReturning );  assert( &(pParse->u1.pReturning->retTrig) == pTrig );  pTrig->table = pTab->zName;  pTrig->pTabSchema = pTab->pSchema;  pTrig->pNext = pList;  pList = pTrig;  }  p = sqliteHashNext(p);  }
#if 0
 if( pList ){  Trigger *pX;  printf("Triggers for %s:", pTab->zName);  for(pX=pList; pX; pX=pX->pNext){  printf(" %s", pX->zName);  }  printf("\n");  fflush(stdout);  }
#endif
 return pList; } SQLITE_PRIVATE void sqlite3BeginTrigger(  Parse *pParse,  Token *pName1,  Token *pName2,  int tr_tm,  int op,  IdList *pColumns,  SrcList *pTableName,  Expr *pWhen,  int isTemp,  int noErr ){  Trigger *pTrigger = 0;  Table *pTab;  char *zName = 0;  sqlite3 *db = pParse->db;  int iDb;  Token *pName;  DbFixer sFix;  assert( pName1!=0 );  assert( pName2!=0 );  assert( op==TK_INSERT || op==TK_UPDATE || op==TK_DELETE );  assert( op>0 && op<0xff );  if( isTemp ){  if( pName2->n>0 ){  sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");  goto trigger_cleanup;  }  iDb = 1;  pName = pName1;  }else{  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);  if( iDb<0 ){  goto trigger_cleanup;  }  }  if( !pTableName || db->mallocFailed ){  goto trigger_cleanup;  }  if( db->init.busy && iDb!=1 ){  sqlite3DbFree(db, pTableName->a[0].zDatabase);  pTableName->a[0].zDatabase = 0;  }  pTab = sqlite3SrcListLookup(pParse, pTableName);  if( db->init.busy==0 && pName2->n==0 && pTab  && pTab->pSchema==db->aDb[1].pSchema ){  iDb = 1;  }  if( db->mallocFailed ) goto trigger_cleanup;  assert( pTableName->nSrc==1 );  sqlite3FixInit(&sFix, pParse, iDb, "trigger", pName);  if( sqlite3FixSrcList(&sFix, pTableName) ){  goto trigger_cleanup;  }  pTab = sqlite3SrcListLookup(pParse, pTableName);  if( !pTab ){  goto trigger_orphan_error;  }  if( IsVirtual(pTab) ){  sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");  goto trigger_orphan_error;  }  zName = sqlite3NameFromToken(db, pName);  if( zName==0 ){  assert( db->mallocFailed );  goto trigger_cleanup;  }  if( sqlite3CheckObjectName(pParse, zName, "trigger", pTab->zName) ){  goto trigger_cleanup;  }  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  if( !IN_RENAME_OBJECT ){  if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash),zName) ){  if( !noErr ){  sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);  }else{  assert( !db->init.busy );  sqlite3CodeVerifySchema(pParse, iDb);  }  goto trigger_cleanup;  }  }  if( sqlite3StrNICmp(pTab->zName, "sqlite_", 7)==0 ){  sqlite3ErrorMsg(pParse, "cannot create trigger on system table");  goto trigger_cleanup;  }  if( IsView(pTab) && tr_tm!=TK_INSTEAD ){  sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S",  (tr_tm == TK_BEFORE)?"BEFORE":"AFTER", pTableName->a);  goto trigger_orphan_error;  }  if( !IsView(pTab) && tr_tm==TK_INSTEAD ){  sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF"  " trigger on table: %S", pTableName->a);  goto trigger_orphan_error;  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( !IN_RENAME_OBJECT ){  int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);  int code = SQLITE_CREATE_TRIGGER;  const char *zDb = db->aDb[iTabDb].zDbSName;  const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;  if( iTabDb==1 || isTemp ) code = SQLITE_CREATE_TEMP_TRIGGER;  if( sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig) ){  goto trigger_cleanup;  }  if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb),0,zDb)){  goto trigger_cleanup;  }  }
#endif
 if (tr_tm == TK_INSTEAD){  tr_tm = TK_BEFORE;  }  pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger));  if( pTrigger==0 ) goto trigger_cleanup;  pTrigger->zName = zName;  zName = 0;  pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);  pTrigger->pSchema = db->aDb[iDb].pSchema;  pTrigger->pTabSchema = pTab->pSchema;  pTrigger->op = (u8)op;  pTrigger->tr_tm = tr_tm==TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER;  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenRemap(pParse, pTrigger->table, pTableName->a[0].zName);  pTrigger->pWhen = pWhen;  pWhen = 0;  }else{  pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);  }  pTrigger->pColumns = pColumns;  pColumns = 0;  assert( pParse->pNewTrigger==0 );  pParse->pNewTrigger = pTrigger; trigger_cleanup:  sqlite3DbFree(db, zName);  sqlite3SrcListDelete(db, pTableName);  sqlite3IdListDelete(db, pColumns);  sqlite3ExprDelete(db, pWhen);  if( !pParse->pNewTrigger ){  sqlite3DeleteTrigger(db, pTrigger);  }else{  assert( pParse->pNewTrigger==pTrigger );  }  return; trigger_orphan_error:  if( db->init.iDb==1 ){  db->init.orphanTrigger = 1;  }  goto trigger_cleanup; } SQLITE_PRIVATE void sqlite3FinishTrigger(  Parse *pParse,  TriggerStep *pStepList,  Token *pAll ){  Trigger *pTrig = pParse->pNewTrigger;  char *zName;  sqlite3 *db = pParse->db;  DbFixer sFix;  int iDb;  Token nameToken;  pParse->pNewTrigger = 0;  if( NEVER(pParse->nErr) || !pTrig ) goto triggerfinish_cleanup;  zName = pTrig->zName;  iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);  pTrig->step_list = pStepList;  while( pStepList ){  pStepList->pTrig = pTrig;  pStepList = pStepList->pNext;  }  sqlite3TokenInit(&nameToken, pTrig->zName);  sqlite3FixInit(&sFix, pParse, iDb, "trigger", &nameToken);  if( sqlite3FixTriggerStep(&sFix, pTrig->step_list)   || sqlite3FixExpr(&sFix, pTrig->pWhen)  ){  goto triggerfinish_cleanup;  }
#ifndef SQLITE_OMIT_ALTERTABLE
 if( IN_RENAME_OBJECT ){  assert( !db->init.busy );  pParse->pNewTrigger = pTrig;  pTrig = 0;  }else
#endif
 if( !db->init.busy ){  Vdbe *v;  char *z;  v = sqlite3GetVdbe(pParse);  if( v==0 ) goto triggerfinish_cleanup;  sqlite3BeginWriteOperation(pParse, 0, iDb);  z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);  testcase( z==0 );  sqlite3NestedParse(pParse,   "INSERT INTO %Q." LEGACY_SCHEMA_TABLE   " VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')",   db->aDb[iDb].zDbSName, zName,   pTrig->table, z);  sqlite3DbFree(db, z);  sqlite3ChangeCookie(pParse, iDb);  sqlite3VdbeAddParseSchemaOp(v, iDb,  sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName), 0);  }  if( db->init.busy ){  Trigger *pLink = pTrig;  Hash *pHash = &db->aDb[iDb].pSchema->trigHash;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  assert( pLink!=0 );  pTrig = sqlite3HashInsert(pHash, zName, pTrig);  if( pTrig ){  sqlite3OomFault(db);  }else if( pLink->pSchema==pLink->pTabSchema ){  Table *pTab;  pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);  assert( pTab!=0 );  pLink->pNext = pTab->pTrigger;  pTab->pTrigger = pLink;  }  } triggerfinish_cleanup:  sqlite3DeleteTrigger(db, pTrig);  assert( IN_RENAME_OBJECT || !pParse->pNewTrigger );  sqlite3DeleteTriggerStep(db, pStepList); } static char *triggerSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){  char *z = sqlite3DbSpanDup(db, zStart, zEnd);  int i;  if( z ) for(i=0; z[i]; i++) if( sqlite3Isspace(z[i]) ) z[i] = ' ';  return z; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerSelectStep(  sqlite3 *db,  Select *pSelect,  const char *zStart,  const char *zEnd ){  TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep));  if( pTriggerStep==0 ) {  sqlite3SelectDelete(db, pSelect);  return 0;  }  pTriggerStep->op = TK_SELECT;  pTriggerStep->pSelect = pSelect;  pTriggerStep->orconf = OE_Default;  pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);  return pTriggerStep; } static TriggerStep *triggerStepAllocate(  Parse *pParse,  u8 op,  Token *pName,  const char *zStart,  const char *zEnd ){  sqlite3 *db = pParse->db;  TriggerStep *pTriggerStep;  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);  if( pTriggerStep ){  char *z = (char*)&pTriggerStep[1];  memcpy(z, pName->z, pName->n);  sqlite3Dequote(z);  pTriggerStep->zTarget = z;  pTriggerStep->op = op;  pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenMap(pParse, pTriggerStep->zTarget, pName);  }  }  return pTriggerStep; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerInsertStep(  Parse *pParse,  Token *pTableName,  IdList *pColumn,  Select *pSelect,  u8 orconf,  Upsert *pUpsert,  const char *zStart,  const char *zEnd ){  sqlite3 *db = pParse->db;  TriggerStep *pTriggerStep;  assert(pSelect != 0 || db->mallocFailed);  pTriggerStep = triggerStepAllocate(pParse, TK_INSERT, pTableName,zStart,zEnd);  if( pTriggerStep ){  if( IN_RENAME_OBJECT ){  pTriggerStep->pSelect = pSelect;  pSelect = 0;  }else{  pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);  }  pTriggerStep->pIdList = pColumn;  pTriggerStep->pUpsert = pUpsert;  pTriggerStep->orconf = orconf;  if( pUpsert ){  sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget);  }  }else{  testcase( pColumn );  sqlite3IdListDelete(db, pColumn);  testcase( pUpsert );  sqlite3UpsertDelete(db, pUpsert);  }  sqlite3SelectDelete(db, pSelect);  return pTriggerStep; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerUpdateStep(  Parse *pParse,  Token *pTableName,  SrcList *pFrom,  ExprList *pEList,  Expr *pWhere,  u8 orconf,  const char *zStart,  const char *zEnd ){  sqlite3 *db = pParse->db;  TriggerStep *pTriggerStep;  pTriggerStep = triggerStepAllocate(pParse, TK_UPDATE, pTableName,zStart,zEnd);  if( pTriggerStep ){  if( IN_RENAME_OBJECT ){  pTriggerStep->pExprList = pEList;  pTriggerStep->pWhere = pWhere;  pTriggerStep->pFrom = pFrom;  pEList = 0;  pWhere = 0;  pFrom = 0;  }else{  pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, EXPRDUP_REDUCE);  pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);  pTriggerStep->pFrom = sqlite3SrcListDup(db, pFrom, EXPRDUP_REDUCE);  }  pTriggerStep->orconf = orconf;  }  sqlite3ExprListDelete(db, pEList);  sqlite3ExprDelete(db, pWhere);  sqlite3SrcListDelete(db, pFrom);  return pTriggerStep; } SQLITE_PRIVATE TriggerStep *sqlite3TriggerDeleteStep(  Parse *pParse,  Token *pTableName,  Expr *pWhere,  const char *zStart,  const char *zEnd ){  sqlite3 *db = pParse->db;  TriggerStep *pTriggerStep;  pTriggerStep = triggerStepAllocate(pParse, TK_DELETE, pTableName,zStart,zEnd);  if( pTriggerStep ){  if( IN_RENAME_OBJECT ){  pTriggerStep->pWhere = pWhere;  pWhere = 0;  }else{  pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);  }  pTriggerStep->orconf = OE_Default;  }  sqlite3ExprDelete(db, pWhere);  return pTriggerStep; } SQLITE_PRIVATE void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){  if( pTrigger==0 || pTrigger->bReturning ) return;  sqlite3DeleteTriggerStep(db, pTrigger->step_list);  sqlite3DbFree(db, pTrigger->zName);  sqlite3DbFree(db, pTrigger->table);  sqlite3ExprDelete(db, pTrigger->pWhen);  sqlite3IdListDelete(db, pTrigger->pColumns);  sqlite3DbFree(db, pTrigger); } SQLITE_PRIVATE void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){  Trigger *pTrigger = 0;  int i;  const char *zDb;  const char *zName;  sqlite3 *db = pParse->db;  if( db->mallocFailed ) goto drop_trigger_cleanup;  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){  goto drop_trigger_cleanup;  }  assert( pName->nSrc==1 );  zDb = pName->a[0].zDatabase;  zName = pName->a[0].zName;  assert( zDb!=0 || sqlite3BtreeHoldsAllMutexes(db) );  for(i=OMIT_TEMPDB; i<db->nDb; i++){  int j = (i<2) ? i^1 : i;  if( zDb && sqlite3DbIsNamed(db, j, zDb)==0 ) continue;  assert( sqlite3SchemaMutexHeld(db, j, 0) );  pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);  if( pTrigger ) break;  }  if( !pTrigger ){  if( !noErr ){  sqlite3ErrorMsg(pParse, "no such trigger: %S", pName->a);  }else{  sqlite3CodeVerifyNamedSchema(pParse, zDb);  }  pParse->checkSchema = 1;  goto drop_trigger_cleanup;  }  sqlite3DropTriggerPtr(pParse, pTrigger); drop_trigger_cleanup:  sqlite3SrcListDelete(db, pName); } static Table *tableOfTrigger(Trigger *pTrigger){  return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table); } SQLITE_PRIVATE void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){  Table  *pTable;  Vdbe *v;  sqlite3 *db = pParse->db;  int iDb;  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);  assert( iDb>=0 && iDb<db->nDb );  pTable = tableOfTrigger(pTrigger);  assert( (pTable && pTable->pSchema==pTrigger->pSchema) || iDb==1 );
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( pTable ){  int code = SQLITE_DROP_TRIGGER;  const char *zDb = db->aDb[iDb].zDbSName;  const char *zTab = SCHEMA_TABLE(iDb);  if( iDb==1 ) code = SQLITE_DROP_TEMP_TRIGGER;  if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||  sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){  return;  }  }
#endif
 if( (v = sqlite3GetVdbe(pParse))!=0 ){  sqlite3NestedParse(pParse,   "DELETE FROM %Q." LEGACY_SCHEMA_TABLE " WHERE name=%Q AND type='trigger'",   db->aDb[iDb].zDbSName, pTrigger->zName  );  sqlite3ChangeCookie(pParse, iDb);  sqlite3VdbeAddOp4(v, OP_DropTrigger, iDb, 0, 0, pTrigger->zName, 0);  } } SQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){  Trigger *pTrigger;  Hash *pHash;  assert( sqlite3SchemaMutexHeld(db, iDb, 0) );  pHash = &(db->aDb[iDb].pSchema->trigHash);  pTrigger = sqlite3HashInsert(pHash, zName, 0);  if( ALWAYS(pTrigger) ){  if( pTrigger->pSchema==pTrigger->pTabSchema ){  Table *pTab = tableOfTrigger(pTrigger);  if( pTab ){  Trigger **pp;  for(pp=&pTab->pTrigger; *pp; pp=&((*pp)->pNext)){  if( *pp==pTrigger ){  *pp = (*pp)->pNext;  break;  }  }  }  }  sqlite3DeleteTrigger(db, pTrigger);  db->mDbFlags |= DBFLAG_SchemaChange;  } } static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){  int e;  if( pIdList==0 || NEVER(pEList==0) ) return 1;  for(e=0; e<pEList->nExpr; e++){  if( sqlite3IdListIndex(pIdList, pEList->a[e].zEName)>=0 ) return 1;  }  return 0; } SQLITE_PRIVATE Trigger *sqlite3TriggersExist(  Parse *pParse,  Table *pTab,  int op,  ExprList *pChanges,  int *pMask ){  int mask = 0;  Trigger *pList = 0;  Trigger *p;  pList = sqlite3TriggerList(pParse, pTab);  assert( pList==0 || IsVirtual(pTab)==0   || (pList->bReturning && pList->pNext==0) );  if( pList!=0 ){  p = pList;  if( (pParse->db->flags & SQLITE_EnableTrigger)==0   && pTab->pTrigger!=0  ){  if( pList==pTab->pTrigger ){  pList = 0;  goto exit_triggers_exist;  }  while( ALWAYS(p->pNext) && p->pNext!=pTab->pTrigger ) p = p->pNext;  p->pNext = 0;  p = pList;  }  do{  if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){  mask |= p->tr_tm;  }else if( p->op==TK_RETURNING ){  assert( sqlite3IsToplevel(pParse) );  p->op = op;  if( IsVirtual(pTab) ){  if( op!=TK_INSERT ){  sqlite3ErrorMsg(pParse,  "%s RETURNING is not available on virtual tables",  op==TK_DELETE ? "DELETE" : "UPDATE");  }  p->tr_tm = TRIGGER_BEFORE;  }else{  p->tr_tm = TRIGGER_AFTER;  }  mask |= p->tr_tm;  }else if( p->bReturning && p->op==TK_INSERT && op==TK_UPDATE  && sqlite3IsToplevel(pParse) ){  mask |= p->tr_tm;  }  p = p->pNext;  }while( p );  } exit_triggers_exist:  if( pMask ){  *pMask = mask;  }  return (mask ? pList : 0); } SQLITE_PRIVATE SrcList *sqlite3TriggerStepSrc(  Parse *pParse,  TriggerStep *pStep ){  sqlite3 *db = pParse->db;  SrcList *pSrc;  char *zName = sqlite3DbStrDup(db, pStep->zTarget);  pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);  assert( pSrc==0 || pSrc->nSrc==1 );  assert( zName || pSrc==0 );  if( pSrc ){  Schema *pSchema = pStep->pTrig->pSchema;  pSrc->a[0].zName = zName;  if( pSchema!=db->aDb[1].pSchema ){  pSrc->a[0].pSchema = pSchema;  }  if( pStep->pFrom ){  SrcList *pDup = sqlite3SrcListDup(db, pStep->pFrom, 0);  pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup);  }  }else{  sqlite3DbFree(db, zName);  }  return pSrc; } static int isAsteriskTerm(  Parse *pParse,  Expr *pTerm ){  assert( pTerm!=0 );  if( pTerm->op==TK_ASTERISK ) return 1;  if( pTerm->op!=TK_DOT ) return 0;  assert( pTerm->pRight!=0 );  assert( pTerm->pLeft!=0 );  if( pTerm->pRight->op!=TK_ASTERISK ) return 0;  sqlite3ErrorMsg(pParse, "RETURNING may not use \"TABLE.*\" wildcards");  return 1; } static ExprList *sqlite3ExpandReturning(  Parse *pParse,  ExprList *pList,  Table *pTab ){  ExprList *pNew = 0;  sqlite3 *db = pParse->db;  int i;  for(i=0; i<pList->nExpr; i++){  Expr *pOldExpr = pList->a[i].pExpr;  if( NEVER(pOldExpr==0) ) continue;  if( isAsteriskTerm(pParse, pOldExpr) ){  int jj;  for(jj=0; jj<pTab->nCol; jj++){  Expr *pNewExpr;  if( IsHiddenColumn(pTab->aCol+jj) ) continue;  pNewExpr = sqlite3Expr(db, TK_ID, pTab->aCol[jj].zCnName);  pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);  if( !db->mallocFailed ){  struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];  pItem->zEName = sqlite3DbStrDup(db, pTab->aCol[jj].zCnName);  pItem->eEName = ENAME_NAME;  }  }  }else{  Expr *pNewExpr = sqlite3ExprDup(db, pOldExpr, 0);  pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr);  if( !db->mallocFailed && ALWAYS(pList->a[i].zEName!=0) ){  struct ExprList_item *pItem = &pNew->a[pNew->nExpr-1];  pItem->zEName = sqlite3DbStrDup(db, pList->a[i].zEName);  pItem->eEName = pList->a[i].eEName;  }  }  }  return pNew; } static void codeReturningTrigger(  Parse *pParse,  Trigger *pTrigger,  Table *pTab,  int regIn ){  Vdbe *v = pParse->pVdbe;  sqlite3 *db = pParse->db;  ExprList *pNew;  Returning *pReturning;  Select sSelect;  SrcList sFrom;  assert( v!=0 );  assert( pParse->bReturning );  pReturning = pParse->u1.pReturning;  assert( pTrigger == &(pReturning->retTrig) );  memset(&sSelect, 0, sizeof(sSelect));  memset(&sFrom, 0, sizeof(sFrom));  sSelect.pEList = sqlite3ExprListDup(db, pReturning->pReturnEL, 0);  sSelect.pSrc = &sFrom;  sFrom.nSrc = 1;  sFrom.a[0].pTab = pTab;  sFrom.a[0].iCursor = -1;  sqlite3SelectPrep(pParse, &sSelect, 0);  if( db->mallocFailed==0 && pParse->nErr==0 ){  sqlite3GenerateColumnNames(pParse, &sSelect);  }  sqlite3ExprListDelete(db, sSelect.pEList);  pNew = sqlite3ExpandReturning(pParse, pReturning->pReturnEL, pTab);  if( !db->mallocFailed ){  NameContext sNC;  memset(&sNC, 0, sizeof(sNC));  if( pReturning->nRetCol==0 ){  pReturning->nRetCol = pNew->nExpr;  pReturning->iRetCur = pParse->nTab++;  }  sNC.pParse = pParse;  sNC.uNC.iBaseReg = regIn;  sNC.ncFlags = NC_UBaseReg;  pParse->eTriggerOp = pTrigger->op;  pParse->pTriggerTab = pTab;  if( sqlite3ResolveExprListNames(&sNC, pNew)==SQLITE_OK   && !db->mallocFailed  ){  int i;  int nCol = pNew->nExpr;  int reg = pParse->nMem+1;  pParse->nMem += nCol+2;  pReturning->iRetReg = reg;  for(i=0; i<nCol; i++){  Expr *pCol = pNew->a[i].pExpr;  assert( pCol!=0 );  sqlite3ExprCodeFactorable(pParse, pCol, reg+i);  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, reg, i, reg+i);  sqlite3VdbeAddOp2(v, OP_NewRowid, pReturning->iRetCur, reg+i+1);  sqlite3VdbeAddOp3(v, OP_Insert, pReturning->iRetCur, reg+i, reg+i+1);  }  }  sqlite3ExprListDelete(db, pNew);  pParse->eTriggerOp = 0;  pParse->pTriggerTab = 0; } static int codeTriggerProgram(  Parse *pParse,  TriggerStep *pStepList,  int orconf ){  TriggerStep *pStep;  Vdbe *v = pParse->pVdbe;  sqlite3 *db = pParse->db;  assert( pParse->pTriggerTab && pParse->pToplevel );  assert( pStepList );  assert( v!=0 );  for(pStep=pStepList; pStep; pStep=pStep->pNext){  pParse->eOrconf = (orconf==OE_Default)?pStep->orconf:(u8)orconf;  assert( pParse->okConstFactor==0 );
#ifndef SQLITE_OMIT_TRACE
 if( pStep->zSpan ){  sqlite3VdbeAddOp4(v, OP_Trace, 0x7fffffff, 1, 0,  sqlite3MPrintf(db, "-- %s", pStep->zSpan),  P4_DYNAMIC);  }
#endif
 switch( pStep->op ){  case TK_UPDATE: {  sqlite3Update(pParse,  sqlite3TriggerStepSrc(pParse, pStep),  sqlite3ExprListDup(db, pStep->pExprList, 0),  sqlite3ExprDup(db, pStep->pWhere, 0),  pParse->eOrconf, 0, 0, 0  );  sqlite3VdbeAddOp0(v, OP_ResetCount);  break;  }  case TK_INSERT: {  sqlite3Insert(pParse,  sqlite3TriggerStepSrc(pParse, pStep),  sqlite3SelectDup(db, pStep->pSelect, 0),  sqlite3IdListDup(db, pStep->pIdList),  pParse->eOrconf,  sqlite3UpsertDup(db, pStep->pUpsert)  );  sqlite3VdbeAddOp0(v, OP_ResetCount);  break;  }  case TK_DELETE: {  sqlite3DeleteFrom(pParse,  sqlite3TriggerStepSrc(pParse, pStep),  sqlite3ExprDup(db, pStep->pWhere, 0), 0, 0  );  sqlite3VdbeAddOp0(v, OP_ResetCount);  break;  }  default: assert( pStep->op==TK_SELECT ); {  SelectDest sDest;  Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);  sqlite3SelectDestInit(&sDest, SRT_Discard, 0);  sqlite3Select(pParse, pSelect, &sDest);  sqlite3SelectDelete(db, pSelect);  break;  }  }  }  return 0; }
#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS
static const char *onErrorText(int onError){  switch( onError ){  case OE_Abort: return "abort";  case OE_Rollback: return "rollback";  case OE_Fail:  return "fail";  case OE_Replace: return "replace";  case OE_Ignore:  return "ignore";  case OE_Default: return "default";  }  return "n/a"; }
#endif
static void transferParseError(Parse *pTo, Parse *pFrom){  assert( pFrom->zErrMsg==0 || pFrom->nErr );  assert( pTo->zErrMsg==0 || pTo->nErr );  if( pTo->nErr==0 ){  pTo->zErrMsg = pFrom->zErrMsg;  pTo->nErr = pFrom->nErr;  pTo->rc = pFrom->rc;  }else{  sqlite3DbFree(pFrom->db, pFrom->zErrMsg);  } } static TriggerPrg *codeRowTrigger(  Parse *pParse,  Trigger *pTrigger,  Table *pTab,  int orconf ){  Parse *pTop = sqlite3ParseToplevel(pParse);  sqlite3 *db = pParse->db;  TriggerPrg *pPrg;  Expr *pWhen = 0;  Vdbe *v;  NameContext sNC;  SubProgram *pProgram = 0;  Parse *pSubParse;  int iEndTrigger = 0;  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );  assert( pTop->pVdbe );  pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));  if( !pPrg ) return 0;  pPrg->pNext = pTop->pTriggerPrg;  pTop->pTriggerPrg = pPrg;  pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));  if( !pProgram ) return 0;  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);  pPrg->pTrigger = pTrigger;  pPrg->orconf = orconf;  pPrg->aColmask[0] = 0xffffffff;  pPrg->aColmask[1] = 0xffffffff;  pSubParse = sqlite3StackAllocZero(db, sizeof(Parse));  if( !pSubParse ) return 0;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pSubParse;  pSubParse->db = db;  pSubParse->pTriggerTab = pTab;  pSubParse->pToplevel = pTop;  pSubParse->zAuthContext = pTrigger->zName;  pSubParse->eTriggerOp = pTrigger->op;  pSubParse->nQueryLoop = pParse->nQueryLoop;  pSubParse->disableVtab = pParse->disableVtab;  v = sqlite3GetVdbe(pSubParse);  if( v ){  VdbeComment((v, "Start: %s.%s (%s %s%s%s ON %s)",  pTrigger->zName, onErrorText(orconf),  (pTrigger->tr_tm==TRIGGER_BEFORE ? "BEFORE" : "AFTER"),  (pTrigger->op==TK_UPDATE ? "UPDATE" : ""),  (pTrigger->op==TK_INSERT ? "INSERT" : ""),  (pTrigger->op==TK_DELETE ? "DELETE" : ""),  pTab->zName  ));
#ifndef SQLITE_OMIT_TRACE
 if( pTrigger->zName ){  sqlite3VdbeChangeP4(v, -1,  sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), P4_DYNAMIC  );  }
#endif
 if( pTrigger->pWhen ){  pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);  if( db->mallocFailed==0   && SQLITE_OK==sqlite3ResolveExprNames(&sNC, pWhen)  ){  iEndTrigger = sqlite3VdbeMakeLabel(pSubParse);  sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, SQLITE_JUMPIFNULL);  }  sqlite3ExprDelete(db, pWhen);  }  codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);  if( iEndTrigger ){  sqlite3VdbeResolveLabel(v, iEndTrigger);  }  sqlite3VdbeAddOp0(v, OP_Halt);  VdbeComment((v, "End: %s.%s", pTrigger->zName, onErrorText(orconf)));  transferParseError(pParse, pSubParse);  if( db->mallocFailed==0 && pParse->nErr==0 ){  pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);  }  pProgram->nMem = pSubParse->nMem;  pProgram->nCsr = pSubParse->nTab;  pProgram->token = (void *)pTrigger;  pPrg->aColmask[0] = pSubParse->oldmask;  pPrg->aColmask[1] = pSubParse->newmask;  sqlite3VdbeDelete(v);  }  assert( !pSubParse->pTriggerPrg && !pSubParse->nMaxArg );  sqlite3ParserReset(pSubParse);  sqlite3StackFree(db, pSubParse);  return pPrg; } static TriggerPrg *getRowTrigger(  Parse *pParse,  Trigger *pTrigger,  Table *pTab,  int orconf ){  Parse *pRoot = sqlite3ParseToplevel(pParse);  TriggerPrg *pPrg;  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );  for(pPrg=pRoot->pTriggerPrg;  pPrg && (pPrg->pTrigger!=pTrigger || pPrg->orconf!=orconf);  pPrg=pPrg->pNext  );  if( !pPrg ){  pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);  }  return pPrg; } SQLITE_PRIVATE void sqlite3CodeRowTriggerDirect(  Parse *pParse,  Trigger *p,  Table *pTab,  int reg,  int orconf,  int ignoreJump ){  Vdbe *v = sqlite3GetVdbe(pParse);  TriggerPrg *pPrg;  pPrg = getRowTrigger(pParse, p, pTab, orconf);  assert( pPrg || pParse->nErr || pParse->db->mallocFailed );  if( pPrg ){  int bRecursive = (p->zName && 0==(pParse->db->flags&SQLITE_RecTriggers));  sqlite3VdbeAddOp4(v, OP_Program, reg, ignoreJump, ++pParse->nMem,  (const char *)pPrg->pProgram, P4_SUBPROGRAM);  VdbeComment(  (v, "Call: %s.%s", (p->zName?p->zName:"fkey"), onErrorText(orconf)));  sqlite3VdbeChangeP5(v, (u8)bRecursive);  } } SQLITE_PRIVATE void sqlite3CodeRowTrigger(  Parse *pParse,  Trigger *pTrigger,  int op,  ExprList *pChanges,  int tr_tm,  Table *pTab,  int reg,  int orconf,  int ignoreJump ){  Trigger *p;  assert( op==TK_UPDATE || op==TK_INSERT || op==TK_DELETE );  assert( tr_tm==TRIGGER_BEFORE || tr_tm==TRIGGER_AFTER );  assert( (op==TK_UPDATE)==(pChanges!=0) );  for(p=pTrigger; p; p=p->pNext){  assert( p->pSchema!=0 );  assert( p->pTabSchema!=0 );  assert( p->pSchema==p->pTabSchema   || p->pSchema==pParse->db->aDb[1].pSchema );  if( (p->op==op || (p->bReturning && p->op==TK_INSERT && op==TK_UPDATE))   && p->tr_tm==tr_tm   && checkColumnOverlap(p->pColumns, pChanges)  ){  if( !p->bReturning ){  sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);  }else if( sqlite3IsToplevel(pParse) ){  codeReturningTrigger(pParse, p, pTab, reg);  }  }  } } SQLITE_PRIVATE u32 sqlite3TriggerColmask(  Parse *pParse,  Trigger *pTrigger,  ExprList *pChanges,  int isNew,  int tr_tm,  Table *pTab,  int orconf ){  const int op = pChanges ? TK_UPDATE : TK_DELETE;  u32 mask = 0;  Trigger *p;  assert( isNew==1 || isNew==0 );  for(p=pTrigger; p; p=p->pNext){  if( p->op==op   && (tr_tm&p->tr_tm)   && checkColumnOverlap(p->pColumns,pChanges)  ){  if( p->bReturning ){  mask = 0xffffffff;  }else{  TriggerPrg *pPrg;  pPrg = getRowTrigger(pParse, p, pTab, orconf);  if( pPrg ){  mask |= pPrg->aColmask[isNew];  }  }  }  }  return mask; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
static void updateVirtualTable(  Parse *pParse,  SrcList *pSrc,  Table *pTab,  ExprList *pChanges,  Expr *pRowidExpr,  int *aXRef,  Expr *pWhere,  int onError );
#endif
SQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){  assert( pTab!=0 );  if( !IsView(pTab) ){  sqlite3_value *pValue = 0;  u8 enc = ENC(sqlite3VdbeDb(v));  Column *pCol = &pTab->aCol[i];  VdbeComment((v, "%s.%s", pTab->zName, pCol->zCnName));  assert( i<pTab->nCol );  sqlite3ValueFromExpr(sqlite3VdbeDb(v),   sqlite3ColumnExpr(pTab,pCol), enc,   pCol->affinity, &pValue);  if( pValue ){  sqlite3VdbeAppendP4(v, pValue, P4_MEM);  }  }
#ifndef SQLITE_OMIT_FLOATING_POINT
 if( pTab->aCol[i].affinity==SQLITE_AFF_REAL && !IsVirtual(pTab) ){  sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);  }
#endif
} static int indexColumnIsBeingUpdated(  Index *pIdx,  int iCol,  int *aXRef,  int chngRowid ){  i16 iIdxCol = pIdx->aiColumn[iCol];  assert( iIdxCol!=XN_ROWID );  if( iIdxCol>=0 ){  return aXRef[iIdxCol]>=0;  }  assert( iIdxCol==XN_EXPR );  assert( pIdx->aColExpr!=0 );  assert( pIdx->aColExpr->a[iCol].pExpr!=0 );  return sqlite3ExprReferencesUpdatedColumn(pIdx->aColExpr->a[iCol].pExpr,  aXRef,chngRowid); } static int indexWhereClauseMightChange(  Index *pIdx,  int *aXRef,  int chngRowid ){  if( pIdx->pPartIdxWhere==0 ) return 0;  return sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere,  aXRef, chngRowid); } static Expr *exprRowColumn(Parse *pParse, int iCol){  Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);  if( pRet ) pRet->iColumn = iCol+1;  return pRet; } static void updateFromSelect(  Parse *pParse,  int iEph,  Index *pPk,  ExprList *pChanges,  SrcList *pTabList,  Expr *pWhere,  ExprList *pOrderBy,  Expr *pLimit ){  int i;  SelectDest dest;  Select *pSelect = 0;  ExprList *pList = 0;  ExprList *pGrp = 0;  Expr *pLimit2 = 0;  ExprList *pOrderBy2 = 0;  sqlite3 *db = pParse->db;  Table *pTab = pTabList->a[0].pTab;  SrcList *pSrc;  Expr *pWhere2;  int eDest;
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( pOrderBy && pLimit==0 ) {  sqlite3ErrorMsg(pParse, "ORDER BY without LIMIT on UPDATE");  return;  }  pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);  pLimit2 = sqlite3ExprDup(db, pLimit, 0);
#else
 UNUSED_PARAMETER(pOrderBy);  UNUSED_PARAMETER(pLimit);
#endif
 pSrc = sqlite3SrcListDup(db, pTabList, 0);  pWhere2 = sqlite3ExprDup(db, pWhere, 0);  assert( pTabList->nSrc>1 );  if( pSrc ){  pSrc->a[0].fg.notCte = 1;  pSrc->a[0].iCursor = -1;  pSrc->a[0].pTab->nTabRef--;  pSrc->a[0].pTab = 0;  }  if( pPk ){  for(i=0; i<pPk->nKeyCol; i++){  Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( pLimit ){  pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));  }
#endif
 pList = sqlite3ExprListAppend(pParse, pList, pNew);  }  eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;  }else if( IsView(pTab) ){  for(i=0; i<pTab->nCol; i++){  pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));  }  eDest = SRT_Table;  }else{  eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;  pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( pLimit ){  pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));  }
#endif
 }  assert( pChanges!=0 || pParse->db->mallocFailed );  if( pChanges ){  for(i=0; i<pChanges->nExpr; i++){  pList = sqlite3ExprListAppend(pParse, pList,  sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)  );  }  }  pSelect = sqlite3SelectNew(pParse, pList,  pSrc, pWhere2, pGrp, 0, pOrderBy2, SF_UFSrcCheck|SF_IncludeHidden, pLimit2  );  if( pSelect ) pSelect->selFlags |= SF_OrderByReqd;  sqlite3SelectDestInit(&dest, eDest, iEph);  dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);  sqlite3Select(pParse, pSelect, &dest);  sqlite3SelectDelete(db, pSelect); } SQLITE_PRIVATE void sqlite3Update(  Parse *pParse,  SrcList *pTabList,  ExprList *pChanges,  Expr *pWhere,  int onError,  ExprList *pOrderBy,  Expr *pLimit,  Upsert *pUpsert ){  int i, j, k;  Table *pTab;  int addrTop = 0;  WhereInfo *pWInfo = 0;  Vdbe *v;  Index *pIdx;  Index *pPk;  int nIdx;  int nAllIdx;  int iBaseCur;  int iDataCur;  int iIdxCur;  sqlite3 *db;  int *aRegIdx = 0;  int *aXRef = 0;  u8 *aToOpen;  u8 chngPk;  u8 chngRowid;  u8 chngKey;  Expr *pRowidExpr = 0;  int iRowidExpr = -1;  AuthContext sContext;  NameContext sNC;  int iDb;  int eOnePass;  int hasFK;  int labelBreak;  int labelContinue;  int flags;
#ifndef SQLITE_OMIT_TRIGGER
 int isView;  Trigger *pTrigger;  int tmask;
#endif
 int newmask;  int iEph = 0;  int nKey = 0;  int aiCurOnePass[2];  int addrOpen = 0;  int iPk = 0;  i16 nPk = 0;  int bReplace = 0;  int bFinishSeek = 1;  int nChangeFrom = 0;  int regRowCount = 0;  int regOldRowid = 0;  int regNewRowid = 0;  int regNew = 0;  int regOld = 0;  int regRowSet = 0;  int regKey = 0;  memset(&sContext, 0, sizeof(sContext));  db = pParse->db;  if( pParse->nErr || db->mallocFailed ){  goto update_cleanup;  }  pTab = sqlite3SrcListLookup(pParse, pTabList);  if( pTab==0 ) goto update_cleanup;  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
#ifndef SQLITE_OMIT_TRIGGER
 pTrigger = sqlite3TriggersExist(pParse, pTab, TK_UPDATE, pChanges, &tmask);  isView = IsView(pTab);  assert( pTrigger || tmask==0 );
#else
# define pTrigger 0
# define isView 0
# define tmask 0
#endif
#ifdef SQLITE_OMIT_VIEW
# undef isView
# define isView 0
#endif
 nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;  assert( nChangeFrom==0 || pUpsert==0 );
#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( !isView && nChangeFrom==0 ){  pWhere = sqlite3LimitWhere(  pParse, pTabList, pWhere, pOrderBy, pLimit, "UPDATE"  );  pOrderBy = 0;  pLimit = 0;  }
#endif
 if( sqlite3ViewGetColumnNames(pParse, pTab) ){  goto update_cleanup;  }  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){  goto update_cleanup;  }  iBaseCur = iDataCur = pParse->nTab++;  iIdxCur = iDataCur+1;  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);  testcase( pPk!=0 && pPk!=pTab->pIndex );  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){  if( pPk==pIdx ){  iDataCur = pParse->nTab;  }  pParse->nTab++;  }  if( pUpsert ){  iDataCur = pUpsert->iDataCur;  iIdxCur = pUpsert->iIdxCur;  pParse->nTab = iBaseCur;  }  pTabList->a[0].iCursor = iDataCur;  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );  if( aXRef==0 ) goto update_cleanup;  aRegIdx = aXRef+pTab->nCol;  aToOpen = (u8*)(aRegIdx+nIdx+1);  memset(aToOpen, 1, nIdx+1);  aToOpen[nIdx+1] = 0;  for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  sNC.pSrcList = pTabList;  sNC.uNC.pUpsert = pUpsert;  sNC.ncFlags = NC_UUpsert;  v = sqlite3GetVdbe(pParse);  if( v==0 ) goto update_cleanup;  chngRowid = chngPk = 0;  for(i=0; i<pChanges->nExpr; i++){  u8 hCol = sqlite3StrIHash(pChanges->a[i].zEName);  if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){  goto update_cleanup;  }  for(j=0; j<pTab->nCol; j++){  if( pTab->aCol[j].hName==hCol   && sqlite3StrICmp(pTab->aCol[j].zCnName, pChanges->a[i].zEName)==0  ){  if( j==pTab->iPKey ){  chngRowid = 1;  pRowidExpr = pChanges->a[i].pExpr;  iRowidExpr = i;  }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){  chngPk = 1;  }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){  testcase( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL );  testcase( pTab->aCol[j].colFlags & COLFLAG_STORED );  sqlite3ErrorMsg(pParse,   "cannot UPDATE generated column \"%s\"",   pTab->aCol[j].zCnName);  goto update_cleanup;  }
#endif
 aXRef[j] = i;  break;  }  }  if( j>=pTab->nCol ){  if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zEName) ){  j = -1;  chngRowid = 1;  pRowidExpr = pChanges->a[i].pExpr;  iRowidExpr = i;  }else{  sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zEName);  pParse->checkSchema = 1;  goto update_cleanup;  }  }
#ifndef SQLITE_OMIT_AUTHORIZATION
 {  int rc;  rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName,  j<0 ? "ROWID" : pTab->aCol[j].zCnName,  db->aDb[iDb].zDbSName);  if( rc==SQLITE_DENY ){  goto update_cleanup;  }else if( rc==SQLITE_IGNORE ){  aXRef[j] = -1;  }  }
#endif
 }  assert( (chngRowid & chngPk)==0 );  assert( chngRowid==0 || chngRowid==1 );  assert( chngPk==0 || chngPk==1 );  chngKey = chngRowid + chngPk;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pTab->tabFlags & TF_HasGenerated ){  int bProgress;  testcase( pTab->tabFlags & TF_HasVirtual );  testcase( pTab->tabFlags & TF_HasStored );  do{  bProgress = 0;  for(i=0; i<pTab->nCol; i++){  if( aXRef[i]>=0 ) continue;  if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 ) continue;  if( sqlite3ExprReferencesUpdatedColumn(  sqlite3ColumnExpr(pTab, &pTab->aCol[i]),   aXRef, chngRowid)  ){  aXRef[i] = 99999;  bProgress = 1;  }  }  }while( bProgress );  }
#endif
 pTabList->a[0].colUsed = IsVirtual(pTab) ? ALLBITS : 0;  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);  if( onError==OE_Replace ) bReplace = 1;  for(nAllIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nAllIdx++){  int reg;  if( chngKey || hasFK>1 || pIdx==pPk   || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)  ){  reg = ++pParse->nMem;  pParse->nMem += pIdx->nColumn;  }else{  reg = 0;  for(i=0; i<pIdx->nKeyCol; i++){  if( indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid) ){  reg = ++pParse->nMem;  pParse->nMem += pIdx->nColumn;  if( onError==OE_Default && pIdx->onError==OE_Replace ){  bReplace = 1;  }  break;  }  }  }  if( reg==0 ) aToOpen[nAllIdx+1] = 0;  aRegIdx[nAllIdx] = reg;  }  aRegIdx[nAllIdx] = ++pParse->nMem;  if( bReplace ){  memset(aToOpen, 1, nIdx+1);  }  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);  sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);  if( !IsVirtual(pTab) ){  assert( aRegIdx[nAllIdx]==pParse->nMem );  regRowSet = aRegIdx[nAllIdx];  regOldRowid = regNewRowid = ++pParse->nMem;  if( chngPk || pTrigger || hasFK ){  regOld = pParse->nMem + 1;  pParse->nMem += pTab->nCol;  }  if( chngKey || pTrigger || hasFK ){  regNewRowid = ++pParse->nMem;  }  regNew = pParse->nMem + 1;  pParse->nMem += pTab->nCol;  }  if( isView ){  sqlite3AuthContextPush(pParse, &sContext, pTab->zName);  }
#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)
 if( nChangeFrom==0 && isView ){  sqlite3MaterializeView(pParse, pTab,  pWhere, pOrderBy, pLimit, iDataCur  );  pOrderBy = 0;  pLimit = 0;  }
#endif
 if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){  goto update_cleanup;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pTab) ){  updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,   pWhere, onError);  goto update_cleanup;  }
#endif
 labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);  if( (db->flags&SQLITE_CountRows)!=0   && !pParse->pTriggerTab   && !pParse->nested   && !pParse->bReturning   && pUpsert==0  ){  regRowCount = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);  }  if( nChangeFrom==0 && HasRowid(pTab) ){  sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);  iEph = pParse->nTab++;  addrOpen = sqlite3VdbeAddOp3(v, OP_OpenEphemeral, iEph, 0, regRowSet);  }else{  assert( pPk!=0 || HasRowid(pTab) );  nPk = pPk ? pPk->nKeyCol : 0;  iPk = pParse->nMem+1;  pParse->nMem += nPk;  pParse->nMem += nChangeFrom;  regKey = ++pParse->nMem;  if( pUpsert==0 ){  int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);  iEph = pParse->nTab++;  if( pPk ) sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);  addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);  if( pPk ){  KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);  if( pKeyInfo ){  pKeyInfo->nAllField = nEphCol;  sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);  }  }  if( nChangeFrom ){  updateFromSelect(  pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit  );
#ifndef SQLITE_OMIT_SUBQUERY
 if( isView ) iDataCur = iEph;
#endif
 }  }  }  if( nChangeFrom ){  sqlite3MultiWrite(pParse);  eOnePass = ONEPASS_OFF;  nKey = nPk;  regKey = iPk;  }else{  if( pUpsert ){  pWInfo = 0;  eOnePass = ONEPASS_SINGLE;  sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);  bFinishSeek = 0;  }else{  flags = WHERE_ONEPASS_DESIRED;  if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){  flags |= WHERE_ONEPASS_MULTIROW;  }  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags,iIdxCur);  if( pWInfo==0 ) goto update_cleanup;  eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);  bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);  if( eOnePass!=ONEPASS_SINGLE ){  sqlite3MultiWrite(pParse);  if( eOnePass==ONEPASS_MULTI ){  int iCur = aiCurOnePass[1];  if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){  eOnePass = ONEPASS_OFF;  }  assert( iCur!=iDataCur || !HasRowid(pTab) );  }  }  }  if( HasRowid(pTab) ){  sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);  if( eOnePass==ONEPASS_OFF ){  aRegIdx[nAllIdx] = ++pParse->nMem;  sqlite3VdbeAddOp3(v, OP_Insert, iEph, regRowSet, regOldRowid);  }else{  if( ALWAYS(addrOpen) ) sqlite3VdbeChangeToNoop(v, addrOpen);  }  }else{  for(i=0; i<nPk; i++){  assert( pPk->aiColumn[i]>=0 );  sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,  pPk->aiColumn[i], iPk+i);  }  if( eOnePass ){  if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);  nKey = nPk;  regKey = iPk;  }else{  sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,  sqlite3IndexAffinityStr(db, pPk), nPk);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);  }  }  }  if( pUpsert==0 ){  if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){  sqlite3WhereEnd(pWInfo);  }  if( !isView ){  int addrOnce = 0;  if( eOnePass!=ONEPASS_OFF ){  if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iBaseCur] = 0;  if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iBaseCur] = 0;  }  if( eOnePass==ONEPASS_MULTI && (nIdx-(aiCurOnePass[1]>=0))>0 ){  addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  }  sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, iBaseCur,   aToOpen, 0, 0);  if( addrOnce ){  sqlite3VdbeJumpHereOrPopInst(v, addrOnce);  }  }  if( eOnePass!=ONEPASS_OFF ){  if( aiCurOnePass[0]!=iDataCur   && aiCurOnePass[1]!=iDataCur
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
  && !isView
#endif
 ){  assert( pPk );  sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelBreak, regKey,nKey);  VdbeCoverage(v);  }  if( eOnePass!=ONEPASS_SINGLE ){  labelContinue = sqlite3VdbeMakeLabel(pParse);  }  sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);  VdbeCoverageIf(v, pPk==0);  VdbeCoverageIf(v, pPk!=0);  }else if( pPk || nChangeFrom ){  labelContinue = sqlite3VdbeMakeLabel(pParse);  sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);  addrTop = sqlite3VdbeCurrentAddr(v);  if( nChangeFrom ){  if( !isView ){  if( pPk ){  for(i=0; i<nPk; i++){  sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);  }  sqlite3VdbeAddOp4Int(  v, OP_NotFound, iDataCur, labelContinue, iPk, nPk  ); VdbeCoverage(v);  }else{  sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);  sqlite3VdbeAddOp3(  v, OP_NotExists, iDataCur, labelContinue, regOldRowid  ); VdbeCoverage(v);  }  }  }else{  sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);  sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);  VdbeCoverage(v);  }  }else{  sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);  labelContinue = sqlite3VdbeMakeLabel(pParse);  addrTop = sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);  VdbeCoverage(v);  }  }  assert( chngKey || pTrigger || hasFK || regOldRowid==regNewRowid );  if( chngRowid ){  assert( iRowidExpr>=0 );  if( nChangeFrom==0 ){  sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);  }else{  sqlite3VdbeAddOp3(v, OP_Column, iEph, iRowidExpr, regNewRowid);  }  sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); VdbeCoverage(v);  }  if( chngPk || hasFK || pTrigger ){  u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);  oldmask |= sqlite3TriggerColmask(pParse,  pTrigger, pChanges, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onError  );  for(i=0; i<pTab->nCol; i++){  u32 colFlags = pTab->aCol[i].colFlags;  k = sqlite3TableColumnToStorage(pTab, i) + regOld;  if( oldmask==0xffffffff   || (i<32 && (oldmask & MASKBIT32(i))!=0)   || (colFlags & COLFLAG_PRIMKEY)!=0  ){  testcase( oldmask!=0xffffffff && i==31 );  sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);  }else{  sqlite3VdbeAddOp2(v, OP_Null, 0, k);  }  }  if( chngRowid==0 && pPk==0 ){  sqlite3VdbeAddOp2(v, OP_Copy, regOldRowid, regNewRowid);  }  }  newmask = sqlite3TriggerColmask(  pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError  );  for(i=0, k=regNew; i<pTab->nCol; i++, k++){  if( i==pTab->iPKey ){  sqlite3VdbeAddOp2(v, OP_Null, 0, k);  }else if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)!=0 ){  if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;  }else{  j = aXRef[i];  if( j>=0 ){  if( nChangeFrom ){  int nOff = (isView ? pTab->nCol : nPk);  assert( eOnePass==ONEPASS_OFF );  sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);  }else{  sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);  }  }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){  testcase( i==31 );  testcase( i==32 );  sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);  bFinishSeek = 0;  }else{  sqlite3VdbeAddOp2(v, OP_Null, 0, k);  }  }  }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pTab->tabFlags & TF_HasGenerated ){  testcase( pTab->tabFlags & TF_HasVirtual );  testcase( pTab->tabFlags & TF_HasStored );  sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);  }
#endif
 if( tmask&TRIGGER_BEFORE ){  sqlite3TableAffinity(v, pTab, regNew);  sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,  TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);  if( !isView ){  if( pPk ){  sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);  VdbeCoverage(v);  }else{  sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);  VdbeCoverage(v);  }  for(i=0, k=regNew; i<pTab->nCol; i++, k++){  if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){  if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;  }else if( aXRef[i]<0 && i!=pTab->iPKey ){  sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);  }  }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 if( pTab->tabFlags & TF_HasGenerated ){  testcase( pTab->tabFlags & TF_HasVirtual );  testcase( pTab->tabFlags & TF_HasStored );  sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);  }
#endif
 }  }  if( !isView ){  assert( regOldRowid>0 );  sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,  regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,  aXRef, 0);  if( bReplace || chngKey ){  if( pPk ){  sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);  }else{  sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);  }  VdbeCoverageNeverTaken(v);  }  if( hasFK ){  sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);  }  sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);  if( bFinishSeek ){  sqlite3VdbeAddOp1(v, OP_FinishSeek, iDataCur);  }  assert( regNew==regNewRowid+1 );
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
 sqlite3VdbeAddOp3(v, OP_Delete, iDataCur,  OPFLAG_ISUPDATE | ((hasFK>1 || chngKey) ? 0 : OPFLAG_ISNOOP),  regNewRowid  );  if( eOnePass==ONEPASS_MULTI ){  assert( hasFK==0 && chngKey==0 );  sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);  }  if( !pParse->nested ){  sqlite3VdbeAppendP4(v, pTab, P4_TABLE);  }
#else
 if( hasFK>1 || chngKey ){  sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);  }
#endif
 if( hasFK ){  sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);  }  sqlite3CompleteInsertion(  pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx,  OPFLAG_ISUPDATE | (eOnePass==ONEPASS_MULTI ? OPFLAG_SAVEPOSITION : 0),  0, 0  );  if( hasFK ){  sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);  }  }  if( regRowCount ){  sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);  }  sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,  TRIGGER_AFTER, pTab, regOldRowid, onError, labelContinue);  if( eOnePass==ONEPASS_SINGLE ){  }else if( eOnePass==ONEPASS_MULTI ){  sqlite3VdbeResolveLabel(v, labelContinue);  sqlite3WhereEnd(pWInfo);  }else{  sqlite3VdbeResolveLabel(v, labelContinue);  sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);  }  sqlite3VdbeResolveLabel(v, labelBreak);  if( pParse->nested==0 && pParse->pTriggerTab==0 && pUpsert==0 ){  sqlite3AutoincrementEnd(pParse);  }  if( regRowCount ){  sqlite3VdbeAddOp2(v, OP_ChngCntRow, regRowCount, 1);  sqlite3VdbeSetNumCols(v, 1);  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, "rows updated", SQLITE_STATIC);  } update_cleanup:  sqlite3AuthContextPop(&sContext);  sqlite3DbFree(db, aXRef);  sqlite3SrcListDelete(db, pTabList);  sqlite3ExprListDelete(db, pChanges);  sqlite3ExprDelete(db, pWhere);
#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)
 sqlite3ExprListDelete(db, pOrderBy);  sqlite3ExprDelete(db, pLimit);
#endif
 return; }
#ifdef isView
 #undef isView
#endif
#ifdef pTrigger
 #undef pTrigger
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
static void updateVirtualTable(  Parse *pParse,  SrcList *pSrc,  Table *pTab,  ExprList *pChanges,  Expr *pRowid,  int *aXRef,  Expr *pWhere,  int onError ){  Vdbe *v = pParse->pVdbe;  int ephemTab;  int i;  sqlite3 *db = pParse->db;  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);  WhereInfo *pWInfo = 0;  int nArg = 2 + pTab->nCol;  int regArg;  int regRec;  int regRowid;  int iCsr = pSrc->a[0].iCursor;  int aDummy[2];  int eOnePass;  int addr;  assert( v );  ephemTab = pParse->nTab++;  addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);  regArg = pParse->nMem + 1;  pParse->nMem += nArg;  if( pSrc->nSrc>1 ){  Index *pPk = 0;  Expr *pRow;  ExprList *pList;  if( HasRowid(pTab) ){  if( pRowid ){  pRow = sqlite3ExprDup(db, pRowid, 0);  }else{  pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);  }  }else{  i16 iPk;  pPk = sqlite3PrimaryKeyIndex(pTab);  assert( pPk!=0 );  assert( pPk->nKeyCol==1 );  iPk = pPk->aiColumn[0];  if( aXRef[iPk]>=0 ){  pRow = sqlite3ExprDup(db, pChanges->a[aXRef[iPk]].pExpr, 0);  }else{  pRow = exprRowColumn(pParse, iPk);  }  }  pList = sqlite3ExprListAppend(pParse, 0, pRow);  for(i=0; i<pTab->nCol; i++){  if( aXRef[i]>=0 ){  pList = sqlite3ExprListAppend(pParse, pList,  sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)  );  }else{  pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));  }  }  updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, 0, 0);  sqlite3ExprListDelete(db, pList);  eOnePass = ONEPASS_OFF;  }else{  regRec = ++pParse->nMem;  regRowid = ++pParse->nMem;  pWInfo = sqlite3WhereBegin(pParse, pSrc,pWhere,0,0,WHERE_ONEPASS_DESIRED,0);  if( pWInfo==0 ) return;  for(i=0; i<pTab->nCol; i++){  assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );  if( aXRef[i]>=0 ){  sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);  }else{  sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);  sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG);  }  }  if( HasRowid(pTab) ){  sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);  if( pRowid ){  sqlite3ExprCode(pParse, pRowid, regArg+1);  }else{  sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);  }  }else{  Index *pPk;  i16 iPk;  pPk = sqlite3PrimaryKeyIndex(pTab);  assert( pPk!=0 );  assert( pPk->nKeyCol==1 );  iPk = pPk->aiColumn[0];  sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);  sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);  }  eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);  assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );  if( eOnePass ){  sqlite3VdbeChangeToNoop(v, addr);  sqlite3VdbeAddOp1(v, OP_Close, iCsr);  }else{  sqlite3MultiWrite(pParse);  sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);
#if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)
 sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);
#endif
 sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);  sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);  }  }  if( eOnePass==ONEPASS_OFF ){  if( pSrc->nSrc==1 ){  sqlite3WhereEnd(pWInfo);  }  addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);  for(i=0; i<nArg; i++){  sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i, regArg+i);  }  }  sqlite3VtabMakeWritable(pParse, pTab);  sqlite3VdbeAddOp4(v, OP_VUpdate, 0, nArg, regArg, pVTab, P4_VTAB);  sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);  sqlite3MayAbort(pParse);  if( eOnePass==ONEPASS_OFF ){  sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1); VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addr);  sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);  }else{  sqlite3WhereEnd(pWInfo);  } }
#endif
#ifndef SQLITE_OMIT_UPSERT
static void SQLITE_NOINLINE upsertDelete(sqlite3 *db, Upsert *p){  do{  Upsert *pNext = p->pNextUpsert;  sqlite3ExprListDelete(db, p->pUpsertTarget);  sqlite3ExprDelete(db, p->pUpsertTargetWhere);  sqlite3ExprListDelete(db, p->pUpsertSet);  sqlite3ExprDelete(db, p->pUpsertWhere);  sqlite3DbFree(db, p->pToFree);  sqlite3DbFree(db, p);  p = pNext;  }while( p ); } SQLITE_PRIVATE void sqlite3UpsertDelete(sqlite3 *db, Upsert *p){  if( p ) upsertDelete(db, p); } SQLITE_PRIVATE Upsert *sqlite3UpsertDup(sqlite3 *db, Upsert *p){  if( p==0 ) return 0;  return sqlite3UpsertNew(db,   sqlite3ExprListDup(db, p->pUpsertTarget, 0),   sqlite3ExprDup(db, p->pUpsertTargetWhere, 0),   sqlite3ExprListDup(db, p->pUpsertSet, 0),   sqlite3ExprDup(db, p->pUpsertWhere, 0),   sqlite3UpsertDup(db, p->pNextUpsert)   ); } SQLITE_PRIVATE Upsert *sqlite3UpsertNew(  sqlite3 *db,  ExprList *pTarget,  Expr *pTargetWhere,  ExprList *pSet,  Expr *pWhere,  Upsert *pNext ){  Upsert *pNew;  pNew = sqlite3DbMallocZero(db, sizeof(Upsert));  if( pNew==0 ){  sqlite3ExprListDelete(db, pTarget);  sqlite3ExprDelete(db, pTargetWhere);  sqlite3ExprListDelete(db, pSet);  sqlite3ExprDelete(db, pWhere);  sqlite3UpsertDelete(db, pNext);  return 0;  }else{  pNew->pUpsertTarget = pTarget;  pNew->pUpsertTargetWhere = pTargetWhere;  pNew->pUpsertSet = pSet;  pNew->pUpsertWhere = pWhere;  pNew->isDoUpdate = pSet!=0;  pNew->pNextUpsert = pNext;  }  return pNew; } SQLITE_PRIVATE int sqlite3UpsertAnalyzeTarget(  Parse *pParse,  SrcList *pTabList,  Upsert *pUpsert ){  Table *pTab;  int rc;  int iCursor;  Index *pIdx;  ExprList *pTarget;  Expr *pTerm;  NameContext sNC;  Expr sCol[2];  int nClause = 0;  assert( pTabList->nSrc==1 );  assert( pTabList->a[0].pTab!=0 );  assert( pUpsert!=0 );  assert( pUpsert->pUpsertTarget!=0 );  memset(&sNC, 0, sizeof(sNC));  sNC.pParse = pParse;  sNC.pSrcList = pTabList;  for(; pUpsert && pUpsert->pUpsertTarget;  pUpsert=pUpsert->pNextUpsert, nClause++){  rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);  if( rc ) return rc;  rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);  if( rc ) return rc;  pTab = pTabList->a[0].pTab;  pTarget = pUpsert->pUpsertTarget;  iCursor = pTabList->a[0].iCursor;  if( HasRowid(pTab)   && pTarget->nExpr==1   && (pTerm = pTarget->a[0].pExpr)->op==TK_COLUMN   && pTerm->iColumn==XN_ROWID  ){  assert( pUpsert->pUpsertIdx==0 );  continue;  }  memset(sCol, 0, sizeof(sCol));  sCol[0].op = TK_COLLATE;  sCol[0].pLeft = &sCol[1];  sCol[1].op = TK_COLUMN;  sCol[1].iTable = pTabList->a[0].iCursor;  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  int ii, jj, nn;  if( !IsUniqueIndex(pIdx) ) continue;  if( pTarget->nExpr!=pIdx->nKeyCol ) continue;  if( pIdx->pPartIdxWhere ){  if( pUpsert->pUpsertTargetWhere==0 ) continue;  if( sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere,   pIdx->pPartIdxWhere, iCursor)!=0 ){  continue;  }  }  nn = pIdx->nKeyCol;  for(ii=0; ii<nn; ii++){  Expr *pExpr;  sCol[0].u.zToken = (char*)pIdx->azColl[ii];  if( pIdx->aiColumn[ii]==XN_EXPR ){  assert( pIdx->aColExpr!=0 );  assert( pIdx->aColExpr->nExpr>ii );  pExpr = pIdx->aColExpr->a[ii].pExpr;  if( pExpr->op!=TK_COLLATE ){  sCol[0].pLeft = pExpr;  pExpr = &sCol[0];  }  }else{  sCol[0].pLeft = &sCol[1];  sCol[1].iColumn = pIdx->aiColumn[ii];  pExpr = &sCol[0];  }  for(jj=0; jj<nn; jj++){  if( sqlite3ExprCompare(pParse,pTarget->a[jj].pExpr,pExpr,iCursor)<2 ){  break;  }  }  if( jj>=nn ){  break;  }  }  if( ii<nn ){  continue;  }  pUpsert->pUpsertIdx = pIdx;  break;  }  if( pUpsert->pUpsertIdx==0 ){  char zWhich[16];  if( nClause==0 && pUpsert->pNextUpsert==0 ){  zWhich[0] = 0;  }else{  sqlite3_snprintf(sizeof(zWhich),zWhich,"%r ", nClause+1);  }  sqlite3ErrorMsg(pParse, "%sON CONFLICT clause does not match any "  "PRIMARY KEY or UNIQUE constraint", zWhich);  return SQLITE_ERROR;  }  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3UpsertNextIsIPK(Upsert *pUpsert){  Upsert *pNext;  if( NEVER(pUpsert==0) ) return 0;  pNext = pUpsert->pNextUpsert;  if( pNext==0 ) return 1;  if( pNext->pUpsertTarget==0 ) return 1;  if( pNext->pUpsertIdx==0 ) return 1;  return 0; } SQLITE_PRIVATE Upsert *sqlite3UpsertOfIndex(Upsert *pUpsert, Index *pIdx){  while(  pUpsert   && pUpsert->pUpsertTarget!=0   && pUpsert->pUpsertIdx!=pIdx  ){   pUpsert = pUpsert->pNextUpsert;  }  return pUpsert; } SQLITE_PRIVATE void sqlite3UpsertDoUpdate(  Parse *pParse,  Upsert *pUpsert,  Table *pTab,  Index *pIdx,  int iCur ){  Vdbe *v = pParse->pVdbe;  sqlite3 *db = pParse->db;  SrcList *pSrc;  int iDataCur;  int i;  Upsert *pTop = pUpsert;  assert( v!=0 );  assert( pUpsert!=0 );  iDataCur = pUpsert->iDataCur;  pUpsert = sqlite3UpsertOfIndex(pTop, pIdx);  VdbeNoopComment((v, "Begin DO UPDATE of UPSERT"));  if( pIdx && iCur!=iDataCur ){  if( HasRowid(pTab) ){  int regRowid = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_IdxRowid, iCur, regRowid);  sqlite3VdbeAddOp3(v, OP_SeekRowid, iDataCur, 0, regRowid);  VdbeCoverage(v);  sqlite3ReleaseTempReg(pParse, regRowid);  }else{  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  int nPk = pPk->nKeyCol;  int iPk = pParse->nMem+1;  pParse->nMem += nPk;  for(i=0; i<nPk; i++){  int k;  assert( pPk->aiColumn[i]>=0 );  k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[i]);  sqlite3VdbeAddOp3(v, OP_Column, iCur, k, iPk+i);  VdbeComment((v, "%s.%s", pIdx->zName,  pTab->aCol[pPk->aiColumn[i]].zCnName));  }  sqlite3VdbeVerifyAbortable(v, OE_Abort);  i = sqlite3VdbeAddOp4Int(v, OP_Found, iDataCur, 0, iPk, nPk);  VdbeCoverage(v);  sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CORRUPT, OE_Abort, 0,  "corrupt database", P4_STATIC);  sqlite3MayAbort(pParse);  sqlite3VdbeJumpHere(v, i);  }  }  pSrc = sqlite3SrcListDup(db, pTop->pUpsertSrc, 0);  for(i=0; i<pTab->nCol; i++){  if( pTab->aCol[i].affinity==SQLITE_AFF_REAL ){  sqlite3VdbeAddOp1(v, OP_RealAffinity, pTop->regData+i);  }  }  sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db,pUpsert->pUpsertSet,0),  sqlite3ExprDup(db,pUpsert->pUpsertWhere,0), OE_Abort, 0, 0, pUpsert);  VdbeNoopComment((v, "End DO UPDATE of UPSERT")); }
#endif
#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)
static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){  sqlite3_stmt *pStmt;  int rc;  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);  if( rc!=SQLITE_OK ) return rc;  while( SQLITE_ROW==(rc = sqlite3_step(pStmt)) ){  const char *zSubSql = (const char*)sqlite3_column_text(pStmt,0);  assert( sqlite3_strnicmp(zSql,"SELECT",6)==0 );  if( zSubSql   && (strncmp(zSubSql,"CRE",3)==0 || strncmp(zSubSql,"INS",3)==0)  ){  rc = execSql(db, pzErrMsg, zSubSql);  if( rc!=SQLITE_OK ) break;  }  }  assert( rc!=SQLITE_ROW );  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  if( rc ){  sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));  }  (void)sqlite3_finalize(pStmt);  return rc; } static int execSqlF(sqlite3 *db, char **pzErrMsg, const char *zSql, ...){  char *z;  va_list ap;  int rc;  va_start(ap, zSql);  z = sqlite3VMPrintf(db, zSql, ap);  va_end(ap);  if( z==0 ) return SQLITE_NOMEM;  rc = execSql(db, pzErrMsg, z);  sqlite3DbFree(db, z);  return rc; } SQLITE_PRIVATE void sqlite3Vacuum(Parse *pParse, Token *pNm, Expr *pInto){  Vdbe *v = sqlite3GetVdbe(pParse);  int iDb = 0;  if( v==0 ) goto build_vacuum_end;  if( pParse->nErr ) goto build_vacuum_end;  if( pNm ){
#ifndef SQLITE_BUG_COMPATIBLE_20160819
 iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);  if( iDb<0 ) goto build_vacuum_end;
#else
 iDb = sqlite3FindDb(pParse->db, pNm);  if( iDb<0 ) iDb = 0;
#endif
 }  if( iDb!=1 ){  int iIntoReg = 0;  if( pInto && sqlite3ResolveSelfReference(pParse,0,0,pInto,0)==0 ){  iIntoReg = ++pParse->nMem;  sqlite3ExprCode(pParse, pInto, iIntoReg);  }  sqlite3VdbeAddOp2(v, OP_Vacuum, iDb, iIntoReg);  sqlite3VdbeUsesBtree(v, iDb);  } build_vacuum_end:  sqlite3ExprDelete(pParse->db, pInto);  return; } SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3RunVacuum(  char **pzErrMsg,  sqlite3 *db,  int iDb,  sqlite3_value *pOut ){  int rc = SQLITE_OK;  Btree *pMain;  Btree *pTemp;  u32 saved_mDbFlags;  u64 saved_flags;  i64 saved_nChange;  i64 saved_nTotalChange;  u32 saved_openFlags;  u8 saved_mTrace;  Db *pDb = 0;  int isMemDb;  int nRes;  int nDb;  const char *zDbMain;  const char *zOut;  if( !db->autoCommit ){  sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");  return SQLITE_ERROR;  }  if( db->nVdbeActive>1 ){  sqlite3SetString(pzErrMsg, db,"cannot VACUUM - SQL statements in progress");  return SQLITE_ERROR;  }  saved_openFlags = db->openFlags;  if( pOut ){  if( sqlite3_value_type(pOut)!=SQLITE_TEXT ){  sqlite3SetString(pzErrMsg, db, "non-text filename");  return SQLITE_ERROR;  }  zOut = (const char*)sqlite3_value_text(pOut);  db->openFlags &= ~SQLITE_OPEN_READONLY;  db->openFlags |= SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE;  }else{  zOut = "";  }  saved_flags = db->flags;  saved_mDbFlags = db->mDbFlags;  saved_nChange = db->nChange;  saved_nTotalChange = db->nTotalChange;  saved_mTrace = db->mTrace;  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks;  db->mDbFlags |= DBFLAG_PreferBuiltin | DBFLAG_Vacuum;  db->flags &= ~(u64)(SQLITE_ForeignKeys | SQLITE_ReverseOrder   | SQLITE_Defensive | SQLITE_CountRows);  db->mTrace = 0;  zDbMain = db->aDb[iDb].zDbSName;  pMain = db->aDb[iDb].pBt;  isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));  nDb = db->nDb;  rc = execSqlF(db, pzErrMsg, "ATTACH %Q AS vacuum_db", zOut);  db->openFlags = saved_openFlags;  if( rc!=SQLITE_OK ) goto end_of_vacuum;  assert( (db->nDb-1)==nDb );  pDb = &db->aDb[nDb];  assert( strcmp(pDb->zDbSName,"vacuum_db")==0 );  pTemp = pDb->pBt;  if( pOut ){  sqlite3_file *id = sqlite3PagerFile(sqlite3BtreePager(pTemp));  i64 sz = 0;  if( id->pMethods!=0 && (sqlite3OsFileSize(id, &sz)!=SQLITE_OK || sz>0) ){  rc = SQLITE_ERROR;  sqlite3SetString(pzErrMsg, db, "output file already exists");  goto end_of_vacuum;  }  db->mDbFlags |= DBFLAG_VacuumInto;  }  nRes = sqlite3BtreeGetRequestedReserve(pMain);  sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);  sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain,0));  sqlite3BtreeSetPagerFlags(pTemp, PAGER_SYNCHRONOUS_OFF|PAGER_CACHESPILL);  rc = execSql(db, pzErrMsg, "BEGIN");  if( rc!=SQLITE_OK ) goto end_of_vacuum;  rc = sqlite3BtreeBeginTrans(pMain, pOut==0 ? 2 : 0, 0);  if( rc!=SQLITE_OK ) goto end_of_vacuum;  if( sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))   ==PAGER_JOURNALMODE_WAL   && pOut==0  ){  db->nextPagesize = 0;  }  if( sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0)   || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0))   || NEVER(db->mallocFailed)  ){  rc = SQLITE_NOMEM_BKPT;  goto end_of_vacuum;  }
#ifndef SQLITE_OMIT_AUTOVACUUM
 sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac>=0 ? db->nextAutovac :   sqlite3BtreeGetAutoVacuum(pMain));
#endif
 db->init.iDb = nDb;  rc = execSqlF(db, pzErrMsg,  "SELECT sql FROM \"%w\".sqlite_schema"  " WHERE type='table'AND name<>'sqlite_sequence'"  " AND coalesce(rootpage,1)>0",  zDbMain  );  if( rc!=SQLITE_OK ) goto end_of_vacuum;  rc = execSqlF(db, pzErrMsg,  "SELECT sql FROM \"%w\".sqlite_schema"  " WHERE type='index'",  zDbMain  );  if( rc!=SQLITE_OK ) goto end_of_vacuum;  db->init.iDb = 0;  rc = execSqlF(db, pzErrMsg,  "SELECT'INSERT INTO vacuum_db.'||quote(name)"  "||' SELECT*FROM\"%w\".'||quote(name)"  "FROM vacuum_db.sqlite_schema "  "WHERE type='table'AND coalesce(rootpage,1)>0",  zDbMain  );  assert( (db->mDbFlags & DBFLAG_Vacuum)!=0 );  db->mDbFlags &= ~DBFLAG_Vacuum;  if( rc!=SQLITE_OK ) goto end_of_vacuum;  rc = execSqlF(db, pzErrMsg,  "INSERT INTO vacuum_db.sqlite_schema"  " SELECT*FROM \"%w\".sqlite_schema"  " WHERE type IN('view','trigger')"  " OR(type='table'AND rootpage=0)",  zDbMain  );  if( rc ) goto end_of_vacuum;  {  u32 meta;  int i;  static const unsigned char aCopy[] = {   BTREE_SCHEMA_VERSION, 1,   BTREE_DEFAULT_CACHE_SIZE, 0,   BTREE_TEXT_ENCODING, 0,   BTREE_USER_VERSION, 0,   BTREE_APPLICATION_ID, 0,  };  assert( SQLITE_TXN_WRITE==sqlite3BtreeTxnState(pTemp) );  assert( pOut!=0 || SQLITE_TXN_WRITE==sqlite3BtreeTxnState(pMain) );  for(i=0; i<ArraySize(aCopy); i+=2){  sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);  rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta+aCopy[i+1]);  if( NEVER(rc!=SQLITE_OK) ) goto end_of_vacuum;  }  if( pOut==0 ){  rc = sqlite3BtreeCopyFile(pMain, pTemp);  }  if( rc!=SQLITE_OK ) goto end_of_vacuum;  rc = sqlite3BtreeCommit(pTemp);  if( rc!=SQLITE_OK ) goto end_of_vacuum;
#ifndef SQLITE_OMIT_AUTOVACUUM
 if( pOut==0 ){  sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));  }
#endif
 }  assert( rc==SQLITE_OK );  if( pOut==0 ){  rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);  } end_of_vacuum:  db->init.iDb = 0;  db->mDbFlags = saved_mDbFlags;  db->flags = saved_flags;  db->nChange = saved_nChange;  db->nTotalChange = saved_nTotalChange;  db->mTrace = saved_mTrace;  sqlite3BtreeSetPageSize(pMain, -1, 0, 1);  db->autoCommit = 1;  if( pDb ){  sqlite3BtreeClose(pDb->pBt);  pDb->pBt = 0;  pDb->pSchema = 0;  }  sqlite3ResetAllSchemasOfConnection(db);  return rc; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
struct VtabCtx {  VTable *pVTable;  Table *pTab;  VtabCtx *pPrior;  int bDeclared; }; SQLITE_PRIVATE Module *sqlite3VtabCreateModule(  sqlite3 *db,  const char *zName,  const sqlite3_module *pModule,  void *pAux,  void (*xDestroy)(void *) ){  Module *pMod;  Module *pDel;  char *zCopy;  if( pModule==0 ){  zCopy = (char*)zName;  pMod = 0;  }else{  int nName = sqlite3Strlen30(zName);  pMod = (Module *)sqlite3Malloc(sizeof(Module) + nName + 1);  if( pMod==0 ){  sqlite3OomFault(db);  return 0;  }  zCopy = (char *)(&pMod[1]);  memcpy(zCopy, zName, nName+1);  pMod->zName = zCopy;  pMod->pModule = pModule;  pMod->pAux = pAux;  pMod->xDestroy = xDestroy;  pMod->pEpoTab = 0;  pMod->nRefModule = 1;  }  pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);  if( pDel ){  if( pDel==pMod ){  sqlite3OomFault(db);  sqlite3DbFree(db, pDel);  pMod = 0;  }else{  sqlite3VtabEponymousTableClear(db, pDel);  sqlite3VtabModuleUnref(db, pDel);  }  }  return pMod; } static int createModule(  sqlite3 *db,  const char *zName,  const sqlite3_module *pModule,  void *pAux,  void (*xDestroy)(void *) ){  int rc = SQLITE_OK;  sqlite3_mutex_enter(db->mutex);  (void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);  rc = sqlite3ApiExit(db, rc);  if( rc!=SQLITE_OK && xDestroy ) xDestroy(pAux);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_create_module(  sqlite3 *db,  const char *zName,  const sqlite3_module *pModule,  void *pAux ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
#endif
 return createModule(db, zName, pModule, pAux, 0); } SQLITE_API int sqlite3_create_module_v2(  sqlite3 *db,  const char *zName,  const sqlite3_module *pModule,  void *pAux,  void (*xDestroy)(void *) ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
#endif
 return createModule(db, zName, pModule, pAux, xDestroy); } SQLITE_API int sqlite3_drop_modules(sqlite3 *db, const char** azNames){  HashElem *pThis, *pNext;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 for(pThis=sqliteHashFirst(&db->aModule); pThis; pThis=pNext){  Module *pMod = (Module*)sqliteHashData(pThis);  pNext = sqliteHashNext(pThis);  if( azNames ){  int ii;  for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}  if( azNames[ii]!=0 ) continue;  }  createModule(db, pMod->zName, 0, 0, 0);  }  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3VtabModuleUnref(sqlite3 *db, Module *pMod){  assert( pMod->nRefModule>0 );  pMod->nRefModule--;  if( pMod->nRefModule==0 ){  if( pMod->xDestroy ){  pMod->xDestroy(pMod->pAux);  }  assert( pMod->pEpoTab==0 );  sqlite3DbFree(db, pMod);  } } SQLITE_PRIVATE void sqlite3VtabLock(VTable *pVTab){  pVTab->nRef++; } SQLITE_PRIVATE VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){  VTable *pVtab;  assert( IsVirtual(pTab) );  for(pVtab=pTab->u.vtab.p; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);  return pVtab; } SQLITE_PRIVATE void sqlite3VtabUnlock(VTable *pVTab){  sqlite3 *db = pVTab->db;  assert( db );  assert( pVTab->nRef>0 );  assert( db->eOpenState==SQLITE_STATE_OPEN   || db->eOpenState==SQLITE_STATE_ZOMBIE );  pVTab->nRef--;  if( pVTab->nRef==0 ){  sqlite3_vtab *p = pVTab->pVtab;  sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);  if( p ){  p->pModule->xDisconnect(p);  }  sqlite3DbFree(db, pVTab);  } } static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){  VTable *pRet = 0;  VTable *pVTable;  assert( IsVirtual(p) );  pVTable = p->u.vtab.p;  p->u.vtab.p = 0;  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema) );  while( pVTable ){  sqlite3 *db2 = pVTable->db;  VTable *pNext = pVTable->pNext;  assert( db2 );  if( db2==db ){  pRet = pVTable;  p->u.vtab.p = pRet;  pRet->pNext = 0;  }else{  pVTable->pNext = db2->pDisconnect;  db2->pDisconnect = pVTable;  }  pVTable = pNext;  }  assert( !db || pRet );  return pRet; } SQLITE_PRIVATE void sqlite3VtabDisconnect(sqlite3 *db, Table *p){  VTable **ppVTab;  assert( IsVirtual(p) );  assert( sqlite3BtreeHoldsAllMutexes(db) );  assert( sqlite3_mutex_held(db->mutex) );  for(ppVTab=&p->u.vtab.p; *ppVTab; ppVTab=&(*ppVTab)->pNext){  if( (*ppVTab)->db==db ){  VTable *pVTab = *ppVTab;  *ppVTab = pVTab->pNext;  sqlite3VtabUnlock(pVTab);  break;  }  } } SQLITE_PRIVATE void sqlite3VtabUnlockList(sqlite3 *db){  VTable *p = db->pDisconnect;  assert( sqlite3BtreeHoldsAllMutexes(db) );  assert( sqlite3_mutex_held(db->mutex) );  if( p ){  db->pDisconnect = 0;  sqlite3ExpirePreparedStatements(db, 0);  do {  VTable *pNext = p->pNext;  sqlite3VtabUnlock(p);  p = pNext;  }while( p );  } } SQLITE_PRIVATE void sqlite3VtabClear(sqlite3 *db, Table *p){  assert( IsVirtual(p) );  if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);  if( p->u.vtab.azArg ){  int i;  for(i=0; i<p->u.vtab.nArg; i++){  if( i!=1 ) sqlite3DbFree(db, p->u.vtab.azArg[i]);  }  sqlite3DbFree(db, p->u.vtab.azArg);  } } static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){  sqlite3_int64 nBytes;  char **azModuleArg;  sqlite3 *db = pParse->db;  assert( IsVirtual(pTable) );  nBytes = sizeof(char *)*(2+pTable->u.vtab.nArg);  if( pTable->u.vtab.nArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){  sqlite3ErrorMsg(pParse, "too many columns on %s", pTable->zName);  }  azModuleArg = sqlite3DbRealloc(db, pTable->u.vtab.azArg, nBytes);  if( azModuleArg==0 ){  sqlite3DbFree(db, zArg);  }else{  int i = pTable->u.vtab.nArg++;  azModuleArg[i] = zArg;  azModuleArg[i+1] = 0;  pTable->u.vtab.azArg = azModuleArg;  } } SQLITE_PRIVATE void sqlite3VtabBeginParse(  Parse *pParse,  Token *pName1,  Token *pName2,  Token *pModuleName,  int ifNotExists ){  Table *pTable;  sqlite3 *db;  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);  pTable = pParse->pNewTable;  if( pTable==0 ) return;  assert( 0==pTable->pIndex );  pTable->eTabType = TABTYP_VTAB;  db = pParse->db;  assert( pTable->u.vtab.nArg==0 );  addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));  addModuleArgument(pParse, pTable, 0);  addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable->zName));  assert( (pParse->sNameToken.z==pName2->z && pName2->z!=0)   || (pParse->sNameToken.z==pName1->z && pName2->z==0)  );  pParse->sNameToken.n = (int)(  &pModuleName->z[pModuleName->n] - pParse->sNameToken.z  );
#ifndef SQLITE_OMIT_AUTHORIZATION
 if( pTable->u.vtab.azArg ){  int iDb = sqlite3SchemaToIndex(db, pTable->pSchema);  assert( iDb>=0 );  sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName,  pTable->u.vtab.azArg[0], pParse->db->aDb[iDb].zDbSName);  }
#endif
} static void addArgumentToVtab(Parse *pParse){  if( pParse->sArg.z && pParse->pNewTable ){  const char *z = (const char*)pParse->sArg.z;  int n = pParse->sArg.n;  sqlite3 *db = pParse->db;  addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));  } } SQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){  Table *pTab = pParse->pNewTable;  sqlite3 *db = pParse->db;  if( pTab==0 ) return;  assert( IsVirtual(pTab) );  addArgumentToVtab(pParse);  pParse->sArg.z = 0;  if( pTab->u.vtab.nArg<1 ) return;  if( !db->init.busy ){  char *zStmt;  char *zWhere;  int iDb;  int iReg;  Vdbe *v;  sqlite3MayAbort(pParse);  if( pEnd ){  pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;  }  zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken);  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  sqlite3NestedParse(pParse,  "UPDATE %Q." LEGACY_SCHEMA_TABLE " "   "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "   "WHERE rowid=#%d",  db->aDb[iDb].zDbSName,  pTab->zName,  pTab->zName,  zStmt,  pParse->regRowid  );  v = sqlite3GetVdbe(pParse);  sqlite3ChangeCookie(pParse, iDb);  sqlite3VdbeAddOp0(v, OP_Expire);  zWhere = sqlite3MPrintf(db, "name=%Q AND sql=%Q", pTab->zName, zStmt);  sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere, 0);  sqlite3DbFree(db, zStmt);  iReg = ++pParse->nMem;  sqlite3VdbeLoadString(v, iReg, pTab->zName);  sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);  }else{  Table *pOld;  Schema *pSchema = pTab->pSchema;  const char *zName = pTab->zName;  assert( zName!=0 );  sqlite3MarkAllShadowTablesOf(db, pTab);  pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);  if( pOld ){  sqlite3OomFault(db);  assert( pTab==pOld );  return;  }  pParse->pNewTable = 0;  } } SQLITE_PRIVATE void sqlite3VtabArgInit(Parse *pParse){  addArgumentToVtab(pParse);  pParse->sArg.z = 0;  pParse->sArg.n = 0; } SQLITE_PRIVATE void sqlite3VtabArgExtend(Parse *pParse, Token *p){  Token *pArg = &pParse->sArg;  if( pArg->z==0 ){  pArg->z = p->z;  pArg->n = p->n;  }else{  assert(pArg->z <= p->z);  pArg->n = (int)(&p->z[p->n] - pArg->z);  } } static int vtabCallConstructor(  sqlite3 *db,  Table *pTab,  Module *pMod,  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),  char **pzErr ){  VtabCtx sCtx;  VTable *pVTable;  int rc;  const char *const*azArg;  int nArg = pTab->u.vtab.nArg;  char *zErr = 0;  char *zModuleName;  int iDb;  VtabCtx *pCtx;  assert( IsVirtual(pTab) );  azArg = (const char *const*)pTab->u.vtab.azArg;  for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){  if( pCtx->pTab==pTab ){  *pzErr = sqlite3MPrintf(db,  "vtable constructor called recursively: %s", pTab->zName  );  return SQLITE_LOCKED;  }  }  zModuleName = sqlite3DbStrDup(db, pTab->zName);  if( !zModuleName ){  return SQLITE_NOMEM_BKPT;  }  pVTable = sqlite3MallocZero(sizeof(VTable));  if( !pVTable ){  sqlite3OomFault(db);  sqlite3DbFree(db, zModuleName);  return SQLITE_NOMEM_BKPT;  }  pVTable->db = db;  pVTable->pMod = pMod;  pVTable->eVtabRisk = SQLITE_VTABRISK_Normal;  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  pTab->u.vtab.azArg[1] = db->aDb[iDb].zDbSName;  assert( &db->pVtabCtx );  assert( xConstruct );  sCtx.pTab = pTab;  sCtx.pVTable = pVTable;  sCtx.pPrior = db->pVtabCtx;  sCtx.bDeclared = 0;  db->pVtabCtx = &sCtx;  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);  db->pVtabCtx = sCtx.pPrior;  if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);  assert( sCtx.pTab==pTab );  if( SQLITE_OK!=rc ){  if( zErr==0 ){  *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);  }else {  *pzErr = sqlite3MPrintf(db, "%s", zErr);  sqlite3_free(zErr);  }  sqlite3DbFree(db, pVTable);  }else if( ALWAYS(pVTable->pVtab) ){  memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));  pVTable->pVtab->pModule = pMod->pModule;  pMod->nRefModule++;  pVTable->nRef = 1;  if( sCtx.bDeclared==0 ){  const char *zFormat = "vtable constructor did not declare schema: %s";  *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);  sqlite3VtabUnlock(pVTable);  rc = SQLITE_ERROR;  }else{  int iCol;  u16 oooHidden = 0;  pVTable->pNext = pTab->u.vtab.p;  pTab->u.vtab.p = pVTable;  for(iCol=0; iCol<pTab->nCol; iCol++){  char *zType = sqlite3ColumnType(&pTab->aCol[iCol], "");  int nType;  int i = 0;  nType = sqlite3Strlen30(zType);  for(i=0; i<nType; i++){  if( 0==sqlite3StrNICmp("hidden", &zType[i], 6)   && (i==0 || zType[i-1]==' ')   && (zType[i+6]=='\0' || zType[i+6]==' ')  ){  break;  }  }  if( i<nType ){  int j;  int nDel = 6 + (zType[i+6] ? 1 : 0);  for(j=i; (j+nDel)<=nType; j++){  zType[j] = zType[j+nDel];  }  if( zType[i]=='\0' && i>0 ){  assert(zType[i-1]==' ');  zType[i-1] = '\0';  }  pTab->aCol[iCol].colFlags |= COLFLAG_HIDDEN;  pTab->tabFlags |= TF_HasHidden;  oooHidden = TF_OOOHidden;  }else{  pTab->tabFlags |= oooHidden;  }  }  }  }  sqlite3DbFree(db, zModuleName);  return rc; } SQLITE_PRIVATE int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){  sqlite3 *db = pParse->db;  const char *zMod;  Module *pMod;  int rc;  assert( pTab );  assert( IsVirtual(pTab) );  if( sqlite3GetVTable(db, pTab) ){  return SQLITE_OK;  }  zMod = pTab->u.vtab.azArg[0];  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);  if( !pMod ){  const char *zModule = pTab->u.vtab.azArg[0];  sqlite3ErrorMsg(pParse, "no such module: %s", zModule);  rc = SQLITE_ERROR;  }else{  char *zErr = 0;  rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);  if( rc!=SQLITE_OK ){  sqlite3ErrorMsg(pParse, "%s", zErr);  pParse->rc = rc;  }  sqlite3DbFree(db, zErr);  }  return rc; } static int growVTrans(sqlite3 *db){  const int ARRAY_INCR = 5;  if( (db->nVTrans%ARRAY_INCR)==0 ){  VTable **aVTrans;  sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*   ((sqlite3_int64)db->nVTrans + ARRAY_INCR);  aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);  if( !aVTrans ){  return SQLITE_NOMEM_BKPT;  }  memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);  db->aVTrans = aVTrans;  }  return SQLITE_OK; } static void addToVTrans(sqlite3 *db, VTable *pVTab){  db->aVTrans[db->nVTrans++] = pVTab;  sqlite3VtabLock(pVTab); } SQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){  int rc = SQLITE_OK;  Table *pTab;  Module *pMod;  const char *zMod;  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);  assert( pTab && IsVirtual(pTab) && !pTab->u.vtab.p );  zMod = pTab->u.vtab.azArg[0];  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);  if( pMod==0 || pMod->pModule->xCreate==0 || pMod->pModule->xDestroy==0 ){  *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);  rc = SQLITE_ERROR;  }else{  rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);  }  if( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab)) ){  rc = growVTrans(db);  if( rc==SQLITE_OK ){  addToVTrans(db, sqlite3GetVTable(db, pTab));  }  }  return rc; } SQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){  VtabCtx *pCtx;  int rc = SQLITE_OK;  Table *pTab;  char *zErr = 0;  Parse sParse;  int initBusy;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zCreateTable==0 ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pCtx = db->pVtabCtx;  if( !pCtx || pCtx->bDeclared ){  sqlite3Error(db, SQLITE_MISUSE);  sqlite3_mutex_leave(db->mutex);  return SQLITE_MISUSE_BKPT;  }  pTab = pCtx->pTab;  assert( IsVirtual(pTab) );  memset(&sParse, 0, sizeof(sParse));  sParse.eParseMode = PARSE_MODE_DECLARE_VTAB;  sParse.db = db;  assert( db->init.busy==0 );  initBusy = db->init.busy;  db->init.busy = 0;  sParse.nQueryLoop = 1;  if( SQLITE_OK==sqlite3RunParser(&sParse, zCreateTable, &zErr)   && sParse.pNewTable   && !db->mallocFailed   && IsOrdinaryTable(sParse.pNewTable)  ){  if( !pTab->aCol ){  Table *pNew = sParse.pNewTable;  Index *pIdx;  pTab->aCol = pNew->aCol;  sqlite3ExprListDelete(db, pNew->u.tab.pDfltList);  pTab->nNVCol = pTab->nCol = pNew->nCol;  pTab->tabFlags |= pNew->tabFlags & (TF_WithoutRowid|TF_NoVisibleRowid);  pNew->nCol = 0;  pNew->aCol = 0;  assert( pTab->pIndex==0 );  assert( HasRowid(pNew) || sqlite3PrimaryKeyIndex(pNew)!=0 );  if( !HasRowid(pNew)   && pCtx->pVTable->pMod->pModule->xUpdate!=0   && sqlite3PrimaryKeyIndex(pNew)->nKeyCol!=1  ){  rc = SQLITE_ERROR;  }  pIdx = pNew->pIndex;  if( pIdx ){  assert( pIdx->pNext==0 );  pTab->pIndex = pIdx;  pNew->pIndex = 0;  pIdx->pTable = pTab;  }  }  pCtx->bDeclared = 1;  }else{  sqlite3ErrorWithMsg(db, SQLITE_ERROR, (zErr ? "%s" : 0), zErr);  sqlite3DbFree(db, zErr);  rc = SQLITE_ERROR;  }  sParse.eParseMode = PARSE_MODE_NORMAL;  if( sParse.pVdbe ){  sqlite3VdbeFinalize(sParse.pVdbe);  }  sqlite3DeleteTable(db, sParse.pNewTable);  sqlite3ParserReset(&sParse);  db->init.busy = initBusy;  assert( (rc&0xff)==rc );  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){  int rc = SQLITE_OK;  Table *pTab;  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);  if( ALWAYS(pTab!=0)   && ALWAYS(IsVirtual(pTab))   && ALWAYS(pTab->u.vtab.p!=0)  ){  VTable *p;  int (*xDestroy)(sqlite3_vtab *);  for(p=pTab->u.vtab.p; p; p=p->pNext){  assert( p->pVtab );  if( p->pVtab->nRef>0 ){  return SQLITE_LOCKED;  }  }  p = vtabDisconnectAll(db, pTab);  xDestroy = p->pMod->pModule->xDestroy;  if( xDestroy==0 ) xDestroy = p->pMod->pModule->xDisconnect;  assert( xDestroy!=0 );  pTab->nTabRef++;  rc = xDestroy(p->pVtab);  if( rc==SQLITE_OK ){  assert( pTab->u.vtab.p==p && p->pNext==0 );  p->pVtab = 0;  pTab->u.vtab.p = 0;  sqlite3VtabUnlock(p);  }  sqlite3DeleteTable(db, pTab);  }  return rc; } static void callFinaliser(sqlite3 *db, int offset){  int i;  if( db->aVTrans ){  VTable **aVTrans = db->aVTrans;  db->aVTrans = 0;  for(i=0; i<db->nVTrans; i++){  VTable *pVTab = aVTrans[i];  sqlite3_vtab *p = pVTab->pVtab;  if( p ){  int (*x)(sqlite3_vtab *);  x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);  if( x ) x(p);  }  pVTab->iSavepoint = 0;  sqlite3VtabUnlock(pVTab);  }  sqlite3DbFree(db, aVTrans);  db->nVTrans = 0;  } } SQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, Vdbe *p){  int i;  int rc = SQLITE_OK;  VTable **aVTrans = db->aVTrans;  db->aVTrans = 0;  for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){  int (*x)(sqlite3_vtab *);  sqlite3_vtab *pVtab = aVTrans[i]->pVtab;  if( pVtab && (x = pVtab->pModule->xSync)!=0 ){  rc = x(pVtab);  sqlite3VtabImportErrmsg(p, pVtab);  }  }  db->aVTrans = aVTrans;  return rc; } SQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db){  callFinaliser(db, offsetof(sqlite3_module,xRollback));  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VtabCommit(sqlite3 *db){  callFinaliser(db, offsetof(sqlite3_module,xCommit));  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){  int rc = SQLITE_OK;  const sqlite3_module *pModule;  if( sqlite3VtabInSync(db) ){  return SQLITE_LOCKED;  }  if( !pVTab ){  return SQLITE_OK;  }  pModule = pVTab->pVtab->pModule;  if( pModule->xBegin ){  int i;  for(i=0; i<db->nVTrans; i++){  if( db->aVTrans[i]==pVTab ){  return SQLITE_OK;  }  }  rc = growVTrans(db);  if( rc==SQLITE_OK ){  rc = pModule->xBegin(pVTab->pVtab);  if( rc==SQLITE_OK ){  int iSvpt = db->nStatement + db->nSavepoint;  addToVTrans(db, pVTab);  if( iSvpt && pModule->xSavepoint ){  pVTab->iSavepoint = iSvpt;  rc = pModule->xSavepoint(pVTab->pVtab, iSvpt-1);  }  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){  int rc = SQLITE_OK;  assert( op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN );  assert( iSavepoint>=-1 );  if( db->aVTrans ){  int i;  for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){  VTable *pVTab = db->aVTrans[i];  const sqlite3_module *pMod = pVTab->pMod->pModule;  if( pVTab->pVtab && pMod->iVersion>=2 ){  int (*xMethod)(sqlite3_vtab *, int);  sqlite3VtabLock(pVTab);  switch( op ){  case SAVEPOINT_BEGIN:  xMethod = pMod->xSavepoint;  pVTab->iSavepoint = iSavepoint+1;  break;  case SAVEPOINT_ROLLBACK:  xMethod = pMod->xRollbackTo;  break;  default:  xMethod = pMod->xRelease;  break;  }  if( xMethod && pVTab->iSavepoint>iSavepoint ){  rc = xMethod(pVTab->pVtab, iSavepoint);  }  sqlite3VtabUnlock(pVTab);  }  }  }  return rc; } SQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(  sqlite3 *db,  FuncDef *pDef,  int nArg,  Expr *pExpr ){  Table *pTab;  sqlite3_vtab *pVtab;  sqlite3_module *pMod;  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**) = 0;  void *pArg = 0;  FuncDef *pNew;  int rc = 0;  if( NEVER(pExpr==0) ) return pDef;  if( pExpr->op!=TK_COLUMN ) return pDef;  assert( ExprUseYTab(pExpr) );  pTab = pExpr->y.pTab;  if( pTab==0 ) return pDef;  if( !IsVirtual(pTab) ) return pDef;  pVtab = sqlite3GetVTable(db, pTab)->pVtab;  assert( pVtab!=0 );  assert( pVtab->pModule!=0 );  pMod = (sqlite3_module *)pVtab->pModule;  if( pMod->xFindFunction==0 ) return pDef;
#ifdef SQLITE_DEBUG
 {  int i;  for(i=0; pDef->zName[i]; i++){  unsigned char x = (unsigned char)pDef->zName[i];  assert( x==sqlite3UpperToLower[x] );  }  }
#endif
 rc = pMod->xFindFunction(pVtab, nArg, pDef->zName, &xSFunc, &pArg);  if( rc==0 ){  return pDef;  }  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)   + sqlite3Strlen30(pDef->zName) + 1);  if( pNew==0 ){  return pDef;  }  *pNew = *pDef;  pNew->zName = (const char*)&pNew[1];  memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName)+1);  pNew->xSFunc = xSFunc;  pNew->pUserData = pArg;  pNew->funcFlags |= SQLITE_FUNC_EPHEM;  return pNew; } SQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){  Parse *pToplevel = sqlite3ParseToplevel(pParse);  int i, n;  Table **apVtabLock;  assert( IsVirtual(pTab) );  for(i=0; i<pToplevel->nVtabLock; i++){  if( pTab==pToplevel->apVtabLock[i] ) return;  }  n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);  apVtabLock = sqlite3Realloc(pToplevel->apVtabLock, n);  if( apVtabLock ){  pToplevel->apVtabLock = apVtabLock;  pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;  }else{  sqlite3OomFault(pToplevel->db);  } } SQLITE_PRIVATE int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){  const sqlite3_module *pModule = pMod->pModule;  Table *pTab;  char *zErr = 0;  int rc;  sqlite3 *db = pParse->db;  if( pMod->pEpoTab ) return 1;  if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;  pTab = sqlite3DbMallocZero(db, sizeof(Table));  if( pTab==0 ) return 0;  pTab->zName = sqlite3DbStrDup(db, pMod->zName);  if( pTab->zName==0 ){  sqlite3DbFree(db, pTab);  return 0;  }  pMod->pEpoTab = pTab;  pTab->nTabRef = 1;  pTab->eTabType = TABTYP_VTAB;  pTab->pSchema = db->aDb[0].pSchema;  assert( pTab->u.vtab.nArg==0 );  pTab->iPKey = -1;  pTab->tabFlags |= TF_Eponymous;  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));  addModuleArgument(pParse, pTab, 0);  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));  rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);  if( rc ){  sqlite3ErrorMsg(pParse, "%s", zErr);  sqlite3DbFree(db, zErr);  sqlite3VtabEponymousTableClear(db, pMod);  }  return 1; } SQLITE_PRIVATE void sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod){  Table *pTab = pMod->pEpoTab;  if( pTab!=0 ){  pTab->tabFlags |= TF_Ephemeral;  sqlite3DeleteTable(db, pTab);  pMod->pEpoTab = 0;  } } SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *db){  static const unsigned char aMap[] = {  SQLITE_ROLLBACK, SQLITE_ABORT, SQLITE_FAIL, SQLITE_IGNORE, SQLITE_REPLACE  };
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 assert( OE_Rollback==1 && OE_Abort==2 && OE_Fail==3 );  assert( OE_Ignore==4 && OE_Replace==5 );  assert( db->vtabOnConflict>=1 && db->vtabOnConflict<=5 );  return (int)aMap[db->vtabOnConflict-1]; } SQLITE_API int sqlite3_vtab_config(sqlite3 *db, int op, ...){  va_list ap;  int rc = SQLITE_OK;  VtabCtx *p;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  p = db->pVtabCtx;  if( !p ){  rc = SQLITE_MISUSE_BKPT;  }else{  assert( p->pTab==0 || IsVirtual(p->pTab) );  va_start(ap, op);  switch( op ){  case SQLITE_VTAB_CONSTRAINT_SUPPORT: {  p->pVTable->bConstraint = (u8)va_arg(ap, int);  break;  }  case SQLITE_VTAB_INNOCUOUS: {  p->pVTable->eVtabRisk = SQLITE_VTABRISK_Low;  break;  }  case SQLITE_VTAB_DIRECTONLY: {  p->pVTable->eVtabRisk = SQLITE_VTABRISK_High;  break;  }  default: {  rc = SQLITE_MISUSE_BKPT;  break;  }  }  va_end(ap);  }  if( rc!=SQLITE_OK ) sqlite3Error(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; }
#endif
#ifndef SQLITE_WHEREINT_H
#define SQLITE_WHEREINT_H
typedef struct WhereClause WhereClause; typedef struct WhereMaskSet WhereMaskSet; typedef struct WhereOrInfo WhereOrInfo; typedef struct WhereAndInfo WhereAndInfo; typedef struct WhereLevel WhereLevel; typedef struct WhereLoop WhereLoop; typedef struct WherePath WherePath; typedef struct WhereTerm WhereTerm; typedef struct WhereLoopBuilder WhereLoopBuilder; typedef struct WhereScan WhereScan; typedef struct WhereOrCost WhereOrCost; typedef struct WhereOrSet WhereOrSet; struct WhereLevel {  int iLeftJoin;  int iTabCur;  int iIdxCur;  int addrBrk;  int addrNxt;  int addrSkip;  int addrCont;  int addrFirst;  int addrBody;  int regBignull;  int addrBignull;
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 u32 iLikeRepCntr;  int addrLikeRep;
#endif
 u8 iFrom;  u8 op, p3, p5;  int p1, p2;  union {  struct {  int nIn;  struct InLoop {  int iCur;  int addrInTop;  int iBase;  int nPrefix;  u8 eEndLoopOp;  } *aInLoop;  } in;  Index *pCoveringIdx;  } u;  struct WhereLoop *pWLoop;  Bitmask notReady;
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 int addrVisit;
#endif
}; struct WhereLoop {  Bitmask prereq;  Bitmask maskSelf;
#ifdef SQLITE_DEBUG
 char cId;
#endif
 u8 iTab;  u8 iSortIdx;  LogEst rSetup;  LogEst rRun;  LogEst nOut;  union {  struct {  u16 nEq;  u16 nBtm;  u16 nTop;  u16 nDistinctCol;  Index *pIndex;  } btree;  struct {  int idxNum;  u8 needFree;  i8 isOrdered;  u16 omitMask;  char *idxStr;  } vtab;  } u;  u32 wsFlags;  u16 nLTerm;  u16 nSkip;
# define WHERE_LOOP_XFER_SZ offsetof(WhereLoop,nLSlot)
 u16 nLSlot;  WhereTerm **aLTerm;  WhereLoop *pNextLoop;  WhereTerm *aLTermSpace[3]; }; struct WhereOrCost {  Bitmask prereq;  LogEst rRun;  LogEst nOut; };
#define N_OR_COST 3
struct WhereOrSet {  u16 n;  WhereOrCost a[N_OR_COST]; }; struct WherePath {  Bitmask maskLoop;  Bitmask revLoop;  LogEst nRow;  LogEst rCost;  LogEst rUnsorted;  i8 isOrdered;  WhereLoop **aLoop; }; struct WhereTerm {  Expr *pExpr;  WhereClause *pWC;  LogEst truthProb;  u16 wtFlags;  u16 eOperator;  u8 nChild;  u8 eMatchOp;  int iParent;  int leftCursor;  union {  struct {  int leftColumn;  int iField;  } x;  WhereOrInfo *pOrInfo;  WhereAndInfo *pAndInfo;  } u;  Bitmask prereqRight;  Bitmask prereqAll; };
#define TERM_DYNAMIC 0x0001
#define TERM_VIRTUAL 0x0002
#define TERM_CODED 0x0004
#define TERM_COPIED  0x0008
#define TERM_ORINFO  0x0010
#define TERM_ANDINFO 0x0020
#define TERM_OR_OK 0x0040
#define TERM_VNULL 0x0080
#define TERM_LIKEOPT 0x0100
#define TERM_LIKECOND  0x0200
#define TERM_LIKE  0x0400
#define TERM_IS  0x0800
#define TERM_VARSELECT 0x1000
#define TERM_HEURTRUTH 0x2000
#ifdef SQLITE_ENABLE_STAT4
# define TERM_HIGHTRUTH 0x4000
#else
# define TERM_HIGHTRUTH 0
#endif
struct WhereScan {  WhereClause *pOrigWC;  WhereClause *pWC;  const char *zCollName;  Expr *pIdxExpr;  char idxaff;  unsigned char nEquiv;  unsigned char iEquiv;  u32 opMask;  int k;  int aiCur[11];  i16 aiColumn[11]; }; struct WhereClause {  WhereInfo *pWInfo;  WhereClause *pOuter;  u8 op;  u8 hasOr;  int nTerm;  int nSlot;  WhereTerm *a;
#if defined(SQLITE_SMALL_STACK)
 WhereTerm aStatic[1];
#else
 WhereTerm aStatic[8];
#endif
}; struct WhereOrInfo {  WhereClause wc;  Bitmask indexable; }; struct WhereAndInfo {  WhereClause wc; }; struct WhereMaskSet {  int bVarSelect;  int n;  int ix[BMS]; };
#define initMaskSet(P) (P)->n=0
struct WhereLoopBuilder {  WhereInfo *pWInfo;  WhereClause *pWC;  ExprList *pOrderBy;  WhereLoop *pNew;  WhereOrSet *pOrSet;
#ifdef SQLITE_ENABLE_STAT4
 UnpackedRecord *pRec;  int nRecValid;
#endif
 unsigned char bldFlags1;  unsigned char bldFlags2;  unsigned int iPlanLimit; };
#define SQLITE_BLDF1_INDEXED 0x0001
#define SQLITE_BLDF1_UNIQUE  0x0002
#define SQLITE_BLDF2_2NDPASS 0x0004
#ifndef SQLITE_QUERY_PLANNER_LIMIT
# define SQLITE_QUERY_PLANNER_LIMIT 20000
#endif
#ifndef SQLITE_QUERY_PLANNER_LIMIT_INCR
# define SQLITE_QUERY_PLANNER_LIMIT_INCR 1000
#endif
typedef struct WhereExprMod WhereExprMod; struct WhereExprMod {  WhereExprMod *pNext;  Expr *pExpr;  Expr orig; }; struct WhereInfo {  Parse *pParse;  SrcList *pTabList;  ExprList *pOrderBy;  ExprList *pResultSet;  Expr *pWhere;  int aiCurOnePass[2];  int iContinue;  int iBreak;  int savedNQueryLoop;  u16 wctrlFlags;  LogEst iLimit;  u8 nLevel;  i8 nOBSat;  u8 eOnePass;  u8 eDistinct;  unsigned bDeferredSeek :1;  unsigned untestedTerms :1;  unsigned bOrderedInnerLoop:1;  unsigned sorted :1;  LogEst nRowOut;  int iTop;  int iEndWhere;  WhereLoop *pLoops;  WhereExprMod *pExprMods;  Bitmask revMask;  WhereClause sWC;  WhereMaskSet sMaskSet;  WhereLevel a[1]; }; SQLITE_PRIVATE Bitmask sqlite3WhereGetMask(WhereMaskSet*,int);
#ifdef WHERETRACE_ENABLED
SQLITE_PRIVATE void sqlite3WhereClausePrint(WhereClause *pWC); SQLITE_PRIVATE void sqlite3WhereTermPrint(WhereTerm *pTerm, int iTerm); SQLITE_PRIVATE void sqlite3WhereLoopPrint(WhereLoop *p, WhereClause *pWC);
#endif
SQLITE_PRIVATE WhereTerm *sqlite3WhereFindTerm(  WhereClause *pWC,  int iCur,  int iColumn,  Bitmask notReady,  u32 op,  Index *pIdx );
#ifndef SQLITE_OMIT_EXPLAIN
SQLITE_PRIVATE int sqlite3WhereExplainOneScan(  Parse *pParse,  SrcList *pTabList,  WhereLevel *pLevel,  u16 wctrlFlags );
#else
# define sqlite3WhereExplainOneScan(u,v,w,x) 0
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
SQLITE_PRIVATE void sqlite3WhereAddScanStatus(  Vdbe *v,  SrcList *pSrclist,  WhereLevel *pLvl,  int addrExplain );
#else
# define sqlite3WhereAddScanStatus(a, b, c, d) ((void)d)
#endif
SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(  Parse *pParse,  Vdbe *v,  WhereInfo *pWInfo,  int iLevel,  WhereLevel *pLevel,  Bitmask notReady ); SQLITE_PRIVATE void sqlite3WhereClauseInit(WhereClause*,WhereInfo*); SQLITE_PRIVATE void sqlite3WhereClauseClear(WhereClause*); SQLITE_PRIVATE void sqlite3WhereSplit(WhereClause*,Expr*,u8); SQLITE_PRIVATE Bitmask sqlite3WhereExprUsage(WhereMaskSet*, Expr*); SQLITE_PRIVATE Bitmask sqlite3WhereExprUsageNN(WhereMaskSet*, Expr*); SQLITE_PRIVATE Bitmask sqlite3WhereExprListUsage(WhereMaskSet*, ExprList*); SQLITE_PRIVATE void sqlite3WhereExprAnalyze(SrcList*, WhereClause*); SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(Parse*, SrcItem*, WhereClause*);
#define WO_IN  0x0001
#define WO_EQ  0x0002
#define WO_LT  (WO_EQ<<(TK_LT-TK_EQ))
#define WO_LE  (WO_EQ<<(TK_LE-TK_EQ))
#define WO_GT  (WO_EQ<<(TK_GT-TK_EQ))
#define WO_GE  (WO_EQ<<(TK_GE-TK_EQ))
#define WO_AUX 0x0040
#define WO_IS  0x0080
#define WO_ISNULL 0x0100
#define WO_OR  0x0200
#define WO_AND 0x0400
#define WO_EQUIV 0x0800
#define WO_NOOP  0x1000
#define WO_ALL 0x1fff
#define WO_SINGLE 0x01ff
#define WHERE_COLUMN_EQ 0x00000001
#define WHERE_COLUMN_RANGE 0x00000002
#define WHERE_COLUMN_IN 0x00000004
#define WHERE_COLUMN_NULL 0x00000008
#define WHERE_CONSTRAINT  0x0000000f
#define WHERE_TOP_LIMIT 0x00000010
#define WHERE_BTM_LIMIT 0x00000020
#define WHERE_BOTH_LIMIT  0x00000030
#define WHERE_IDX_ONLY  0x00000040
#define WHERE_IPK 0x00000100
#define WHERE_INDEXED 0x00000200
#define WHERE_VIRTUALTABLE 0x00000400
#define WHERE_IN_ABLE 0x00000800
#define WHERE_ONEROW  0x00001000
#define WHERE_MULTI_OR  0x00002000
#define WHERE_AUTO_INDEX  0x00004000
#define WHERE_SKIPSCAN  0x00008000
#define WHERE_UNQ_WANTED  0x00010000
#define WHERE_PARTIALIDX  0x00020000
#define WHERE_IN_EARLYOUT 0x00040000
#define WHERE_BIGNULL_SORT 0x00080000
#define WHERE_IN_SEEKSCAN 0x00100000
#define WHERE_TRANSCONS 0x00200000
#endif
#ifndef SQLITE_OMIT_EXPLAIN
static const char *explainIndexColumnName(Index *pIdx, int i){  i = pIdx->aiColumn[i];  if( i==XN_EXPR ) return "<expr>";  if( i==XN_ROWID ) return "rowid";  return pIdx->pTable->aCol[i].zCnName; } static void explainAppendTerm(  StrAccum *pStr,  Index *pIdx,  int nTerm,  int iTerm,  int bAnd,  const char *zOp ){  int i;  assert( nTerm>=1 );  if( bAnd ) sqlite3_str_append(pStr, " AND ", 5);  if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);  for(i=0; i<nTerm; i++){  if( i ) sqlite3_str_append(pStr, ",", 1);  sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, iTerm+i));  }  if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);  sqlite3_str_append(pStr, zOp, 1);  if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);  for(i=0; i<nTerm; i++){  if( i ) sqlite3_str_append(pStr, ",", 1);  sqlite3_str_append(pStr, "?", 1);  }  if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1); } static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){  Index *pIndex = pLoop->u.btree.pIndex;  u16 nEq = pLoop->u.btree.nEq;  u16 nSkip = pLoop->nSkip;  int i, j;  if( nEq==0 && (pLoop->wsFlags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))==0 ) return;  sqlite3_str_append(pStr, " (", 2);  for(i=0; i<nEq; i++){  const char *z = explainIndexColumnName(pIndex, i);  if( i ) sqlite3_str_append(pStr, " AND ", 5);  sqlite3_str_appendf(pStr, i>=nSkip ? "%s=?" : "ANY(%s)", z);  }  j = i;  if( pLoop->wsFlags&WHERE_BTM_LIMIT ){  explainAppendTerm(pStr, pIndex, pLoop->u.btree.nBtm, j, i, ">");  i = 1;  }  if( pLoop->wsFlags&WHERE_TOP_LIMIT ){  explainAppendTerm(pStr, pIndex, pLoop->u.btree.nTop, j, i, "<");  }  sqlite3_str_append(pStr, ")", 1); } SQLITE_PRIVATE int sqlite3WhereExplainOneScan(  Parse *pParse,  SrcList *pTabList,  WhereLevel *pLevel,  u16 wctrlFlags ){  int ret = 0;
#if !defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_STMT_SCANSTATUS)
 if( sqlite3ParseToplevel(pParse)->explain==2 )
#endif
 {  SrcItem *pItem = &pTabList->a[pLevel->iFrom];  Vdbe *v = pParse->pVdbe;  sqlite3 *db = pParse->db;  int isSearch;  WhereLoop *pLoop;  u32 flags;  char *zMsg;  StrAccum str;  char zBuf[100];  pLoop = pLevel->pWLoop;  flags = pLoop->wsFlags;  if( (flags&WHERE_MULTI_OR) || (wctrlFlags&WHERE_OR_SUBCLAUSE) ) return 0;  isSearch = (flags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))!=0  || ((flags&WHERE_VIRTUALTABLE)==0 && (pLoop->u.btree.nEq>0))  || (wctrlFlags&(WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX));  sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), SQLITE_MAX_LENGTH);  str.printfFlags = SQLITE_PRINTF_INTERNAL;  sqlite3_str_appendf(&str, "%s %S", isSearch ? "SEARCH" : "SCAN", pItem);  if( (flags & (WHERE_IPK|WHERE_VIRTUALTABLE))==0 ){  const char *zFmt = 0;  Index *pIdx;  assert( pLoop->u.btree.pIndex!=0 );  pIdx = pLoop->u.btree.pIndex;  assert( !(flags&WHERE_AUTO_INDEX) || (flags&WHERE_IDX_ONLY) );  if( !HasRowid(pItem->pTab) && IsPrimaryKeyIndex(pIdx) ){  if( isSearch ){  zFmt = "PRIMARY KEY";  }  }else if( flags & WHERE_PARTIALIDX ){  zFmt = "AUTOMATIC PARTIAL COVERING INDEX";  }else if( flags & WHERE_AUTO_INDEX ){  zFmt = "AUTOMATIC COVERING INDEX";  }else if( flags & WHERE_IDX_ONLY ){  zFmt = "COVERING INDEX %s";  }else{  zFmt = "INDEX %s";  }  if( zFmt ){  sqlite3_str_append(&str, " USING ", 7);  sqlite3_str_appendf(&str, zFmt, pIdx->zName);  explainIndexRange(&str, pLoop);  }  }else if( (flags & WHERE_IPK)!=0 && (flags & WHERE_CONSTRAINT)!=0 ){  const char *zRangeOp;  if( flags&(WHERE_COLUMN_EQ|WHERE_COLUMN_IN) ){  zRangeOp = "=";  }else if( (flags&WHERE_BOTH_LIMIT)==WHERE_BOTH_LIMIT ){  zRangeOp = ">? AND rowid<";  }else if( flags&WHERE_BTM_LIMIT ){  zRangeOp = ">";  }else{  assert( flags&WHERE_TOP_LIMIT);  zRangeOp = "<";  }  sqlite3_str_appendf(&str,  " USING INTEGER PRIMARY KEY (rowid%s?)",zRangeOp);  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 else if( (flags & WHERE_VIRTUALTABLE)!=0 ){  sqlite3_str_appendf(&str, " VIRTUAL TABLE INDEX %d:%s",  pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr);  }
#endif
#ifdef SQLITE_EXPLAIN_ESTIMATED_ROWS
 if( pLoop->nOut>=10 ){  sqlite3_str_appendf(&str, " (~%llu rows)",   sqlite3LogEstToInt(pLoop->nOut));  }else{  sqlite3_str_append(&str, " (~1 row)", 9);  }
#endif
 zMsg = sqlite3StrAccumFinish(&str);  sqlite3ExplainBreakpoint("",zMsg);  ret = sqlite3VdbeAddOp4(v, OP_Explain, sqlite3VdbeCurrentAddr(v),  pParse->addrExplain, 0, zMsg,P4_DYNAMIC);  }  return ret; }
#endif
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
SQLITE_PRIVATE void sqlite3WhereAddScanStatus(  Vdbe *v,  SrcList *pSrclist,  WhereLevel *pLvl,  int addrExplain ){  const char *zObj = 0;  WhereLoop *pLoop = pLvl->pWLoop;  if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0 && pLoop->u.btree.pIndex!=0 ){  zObj = pLoop->u.btree.pIndex->zName;  }else{  zObj = pSrclist->a[pLvl->iFrom].zName;  }  sqlite3VdbeScanStatus(  v, addrExplain, pLvl->addrBody, pLvl->addrVisit, pLoop->nOut, zObj  ); }
#endif
static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){  int nLoop = 0;  assert( pTerm!=0 );  while( (pTerm->wtFlags & TERM_CODED)==0  && (pLevel->iLeftJoin==0 || ExprHasProperty(pTerm->pExpr, EP_FromJoin))  && (pLevel->notReady & pTerm->prereqAll)==0  ){  if( nLoop && (pTerm->wtFlags & TERM_LIKE)!=0 ){  pTerm->wtFlags |= TERM_LIKECOND;  }else{  pTerm->wtFlags |= TERM_CODED;  }
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x20000 ){  sqlite3DebugPrintf("DISABLE-");  sqlite3WhereTermPrint(pTerm, (int)(pTerm - (pTerm->pWC->a)));  }
#endif
 if( pTerm->iParent<0 ) break;  pTerm = &pTerm->pWC->a[pTerm->iParent];  assert( pTerm!=0 );  pTerm->nChild--;  if( pTerm->nChild!=0 ) break;  nLoop++;  } } static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){  Vdbe *v = pParse->pVdbe;  if( zAff==0 ){  assert( pParse->db->mallocFailed );  return;  }  assert( v!=0 );  assert( SQLITE_AFF_NONE<SQLITE_AFF_BLOB );  while( n>0 && zAff[0]<=SQLITE_AFF_BLOB ){  n--;  base++;  zAff++;  }  while( n>1 && zAff[n-1]<=SQLITE_AFF_BLOB ){  n--;  }  if( n>0 ){  sqlite3VdbeAddOp4(v, OP_Affinity, base, n, 0, zAff, n);  } } static void updateRangeAffinityStr(  Expr *pRight,  int n,  char *zAff ){  int i;  for(i=0; i<n; i++){  Expr *p = sqlite3VectorFieldSubexpr(pRight, i);  if( sqlite3CompareAffinity(p, zAff[i])==SQLITE_AFF_BLOB   || sqlite3ExprNeedsNoAffinityChange(p, zAff[i])  ){  zAff[i] = SQLITE_AFF_BLOB;  }  } } static Expr *removeUnindexableInClauseTerms(  Parse *pParse,  int iEq,  WhereLoop *pLoop,  Expr *pX ){  sqlite3 *db = pParse->db;  Expr *pNew;  pNew = sqlite3ExprDup(db, pX, 0);  if( db->mallocFailed==0 ){  ExprList *pOrigRhs;  ExprList *pOrigLhs;  ExprList *pRhs = 0;  ExprList *pLhs = 0;  int i;  Select *pSelect;  assert( ExprUseXSelect(pNew) );  pOrigRhs = pNew->x.pSelect->pEList;  assert( pNew->pLeft!=0 );  assert( ExprUseXList(pNew->pLeft) );  pOrigLhs = pNew->pLeft->x.pList;  for(i=iEq; i<pLoop->nLTerm; i++){  if( pLoop->aLTerm[i]->pExpr==pX ){  int iField;  assert( (pLoop->aLTerm[i]->eOperator & (WO_OR|WO_AND))==0 );  iField = pLoop->aLTerm[i]->u.x.iField - 1;  if( pOrigRhs->a[iField].pExpr==0 ) continue;  pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);  pOrigRhs->a[iField].pExpr = 0;  assert( pOrigLhs->a[iField].pExpr!=0 );  pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs->a[iField].pExpr);  pOrigLhs->a[iField].pExpr = 0;  }  }  sqlite3ExprListDelete(db, pOrigRhs);  sqlite3ExprListDelete(db, pOrigLhs);  pNew->pLeft->x.pList = pLhs;  pNew->x.pSelect->pEList = pRhs;  if( pLhs && pLhs->nExpr==1 ){  Expr *p = pLhs->a[0].pExpr;  pLhs->a[0].pExpr = 0;  sqlite3ExprDelete(db, pNew->pLeft);  pNew->pLeft = p;  }  pSelect = pNew->x.pSelect;  if( pSelect->pOrderBy ){  ExprList *pOrderBy = pSelect->pOrderBy;  for(i=0; i<pOrderBy->nExpr; i++){  pOrderBy->a[i].u.x.iOrderByCol = 0;  }  }
#if 0
 printf("For indexing, change the IN expr:\n");  sqlite3TreeViewExpr(0, pX, 0);  printf("Into:\n");  sqlite3TreeViewExpr(0, pNew, 0);
#endif
 }  return pNew; } static int codeEqualityTerm(  Parse *pParse,  WhereTerm *pTerm,  WhereLevel *pLevel,  int iEq,  int bRev,  int iTarget ){  Expr *pX = pTerm->pExpr;  Vdbe *v = pParse->pVdbe;  int iReg;  assert( pLevel->pWLoop->aLTerm[iEq]==pTerm );  assert( iTarget>0 );  if( pX->op==TK_EQ || pX->op==TK_IS ){  iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);  }else if( pX->op==TK_ISNULL ){  iReg = iTarget;  sqlite3VdbeAddOp2(v, OP_Null, 0, iReg);
#ifndef SQLITE_OMIT_SUBQUERY
 }else{  int eType = IN_INDEX_NOOP;  int iTab;  struct InLoop *pIn;  WhereLoop *pLoop = pLevel->pWLoop;  int i;  int nEq = 0;  int *aiMap = 0;  if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0  && pLoop->u.btree.pIndex!=0  && pLoop->u.btree.pIndex->aSortOrder[iEq]  ){  testcase( iEq==0 );  testcase( bRev );  bRev = !bRev;  }  assert( pX->op==TK_IN );  iReg = iTarget;  for(i=0; i<iEq; i++){  if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){  disableTerm(pLevel, pTerm);  return iTarget;  }  }  for(i=iEq;i<pLoop->nLTerm; i++){  assert( pLoop->aLTerm[i]!=0 );  if( pLoop->aLTerm[i]->pExpr==pX ) nEq++;  }  iTab = 0;  if( !ExprUseXSelect(pX) || pX->x.pSelect->pEList->nExpr==1 ){  eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, 0, &iTab);  }else{  sqlite3 *db = pParse->db;  pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);  if( !db->mallocFailed ){  aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*nEq);  eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);  pTerm->pExpr->iTable = iTab;  }  sqlite3ExprDelete(db, pX);  pX = pTerm->pExpr;  }  if( eType==IN_INDEX_INDEX_DESC ){  testcase( bRev );  bRev = !bRev;  }  sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iTab, 0);  VdbeCoverageIf(v, bRev);  VdbeCoverageIf(v, !bRev);  assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );  pLoop->wsFlags |= WHERE_IN_ABLE;  if( pLevel->u.in.nIn==0 ){  pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);  }  if( iEq>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0 ){  pLoop->wsFlags |= WHERE_IN_EARLYOUT;  }  i = pLevel->u.in.nIn;  pLevel->u.in.nIn += nEq;  pLevel->u.in.aInLoop =   sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop,  sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);  pIn = pLevel->u.in.aInLoop;  if( pIn ){  int iMap = 0;  pIn += i;  for(i=iEq;i<pLoop->nLTerm; i++){  if( pLoop->aLTerm[i]->pExpr==pX ){  int iOut = iReg + i - iEq;  if( eType==IN_INDEX_ROWID ){  pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iOut);  }else{  int iCol = aiMap ? aiMap[iMap++] : 0;  pIn->addrInTop = sqlite3VdbeAddOp3(v,OP_Column,iTab, iCol, iOut);  }  sqlite3VdbeAddOp1(v, OP_IsNull, iOut); VdbeCoverage(v);  if( i==iEq ){  pIn->iCur = iTab;  pIn->eEndLoopOp = bRev ? OP_Prev : OP_Next;  if( iEq>0 ){  pIn->iBase = iReg - i;  pIn->nPrefix = i;  }else{  pIn->nPrefix = 0;  }  }else{  pIn->eEndLoopOp = OP_Noop;  }  pIn++;  }  }  testcase( iEq>0  && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0  && (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 );  if( iEq>0   && (pLoop->wsFlags & (WHERE_IN_SEEKSCAN|WHERE_VIRTUALTABLE))==0  ){  sqlite3VdbeAddOp3(v, OP_SeekHit, pLevel->iIdxCur, 0, iEq);  }  }else{  pLevel->u.in.nIn = 0;  }  sqlite3DbFree(pParse->db, aiMap);
#endif
 }  if( (pLevel->pWLoop->wsFlags & WHERE_TRANSCONS)==0   || (pTerm->eOperator & WO_EQUIV)==0  ){  disableTerm(pLevel, pTerm);  }  return iReg; } static int codeAllEqualityTerms(  Parse *pParse,  WhereLevel *pLevel,  int bRev,  int nExtraReg,  char **pzAff ){  u16 nEq;  u16 nSkip;  Vdbe *v = pParse->pVdbe;  Index *pIdx;  WhereTerm *pTerm;  WhereLoop *pLoop;  int j;  int regBase;  int nReg;  char *zAff;  pLoop = pLevel->pWLoop;  assert( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0 );  nEq = pLoop->u.btree.nEq;  nSkip = pLoop->nSkip;  pIdx = pLoop->u.btree.pIndex;  assert( pIdx!=0 );  regBase = pParse->nMem + 1;  nReg = pLoop->u.btree.nEq + nExtraReg;  pParse->nMem += nReg;  zAff = sqlite3DbStrDup(pParse->db,sqlite3IndexAffinityStr(pParse->db,pIdx));  assert( zAff!=0 || pParse->db->mallocFailed );  if( nSkip ){  int iIdxCur = pLevel->iIdxCur;  sqlite3VdbeAddOp3(v, OP_Null, 0, regBase, regBase+nSkip-1);  sqlite3VdbeAddOp1(v, (bRev?OP_Last:OP_Rewind), iIdxCur);  VdbeCoverageIf(v, bRev==0);  VdbeCoverageIf(v, bRev!=0);  VdbeComment((v, "begin skip-scan on %s", pIdx->zName));  j = sqlite3VdbeAddOp0(v, OP_Goto);  pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, (bRev?OP_SeekLT:OP_SeekGT),  iIdxCur, 0, regBase, nSkip);  VdbeCoverageIf(v, bRev==0);  VdbeCoverageIf(v, bRev!=0);  sqlite3VdbeJumpHere(v, j);  for(j=0; j<nSkip; j++){  sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, j, regBase+j);  testcase( pIdx->aiColumn[j]==XN_EXPR );  VdbeComment((v, "%s", explainIndexColumnName(pIdx, j)));  }  }  assert( zAff==0 || (int)strlen(zAff)>=nEq );  for(j=nSkip; j<nEq; j++){  int r1;  pTerm = pLoop->aLTerm[j];  assert( pTerm!=0 );  testcase( (pTerm->wtFlags & TERM_CODED)!=0 );  testcase( pTerm->wtFlags & TERM_VIRTUAL );  r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase+j);  if( r1!=regBase+j ){  if( nReg==1 ){  sqlite3ReleaseTempReg(pParse, regBase);  regBase = r1;  }else{  sqlite3VdbeAddOp2(v, OP_Copy, r1, regBase+j);  }  }  if( pTerm->eOperator & WO_IN ){  if( pTerm->pExpr->flags & EP_xIsSelect ){  if( zAff ) zAff[j] = SQLITE_AFF_BLOB;  }  }else if( (pTerm->eOperator & WO_ISNULL)==0 ){  Expr *pRight = pTerm->pExpr->pRight;  if( (pTerm->wtFlags & TERM_IS)==0 && sqlite3ExprCanBeNull(pRight) ){  sqlite3VdbeAddOp2(v, OP_IsNull, regBase+j, pLevel->addrBrk);  VdbeCoverage(v);  }  if( pParse->db->mallocFailed==0 && pParse->nErr==0 ){  if( sqlite3CompareAffinity(pRight, zAff[j])==SQLITE_AFF_BLOB ){  zAff[j] = SQLITE_AFF_BLOB;  }  if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){  zAff[j] = SQLITE_AFF_BLOB;  }  }  }  }  *pzAff = zAff;  return regBase; }
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
static void whereLikeOptimizationStringFixup(  Vdbe *v,  WhereLevel *pLevel,  WhereTerm *pTerm ){  if( pTerm->wtFlags & TERM_LIKEOPT ){  VdbeOp *pOp;  assert( pLevel->iLikeRepCntr>0 );  pOp = sqlite3VdbeGetOp(v, -1);  assert( pOp!=0 );  assert( pOp->opcode==OP_String8  || pTerm->pWC->pWInfo->pParse->db->mallocFailed );  pOp->p3 = (int)(pLevel->iLikeRepCntr>>1);  pOp->p5 = (u8)(pLevel->iLikeRepCntr&1);  } }
#else
# define whereLikeOptimizationStringFixup(A,B,C)
#endif
#ifdef SQLITE_ENABLE_CURSOR_HINTS
struct CCurHint {  int iTabCur;  int iIdxCur;  Index *pIdx; }; static int codeCursorHintCheckExpr(Walker *pWalker, Expr *pExpr){  struct CCurHint *pHint = pWalker->u.pCCurHint;  assert( pHint->pIdx!=0 );  if( pExpr->op==TK_COLUMN   && pExpr->iTable==pHint->iTabCur   && sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn)<0  ){  pWalker->eCode = 1;  }  return WRC_Continue; } static int codeCursorHintIsOrFunction(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_IS   || pExpr->op==TK_ISNULL || pExpr->op==TK_ISNOT   || pExpr->op==TK_NOTNULL || pExpr->op==TK_CASE  ){  pWalker->eCode = 1;  }else if( pExpr->op==TK_FUNCTION ){  int d1;  char d2[4];  if( 0==sqlite3IsLikeFunction(pWalker->pParse->db, pExpr, &d1, d2) ){  pWalker->eCode = 1;  }  }  return WRC_Continue; } static int codeCursorHintFixExpr(Walker *pWalker, Expr *pExpr){  int rc = WRC_Continue;  struct CCurHint *pHint = pWalker->u.pCCurHint;  if( pExpr->op==TK_COLUMN ){  if( pExpr->iTable!=pHint->iTabCur ){  int reg = ++pWalker->pParse->nMem;  sqlite3ExprCode(pWalker->pParse, pExpr, reg);  pExpr->op = TK_REGISTER;  pExpr->iTable = reg;  }else if( pHint->pIdx!=0 ){  pExpr->iTable = pHint->iIdxCur;  pExpr->iColumn = sqlite3TableColumnToIndex(pHint->pIdx, pExpr->iColumn);  assert( pExpr->iColumn>=0 );  }  }else if( pExpr->op==TK_AGG_FUNCTION ){  rc = WRC_Prune;  }  return rc; } static void codeCursorHint(  SrcItem *pTabItem,  WhereInfo *pWInfo,  WhereLevel *pLevel,  WhereTerm *pEndRange ){  Parse *pParse = pWInfo->pParse;  sqlite3 *db = pParse->db;  Vdbe *v = pParse->pVdbe;  Expr *pExpr = 0;  WhereLoop *pLoop = pLevel->pWLoop;  int iCur;  WhereClause *pWC;  WhereTerm *pTerm;  int i, j;  struct CCurHint sHint;  Walker sWalker;  if( OptimizationDisabled(db, SQLITE_CursorHints) ) return;  iCur = pLevel->iTabCur;  assert( iCur==pWInfo->pTabList->a[pLevel->iFrom].iCursor );  sHint.iTabCur = iCur;  sHint.iIdxCur = pLevel->iIdxCur;  sHint.pIdx = pLoop->u.btree.pIndex;  memset(&sWalker, 0, sizeof(sWalker));  sWalker.pParse = pParse;  sWalker.u.pCCurHint = &sHint;  pWC = &pWInfo->sWC;  for(i=0; i<pWC->nTerm; i++){  pTerm = &pWC->a[i];  if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;  if( pTerm->prereqAll & pLevel->notReady ) continue;  if( pTabItem->fg.jointype & JT_LEFT ){  Expr *pExpr = pTerm->pExpr;  if( !ExprHasProperty(pExpr, EP_FromJoin)   || pExpr->iRightJoinTable!=pTabItem->iCursor  ){  sWalker.eCode = 0;  sWalker.xExprCallback = codeCursorHintIsOrFunction;  sqlite3WalkExpr(&sWalker, pTerm->pExpr);  if( sWalker.eCode ) continue;  }  }else{  if( ExprHasProperty(pTerm->pExpr, EP_FromJoin) ) continue;  }  if( pLoop->u.btree.nEq==0 && pTerm!=pEndRange ){  for(j=0; j<pLoop->nLTerm && pLoop->aLTerm[j]!=pTerm; j++){}  if( j<pLoop->nLTerm ) continue;  }  if( sqlite3ExprContainsSubquery(pTerm->pExpr) ) continue;  if( sHint.pIdx!=0 ){  sWalker.eCode = 0;  sWalker.xExprCallback = codeCursorHintCheckExpr;  sqlite3WalkExpr(&sWalker, pTerm->pExpr);  if( sWalker.eCode ) continue;  }  pExpr = sqlite3ExprAnd(pParse, pExpr, sqlite3ExprDup(db, pTerm->pExpr, 0));  }  if( pExpr!=0 ){  sWalker.xExprCallback = codeCursorHintFixExpr;  sqlite3WalkExpr(&sWalker, pExpr);  sqlite3VdbeAddOp4(v, OP_CursorHint,  (sHint.pIdx ? sHint.iIdxCur : sHint.iTabCur), 0, 0,  (const char*)pExpr, P4_EXPR);  } }
#else
# define codeCursorHint(A,B,C,D)
#endif
static void codeDeferredSeek(  WhereInfo *pWInfo,  Index *pIdx,  int iCur,  int iIdxCur ){  Parse *pParse = pWInfo->pParse;  Vdbe *v = pParse->pVdbe;  assert( iIdxCur>0 );  assert( pIdx->aiColumn[pIdx->nColumn-1]==-1 );  pWInfo->bDeferredSeek = 1;  sqlite3VdbeAddOp3(v, OP_DeferredSeek, iIdxCur, 0, iCur);  if( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)   && DbMaskAllZero(sqlite3ParseToplevel(pParse)->writeMask)  ){  int i;  Table *pTab = pIdx->pTable;  u32 *ai = (u32*)sqlite3DbMallocZero(pParse->db, sizeof(u32)*(pTab->nCol+1));  if( ai ){  ai[0] = pTab->nCol;  for(i=0; i<pIdx->nColumn-1; i++){  int x1, x2;  assert( pIdx->aiColumn[i]<pTab->nCol );  x1 = pIdx->aiColumn[i];  x2 = sqlite3TableColumnToStorage(pTab, x1);  testcase( x1!=x2 );  if( x1>=0 ) ai[x2+1] = i+1;  }  sqlite3VdbeChangeP4(v, -1, (char*)ai, P4_INTARRAY);  }  } } static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg){  assert( nReg>0 );  if( p && sqlite3ExprIsVector(p) ){
#ifndef SQLITE_OMIT_SUBQUERY
 if( ExprUseXSelect(p) ){  Vdbe *v = pParse->pVdbe;  int iSelect;  assert( p->op==TK_SELECT );  iSelect = sqlite3CodeSubselect(pParse, p);  sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);  }else
#endif
 {  int i;  const ExprList *pList;  assert( ExprUseXList(p) );  pList = p->x.pList;  assert( nReg<=pList->nExpr );  for(i=0; i<nReg; i++){  sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg+i);  }  }  }else{  assert( nReg==1 || pParse->nErr );  sqlite3ExprCode(pParse, p, iReg);  } } typedef struct IdxExprTrans {  Expr *pIdxExpr;  int iTabCur;  int iIdxCur;  int iIdxCol;  int iTabCol;  WhereInfo *pWInfo;  sqlite3 *db; } IdxExprTrans; static void preserveExpr(IdxExprTrans *pTrans, Expr *pExpr){  WhereExprMod *pNew;  pNew = sqlite3DbMallocRaw(pTrans->db, sizeof(*pNew));  if( pNew==0 ) return;  pNew->pNext = pTrans->pWInfo->pExprMods;  pTrans->pWInfo->pExprMods = pNew;  pNew->pExpr = pExpr;  memcpy(&pNew->orig, pExpr, sizeof(*pExpr)); } static int whereIndexExprTransNode(Walker *p, Expr *pExpr){  IdxExprTrans *pX = p->u.pIdxTrans;  if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){  preserveExpr(pX, pExpr);  pExpr->affExpr = sqlite3ExprAffinity(pExpr);  pExpr->op = TK_COLUMN;  pExpr->iTable = pX->iIdxCur;  pExpr->iColumn = pX->iIdxCol;  testcase( ExprHasProperty(pExpr, EP_Skip) );  testcase( ExprHasProperty(pExpr, EP_Unlikely) );  ExprClearProperty(pExpr, EP_Skip|EP_Unlikely|EP_WinFunc|EP_Subrtn);  pExpr->y.pTab = 0;  return WRC_Prune;  }else{  return WRC_Continue;  } }
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){  if( pExpr->op==TK_COLUMN ){  IdxExprTrans *pX = p->u.pIdxTrans;  if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){  assert( ExprUseYTab(pExpr) && pExpr->y.pTab!=0 );  preserveExpr(pX, pExpr);  pExpr->affExpr = sqlite3TableColumnAffinity(pExpr->y.pTab,pExpr->iColumn);  pExpr->iTable = pX->iIdxCur;  pExpr->iColumn = pX->iIdxCol;  pExpr->y.pTab = 0;  }  }  return WRC_Continue; }
#endif
static void whereIndexExprTrans(  Index *pIdx,  int iTabCur,  int iIdxCur,  WhereInfo *pWInfo ){  int iIdxCol;  ExprList *aColExpr;  Table *pTab;  Walker w;  IdxExprTrans x;  aColExpr = pIdx->aColExpr;  if( aColExpr==0 && !pIdx->bHasVCol ){  return;  }  pTab = pIdx->pTable;  memset(&w, 0, sizeof(w));  w.u.pIdxTrans = &x;  x.iTabCur = iTabCur;  x.iIdxCur = iIdxCur;  x.pWInfo = pWInfo;  x.db = pWInfo->pParse->db;  for(iIdxCol=0; iIdxCol<pIdx->nColumn; iIdxCol++){  i16 iRef = pIdx->aiColumn[iIdxCol];  if( iRef==XN_EXPR ){  assert( aColExpr!=0 && aColExpr->a[iIdxCol].pExpr!=0 );  x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;  if( sqlite3ExprIsConstant(x.pIdxExpr) ) continue;  w.xExprCallback = whereIndexExprTransNode;
#ifndef SQLITE_OMIT_GENERATED_COLUMNS
 }else if( iRef>=0   && (pTab->aCol[iRef].colFlags & COLFLAG_VIRTUAL)!=0   && ((pTab->aCol[iRef].colFlags & COLFLAG_HASCOLL)==0   || sqlite3StrICmp(sqlite3ColumnColl(&pTab->aCol[iRef]),   sqlite3StrBINARY)==0)  ){  x.iTabCol = iRef;  w.xExprCallback = whereIndexExprTransColumn;
#endif
 }else{  continue;  }  x.iIdxCol = iIdxCol;  sqlite3WalkExpr(&w, pWInfo->pWhere);  sqlite3WalkExprList(&w, pWInfo->pOrderBy);  sqlite3WalkExprList(&w, pWInfo->pResultSet);  } } static void whereApplyPartialIndexConstraints(  Expr *pTruth,  int iTabCur,  WhereClause *pWC ){  int i;  WhereTerm *pTerm;  while( pTruth->op==TK_AND ){  whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);  pTruth = pTruth->pRight;  }  for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){  Expr *pExpr;  if( pTerm->wtFlags & TERM_CODED ) continue;  pExpr = pTerm->pExpr;  if( sqlite3ExprCompare(0, pExpr, pTruth, iTabCur)==0 ){  pTerm->wtFlags |= TERM_CODED;  }  } } SQLITE_PRIVATE Bitmask sqlite3WhereCodeOneLoopStart(  Parse *pParse,  Vdbe *v,  WhereInfo *pWInfo,  int iLevel,  WhereLevel *pLevel,  Bitmask notReady ){  int j, k;  int iCur;  int addrNxt;  int bRev;  WhereLoop *pLoop;  WhereClause *pWC;  WhereTerm *pTerm;  sqlite3 *db;  SrcItem *pTabItem;  int addrBrk;  int addrHalt;  int addrCont;  int iRowidReg = 0;  int iReleaseReg = 0;  Index *pIdx = 0;  int iLoop;  pWC = &pWInfo->sWC;  db = pParse->db;  pLoop = pLevel->pWLoop;  pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];  iCur = pTabItem->iCursor;  pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);  bRev = (pWInfo->revMask>>iLevel)&1;  VdbeModuleComment((v, "Begin WHERE-loop%d: %s",iLevel,pTabItem->pTab->zName));
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x800 ){  sqlite3DebugPrintf("Coding level %d of %d: notReady=%llx iFrom=%d\n",   iLevel, pWInfo->nLevel, (u64)notReady, pLevel->iFrom);  sqlite3WhereLoopPrint(pLoop, pWC);  }  if( sqlite3WhereTrace & 0x20000 ){  if( iLevel==0 ){  sqlite3DebugPrintf("WHERE clause being coded:\n");  sqlite3TreeViewExpr(0, pWInfo->pWhere, 0);  }  sqlite3DebugPrintf("All WHERE-clause terms before coding:\n");  sqlite3WhereClausePrint(pWC);  }
#endif
 addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);  addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);  assert( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)   || pLevel->iFrom>0 || (pTabItem[0].fg.jointype & JT_LEFT)==0  );  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & JT_LEFT)!=0 ){  pLevel->iLeftJoin = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 0, pLevel->iLeftJoin);  VdbeComment((v, "init LEFT JOIN no-match flag"));  }  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}  addrHalt = pWInfo->a[j].addrBrk;  if( pTabItem->fg.viaCoroutine ){  int regYield = pTabItem->regReturn;  sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);  pLevel->p2 = sqlite3VdbeAddOp2(v, OP_Yield, regYield, addrBrk);  VdbeCoverage(v);  VdbeComment((v, "next row of %s", pTabItem->pTab->zName));  pLevel->op = OP_Goto;  }else
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){  int iReg;  int addrNotFound;  int nConstraint = pLoop->nLTerm;  int iIn;  iReg = sqlite3GetTempRange(pParse, nConstraint+2);  addrNotFound = pLevel->addrBrk;  for(j=0; j<nConstraint; j++){  int iTarget = iReg+j+2;  pTerm = pLoop->aLTerm[j];  if( NEVER(pTerm==0) ) continue;  if( pTerm->eOperator & WO_IN ){  codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);  addrNotFound = pLevel->addrNxt;  }else{  Expr *pRight = pTerm->pExpr->pRight;  codeExprOrVector(pParse, pRight, iTarget, 1);  }  }  sqlite3VdbeAddOp2(v, OP_Integer, pLoop->u.vtab.idxNum, iReg);  sqlite3VdbeAddOp2(v, OP_Integer, nConstraint, iReg+1);  sqlite3VdbeAddOp4(v, OP_VFilter, iCur, addrNotFound, iReg,  pLoop->u.vtab.idxStr,  pLoop->u.vtab.needFree ? P4_DYNAMIC : P4_STATIC);  VdbeCoverage(v);  pLoop->u.vtab.needFree = 0;  if( db->mallocFailed ) pLoop->u.vtab.idxStr = 0;  pLevel->p1 = iCur;  pLevel->op = pWInfo->eOnePass ? OP_Noop : OP_VNext;  pLevel->p2 = sqlite3VdbeCurrentAddr(v);  assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );  if( pLoop->wsFlags & WHERE_IN_ABLE ){  iIn = pLevel->u.in.nIn;  }else{  iIn = 0;  }  for(j=nConstraint-1; j>=0; j--){  pTerm = pLoop->aLTerm[j];  if( (pTerm->eOperator & WO_IN)!=0 ) iIn--;  if( j<16 && (pLoop->u.vtab.omitMask>>j)&1 ){  disableTerm(pLevel, pTerm);  }else if( (pTerm->eOperator & WO_IN)!=0  && sqlite3ExprVectorSize(pTerm->pExpr->pLeft)==1  ){  Expr *pCompare;  Expr *pRight;  VdbeOp *pOp;  assert( pLevel->u.in.aInLoop!=0 || db->mallocFailed );  if( !db->mallocFailed ){  assert( iIn>=0 && iIn<pLevel->u.in.nIn );  pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[iIn].addrInTop);  assert( pOp->opcode==OP_Column || pOp->opcode==OP_Rowid );  assert( pOp->opcode!=OP_Column || pOp->p3==iReg+j+2 );  assert( pOp->opcode!=OP_Rowid || pOp->p2==iReg+j+2 );  testcase( pOp->opcode==OP_Rowid );  sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);  }  pCompare = sqlite3PExpr(pParse, TK_EQ, 0, 0);  assert( pCompare!=0 || db->mallocFailed );  if( pCompare ){  pCompare->pLeft = pTerm->pExpr->pLeft;  pCompare->pRight = pRight = sqlite3Expr(db, TK_REGISTER, 0);  if( pRight ){  pRight->iTable = iReg+j+2;  sqlite3ExprIfFalse(  pParse, pCompare, pLevel->addrCont, SQLITE_JUMPIFNULL  );  }  pCompare->pLeft = 0;  sqlite3ExprDelete(db, pCompare);  }  }  }  assert( iIn==0 || db->mallocFailed );  }else
#endif
 if( (pLoop->wsFlags & WHERE_IPK)!=0   && (pLoop->wsFlags & (WHERE_COLUMN_IN|WHERE_COLUMN_EQ))!=0  ){  assert( pLoop->u.btree.nEq==1 );  pTerm = pLoop->aLTerm[0];  assert( pTerm!=0 );  assert( pTerm->pExpr!=0 );  testcase( pTerm->wtFlags & TERM_VIRTUAL );  iReleaseReg = ++pParse->nMem;  iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);  if( iRowidReg!=iReleaseReg ) sqlite3ReleaseTempReg(pParse, iReleaseReg);  addrNxt = pLevel->addrNxt;  sqlite3VdbeAddOp3(v, OP_SeekRowid, iCur, addrNxt, iRowidReg);  VdbeCoverage(v);  pLevel->op = OP_Noop;  }else if( (pLoop->wsFlags & WHERE_IPK)!=0   && (pLoop->wsFlags & WHERE_COLUMN_RANGE)!=0  ){  int testOp = OP_Noop;  int start;  int memEndValue = 0;  WhereTerm *pStart, *pEnd;  j = 0;  pStart = pEnd = 0;  if( pLoop->wsFlags & WHERE_BTM_LIMIT ) pStart = pLoop->aLTerm[j++];  if( pLoop->wsFlags & WHERE_TOP_LIMIT ) pEnd = pLoop->aLTerm[j++];  assert( pStart!=0 || pEnd!=0 );  if( bRev ){  pTerm = pStart;  pStart = pEnd;  pEnd = pTerm;  }  codeCursorHint(pTabItem, pWInfo, pLevel, pEnd);  if( pStart ){  Expr *pX;  int r1, rTemp;  int op;  const u8 aMoveOp[] = {   OP_SeekGT,   OP_SeekLE,   OP_SeekLT,   OP_SeekGE  };  assert( TK_LE==TK_GT+1 );  assert( TK_LT==TK_GT+2 );  assert( TK_GE==TK_GT+3 );  assert( (pStart->wtFlags & TERM_VNULL)==0 );  testcase( pStart->wtFlags & TERM_VIRTUAL );  pX = pStart->pExpr;  assert( pX!=0 );  testcase( pStart->leftCursor!=iCur );  if( sqlite3ExprIsVector(pX->pRight) ){  r1 = rTemp = sqlite3GetTempReg(pParse);  codeExprOrVector(pParse, pX->pRight, r1, 1);  testcase( pX->op==TK_GT );  testcase( pX->op==TK_GE );  testcase( pX->op==TK_LT );  testcase( pX->op==TK_LE );  op = aMoveOp[((pX->op - TK_GT - 1) & 0x3) | 0x1];  assert( pX->op!=TK_GT || op==OP_SeekGE );  assert( pX->op!=TK_GE || op==OP_SeekGE );  assert( pX->op!=TK_LT || op==OP_SeekLE );  assert( pX->op!=TK_LE || op==OP_SeekLE );  }else{  r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);  disableTerm(pLevel, pStart);  op = aMoveOp[(pX->op - TK_GT)];  }  sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);  VdbeComment((v, "pk"));  VdbeCoverageIf(v, pX->op==TK_GT);  VdbeCoverageIf(v, pX->op==TK_LE);  VdbeCoverageIf(v, pX->op==TK_LT);  VdbeCoverageIf(v, pX->op==TK_GE);  sqlite3ReleaseTempReg(pParse, rTemp);  }else{  sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iCur, addrHalt);  VdbeCoverageIf(v, bRev==0);  VdbeCoverageIf(v, bRev!=0);  }  if( pEnd ){  Expr *pX;  pX = pEnd->pExpr;  assert( pX!=0 );  assert( (pEnd->wtFlags & TERM_VNULL)==0 );  testcase( pEnd->leftCursor!=iCur );  testcase( pEnd->wtFlags & TERM_VIRTUAL );  memEndValue = ++pParse->nMem;  codeExprOrVector(pParse, pX->pRight, memEndValue, 1);  if( 0==sqlite3ExprIsVector(pX->pRight)   && (pX->op==TK_LT || pX->op==TK_GT)  ){  testOp = bRev ? OP_Le : OP_Ge;  }else{  testOp = bRev ? OP_Lt : OP_Gt;  }  if( 0==sqlite3ExprIsVector(pX->pRight) ){  disableTerm(pLevel, pEnd);  }  }  start = sqlite3VdbeCurrentAddr(v);  pLevel->op = bRev ? OP_Prev : OP_Next;  pLevel->p1 = iCur;  pLevel->p2 = start;  assert( pLevel->p5==0 );  if( testOp!=OP_Noop ){  iRowidReg = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Rowid, iCur, iRowidReg);  sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);  VdbeCoverageIf(v, testOp==OP_Le);  VdbeCoverageIf(v, testOp==OP_Lt);  VdbeCoverageIf(v, testOp==OP_Ge);  VdbeCoverageIf(v, testOp==OP_Gt);  sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL);  }  }else if( pLoop->wsFlags & WHERE_INDEXED ){  static const u8 aStartOp[] = {  0,  0,  OP_Rewind,  OP_Last,  OP_SeekGT,  OP_SeekLT,  OP_SeekGE,  OP_SeekLE  };  static const u8 aEndOp[] = {  OP_IdxGE,  OP_IdxGT,  OP_IdxLE,  OP_IdxLT,  };  u16 nEq = pLoop->u.btree.nEq;  u16 nBtm = pLoop->u.btree.nBtm;  u16 nTop = pLoop->u.btree.nTop;  int regBase;  WhereTerm *pRangeStart = 0;  WhereTerm *pRangeEnd = 0;  int startEq;  int endEq;  int start_constraints;  int nConstraint;  int iIdxCur;  int nExtraReg = 0;  int op;  char *zStartAff;  char *zEndAff = 0;  u8 bSeekPastNull = 0;  u8 bStopAtNull = 0;  int omitTable;  int regBignull = 0;  int addrSeekScan = 0;  pIdx = pLoop->u.btree.pIndex;  iIdxCur = pLevel->iIdxCur;  assert( nEq>=pLoop->nSkip );  j = nEq;  if( pLoop->wsFlags & WHERE_BTM_LIMIT ){  pRangeStart = pLoop->aLTerm[j++];  nExtraReg = MAX(nExtraReg, pLoop->u.btree.nBtm);  assert( (pRangeStart->wtFlags & TERM_LIKEOPT)==0 ||  (pLoop->wsFlags & WHERE_TOP_LIMIT)!=0 );  }  if( pLoop->wsFlags & WHERE_TOP_LIMIT ){  pRangeEnd = pLoop->aLTerm[j++];  nExtraReg = MAX(nExtraReg, pLoop->u.btree.nTop);
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 if( (pRangeEnd->wtFlags & TERM_LIKEOPT)!=0 ){  assert( pRangeStart!=0 );  assert( pRangeStart->wtFlags & TERM_LIKEOPT );  pLevel->iLikeRepCntr = (u32)++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 1, (int)pLevel->iLikeRepCntr);  VdbeComment((v, "LIKE loop counter"));  pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);  testcase( bRev );  testcase( pIdx->aSortOrder[nEq]==SQLITE_SO_DESC );  assert( (bRev & ~1)==0 );  pLevel->iLikeRepCntr <<=1;  pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq]==SQLITE_SO_DESC);  }
#endif
 if( pRangeStart==0 ){  j = pIdx->aiColumn[nEq];  if( (j>=0 && pIdx->pTable->aCol[j].notNull==0) || j==XN_EXPR ){  bSeekPastNull = 1;  }  }  }  assert( pRangeEnd==0 || (pRangeEnd->wtFlags & TERM_VNULL)==0 );  if( (pLoop->wsFlags & (WHERE_TOP_LIMIT|WHERE_BTM_LIMIT))==0   && (pLoop->wsFlags & WHERE_BIGNULL_SORT)!=0  ){  assert( bSeekPastNull==0 && nExtraReg==0 && nBtm==0 && nTop==0 );  assert( pRangeEnd==0 && pRangeStart==0 );  testcase( pLoop->nSkip>0 );  nExtraReg = 1;  bSeekPastNull = 1;  pLevel->regBignull = regBignull = ++pParse->nMem;  if( pLevel->iLeftJoin ){  sqlite3VdbeAddOp2(v, OP_Integer, 0, regBignull);  }  pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);  }  if( (nEq<pIdx->nColumn && bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC)) ){  SWAP(WhereTerm *, pRangeEnd, pRangeStart);  SWAP(u8, bSeekPastNull, bStopAtNull);  SWAP(u8, nBtm, nTop);  }  if( iLevel>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)!=0 ){  sqlite3VdbeAddOp1(v, OP_NullRow, iIdxCur);  }  codeCursorHint(pTabItem, pWInfo, pLevel, pRangeEnd);  regBase = codeAllEqualityTerms(pParse,pLevel,bRev,nExtraReg,&zStartAff);  assert( zStartAff==0 || sqlite3Strlen30(zStartAff)>=nEq );  if( zStartAff && nTop ){  zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);  }  addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);  testcase( pRangeStart && (pRangeStart->eOperator & WO_LE)!=0 );  testcase( pRangeStart && (pRangeStart->eOperator & WO_GE)!=0 );  testcase( pRangeEnd && (pRangeEnd->eOperator & WO_LE)!=0 );  testcase( pRangeEnd && (pRangeEnd->eOperator & WO_GE)!=0 );  startEq = !pRangeStart || pRangeStart->eOperator & (WO_LE|WO_GE);  endEq =  !pRangeEnd || pRangeEnd->eOperator & (WO_LE|WO_GE);  start_constraints = pRangeStart || nEq>0;  nConstraint = nEq;  if( pRangeStart ){  Expr *pRight = pRangeStart->pExpr->pRight;  codeExprOrVector(pParse, pRight, regBase+nEq, nBtm);  whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);  if( (pRangeStart->wtFlags & TERM_VNULL)==0   && sqlite3ExprCanBeNull(pRight)  ){  sqlite3VdbeAddOp2(v, OP_IsNull, regBase+nEq, addrNxt);  VdbeCoverage(v);  }  if( zStartAff ){  updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);  }  nConstraint += nBtm;  testcase( pRangeStart->wtFlags & TERM_VIRTUAL );  if( sqlite3ExprIsVector(pRight)==0 ){  disableTerm(pLevel, pRangeStart);  }else{  startEq = 1;  }  bSeekPastNull = 0;  }else if( bSeekPastNull ){  startEq = 0;  sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);  start_constraints = 1;  nConstraint++;  }else if( regBignull ){  sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);  start_constraints = 1;  nConstraint++;  }  codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);  if( pLoop->nSkip>0 && nConstraint==pLoop->nSkip ){  }else{  if( regBignull ){  sqlite3VdbeAddOp2(v, OP_Integer, 1, regBignull);  VdbeComment((v, "NULL-scan pass ctr"));  }  op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];  assert( op!=0 );  if( (pLoop->wsFlags & WHERE_IN_SEEKSCAN)!=0 && op==OP_SeekGE ){  assert( regBignull==0 );  addrSeekScan = sqlite3VdbeAddOp1(v, OP_SeekScan,   (pIdx->aiRowLogEst[0]+9)/10);  VdbeCoverage(v);  }  sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);  VdbeCoverage(v);  VdbeCoverageIf(v, op==OP_Rewind); testcase( op==OP_Rewind );  VdbeCoverageIf(v, op==OP_Last); testcase( op==OP_Last );  VdbeCoverageIf(v, op==OP_SeekGT); testcase( op==OP_SeekGT );  VdbeCoverageIf(v, op==OP_SeekGE); testcase( op==OP_SeekGE );  VdbeCoverageIf(v, op==OP_SeekLE); testcase( op==OP_SeekLE );  VdbeCoverageIf(v, op==OP_SeekLT); testcase( op==OP_SeekLT );  assert( bSeekPastNull==0 || bStopAtNull==0 );  if( regBignull ){  assert( bSeekPastNull==1 || bStopAtNull==1 );  assert( bSeekPastNull==!bStopAtNull );  assert( bStopAtNull==startEq );  sqlite3VdbeAddOp2(v, OP_Goto, 0, sqlite3VdbeCurrentAddr(v)+2);  op = aStartOp[(nConstraint>1)*4 + 2 + bRev];  sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,   nConstraint-startEq);  VdbeCoverage(v);  VdbeCoverageIf(v, op==OP_Rewind); testcase( op==OP_Rewind );  VdbeCoverageIf(v, op==OP_Last); testcase( op==OP_Last );  VdbeCoverageIf(v, op==OP_SeekGE); testcase( op==OP_SeekGE );  VdbeCoverageIf(v, op==OP_SeekLE); testcase( op==OP_SeekLE );  assert( op==OP_Rewind || op==OP_Last || op==OP_SeekGE || op==OP_SeekLE);  }  }  nConstraint = nEq;  assert( pLevel->p2==0 );  if( pRangeEnd ){  Expr *pRight = pRangeEnd->pExpr->pRight;  if( addrSeekScan ){  pLevel->p2 = sqlite3VdbeCurrentAddr(v);  }  codeExprOrVector(pParse, pRight, regBase+nEq, nTop);  whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);  if( (pRangeEnd->wtFlags & TERM_VNULL)==0   && sqlite3ExprCanBeNull(pRight)  ){  sqlite3VdbeAddOp2(v, OP_IsNull, regBase+nEq, addrNxt);  VdbeCoverage(v);  }  if( zEndAff ){  updateRangeAffinityStr(pRight, nTop, zEndAff);  codeApplyAffinity(pParse, regBase+nEq, nTop, zEndAff);  }else{  assert( pParse->db->mallocFailed );  }  nConstraint += nTop;  testcase( pRangeEnd->wtFlags & TERM_VIRTUAL );  if( sqlite3ExprIsVector(pRight)==0 ){  disableTerm(pLevel, pRangeEnd);  }else{  endEq = 1;  }  }else if( bStopAtNull ){  if( regBignull==0 ){  sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);  endEq = 0;  }  nConstraint++;  }  sqlite3DbFree(db, zStartAff);  sqlite3DbFree(db, zEndAff);  if( pLevel->p2==0 ) pLevel->p2 = sqlite3VdbeCurrentAddr(v);  if( nConstraint ){  if( regBignull ){  sqlite3VdbeAddOp2(v, OP_IfNot, regBignull, sqlite3VdbeCurrentAddr(v)+3);  VdbeComment((v, "If NULL-scan 2nd pass"));  VdbeCoverage(v);  }  op = aEndOp[bRev*2 + endEq];  sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);  testcase( op==OP_IdxGT ); VdbeCoverageIf(v, op==OP_IdxGT );  testcase( op==OP_IdxGE ); VdbeCoverageIf(v, op==OP_IdxGE );  testcase( op==OP_IdxLT ); VdbeCoverageIf(v, op==OP_IdxLT );  testcase( op==OP_IdxLE ); VdbeCoverageIf(v, op==OP_IdxLE );  if( addrSeekScan ) sqlite3VdbeJumpHere(v, addrSeekScan);  }  if( regBignull ){  assert( bSeekPastNull==!bStopAtNull );  assert( bSeekPastNull+bStopAtNull==1 );  assert( nConstraint+bSeekPastNull>0 );  sqlite3VdbeAddOp2(v, OP_If, regBignull, sqlite3VdbeCurrentAddr(v)+2);  VdbeComment((v, "If NULL-scan 1st pass"));  VdbeCoverage(v);  op = aEndOp[bRev*2 + bSeekPastNull];  sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,   nConstraint+bSeekPastNull);  testcase( op==OP_IdxGT ); VdbeCoverageIf(v, op==OP_IdxGT );  testcase( op==OP_IdxGE ); VdbeCoverageIf(v, op==OP_IdxGE );  testcase( op==OP_IdxLT ); VdbeCoverageIf(v, op==OP_IdxLT );  testcase( op==OP_IdxLE ); VdbeCoverageIf(v, op==OP_IdxLE );  }  if( (pLoop->wsFlags & WHERE_IN_EARLYOUT)!=0 ){  sqlite3VdbeAddOp3(v, OP_SeekHit, iIdxCur, nEq, nEq);  }  omitTable = (pLoop->wsFlags & WHERE_IDX_ONLY)!=0   && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0;  if( omitTable ){  }else if( HasRowid(pIdx->pTable) ){  codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);  }else if( iCur!=iIdxCur ){  Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);  iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);  for(j=0; j<pPk->nKeyCol; j++){  k = sqlite3TableColumnToIndex(pIdx, pPk->aiColumn[j]);  sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, k, iRowidReg+j);  }  sqlite3VdbeAddOp4Int(v, OP_NotFound, iCur, addrCont,   iRowidReg, pPk->nKeyCol); VdbeCoverage(v);  }  if( pLevel->iLeftJoin==0 ){  if( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0 ){  whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo);  }  if( pIdx->pPartIdxWhere ){  whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);  }  }else{  testcase( pIdx->pPartIdxWhere );  assert( (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0 );  }  if( pLoop->wsFlags & WHERE_ONEROW ){  pLevel->op = OP_Noop;  }else if( bRev ){  pLevel->op = OP_Prev;  }else{  pLevel->op = OP_Next;  }  pLevel->p1 = iIdxCur;  pLevel->p3 = (pLoop->wsFlags&WHERE_UNQ_WANTED)!=0 ? 1:0;  if( (pLoop->wsFlags & WHERE_CONSTRAINT)==0 ){  pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;  }else{  assert( pLevel->p5==0 );  }  if( omitTable ) pIdx = 0;  }else
#ifndef SQLITE_OMIT_OR_OPTIMIZATION
 if( pLoop->wsFlags & WHERE_MULTI_OR ){  WhereClause *pOrWc;  SrcList *pOrTab;  Index *pCov = 0;  int iCovCur = pParse->nTab++;  int regReturn = ++pParse->nMem;  int regRowset = 0;  int regRowid = 0;  int iLoopBody = sqlite3VdbeMakeLabel(pParse);  int iRetInit;  int untestedTerms = 0;  int ii;  Expr *pAndExpr = 0;  Table *pTab = pTabItem->pTab;  pTerm = pLoop->aLTerm[0];  assert( pTerm!=0 );  assert( pTerm->eOperator & WO_OR );  assert( (pTerm->wtFlags & TERM_ORINFO)!=0 );  pOrWc = &pTerm->u.pOrInfo->wc;  pLevel->op = OP_Return;  pLevel->p1 = regReturn;  if( pWInfo->nLevel>1 ){  int nNotReady;  SrcItem *origSrc;  nNotReady = pWInfo->nLevel - iLevel - 1;  pOrTab = sqlite3StackAllocRaw(db,  sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]));  if( pOrTab==0 ) return notReady;  pOrTab->nAlloc = (u8)(nNotReady + 1);  pOrTab->nSrc = pOrTab->nAlloc;  memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));  origSrc = pWInfo->pTabList->a;  for(k=1; k<=nNotReady; k++){  memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));  }  }else{  pOrTab = pWInfo->pTabList;  }  if( (pWInfo->wctrlFlags & WHERE_DUPLICATES_OK)==0 ){  if( HasRowid(pTab) ){  regRowset = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Null, 0, regRowset);  }else{  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  regRowset = pParse->nTab++;  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, regRowset, pPk->nKeyCol);  sqlite3VdbeSetP4KeyInfo(pParse, pPk);  }  regRowid = ++pParse->nMem;  }  iRetInit = sqlite3VdbeAddOp2(v, OP_Integer, 0, regReturn);  if( pWC->nTerm>1 ){  int iTerm;  for(iTerm=0; iTerm<pWC->nTerm; iTerm++){  Expr *pExpr = pWC->a[iTerm].pExpr;  if( &pWC->a[iTerm] == pTerm ) continue;  testcase( pWC->a[iTerm].wtFlags & TERM_VIRTUAL );  testcase( pWC->a[iTerm].wtFlags & TERM_CODED );  if( (pWC->a[iTerm].wtFlags & (TERM_VIRTUAL|TERM_CODED))!=0 ) continue;  if( (pWC->a[iTerm].eOperator & WO_ALL)==0 ) continue;  testcase( pWC->a[iTerm].wtFlags & TERM_ORINFO );  pExpr = sqlite3ExprDup(db, pExpr, 0);  pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);  }  if( pAndExpr ){  pAndExpr = sqlite3PExpr(pParse, TK_AND|0x10000, 0, pAndExpr);  }  }  ExplainQueryPlan((pParse, 1, "MULTI-INDEX OR"));  for(ii=0; ii<pOrWc->nTerm; ii++){  WhereTerm *pOrTerm = &pOrWc->a[ii];  if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & WO_AND)!=0 ){  WhereInfo *pSubWInfo;  Expr *pOrExpr = pOrTerm->pExpr;  Expr *pDelete;  int jmp1 = 0;  testcase( (pTabItem[0].fg.jointype & JT_LEFT)!=0   && !ExprHasProperty(pOrExpr, EP_FromJoin)  );  pDelete = pOrExpr = sqlite3ExprDup(db, pOrExpr, 0);  if( db->mallocFailed ){  sqlite3ExprDelete(db, pDelete);  continue;  }  if( pAndExpr ){  pAndExpr->pLeft = pOrExpr;  pOrExpr = pAndExpr;  }  ExplainQueryPlan((pParse, 1, "INDEX %d", ii+1));  WHERETRACE(0xffff, ("Subplan for OR-clause:\n"));  pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0,  WHERE_OR_SUBCLAUSE, iCovCur);  assert( pSubWInfo || pParse->nErr || db->mallocFailed );  if( pSubWInfo ){  WhereLoop *pSubLoop;  int addrExplain = sqlite3WhereExplainOneScan(  pParse, pOrTab, &pSubWInfo->a[0], 0  );  sqlite3WhereAddScanStatus(v, pOrTab, &pSubWInfo->a[0], addrExplain);  if( (pWInfo->wctrlFlags & WHERE_DUPLICATES_OK)==0 ){  int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);  if( HasRowid(pTab) ){  sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);  jmp1 = sqlite3VdbeAddOp4Int(v, OP_RowSetTest, regRowset, 0,  regRowid, iSet);  VdbeCoverage(v);  }else{  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  int nPk = pPk->nKeyCol;  int iPk;  int r;  r = sqlite3GetTempRange(pParse, nPk);  for(iPk=0; iPk<nPk; iPk++){  int iCol = pPk->aiColumn[iPk];  sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol,r+iPk);  }  if( iSet ){  jmp1 = sqlite3VdbeAddOp4Int(v, OP_Found, regRowset, 0, r, nPk);  VdbeCoverage(v);  }  if( iSet>=0 ){  sqlite3VdbeAddOp3(v, OP_MakeRecord, r, nPk, regRowid);  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, regRowset, regRowid,   r, nPk);  if( iSet ) sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);  }  sqlite3ReleaseTempRange(pParse, r, nPk);  }  }  sqlite3VdbeAddOp2(v, OP_Gosub, regReturn, iLoopBody);  if( jmp1 ) sqlite3VdbeJumpHere(v, jmp1);  if( pSubWInfo->untestedTerms ) untestedTerms = 1;  pSubLoop = pSubWInfo->a[0].pWLoop;  assert( (pSubLoop->wsFlags & WHERE_AUTO_INDEX)==0 );  if( (pSubLoop->wsFlags & WHERE_INDEXED)!=0   && (ii==0 || pSubLoop->u.btree.pIndex==pCov)   && (HasRowid(pTab) || !IsPrimaryKeyIndex(pSubLoop->u.btree.pIndex))  ){  assert( pSubWInfo->a[0].iIdxCur==iCovCur );  pCov = pSubLoop->u.btree.pIndex;  }else{  pCov = 0;  }  if( sqlite3WhereUsesDeferredSeek(pSubWInfo) ){  pWInfo->bDeferredSeek = 1;  }  sqlite3WhereEnd(pSubWInfo);  ExplainQueryPlanPop(pParse);  }  sqlite3ExprDelete(db, pDelete);  }  }  ExplainQueryPlanPop(pParse);  assert( pLevel->pWLoop==pLoop );  assert( (pLoop->wsFlags & WHERE_MULTI_OR)!=0 );  assert( (pLoop->wsFlags & WHERE_IN_ABLE)==0 );  pLevel->u.pCoveringIdx = pCov;  if( pCov ) pLevel->iIdxCur = iCovCur;  if( pAndExpr ){  pAndExpr->pLeft = 0;  sqlite3ExprDelete(db, pAndExpr);  }  sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));  sqlite3VdbeGoto(v, pLevel->addrBrk);  sqlite3VdbeResolveLabel(v, iLoopBody);  if( pWInfo->nLevel>1 ){ sqlite3StackFree(db, pOrTab); }  if( !untestedTerms ) disableTerm(pLevel, pTerm);  }else
#endif
 {  static const u8 aStep[] = { OP_Next, OP_Prev };  static const u8 aStart[] = { OP_Rewind, OP_Last };  assert( bRev==0 || bRev==1 );  if( pTabItem->fg.isRecursive ){  pLevel->op = OP_Noop;  }else{  codeCursorHint(pTabItem, pWInfo, pLevel, 0);  pLevel->op = aStep[bRev];  pLevel->p1 = iCur;  pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrHalt);  VdbeCoverageIf(v, bRev==0);  VdbeCoverageIf(v, bRev!=0);  pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;  }  }
#ifdef SQLITE_ENABLE_STMT_SCANSTATUS
 pLevel->addrVisit = sqlite3VdbeCurrentAddr(v);
#endif
 iLoop = (pIdx ? 1 : 2);  do{  int iNext = 0;  for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){  Expr *pE;  int skipLikeAddr = 0;  testcase( pTerm->wtFlags & TERM_VIRTUAL );  testcase( pTerm->wtFlags & TERM_CODED );  if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;  if( (pTerm->prereqAll & pLevel->notReady)!=0 ){  testcase( pWInfo->untestedTerms==0  && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)!=0 );  pWInfo->untestedTerms = 1;  continue;  }  pE = pTerm->pExpr;  assert( pE!=0 );  if( (pTabItem->fg.jointype&JT_LEFT) && !ExprHasProperty(pE,EP_FromJoin) ){  continue;  }  if( iLoop==1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx) ){  iNext = 2;  continue;  }  if( iLoop<3 && (pTerm->wtFlags & TERM_VARSELECT) ){  if( iNext==0 ) iNext = 3;  continue;  }  if( (pTerm->wtFlags & TERM_LIKECOND)!=0 ){
#ifdef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 continue;
#else
 u32 x = pLevel->iLikeRepCntr;  if( x>0 ){  skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?OP_IfNot:OP_If,(int)(x>>1));  VdbeCoverageIf(v, (x&1)==1);  VdbeCoverageIf(v, (x&1)==0);  }
#endif
 }
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace ){  VdbeNoopComment((v, "WhereTerm[%d] (%p) priority=%d",   pWC->nTerm-j, pTerm, iLoop));  }  if( sqlite3WhereTrace & 0x800 ){  sqlite3DebugPrintf("Coding auxiliary constraint:\n");  sqlite3WhereTermPrint(pTerm, pWC->nTerm-j);  }
#endif
 sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);  if( skipLikeAddr ) sqlite3VdbeJumpHere(v, skipLikeAddr);  pTerm->wtFlags |= TERM_CODED;  }  iLoop = iNext;  }while( iLoop>0 );  for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){  Expr *pE, sEAlt;  WhereTerm *pAlt;  if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;  if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) continue;  if( (pTerm->eOperator & WO_EQUIV)==0 ) continue;  if( pTerm->leftCursor!=iCur ) continue;  if( pTabItem->fg.jointype & JT_LEFT ) continue;  pE = pTerm->pExpr;
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x800 ){  sqlite3DebugPrintf("Coding transitive constraint:\n");  sqlite3WhereTermPrint(pTerm, pWC->nTerm-j);  }
#endif
 assert( !ExprHasProperty(pE, EP_FromJoin) );  assert( (pTerm->prereqRight & pLevel->notReady)!=0 );  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.x.leftColumn, notReady,  WO_EQ|WO_IN|WO_IS, 0);  if( pAlt==0 ) continue;  if( pAlt->wtFlags & (TERM_CODED) ) continue;  if( (pAlt->eOperator & WO_IN)   && ExprUseXSelect(pAlt->pExpr)   && (pAlt->pExpr->x.pSelect->pEList->nExpr>1)  ){  continue;  }  testcase( pAlt->eOperator & WO_EQ );  testcase( pAlt->eOperator & WO_IS );  testcase( pAlt->eOperator & WO_IN );  VdbeModuleComment((v, "begin transitive constraint"));  sEAlt = *pAlt->pExpr;  sEAlt.pLeft = pE->pLeft;  sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, SQLITE_JUMPIFNULL);  pAlt->wtFlags |= TERM_CODED;  }  if( pLevel->iLeftJoin ){  pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp2(v, OP_Integer, 1, pLevel->iLeftJoin);  VdbeComment((v, "record LEFT JOIN hit"));  for(pTerm=pWC->a, j=0; j<pWC->nTerm; j++, pTerm++){  testcase( pTerm->wtFlags & TERM_VIRTUAL );  testcase( pTerm->wtFlags & TERM_CODED );  if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;  if( (pTerm->prereqAll & pLevel->notReady)!=0 ){  assert( pWInfo->untestedTerms );  continue;  }  assert( pTerm->pExpr );  sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, SQLITE_JUMPIFNULL);  pTerm->wtFlags |= TERM_CODED;  }  }
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x20000 ){  sqlite3DebugPrintf("All WHERE-clause terms after coding level %d:\n",   iLevel);  sqlite3WhereClausePrint(pWC);  }  if( sqlite3WhereTrace & 0x800 ){  sqlite3DebugPrintf("End Coding level %d: notReady=%llx\n",   iLevel, (u64)pLevel->notReady);  }
#endif
 return pLevel->notReady; } static void exprAnalyze(SrcList*, WhereClause*, int); static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){  sqlite3WhereClauseClear(&p->wc);  sqlite3DbFree(db, p); } static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){  sqlite3WhereClauseClear(&p->wc);  sqlite3DbFree(db, p); } static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){  WhereTerm *pTerm;  int idx;  testcase( wtFlags & TERM_VIRTUAL );  if( pWC->nTerm>=pWC->nSlot ){  WhereTerm *pOld = pWC->a;  sqlite3 *db = pWC->pWInfo->pParse->db;  pWC->a = sqlite3DbMallocRawNN(db, sizeof(pWC->a[0])*pWC->nSlot*2 );  if( pWC->a==0 ){  if( wtFlags & TERM_DYNAMIC ){  sqlite3ExprDelete(db, p);  }  pWC->a = pOld;  return 0;  }  memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);  if( pOld!=pWC->aStatic ){  sqlite3DbFree(db, pOld);  }  pWC->nSlot = sqlite3DbMallocSize(db, pWC->a)/sizeof(pWC->a[0]);  }  pTerm = &pWC->a[idx = pWC->nTerm++];  if( p && ExprHasProperty(p, EP_Unlikely) ){  pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;  }else{  pTerm->truthProb = 1;  }  pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);  pTerm->wtFlags = wtFlags;  pTerm->pWC = pWC;  pTerm->iParent = -1;  memset(&pTerm->eOperator, 0,   sizeof(WhereTerm) - offsetof(WhereTerm,eOperator));  return idx; } static int allowedOp(int op){  assert( TK_GT>TK_EQ && TK_GT<TK_GE );  assert( TK_LT>TK_EQ && TK_LT<TK_GE );  assert( TK_LE>TK_EQ && TK_LE<TK_GE );  assert( TK_GE==TK_EQ+4 );  return op==TK_IN || (op>=TK_EQ && op<=TK_GE) || op==TK_ISNULL || op==TK_IS; } static u16 exprCommute(Parse *pParse, Expr *pExpr){  if( pExpr->pLeft->op==TK_VECTOR   || pExpr->pRight->op==TK_VECTOR   || sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight) !=  sqlite3BinaryCompareCollSeq(pParse, pExpr->pRight, pExpr->pLeft)  ){  pExpr->flags ^= EP_Commuted;  }  SWAP(Expr*,pExpr->pRight,pExpr->pLeft);  if( pExpr->op>=TK_GT ){  assert( TK_LT==TK_GT+2 );  assert( TK_GE==TK_LE+2 );  assert( TK_GT>TK_EQ );  assert( TK_GT<TK_LE );  assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );  pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;  }  return 0; } static u16 operatorMask(int op){  u16 c;  assert( allowedOp(op) );  if( op==TK_IN ){  c = WO_IN;  }else if( op==TK_ISNULL ){  c = WO_ISNULL;  }else if( op==TK_IS ){  c = WO_IS;  }else{  assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );  c = (u16)(WO_EQ<<(op-TK_EQ));  }  assert( op!=TK_ISNULL || c==WO_ISNULL );  assert( op!=TK_IN || c==WO_IN );  assert( op!=TK_EQ || c==WO_EQ );  assert( op!=TK_LT || c==WO_LT );  assert( op!=TK_LE || c==WO_LE );  assert( op!=TK_GT || c==WO_GT );  assert( op!=TK_GE || c==WO_GE );  assert( op!=TK_IS || c==WO_IS );  return c; }
#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION
static int isLikeOrGlob(  Parse *pParse,  Expr *pExpr,  Expr **ppPrefix,  int *pisComplete,  int *pnoCase ){  const u8 *z = 0;  Expr *pRight, *pLeft;  ExprList *pList;  u8 c;  int cnt;  u8 wc[4];  sqlite3 *db = pParse->db;  sqlite3_value *pVal = 0;  int op;  int rc;  if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, (char*)wc) ){  return 0;  }
#ifdef SQLITE_EBCDIC
 if( *pnoCase ) return 0;
#endif
 assert( ExprUseXList(pExpr) );  pList = pExpr->x.pList;  pLeft = pList->a[1].pExpr;  pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);  op = pRight->op;  if( op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){  Vdbe *pReprepare = pParse->pReprepare;  int iCol = pRight->iColumn;  pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, SQLITE_AFF_BLOB);  if( pVal && sqlite3_value_type(pVal)==SQLITE_TEXT ){  z = sqlite3_value_text(pVal);  }  sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);  assert( pRight->op==TK_VARIABLE || pRight->op==TK_REGISTER );  }else if( op==TK_STRING ){  assert( !ExprHasProperty(pRight, EP_IntValue) );   z = (u8*)pRight->u.zToken;  }  if( z ){  cnt = 0;  while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){  cnt++;  if( c==wc[3] && z[cnt]!=0 ) cnt++;  }  if( cnt!=0 && 255!=(u8)z[cnt-1] && (cnt>1 || z[0]!=wc[3]) ){  Expr *pPrefix;  *pisComplete = c==wc[0] && z[cnt+1]==0;  pPrefix = sqlite3Expr(db, TK_STRING, (char*)z);  if( pPrefix ){  int iFrom, iTo;  char *zNew;  assert( !ExprHasProperty(pPrefix, EP_IntValue) );  zNew = pPrefix->u.zToken;  zNew[cnt] = 0;  for(iFrom=iTo=0; iFrom<cnt; iFrom++){  if( zNew[iFrom]==wc[3] ) iFrom++;  zNew[iTo++] = zNew[iFrom];  }  zNew[iTo] = 0;  assert( iTo>0 );  if( pLeft->op!=TK_COLUMN   || sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT   || (ALWAYS( ExprUseYTab(pLeft) )   && pLeft->y.pTab   && IsVirtual(pLeft->y.pTab))  ){  int isNum;  double rDummy;  isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);  if( isNum<=0 ){  if( iTo==1 && zNew[0]=='-' ){  isNum = +1;  }else{  zNew[iTo-1]++;  isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);  zNew[iTo-1]--;  }  }  if( isNum>0 ){  sqlite3ExprDelete(db, pPrefix);  sqlite3ValueFree(pVal);  return 0;  }  }  }  *ppPrefix = pPrefix;  if( op==TK_VARIABLE ){  Vdbe *v = pParse->pVdbe;  sqlite3VdbeSetVarmask(v, pRight->iColumn);  assert( !ExprHasProperty(pRight, EP_IntValue) );  if( *pisComplete && pRight->u.zToken[1] ){  int r1 = sqlite3GetTempReg(pParse);  sqlite3ExprCodeTarget(pParse, pRight, r1);  sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);  sqlite3ReleaseTempReg(pParse, r1);  }  }  }else{  z = 0;  }  }  rc = (z!=0);  sqlite3ValueFree(pVal);  return rc; }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
static int isAuxiliaryVtabOperator(  sqlite3 *db,  Expr *pExpr,  unsigned char *peOp2,  Expr **ppLeft,  Expr **ppRight ){  if( pExpr->op==TK_FUNCTION ){  static const struct Op2 {  const char *zOp;  unsigned char eOp2;  } aOp[] = {  { "match", SQLITE_INDEX_CONSTRAINT_MATCH },  { "glob", SQLITE_INDEX_CONSTRAINT_GLOB },  { "like", SQLITE_INDEX_CONSTRAINT_LIKE },  { "regexp", SQLITE_INDEX_CONSTRAINT_REGEXP }  };  ExprList *pList;  Expr *pCol;  int i;  assert( ExprUseXList(pExpr) );  pList = pExpr->x.pList;  if( pList==0 || pList->nExpr!=2 ){  return 0;  }  pCol = pList->a[1].pExpr;  assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );  testcase( pCol->op==TK_COLUMN && pCol->y.pTab==0 );  if( ExprIsVtab(pCol) ){  for(i=0; i<ArraySize(aOp); i++){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  if( sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp)==0 ){  *peOp2 = aOp[i].eOp2;  *ppRight = pList->a[0].pExpr;  *ppLeft = pCol;  return 1;  }  }  }  pCol = pList->a[0].pExpr;  assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );  testcase( pCol->op==TK_COLUMN && pCol->y.pTab==0 );  if( ExprIsVtab(pCol) ){  sqlite3_vtab *pVtab;  sqlite3_module *pMod;  void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);  void *pNotUsed;  pVtab = sqlite3GetVTable(db, pCol->y.pTab)->pVtab;  assert( pVtab!=0 );  assert( pVtab->pModule!=0 );  assert( !ExprHasProperty(pExpr, EP_IntValue) );   pMod = (sqlite3_module *)pVtab->pModule;  if( pMod->xFindFunction!=0 ){  i = pMod->xFindFunction(pVtab,2, pExpr->u.zToken, &xNotUsed, &pNotUsed);  if( i>=SQLITE_INDEX_CONSTRAINT_FUNCTION ){  *peOp2 = i;  *ppRight = pList->a[1].pExpr;  *ppLeft = pCol;  return 1;  }  }  }  }else if( pExpr->op==TK_NE || pExpr->op==TK_ISNOT || pExpr->op==TK_NOTNULL ){  int res = 0;  Expr *pLeft = pExpr->pLeft;  Expr *pRight = pExpr->pRight;  assert( pLeft->op!=TK_COLUMN || ExprUseYTab(pLeft) );  testcase( pLeft->op==TK_COLUMN && pLeft->y.pTab==0 );  if( ExprIsVtab(pLeft) ){  res++;  }  assert( pRight==0 || pRight->op!=TK_COLUMN || ExprUseYTab(pRight) );  testcase( pRight && pRight->op==TK_COLUMN && pRight->y.pTab==0 );  if( pRight && ExprIsVtab(pRight) ){  res++;  SWAP(Expr*, pLeft, pRight);  }  *ppLeft = pLeft;  *ppRight = pRight;  if( pExpr->op==TK_NE ) *peOp2 = SQLITE_INDEX_CONSTRAINT_NE;  if( pExpr->op==TK_ISNOT ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOT;  if( pExpr->op==TK_NOTNULL ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOTNULL;  return res;  }  return 0; }
#endif
static void transferJoinMarkings(Expr *pDerived, Expr *pBase){  if( pDerived ){  pDerived->flags |= pBase->flags & EP_FromJoin;  pDerived->iRightJoinTable = pBase->iRightJoinTable;  } } static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){  pWC->a[iChild].iParent = iParent;  pWC->a[iChild].truthProb = pWC->a[iParent].truthProb;  pWC->a[iParent].nChild++; } static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){  if( pTerm->eOperator!=WO_AND ){  return N==0 ? pTerm : 0;  }  if( N<pTerm->u.pAndInfo->wc.nTerm ){  return &pTerm->u.pAndInfo->wc.a[N];  }  return 0; } static void whereCombineDisjuncts(  SrcList *pSrc,  WhereClause *pWC,  WhereTerm *pOne,  WhereTerm *pTwo ){  u16 eOp = pOne->eOperator | pTwo->eOperator;  sqlite3 *db;  Expr *pNew;  int op;  int idxNew;  if( (pOne->wtFlags | pTwo->wtFlags) & TERM_VNULL ) return;  if( (pOne->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;  if( (pTwo->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;  if( (eOp & (WO_EQ|WO_LT|WO_LE))!=eOp   && (eOp & (WO_EQ|WO_GT|WO_GE))!=eOp ) return;  assert( pOne->pExpr->pLeft!=0 && pOne->pExpr->pRight!=0 );  assert( pTwo->pExpr->pLeft!=0 && pTwo->pExpr->pRight!=0 );  if( sqlite3ExprCompare(0,pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;  if( sqlite3ExprCompare(0,pOne->pExpr->pRight, pTwo->pExpr->pRight,-1) )return;  if( (eOp & (eOp-1))!=0 ){  if( eOp & (WO_LT|WO_LE) ){  eOp = WO_LE;  }else{  assert( eOp & (WO_GT|WO_GE) );  eOp = WO_GE;  }  }  db = pWC->pWInfo->pParse->db;  pNew = sqlite3ExprDup(db, pOne->pExpr, 0);  if( pNew==0 ) return;  for(op=TK_EQ; eOp!=(WO_EQ<<(op-TK_EQ)); op++){ assert( op<TK_GE ); }  pNew->op = op;  idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);  exprAnalyze(pSrc, pWC, idxNew); }
#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)
static void exprAnalyzeOrTerm(  SrcList *pSrc,  WhereClause *pWC,  int idxTerm ){  WhereInfo *pWInfo = pWC->pWInfo;  Parse *pParse = pWInfo->pParse;  sqlite3 *db = pParse->db;  WhereTerm *pTerm = &pWC->a[idxTerm];  Expr *pExpr = pTerm->pExpr;  int i;  WhereClause *pOrWc;  WhereTerm *pOrTerm;  WhereOrInfo *pOrInfo;  Bitmask chngToIN;  Bitmask indexable;  assert( (pTerm->wtFlags & (TERM_DYNAMIC|TERM_ORINFO|TERM_ANDINFO))==0 );  assert( pExpr->op==TK_OR );  pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));  if( pOrInfo==0 ) return;  pTerm->wtFlags |= TERM_ORINFO;  pOrWc = &pOrInfo->wc;  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));  sqlite3WhereClauseInit(pOrWc, pWInfo);  sqlite3WhereSplit(pOrWc, pExpr, TK_OR);  sqlite3WhereExprAnalyze(pSrc, pOrWc);  if( db->mallocFailed ) return;  assert( pOrWc->nTerm>=2 );  indexable = ~(Bitmask)0;  chngToIN = ~(Bitmask)0;  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){  if( (pOrTerm->eOperator & WO_SINGLE)==0 ){  WhereAndInfo *pAndInfo;  assert( (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 );  chngToIN = 0;  pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));  if( pAndInfo ){  WhereClause *pAndWC;  WhereTerm *pAndTerm;  int j;  Bitmask b = 0;  pOrTerm->u.pAndInfo = pAndInfo;  pOrTerm->wtFlags |= TERM_ANDINFO;  pOrTerm->eOperator = WO_AND;  pOrTerm->leftCursor = -1;  pAndWC = &pAndInfo->wc;  memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));  sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);  sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, TK_AND);  sqlite3WhereExprAnalyze(pSrc, pAndWC);  pAndWC->pOuter = pWC;  if( !db->mallocFailed ){  for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){  assert( pAndTerm->pExpr );  if( allowedOp(pAndTerm->pExpr->op)   || pAndTerm->eOperator==WO_AUX  ){  b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pAndTerm->leftCursor);  }  }  }  indexable &= b;  }  }else if( pOrTerm->wtFlags & TERM_COPIED ){  }else{  Bitmask b;  b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);  if( pOrTerm->wtFlags & TERM_VIRTUAL ){  WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];  b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);  }  indexable &= b;  if( (pOrTerm->eOperator & WO_EQ)==0 ){  chngToIN = 0;  }else{  chngToIN &= b;  }  }  }  pOrInfo->indexable = indexable;  pTerm->eOperator = WO_OR;  pTerm->leftCursor = -1;  if( indexable ){  pWC->hasOr = 1;  }  if( indexable && pOrWc->nTerm==2 ){  int iOne = 0;  WhereTerm *pOne;  while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){  int iTwo = 0;  WhereTerm *pTwo;  while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){  whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);  }  }  }  if( chngToIN ){  int okToChngToIN = 0;  int iColumn = -1;  int iCursor = -1;  int j = 0;  for(j=0; j<2 && !okToChngToIN; j++){  Expr *pLeft = 0;  pOrTerm = pOrWc->a;  for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){  assert( pOrTerm->eOperator & WO_EQ );  pOrTerm->wtFlags &= ~TERM_OR_OK;  if( pOrTerm->leftCursor==iCursor ){  assert( j==1 );  continue;  }  if( (chngToIN & sqlite3WhereGetMask(&pWInfo->sMaskSet,  pOrTerm->leftCursor))==0 ){  testcase( pOrTerm->wtFlags & TERM_COPIED );  testcase( pOrTerm->wtFlags & TERM_VIRTUAL );  assert( pOrTerm->wtFlags & (TERM_COPIED|TERM_VIRTUAL) );  continue;  }  assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );  iColumn = pOrTerm->u.x.leftColumn;  iCursor = pOrTerm->leftCursor;  pLeft = pOrTerm->pExpr->pLeft;  break;  }  if( i<0 ){  assert( j==1 );  assert( IsPowerOfTwo(chngToIN) );  assert( chngToIN==sqlite3WhereGetMask(&pWInfo->sMaskSet, iCursor) );  break;  }  testcase( j==1 );  okToChngToIN = 1;  for(; i>=0 && okToChngToIN; i--, pOrTerm++){  assert( pOrTerm->eOperator & WO_EQ );  assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );  if( pOrTerm->leftCursor!=iCursor ){  pOrTerm->wtFlags &= ~TERM_OR_OK;  }else if( pOrTerm->u.x.leftColumn!=iColumn || (iColumn==XN_EXPR   && sqlite3ExprCompare(pParse, pOrTerm->pExpr->pLeft, pLeft, -1)  )){  okToChngToIN = 0;  }else{  int affLeft, affRight;  affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);  affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);  if( affRight!=0 && affRight!=affLeft ){  okToChngToIN = 0;  }else{  pOrTerm->wtFlags |= TERM_OR_OK;  }  }  }  }  if( okToChngToIN ){  Expr *pDup;  ExprList *pList = 0;  Expr *pLeft = 0;  Expr *pNew;  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){  if( (pOrTerm->wtFlags & TERM_OR_OK)==0 ) continue;  assert( pOrTerm->eOperator & WO_EQ );  assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );  assert( pOrTerm->leftCursor==iCursor );  assert( pOrTerm->u.x.leftColumn==iColumn );  pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);  pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);  pLeft = pOrTerm->pExpr->pLeft;  }  assert( pLeft!=0 );  pDup = sqlite3ExprDup(db, pLeft, 0);  pNew = sqlite3PExpr(pParse, TK_IN, pDup, 0);  if( pNew ){  int idxNew;  transferJoinMarkings(pNew, pExpr);  assert( ExprUseXList(pNew) );  pNew->x.pList = pList;  idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);  testcase( idxNew==0 );  exprAnalyze(pSrc, pWC, idxNew);  markTermAsChild(pWC, idxNew, idxTerm);  }else{  sqlite3ExprListDelete(db, pList);  }  }  } }
#endif
static int termIsEquivalence(Parse *pParse, Expr *pExpr){  char aff1, aff2;  CollSeq *pColl;  if( !OptimizationEnabled(pParse->db, SQLITE_Transitive) ) return 0;  if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;  if( ExprHasProperty(pExpr, EP_FromJoin) ) return 0;  aff1 = sqlite3ExprAffinity(pExpr->pLeft);  aff2 = sqlite3ExprAffinity(pExpr->pRight);  if( aff1!=aff2   && (!sqlite3IsNumericAffinity(aff1) || !sqlite3IsNumericAffinity(aff2))  ){  return 0;  }  pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);  if( sqlite3IsBinary(pColl) ) return 1;  return sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight); } static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){  Bitmask mask = 0;  while( pS ){  SrcList *pSrc = pS->pSrc;  mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);  mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);  mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);  mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);  mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);  if( ALWAYS(pSrc!=0) ){  int i;  for(i=0; i<pSrc->nSrc; i++){  mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);  mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);  if( pSrc->a[i].fg.isTabFunc ){  mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);  }  }  }  pS = pS->pPrior;  }  return mask; } static SQLITE_NOINLINE int exprMightBeIndexed2(  SrcList *pFrom,  Bitmask mPrereq,  int *aiCurCol,  Expr *pExpr ){  Index *pIdx;  int i;  int iCur;  for(i=0; mPrereq>1; i++, mPrereq>>=1){}  iCur = pFrom->a[i].iCursor;  for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){  if( pIdx->aColExpr==0 ) continue;  for(i=0; i<pIdx->nKeyCol; i++){  if( pIdx->aiColumn[i]!=XN_EXPR ) continue;  if( sqlite3ExprCompareSkip(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){  aiCurCol[0] = iCur;  aiCurCol[1] = XN_EXPR;  return 1;  }  }  }  return 0; } static int exprMightBeIndexed(  SrcList *pFrom,  Bitmask mPrereq,  int *aiCurCol,  Expr *pExpr,  int op ){  assert( TK_GT+1==TK_LE && TK_GT+2==TK_LT && TK_GT+3==TK_GE );  assert( TK_IS<TK_GE && TK_ISNULL<TK_GE && TK_IN<TK_GE );  assert( op<=TK_GE );  if( pExpr->op==TK_VECTOR && (op>=TK_GT && ALWAYS(op<=TK_GE)) ){  assert( ExprUseXList(pExpr) );  pExpr = pExpr->x.pList->a[0].pExpr;  }  if( pExpr->op==TK_COLUMN ){  aiCurCol[0] = pExpr->iTable;  aiCurCol[1] = pExpr->iColumn;  return 1;  }  if( mPrereq==0 ) return 0;  if( (mPrereq&(mPrereq-1))!=0 ) return 0;  return exprMightBeIndexed2(pFrom,mPrereq,aiCurCol,pExpr); } static void exprAnalyze(  SrcList *pSrc,  WhereClause *pWC,  int idxTerm ){  WhereInfo *pWInfo = pWC->pWInfo;  WhereTerm *pTerm;  WhereMaskSet *pMaskSet;  Expr *pExpr;  Bitmask prereqLeft;  Bitmask prereqAll;  Bitmask extraRight = 0;  Expr *pStr1 = 0;  int isComplete = 0;  int noCase = 0;  int op;  Parse *pParse = pWInfo->pParse;  sqlite3 *db = pParse->db;  unsigned char eOp2 = 0;  int nLeft;  if( db->mallocFailed ){  return;  }  pTerm = &pWC->a[idxTerm];  pMaskSet = &pWInfo->sMaskSet;  pExpr = pTerm->pExpr;  assert( pExpr->op!=TK_AS && pExpr->op!=TK_COLLATE );  prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);  op = pExpr->op;  if( op==TK_IN ){  assert( pExpr->pRight==0 );  if( sqlite3ExprCheckIN(pParse, pExpr) ) return;  if( ExprUseXSelect(pExpr) ){  pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);  }else{  pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);  }  }else if( op==TK_ISNULL ){  pTerm->prereqRight = 0;  }else{  pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);  }  pMaskSet->bVarSelect = 0;  prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr);  if( pMaskSet->bVarSelect ) pTerm->wtFlags |= TERM_VARSELECT;  if( ExprHasProperty(pExpr, EP_FromJoin) ){  Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->iRightJoinTable);  prereqAll |= x;  extraRight = x-1;  if( (prereqAll>>1)>=x ){  sqlite3ErrorMsg(pParse, "ON clause references tables to its right");  return;  }  }  pTerm->prereqAll = prereqAll;  pTerm->leftCursor = -1;  pTerm->iParent = -1;  pTerm->eOperator = 0;  if( allowedOp(op) ){  int aiCurCol[2];  Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);  Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);  u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? WO_ALL : WO_EQUIV;  if( pTerm->u.x.iField>0 ){  assert( op==TK_IN );  assert( pLeft->op==TK_VECTOR );  assert( ExprUseXList(pLeft) );  pLeft = pLeft->x.pList->a[pTerm->u.x.iField-1].pExpr;  }  if( exprMightBeIndexed(pSrc, prereqLeft, aiCurCol, pLeft, op) ){  pTerm->leftCursor = aiCurCol[0];  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  pTerm->u.x.leftColumn = aiCurCol[1];  pTerm->eOperator = operatorMask(op) & opMask;  }  if( op==TK_IS ) pTerm->wtFlags |= TERM_IS;  if( pRight   && exprMightBeIndexed(pSrc, pTerm->prereqRight, aiCurCol, pRight, op)   && !ExprHasProperty(pRight, EP_FixedCol)  ){  WhereTerm *pNew;  Expr *pDup;  u16 eExtraOp = 0;  assert( pTerm->u.x.iField==0 );  if( pTerm->leftCursor>=0 ){  int idxNew;  pDup = sqlite3ExprDup(db, pExpr, 0);  if( db->mallocFailed ){  sqlite3ExprDelete(db, pDup);  return;  }  idxNew = whereClauseInsert(pWC, pDup, TERM_VIRTUAL|TERM_DYNAMIC);  if( idxNew==0 ) return;  pNew = &pWC->a[idxNew];  markTermAsChild(pWC, idxNew, idxTerm);  if( op==TK_IS ) pNew->wtFlags |= TERM_IS;  pTerm = &pWC->a[idxTerm];  pTerm->wtFlags |= TERM_COPIED;  if( termIsEquivalence(pParse, pDup) ){  pTerm->eOperator |= WO_EQUIV;  eExtraOp = WO_EQUIV;  }  }else{  pDup = pExpr;  pNew = pTerm;  }  pNew->wtFlags |= exprCommute(pParse, pDup);  pNew->leftCursor = aiCurCol[0];  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  pNew->u.x.leftColumn = aiCurCol[1];  testcase( (prereqLeft | extraRight) != prereqLeft );  pNew->prereqRight = prereqLeft | extraRight;  pNew->prereqAll = prereqAll;  pNew->eOperator = (operatorMask(pDup->op) + eExtraOp) & opMask;  }else  if( op==TK_ISNULL   && !ExprHasProperty(pExpr,EP_FromJoin)   && 0==sqlite3ExprCanBeNull(pLeft)  ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );  pExpr->op = TK_TRUEFALSE;  pExpr->u.zToken = "false";  ExprSetProperty(pExpr, EP_IsFalse);  pTerm->prereqAll = 0;  pTerm->eOperator = 0;  }  }
#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION
 else if( pExpr->op==TK_BETWEEN && pWC->op==TK_AND ){  ExprList *pList;  int i;  static const u8 ops[] = {TK_GE, TK_LE};  assert( ExprUseXList(pExpr) );  pList = pExpr->x.pList;  assert( pList!=0 );  assert( pList->nExpr==2 );  for(i=0; i<2; i++){  Expr *pNewExpr;  int idxNew;  pNewExpr = sqlite3PExpr(pParse, ops[i],   sqlite3ExprDup(db, pExpr->pLeft, 0),   sqlite3ExprDup(db, pList->a[i].pExpr, 0));  transferJoinMarkings(pNewExpr, pExpr);  idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);  testcase( idxNew==0 );  exprAnalyze(pSrc, pWC, idxNew);  pTerm = &pWC->a[idxTerm];  markTermAsChild(pWC, idxNew, idxTerm);  }  }
#endif
#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)
 else if( pExpr->op==TK_OR ){  assert( pWC->op==TK_AND );  exprAnalyzeOrTerm(pSrc, pWC, idxTerm);  pTerm = &pWC->a[idxTerm];  }
#endif
 else if( pExpr->op==TK_NOTNULL ){  if( pExpr->pLeft->op==TK_COLUMN   && pExpr->pLeft->iColumn>=0   && !ExprHasProperty(pExpr, EP_FromJoin)  ){  Expr *pNewExpr;  Expr *pLeft = pExpr->pLeft;  int idxNew;  WhereTerm *pNewTerm;  pNewExpr = sqlite3PExpr(pParse, TK_GT,  sqlite3ExprDup(db, pLeft, 0),  sqlite3ExprAlloc(db, TK_NULL, 0, 0));  idxNew = whereClauseInsert(pWC, pNewExpr,  TERM_VIRTUAL|TERM_DYNAMIC|TERM_VNULL);  if( idxNew ){  pNewTerm = &pWC->a[idxNew];  pNewTerm->prereqRight = 0;  pNewTerm->leftCursor = pLeft->iTable;  pNewTerm->u.x.leftColumn = pLeft->iColumn;  pNewTerm->eOperator = WO_GT;  markTermAsChild(pWC, idxNew, idxTerm);  pTerm = &pWC->a[idxTerm];  pTerm->wtFlags |= TERM_COPIED;  pNewTerm->prereqAll = pTerm->prereqAll;  }  }  }
#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION
 else if( pExpr->op==TK_FUNCTION   && pWC->op==TK_AND   && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)  ){  Expr *pLeft;  Expr *pStr2;  Expr *pNewExpr1;  Expr *pNewExpr2;  int idxNew1;  int idxNew2;  const char *zCollSeqName;  const u16 wtFlags = TERM_LIKEOPT | TERM_VIRTUAL | TERM_DYNAMIC;  assert( ExprUseXList(pExpr) );  pLeft = pExpr->x.pList->a[1].pExpr;  pStr2 = sqlite3ExprDup(db, pStr1, 0);  assert( pStr1==0 || !ExprHasProperty(pStr1, EP_IntValue) );  assert( pStr2==0 || !ExprHasProperty(pStr2, EP_IntValue) );  if( noCase && !pParse->db->mallocFailed ){  int i;  char c;  pTerm->wtFlags |= TERM_LIKE;  for(i=0; (c = pStr1->u.zToken[i])!=0; i++){  pStr1->u.zToken[i] = sqlite3Toupper(c);  pStr2->u.zToken[i] = sqlite3Tolower(c);  }  }  if( !db->mallocFailed ){  u8 c, *pC;  pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];  c = *pC;  if( noCase ){  if( c=='A'-1 ) isComplete = 0;  c = sqlite3UpperToLower[c];  }  *pC = c + 1;  }  zCollSeqName = noCase ? "NOCASE" : sqlite3StrBINARY;  pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);  pNewExpr1 = sqlite3PExpr(pParse, TK_GE,   sqlite3ExprAddCollateString(pParse,pNewExpr1,zCollSeqName),   pStr1);  transferJoinMarkings(pNewExpr1, pExpr);  idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);  testcase( idxNew1==0 );  exprAnalyze(pSrc, pWC, idxNew1);  pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);  pNewExpr2 = sqlite3PExpr(pParse, TK_LT,   sqlite3ExprAddCollateString(pParse,pNewExpr2,zCollSeqName),   pStr2);  transferJoinMarkings(pNewExpr2, pExpr);  idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);  testcase( idxNew2==0 );  exprAnalyze(pSrc, pWC, idxNew2);  pTerm = &pWC->a[idxTerm];  if( isComplete ){  markTermAsChild(pWC, idxNew1, idxTerm);  markTermAsChild(pWC, idxNew2, idxTerm);  }  }
#endif
 if( (pExpr->op==TK_EQ || pExpr->op==TK_IS)   && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1   && sqlite3ExprVectorSize(pExpr->pRight)==nLeft   && ( (pExpr->pLeft->flags & EP_xIsSelect)==0   || (pExpr->pRight->flags & EP_xIsSelect)==0)   && pWC->op==TK_AND  ){  int i;  for(i=0; i<nLeft; i++){  int idxNew;  Expr *pNew;  Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i, nLeft);  Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i, nLeft);  pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight);  transferJoinMarkings(pNew, pExpr);  idxNew = whereClauseInsert(pWC, pNew, TERM_DYNAMIC);  exprAnalyze(pSrc, pWC, idxNew);  }  pTerm = &pWC->a[idxTerm];  pTerm->wtFlags |= TERM_CODED|TERM_VIRTUAL;  pTerm->eOperator = 0;  }  else if( pExpr->op==TK_IN   && pTerm->u.x.iField==0   && pExpr->pLeft->op==TK_VECTOR   && ALWAYS( ExprUseXSelect(pExpr) )   && pExpr->x.pSelect->pPrior==0
#ifndef SQLITE_OMIT_WINDOWFUNC
  && pExpr->x.pSelect->pWin==0
#endif
  && pWC->op==TK_AND  ){  int i;  for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){  int idxNew;  idxNew = whereClauseInsert(pWC, pExpr, TERM_VIRTUAL);  pWC->a[idxNew].u.x.iField = i+1;  exprAnalyze(pSrc, pWC, idxNew);  markTermAsChild(pWC, idxNew, idxTerm);  }  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 else if( pWC->op==TK_AND ){  Expr *pRight = 0, *pLeft = 0;  int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);  while( res-- > 0 ){  int idxNew;  WhereTerm *pNewTerm;  Bitmask prereqColumn, prereqExpr;  prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);  prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);  if( (prereqExpr & prereqColumn)==0 ){  Expr *pNewExpr;  pNewExpr = sqlite3PExpr(pParse, TK_MATCH,  0, sqlite3ExprDup(db, pRight, 0));  if( ExprHasProperty(pExpr, EP_FromJoin) && pNewExpr ){  ExprSetProperty(pNewExpr, EP_FromJoin);  pNewExpr->iRightJoinTable = pExpr->iRightJoinTable;  }  idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);  testcase( idxNew==0 );  pNewTerm = &pWC->a[idxNew];  pNewTerm->prereqRight = prereqExpr;  pNewTerm->leftCursor = pLeft->iTable;  pNewTerm->u.x.leftColumn = pLeft->iColumn;  pNewTerm->eOperator = WO_AUX;  pNewTerm->eMatchOp = eOp2;  markTermAsChild(pWC, idxNew, idxTerm);  pTerm = &pWC->a[idxTerm];  pTerm->wtFlags |= TERM_COPIED;  pNewTerm->prereqAll = pTerm->prereqAll;  }  SWAP(Expr*, pLeft, pRight);  }  }
#endif
 testcase( pTerm!=&pWC->a[idxTerm] );  pTerm = &pWC->a[idxTerm];  pTerm->prereqRight |= extraRight; } SQLITE_PRIVATE void sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op){  Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);  pWC->op = op;  assert( pE2!=0 || pExpr==0 );  if( pE2==0 ) return;  if( pE2->op!=op ){  whereClauseInsert(pWC, pExpr, 0);  }else{  sqlite3WhereSplit(pWC, pE2->pLeft, op);  sqlite3WhereSplit(pWC, pE2->pRight, op);  } } SQLITE_PRIVATE void sqlite3WhereClauseInit(  WhereClause *pWC,  WhereInfo *pWInfo ){  pWC->pWInfo = pWInfo;  pWC->hasOr = 0;  pWC->pOuter = 0;  pWC->nTerm = 0;  pWC->nSlot = ArraySize(pWC->aStatic);  pWC->a = pWC->aStatic; } SQLITE_PRIVATE void sqlite3WhereClauseClear(WhereClause *pWC){  int i;  WhereTerm *a;  sqlite3 *db = pWC->pWInfo->pParse->db;  for(i=pWC->nTerm-1, a=pWC->a; i>=0; i--, a++){  if( a->wtFlags & TERM_DYNAMIC ){  sqlite3ExprDelete(db, a->pExpr);  }  if( a->wtFlags & TERM_ORINFO ){  whereOrInfoDelete(db, a->u.pOrInfo);  }else if( a->wtFlags & TERM_ANDINFO ){  whereAndInfoDelete(db, a->u.pAndInfo);  }  }  if( pWC->a!=pWC->aStatic ){  sqlite3DbFree(db, pWC->a);  } } SQLITE_PRIVATE Bitmask sqlite3WhereExprUsageNN(WhereMaskSet *pMaskSet, Expr *p){  Bitmask mask;  if( p->op==TK_COLUMN && !ExprHasProperty(p, EP_FixedCol) ){  return sqlite3WhereGetMask(pMaskSet, p->iTable);  }else if( ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){  assert( p->op!=TK_IF_NULL_ROW );  return 0;  }  mask = (p->op==TK_IF_NULL_ROW) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;  if( p->pLeft ) mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);  if( p->pRight ){  mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pRight);  assert( p->x.pList==0 );  }else if( ExprUseXSelect(p) ){  if( ExprHasProperty(p, EP_VarSelect) ) pMaskSet->bVarSelect = 1;  mask |= exprSelectUsage(pMaskSet, p->x.pSelect);  }else if( p->x.pList ){  mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( (p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION) && ExprUseYWin(p) ){  assert( p->y.pWin!=0 );  mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pPartition);  mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pOrderBy);  mask |= sqlite3WhereExprUsage(pMaskSet, p->y.pWin->pFilter);  }
#endif
 return mask; } SQLITE_PRIVATE Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p){  return p ? sqlite3WhereExprUsageNN(pMaskSet,p) : 0; } SQLITE_PRIVATE Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList){  int i;  Bitmask mask = 0;  if( pList ){  for(i=0; i<pList->nExpr; i++){  mask |= sqlite3WhereExprUsage(pMaskSet, pList->a[i].pExpr);  }  }  return mask; } SQLITE_PRIVATE void sqlite3WhereExprAnalyze(  SrcList *pTabList,  WhereClause *pWC ){  int i;  for(i=pWC->nTerm-1; i>=0; i--){  exprAnalyze(pTabList, pWC, i);  } } SQLITE_PRIVATE void sqlite3WhereTabFuncArgs(  Parse *pParse,  SrcItem *pItem,  WhereClause *pWC ){  Table *pTab;  int j, k;  ExprList *pArgs;  Expr *pColRef;  Expr *pTerm;  if( pItem->fg.isTabFunc==0 ) return;  pTab = pItem->pTab;  assert( pTab!=0 );  pArgs = pItem->u1.pFuncArg;  if( pArgs==0 ) return;  for(j=k=0; j<pArgs->nExpr; j++){  Expr *pRhs;  while( k<pTab->nCol && (pTab->aCol[k].colFlags & COLFLAG_HIDDEN)==0 ){k++;}  if( k>=pTab->nCol ){  sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d",  pTab->zName, j);  return;  }  pColRef = sqlite3ExprAlloc(pParse->db, TK_COLUMN, 0, 0);  if( pColRef==0 ) return;  pColRef->iTable = pItem->iCursor;  pColRef->iColumn = k++;  assert( ExprUseYTab(pColRef) );  pColRef->y.pTab = pTab;  pRhs = sqlite3PExpr(pParse, TK_UPLUS,  sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0), 0);  pTerm = sqlite3PExpr(pParse, TK_EQ, pColRef, pRhs);  if( pItem->fg.jointype & JT_LEFT ){  sqlite3SetJoinExpr(pTerm, pItem->iCursor);  }  whereClauseInsert(pWC, pTerm, TERM_DYNAMIC);  } } typedef struct HiddenIndexInfo HiddenIndexInfo; struct HiddenIndexInfo {  WhereClause *pWC;  Parse *pParse; }; static int whereLoopResize(sqlite3*, WhereLoop*, int); SQLITE_PRIVATE LogEst sqlite3WhereOutputRowCount(WhereInfo *pWInfo){  return pWInfo->nRowOut; } SQLITE_PRIVATE int sqlite3WhereIsDistinct(WhereInfo *pWInfo){  return pWInfo->eDistinct; } SQLITE_PRIVATE int sqlite3WhereIsOrdered(WhereInfo *pWInfo){  return pWInfo->nOBSat; } SQLITE_PRIVATE int sqlite3WhereOrderByLimitOptLabel(WhereInfo *pWInfo){  WhereLevel *pInner;  if( !pWInfo->bOrderedInnerLoop ){  return pWInfo->iContinue;  }  pInner = &pWInfo->a[pWInfo->nLevel-1];  assert( pInner->addrNxt!=0 );  return pInner->addrNxt; } SQLITE_PRIVATE void sqlite3WhereMinMaxOptEarlyOut(Vdbe *v, WhereInfo *pWInfo){  WhereLevel *pInner;  int i;  if( !pWInfo->bOrderedInnerLoop ) return;  if( pWInfo->nOBSat==0 ) return;  for(i=pWInfo->nLevel-1; i>=0; i--){  pInner = &pWInfo->a[i];  if( (pInner->pWLoop->wsFlags & WHERE_COLUMN_IN)!=0 ){  sqlite3VdbeGoto(v, pInner->addrNxt);  return;  }  }  sqlite3VdbeGoto(v, pWInfo->iBreak); } SQLITE_PRIVATE int sqlite3WhereContinueLabel(WhereInfo *pWInfo){  assert( pWInfo->iContinue!=0 );  return pWInfo->iContinue; } SQLITE_PRIVATE int sqlite3WhereBreakLabel(WhereInfo *pWInfo){  return pWInfo->iBreak; } SQLITE_PRIVATE int sqlite3WhereOkOnePass(WhereInfo *pWInfo, int *aiCur){  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace && pWInfo->eOnePass!=ONEPASS_OFF ){  sqlite3DebugPrintf("%s cursors: %d %d\n",   pWInfo->eOnePass==ONEPASS_SINGLE ? "ONEPASS_SINGLE" : "ONEPASS_MULTI",   aiCur[0], aiCur[1]);  }
#endif
 return pWInfo->eOnePass; } SQLITE_PRIVATE int sqlite3WhereUsesDeferredSeek(WhereInfo *pWInfo){  return pWInfo->bDeferredSeek; } static void whereOrMove(WhereOrSet *pDest, WhereOrSet *pSrc){  pDest->n = pSrc->n;  memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0])); } static int whereOrInsert(  WhereOrSet *pSet,  Bitmask prereq,  LogEst rRun,  LogEst nOut ){  u16 i;  WhereOrCost *p;  for(i=pSet->n, p=pSet->a; i>0; i--, p++){  if( rRun<=p->rRun && (prereq & p->prereq)==prereq ){  goto whereOrInsert_done;  }  if( p->rRun<=rRun && (p->prereq & prereq)==p->prereq ){  return 0;  }  }  if( pSet->n<N_OR_COST ){  p = &pSet->a[pSet->n++];  p->nOut = nOut;  }else{  p = pSet->a;  for(i=1; i<pSet->n; i++){  if( p->rRun>pSet->a[i].rRun ) p = pSet->a + i;  }  if( p->rRun<=rRun ) return 0;  } whereOrInsert_done:  p->prereq = prereq;  p->rRun = rRun;  if( p->nOut>nOut ) p->nOut = nOut;  return 1; } SQLITE_PRIVATE Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet, int iCursor){  int i;  assert( pMaskSet->n<=(int)sizeof(Bitmask)*8 );  for(i=0; i<pMaskSet->n; i++){  if( pMaskSet->ix[i]==iCursor ){  return MASKBIT(i);  }  }  return 0; } static void createMask(WhereMaskSet *pMaskSet, int iCursor){  assert( pMaskSet->n < ArraySize(pMaskSet->ix) );  pMaskSet->ix[pMaskSet->n++] = iCursor; } static Expr *whereRightSubexprIsColumn(Expr *p){  p = sqlite3ExprSkipCollateAndLikely(p->pRight);  if( ALWAYS(p!=0) && p->op==TK_COLUMN && !ExprHasProperty(p, EP_FixedCol) ){  return p;  }  return 0; } static WhereTerm *whereScanNext(WhereScan *pScan){  int iCur;  i16 iColumn;  Expr *pX;  WhereClause *pWC;  WhereTerm *pTerm;  int k = pScan->k;  assert( pScan->iEquiv<=pScan->nEquiv );  pWC = pScan->pWC;  while(1){  iColumn = pScan->aiColumn[pScan->iEquiv-1];  iCur = pScan->aiCur[pScan->iEquiv-1];  assert( pWC!=0 );  assert( iCur>=0 );  do{  for(pTerm=pWC->a+k; k<pWC->nTerm; k++, pTerm++){  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 || pTerm->leftCursor<0 );  if( pTerm->leftCursor==iCur   && pTerm->u.x.leftColumn==iColumn   && (iColumn!=XN_EXPR   || sqlite3ExprCompareSkip(pTerm->pExpr->pLeft,   pScan->pIdxExpr,iCur)==0)   && (pScan->iEquiv<=1 || !ExprHasProperty(pTerm->pExpr, EP_FromJoin))  ){  if( (pTerm->eOperator & WO_EQUIV)!=0   && pScan->nEquiv<ArraySize(pScan->aiCur)   && (pX = whereRightSubexprIsColumn(pTerm->pExpr))!=0  ){  int j;  for(j=0; j<pScan->nEquiv; j++){  if( pScan->aiCur[j]==pX->iTable   && pScan->aiColumn[j]==pX->iColumn ){  break;  }  }  if( j==pScan->nEquiv ){  pScan->aiCur[j] = pX->iTable;  pScan->aiColumn[j] = pX->iColumn;  pScan->nEquiv++;  }  }  if( (pTerm->eOperator & pScan->opMask)!=0 ){  if( pScan->zCollName && (pTerm->eOperator & WO_ISNULL)==0 ){  CollSeq *pColl;  Parse *pParse = pWC->pWInfo->pParse;  pX = pTerm->pExpr;  if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){  continue;  }  assert(pX->pLeft);  pColl = sqlite3ExprCompareCollSeq(pParse, pX);  if( pColl==0 ) pColl = pParse->db->pDfltColl;  if( sqlite3StrICmp(pColl->zName, pScan->zCollName) ){  continue;  }  }  if( (pTerm->eOperator & (WO_EQ|WO_IS))!=0   && (pX = pTerm->pExpr->pRight, ALWAYS(pX!=0))   && pX->op==TK_COLUMN   && pX->iTable==pScan->aiCur[0]   && pX->iColumn==pScan->aiColumn[0]  ){  testcase( pTerm->eOperator & WO_IS );  continue;  }  pScan->pWC = pWC;  pScan->k = k+1;
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x20000 ){  int ii;  sqlite3DebugPrintf("SCAN-TERM %p: nEquiv=%d",   pTerm, pScan->nEquiv);  for(ii=0; ii<pScan->nEquiv; ii++){  sqlite3DebugPrintf(" {%d:%d}",   pScan->aiCur[ii], pScan->aiColumn[ii]);  }  sqlite3DebugPrintf("\n");  }
#endif
 return pTerm;  }  }  }  pWC = pWC->pOuter;  k = 0;  }while( pWC!=0 );  if( pScan->iEquiv>=pScan->nEquiv ) break;  pWC = pScan->pOrigWC;  k = 0;  pScan->iEquiv++;  }  return 0; } static SQLITE_NOINLINE WhereTerm *whereScanInitIndexExpr(WhereScan *pScan){  pScan->idxaff = sqlite3ExprAffinity(pScan->pIdxExpr);  return whereScanNext(pScan); } static WhereTerm *whereScanInit(  WhereScan *pScan,  WhereClause *pWC,  int iCur,  int iColumn,  u32 opMask,  Index *pIdx ){  pScan->pOrigWC = pWC;  pScan->pWC = pWC;  pScan->pIdxExpr = 0;  pScan->idxaff = 0;  pScan->zCollName = 0;  pScan->opMask = opMask;  pScan->k = 0;  pScan->aiCur[0] = iCur;  pScan->nEquiv = 1;  pScan->iEquiv = 1;  if( pIdx ){  int j = iColumn;  iColumn = pIdx->aiColumn[j];  if( iColumn==XN_EXPR ){  pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;  pScan->zCollName = pIdx->azColl[j];  pScan->aiColumn[0] = XN_EXPR;  return whereScanInitIndexExpr(pScan);  }else if( iColumn==pIdx->pTable->iPKey ){  iColumn = XN_ROWID;  }else if( iColumn>=0 ){  pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity;  pScan->zCollName = pIdx->azColl[j];  }  }else if( iColumn==XN_EXPR ){  return 0;  }  pScan->aiColumn[0] = iColumn;  return whereScanNext(pScan); } SQLITE_PRIVATE WhereTerm *sqlite3WhereFindTerm(  WhereClause *pWC,  int iCur,  int iColumn,  Bitmask notReady,  u32 op,  Index *pIdx ){  WhereTerm *pResult = 0;  WhereTerm *p;  WhereScan scan;  p = whereScanInit(&scan, pWC, iCur, iColumn, op, pIdx);  op &= WO_EQ|WO_IS;  while( p ){  if( (p->prereqRight & notReady)==0 ){  if( p->prereqRight==0 && (p->eOperator&op)!=0 ){  testcase( p->eOperator & WO_IS );  return p;  }  if( pResult==0 ) pResult = p;  }  p = whereScanNext(&scan);  }  return pResult; } static int findIndexCol(  Parse *pParse,  ExprList *pList,  int iBase,  Index *pIdx,  int iCol ){  int i;  const char *zColl = pIdx->azColl[iCol];  for(i=0; i<pList->nExpr; i++){  Expr *p = sqlite3ExprSkipCollateAndLikely(pList->a[i].pExpr);  if( ALWAYS(p!=0)   && (p->op==TK_COLUMN || p->op==TK_AGG_COLUMN)   && p->iColumn==pIdx->aiColumn[iCol]   && p->iTable==iBase  ){  CollSeq *pColl = sqlite3ExprNNCollSeq(pParse, pList->a[i].pExpr);  if( 0==sqlite3StrICmp(pColl->zName, zColl) ){  return i;  }  }  }  return -1; } static int indexColumnNotNull(Index *pIdx, int iCol){  int j;  assert( pIdx!=0 );  assert( iCol>=0 && iCol<pIdx->nColumn );  j = pIdx->aiColumn[iCol];  if( j>=0 ){  return pIdx->pTable->aCol[j].notNull;  }else if( j==(-1) ){  return 1;  }else{  assert( j==(-2) );  return 0;  } } static int isDistinctRedundant(  Parse *pParse,  SrcList *pTabList,  WhereClause *pWC,  ExprList *pDistinct ){  Table *pTab;  Index *pIdx;  int i;  int iBase;  if( pTabList->nSrc!=1 ) return 0;  iBase = pTabList->a[0].iCursor;  pTab = pTabList->a[0].pTab;  for(i=0; i<pDistinct->nExpr; i++){  Expr *p = sqlite3ExprSkipCollateAndLikely(pDistinct->a[i].pExpr);  if( NEVER(p==0) ) continue;  if( p->op!=TK_COLUMN && p->op!=TK_AGG_COLUMN ) continue;  if( p->iTable==iBase && p->iColumn<0 ) return 1;  }  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  if( !IsUniqueIndex(pIdx) ) continue;  if( pIdx->pPartIdxWhere ) continue;  for(i=0; i<pIdx->nKeyCol; i++){  if( 0==sqlite3WhereFindTerm(pWC, iBase, i, ~(Bitmask)0, WO_EQ, pIdx) ){  if( findIndexCol(pParse, pDistinct, iBase, pIdx, i)<0 ) break;  if( indexColumnNotNull(pIdx, i)==0 ) break;  }  }  if( i==pIdx->nKeyCol ){  return 1;  }  }  return 0; } static LogEst estLog(LogEst N){  return N<=10 ? 0 : sqlite3LogEst(N) - 33; } static void translateColumnToCopy(  Parse *pParse,  int iStart,  int iTabCur,  int iRegister,  int iAutoidxCur ){  Vdbe *v = pParse->pVdbe;  VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);  int iEnd = sqlite3VdbeCurrentAddr(v);  if( pParse->db->mallocFailed ) return;  for(; iStart<iEnd; iStart++, pOp++){  if( pOp->p1!=iTabCur ) continue;  if( pOp->opcode==OP_Column ){  pOp->opcode = OP_Copy;  pOp->p1 = pOp->p2 + iRegister;  pOp->p2 = pOp->p3;  pOp->p3 = 0;  }else if( pOp->opcode==OP_Rowid ){  pOp->opcode = OP_Sequence;  pOp->p1 = iAutoidxCur;
#ifdef SQLITE_ALLOW_ROWID_IN_VIEW
 if( iAutoidxCur==0 ){  pOp->opcode = OP_Null;  pOp->p3 = 0;  }
#endif
 }  } }
#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(WHERETRACE_ENABLED)
static void whereTraceIndexInfoInputs(sqlite3_index_info *p){  int i;  if( !sqlite3WhereTrace ) return;  for(i=0; i<p->nConstraint; i++){  sqlite3DebugPrintf(" constraint[%d]: col=%d termid=%d op=%d usabled=%d\n",   i,   p->aConstraint[i].iColumn,   p->aConstraint[i].iTermOffset,   p->aConstraint[i].op,   p->aConstraint[i].usable);  }  for(i=0; i<p->nOrderBy; i++){  sqlite3DebugPrintf(" orderby[%d]: col=%d desc=%d\n",   i,   p->aOrderBy[i].iColumn,   p->aOrderBy[i].desc);  } } static void whereTraceIndexInfoOutputs(sqlite3_index_info *p){  int i;  if( !sqlite3WhereTrace ) return;  for(i=0; i<p->nConstraint; i++){  sqlite3DebugPrintf(" usage[%d]: argvIdx=%d omit=%d\n",   i,   p->aConstraintUsage[i].argvIndex,   p->aConstraintUsage[i].omit);  }  sqlite3DebugPrintf(" idxNum=%d\n", p->idxNum);  sqlite3DebugPrintf(" idxStr=%s\n", p->idxStr);  sqlite3DebugPrintf(" orderByConsumed=%d\n", p->orderByConsumed);  sqlite3DebugPrintf(" estimatedCost=%g\n", p->estimatedCost);  sqlite3DebugPrintf(" estimatedRows=%lld\n", p->estimatedRows); }
#else
#define whereTraceIndexInfoInputs(A)
#define whereTraceIndexInfoOutputs(A)
#endif
#ifndef SQLITE_OMIT_AUTOMATIC_INDEX
static int termCanDriveIndex(  WhereTerm *pTerm,  SrcItem *pSrc,  Bitmask notReady ){  char aff;  if( pTerm->leftCursor!=pSrc->iCursor ) return 0;  if( (pTerm->eOperator & (WO_EQ|WO_IS))==0 ) return 0;  if( (pSrc->fg.jointype & JT_LEFT)   && !ExprHasProperty(pTerm->pExpr, EP_FromJoin)   && (pTerm->eOperator & WO_IS)  ){  return 0;  }  if( (pTerm->prereqRight & notReady)!=0 ) return 0;  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  if( pTerm->u.x.leftColumn<0 ) return 0;  aff = pSrc->pTab->aCol[pTerm->u.x.leftColumn].affinity;  if( !sqlite3IndexAffinityOk(pTerm->pExpr, aff) ) return 0;  testcase( pTerm->pExpr->op==TK_IS );  return 1; }
#endif
#ifndef SQLITE_OMIT_AUTOMATIC_INDEX
static void constructAutomaticIndex(  Parse *pParse,  WhereClause *pWC,  SrcItem *pSrc,  Bitmask notReady,  WhereLevel *pLevel ){  int nKeyCol;  WhereTerm *pTerm;  WhereTerm *pWCEnd;  Index *pIdx;  Vdbe *v;  int addrInit;  Table *pTable;  int addrTop;  int regRecord;  int n;  int i;  int mxBitCol;  CollSeq *pColl;  WhereLoop *pLoop;  char *zNotUsed;  Bitmask idxCols;  Bitmask extraCols;  u8 sentWarning = 0;  Expr *pPartial = 0;  int iContinue = 0;  SrcItem *pTabItem;  int addrCounter = 0;  int regBase;  v = pParse->pVdbe;  assert( v!=0 );  addrInit = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);  nKeyCol = 0;  pTable = pSrc->pTab;  pWCEnd = &pWC->a[pWC->nTerm];  pLoop = pLevel->pWLoop;  idxCols = 0;  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){  Expr *pExpr = pTerm->pExpr;  assert( !ExprHasProperty(pExpr, EP_FromJoin)   || pExpr->iRightJoinTable!=pSrc->iCursor   || pLoop->prereq!=0 );  if( pLoop->prereq==0   && (pTerm->wtFlags & TERM_VIRTUAL)==0   && !ExprHasProperty(pExpr, EP_FromJoin)   && sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor) ){  pPartial = sqlite3ExprAnd(pParse, pPartial,  sqlite3ExprDup(pParse->db, pExpr, 0));  }  if( termCanDriveIndex(pTerm, pSrc, notReady) ){  int iCol;  Bitmask cMask;  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  iCol = pTerm->u.x.leftColumn;  cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);  testcase( iCol==BMS );  testcase( iCol==BMS-1 );  if( !sentWarning ){  sqlite3_log(SQLITE_WARNING_AUTOINDEX,  "automatic index on %s(%s)", pTable->zName,  pTable->aCol[iCol].zCnName);  sentWarning = 1;  }  if( (idxCols & cMask)==0 ){  if( whereLoopResize(pParse->db, pLoop, nKeyCol+1) ){  goto end_auto_index_create;  }  pLoop->aLTerm[nKeyCol++] = pTerm;  idxCols |= cMask;  }  }  }  assert( nKeyCol>0 || pParse->db->mallocFailed );  pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;  pLoop->wsFlags = WHERE_COLUMN_EQ | WHERE_IDX_ONLY | WHERE_INDEXED   | WHERE_AUTO_INDEX;  extraCols = pSrc->colUsed & (~idxCols | MASKBIT(BMS-1));  mxBitCol = MIN(BMS-1,pTable->nCol);  testcase( pTable->nCol==BMS-1 );  testcase( pTable->nCol==BMS-2 );  for(i=0; i<mxBitCol; i++){  if( extraCols & MASKBIT(i) ) nKeyCol++;  }  if( pSrc->colUsed & MASKBIT(BMS-1) ){  nKeyCol += pTable->nCol - BMS + 1;  }  pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol+1, 0, &zNotUsed);  if( pIdx==0 ) goto end_auto_index_create;  pLoop->u.btree.pIndex = pIdx;  pIdx->zName = "auto-index";  pIdx->pTable = pTable;  n = 0;  idxCols = 0;  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){  if( termCanDriveIndex(pTerm, pSrc, notReady) ){  int iCol;  Bitmask cMask;  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  iCol = pTerm->u.x.leftColumn;  cMask = iCol>=BMS ? MASKBIT(BMS-1) : MASKBIT(iCol);  testcase( iCol==BMS-1 );  testcase( iCol==BMS );  if( (idxCols & cMask)==0 ){  Expr *pX = pTerm->pExpr;  idxCols |= cMask;  pIdx->aiColumn[n] = pTerm->u.x.leftColumn;  pColl = sqlite3ExprCompareCollSeq(pParse, pX);  assert( pColl!=0 || pParse->nErr>0 );  pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;  n++;  }  }  }  assert( (u32)n==pLoop->u.btree.nEq );  for(i=0; i<mxBitCol; i++){  if( extraCols & MASKBIT(i) ){  pIdx->aiColumn[n] = i;  pIdx->azColl[n] = sqlite3StrBINARY;  n++;  }  }  if( pSrc->colUsed & MASKBIT(BMS-1) ){  for(i=BMS-1; i<pTable->nCol; i++){  pIdx->aiColumn[n] = i;  pIdx->azColl[n] = sqlite3StrBINARY;  n++;  }  }  assert( n==nKeyCol );  pIdx->aiColumn[n] = XN_ROWID;  pIdx->azColl[n] = sqlite3StrBINARY;  assert( pLevel->iIdxCur>=0 );  pLevel->iIdxCur = pParse->nTab++;  sqlite3VdbeAddOp2(v, OP_OpenAutoindex, pLevel->iIdxCur, nKeyCol+1);  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);  VdbeComment((v, "for %s", pTable->zName));  pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];  if( pTabItem->fg.viaCoroutine ){  int regYield = pTabItem->regReturn;  addrCounter = sqlite3VdbeAddOp2(v, OP_Integer, 0, 0);  sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);  addrTop = sqlite3VdbeAddOp1(v, OP_Yield, regYield);  VdbeCoverage(v);  VdbeComment((v, "next row of %s", pTabItem->pTab->zName));  }else{  addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, pLevel->iTabCur); VdbeCoverage(v);  }  if( pPartial ){  iContinue = sqlite3VdbeMakeLabel(pParse);  sqlite3ExprIfFalse(pParse, pPartial, iContinue, SQLITE_JUMPIFNULL);  pLoop->wsFlags |= WHERE_PARTIALIDX;  }  regRecord = sqlite3GetTempReg(pParse);  regBase = sqlite3GenerateIndexKey(  pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0  );  sqlite3VdbeAddOp2(v, OP_IdxInsert, pLevel->iIdxCur, regRecord);  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);  if( pPartial ) sqlite3VdbeResolveLabel(v, iContinue);  if( pTabItem->fg.viaCoroutine ){  sqlite3VdbeChangeP2(v, addrCounter, regBase+n);  testcase( pParse->db->mallocFailed );  assert( pLevel->iIdxCur>0 );  translateColumnToCopy(pParse, addrTop, pLevel->iTabCur,  pTabItem->regResult, pLevel->iIdxCur);  sqlite3VdbeGoto(v, addrTop);  pTabItem->fg.viaCoroutine = 0;  }else{  sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop+1); VdbeCoverage(v);  sqlite3VdbeChangeP5(v, SQLITE_STMTSTATUS_AUTOINDEX);  }  sqlite3VdbeJumpHere(v, addrTop);  sqlite3ReleaseTempReg(pParse, regRecord);  sqlite3VdbeJumpHere(v, addrInit); end_auto_index_create:  sqlite3ExprDelete(pParse->db, pPartial); }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
static sqlite3_index_info *allocateIndexInfo(  Parse *pParse,  WhereClause *pWC,  Bitmask mUnusable,  SrcItem *pSrc,  ExprList *pOrderBy,  u16 *pmNoOmit ){  int i, j;  int nTerm;  struct sqlite3_index_constraint *pIdxCons;  struct sqlite3_index_orderby *pIdxOrderBy;  struct sqlite3_index_constraint_usage *pUsage;  struct HiddenIndexInfo *pHidden;  WhereTerm *pTerm;  int nOrderBy;  sqlite3_index_info *pIdxInfo;  u16 mNoOmit = 0;  for(i=nTerm=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){  if( pTerm->leftCursor != pSrc->iCursor ) continue;  if( pTerm->prereqRight & mUnusable ) continue;  assert( IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV) );  testcase( pTerm->eOperator & WO_IN );  testcase( pTerm->eOperator & WO_ISNULL );  testcase( pTerm->eOperator & WO_IS );  testcase( pTerm->eOperator & WO_ALL );  if( (pTerm->eOperator & ~(WO_EQUIV))==0 ) continue;  if( pTerm->wtFlags & TERM_VNULL ) continue;  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  assert( pTerm->u.x.leftColumn>=(-1) );  nTerm++;  }  nOrderBy = 0;  if( pOrderBy ){  int n = pOrderBy->nExpr;  for(i=0; i<n; i++){  Expr *pExpr = pOrderBy->a[i].pExpr;  if( pExpr->op!=TK_COLUMN || pExpr->iTable!=pSrc->iCursor ) break;  if( pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL ) break;  }  if( i==n){  nOrderBy = n;  }  }  pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)   + (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm   + sizeof(*pIdxOrderBy)*nOrderBy + sizeof(*pHidden) );  if( pIdxInfo==0 ){  sqlite3ErrorMsg(pParse, "out of memory");  return 0;  }  pHidden = (struct HiddenIndexInfo*)&pIdxInfo[1];  pIdxCons = (struct sqlite3_index_constraint*)&pHidden[1];  pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];  pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];  pIdxInfo->nOrderBy = nOrderBy;  pIdxInfo->aConstraint = pIdxCons;  pIdxInfo->aOrderBy = pIdxOrderBy;  pIdxInfo->aConstraintUsage = pUsage;  pHidden->pWC = pWC;  pHidden->pParse = pParse;  for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){  u16 op;  if( pTerm->leftCursor != pSrc->iCursor ) continue;  if( pTerm->prereqRight & mUnusable ) continue;  assert( IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV) );  testcase( pTerm->eOperator & WO_IN );  testcase( pTerm->eOperator & WO_IS );  testcase( pTerm->eOperator & WO_ISNULL );  testcase( pTerm->eOperator & WO_ALL );  if( (pTerm->eOperator & ~(WO_EQUIV))==0 ) continue;  if( pTerm->wtFlags & TERM_VNULL ) continue;  if( (pSrc->fg.jointype & JT_LEFT)!=0   && !ExprHasProperty(pTerm->pExpr, EP_FromJoin)  ){  continue;  }  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  assert( pTerm->u.x.leftColumn>=(-1) );  pIdxCons[j].iColumn = pTerm->u.x.leftColumn;  pIdxCons[j].iTermOffset = i;  op = pTerm->eOperator & WO_ALL;  if( op==WO_IN ) op = WO_EQ;  if( op==WO_AUX ){  pIdxCons[j].op = pTerm->eMatchOp;  }else if( op & (WO_ISNULL|WO_IS) ){  if( op==WO_ISNULL ){  pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_ISNULL;  }else{  pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_IS;  }  }else{  pIdxCons[j].op = (u8)op;  assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );  assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );  assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );  assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );  assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );  assert( pTerm->eOperator&(WO_IN|WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_AUX) );  if( op & (WO_LT|WO_LE|WO_GT|WO_GE)   && sqlite3ExprIsVector(pTerm->pExpr->pRight)  ){  testcase( j!=i );  if( j<16 ) mNoOmit |= (1 << j);  if( op==WO_LT ) pIdxCons[j].op = WO_LE;  if( op==WO_GT ) pIdxCons[j].op = WO_GE;  }  }  j++;  }  pIdxInfo->nConstraint = j;  for(i=0; i<nOrderBy; i++){  Expr *pExpr = pOrderBy->a[i].pExpr;  pIdxOrderBy[i].iColumn = pExpr->iColumn;  pIdxOrderBy[i].desc = pOrderBy->a[i].sortFlags & KEYINFO_ORDER_DESC;  }  *pmNoOmit = mNoOmit;  return pIdxInfo; } static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;  int rc;  whereTraceIndexInfoInputs(p);  rc = pVtab->pModule->xBestIndex(pVtab, p);  whereTraceIndexInfoOutputs(p);  if( rc!=SQLITE_OK && rc!=SQLITE_CONSTRAINT ){  if( rc==SQLITE_NOMEM ){  sqlite3OomFault(pParse->db);  }else if( !pVtab->zErrMsg ){  sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));  }else{  sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);  }  }  sqlite3_free(pVtab->zErrMsg);  pVtab->zErrMsg = 0;  return rc; }
#endif
#ifdef SQLITE_ENABLE_STAT4
static int whereKeyStats(  Parse *pParse,  Index *pIdx,  UnpackedRecord *pRec,  int roundUp,  tRowcnt *aStat ){  IndexSample *aSample = pIdx->aSample;  int iCol;  int i;  int iSample;  int iMin = 0;  int iTest;  int res;  int nField;  tRowcnt iLower = 0;
#ifndef SQLITE_DEBUG
 UNUSED_PARAMETER( pParse );
#endif
 assert( pRec!=0 );  assert( pIdx->nSample>0 );  assert( pRec->nField>0 && pRec->nField<=pIdx->nSampleCol );  nField = pRec->nField;  iCol = 0;  iSample = pIdx->nSample * nField;  do{  int iSamp;  int n;  iTest = (iMin+iSample)/2;  iSamp = iTest / nField;  if( iSamp>0 ){  for(n=(iTest % nField) + 1; n<nField; n++){  if( aSample[iSamp-1].anLt[n-1]!=aSample[iSamp].anLt[n-1] ) break;  }  }else{  n = iTest + 1;  }  pRec->nField = n;  res = sqlite3VdbeRecordCompare(aSample[iSamp].n, aSample[iSamp].p, pRec);  if( res<0 ){  iLower = aSample[iSamp].anLt[n-1] + aSample[iSamp].anEq[n-1];  iMin = iTest+1;  }else if( res==0 && n<nField ){  iLower = aSample[iSamp].anLt[n-1];  iMin = iTest+1;  res = -1;  }else{  iSample = iTest;  iCol = n-1;  }  }while( res && iMin<iSample );  i = iSample / nField;
#ifdef SQLITE_DEBUG
 if( pParse->db->mallocFailed==0 ){  if( res==0 ){  assert( i<pIdx->nSample );  assert( iCol==nField-1 );  pRec->nField = nField;  assert( 0==sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)   || pParse->db->mallocFailed  );  }else{  assert( i<=pIdx->nSample && i>=0 );  pRec->nField = iCol+1;  assert( i==pIdx->nSample   || sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)>0   || pParse->db->mallocFailed );  if( iCol>0 ){  pRec->nField = iCol;  assert( sqlite3VdbeRecordCompare(aSample[i].n, aSample[i].p, pRec)<=0   || pParse->db->mallocFailed );  }  if( i>0 ){  pRec->nField = nField;  assert( sqlite3VdbeRecordCompare(aSample[i-1].n, aSample[i-1].p, pRec)<0   || pParse->db->mallocFailed );  }  }  }
#endif
 if( res==0 ){  assert( iCol==nField-1 );  aStat[0] = aSample[i].anLt[iCol];  aStat[1] = aSample[i].anEq[iCol];  }else{  tRowcnt iUpper, iGap;  if( i>=pIdx->nSample ){  iUpper = sqlite3LogEstToInt(pIdx->aiRowLogEst[0]);  }else{  iUpper = aSample[i].anLt[iCol];  }  if( iLower>=iUpper ){  iGap = 0;  }else{  iGap = iUpper - iLower;  }  if( roundUp ){  iGap = (iGap*2)/3;  }else{  iGap = iGap/3;  }  aStat[0] = iLower + iGap;  aStat[1] = pIdx->aAvgEq[nField-1];  }  pRec->nField = nField;  return i; }
#endif
static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew){  LogEst nRet = nNew;  if( pTerm ){  if( pTerm->truthProb<=0 ){  nRet += pTerm->truthProb;  }else if( (pTerm->wtFlags & TERM_VNULL)==0 ){  nRet -= 20; assert( 20==sqlite3LogEst(4) );  }  }  return nRet; }
#ifdef SQLITE_ENABLE_STAT4
SQLITE_PRIVATE char sqlite3IndexColumnAffinity(sqlite3 *db, Index *pIdx, int iCol){  assert( iCol>=0 && iCol<pIdx->nColumn );  if( !pIdx->zColAff ){  if( sqlite3IndexAffinityStr(db, pIdx)==0 ) return SQLITE_AFF_BLOB;  }  assert( pIdx->zColAff[iCol]!=0 );  return pIdx->zColAff[iCol]; }
#endif
#ifdef SQLITE_ENABLE_STAT4
static int whereRangeSkipScanEst(  Parse *pParse,  WhereTerm *pLower,  WhereTerm *pUpper,  WhereLoop *pLoop,  int *pbDone ){  Index *p = pLoop->u.btree.pIndex;  int nEq = pLoop->u.btree.nEq;  sqlite3 *db = pParse->db;  int nLower = -1;  int nUpper = p->nSample+1;  int rc = SQLITE_OK;  u8 aff = sqlite3IndexColumnAffinity(db, p, nEq);  CollSeq *pColl;  sqlite3_value *p1 = 0;  sqlite3_value *p2 = 0;  sqlite3_value *pVal = 0;  pColl = sqlite3LocateCollSeq(pParse, p->azColl[nEq]);  if( pLower ){  rc = sqlite3Stat4ValueFromExpr(pParse, pLower->pExpr->pRight, aff, &p1);  nLower = 0;  }  if( pUpper && rc==SQLITE_OK ){  rc = sqlite3Stat4ValueFromExpr(pParse, pUpper->pExpr->pRight, aff, &p2);  nUpper = p2 ? 0 : p->nSample;  }  if( p1 || p2 ){  int i;  int nDiff;  for(i=0; rc==SQLITE_OK && i<p->nSample; i++){  rc = sqlite3Stat4Column(db, p->aSample[i].p, p->aSample[i].n, nEq, &pVal);  if( rc==SQLITE_OK && p1 ){  int res = sqlite3MemCompare(p1, pVal, pColl);  if( res>=0 ) nLower++;  }  if( rc==SQLITE_OK && p2 ){  int res = sqlite3MemCompare(p2, pVal, pColl);  if( res>=0 ) nUpper++;  }  }  nDiff = (nUpper - nLower);  if( nDiff<=0 ) nDiff = 1;  if( nDiff!=1 || pUpper==0 || pLower==0 ){  int nAdjust = (sqlite3LogEst(p->nSample) - sqlite3LogEst(nDiff));  pLoop->nOut -= nAdjust;  *pbDone = 1;  WHERETRACE(0x10, ("range skip-scan regions: %u..%u adjust=%d est=%d\n",   nLower, nUpper, nAdjust*-1, pLoop->nOut));  }  }else{  assert( *pbDone==0 );  }  sqlite3ValueFree(p1);  sqlite3ValueFree(p2);  sqlite3ValueFree(pVal);  return rc; }
#endif
static int whereRangeScanEst(  Parse *pParse,  WhereLoopBuilder *pBuilder,  WhereTerm *pLower,  WhereTerm *pUpper,  WhereLoop *pLoop ){  int rc = SQLITE_OK;  int nOut = pLoop->nOut;  LogEst nNew;
#ifdef SQLITE_ENABLE_STAT4
 Index *p = pLoop->u.btree.pIndex;  int nEq = pLoop->u.btree.nEq;  if( p->nSample>0 && ALWAYS(nEq<p->nSampleCol)   && OptimizationEnabled(pParse->db, SQLITE_Stat4)  ){  if( nEq==pBuilder->nRecValid ){  UnpackedRecord *pRec = pBuilder->pRec;  tRowcnt a[2];  int nBtm = pLoop->u.btree.nBtm;  int nTop = pLoop->u.btree.nTop;  tRowcnt iLower;  tRowcnt iUpper;  int iLwrIdx = -2;  int iUprIdx = -1;  if( pRec ){  testcase( pRec->nField!=pBuilder->nRecValid );  pRec->nField = pBuilder->nRecValid;  }  if( nEq==0 ){  iLower = 0;  iUpper = p->nRowEst0;  }else{  whereKeyStats(pParse, p, pRec, 0, a);  iLower = a[0];  iUpper = a[0] + a[1];  }  assert( pLower==0 || (pLower->eOperator & (WO_GT|WO_GE))!=0 );  assert( pUpper==0 || (pUpper->eOperator & (WO_LT|WO_LE))!=0 );  assert( p->aSortOrder!=0 );  if( p->aSortOrder[nEq] ){  SWAP(WhereTerm*, pLower, pUpper);  SWAP(int, nBtm, nTop);  }  if( pLower ){  int n;  Expr *pExpr = pLower->pExpr->pRight;  rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, nBtm, nEq, &n);  if( rc==SQLITE_OK && n ){  tRowcnt iNew;  u16 mask = WO_GT|WO_LE;  if( sqlite3ExprVectorSize(pExpr)>n ) mask = (WO_LE|WO_LT);  iLwrIdx = whereKeyStats(pParse, p, pRec, 0, a);  iNew = a[0] + ((pLower->eOperator & mask) ? a[1] : 0);  if( iNew>iLower ) iLower = iNew;  nOut--;  pLower = 0;  }  }  if( pUpper ){  int n;  Expr *pExpr = pUpper->pExpr->pRight;  rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, nTop, nEq, &n);  if( rc==SQLITE_OK && n ){  tRowcnt iNew;  u16 mask = WO_GT|WO_LE;  if( sqlite3ExprVectorSize(pExpr)>n ) mask = (WO_LE|WO_LT);  iUprIdx = whereKeyStats(pParse, p, pRec, 1, a);  iNew = a[0] + ((pUpper->eOperator & mask) ? a[1] : 0);  if( iNew<iUpper ) iUpper = iNew;  nOut--;  pUpper = 0;  }  }  pBuilder->pRec = pRec;  if( rc==SQLITE_OK ){  if( iUpper>iLower ){  nNew = sqlite3LogEst(iUpper - iLower);  if( iLwrIdx==iUprIdx ) nNew -= 20; assert( 20==sqlite3LogEst(4) );  }else{  nNew = 10; assert( 10==sqlite3LogEst(2) );  }  if( nNew<nOut ){  nOut = nNew;  }  WHERETRACE(0x10, ("STAT4 range scan: %u..%u est=%d\n",   (u32)iLower, (u32)iUpper, nOut));  }  }else{  int bDone = 0;  rc = whereRangeSkipScanEst(pParse, pLower, pUpper, pLoop, &bDone);  if( bDone ) return rc;  }  }
#else
 UNUSED_PARAMETER(pParse);  UNUSED_PARAMETER(pBuilder);  assert( pLower || pUpper );
#endif
 assert( pUpper==0 || (pUpper->wtFlags & TERM_VNULL)==0 );  nNew = whereRangeAdjust(pLower, nOut);  nNew = whereRangeAdjust(pUpper, nNew);  if( pLower && pLower->truthProb>0 && pUpper && pUpper->truthProb>0 ){  nNew -= 20;  }  nOut -= (pLower!=0) + (pUpper!=0);  if( nNew<10 ) nNew = 10;  if( nNew<nOut ) nOut = nNew;
#if defined(WHERETRACE_ENABLED)
 if( pLoop->nOut>nOut ){  WHERETRACE(0x10,("Range scan lowers nOut from %d to %d\n",  pLoop->nOut, nOut));  }
#endif
 pLoop->nOut = (LogEst)nOut;  return rc; }
#ifdef SQLITE_ENABLE_STAT4
static int whereEqualScanEst(  Parse *pParse,  WhereLoopBuilder *pBuilder,  Expr *pExpr,  tRowcnt *pnRow ){  Index *p = pBuilder->pNew->u.btree.pIndex;  int nEq = pBuilder->pNew->u.btree.nEq;  UnpackedRecord *pRec = pBuilder->pRec;  int rc;  tRowcnt a[2];  int bOk;  assert( nEq>=1 );  assert( nEq<=p->nColumn );  assert( p->aSample!=0 );  assert( p->nSample>0 );  assert( pBuilder->nRecValid<nEq );  if( pBuilder->nRecValid<(nEq-1) ){  return SQLITE_NOTFOUND;  }  if( nEq>=p->nColumn ){  *pnRow = 1;  return SQLITE_OK;  }  rc = sqlite3Stat4ProbeSetValue(pParse, p, &pRec, pExpr, 1, nEq-1, &bOk);  pBuilder->pRec = pRec;  if( rc!=SQLITE_OK ) return rc;  if( bOk==0 ) return SQLITE_NOTFOUND;  pBuilder->nRecValid = nEq;  whereKeyStats(pParse, p, pRec, 0, a);  WHERETRACE(0x10,("equality scan regions %s(%d): %d\n",   p->zName, nEq-1, (int)a[1]));  *pnRow = a[1];  return rc; }
#endif
#ifdef SQLITE_ENABLE_STAT4
static int whereInScanEst(  Parse *pParse,  WhereLoopBuilder *pBuilder,  ExprList *pList,  tRowcnt *pnRow ){  Index *p = pBuilder->pNew->u.btree.pIndex;  i64 nRow0 = sqlite3LogEstToInt(p->aiRowLogEst[0]);  int nRecValid = pBuilder->nRecValid;  int rc = SQLITE_OK;  tRowcnt nEst;  tRowcnt nRowEst = 0;  int i;  assert( p->aSample!=0 );  for(i=0; rc==SQLITE_OK && i<pList->nExpr; i++){  nEst = nRow0;  rc = whereEqualScanEst(pParse, pBuilder, pList->a[i].pExpr, &nEst);  nRowEst += nEst;  pBuilder->nRecValid = nRecValid;  }  if( rc==SQLITE_OK ){  if( nRowEst > nRow0 ) nRowEst = nRow0;  *pnRow = nRowEst;  WHERETRACE(0x10,("IN row estimate: est=%d\n", nRowEst));  }  assert( pBuilder->nRecValid==nRecValid );  return rc; }
#endif
#ifdef WHERETRACE_ENABLED
SQLITE_PRIVATE void sqlite3WhereTermPrint(WhereTerm *pTerm, int iTerm){  if( pTerm==0 ){  sqlite3DebugPrintf("TERM-%-3d NULL\n", iTerm);  }else{  char zType[8];  char zLeft[50];  memcpy(zType, "....", 5);  if( pTerm->wtFlags & TERM_VIRTUAL ) zType[0] = 'V';  if( pTerm->eOperator & WO_EQUIV ) zType[1] = 'E';  if( ExprHasProperty(pTerm->pExpr, EP_FromJoin) ) zType[2] = 'L';  if( pTerm->wtFlags & TERM_CODED ) zType[3] = 'C';  if( pTerm->eOperator & WO_SINGLE ){  assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );  sqlite3_snprintf(sizeof(zLeft),zLeft,"left={%d:%d}",   pTerm->leftCursor, pTerm->u.x.leftColumn);  }else if( (pTerm->eOperator & WO_OR)!=0 && pTerm->u.pOrInfo!=0 ){  sqlite3_snprintf(sizeof(zLeft),zLeft,"indexable=0x%llx",   pTerm->u.pOrInfo->indexable);  }else{  sqlite3_snprintf(sizeof(zLeft),zLeft,"left=%d", pTerm->leftCursor);  }  sqlite3DebugPrintf(   "TERM-%-3d %p %s %-12s op=%03x wtFlags=%04x",   iTerm, pTerm, zType, zLeft, pTerm->eOperator, pTerm->wtFlags);  if( sqlite3WhereTrace & 0x10000 ){  sqlite3DebugPrintf(" prob=%-3d prereq=%llx,%llx",  pTerm->truthProb, (u64)pTerm->prereqAll, (u64)pTerm->prereqRight);  }  if( (pTerm->eOperator & (WO_OR|WO_AND))==0 && pTerm->u.x.iField ){  sqlite3DebugPrintf(" iField=%d", pTerm->u.x.iField);  }  if( pTerm->iParent>=0 ){  sqlite3DebugPrintf(" iParent=%d", pTerm->iParent);  }  sqlite3DebugPrintf("\n");  sqlite3TreeViewExpr(0, pTerm->pExpr, 0);  } }
#endif
#ifdef WHERETRACE_ENABLED
SQLITE_PRIVATE void sqlite3WhereClausePrint(WhereClause *pWC){  int i;  for(i=0; i<pWC->nTerm; i++){  sqlite3WhereTermPrint(&pWC->a[i], i);  } }
#endif
#ifdef WHERETRACE_ENABLED
SQLITE_PRIVATE void sqlite3WhereLoopPrint(WhereLoop *p, WhereClause *pWC){  WhereInfo *pWInfo = pWC->pWInfo;  int nb = 1+(pWInfo->pTabList->nSrc+3)/4;  SrcItem *pItem = pWInfo->pTabList->a + p->iTab;  Table *pTab = pItem->pTab;  Bitmask mAll = (((Bitmask)1)<<(nb*4)) - 1;  sqlite3DebugPrintf("%c%2d.%0*llx.%0*llx", p->cId,   p->iTab, nb, p->maskSelf, nb, p->prereq & mAll);  sqlite3DebugPrintf(" %12s",   pItem->zAlias ? pItem->zAlias : pTab->zName);  if( (p->wsFlags & WHERE_VIRTUALTABLE)==0 ){  const char *zName;  if( p->u.btree.pIndex && (zName = p->u.btree.pIndex->zName)!=0 ){  if( strncmp(zName, "sqlite_autoindex_", 17)==0 ){  int i = sqlite3Strlen30(zName) - 1;  while( zName[i]!='_' ) i--;  zName += i;  }  sqlite3DebugPrintf(".%-16s %2d", zName, p->u.btree.nEq);  }else{  sqlite3DebugPrintf("%20s","");  }  }else{  char *z;  if( p->u.vtab.idxStr ){  z = sqlite3_mprintf("(%d,\"%s\",%#x)",  p->u.vtab.idxNum, p->u.vtab.idxStr, p->u.vtab.omitMask);  }else{  z = sqlite3_mprintf("(%d,%x)", p->u.vtab.idxNum, p->u.vtab.omitMask);  }  sqlite3DebugPrintf(" %-19s", z);  sqlite3_free(z);  }  if( p->wsFlags & WHERE_SKIPSCAN ){  sqlite3DebugPrintf(" f %05x %d-%d", p->wsFlags, p->nLTerm,p->nSkip);  }else{  sqlite3DebugPrintf(" f %05x N %d", p->wsFlags, p->nLTerm);  }  sqlite3DebugPrintf(" cost %d,%d,%d\n", p->rSetup, p->rRun, p->nOut);  if( p->nLTerm && (sqlite3WhereTrace & 0x100)!=0 ){  int i;  for(i=0; i<p->nLTerm; i++){  sqlite3WhereTermPrint(p->aLTerm[i], i);  }  } }
#endif
static void whereLoopInit(WhereLoop *p){  p->aLTerm = p->aLTermSpace;  p->nLTerm = 0;  p->nLSlot = ArraySize(p->aLTermSpace);  p->wsFlags = 0; } static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){  if( p->wsFlags & (WHERE_VIRTUALTABLE|WHERE_AUTO_INDEX) ){  if( (p->wsFlags & WHERE_VIRTUALTABLE)!=0 && p->u.vtab.needFree ){  sqlite3_free(p->u.vtab.idxStr);  p->u.vtab.needFree = 0;  p->u.vtab.idxStr = 0;  }else if( (p->wsFlags & WHERE_AUTO_INDEX)!=0 && p->u.btree.pIndex!=0 ){  sqlite3DbFree(db, p->u.btree.pIndex->zColAff);  sqlite3DbFreeNN(db, p->u.btree.pIndex);  p->u.btree.pIndex = 0;  }  } } static void whereLoopClear(sqlite3 *db, WhereLoop *p){  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);  whereLoopClearUnion(db, p);  whereLoopInit(p); } static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){  WhereTerm **paNew;  if( p->nLSlot>=n ) return SQLITE_OK;  n = (n+7)&~7;  paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);  if( paNew==0 ) return SQLITE_NOMEM_BKPT;  memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);  p->aLTerm = paNew;  p->nLSlot = n;  return SQLITE_OK; } static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom){  whereLoopClearUnion(db, pTo);  if( whereLoopResize(db, pTo, pFrom->nLTerm) ){  memset(pTo, 0, WHERE_LOOP_XFER_SZ);  return SQLITE_NOMEM_BKPT;  }  memcpy(pTo, pFrom, WHERE_LOOP_XFER_SZ);  memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));  if( pFrom->wsFlags & WHERE_VIRTUALTABLE ){  pFrom->u.vtab.needFree = 0;  }else if( (pFrom->wsFlags & WHERE_AUTO_INDEX)!=0 ){  pFrom->u.btree.pIndex = 0;  }  return SQLITE_OK; } static void whereLoopDelete(sqlite3 *db, WhereLoop *p){  whereLoopClear(db, p);  sqlite3DbFreeNN(db, p); } static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){  int i;  assert( pWInfo!=0 );  for(i=0; i<pWInfo->nLevel; i++){  WhereLevel *pLevel = &pWInfo->a[i];  if( pLevel->pWLoop && (pLevel->pWLoop->wsFlags & WHERE_IN_ABLE)!=0 ){  assert( (pLevel->pWLoop->wsFlags & WHERE_MULTI_OR)==0 );  sqlite3DbFree(db, pLevel->u.in.aInLoop);  }  }  sqlite3WhereClauseClear(&pWInfo->sWC);  while( pWInfo->pLoops ){  WhereLoop *p = pWInfo->pLoops;  pWInfo->pLoops = p->pNextLoop;  whereLoopDelete(db, p);  }  assert( pWInfo->pExprMods==0 );  sqlite3DbFreeNN(db, pWInfo); } static void whereUndoExprMods(WhereInfo *pWInfo){  while( pWInfo->pExprMods ){  WhereExprMod *p = pWInfo->pExprMods;  pWInfo->pExprMods = p->pNext;  memcpy(p->pExpr, &p->orig, sizeof(p->orig));  sqlite3DbFree(pWInfo->pParse->db, p);  } } static int whereLoopCheaperProperSubset(  const WhereLoop *pX,  const WhereLoop *pY ){  int i, j;  if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){  return 0;  }  if( pX->rRun>pY->rRun && pX->nOut>pY->nOut ) return 0;  if( pY->nSkip > pX->nSkip ) return 0;  for(i=pX->nLTerm-1; i>=0; i--){  if( pX->aLTerm[i]==0 ) continue;  for(j=pY->nLTerm-1; j>=0; j--){  if( pY->aLTerm[j]==pX->aLTerm[i] ) break;  }  if( j<0 ) return 0;  }  if( (pX->wsFlags&WHERE_IDX_ONLY)!=0   && (pY->wsFlags&WHERE_IDX_ONLY)==0 ){  return 0;  }  return 1; } static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate){  if( (pTemplate->wsFlags & WHERE_INDEXED)==0 ) return;  for(; p; p=p->pNextLoop){  if( p->iTab!=pTemplate->iTab ) continue;  if( (p->wsFlags & WHERE_INDEXED)==0 ) continue;  if( whereLoopCheaperProperSubset(p, pTemplate) ){  WHERETRACE(0x80,("subset cost adjustment %d,%d to %d,%d\n",   pTemplate->rRun, pTemplate->nOut,   MIN(p->rRun, pTemplate->rRun),   MIN(p->nOut - 1, pTemplate->nOut)));  pTemplate->rRun = MIN(p->rRun, pTemplate->rRun);  pTemplate->nOut = MIN(p->nOut - 1, pTemplate->nOut);  }else if( whereLoopCheaperProperSubset(pTemplate, p) ){  WHERETRACE(0x80,("subset cost adjustment %d,%d to %d,%d\n",   pTemplate->rRun, pTemplate->nOut,   MAX(p->rRun, pTemplate->rRun),   MAX(p->nOut + 1, pTemplate->nOut)));  pTemplate->rRun = MAX(p->rRun, pTemplate->rRun);  pTemplate->nOut = MAX(p->nOut + 1, pTemplate->nOut);  }  } } static WhereLoop **whereLoopFindLesser(  WhereLoop **ppPrev,  const WhereLoop *pTemplate ){  WhereLoop *p;  for(p=(*ppPrev); p; ppPrev=&p->pNextLoop, p=*ppPrev){  if( p->iTab!=pTemplate->iTab || p->iSortIdx!=pTemplate->iSortIdx ){  continue;  }  assert( p->rSetup==0 || pTemplate->rSetup==0   || p->rSetup==pTemplate->rSetup );  assert( p->rSetup>=pTemplate->rSetup );  if( (p->wsFlags & WHERE_AUTO_INDEX)!=0   && (pTemplate->nSkip)==0   && (pTemplate->wsFlags & WHERE_INDEXED)!=0   && (pTemplate->wsFlags & WHERE_COLUMN_EQ)!=0   && (p->prereq & pTemplate->prereq)==pTemplate->prereq  ){  break;  }  if( (p->prereq & pTemplate->prereq)==p->prereq   && p->rSetup<=pTemplate->rSetup   && p->rRun<=pTemplate->rRun   && p->nOut<=pTemplate->nOut  ){  return 0;  }  if( (p->prereq & pTemplate->prereq)==pTemplate->prereq   && p->rRun>=pTemplate->rRun   && p->nOut>=pTemplate->nOut  ){  assert( p->rSetup>=pTemplate->rSetup );  break;  }  }  return ppPrev; } static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){  WhereLoop **ppPrev, *p;  WhereInfo *pWInfo = pBuilder->pWInfo;  sqlite3 *db = pWInfo->pParse->db;  int rc;  if( pBuilder->iPlanLimit==0 ){  WHERETRACE(0xffffffff,("=== query planner search limit reached ===\n"));  if( pBuilder->pOrSet ) pBuilder->pOrSet->n = 0;  return SQLITE_DONE;  }  pBuilder->iPlanLimit--;  whereLoopAdjustCost(pWInfo->pLoops, pTemplate);  if( pBuilder->pOrSet!=0 ){  if( pTemplate->nLTerm ){
#if WHERETRACE_ENABLED
 u16 n = pBuilder->pOrSet->n;  int x =
#endif
 whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,  pTemplate->nOut);
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x8 ){  sqlite3DebugPrintf(x?"  or-%d: ":"  or-X: ", n);  sqlite3WhereLoopPrint(pTemplate, pBuilder->pWC);  }
#endif
 }  return SQLITE_OK;  }  ppPrev = whereLoopFindLesser(&pWInfo->pLoops, pTemplate);  if( ppPrev==0 ){
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x8 ){  sqlite3DebugPrintf("  skip: ");  sqlite3WhereLoopPrint(pTemplate, pBuilder->pWC);  }
#endif
 return SQLITE_OK;  }else{  p = *ppPrev;  }
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x8 ){  if( p!=0 ){  sqlite3DebugPrintf("replace: ");  sqlite3WhereLoopPrint(p, pBuilder->pWC);  sqlite3DebugPrintf("  with: ");  }else{  sqlite3DebugPrintf(" add: ");  }  sqlite3WhereLoopPrint(pTemplate, pBuilder->pWC);  }
#endif
 if( p==0 ){  *ppPrev = p = sqlite3DbMallocRawNN(db, sizeof(WhereLoop));  if( p==0 ) return SQLITE_NOMEM_BKPT;  whereLoopInit(p);  p->pNextLoop = 0;  }else{  WhereLoop **ppTail = &p->pNextLoop;  WhereLoop *pToDel;  while( *ppTail ){  ppTail = whereLoopFindLesser(ppTail, pTemplate);  if( ppTail==0 ) break;  pToDel = *ppTail;  if( pToDel==0 ) break;  *ppTail = pToDel->pNextLoop;
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x8 ){  sqlite3DebugPrintf(" delete: ");  sqlite3WhereLoopPrint(pToDel, pBuilder->pWC);  }
#endif
 whereLoopDelete(db, pToDel);  }  }  rc = whereLoopXfer(db, p, pTemplate);  if( (p->wsFlags & WHERE_VIRTUALTABLE)==0 ){  Index *pIndex = p->u.btree.pIndex;  if( pIndex && pIndex->idxType==SQLITE_IDXTYPE_IPK ){  p->u.btree.pIndex = 0;  }  }  return rc; } static void whereLoopOutputAdjust(  WhereClause *pWC,  WhereLoop *pLoop,  LogEst nRow ){  WhereTerm *pTerm, *pX;  Bitmask notAllowed = ~(pLoop->prereq|pLoop->maskSelf);  int i, j;  LogEst iReduce = 0;  assert( (pLoop->wsFlags & WHERE_AUTO_INDEX)==0 );  for(i=pWC->nTerm, pTerm=pWC->a; i>0; i--, pTerm++){  assert( pTerm!=0 );  if( (pTerm->wtFlags & TERM_VIRTUAL)!=0 ) break;  if( (pTerm->prereqAll & pLoop->maskSelf)==0 ) continue;  if( (pTerm->prereqAll & notAllowed)!=0 ) continue;  for(j=pLoop->nLTerm-1; j>=0; j--){  pX = pLoop->aLTerm[j];  if( pX==0 ) continue;  if( pX==pTerm ) break;  if( pX->iParent>=0 && (&pWC->a[pX->iParent])==pTerm ) break;  }  if( j<0 ){  if( pTerm->truthProb<=0 ){  pLoop->nOut += pTerm->truthProb;  }else{  pLoop->nOut--;  if( (pTerm->eOperator&(WO_EQ|WO_IS))!=0   && (pTerm->wtFlags & TERM_HIGHTRUTH)==0  ){  Expr *pRight = pTerm->pExpr->pRight;  int k = 0;  testcase( pTerm->pExpr->op==TK_IS );  if( sqlite3ExprIsInteger(pRight, &k) && k>=(-1) && k<=1 ){  k = 10;  }else{  k = 20;  }  if( iReduce<k ){  pTerm->wtFlags |= TERM_HEURTRUTH;  iReduce = k;  }  }  }  }  }  if( pLoop->nOut > nRow-iReduce ) pLoop->nOut = nRow - iReduce; } static int whereRangeVectorLen(  Parse *pParse,  int iCur,  Index *pIdx,  int nEq,  WhereTerm *pTerm ){  int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);  int i;  nCmp = MIN(nCmp, (pIdx->nColumn - nEq));  for(i=1; i<nCmp; i++){  char aff;  char idxaff = 0;  CollSeq *pColl;  Expr *pLhs, *pRhs;  assert( ExprUseXList(pTerm->pExpr->pLeft) );  pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;  pRhs = pTerm->pExpr->pRight;  if( ExprUseXSelect(pRhs) ){  pRhs = pRhs->x.pSelect->pEList->a[i].pExpr;  }else{  pRhs = pRhs->x.pList->a[i].pExpr;  }  if( pLhs->op!=TK_COLUMN   || pLhs->iTable!=iCur   || pLhs->iColumn!=pIdx->aiColumn[i+nEq]   || pIdx->aSortOrder[i+nEq]!=pIdx->aSortOrder[nEq]  ){  break;  }  testcase( pLhs->iColumn==XN_ROWID );  aff = sqlite3CompareAffinity(pRhs, sqlite3ExprAffinity(pLhs));  idxaff = sqlite3TableColumnAffinity(pIdx->pTable, pLhs->iColumn);  if( aff!=idxaff ) break;  pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);  if( pColl==0 ) break;  if( sqlite3StrICmp(pColl->zName, pIdx->azColl[i+nEq]) ) break;  }  return i; }
#ifdef SQLITE_ENABLE_COSTMULT
# define ApplyCostMultiplier(C,T) C += T
#else
# define ApplyCostMultiplier(C,T)
#endif
static int whereLoopAddBtreeIndex(  WhereLoopBuilder *pBuilder,  SrcItem *pSrc,  Index *pProbe,  LogEst nInMul ){  WhereInfo *pWInfo = pBuilder->pWInfo;  Parse *pParse = pWInfo->pParse;  sqlite3 *db = pParse->db;  WhereLoop *pNew;  WhereTerm *pTerm;  int opMask;  WhereScan scan;  Bitmask saved_prereq;  u16 saved_nLTerm;  u16 saved_nEq;  u16 saved_nBtm;  u16 saved_nTop;  u16 saved_nSkip;  u32 saved_wsFlags;  LogEst saved_nOut;  int rc = SQLITE_OK;  LogEst rSize;  LogEst rLogSize;  WhereTerm *pTop = 0, *pBtm = 0;  pNew = pBuilder->pNew;  if( db->mallocFailed ) return SQLITE_NOMEM_BKPT;  WHERETRACE(0x800, ("BEGIN %s.addBtreeIdx(%s), nEq=%d, nSkip=%d, rRun=%d\n",   pProbe->pTable->zName,pProbe->zName,   pNew->u.btree.nEq, pNew->nSkip, pNew->rRun));  assert( (pNew->wsFlags & WHERE_VIRTUALTABLE)==0 );  assert( (pNew->wsFlags & WHERE_TOP_LIMIT)==0 );  if( pNew->wsFlags & WHERE_BTM_LIMIT ){  opMask = WO_LT|WO_LE;  }else{  assert( pNew->u.btree.nBtm==0 );  opMask = WO_EQ|WO_IN|WO_GT|WO_GE|WO_LT|WO_LE|WO_ISNULL|WO_IS;  }  if( pProbe->bUnordered ) opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);  assert( pNew->u.btree.nEq<pProbe->nColumn );  assert( pNew->u.btree.nEq<pProbe->nKeyCol   || pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY );  saved_nEq = pNew->u.btree.nEq;  saved_nBtm = pNew->u.btree.nBtm;  saved_nTop = pNew->u.btree.nTop;  saved_nSkip = pNew->nSkip;  saved_nLTerm = pNew->nLTerm;  saved_wsFlags = pNew->wsFlags;  saved_prereq = pNew->prereq;  saved_nOut = pNew->nOut;  pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,  opMask, pProbe);  pNew->rSetup = 0;  rSize = pProbe->aiRowLogEst[0];  rLogSize = estLog(rSize);  for(; rc==SQLITE_OK && pTerm!=0; pTerm = whereScanNext(&scan)){  u16 eOp = pTerm->eOperator;  LogEst rCostIdx;  LogEst nOutUnadjusted;  int nIn = 0;
#ifdef SQLITE_ENABLE_STAT4
 int nRecValid = pBuilder->nRecValid;
#endif
 if( (eOp==WO_ISNULL || (pTerm->wtFlags&TERM_VNULL)!=0)   && indexColumnNotNull(pProbe, saved_nEq)  ){  continue;  }  if( pTerm->prereqRight & pNew->maskSelf ) continue;  if( pTerm->wtFlags & TERM_LIKEOPT && pTerm->eOperator==WO_LT ) continue;  if( (pSrc->fg.jointype & JT_LEFT)!=0   && !ExprHasProperty(pTerm->pExpr, EP_FromJoin)  ){  continue;  }  if( IsUniqueIndex(pProbe) && saved_nEq==pProbe->nKeyCol-1 ){  pBuilder->bldFlags1 |= SQLITE_BLDF1_UNIQUE;  }else{  pBuilder->bldFlags1 |= SQLITE_BLDF1_INDEXED;  }  pNew->wsFlags = saved_wsFlags;  pNew->u.btree.nEq = saved_nEq;  pNew->u.btree.nBtm = saved_nBtm;  pNew->u.btree.nTop = saved_nTop;  pNew->nLTerm = saved_nLTerm;  if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break;  pNew->aLTerm[pNew->nLTerm++] = pTerm;  pNew->prereq = (saved_prereq | pTerm->prereqRight) & ~pNew->maskSelf;  assert( nInMul==0  || (pNew->wsFlags & WHERE_COLUMN_NULL)!=0  || (pNew->wsFlags & WHERE_COLUMN_IN)!=0  || (pNew->wsFlags & WHERE_SKIPSCAN)!=0  );  if( eOp & WO_IN ){  Expr *pExpr = pTerm->pExpr;  if( ExprUseXSelect(pExpr) ){  int i;  nIn = 46; assert( 46==sqlite3LogEst(25) );  for(i=0; i<pNew->nLTerm-1; i++){  if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ) nIn = 0;  }  }else if( ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr) ){  nIn = sqlite3LogEst(pExpr->x.pList->nExpr);  }  if( pProbe->hasStat1 && rLogSize>=10 ){  LogEst M, logK, x;  M = pProbe->aiRowLogEst[saved_nEq];  logK = estLog(nIn);  x = M + logK + 10 - (nIn + rLogSize);  if( x>=0 ){  WHERETRACE(0x40,  ("IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d) "   "prefers indexed lookup\n",   saved_nEq, M, logK, nIn, rLogSize, x));  }else if( nInMul<2 && OptimizationEnabled(db, SQLITE_SeekScan) ){  WHERETRACE(0x40,  ("IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d"   " nInMul=%d) prefers skip-scan\n",   saved_nEq, M, logK, nIn, rLogSize, x, nInMul));  pNew->wsFlags |= WHERE_IN_SEEKSCAN;  }else{  WHERETRACE(0x40,  ("IN operator (N=%d M=%d logK=%d nIn=%d rLogSize=%d x=%d"   " nInMul=%d) prefers normal scan\n",   saved_nEq, M, logK, nIn, rLogSize, x, nInMul));  continue;  }  }  pNew->wsFlags |= WHERE_COLUMN_IN;  }else if( eOp & (WO_EQ|WO_IS) ){  int iCol = pProbe->aiColumn[saved_nEq];  pNew->wsFlags |= WHERE_COLUMN_EQ;  assert( saved_nEq==pNew->u.btree.nEq );  if( iCol==XN_ROWID   || (iCol>=0 && nInMul==0 && saved_nEq==pProbe->nKeyCol-1)  ){  if( iCol==XN_ROWID || pProbe->uniqNotNull   || (pProbe->nKeyCol==1 && pProbe->onError && eOp==WO_EQ)  ){  pNew->wsFlags |= WHERE_ONEROW;  }else{  pNew->wsFlags |= WHERE_UNQ_WANTED;  }  }  if( scan.iEquiv>1 ) pNew->wsFlags |= WHERE_TRANSCONS;  }else if( eOp & WO_ISNULL ){  pNew->wsFlags |= WHERE_COLUMN_NULL;  }else if( eOp & (WO_GT|WO_GE) ){  testcase( eOp & WO_GT );  testcase( eOp & WO_GE );  pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_BTM_LIMIT;  pNew->u.btree.nBtm = whereRangeVectorLen(  pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm  );  pBtm = pTerm;  pTop = 0;  if( pTerm->wtFlags & TERM_LIKEOPT ){  pTop = &pTerm[1];  assert( (pTop-(pTerm->pWC->a))<pTerm->pWC->nTerm );  assert( pTop->wtFlags & TERM_LIKEOPT );  assert( pTop->eOperator==WO_LT );  if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break;  pNew->aLTerm[pNew->nLTerm++] = pTop;  pNew->wsFlags |= WHERE_TOP_LIMIT;  pNew->u.btree.nTop = 1;  }  }else{  assert( eOp & (WO_LT|WO_LE) );  testcase( eOp & WO_LT );  testcase( eOp & WO_LE );  pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_TOP_LIMIT;  pNew->u.btree.nTop = whereRangeVectorLen(  pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm  );  pTop = pTerm;  pBtm = (pNew->wsFlags & WHERE_BTM_LIMIT)!=0 ?   pNew->aLTerm[pNew->nLTerm-2] : 0;  }  assert( pNew->nOut==saved_nOut );  if( pNew->wsFlags & WHERE_COLUMN_RANGE ){  whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);  }else{  int nEq = ++pNew->u.btree.nEq;  assert( eOp & (WO_ISNULL|WO_EQ|WO_IN|WO_IS) );  assert( pNew->nOut==saved_nOut );  if( pTerm->truthProb<=0 && pProbe->aiColumn[saved_nEq]>=0 ){  assert( (eOp & WO_IN) || nIn==0 );  testcase( eOp & WO_IN );  pNew->nOut += pTerm->truthProb;  pNew->nOut -= nIn;  }else{
#ifdef SQLITE_ENABLE_STAT4
 tRowcnt nOut = 0;  if( nInMul==0   && pProbe->nSample   && ALWAYS(pNew->u.btree.nEq<=pProbe->nSampleCol)   && ((eOp & WO_IN)==0 || ExprUseXList(pTerm->pExpr))   && OptimizationEnabled(db, SQLITE_Stat4)  ){  Expr *pExpr = pTerm->pExpr;  if( (eOp & (WO_EQ|WO_ISNULL|WO_IS))!=0 ){  testcase( eOp & WO_EQ );  testcase( eOp & WO_IS );  testcase( eOp & WO_ISNULL );  rc = whereEqualScanEst(pParse, pBuilder, pExpr->pRight, &nOut);  }else{  rc = whereInScanEst(pParse, pBuilder, pExpr->x.pList, &nOut);  }  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;  if( rc!=SQLITE_OK ) break;  if( nOut ){  pNew->nOut = sqlite3LogEst(nOut);  if( nEq==1   && pNew->nOut+10 > pProbe->aiRowLogEst[0]  ){
#if WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x01 ){  sqlite3DebugPrintf(   "STAT4 determines term has low selectivity:\n");  sqlite3WhereTermPrint(pTerm, 999);  }
#endif
 pTerm->wtFlags |= TERM_HIGHTRUTH;  if( pTerm->wtFlags & TERM_HEURTRUTH ){  pBuilder->bldFlags2 |= SQLITE_BLDF2_2NDPASS;  }  }  if( pNew->nOut>saved_nOut ) pNew->nOut = saved_nOut;  pNew->nOut -= nIn;  }  }  if( nOut==0 )
#endif
 {  pNew->nOut += (pProbe->aiRowLogEst[nEq] - pProbe->aiRowLogEst[nEq-1]);  if( eOp & WO_ISNULL ){  pNew->nOut += 10;  }  }  }  }  assert( pSrc->pTab->szTabRow>0 );  rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pTab->szTabRow;  pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);  if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK))==0 ){  pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut + 16);  }  ApplyCostMultiplier(pNew->rRun, pProbe->pTable->costMult);  nOutUnadjusted = pNew->nOut;  pNew->rRun += nInMul + nIn;  pNew->nOut += nInMul + nIn;  whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);  rc = whereLoopInsert(pBuilder, pNew);  if( pNew->wsFlags & WHERE_COLUMN_RANGE ){  pNew->nOut = saved_nOut;  }else{  pNew->nOut = nOutUnadjusted;  }  if( (pNew->wsFlags & WHERE_TOP_LIMIT)==0   && pNew->u.btree.nEq<pProbe->nColumn   && (pNew->u.btree.nEq<pProbe->nKeyCol ||   pProbe->idxType!=SQLITE_IDXTYPE_PRIMARYKEY)  ){  whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nInMul+nIn);  }  pNew->nOut = saved_nOut;
#ifdef SQLITE_ENABLE_STAT4
 pBuilder->nRecValid = nRecValid;
#endif
 }  pNew->prereq = saved_prereq;  pNew->u.btree.nEq = saved_nEq;  pNew->u.btree.nBtm = saved_nBtm;  pNew->u.btree.nTop = saved_nTop;  pNew->nSkip = saved_nSkip;  pNew->wsFlags = saved_wsFlags;  pNew->nOut = saved_nOut;  pNew->nLTerm = saved_nLTerm;  assert( 42==sqlite3LogEst(18) );  if( saved_nEq==saved_nSkip   && saved_nEq+1<pProbe->nKeyCol   && saved_nEq==pNew->nLTerm   && pProbe->noSkipScan==0   && pProbe->hasStat1!=0   && OptimizationEnabled(db, SQLITE_SkipScan)   && pProbe->aiRowLogEst[saved_nEq+1]>=42   && (rc = whereLoopResize(db, pNew, pNew->nLTerm+1))==SQLITE_OK  ){  LogEst nIter;  pNew->u.btree.nEq++;  pNew->nSkip++;  pNew->aLTerm[pNew->nLTerm++] = 0;  pNew->wsFlags |= WHERE_SKIPSCAN;  nIter = pProbe->aiRowLogEst[saved_nEq] - pProbe->aiRowLogEst[saved_nEq+1];  pNew->nOut -= nIter;  nIter += 5;  whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nIter + nInMul);  pNew->nOut = saved_nOut;  pNew->u.btree.nEq = saved_nEq;  pNew->nSkip = saved_nSkip;  pNew->wsFlags = saved_wsFlags;  }  WHERETRACE(0x800, ("END %s.addBtreeIdx(%s), nEq=%d, rc=%d\n",  pProbe->pTable->zName, pProbe->zName, saved_nEq, rc));  return rc; } static int indexMightHelpWithOrderBy(  WhereLoopBuilder *pBuilder,  Index *pIndex,  int iCursor ){  ExprList *pOB;  ExprList *aColExpr;  int ii, jj;  if( pIndex->bUnordered ) return 0;  if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;  for(ii=0; ii<pOB->nExpr; ii++){  Expr *pExpr = sqlite3ExprSkipCollateAndLikely(pOB->a[ii].pExpr);  if( NEVER(pExpr==0) ) continue;  if( pExpr->op==TK_COLUMN && pExpr->iTable==iCursor ){  if( pExpr->iColumn<0 ) return 1;  for(jj=0; jj<pIndex->nKeyCol; jj++){  if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;  }  }else if( (aColExpr = pIndex->aColExpr)!=0 ){  for(jj=0; jj<pIndex->nKeyCol; jj++){  if( pIndex->aiColumn[jj]!=XN_EXPR ) continue;  if( sqlite3ExprCompareSkip(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){  return 1;  }  }  }  }  return 0; } static int whereUsablePartialIndex(  int iTab,  int isLeft,  WhereClause *pWC,  Expr *pWhere ){  int i;  WhereTerm *pTerm;  Parse *pParse = pWC->pWInfo->pParse;  while( pWhere->op==TK_AND ){  if( !whereUsablePartialIndex(iTab,isLeft,pWC,pWhere->pLeft) ) return 0;  pWhere = pWhere->pRight;  }  if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;  for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){  Expr *pExpr;  pExpr = pTerm->pExpr;  if( (!ExprHasProperty(pExpr, EP_FromJoin) || pExpr->iRightJoinTable==iTab)   && (isLeft==0 || ExprHasProperty(pExpr, EP_FromJoin))   && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)   && (pTerm->wtFlags & TERM_VNULL)==0  ){  return 1;  }  }  return 0; } static int whereLoopAddBtree(  WhereLoopBuilder *pBuilder,  Bitmask mPrereq ){  WhereInfo *pWInfo;  Index *pProbe;  Index sPk;  LogEst aiRowEstPk[2];  i16 aiColumnPk = -1;  SrcList *pTabList;  SrcItem *pSrc;  WhereLoop *pNew;  int rc = SQLITE_OK;  int iSortIdx = 1;  int b;  LogEst rSize;  WhereClause *pWC;  Table *pTab;  pNew = pBuilder->pNew;  pWInfo = pBuilder->pWInfo;  pTabList = pWInfo->pTabList;  pSrc = pTabList->a + pNew->iTab;  pTab = pSrc->pTab;  pWC = pBuilder->pWC;  assert( !IsVirtual(pSrc->pTab) );  if( pSrc->fg.isIndexedBy ){  assert( pSrc->fg.isCte==0 );  pProbe = pSrc->u2.pIBIndex;  }else if( !HasRowid(pTab) ){  pProbe = pTab->pIndex;  }else{  Index *pFirst;  memset(&sPk, 0, sizeof(Index));  sPk.nKeyCol = 1;  sPk.nColumn = 1;  sPk.aiColumn = &aiColumnPk;  sPk.aiRowLogEst = aiRowEstPk;  sPk.onError = OE_Replace;  sPk.pTable = pTab;  sPk.szIdxRow = pTab->szTabRow;  sPk.idxType = SQLITE_IDXTYPE_IPK;  aiRowEstPk[0] = pTab->nRowLogEst;  aiRowEstPk[1] = 0;  pFirst = pSrc->pTab->pIndex;  if( pSrc->fg.notIndexed==0 ){  sPk.pNext = pFirst;  }  pProbe = &sPk;  }  rSize = pTab->nRowLogEst;
#ifndef SQLITE_OMIT_AUTOMATIC_INDEX
 if( !pBuilder->pOrSet   && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0   && (pWInfo->pParse->db->flags & SQLITE_AutoIndex)!=0   && !pSrc->fg.isIndexedBy   && !pSrc->fg.notIndexed   && HasRowid(pTab)   && !pSrc->fg.isCorrelated   && !pSrc->fg.isRecursive  ){  LogEst rLogSize;  WhereTerm *pTerm;  WhereTerm *pWCEnd = pWC->a + pWC->nTerm;  rLogSize = estLog(rSize);  for(pTerm=pWC->a; rc==SQLITE_OK && pTerm<pWCEnd; pTerm++){  if( pTerm->prereqRight & pNew->maskSelf ) continue;  if( termCanDriveIndex(pTerm, pSrc, 0) ){  pNew->u.btree.nEq = 1;  pNew->nSkip = 0;  pNew->u.btree.pIndex = 0;  pNew->nLTerm = 1;  pNew->aLTerm[0] = pTerm;  pNew->rSetup = rLogSize + rSize;  if( !IsView(pTab) && (pTab->tabFlags & TF_Ephemeral)==0 ){  pNew->rSetup += 28;  }else{  pNew->rSetup -= 10;  }  ApplyCostMultiplier(pNew->rSetup, pTab->costMult);  if( pNew->rSetup<0 ) pNew->rSetup = 0;  pNew->nOut = 43; assert( 43==sqlite3LogEst(20) );  pNew->rRun = sqlite3LogEstAdd(rLogSize,pNew->nOut);  pNew->wsFlags = WHERE_AUTO_INDEX;  pNew->prereq = mPrereq | pTerm->prereqRight;  rc = whereLoopInsert(pBuilder, pNew);  }  }  }
#endif
 for(; rc==SQLITE_OK && pProbe;  pProbe=(pSrc->fg.isIndexedBy ? 0 : pProbe->pNext), iSortIdx++  ){  int isLeft = (pSrc->fg.jointype & JT_OUTER)!=0;  if( pProbe->pPartIdxWhere!=0   && !whereUsablePartialIndex(pSrc->iCursor, isLeft, pWC,   pProbe->pPartIdxWhere)  ){  testcase( pNew->iTab!=pSrc->iCursor );  continue;  }  if( pProbe->bNoQuery ) continue;  rSize = pProbe->aiRowLogEst[0];  pNew->u.btree.nEq = 0;  pNew->u.btree.nBtm = 0;  pNew->u.btree.nTop = 0;  pNew->nSkip = 0;  pNew->nLTerm = 0;  pNew->iSortIdx = 0;  pNew->rSetup = 0;  pNew->prereq = mPrereq;  pNew->nOut = rSize;  pNew->u.btree.pIndex = pProbe;  b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);  assert( (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || b==0 );  if( pProbe->idxType==SQLITE_IDXTYPE_IPK ){  pNew->wsFlags = WHERE_IPK;  pNew->iSortIdx = b ? iSortIdx : 0;
#ifdef SQLITE_ENABLE_STAT4
 pNew->rRun = rSize + 16 - 2*((pTab->tabFlags & TF_HasStat4)!=0);
#else
 pNew->rRun = rSize + 16;
#endif
 ApplyCostMultiplier(pNew->rRun, pTab->costMult);  whereLoopOutputAdjust(pWC, pNew, rSize);  rc = whereLoopInsert(pBuilder, pNew);  pNew->nOut = rSize;  if( rc ) break;  }else{  Bitmask m;  if( pProbe->isCovering ){  pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;  m = 0;  }else{  m = pSrc->colUsed & pProbe->colNotIdxed;  pNew->wsFlags = (m==0) ? (WHERE_IDX_ONLY|WHERE_INDEXED) : WHERE_INDEXED;  }  if( b   || !HasRowid(pTab)   || pProbe->pPartIdxWhere!=0   || pSrc->fg.isIndexedBy   || ( m==0   && pProbe->bUnordered==0   && (pProbe->szIdxRow<pTab->szTabRow)   && (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0   && sqlite3GlobalConfig.bUseCis   && OptimizationEnabled(pWInfo->pParse->db, SQLITE_CoverIdxScan)  )  ){  pNew->iSortIdx = b ? iSortIdx : 0;  pNew->rRun = rSize + 1 + (15*pProbe->szIdxRow)/pTab->szTabRow;  if( m!=0 ){  LogEst nLookup = rSize + 16;  int ii;  int iCur = pSrc->iCursor;  WhereClause *pWC2 = &pWInfo->sWC;  for(ii=0; ii<pWC2->nTerm; ii++){  WhereTerm *pTerm = &pWC2->a[ii];  if( !sqlite3ExprCoveredByIndex(pTerm->pExpr, iCur, pProbe) ){  break;  }  if( pTerm->truthProb<=0 ){  nLookup += pTerm->truthProb;  }else{  nLookup--;  if( pTerm->eOperator & (WO_EQ|WO_IS) ) nLookup -= 19;  }  }  pNew->rRun = sqlite3LogEstAdd(pNew->rRun, nLookup);  }  ApplyCostMultiplier(pNew->rRun, pTab->costMult);  whereLoopOutputAdjust(pWC, pNew, rSize);  rc = whereLoopInsert(pBuilder, pNew);  pNew->nOut = rSize;  if( rc ) break;  }  }  pBuilder->bldFlags1 = 0;  rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);  if( pBuilder->bldFlags1==SQLITE_BLDF1_INDEXED ){  pTab->tabFlags |= TF_StatsUsed;  }
#ifdef SQLITE_ENABLE_STAT4
 sqlite3Stat4ProbeFree(pBuilder->pRec);  pBuilder->nRecValid = 0;  pBuilder->pRec = 0;
#endif
 }  return rc; }
#ifndef SQLITE_OMIT_VIRTUALTABLE
static int whereLoopAddVirtualOne(  WhereLoopBuilder *pBuilder,  Bitmask mPrereq,  Bitmask mUsable,  u16 mExclude,  sqlite3_index_info *pIdxInfo,  u16 mNoOmit,  int *pbIn ){  WhereClause *pWC = pBuilder->pWC;  struct sqlite3_index_constraint *pIdxCons;  struct sqlite3_index_constraint_usage *pUsage = pIdxInfo->aConstraintUsage;  int i;  int mxTerm;  int rc = SQLITE_OK;  WhereLoop *pNew = pBuilder->pNew;  Parse *pParse = pBuilder->pWInfo->pParse;  SrcItem *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];  int nConstraint = pIdxInfo->nConstraint;  assert( (mUsable & mPrereq)==mPrereq );  *pbIn = 0;  pNew->prereq = mPrereq;  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;  for(i=0; i<nConstraint; i++, pIdxCons++){  WhereTerm *pTerm = &pWC->a[pIdxCons->iTermOffset];  pIdxCons->usable = 0;  if( (pTerm->prereqRight & mUsable)==pTerm->prereqRight   && (pTerm->eOperator & mExclude)==0  ){  pIdxCons->usable = 1;  }  }  memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);  assert( pIdxInfo->needToFreeIdxStr==0 );  pIdxInfo->idxStr = 0;  pIdxInfo->idxNum = 0;  pIdxInfo->orderByConsumed = 0;  pIdxInfo->estimatedCost = SQLITE_BIG_DBL / (double)2;  pIdxInfo->estimatedRows = 25;  pIdxInfo->idxFlags = 0;  pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;  rc = vtabBestIndex(pParse, pSrc->pTab, pIdxInfo);  if( rc ){  if( rc==SQLITE_CONSTRAINT ){  WHERETRACE(0xffff, (" ^^^^--- non-viable plan rejected!\n"));  return SQLITE_OK;  }  return rc;  }  mxTerm = -1;  assert( pNew->nLSlot>=nConstraint );  for(i=0; i<nConstraint; i++) pNew->aLTerm[i] = 0;  pNew->u.vtab.omitMask = 0;  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;  for(i=0; i<nConstraint; i++, pIdxCons++){  int iTerm;  if( (iTerm = pUsage[i].argvIndex - 1)>=0 ){  WhereTerm *pTerm;  int j = pIdxCons->iTermOffset;  if( iTerm>=nConstraint   || j<0   || j>=pWC->nTerm   || pNew->aLTerm[iTerm]!=0   || pIdxCons->usable==0  ){  sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pTab->zName);  testcase( pIdxInfo->needToFreeIdxStr );  return SQLITE_ERROR;  }  testcase( iTerm==nConstraint-1 );  testcase( j==0 );  testcase( j==pWC->nTerm-1 );  pTerm = &pWC->a[j];  pNew->prereq |= pTerm->prereqRight;  assert( iTerm<pNew->nLSlot );  pNew->aLTerm[iTerm] = pTerm;  if( iTerm>mxTerm ) mxTerm = iTerm;  testcase( iTerm==15 );  testcase( iTerm==16 );  if( pUsage[i].omit ){  if( i<16 && ((1<<i)&mNoOmit)==0 ){  testcase( i!=iTerm );  pNew->u.vtab.omitMask |= 1<<iTerm;  }else{  testcase( i!=iTerm );  }  }  if( (pTerm->eOperator & WO_IN)!=0 ){  pIdxInfo->orderByConsumed = 0;  pIdxInfo->idxFlags &= ~SQLITE_INDEX_SCAN_UNIQUE;  *pbIn = 1; assert( (mExclude & WO_IN)==0 );  }  }  }  pNew->nLTerm = mxTerm+1;  for(i=0; i<=mxTerm; i++){  if( pNew->aLTerm[i]==0 ){  sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pTab->zName);  testcase( pIdxInfo->needToFreeIdxStr );  return SQLITE_ERROR;  }  }  assert( pNew->nLTerm<=pNew->nLSlot );  pNew->u.vtab.idxNum = pIdxInfo->idxNum;  pNew->u.vtab.needFree = pIdxInfo->needToFreeIdxStr;  pIdxInfo->needToFreeIdxStr = 0;  pNew->u.vtab.idxStr = pIdxInfo->idxStr;  pNew->u.vtab.isOrdered = (i8)(pIdxInfo->orderByConsumed ?  pIdxInfo->nOrderBy : 0);  pNew->rSetup = 0;  pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);  pNew->nOut = sqlite3LogEst(pIdxInfo->estimatedRows);  if( pIdxInfo->idxFlags & SQLITE_INDEX_SCAN_UNIQUE ){  pNew->wsFlags |= WHERE_ONEROW;  }else{  pNew->wsFlags &= ~WHERE_ONEROW;  }  rc = whereLoopInsert(pBuilder, pNew);  if( pNew->u.vtab.needFree ){  sqlite3_free(pNew->u.vtab.idxStr);  pNew->u.vtab.needFree = 0;  }  WHERETRACE(0xffff, (" bIn=%d prereqIn=%04llx prereqOut=%04llx\n",  *pbIn, (sqlite3_uint64)mPrereq,  (sqlite3_uint64)(pNew->prereq & ~mPrereq)));  return rc; } SQLITE_API const char *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo, int iCons){  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];  const char *zRet = 0;  if( iCons>=0 && iCons<pIdxInfo->nConstraint ){  CollSeq *pC = 0;  int iTerm = pIdxInfo->aConstraint[iCons].iTermOffset;  Expr *pX = pHidden->pWC->a[iTerm].pExpr;  if( pX->pLeft ){  pC = sqlite3ExprCompareCollSeq(pHidden->pParse, pX);  }  zRet = (pC ? pC->zName : sqlite3StrBINARY);  }  return zRet; } static int whereLoopAddVirtual(  WhereLoopBuilder *pBuilder,  Bitmask mPrereq,  Bitmask mUnusable ){  int rc = SQLITE_OK;  WhereInfo *pWInfo;  Parse *pParse;  WhereClause *pWC;  SrcItem *pSrc;  sqlite3_index_info *p;  int nConstraint;  int bIn;  WhereLoop *pNew;  Bitmask mBest;  u16 mNoOmit;  assert( (mPrereq & mUnusable)==0 );  pWInfo = pBuilder->pWInfo;  pParse = pWInfo->pParse;  pWC = pBuilder->pWC;  pNew = pBuilder->pNew;  pSrc = &pWInfo->pTabList->a[pNew->iTab];  assert( IsVirtual(pSrc->pTab) );  p = allocateIndexInfo(pParse, pWC, mUnusable, pSrc, pBuilder->pOrderBy,  &mNoOmit);  if( p==0 ) return SQLITE_NOMEM_BKPT;  pNew->rSetup = 0;  pNew->wsFlags = WHERE_VIRTUALTABLE;  pNew->nLTerm = 0;  pNew->u.vtab.needFree = 0;  nConstraint = p->nConstraint;  if( whereLoopResize(pParse->db, pNew, nConstraint) ){  sqlite3DbFree(pParse->db, p);  return SQLITE_NOMEM_BKPT;  }  WHERETRACE(0x800, ("BEGIN %s.addVirtual()\n", pSrc->pTab->zName));  WHERETRACE(0x40, (" VirtualOne: all usable\n"));  rc = whereLoopAddVirtualOne(pBuilder, mPrereq, ALLBITS, 0, p, mNoOmit, &bIn);  if( rc==SQLITE_OK && ((mBest = (pNew->prereq & ~mPrereq))!=0 || bIn) ){  int seenZero = 0;  int seenZeroNoIN = 0;  Bitmask mPrev = 0;  Bitmask mBestNoIn = 0;  if( bIn ){  WHERETRACE(0x40, (" VirtualOne: all usable w/o IN\n"));  rc = whereLoopAddVirtualOne(  pBuilder, mPrereq, ALLBITS, WO_IN, p, mNoOmit, &bIn);  assert( bIn==0 );  mBestNoIn = pNew->prereq & ~mPrereq;  if( mBestNoIn==0 ){  seenZero = 1;  seenZeroNoIN = 1;  }  }  while( rc==SQLITE_OK ){  int i;  Bitmask mNext = ALLBITS;  assert( mNext>0 );  for(i=0; i<nConstraint; i++){  Bitmask mThis = (  pWC->a[p->aConstraint[i].iTermOffset].prereqRight & ~mPrereq  );  if( mThis>mPrev && mThis<mNext ) mNext = mThis;  }  mPrev = mNext;  if( mNext==ALLBITS ) break;  if( mNext==mBest || mNext==mBestNoIn ) continue;  WHERETRACE(0x40, (" VirtualOne: mPrev=%04llx mNext=%04llx\n",   (sqlite3_uint64)mPrev, (sqlite3_uint64)mNext));  rc = whereLoopAddVirtualOne(  pBuilder, mPrereq, mNext|mPrereq, 0, p, mNoOmit, &bIn);  if( pNew->prereq==mPrereq ){  seenZero = 1;  if( bIn==0 ) seenZeroNoIN = 1;  }  }  if( rc==SQLITE_OK && seenZero==0 ){  WHERETRACE(0x40, (" VirtualOne: all disabled\n"));  rc = whereLoopAddVirtualOne(  pBuilder, mPrereq, mPrereq, 0, p, mNoOmit, &bIn);  if( bIn==0 ) seenZeroNoIN = 1;  }  if( rc==SQLITE_OK && seenZeroNoIN==0 ){  WHERETRACE(0x40, (" VirtualOne: all disabled and w/o IN\n"));  rc = whereLoopAddVirtualOne(  pBuilder, mPrereq, mPrereq, WO_IN, p, mNoOmit, &bIn);  }  }  if( p->needToFreeIdxStr ) sqlite3_free(p->idxStr);  sqlite3DbFreeNN(pParse->db, p);  WHERETRACE(0x800, ("END %s.addVirtual(), rc=%d\n", pSrc->pTab->zName, rc));  return rc; }
#endif
static int whereLoopAddOr(  WhereLoopBuilder *pBuilder,  Bitmask mPrereq,  Bitmask mUnusable ){  WhereInfo *pWInfo = pBuilder->pWInfo;  WhereClause *pWC;  WhereLoop *pNew;  WhereTerm *pTerm, *pWCEnd;  int rc = SQLITE_OK;  int iCur;  WhereClause tempWC;  WhereLoopBuilder sSubBuild;  WhereOrSet sSum, sCur;  SrcItem *pItem;  pWC = pBuilder->pWC;  pWCEnd = pWC->a + pWC->nTerm;  pNew = pBuilder->pNew;  memset(&sSum, 0, sizeof(sSum));  pItem = pWInfo->pTabList->a + pNew->iTab;  iCur = pItem->iCursor;  for(pTerm=pWC->a; pTerm<pWCEnd && rc==SQLITE_OK; pTerm++){  if( (pTerm->eOperator & WO_OR)!=0   && (pTerm->u.pOrInfo->indexable & pNew->maskSelf)!=0  ){  WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;  WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];  WhereTerm *pOrTerm;  int once = 1;  int i, j;  sSubBuild = *pBuilder;  sSubBuild.pOrderBy = 0;  sSubBuild.pOrSet = &sCur;  WHERETRACE(0x200, ("Begin processing OR-clause %p\n", pTerm));  for(pOrTerm=pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++){  if( (pOrTerm->eOperator & WO_AND)!=0 ){  sSubBuild.pWC = &pOrTerm->u.pAndInfo->wc;  }else if( pOrTerm->leftCursor==iCur ){  tempWC.pWInfo = pWC->pWInfo;  tempWC.pOuter = pWC;  tempWC.op = TK_AND;  tempWC.nTerm = 1;  tempWC.a = pOrTerm;  sSubBuild.pWC = &tempWC;  }else{  continue;  }  sCur.n = 0;
#ifdef WHERETRACE_ENABLED
 WHERETRACE(0x200, ("OR-term %d of %p has %d subterms:\n",   (int)(pOrTerm-pOrWC->a), pTerm, sSubBuild.pWC->nTerm));  if( sqlite3WhereTrace & 0x400 ){  sqlite3WhereClausePrint(sSubBuild.pWC);  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pItem->pTab) ){  rc = whereLoopAddVirtual(&sSubBuild, mPrereq, mUnusable);  }else
#endif
 {  rc = whereLoopAddBtree(&sSubBuild, mPrereq);  }  if( rc==SQLITE_OK ){  rc = whereLoopAddOr(&sSubBuild, mPrereq, mUnusable);  }  assert( rc==SQLITE_OK || rc==SQLITE_DONE || sCur.n==0  || rc==SQLITE_NOMEM );  testcase( rc==SQLITE_NOMEM && sCur.n>0 );  testcase( rc==SQLITE_DONE );  if( sCur.n==0 ){  sSum.n = 0;  break;  }else if( once ){  whereOrMove(&sSum, &sCur);  once = 0;  }else{  WhereOrSet sPrev;  whereOrMove(&sPrev, &sSum);  sSum.n = 0;  for(i=0; i<sPrev.n; i++){  for(j=0; j<sCur.n; j++){  whereOrInsert(&sSum, sPrev.a[i].prereq | sCur.a[j].prereq,  sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun),  sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut));  }  }  }  }  pNew->nLTerm = 1;  pNew->aLTerm[0] = pTerm;  pNew->wsFlags = WHERE_MULTI_OR;  pNew->rSetup = 0;  pNew->iSortIdx = 0;  memset(&pNew->u, 0, sizeof(pNew->u));  for(i=0; rc==SQLITE_OK && i<sSum.n; i++){  pNew->rRun = sSum.a[i].rRun + 1;  pNew->nOut = sSum.a[i].nOut;  pNew->prereq = sSum.a[i].prereq;  rc = whereLoopInsert(pBuilder, pNew);  }  WHERETRACE(0x200, ("End processing OR-clause %p\n", pTerm));  }  }  return rc; } static int whereLoopAddAll(WhereLoopBuilder *pBuilder){  WhereInfo *pWInfo = pBuilder->pWInfo;  Bitmask mPrereq = 0;  Bitmask mPrior = 0;  int iTab;  SrcList *pTabList = pWInfo->pTabList;  SrcItem *pItem;  SrcItem *pEnd = &pTabList->a[pWInfo->nLevel];  sqlite3 *db = pWInfo->pParse->db;  int rc = SQLITE_OK;  WhereLoop *pNew;  pNew = pBuilder->pNew;  whereLoopInit(pNew);  pBuilder->iPlanLimit = SQLITE_QUERY_PLANNER_LIMIT;  for(iTab=0, pItem=pTabList->a; pItem<pEnd; iTab++, pItem++){  Bitmask mUnusable = 0;  pNew->iTab = iTab;  pBuilder->iPlanLimit += SQLITE_QUERY_PLANNER_LIMIT_INCR;  pNew->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, pItem->iCursor);  if( (pItem->fg.jointype & (JT_LEFT|JT_CROSS))!=0 ){  mPrereq = mPrior;  }else{  mPrereq = 0;  }
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( IsVirtual(pItem->pTab) ){  SrcItem *p;  for(p=&pItem[1]; p<pEnd; p++){  if( mUnusable || (p->fg.jointype & (JT_LEFT|JT_CROSS)) ){  mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);  }  }  rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable);  }else
#endif
 {  rc = whereLoopAddBtree(pBuilder, mPrereq);  }  if( rc==SQLITE_OK && pBuilder->pWC->hasOr ){  rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable);  }  mPrior |= pNew->maskSelf;  if( rc || db->mallocFailed ){  if( rc==SQLITE_DONE ){  sqlite3_log(SQLITE_WARNING, "abbreviated query algorithm search");  rc = SQLITE_OK;  }else{  break;  }  }  }  whereLoopClear(db, pNew);  return rc; } static i8 wherePathSatisfiesOrderBy(  WhereInfo *pWInfo,  ExprList *pOrderBy,  WherePath *pPath,  u16 wctrlFlags,  u16 nLoop,  WhereLoop *pLast,  Bitmask *pRevMask ){  u8 revSet;  u8 rev;  u8 revIdx;  u8 isOrderDistinct;  u8 distinctColumns;  u8 isMatch;  u16 eqOpMask;  u16 nKeyCol;  u16 nColumn;  u16 nOrderBy;  int iLoop;  int i, j;  int iCur;  int iColumn;  WhereLoop *pLoop = 0;  WhereTerm *pTerm;  Expr *pOBExpr;  CollSeq *pColl;  Index *pIndex;  sqlite3 *db = pWInfo->pParse->db;  Bitmask obSat = 0;  Bitmask obDone;  Bitmask orderDistinctMask;  Bitmask ready;  assert( pOrderBy!=0 );  if( nLoop && OptimizationDisabled(db, SQLITE_OrderByIdxJoin) ) return 0;  nOrderBy = pOrderBy->nExpr;  testcase( nOrderBy==BMS-1 );  if( nOrderBy>BMS-1 ) return 0;  isOrderDistinct = 1;  obDone = MASKBIT(nOrderBy)-1;  orderDistinctMask = 0;  ready = 0;  eqOpMask = WO_EQ | WO_IS | WO_ISNULL;  if( wctrlFlags & (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MAX|WHERE_ORDERBY_MIN) ){  eqOpMask |= WO_IN;  }  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){  if( iLoop>0 ) ready |= pLoop->maskSelf;  if( iLoop<nLoop ){  pLoop = pPath->aLoop[iLoop];  if( wctrlFlags & WHERE_ORDERBY_LIMIT ) continue;  }else{  pLoop = pLast;  }  if( pLoop->wsFlags & WHERE_VIRTUALTABLE ){  if( pLoop->u.vtab.isOrdered && (wctrlFlags & WHERE_DISTINCTBY)==0 ){  obSat = obDone;  }  break;  }else if( wctrlFlags & WHERE_DISTINCTBY ){  pLoop->u.btree.nDistinctCol = 0;  }  iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;  for(i=0; i<nOrderBy; i++){  if( MASKBIT(i) & obSat ) continue;  pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);  if( NEVER(pOBExpr==0) ) continue;  if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) continue;  if( pOBExpr->iTable!=iCur ) continue;  pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,   ~ready, eqOpMask, 0);  if( pTerm==0 ) continue;  if( pTerm->eOperator==WO_IN ){  assert( wctrlFlags &   (WHERE_ORDERBY_LIMIT|WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX) );  for(j=0; j<pLoop->nLTerm && pTerm!=pLoop->aLTerm[j]; j++){}  if( j>=pLoop->nLTerm ) continue;  }  if( (pTerm->eOperator&(WO_EQ|WO_IS))!=0 && pOBExpr->iColumn>=0 ){  Parse *pParse = pWInfo->pParse;  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[i].pExpr);  CollSeq *pColl2 = sqlite3ExprCompareCollSeq(pParse, pTerm->pExpr);  assert( pColl1 );  if( pColl2==0 || sqlite3StrICmp(pColl1->zName, pColl2->zName) ){  continue;  }  testcase( pTerm->pExpr->op==TK_IS );  }  obSat |= MASKBIT(i);  }  if( (pLoop->wsFlags & WHERE_ONEROW)==0 ){  if( pLoop->wsFlags & WHERE_IPK ){  pIndex = 0;  nKeyCol = 0;  nColumn = 1;  }else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){  return 0;  }else{  nKeyCol = pIndex->nKeyCol;  nColumn = pIndex->nColumn;  assert( nColumn==nKeyCol+1 || !HasRowid(pIndex->pTable) );  assert( pIndex->aiColumn[nColumn-1]==XN_ROWID  || !HasRowid(pIndex->pTable));  isOrderDistinct = IsUniqueIndex(pIndex)  && (pLoop->wsFlags & WHERE_SKIPSCAN)==0;  }  rev = revSet = 0;  distinctColumns = 0;  for(j=0; j<nColumn; j++){  u8 bOnce = 1;  assert( j>=pLoop->u.btree.nEq  || (pLoop->aLTerm[j]==0)==(j<pLoop->nSkip)  );  if( j<pLoop->u.btree.nEq && j>=pLoop->nSkip ){  u16 eOp = pLoop->aLTerm[j]->eOperator;  if( (eOp & eqOpMask)!=0 ){  if( eOp & (WO_ISNULL|WO_IS) ){  testcase( eOp & WO_ISNULL );  testcase( eOp & WO_IS );  testcase( isOrderDistinct );  isOrderDistinct = 0;  }  continue;  }else if( ALWAYS(eOp & WO_IN) ){  Expr *pX = pLoop->aLTerm[j]->pExpr;  for(i=j+1; i<pLoop->u.btree.nEq; i++){  if( pLoop->aLTerm[i]->pExpr==pX ){  assert( (pLoop->aLTerm[i]->eOperator & WO_IN) );  bOnce = 0;  break;  }  }  }  }  if( pIndex ){  iColumn = pIndex->aiColumn[j];  revIdx = pIndex->aSortOrder[j] & KEYINFO_ORDER_DESC;  if( iColumn==pIndex->pTable->iPKey ) iColumn = XN_ROWID;  }else{  iColumn = XN_ROWID;  revIdx = 0;  }  if( isOrderDistinct ){  if( iColumn>=0   && j>=pLoop->u.btree.nEq   && pIndex->pTable->aCol[iColumn].notNull==0  ){  isOrderDistinct = 0;  }  if( iColumn==XN_EXPR ){  isOrderDistinct = 0;  }  }  isMatch = 0;  for(i=0; bOnce && i<nOrderBy; i++){  if( MASKBIT(i) & obSat ) continue;  pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);  testcase( wctrlFlags & WHERE_GROUPBY );  testcase( wctrlFlags & WHERE_DISTINCTBY );  if( NEVER(pOBExpr==0) ) continue;  if( (wctrlFlags & (WHERE_GROUPBY|WHERE_DISTINCTBY))==0 ) bOnce = 0;  if( iColumn>=XN_ROWID ){  if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) continue;  if( pOBExpr->iTable!=iCur ) continue;  if( pOBExpr->iColumn!=iColumn ) continue;  }else{  Expr *pIdxExpr = pIndex->aColExpr->a[j].pExpr;  if( sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, iCur) ){  continue;  }  }  if( iColumn!=XN_ROWID ){  pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);  if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;  }  if( wctrlFlags & WHERE_DISTINCTBY ){  pLoop->u.btree.nDistinctCol = j+1;  }  isMatch = 1;  break;  }  if( isMatch && (wctrlFlags & WHERE_GROUPBY)==0 ){  if( revSet ){  if( (rev ^ revIdx)!=(pOrderBy->a[i].sortFlags&KEYINFO_ORDER_DESC) ){  isMatch = 0;  }  }else{  rev = revIdx ^ (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_DESC);  if( rev ) *pRevMask |= MASKBIT(iLoop);  revSet = 1;  }  }  if( isMatch && (pOrderBy->a[i].sortFlags & KEYINFO_ORDER_BIGNULL) ){  if( j==pLoop->u.btree.nEq ){  pLoop->wsFlags |= WHERE_BIGNULL_SORT;  }else{  isMatch = 0;  }  }  if( isMatch ){  if( iColumn==XN_ROWID ){  testcase( distinctColumns==0 );  distinctColumns = 1;  }  obSat |= MASKBIT(i);  }else{  if( j==0 || j<nKeyCol ){  testcase( isOrderDistinct!=0 );  isOrderDistinct = 0;  }  break;  }  }  if( distinctColumns ){  testcase( isOrderDistinct==0 );  isOrderDistinct = 1;  }  }  if( isOrderDistinct ){  orderDistinctMask |= pLoop->maskSelf;  for(i=0; i<nOrderBy; i++){  Expr *p;  Bitmask mTerm;  if( MASKBIT(i) & obSat ) continue;  p = pOrderBy->a[i].pExpr;  mTerm = sqlite3WhereExprUsage(&pWInfo->sMaskSet,p);  if( mTerm==0 && !sqlite3ExprIsConstant(p) ) continue;  if( (mTerm&~orderDistinctMask)==0 ){  obSat |= MASKBIT(i);  }  }  }  }  if( obSat==obDone ) return (i8)nOrderBy;  if( !isOrderDistinct ){  for(i=nOrderBy-1; i>0; i--){  Bitmask m = ALWAYS(i<BMS) ? MASKBIT(i) - 1 : 0;  if( (obSat&m)==m ) return i;  }  return 0;  }  return -1; } SQLITE_PRIVATE int sqlite3WhereIsSorted(WhereInfo *pWInfo){  assert( pWInfo->wctrlFlags & WHERE_GROUPBY );  assert( pWInfo->wctrlFlags & WHERE_SORTBYGROUP );  return pWInfo->sorted; }
#ifdef WHERETRACE_ENABLED
static const char *wherePathName(WherePath *pPath, int nLoop, WhereLoop *pLast){  static char zName[65];  int i;  for(i=0; i<nLoop; i++){ zName[i] = pPath->aLoop[i]->cId; }  if( pLast ) zName[i++] = pLast->cId;  zName[i] = 0;  return zName; }
#endif
static LogEst whereSortingCost(  WhereInfo *pWInfo,  LogEst nRow,  int nOrderBy,  int nSorted ){  LogEst rScale, rSortCost;  assert( nOrderBy>0 && 66==sqlite3LogEst(100) );  rScale = sqlite3LogEst((nOrderBy-nSorted)*100/nOrderBy) - 66;  rSortCost = nRow + rScale + 16;  if( (pWInfo->wctrlFlags & WHERE_USE_LIMIT)!=0 && pWInfo->iLimit<nRow ){  nRow = pWInfo->iLimit;  }else if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT) ){  if( nRow>10 ){ nRow -= 10; assert( 10==sqlite3LogEst(2) ); }  }  rSortCost += estLog(nRow);  return rSortCost; } static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){  int mxChoice;  int nLoop;  Parse *pParse;  sqlite3 *db;  int iLoop;  int ii, jj;  int mxI = 0;  int nOrderBy;  LogEst mxCost = 0;  LogEst mxUnsorted = 0;  int nTo, nFrom;  WherePath *aFrom;  WherePath *aTo;  WherePath *pFrom;  WherePath *pTo;  WhereLoop *pWLoop;  WhereLoop **pX;  LogEst *aSortCost = 0;  char *pSpace;  int nSpace;  pParse = pWInfo->pParse;  db = pParse->db;  nLoop = pWInfo->nLevel;  mxChoice = (nLoop<=1) ? 1 : (nLoop==2 ? 5 : 10);  assert( nLoop<=pWInfo->pTabList->nSrc );  WHERETRACE(0x002, ("---- begin solver. (nRowEst=%d)\n", nRowEst));  if( pWInfo->pOrderBy==0 || nRowEst==0 ){  nOrderBy = 0;  }else{  nOrderBy = pWInfo->pOrderBy->nExpr;  }  nSpace = (sizeof(WherePath)+sizeof(WhereLoop*)*nLoop)*mxChoice*2;  nSpace += sizeof(LogEst) * nOrderBy;  pSpace = sqlite3DbMallocRawNN(db, nSpace);  if( pSpace==0 ) return SQLITE_NOMEM_BKPT;  aTo = (WherePath*)pSpace;  aFrom = aTo+mxChoice;  memset(aFrom, 0, sizeof(aFrom[0]));  pX = (WhereLoop**)(aFrom+mxChoice);  for(ii=mxChoice*2, pFrom=aTo; ii>0; ii--, pFrom++, pX += nLoop){  pFrom->aLoop = pX;  }  if( nOrderBy ){  aSortCost = (LogEst*)pX;  memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);  }  assert( aSortCost==0 || &pSpace[nSpace]==(char*)&aSortCost[nOrderBy] );  assert( aSortCost!=0 || &pSpace[nSpace]==(char*)pX );  aFrom[0].nRow = MIN(pParse->nQueryLoop, 48); assert( 48==sqlite3LogEst(28) );  nFrom = 1;  assert( aFrom[0].isOrdered==0 );  if( nOrderBy ){  aFrom[0].isOrdered = nLoop>0 ? -1 : nOrderBy;  }  for(iLoop=0; iLoop<nLoop; iLoop++){  nTo = 0;  for(ii=0, pFrom=aFrom; ii<nFrom; ii++, pFrom++){  for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){  LogEst nOut;  LogEst rCost;  LogEst rUnsorted;  i8 isOrdered = pFrom->isOrdered;  Bitmask maskNew;  Bitmask revMask = 0;  if( (pWLoop->prereq & ~pFrom->maskLoop)!=0 ) continue;  if( (pWLoop->maskSelf & pFrom->maskLoop)!=0 ) continue;  if( (pWLoop->wsFlags & WHERE_AUTO_INDEX)!=0 && pFrom->nRow<3 ){  assert( 10==sqlite3LogEst(2) );  continue;  }  rUnsorted = sqlite3LogEstAdd(pWLoop->rSetup,pWLoop->rRun + pFrom->nRow);  rUnsorted = sqlite3LogEstAdd(rUnsorted, pFrom->rUnsorted);  nOut = pFrom->nRow + pWLoop->nOut;  maskNew = pFrom->maskLoop | pWLoop->maskSelf;  if( isOrdered<0 ){  isOrdered = wherePathSatisfiesOrderBy(pWInfo,   pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags,   iLoop, pWLoop, &revMask);  }else{  revMask = pFrom->revLoop;  }  if( isOrdered>=0 && isOrdered<nOrderBy ){  if( aSortCost[isOrdered]==0 ){  aSortCost[isOrdered] = whereSortingCost(  pWInfo, nRowEst, nOrderBy, isOrdered  );  }  rCost = sqlite3LogEstAdd(rUnsorted, aSortCost[isOrdered]) + 5;  WHERETRACE(0x002,  ("---- sort cost=%-3d (%d/%d) increases cost %3d to %-3d\n",   aSortCost[isOrdered], (nOrderBy-isOrdered), nOrderBy,   rUnsorted, rCost));  }else{  rCost = rUnsorted;  rUnsorted -= 2;  }  for(jj=0, pTo=aTo; jj<nTo; jj++, pTo++){  if( pTo->maskLoop==maskNew   && ((pTo->isOrdered^isOrdered)&0x80)==0  ){  testcase( jj==nTo-1 );  break;  }  }  if( jj>=nTo ){  if( nTo>=mxChoice   && (rCost>mxCost || (rCost==mxCost && rUnsorted>=mxUnsorted))  ){
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace&0x4 ){  sqlite3DebugPrintf("Skip  %s cost=%-3d,%3d,%3d order=%c\n",  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,  isOrdered>=0 ? isOrdered+'0' : '?');  }
#endif
 continue;  }  if( nTo<mxChoice ){  jj = nTo++;  }else{  jj = mxI;  }  pTo = &aTo[jj];
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace&0x4 ){  sqlite3DebugPrintf("New %s cost=%-3d,%3d,%3d order=%c\n",  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,  isOrdered>=0 ? isOrdered+'0' : '?');  }
#endif
 }else{  if( pTo->rCost<rCost   || (pTo->rCost==rCost   && (pTo->nRow<nOut   || (pTo->nRow==nOut && pTo->rUnsorted<=rUnsorted)  )  )  ){
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace&0x4 ){  sqlite3DebugPrintf(  "Skip  %s cost=%-3d,%3d,%3d order=%c",  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,  isOrdered>=0 ? isOrdered+'0' : '?');  sqlite3DebugPrintf("  vs %s cost=%-3d,%3d,%3d order=%c\n",  wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,  pTo->rUnsorted, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');  }
#endif
 testcase( pTo->rCost==rCost );  continue;  }  testcase( pTo->rCost==rCost+1 );
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace&0x4 ){  sqlite3DebugPrintf(  "Update %s cost=%-3d,%3d,%3d order=%c",  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,  isOrdered>=0 ? isOrdered+'0' : '?');  sqlite3DebugPrintf(" was %s cost=%-3d,%3d,%3d order=%c\n",  wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,  pTo->rUnsorted, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');  }
#endif
 }  pTo->maskLoop = pFrom->maskLoop | pWLoop->maskSelf;  pTo->revLoop = revMask;  pTo->nRow = nOut;  pTo->rCost = rCost;  pTo->rUnsorted = rUnsorted;  pTo->isOrdered = isOrdered;  memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);  pTo->aLoop[iLoop] = pWLoop;  if( nTo>=mxChoice ){  mxI = 0;  mxCost = aTo[0].rCost;  mxUnsorted = aTo[0].nRow;  for(jj=1, pTo=&aTo[1]; jj<mxChoice; jj++, pTo++){  if( pTo->rCost>mxCost   || (pTo->rCost==mxCost && pTo->rUnsorted>mxUnsorted)  ){  mxCost = pTo->rCost;  mxUnsorted = pTo->rUnsorted;  mxI = jj;  }  }  }  }  }
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace & 0x02 ){  sqlite3DebugPrintf("---- after round %d ----\n", iLoop);  for(ii=0, pTo=aTo; ii<nTo; ii++, pTo++){  sqlite3DebugPrintf(" %s cost=%-3d nrow=%-3d order=%c",   wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,   pTo->isOrdered>=0 ? (pTo->isOrdered+'0') : '?');  if( pTo->isOrdered>0 ){  sqlite3DebugPrintf(" rev=0x%llx\n", pTo->revLoop);  }else{  sqlite3DebugPrintf("\n");  }  }  }
#endif
 pFrom = aTo;  aTo = aFrom;  aFrom = pFrom;  nFrom = nTo;  }  if( nFrom==0 ){  sqlite3ErrorMsg(pParse, "no query solution");  sqlite3DbFreeNN(db, pSpace);  return SQLITE_ERROR;  }  pFrom = aFrom;  for(ii=1; ii<nFrom; ii++){  if( pFrom->rCost>aFrom[ii].rCost ) pFrom = &aFrom[ii];  }  assert( pWInfo->nLevel==nLoop );  for(iLoop=0; iLoop<nLoop; iLoop++){  WhereLevel *pLevel = pWInfo->a + iLoop;  pLevel->pWLoop = pWLoop = pFrom->aLoop[iLoop];  pLevel->iFrom = pWLoop->iTab;  pLevel->iTabCur = pWInfo->pTabList->a[pLevel->iFrom].iCursor;  }  if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT)!=0   && (pWInfo->wctrlFlags & WHERE_DISTINCTBY)==0   && pWInfo->eDistinct==WHERE_DISTINCT_NOOP   && nRowEst  ){  Bitmask notUsed;  int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom,   WHERE_DISTINCTBY, nLoop-1, pFrom->aLoop[nLoop-1], &notUsed);  if( rc==pWInfo->pResultSet->nExpr ){  pWInfo->eDistinct = WHERE_DISTINCT_ORDERED;  }  }  pWInfo->bOrderedInnerLoop = 0;  if( pWInfo->pOrderBy ){  if( pWInfo->wctrlFlags & WHERE_DISTINCTBY ){  if( pFrom->isOrdered==pWInfo->pOrderBy->nExpr ){  pWInfo->eDistinct = WHERE_DISTINCT_ORDERED;  }  }else{  pWInfo->nOBSat = pFrom->isOrdered;  pWInfo->revMask = pFrom->revLoop;  if( pWInfo->nOBSat<=0 ){  pWInfo->nOBSat = 0;  if( nLoop>0 ){  u32 wsFlags = pFrom->aLoop[nLoop-1]->wsFlags;  if( (wsFlags & WHERE_ONEROW)==0   && (wsFlags&(WHERE_IPK|WHERE_COLUMN_IN))!=(WHERE_IPK|WHERE_COLUMN_IN)  ){  Bitmask m = 0;  int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom,  WHERE_ORDERBY_LIMIT, nLoop-1, pFrom->aLoop[nLoop-1], &m);  testcase( wsFlags & WHERE_IPK );  testcase( wsFlags & WHERE_COLUMN_IN );  if( rc==pWInfo->pOrderBy->nExpr ){  pWInfo->bOrderedInnerLoop = 1;  pWInfo->revMask = m;  }  }  }  }else if( nLoop  && pWInfo->nOBSat==1  && (pWInfo->wctrlFlags & (WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX))!=0  ){  pWInfo->bOrderedInnerLoop = 1;  }  }  if( (pWInfo->wctrlFlags & WHERE_SORTBYGROUP)  && pWInfo->nOBSat==pWInfo->pOrderBy->nExpr && nLoop>0  ){  Bitmask revMask = 0;  int nOrder = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy,  pFrom, 0, nLoop-1, pFrom->aLoop[nLoop-1], &revMask  );  assert( pWInfo->sorted==0 );  if( nOrder==pWInfo->pOrderBy->nExpr ){  pWInfo->sorted = 1;  pWInfo->revMask = revMask;  }  }  }  pWInfo->nRowOut = pFrom->nRow;  sqlite3DbFreeNN(db, pSpace);  return SQLITE_OK; } static int whereShortCut(WhereLoopBuilder *pBuilder){  WhereInfo *pWInfo;  SrcItem *pItem;  WhereClause *pWC;  WhereTerm *pTerm;  WhereLoop *pLoop;  int iCur;  int j;  Table *pTab;  Index *pIdx;  WhereScan scan;  pWInfo = pBuilder->pWInfo;  if( pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE ) return 0;  assert( pWInfo->pTabList->nSrc>=1 );  pItem = pWInfo->pTabList->a;  pTab = pItem->pTab;  if( IsVirtual(pTab) ) return 0;  if( pItem->fg.isIndexedBy ) return 0;  iCur = pItem->iCursor;  pWC = &pWInfo->sWC;  pLoop = pBuilder->pNew;  pLoop->wsFlags = 0;  pLoop->nSkip = 0;  pTerm = whereScanInit(&scan, pWC, iCur, -1, WO_EQ|WO_IS, 0);  while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);  if( pTerm ){  testcase( pTerm->eOperator & WO_IS );  pLoop->wsFlags = WHERE_COLUMN_EQ|WHERE_IPK|WHERE_ONEROW;  pLoop->aLTerm[0] = pTerm;  pLoop->nLTerm = 1;  pLoop->u.btree.nEq = 1;  pLoop->rRun = 33;  }else{  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){  int opMask;  assert( pLoop->aLTermSpace==pLoop->aLTerm );  if( !IsUniqueIndex(pIdx)   || pIdx->pPartIdxWhere!=0   || pIdx->nKeyCol>ArraySize(pLoop->aLTermSpace)  ) continue;  opMask = pIdx->uniqNotNull ? (WO_EQ|WO_IS) : WO_EQ;  for(j=0; j<pIdx->nKeyCol; j++){  pTerm = whereScanInit(&scan, pWC, iCur, j, opMask, pIdx);  while( pTerm && pTerm->prereqRight ) pTerm = whereScanNext(&scan);  if( pTerm==0 ) break;  testcase( pTerm->eOperator & WO_IS );  pLoop->aLTerm[j] = pTerm;  }  if( j!=pIdx->nKeyCol ) continue;  pLoop->wsFlags = WHERE_COLUMN_EQ|WHERE_ONEROW|WHERE_INDEXED;  if( pIdx->isCovering || (pItem->colUsed & pIdx->colNotIdxed)==0 ){  pLoop->wsFlags |= WHERE_IDX_ONLY;  }  pLoop->nLTerm = j;  pLoop->u.btree.nEq = j;  pLoop->u.btree.pIndex = pIdx;  pLoop->rRun = 39;  break;  }  }  if( pLoop->wsFlags ){  pLoop->nOut = (LogEst)1;  pWInfo->a[0].pWLoop = pLoop;  assert( pWInfo->sMaskSet.n==1 && iCur==pWInfo->sMaskSet.ix[0] );  pLoop->maskSelf = 1;  pWInfo->a[0].iTabCur = iCur;  pWInfo->nRowOut = 1;  if( pWInfo->pOrderBy ) pWInfo->nOBSat = pWInfo->pOrderBy->nExpr;  if( pWInfo->wctrlFlags & WHERE_WANT_DISTINCT ){  pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;  }  if( scan.iEquiv>1 ) pLoop->wsFlags |= WHERE_TRANSCONS;
#ifdef SQLITE_DEBUG
 pLoop->cId = '0';
#endif
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace ){  sqlite3DebugPrintf("whereShortCut() used to compute solution\n");  }
#endif
 return 1;  }  return 0; } static int exprNodeIsDeterministic(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_FUNCTION && ExprHasProperty(pExpr, EP_ConstFunc)==0 ){  pWalker->eCode = 0;  return WRC_Abort;  }  return WRC_Continue; } static int exprIsDeterministic(Expr *p){  Walker w;  memset(&w, 0, sizeof(w));  w.eCode = 1;  w.xExprCallback = exprNodeIsDeterministic;  w.xSelectCallback = sqlite3SelectWalkFail;  sqlite3WalkExpr(&w, p);  return w.eCode; }
#ifdef WHERETRACE_ENABLED
static void showAllWhereLoops(WhereInfo *pWInfo, WhereClause *pWC){  if( sqlite3WhereTrace ){  WhereLoop *p;  int i;  static const char zLabel[] = "0123456789abcdefghijklmnopqrstuvwyxz"   "ABCDEFGHIJKLMNOPQRSTUVWYXZ";  for(p=pWInfo->pLoops, i=0; p; p=p->pNextLoop, i++){  p->cId = zLabel[i%(sizeof(zLabel)-1)];  sqlite3WhereLoopPrint(p, pWC);  }  } }
# define WHERETRACE_ALL_LOOPS(W,C) showAllWhereLoops(W,C)
#else
# define WHERETRACE_ALL_LOOPS(W,C)
#endif
SQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(  Parse *pParse,  SrcList *pTabList,  Expr *pWhere,  ExprList *pOrderBy,  ExprList *pResultSet,  u16 wctrlFlags,  int iAuxArg ){  int nByteWInfo;  int nTabList;  WhereInfo *pWInfo;  Vdbe *v = pParse->pVdbe;  Bitmask notReady;  WhereLoopBuilder sWLB;  WhereMaskSet *pMaskSet;  WhereLevel *pLevel;  WhereLoop *pLoop;  int ii;  sqlite3 *db;  int rc;  u8 bFordelete = 0;  assert( (wctrlFlags & WHERE_ONEPASS_MULTIROW)==0 || (  (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0   && (wctrlFlags & WHERE_OR_SUBCLAUSE)==0  ));  assert( (wctrlFlags & WHERE_OR_SUBCLAUSE)==0  || (wctrlFlags & WHERE_USE_LIMIT)==0 );  db = pParse->db;  memset(&sWLB, 0, sizeof(sWLB));  testcase( pOrderBy && pOrderBy->nExpr==BMS-1 );  if( pOrderBy && pOrderBy->nExpr>=BMS ) pOrderBy = 0;  sWLB.pOrderBy = pOrderBy;  if( OptimizationDisabled(db, SQLITE_DistinctOpt) ){  wctrlFlags &= ~WHERE_WANT_DISTINCT;  }  testcase( pTabList->nSrc==BMS );  if( pTabList->nSrc>BMS ){  sqlite3ErrorMsg(pParse, "at most %d tables in a join", BMS);  return 0;  }  nTabList = (wctrlFlags & WHERE_OR_SUBCLAUSE) ? 1 : pTabList->nSrc;  nByteWInfo = ROUND8(sizeof(WhereInfo)+(nTabList-1)*sizeof(WhereLevel));  pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));  if( db->mallocFailed ){  sqlite3DbFree(db, pWInfo);  pWInfo = 0;  goto whereBeginError;  }  pWInfo->pParse = pParse;  pWInfo->pTabList = pTabList;  pWInfo->pOrderBy = pOrderBy;  pWInfo->pWhere = pWhere;  pWInfo->pResultSet = pResultSet;  pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;  pWInfo->nLevel = nTabList;  pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(pParse);  pWInfo->wctrlFlags = wctrlFlags;  pWInfo->iLimit = iAuxArg;  pWInfo->savedNQueryLoop = pParse->nQueryLoop;  memset(&pWInfo->nOBSat, 0,   offsetof(WhereInfo,sWC) - offsetof(WhereInfo,nOBSat));  memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));  assert( pWInfo->eOnePass==ONEPASS_OFF );  pMaskSet = &pWInfo->sMaskSet;  sWLB.pWInfo = pWInfo;  sWLB.pWC = &pWInfo->sWC;  sWLB.pNew = (WhereLoop*)(((char*)pWInfo)+nByteWInfo);  assert( EIGHT_BYTE_ALIGNMENT(sWLB.pNew) );  whereLoopInit(sWLB.pNew);
#ifdef SQLITE_DEBUG
 sWLB.pNew->cId = '*';
#endif
 initMaskSet(pMaskSet);  sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);  sqlite3WhereSplit(&pWInfo->sWC, pWhere, TK_AND);  if( nTabList==0 ){  if( pOrderBy ) pWInfo->nOBSat = pOrderBy->nExpr;  if( wctrlFlags & WHERE_WANT_DISTINCT ){  pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;  }  ExplainQueryPlan((pParse, 0, "SCAN CONSTANT ROW"));  }else{  ii = 0;  do{  createMask(pMaskSet, pTabList->a[ii].iCursor);  sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);  }while( (++ii)<pTabList->nSrc );
 #ifdef SQLITE_DEBUG
 {  Bitmask mx = 0;  for(ii=0; ii<pTabList->nSrc; ii++){  Bitmask m = sqlite3WhereGetMask(pMaskSet, pTabList->a[ii].iCursor);  assert( m>=mx );  mx = m;  }  }
 #endif
 }  sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);  if( db->mallocFailed ) goto whereBeginError;  for(ii=0; ii<sWLB.pWC->nTerm; ii++){  WhereTerm *pT = &sWLB.pWC->a[ii];  if( pT->wtFlags & TERM_VIRTUAL ) continue;  if( pT->prereqAll==0 && (nTabList==0 || exprIsDeterministic(pT->pExpr)) ){  sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, SQLITE_JUMPIFNULL);  pT->wtFlags |= TERM_CODED;  }  }  if( wctrlFlags & WHERE_WANT_DISTINCT ){  if( isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet) ){  pWInfo->eDistinct = WHERE_DISTINCT_UNIQUE;  }else if( pOrderBy==0 ){  pWInfo->wctrlFlags |= WHERE_DISTINCTBY;  pWInfo->pOrderBy = pResultSet;  }  }
#if defined(WHERETRACE_ENABLED)
 if( sqlite3WhereTrace & 0xffff ){  sqlite3DebugPrintf("*** Optimizer Start *** (wctrlFlags: 0x%x",wctrlFlags);  if( wctrlFlags & WHERE_USE_LIMIT ){  sqlite3DebugPrintf(", limit: %d", iAuxArg);  }  sqlite3DebugPrintf(")\n");  if( sqlite3WhereTrace & 0x100 ){  Select sSelect;  memset(&sSelect, 0, sizeof(sSelect));  sSelect.selFlags = SF_WhereBegin;  sSelect.pSrc = pTabList;  sSelect.pWhere = pWhere;  sSelect.pOrderBy = pOrderBy;  sSelect.pEList = pResultSet;  sqlite3TreeViewSelect(0, &sSelect, 0);  }  }  if( sqlite3WhereTrace & 0x100 ){  sqlite3DebugPrintf("---- WHERE clause at start of analysis:\n");  sqlite3WhereClausePrint(sWLB.pWC);  }
#endif
 if( nTabList!=1 || whereShortCut(&sWLB)==0 ){  rc = whereLoopAddAll(&sWLB);  if( rc ) goto whereBeginError;
#ifdef SQLITE_ENABLE_STAT4
 if( sWLB.bldFlags2 & SQLITE_BLDF2_2NDPASS ){  WHERETRACE_ALL_LOOPS(pWInfo, sWLB.pWC);  WHERETRACE(0xffff,   ("**** Redo all loop computations due to"  " TERM_HIGHTRUTH changes ****\n"));  while( pWInfo->pLoops ){  WhereLoop *p = pWInfo->pLoops;  pWInfo->pLoops = p->pNextLoop;  whereLoopDelete(db, p);  }  rc = whereLoopAddAll(&sWLB);  if( rc ) goto whereBeginError;  }
#endif
 WHERETRACE_ALL_LOOPS(pWInfo, sWLB.pWC);  wherePathSolver(pWInfo, 0);  if( db->mallocFailed ) goto whereBeginError;  if( pWInfo->pOrderBy ){   wherePathSolver(pWInfo, pWInfo->nRowOut+1);   if( db->mallocFailed ) goto whereBeginError;  }  }  if( pWInfo->pOrderBy==0 && (db->flags & SQLITE_ReverseOrder)!=0 ){   pWInfo->revMask = ALLBITS;  }  if( pParse->nErr || db->mallocFailed ){  goto whereBeginError;  }
#ifdef WHERETRACE_ENABLED
 if( sqlite3WhereTrace ){  sqlite3DebugPrintf("---- Solution nRow=%d", pWInfo->nRowOut);  if( pWInfo->nOBSat>0 ){  sqlite3DebugPrintf(" ORDERBY=%d,0x%llx", pWInfo->nOBSat, pWInfo->revMask);  }  switch( pWInfo->eDistinct ){  case WHERE_DISTINCT_UNIQUE: {  sqlite3DebugPrintf(" DISTINCT=unique");  break;  }  case WHERE_DISTINCT_ORDERED: {  sqlite3DebugPrintf(" DISTINCT=ordered");  break;  }  case WHERE_DISTINCT_UNORDERED: {  sqlite3DebugPrintf(" DISTINCT=unordered");  break;  }  }  sqlite3DebugPrintf("\n");  for(ii=0; ii<pWInfo->nLevel; ii++){  sqlite3WhereLoopPrint(pWInfo->a[ii].pWLoop, sWLB.pWC);  }  }
#endif
 notReady = ~(Bitmask)0;  if( pWInfo->nLevel>=2   && pResultSet!=0   && 0==(wctrlFlags & WHERE_AGG_DISTINCT)   && OptimizationEnabled(db, SQLITE_OmitNoopJoin)  ){  int i;  Bitmask tabUsed = sqlite3WhereExprListUsage(pMaskSet, pResultSet);  if( sWLB.pOrderBy ){  tabUsed |= sqlite3WhereExprListUsage(pMaskSet, sWLB.pOrderBy);  }  for(i=pWInfo->nLevel-1; i>=1; i--){  WhereTerm *pTerm, *pEnd;  SrcItem *pItem;  pLoop = pWInfo->a[i].pWLoop;  pItem = &pWInfo->pTabList->a[pLoop->iTab];  if( (pItem->fg.jointype & JT_LEFT)==0 ) continue;  if( (wctrlFlags & WHERE_WANT_DISTINCT)==0   && (pLoop->wsFlags & WHERE_ONEROW)==0  ){  continue;  }  if( (tabUsed & pLoop->maskSelf)!=0 ) continue;  pEnd = sWLB.pWC->a + sWLB.pWC->nTerm;  for(pTerm=sWLB.pWC->a; pTerm<pEnd; pTerm++){  if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){  if( !ExprHasProperty(pTerm->pExpr, EP_FromJoin)   || pTerm->pExpr->iRightJoinTable!=pItem->iCursor  ){  break;  }  }  }  if( pTerm<pEnd ) continue;  WHERETRACE(0xffff, ("-> drop loop %c not used\n", pLoop->cId));  notReady &= ~pLoop->maskSelf;  for(pTerm=sWLB.pWC->a; pTerm<pEnd; pTerm++){  if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){  pTerm->wtFlags |= TERM_CODED;  }  }  if( i!=pWInfo->nLevel-1 ){  int nByte = (pWInfo->nLevel-1-i) * sizeof(WhereLevel);  memmove(&pWInfo->a[i], &pWInfo->a[i+1], nByte);  }  pWInfo->nLevel--;  nTabList--;  }  }
#if defined(WHERETRACE_ENABLED)
 if( sqlite3WhereTrace & 0x100 ){  sqlite3DebugPrintf("---- WHERE clause at end of analysis:\n");  sqlite3WhereClausePrint(sWLB.pWC);  }  WHERETRACE(0xffff,("*** Optimizer Finished ***\n"));
#endif
 pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;  assert( (wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || pWInfo->nLevel==1 );  if( (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0 ){  int wsFlags = pWInfo->a[0].pWLoop->wsFlags;  int bOnerow = (wsFlags & WHERE_ONEROW)!=0;  assert( !(wsFlags & WHERE_VIRTUALTABLE) || IsVirtual(pTabList->a[0].pTab) );  if( bOnerow || (  0!=(wctrlFlags & WHERE_ONEPASS_MULTIROW)   && !IsVirtual(pTabList->a[0].pTab)   && (0==(wsFlags & WHERE_MULTI_OR) || (wctrlFlags & WHERE_DUPLICATES_OK))  )){  pWInfo->eOnePass = bOnerow ? ONEPASS_SINGLE : ONEPASS_MULTI;  if( HasRowid(pTabList->a[0].pTab) && (wsFlags & WHERE_IDX_ONLY) ){  if( wctrlFlags & WHERE_ONEPASS_MULTIROW ){  bFordelete = OPFLAG_FORDELETE;  }  pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~WHERE_IDX_ONLY);  }  }  }  for(ii=0, pLevel=pWInfo->a; ii<nTabList; ii++, pLevel++){  Table *pTab;  int iDb;  SrcItem *pTabItem;  pTabItem = &pTabList->a[pLevel->iFrom];  pTab = pTabItem->pTab;  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);  pLoop = pLevel->pWLoop;  if( (pTab->tabFlags & TF_Ephemeral)!=0 || IsView(pTab) ){  }else
#ifndef SQLITE_OMIT_VIRTUALTABLE
 if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 ){  const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);  int iCur = pTabItem->iCursor;  sqlite3VdbeAddOp4(v, OP_VOpen, iCur, 0, 0, pVTab, P4_VTAB);  }else if( IsVirtual(pTab) ){  }else
#endif
 if( (pLoop->wsFlags & WHERE_IDX_ONLY)==0   && (wctrlFlags & WHERE_OR_SUBCLAUSE)==0 ){  int op = OP_OpenRead;  if( pWInfo->eOnePass!=ONEPASS_OFF ){  op = OP_OpenWrite;  pWInfo->aiCurOnePass[0] = pTabItem->iCursor;  };  sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);  assert( pTabItem->iCursor==pLevel->iTabCur );  testcase( pWInfo->eOnePass==ONEPASS_OFF && pTab->nCol==BMS-1 );  testcase( pWInfo->eOnePass==ONEPASS_OFF && pTab->nCol==BMS );  if( pWInfo->eOnePass==ONEPASS_OFF   && pTab->nCol<BMS   && (pTab->tabFlags & (TF_HasGenerated|TF_WithoutRowid))==0  ){  Bitmask b = pTabItem->colUsed;  int n = 0;  for(; b; b=b>>1, n++){}  sqlite3VdbeChangeP4(v, -1, SQLITE_INT_TO_PTR(n), P4_INT32);  assert( n<=pTab->nCol );  }
#ifdef SQLITE_ENABLE_CURSOR_HINTS
 if( pLoop->u.btree.pIndex!=0 ){  sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ|bFordelete);  }else
#endif
 {  sqlite3VdbeChangeP5(v, bFordelete);  }
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
 sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, pTabItem->iCursor, 0, 0,  (const u8*)&pTabItem->colUsed, P4_INT64);
#endif
 }else{  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);  }  if( pLoop->wsFlags & WHERE_INDEXED ){  Index *pIx = pLoop->u.btree.pIndex;  int iIndexCur;  int op = OP_OpenRead;  assert( iAuxArg!=0 || (pWInfo->wctrlFlags & WHERE_ONEPASS_DESIRED)==0 );  if( !HasRowid(pTab) && IsPrimaryKeyIndex(pIx)   && (wctrlFlags & WHERE_OR_SUBCLAUSE)!=0  ){  iIndexCur = pLevel->iTabCur;  op = 0;  }else if( pWInfo->eOnePass!=ONEPASS_OFF ){  Index *pJ = pTabItem->pTab->pIndex;  iIndexCur = iAuxArg;  assert( wctrlFlags & WHERE_ONEPASS_DESIRED );  while( ALWAYS(pJ) && pJ!=pIx ){  iIndexCur++;  pJ = pJ->pNext;  }  op = OP_OpenWrite;  pWInfo->aiCurOnePass[1] = iIndexCur;  }else if( iAuxArg && (wctrlFlags & WHERE_OR_SUBCLAUSE)!=0 ){  iIndexCur = iAuxArg;  op = OP_ReopenIdx;  }else{  iIndexCur = pParse->nTab++;  }  pLevel->iIdxCur = iIndexCur;  assert( pIx->pSchema==pTab->pSchema );  assert( iIndexCur>=0 );  if( op ){  sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIx);  if( (pLoop->wsFlags & WHERE_CONSTRAINT)!=0   && (pLoop->wsFlags & (WHERE_COLUMN_RANGE|WHERE_SKIPSCAN))==0   && (pLoop->wsFlags & WHERE_BIGNULL_SORT)==0   && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0   && (pWInfo->wctrlFlags&WHERE_ORDERBY_MIN)==0   && pWInfo->eDistinct!=WHERE_DISTINCT_ORDERED  ){  sqlite3VdbeChangeP5(v, OPFLAG_SEEKEQ);  }  VdbeComment((v, "%s", pIx->zName));
#ifdef SQLITE_ENABLE_COLUMN_USED_MASK
 {  u64 colUsed = 0;  int ii, jj;  for(ii=0; ii<pIx->nColumn; ii++){  jj = pIx->aiColumn[ii];  if( jj<0 ) continue;  if( jj>63 ) jj = 63;  if( (pTabItem->colUsed & MASKBIT(jj))==0 ) continue;  colUsed |= ((u64)1)<<(ii<63 ? ii : 63);  }  sqlite3VdbeAddOp4Dup8(v, OP_ColumnsUsed, iIndexCur, 0, 0,  (u8*)&colUsed, P4_INT64);  }
#endif
 }  }  if( iDb>=0 ) sqlite3CodeVerifySchema(pParse, iDb);  }  pWInfo->iTop = sqlite3VdbeCurrentAddr(v);  if( db->mallocFailed ) goto whereBeginError;  for(ii=0; ii<nTabList; ii++){  int addrExplain;  int wsFlags;  if( pParse->nErr ) goto whereBeginError;  pLevel = &pWInfo->a[ii];  wsFlags = pLevel->pWLoop->wsFlags;
#ifndef SQLITE_OMIT_AUTOMATIC_INDEX
 if( (pLevel->pWLoop->wsFlags & WHERE_AUTO_INDEX)!=0 ){  constructAutomaticIndex(pParse, &pWInfo->sWC,  &pTabList->a[pLevel->iFrom], notReady, pLevel);  if( db->mallocFailed ) goto whereBeginError;  }
#endif
 addrExplain = sqlite3WhereExplainOneScan(  pParse, pTabList, pLevel, wctrlFlags  );  pLevel->addrBody = sqlite3VdbeCurrentAddr(v);  notReady = sqlite3WhereCodeOneLoopStart(pParse,v,pWInfo,ii,pLevel,notReady);  pWInfo->iContinue = pLevel->addrCont;  if( (wsFlags&WHERE_MULTI_OR)==0 && (wctrlFlags&WHERE_OR_SUBCLAUSE)==0 ){  sqlite3WhereAddScanStatus(v, pTabList, pLevel, addrExplain);  }  }  VdbeModuleComment((v, "Begin WHERE-core"));  pWInfo->iEndWhere = sqlite3VdbeCurrentAddr(v);  return pWInfo; whereBeginError:  if( pWInfo ){  testcase( pWInfo->pExprMods!=0 );  whereUndoExprMods(pWInfo);  pParse->nQueryLoop = pWInfo->savedNQueryLoop;  whereInfoFree(db, pWInfo);  }  return 0; }
#ifndef SQLITE_DEBUG
# define OpcodeRewriteTrace(D,K,P)
#else
# define OpcodeRewriteTrace(D,K,P) sqlite3WhereOpcodeRewriteTrace(D,K,P)
 static void sqlite3WhereOpcodeRewriteTrace(  sqlite3 *db,  int pc,  VdbeOp *pOp  ){  if( (db->flags & SQLITE_VdbeAddopTrace)==0 ) return;  sqlite3VdbePrintOp(0, pc, pOp);  }
#endif
SQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){  Parse *pParse = pWInfo->pParse;  Vdbe *v = pParse->pVdbe;  int i;  WhereLevel *pLevel;  WhereLoop *pLoop;  SrcList *pTabList = pWInfo->pTabList;  sqlite3 *db = pParse->db;  int iEnd = sqlite3VdbeCurrentAddr(v);  VdbeModuleComment((v, "End WHERE-core"));  for(i=pWInfo->nLevel-1; i>=0; i--){  int addr;  pLevel = &pWInfo->a[i];  pLoop = pLevel->pWLoop;  if( pLevel->op!=OP_Noop ){
#ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
 int addrSeek = 0;  Index *pIdx;  int n;  if( pWInfo->eDistinct==WHERE_DISTINCT_ORDERED   && i==pWInfo->nLevel-1   && (pLoop->wsFlags & WHERE_INDEXED)!=0   && (pIdx = pLoop->u.btree.pIndex)->hasStat1   && (n = pLoop->u.btree.nDistinctCol)>0   && pIdx->aiRowLogEst[n]>=36  ){  int r1 = pParse->nMem+1;  int j, op;  for(j=0; j<n; j++){  sqlite3VdbeAddOp3(v, OP_Column, pLevel->iIdxCur, j, r1+j);  }  pParse->nMem += n+1;  op = pLevel->op==OP_Prev ? OP_SeekLT : OP_SeekGT;  addrSeek = sqlite3VdbeAddOp4Int(v, op, pLevel->iIdxCur, 0, r1, n);  VdbeCoverageIf(v, op==OP_SeekLT);  VdbeCoverageIf(v, op==OP_SeekGT);  sqlite3VdbeAddOp2(v, OP_Goto, 1, pLevel->p2);  }
#endif
 sqlite3VdbeResolveLabel(v, pLevel->addrCont);  sqlite3VdbeAddOp3(v, pLevel->op, pLevel->p1, pLevel->p2, pLevel->p3);  sqlite3VdbeChangeP5(v, pLevel->p5);  VdbeCoverage(v);  VdbeCoverageIf(v, pLevel->op==OP_Next);  VdbeCoverageIf(v, pLevel->op==OP_Prev);  VdbeCoverageIf(v, pLevel->op==OP_VNext);  if( pLevel->regBignull ){  sqlite3VdbeResolveLabel(v, pLevel->addrBignull);  sqlite3VdbeAddOp2(v, OP_DecrJumpZero, pLevel->regBignull, pLevel->p2-1);  VdbeCoverage(v);  }
#ifndef SQLITE_DISABLE_SKIPAHEAD_DISTINCT
 if( addrSeek ) sqlite3VdbeJumpHere(v, addrSeek);
#endif
 }else{  sqlite3VdbeResolveLabel(v, pLevel->addrCont);  }  if( (pLoop->wsFlags & WHERE_IN_ABLE)!=0 && pLevel->u.in.nIn>0 ){  struct InLoop *pIn;  int j;  sqlite3VdbeResolveLabel(v, pLevel->addrNxt);  for(j=pLevel->u.in.nIn, pIn=&pLevel->u.in.aInLoop[j-1]; j>0; j--, pIn--){  assert( sqlite3VdbeGetOp(v, pIn->addrInTop+1)->opcode==OP_IsNull   || pParse->db->mallocFailed );  sqlite3VdbeJumpHere(v, pIn->addrInTop+1);  if( pIn->eEndLoopOp!=OP_Noop ){  if( pIn->nPrefix ){  int bEarlyOut =  (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0   && (pLoop->wsFlags & WHERE_IN_EARLYOUT)!=0;  if( pLevel->iLeftJoin ){  sqlite3VdbeAddOp2(v, OP_IfNotOpen, pIn->iCur,  sqlite3VdbeCurrentAddr(v) + 2 + bEarlyOut);  VdbeCoverage(v);  }  if( bEarlyOut ){  sqlite3VdbeAddOp4Int(v, OP_IfNoHope, pLevel->iIdxCur,  sqlite3VdbeCurrentAddr(v)+2,  pIn->iBase, pIn->nPrefix);  VdbeCoverage(v);  sqlite3VdbeJumpHere(v, pIn->addrInTop+1);  }  }  sqlite3VdbeAddOp2(v, pIn->eEndLoopOp, pIn->iCur, pIn->addrInTop);  VdbeCoverage(v);  VdbeCoverageIf(v, pIn->eEndLoopOp==OP_Prev);  VdbeCoverageIf(v, pIn->eEndLoopOp==OP_Next);  }  sqlite3VdbeJumpHere(v, pIn->addrInTop-1);  }  }  sqlite3VdbeResolveLabel(v, pLevel->addrBrk);  if( pLevel->addrSkip ){  sqlite3VdbeGoto(v, pLevel->addrSkip);  VdbeComment((v, "next skip-scan on %s", pLoop->u.btree.pIndex->zName));  sqlite3VdbeJumpHere(v, pLevel->addrSkip);  sqlite3VdbeJumpHere(v, pLevel->addrSkip-2);  }
#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS
 if( pLevel->addrLikeRep ){  sqlite3VdbeAddOp2(v, OP_DecrJumpZero, (int)(pLevel->iLikeRepCntr>>1),  pLevel->addrLikeRep);  VdbeCoverage(v);  }
#endif
 if( pLevel->iLeftJoin ){  int ws = pLoop->wsFlags;  addr = sqlite3VdbeAddOp1(v, OP_IfPos, pLevel->iLeftJoin); VdbeCoverage(v);  assert( (ws & WHERE_IDX_ONLY)==0 || (ws & WHERE_INDEXED)!=0 );  if( (ws & WHERE_IDX_ONLY)==0 ){  assert( pLevel->iTabCur==pTabList->a[pLevel->iFrom].iCursor );  sqlite3VdbeAddOp1(v, OP_NullRow, pLevel->iTabCur);  }  if( (ws & WHERE_INDEXED)   || ((ws & WHERE_MULTI_OR) && pLevel->u.pCoveringIdx)  ){  if( ws & WHERE_MULTI_OR ){  Index *pIx = pLevel->u.pCoveringIdx;  int iDb = sqlite3SchemaToIndex(db, pIx->pSchema);  sqlite3VdbeAddOp3(v, OP_ReopenIdx, pLevel->iIdxCur, pIx->tnum, iDb);  sqlite3VdbeSetP4KeyInfo(pParse, pIx);  }  sqlite3VdbeAddOp1(v, OP_NullRow, pLevel->iIdxCur);  }  if( pLevel->op==OP_Return ){  sqlite3VdbeAddOp2(v, OP_Gosub, pLevel->p1, pLevel->addrFirst);  }else{  sqlite3VdbeGoto(v, pLevel->addrFirst);  }  sqlite3VdbeJumpHere(v, addr);  }  VdbeModuleComment((v, "End WHERE-loop%d: %s", i,   pWInfo->pTabList->a[pLevel->iFrom].pTab->zName));  }  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);  assert( pWInfo->nLevel<=pTabList->nSrc );  for(i=0, pLevel=pWInfo->a; i<pWInfo->nLevel; i++, pLevel++){  int k, last;  VdbeOp *pOp, *pLastOp;  Index *pIdx = 0;  SrcItem *pTabItem = &pTabList->a[pLevel->iFrom];  Table *pTab = pTabItem->pTab;  assert( pTab!=0 );  pLoop = pLevel->pWLoop;  if( pTabItem->fg.viaCoroutine ){  testcase( pParse->db->mallocFailed );  translateColumnToCopy(pParse, pLevel->addrBody, pLevel->iTabCur,  pTabItem->regResult, 0);  continue;  }
#ifdef SQLITE_ENABLE_EARLY_CURSOR_CLOSE
 if( (pTab->tabFlags & TF_Ephemeral)==0   && !IsView(pTab)   && (pWInfo->wctrlFlags & WHERE_OR_SUBCLAUSE)==0  ){  int ws = pLoop->wsFlags;  if( pWInfo->eOnePass==ONEPASS_OFF && (ws & WHERE_IDX_ONLY)==0 ){  sqlite3VdbeAddOp1(v, OP_Close, pTabItem->iCursor);  }  if( (ws & WHERE_INDEXED)!=0   && (ws & (WHERE_IPK|WHERE_AUTO_INDEX))==0   && pLevel->iIdxCur!=pWInfo->aiCurOnePass[1]  ){  sqlite3VdbeAddOp1(v, OP_Close, pLevel->iIdxCur);  }  }
#endif
 if( pLoop->wsFlags & (WHERE_INDEXED|WHERE_IDX_ONLY) ){  pIdx = pLoop->u.btree.pIndex;  }else if( pLoop->wsFlags & WHERE_MULTI_OR ){  pIdx = pLevel->u.pCoveringIdx;  }  if( pIdx   && !db->mallocFailed  ){  if( pWInfo->eOnePass==ONEPASS_OFF || !HasRowid(pIdx->pTable) ){  last = iEnd;  }else{  last = pWInfo->iEndWhere;  }  k = pLevel->addrBody + 1;
#ifdef SQLITE_DEBUG
 if( db->flags & SQLITE_VdbeAddopTrace ){  printf("TRANSLATE opcodes in range %d..%d\n", k, last-1);  }  pOp = sqlite3VdbeGetOp(v, k - 1);  assert( pOp->opcode!=OP_Column || pOp->p1!=pLevel->iTabCur );  assert( pOp->opcode!=OP_Rowid || pOp->p1!=pLevel->iTabCur );  assert( pOp->opcode!=OP_IfNullRow || pOp->p1!=pLevel->iTabCur );
#endif
 pOp = sqlite3VdbeGetOp(v, k);  pLastOp = pOp + (last - k);  assert( pOp<=pLastOp );  do{  if( pOp->p1!=pLevel->iTabCur ){  }else if( pOp->opcode==OP_Column
#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC
  || pOp->opcode==OP_Offset
#endif
 ){  int x = pOp->p2;  assert( pIdx->pTable==pTab );  if( !HasRowid(pTab) ){  Index *pPk = sqlite3PrimaryKeyIndex(pTab);  x = pPk->aiColumn[x];  assert( x>=0 );  }else{  testcase( x!=sqlite3StorageColumnToTable(pTab,x) );  x = sqlite3StorageColumnToTable(pTab,x);  }  x = sqlite3TableColumnToIndex(pIdx, x);  if( x>=0 ){  pOp->p2 = x;  pOp->p1 = pLevel->iIdxCur;  OpcodeRewriteTrace(db, k, pOp);  }  assert( (pLoop->wsFlags & WHERE_IDX_ONLY)==0 || x>=0  || pWInfo->eOnePass );  }else if( pOp->opcode==OP_Rowid ){  pOp->p1 = pLevel->iIdxCur;  pOp->opcode = OP_IdxRowid;  OpcodeRewriteTrace(db, k, pOp);  }else if( pOp->opcode==OP_IfNullRow ){  pOp->p1 = pLevel->iIdxCur;  OpcodeRewriteTrace(db, k, pOp);  }
#ifdef SQLITE_DEBUG
 k++;
#endif
 }while( (++pOp)<pLastOp );
#ifdef SQLITE_DEBUG
 if( db->flags & SQLITE_VdbeAddopTrace ) printf("TRANSLATE complete\n");
#endif
 }  }  if( pWInfo->pExprMods ) whereUndoExprMods(pWInfo);  pParse->nQueryLoop = pWInfo->savedNQueryLoop;  whereInfoFree(db, pWInfo);  return; }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void row_numberStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ) (*p)++;  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg); } static void row_numberValueFunc(sqlite3_context *pCtx){  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));  sqlite3_result_int64(pCtx, (p ? *p : 0)); } struct CallCount {  i64 nValue;  i64 nStep;  i64 nTotal; }; static void dense_rankStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct CallCount *p;  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ) p->nStep = 1;  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg); } static void dense_rankValueFunc(sqlite3_context *pCtx){  struct CallCount *p;  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  if( p->nStep ){  p->nValue++;  p->nStep = 0;  }  sqlite3_result_int64(pCtx, p->nValue);  } } struct NthValueCtx {  i64 nStep;  sqlite3_value *pValue; }; static void nth_valueStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct NthValueCtx *p;  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  i64 iVal;  switch( sqlite3_value_numeric_type(apArg[1]) ){  case SQLITE_INTEGER:  iVal = sqlite3_value_int64(apArg[1]);  break;  case SQLITE_FLOAT: {  double fVal = sqlite3_value_double(apArg[1]);  if( ((i64)fVal)!=fVal ) goto error_out;  iVal = (i64)fVal;  break;  }  default:  goto error_out;  }  if( iVal<=0 ) goto error_out;  p->nStep++;  if( iVal==p->nStep ){  p->pValue = sqlite3_value_dup(apArg[0]);  if( !p->pValue ){  sqlite3_result_error_nomem(pCtx);  }  }  }  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg);  return;  error_out:  sqlite3_result_error(  pCtx, "second argument to nth_value must be a positive integer", -1  ); } static void nth_valueFinalizeFunc(sqlite3_context *pCtx){  struct NthValueCtx *p;  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);  if( p && p->pValue ){  sqlite3_result_value(pCtx, p->pValue);  sqlite3_value_free(p->pValue);  p->pValue = 0;  } }
#define nth_valueInvFunc noopStepFunc
#define nth_valueValueFunc noopValueFunc
static void first_valueStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct NthValueCtx *p;  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p && p->pValue==0 ){  p->pValue = sqlite3_value_dup(apArg[0]);  if( !p->pValue ){  sqlite3_result_error_nomem(pCtx);  }  }  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg); } static void first_valueFinalizeFunc(sqlite3_context *pCtx){  struct NthValueCtx *p;  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p && p->pValue ){  sqlite3_result_value(pCtx, p->pValue);  sqlite3_value_free(p->pValue);  p->pValue = 0;  } }
#define first_valueInvFunc noopStepFunc
#define first_valueValueFunc noopValueFunc
static void rankStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct CallCount *p;  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  p->nStep++;  if( p->nValue==0 ){  p->nValue = p->nStep;  }  }  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg); } static void rankValueFunc(sqlite3_context *pCtx){  struct CallCount *p;  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  sqlite3_result_int64(pCtx, p->nValue);  p->nValue = 0;  } } static void percent_rankStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct CallCount *p;  UNUSED_PARAMETER(nArg); assert( nArg==0 );  UNUSED_PARAMETER(apArg);  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  p->nTotal++;  } } static void percent_rankInvFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct CallCount *p;  UNUSED_PARAMETER(nArg); assert( nArg==0 );  UNUSED_PARAMETER(apArg);  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  p->nStep++; } static void percent_rankValueFunc(sqlite3_context *pCtx){  struct CallCount *p;  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  p->nValue = p->nStep;  if( p->nTotal>1 ){  double r = (double)p->nValue / (double)(p->nTotal-1);  sqlite3_result_double(pCtx, r);  }else{  sqlite3_result_double(pCtx, 0.0);  }  } }
#define percent_rankFinalizeFunc percent_rankValueFunc
static void cume_distStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct CallCount *p;  UNUSED_PARAMETER(nArg); assert( nArg==0 );  UNUSED_PARAMETER(apArg);  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  p->nTotal++;  } } static void cume_distInvFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct CallCount *p;  UNUSED_PARAMETER(nArg); assert( nArg==0 );  UNUSED_PARAMETER(apArg);  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));  p->nStep++; } static void cume_distValueFunc(sqlite3_context *pCtx){  struct CallCount *p;  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);  if( p ){  double r = (double)(p->nStep) / (double)(p->nTotal);  sqlite3_result_double(pCtx, r);  } }
#define cume_distFinalizeFunc cume_distValueFunc
struct NtileCtx {  i64 nTotal;  i64 nParam;  i64 iRow; }; static void ntileStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct NtileCtx *p;  assert( nArg==1 ); UNUSED_PARAMETER(nArg);  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  if( p->nTotal==0 ){  p->nParam = sqlite3_value_int64(apArg[0]);  if( p->nParam<=0 ){  sqlite3_result_error(  pCtx, "argument of ntile must be a positive integer", -1  );  }  }  p->nTotal++;  } } static void ntileInvFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct NtileCtx *p;  assert( nArg==1 ); UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg);  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  p->iRow++; } static void ntileValueFunc(sqlite3_context *pCtx){  struct NtileCtx *p;  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p && p->nParam>0 ){  int nSize = (p->nTotal / p->nParam);  if( nSize==0 ){  sqlite3_result_int64(pCtx, p->iRow+1);  }else{  i64 nLarge = p->nTotal - p->nParam*nSize;  i64 iSmall = nLarge*(nSize+1);  i64 iRow = p->iRow;  assert( (nLarge*(nSize+1) + (p->nParam-nLarge)*nSize)==p->nTotal );  if( iRow<iSmall ){  sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));  }else{  sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);  }  }  } }
#define ntileFinalizeFunc ntileValueFunc
struct LastValueCtx {  sqlite3_value *pVal;  int nVal; }; static void last_valueStepFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct LastValueCtx *p;  UNUSED_PARAMETER(nArg);  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p ){  sqlite3_value_free(p->pVal);  p->pVal = sqlite3_value_dup(apArg[0]);  if( p->pVal==0 ){  sqlite3_result_error_nomem(pCtx);  }else{  p->nVal++;  }  } } static void last_valueInvFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  struct LastValueCtx *p;  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(apArg);  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( ALWAYS(p) ){  p->nVal--;  if( p->nVal==0 ){  sqlite3_value_free(p->pVal);  p->pVal = 0;  }  } } static void last_valueValueFunc(sqlite3_context *pCtx){  struct LastValueCtx *p;  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);  if( p && p->pVal ){  sqlite3_result_value(pCtx, p->pVal);  } } static void last_valueFinalizeFunc(sqlite3_context *pCtx){  struct LastValueCtx *p;  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));  if( p && p->pVal ){  sqlite3_result_value(pCtx, p->pVal);  sqlite3_value_free(p->pVal);  p->pVal = 0;  } } static const char row_numberName[] =  "row_number"; static const char dense_rankName[] =  "dense_rank"; static const char rankName[] =  "rank"; static const char percent_rankName[] = "percent_rank"; static const char cume_distName[] = "cume_dist"; static const char ntileName[] = "ntile"; static const char last_valueName[] =  "last_value"; static const char nth_valueName[] = "nth_value"; static const char first_valueName[] = "first_value"; static const char leadName[] =  "lead"; static const char lagName[] = "lag"; static void noopStepFunc(  sqlite3_context *p,  int n,  sqlite3_value **a ){  UNUSED_PARAMETER(p);  UNUSED_PARAMETER(n);  UNUSED_PARAMETER(a);  assert(0); } static void noopValueFunc(sqlite3_context *p){ UNUSED_PARAMETER(p); }
#define WINDOWFUNCALL(name,nArg,extra) {   nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  name ## StepFunc, name ## FinalizeFunc, name ## ValueFunc,  name ## InvFunc, name ## Name, {0}  }

#define WINDOWFUNCNOOP(name,nArg,extra) {  nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  noopStepFunc, noopValueFunc, noopValueFunc,  noopStepFunc, name ## Name, {0} }

#define WINDOWFUNCX(name,nArg,extra) {   nArg, (SQLITE_FUNC_BUILTIN|SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0,  name ## StepFunc, name ## ValueFunc, name ## ValueFunc,  noopStepFunc, name ## Name, {0} }

SQLITE_PRIVATE void sqlite3WindowFunctions(void){  static FuncDef aWindowFuncs[] = {  WINDOWFUNCX(row_number, 0, 0),  WINDOWFUNCX(dense_rank, 0, 0),  WINDOWFUNCX(rank, 0, 0),  WINDOWFUNCALL(percent_rank, 0, 0),  WINDOWFUNCALL(cume_dist, 0, 0),  WINDOWFUNCALL(ntile, 1, 0),  WINDOWFUNCALL(last_value, 1, 0),  WINDOWFUNCALL(nth_value, 2, 0),  WINDOWFUNCALL(first_value, 1, 0),  WINDOWFUNCNOOP(lead, 1, 0),  WINDOWFUNCNOOP(lead, 2, 0),  WINDOWFUNCNOOP(lead, 3, 0),  WINDOWFUNCNOOP(lag, 1, 0),  WINDOWFUNCNOOP(lag, 2, 0),  WINDOWFUNCNOOP(lag, 3, 0),  };  sqlite3InsertBuiltinFuncs(aWindowFuncs, ArraySize(aWindowFuncs)); } static Window *windowFind(Parse *pParse, Window *pList, const char *zName){  Window *p;  for(p=pList; p; p=p->pNextWin){  if( sqlite3StrICmp(p->zName, zName)==0 ) break;  }  if( p==0 ){  sqlite3ErrorMsg(pParse, "no such window: %s", zName);  }  return p; } SQLITE_PRIVATE void sqlite3WindowUpdate(  Parse *pParse,  Window *pList,  Window *pWin,  FuncDef *pFunc ){  if( pWin->zName && pWin->eFrmType==0 ){  Window *p = windowFind(pParse, pList, pWin->zName);  if( p==0 ) return;  pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);  pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);  pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);  pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);  pWin->eStart = p->eStart;  pWin->eEnd = p->eEnd;  pWin->eFrmType = p->eFrmType;  pWin->eExclude = p->eExclude;  }else{  sqlite3WindowChain(pParse, pWin, pList);  }  if( (pWin->eFrmType==TK_RANGE)   && (pWin->pStart || pWin->pEnd)   && (pWin->pOrderBy==0 || pWin->pOrderBy->nExpr!=1)  ){  sqlite3ErrorMsg(pParse,  "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression"  );  }else  if( pFunc->funcFlags & SQLITE_FUNC_WINDOW ){  sqlite3 *db = pParse->db;  if( pWin->pFilter ){  sqlite3ErrorMsg(pParse,  "FILTER clause may only be used with aggregate window functions"  );  }else{  struct WindowUpdate {  const char *zFunc;  int eFrmType;  int eStart;  int eEnd;  } aUp[] = {  { row_numberName, TK_ROWS, TK_UNBOUNDED, TK_CURRENT },  { dense_rankName, TK_RANGE, TK_UNBOUNDED, TK_CURRENT },  { rankName, TK_RANGE, TK_UNBOUNDED, TK_CURRENT },  { percent_rankName, TK_GROUPS, TK_CURRENT, TK_UNBOUNDED },  { cume_distName, TK_GROUPS, TK_FOLLOWING, TK_UNBOUNDED },  { ntileName, TK_ROWS, TK_CURRENT, TK_UNBOUNDED },  { leadName, TK_ROWS, TK_UNBOUNDED, TK_UNBOUNDED },  { lagName, TK_ROWS, TK_UNBOUNDED, TK_CURRENT },  };  int i;  for(i=0; i<ArraySize(aUp); i++){  if( pFunc->zName==aUp[i].zFunc ){  sqlite3ExprDelete(db, pWin->pStart);  sqlite3ExprDelete(db, pWin->pEnd);  pWin->pEnd = pWin->pStart = 0;  pWin->eFrmType = aUp[i].eFrmType;  pWin->eStart = aUp[i].eStart;  pWin->eEnd = aUp[i].eEnd;  pWin->eExclude = 0;  if( pWin->eStart==TK_FOLLOWING ){  pWin->pStart = sqlite3Expr(db, TK_INTEGER, "1");  }  break;  }  }  }  }  pWin->pFunc = pFunc; } typedef struct WindowRewrite WindowRewrite; struct WindowRewrite {  Window *pWin;  SrcList *pSrc;  ExprList *pSub;  Table *pTab;  Select *pSubSelect; }; static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){  struct WindowRewrite *p = pWalker->u.pRewrite;  Parse *pParse = pWalker->pParse;  assert( p!=0 );  assert( p->pWin!=0 );  if( p->pSubSelect ){  if( pExpr->op!=TK_COLUMN ){  return WRC_Continue;  }else{  int nSrc = p->pSrc->nSrc;  int i;  for(i=0; i<nSrc; i++){  if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;  }  if( i==nSrc ) return WRC_Continue;  }  }  switch( pExpr->op ){  case TK_FUNCTION:  if( !ExprHasProperty(pExpr, EP_WinFunc) ){  break;  }else{  Window *pWin;  for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){  if( pExpr->y.pWin==pWin ){  assert( pWin->pOwner==pExpr );  return WRC_Prune;  }  }  }  deliberate_fall_through  case TK_AGG_FUNCTION:  case TK_COLUMN: {  int iCol = -1;  if( pParse->db->mallocFailed ) return WRC_Abort;  if( p->pSub ){  int i;  for(i=0; i<p->pSub->nExpr; i++){  if( 0==sqlite3ExprCompare(0, p->pSub->a[i].pExpr, pExpr, -1) ){  iCol = i;  break;  }  }  }  if( iCol<0 ){  Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);  if( pDup && pDup->op==TK_AGG_FUNCTION ) pDup->op = TK_FUNCTION;  p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);  }  if( p->pSub ){  int f = pExpr->flags & EP_Collate;  assert( ExprHasProperty(pExpr, EP_Static)==0 );  ExprSetProperty(pExpr, EP_Static);  sqlite3ExprDelete(pParse->db, pExpr);  ExprClearProperty(pExpr, EP_Static);  memset(pExpr, 0, sizeof(Expr));  pExpr->op = TK_COLUMN;  pExpr->iColumn = (iCol<0 ? p->pSub->nExpr-1: iCol);  pExpr->iTable = p->pWin->iEphCsr;  pExpr->y.pTab = p->pTab;  pExpr->flags = f;  }  if( pParse->db->mallocFailed ) return WRC_Abort;  break;  }  default:  break;  }  return WRC_Continue; } static int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){  struct WindowRewrite *p = pWalker->u.pRewrite;  Select *pSave = p->pSubSelect;  if( pSave==pSelect ){  return WRC_Continue;  }else{  p->pSubSelect = pSelect;  sqlite3WalkSelect(pWalker, pSelect);  p->pSubSelect = pSave;  }  return WRC_Prune; } static void selectWindowRewriteEList(  Parse *pParse,  Window *pWin,  SrcList *pSrc,  ExprList *pEList,  Table *pTab,  ExprList **ppSub ){  Walker sWalker;  WindowRewrite sRewrite;  assert( pWin!=0 );  memset(&sWalker, 0, sizeof(Walker));  memset(&sRewrite, 0, sizeof(WindowRewrite));  sRewrite.pSub = *ppSub;  sRewrite.pWin = pWin;  sRewrite.pSrc = pSrc;  sRewrite.pTab = pTab;  sWalker.pParse = pParse;  sWalker.xExprCallback = selectWindowRewriteExprCb;  sWalker.xSelectCallback = selectWindowRewriteSelectCb;  sWalker.u.pRewrite = &sRewrite;  (void)sqlite3WalkExprList(&sWalker, pEList);  *ppSub = sRewrite.pSub; } static ExprList *exprListAppendList(  Parse *pParse,  ExprList *pList,  ExprList *pAppend,  int bIntToNull ){  if( pAppend ){  int i;  int nInit = pList ? pList->nExpr : 0;  for(i=0; i<pAppend->nExpr; i++){  sqlite3 *db = pParse->db;  Expr *pDup = sqlite3ExprDup(db, pAppend->a[i].pExpr, 0);  assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );  if( db->mallocFailed ){  sqlite3ExprDelete(db, pDup);  break;  }  if( bIntToNull ){  int iDummy;  Expr *pSub;  pSub = sqlite3ExprSkipCollateAndLikely(pDup);  if( sqlite3ExprIsInteger(pSub, &iDummy) ){  pSub->op = TK_NULL;  pSub->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);  pSub->u.zToken = 0;  }  }  pList = sqlite3ExprListAppend(pParse, pList, pDup);  if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;  }  }  return pList; } static int sqlite3WindowExtraAggFuncDepth(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_AGG_FUNCTION   && pExpr->op2>=pWalker->walkerDepth  ){  pExpr->op2++;  }  return WRC_Continue; } static int disallowAggregatesInOrderByCb(Walker *pWalker, Expr *pExpr){  if( pExpr->op==TK_AGG_FUNCTION && pExpr->pAggInfo==0 ){  assert( !ExprHasProperty(pExpr, EP_IntValue) );   sqlite3ErrorMsg(pWalker->pParse,   "misuse of aggregate: %s()", pExpr->u.zToken);  }  return WRC_Continue; } SQLITE_PRIVATE int sqlite3WindowRewrite(Parse *pParse, Select *p){  int rc = SQLITE_OK;  if( p->pWin && p->pPrior==0 && ALWAYS((p->selFlags & SF_WinRewrite)==0) ){  Vdbe *v = sqlite3GetVdbe(pParse);  sqlite3 *db = pParse->db;  Select *pSub = 0;  SrcList *pSrc = p->pSrc;  Expr *pWhere = p->pWhere;  ExprList *pGroupBy = p->pGroupBy;  Expr *pHaving = p->pHaving;  ExprList *pSort = 0;  ExprList *pSublist = 0;  Window *pMWin = p->pWin;  Window *pWin;  Table *pTab;  Walker w;  u32 selFlags = p->selFlags;  pTab = sqlite3DbMallocZero(db, sizeof(Table));  if( pTab==0 ){  return sqlite3ErrorToParser(db, SQLITE_NOMEM);  }  sqlite3AggInfoPersistWalkerInit(&w, pParse);  sqlite3WalkSelect(&w, p);  if( (p->selFlags & SF_Aggregate)==0 ){  w.xExprCallback = disallowAggregatesInOrderByCb;  w.xSelectCallback = 0;  sqlite3WalkExprList(&w, p->pOrderBy);  }  p->pSrc = 0;  p->pWhere = 0;  p->pGroupBy = 0;  p->pHaving = 0;  p->selFlags &= ~SF_Aggregate;  p->selFlags |= SF_WinRewrite;  pSort = exprListAppendList(pParse, 0, pMWin->pPartition, 1);  pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);  if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){  int nSave = pSort->nExpr;  pSort->nExpr = p->pOrderBy->nExpr;  if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){  sqlite3ExprListDelete(db, p->pOrderBy);  p->pOrderBy = 0;  }  pSort->nExpr = nSave;  }  pMWin->iEphCsr = pParse->nTab++;  pParse->nTab += 3;  selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);  selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);  pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);  pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);  pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  ExprList *pArgs;  assert( ExprUseXList(pWin->pOwner) );  pArgs = pWin->pOwner->x.pList;  if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){  selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);  pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);  pWin->bExprArgs = 1;  }else{  pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);  pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);  }  if( pWin->pFilter ){  Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);  pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);  }  pWin->regAccum = ++pParse->nMem;  pWin->regResult = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);  }  if( pSublist==0 ){  pSublist = sqlite3ExprListAppend(pParse, 0,  sqlite3Expr(db, TK_INTEGER, "0")  );  }  pSub = sqlite3SelectNew(  pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0  );  SELECTTRACE(1,pParse,pSub,   ("New window-function subquery in FROM clause of (%u/%p)\n",   p->selId, p));  p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);  assert( pSub!=0 || p->pSrc==0 );  if( p->pSrc ){  Table *pTab2;  p->pSrc->a[0].pSelect = pSub;  sqlite3SrcListAssignCursors(pParse, p->pSrc);  pSub->selFlags |= SF_Expanded|SF_OrderByReqd;  pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE);  pSub->selFlags |= (selFlags & SF_Aggregate);  if( pTab2==0 ){  rc = SQLITE_NOMEM;  }else{  memcpy(pTab, pTab2, sizeof(Table));  pTab->tabFlags |= TF_Ephemeral;  p->pSrc->a[0].pTab = pTab;  pTab = pTab2;  memset(&w, 0, sizeof(w));  w.xExprCallback = sqlite3WindowExtraAggFuncDepth;  w.xSelectCallback = sqlite3WalkerDepthIncrease;  w.xSelectCallback2 = sqlite3WalkerDepthDecrease;  sqlite3WalkSelect(&w, pSub);  }  }else{  sqlite3SelectDelete(db, pSub);  }  if( db->mallocFailed ) rc = SQLITE_NOMEM;  sqlite3ParserAddCleanup(pParse, sqlite3DbFree, pTab);  }  if( rc ){  if( pParse->nErr==0 ){  assert( pParse->db->mallocFailed );  sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);  }  }  return rc; } SQLITE_PRIVATE void sqlite3WindowUnlinkFromSelect(Window *p){  if( p->ppThis ){  *p->ppThis = p->pNextWin;  if( p->pNextWin ) p->pNextWin->ppThis = p->ppThis;  p->ppThis = 0;  } } SQLITE_PRIVATE void sqlite3WindowDelete(sqlite3 *db, Window *p){  if( p ){  sqlite3WindowUnlinkFromSelect(p);  sqlite3ExprDelete(db, p->pFilter);  sqlite3ExprListDelete(db, p->pPartition);  sqlite3ExprListDelete(db, p->pOrderBy);  sqlite3ExprDelete(db, p->pEnd);  sqlite3ExprDelete(db, p->pStart);  sqlite3DbFree(db, p->zName);  sqlite3DbFree(db, p->zBase);  sqlite3DbFree(db, p);  } } SQLITE_PRIVATE void sqlite3WindowListDelete(sqlite3 *db, Window *p){  while( p ){  Window *pNext = p->pNextWin;  sqlite3WindowDelete(db, p);  p = pNext;  } } static Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){  if( 0==sqlite3ExprIsConstant(pExpr) ){  if( IN_RENAME_OBJECT ) sqlite3RenameExprUnmap(pParse, pExpr);  sqlite3ExprDelete(pParse->db, pExpr);  pExpr = sqlite3ExprAlloc(pParse->db, TK_NULL, 0, 0);  }  return pExpr; } SQLITE_PRIVATE Window *sqlite3WindowAlloc(  Parse *pParse,  int eType,  int eStart,  Expr *pStart,  int eEnd,  Expr *pEnd,  u8 eExclude ){  Window *pWin = 0;  int bImplicitFrame = 0;  assert( eType==0 || eType==TK_RANGE || eType==TK_ROWS || eType==TK_GROUPS );  assert( eStart==TK_CURRENT || eStart==TK_PRECEDING   || eStart==TK_UNBOUNDED || eStart==TK_FOLLOWING );  assert( eEnd==TK_CURRENT || eEnd==TK_FOLLOWING   || eEnd==TK_UNBOUNDED || eEnd==TK_PRECEDING );  assert( (eStart==TK_PRECEDING || eStart==TK_FOLLOWING)==(pStart!=0) );  assert( (eEnd==TK_FOLLOWING || eEnd==TK_PRECEDING)==(pEnd!=0) );  if( eType==0 ){  bImplicitFrame = 1;  eType = TK_RANGE;  }  if( (eStart==TK_CURRENT && eEnd==TK_PRECEDING)   || (eStart==TK_FOLLOWING && (eEnd==TK_PRECEDING || eEnd==TK_CURRENT))  ){  sqlite3ErrorMsg(pParse, "unsupported frame specification");  goto windowAllocErr;  }  pWin = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));  if( pWin==0 ) goto windowAllocErr;  pWin->eFrmType = eType;  pWin->eStart = eStart;  pWin->eEnd = eEnd;  if( eExclude==0 && OptimizationDisabled(pParse->db, SQLITE_WindowFunc) ){  eExclude = TK_NO;  }  pWin->eExclude = eExclude;  pWin->bImplicitFrame = bImplicitFrame;  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);  return pWin; windowAllocErr:  sqlite3ExprDelete(pParse->db, pEnd);  sqlite3ExprDelete(pParse->db, pStart);  return 0; } SQLITE_PRIVATE Window *sqlite3WindowAssemble(  Parse *pParse,  Window *pWin,  ExprList *pPartition,  ExprList *pOrderBy,  Token *pBase ){  if( pWin ){  pWin->pPartition = pPartition;  pWin->pOrderBy = pOrderBy;  if( pBase ){  pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, pBase->n);  }  }else{  sqlite3ExprListDelete(pParse->db, pPartition);  sqlite3ExprListDelete(pParse->db, pOrderBy);  }  return pWin; } SQLITE_PRIVATE void sqlite3WindowChain(Parse *pParse, Window *pWin, Window *pList){  if( pWin->zBase ){  sqlite3 *db = pParse->db;  Window *pExist = windowFind(pParse, pList, pWin->zBase);  if( pExist ){  const char *zErr = 0;  if( pWin->pPartition ){  zErr = "PARTITION clause";  }else if( pExist->pOrderBy && pWin->pOrderBy ){  zErr = "ORDER BY clause";  }else if( pExist->bImplicitFrame==0 ){  zErr = "frame specification";  }  if( zErr ){  sqlite3ErrorMsg(pParse,  "cannot override %s of window: %s", zErr, pWin->zBase  );  }else{  pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);  if( pExist->pOrderBy ){  assert( pWin->pOrderBy==0 );  pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);  }  sqlite3DbFree(db, pWin->zBase);  pWin->zBase = 0;  }  }  } } SQLITE_PRIVATE void sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){  if( p ){  assert( p->op==TK_FUNCTION );  assert( pWin );  p->y.pWin = pWin;  ExprSetProperty(p, EP_WinFunc);  pWin->pOwner = p;  if( (p->flags & EP_Distinct) && pWin->eFrmType!=TK_FILTER ){  sqlite3ErrorMsg(pParse,  "DISTINCT is not supported for window functions"  );  }  }else{  sqlite3WindowDelete(pParse->db, pWin);  } } SQLITE_PRIVATE void sqlite3WindowLink(Select *pSel, Window *pWin){  if( pSel ){  if( 0==pSel->pWin || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0) ){  pWin->pNextWin = pSel->pWin;  if( pSel->pWin ){  pSel->pWin->ppThis = &pWin->pNextWin;  }  pSel->pWin = pWin;  pWin->ppThis = &pSel->pWin;  }else{  if( sqlite3ExprListCompare(pWin->pPartition, pSel->pWin->pPartition,-1) ){  pSel->selFlags |= SF_MultiPart;  }  }  } } SQLITE_PRIVATE int sqlite3WindowCompare(  const Parse *pParse,  const Window *p1,  const Window *p2,  int bFilter ){  int res;  if( NEVER(p1==0) || NEVER(p2==0) ) return 1;  if( p1->eFrmType!=p2->eFrmType ) return 1;  if( p1->eStart!=p2->eStart ) return 1;  if( p1->eEnd!=p2->eEnd ) return 1;  if( p1->eExclude!=p2->eExclude ) return 1;  if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) return 1;  if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) return 1;  if( (res = sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1)) ){  return res;  }  if( (res = sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1)) ){  return res;  }  if( bFilter ){  if( (res = sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1)) ){  return res;  }  }  return 0; } SQLITE_PRIVATE void sqlite3WindowCodeInit(Parse *pParse, Select *pSelect){  int nEphExpr = pSelect->pSrc->a[0].pSelect->pEList->nExpr;  Window *pMWin = pSelect->pWin;  Window *pWin;  Vdbe *v = sqlite3GetVdbe(pParse);  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, nEphExpr);  sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr);  sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr);  sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr);  if( pMWin->pPartition ){  int nExpr = pMWin->pPartition->nExpr;  pMWin->regPart = pParse->nMem+1;  pParse->nMem += nExpr;  sqlite3VdbeAddOp3(v, OP_Null, 0, pMWin->regPart, pMWin->regPart+nExpr-1);  }  pMWin->regOne = ++pParse->nMem;  sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regOne);  if( pMWin->eExclude ){  pMWin->regStartRowid = ++pParse->nMem;  pMWin->regEndRowid = ++pParse->nMem;  pMWin->csrApp = pParse->nTab++;  sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);  sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);  sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->csrApp, pMWin->iEphCsr);  return;  }  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  FuncDef *p = pWin->pFunc;  if( (p->funcFlags & SQLITE_FUNC_MINMAX) && pWin->eStart!=TK_UNBOUNDED ){  ExprList *pList;  KeyInfo *pKeyInfo;  assert( ExprUseXList(pWin->pOwner) );  pList = pWin->pOwner->x.pList;  pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);  pWin->csrApp = pParse->nTab++;  pWin->regApp = pParse->nMem+1;  pParse->nMem += 3;  if( pKeyInfo && pWin->pFunc->zName[1]=='i' ){  assert( pKeyInfo->aSortFlags[0]==0 );  pKeyInfo->aSortFlags[0] = KEYINFO_ORDER_DESC;  }  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pWin->csrApp, 2);  sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);  sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);  }  else if( p->zName==nth_valueName || p->zName==first_valueName ){  pWin->regApp = pParse->nMem+1;  pWin->csrApp = pParse->nTab++;  pParse->nMem += 2;  sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);  }  else if( p->zName==leadName || p->zName==lagName ){  pWin->csrApp = pParse->nTab++;  sqlite3VdbeAddOp2(v, OP_OpenDup, pWin->csrApp, pMWin->iEphCsr);  }  } }
#define WINDOW_STARTING_INT 0
#define WINDOW_ENDING_INT 1
#define WINDOW_NTH_VALUE_INT 2
#define WINDOW_STARTING_NUM 3
#define WINDOW_ENDING_NUM 4
static void windowCheckValue(Parse *pParse, int reg, int eCond){  static const char *azErr[] = {  "frame starting offset must be a non-negative integer",  "frame ending offset must be a non-negative integer",  "second argument to nth_value must be a positive integer",  "frame starting offset must be a non-negative number",  "frame ending offset must be a non-negative number",  };  static int aOp[] = { OP_Ge, OP_Ge, OP_Gt, OP_Ge, OP_Ge };  Vdbe *v = sqlite3GetVdbe(pParse);  int regZero = sqlite3GetTempReg(pParse);  assert( eCond>=0 && eCond<ArraySize(azErr) );  sqlite3VdbeAddOp2(v, OP_Integer, 0, regZero);  if( eCond>=WINDOW_STARTING_NUM ){  int regString = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);  sqlite3VdbeAddOp3(v, OP_Ge, regString, sqlite3VdbeCurrentAddr(v)+2, reg);  sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC|SQLITE_JUMPIFNULL);  VdbeCoverage(v);  assert( eCond==3 || eCond==4 );  VdbeCoverageIf(v, eCond==3);  VdbeCoverageIf(v, eCond==4);  }else{  sqlite3VdbeAddOp2(v, OP_MustBeInt, reg, sqlite3VdbeCurrentAddr(v)+2);  VdbeCoverage(v);  assert( eCond==0 || eCond==1 || eCond==2 );  VdbeCoverageIf(v, eCond==0);  VdbeCoverageIf(v, eCond==1);  VdbeCoverageIf(v, eCond==2);  }  sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);  sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC);  VdbeCoverageNeverNullIf(v, eCond==0);  VdbeCoverageNeverNullIf(v, eCond==1);  VdbeCoverageNeverNullIf(v, eCond==2);  VdbeCoverageNeverNullIf(v, eCond==3);  VdbeCoverageNeverNullIf(v, eCond==4);  sqlite3MayAbort(pParse);  sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_ERROR, OE_Abort);  sqlite3VdbeAppendP4(v, (void*)azErr[eCond], P4_STATIC);  sqlite3ReleaseTempReg(pParse, regZero); } static int windowArgCount(Window *pWin){  const ExprList *pList;  assert( ExprUseXList(pWin->pOwner) );  pList = pWin->pOwner->x.pList;  return (pList ? pList->nExpr : 0); } typedef struct WindowCodeArg WindowCodeArg; typedef struct WindowCsrAndReg WindowCsrAndReg; struct WindowCsrAndReg {  int csr;  int reg; }; struct WindowCodeArg {  Parse *pParse;  Window *pMWin;  Vdbe *pVdbe;  int addrGosub;  int regGosub;  int regArg;  int eDelete;  int regRowid;  WindowCsrAndReg start;  WindowCsrAndReg current;  WindowCsrAndReg end; }; static void windowReadPeerValues(  WindowCodeArg *p,  int csr,  int reg ){  Window *pMWin = p->pMWin;  ExprList *pOrderBy = pMWin->pOrderBy;  if( pOrderBy ){  Vdbe *v = sqlite3GetVdbe(p->pParse);  ExprList *pPart = pMWin->pPartition;  int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);  int i;  for(i=0; i<pOrderBy->nExpr; i++){  sqlite3VdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);  }  } } static void windowAggStep(  WindowCodeArg *p,  Window *pMWin,  int csr,  int bInverse,  int reg ){  Parse *pParse = p->pParse;  Vdbe *v = sqlite3GetVdbe(pParse);  Window *pWin;  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  FuncDef *pFunc = pWin->pFunc;  int regArg;  int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);  int i;  assert( bInverse==0 || pWin->eStart!=TK_UNBOUNDED );  assert( pWin==pMWin || sqlite3WindowCompare(pParse,pWin,pMWin,0)!=1 );  for(i=0; i<nArg; i++){  if( i!=1 || pFunc->zName!=nth_valueName ){  sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+i, reg+i);  }else{  sqlite3VdbeAddOp3(v, OP_Column, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);  }  }  regArg = reg;  if( pMWin->regStartRowid==0   && (pFunc->funcFlags & SQLITE_FUNC_MINMAX)   && (pWin->eStart!=TK_UNBOUNDED)  ){  int addrIsNull = sqlite3VdbeAddOp1(v, OP_IsNull, regArg);  VdbeCoverage(v);  if( bInverse==0 ){  sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1, 1);  sqlite3VdbeAddOp2(v, OP_SCopy, regArg, pWin->regApp);  sqlite3VdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2, pWin->regApp+2);  sqlite3VdbeAddOp2(v, OP_IdxInsert, pWin->csrApp, pWin->regApp+2);  }else{  sqlite3VdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0, regArg, 1);  VdbeCoverageNeverTaken(v);  sqlite3VdbeAddOp1(v, OP_Delete, pWin->csrApp);  sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);  }  sqlite3VdbeJumpHere(v, addrIsNull);  }else if( pWin->regApp ){  assert( pFunc->zName==nth_valueName   || pFunc->zName==first_valueName  );  assert( bInverse==0 || bInverse==1 );  sqlite3VdbeAddOp2(v, OP_AddImm, pWin->regApp+1-bInverse, 1);  }else if( pFunc->xSFunc!=noopStepFunc ){  int addrIf = 0;  if( pWin->pFilter ){  int regTmp;  assert( ExprUseXList(pWin->pOwner) );  assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );  assert( pWin->bExprArgs || nArg ||pWin->pOwner->x.pList==0 );  regTmp = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);  addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);  VdbeCoverage(v);  sqlite3ReleaseTempReg(pParse, regTmp);  }  if( pWin->bExprArgs ){  int iOp = sqlite3VdbeCurrentAddr(v);  int iEnd;  assert( ExprUseXList(pWin->pOwner) );  nArg = pWin->pOwner->x.pList->nExpr;  regArg = sqlite3GetTempRange(pParse, nArg);  sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);  for(iEnd=sqlite3VdbeCurrentAddr(v); iOp<iEnd; iOp++){  VdbeOp *pOp = sqlite3VdbeGetOp(v, iOp);  if( pOp->opcode==OP_Column && pOp->p1==pWin->iEphCsr ){  pOp->p1 = csr;  }  }  }  if( pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){  CollSeq *pColl;  assert( nArg>0 );  assert( ExprUseXList(pWin->pOwner) );  pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);  sqlite3VdbeAddOp4(v, OP_CollSeq, 0,0,0, (const char*)pColl, P4_COLLSEQ);  }  sqlite3VdbeAddOp3(v, bInverse? OP_AggInverse : OP_AggStep,  bInverse, regArg, pWin->regAccum);  sqlite3VdbeAppendP4(v, pFunc, P4_FUNCDEF);  sqlite3VdbeChangeP5(v, (u8)nArg);  if( pWin->bExprArgs ){  sqlite3ReleaseTempRange(pParse, regArg, nArg);  }  if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);  }  } }
#define WINDOW_RETURN_ROW 1
#define WINDOW_AGGINVERSE 2
#define WINDOW_AGGSTEP 3
static void windowAggFinal(WindowCodeArg *p, int bFin){  Parse *pParse = p->pParse;  Window *pMWin = p->pMWin;  Vdbe *v = sqlite3GetVdbe(pParse);  Window *pWin;  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  if( pMWin->regStartRowid==0   && (pWin->pFunc->funcFlags & SQLITE_FUNC_MINMAX)   && (pWin->eStart!=TK_UNBOUNDED)  ){  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);  sqlite3VdbeAddOp1(v, OP_Last, pWin->csrApp);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_Column, pWin->csrApp, 0, pWin->regResult);  sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);  }else if( pWin->regApp ){  assert( pMWin->regStartRowid==0 );  }else{  int nArg = windowArgCount(pWin);  if( bFin ){  sqlite3VdbeAddOp2(v, OP_AggFinal, pWin->regAccum, nArg);  sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);  sqlite3VdbeAddOp2(v, OP_Copy, pWin->regAccum, pWin->regResult);  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);  }else{  sqlite3VdbeAddOp3(v, OP_AggValue,pWin->regAccum,nArg,pWin->regResult);  sqlite3VdbeAppendP4(v, pWin->pFunc, P4_FUNCDEF);  }  }  } } static void windowFullScan(WindowCodeArg *p){  Window *pWin;  Parse *pParse = p->pParse;  Window *pMWin = p->pMWin;  Vdbe *v = p->pVdbe;  int regCRowid = 0;  int regCPeer = 0;  int regRowid = 0;  int regPeer = 0;  int nPeer;  int lblNext;  int lblBrk;  int addrNext;  int csr;  VdbeModuleComment((v, "windowFullScan begin"));  assert( pMWin!=0 );  csr = pMWin->csrApp;  nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);  lblNext = sqlite3VdbeMakeLabel(pParse);  lblBrk = sqlite3VdbeMakeLabel(pParse);  regCRowid = sqlite3GetTempReg(pParse);  regRowid = sqlite3GetTempReg(pParse);  if( nPeer ){  regCPeer = sqlite3GetTempRange(pParse, nPeer);  regPeer = sqlite3GetTempRange(pParse, nPeer);  }  sqlite3VdbeAddOp2(v, OP_Rowid, pMWin->iEphCsr, regCRowid);  windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);  }  sqlite3VdbeAddOp3(v, OP_SeekGE, csr, lblBrk, pMWin->regStartRowid);  VdbeCoverage(v);  addrNext = sqlite3VdbeCurrentAddr(v);  sqlite3VdbeAddOp2(v, OP_Rowid, csr, regRowid);  sqlite3VdbeAddOp3(v, OP_Gt, pMWin->regEndRowid, lblBrk, regRowid);  VdbeCoverageNeverNull(v);  if( pMWin->eExclude==TK_CURRENT ){  sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, lblNext, regRowid);  VdbeCoverageNeverNull(v);  }else if( pMWin->eExclude!=TK_NO ){  int addr;  int addrEq = 0;  KeyInfo *pKeyInfo = 0;  if( pMWin->pOrderBy ){  pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);  }  if( pMWin->eExclude==TK_TIES ){  addrEq = sqlite3VdbeAddOp3(v, OP_Eq, regCRowid, 0, regRowid);  VdbeCoverageNeverNull(v);  }  if( pKeyInfo ){  windowReadPeerValues(p, csr, regPeer);  sqlite3VdbeAddOp3(v, OP_Compare, regPeer, regCPeer, nPeer);  sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);  addr = sqlite3VdbeCurrentAddr(v)+1;  sqlite3VdbeAddOp3(v, OP_Jump, addr, lblNext, addr);  VdbeCoverageEqNe(v);  }else{  sqlite3VdbeAddOp2(v, OP_Goto, 0, lblNext);  }  if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);  }  windowAggStep(p, pMWin, csr, 0, p->regArg);  sqlite3VdbeResolveLabel(v, lblNext);  sqlite3VdbeAddOp2(v, OP_Next, csr, addrNext);  VdbeCoverage(v);  sqlite3VdbeJumpHere(v, addrNext-1);  sqlite3VdbeJumpHere(v, addrNext+1);  sqlite3ReleaseTempReg(pParse, regRowid);  sqlite3ReleaseTempReg(pParse, regCRowid);  if( nPeer ){  sqlite3ReleaseTempRange(pParse, regPeer, nPeer);  sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);  }  windowAggFinal(p, 1);  VdbeModuleComment((v, "windowFullScan end")); } static void windowReturnOneRow(WindowCodeArg *p){  Window *pMWin = p->pMWin;  Vdbe *v = p->pVdbe;  if( pMWin->regStartRowid ){  windowFullScan(p);  }else{  Parse *pParse = p->pParse;  Window *pWin;  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  FuncDef *pFunc = pWin->pFunc;  assert( ExprUseXList(pWin->pOwner) );  if( pFunc->zName==nth_valueName   || pFunc->zName==first_valueName  ){  int csr = pWin->csrApp;  int lbl = sqlite3VdbeMakeLabel(pParse);  int tmpReg = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);  if( pFunc->zName==nth_valueName ){  sqlite3VdbeAddOp3(v, OP_Column,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);  windowCheckValue(pParse, tmpReg, 2);  }else{  sqlite3VdbeAddOp2(v, OP_Integer, 1, tmpReg);  }  sqlite3VdbeAddOp3(v, OP_Add, tmpReg, pWin->regApp, tmpReg);  sqlite3VdbeAddOp3(v, OP_Gt, pWin->regApp+1, lbl, tmpReg);  VdbeCoverageNeverNull(v);  sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, 0, tmpReg);  VdbeCoverageNeverTaken(v);  sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);  sqlite3VdbeResolveLabel(v, lbl);  sqlite3ReleaseTempReg(pParse, tmpReg);  }  else if( pFunc->zName==leadName || pFunc->zName==lagName ){  int nArg = pWin->pOwner->x.pList->nExpr;  int csr = pWin->csrApp;  int lbl = sqlite3VdbeMakeLabel(pParse);  int tmpReg = sqlite3GetTempReg(pParse);  int iEph = pMWin->iEphCsr;  if( nArg<3 ){  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regResult);  }else{  sqlite3VdbeAddOp3(v, OP_Column, iEph,pWin->iArgCol+2,pWin->regResult);  }  sqlite3VdbeAddOp2(v, OP_Rowid, iEph, tmpReg);  if( nArg<2 ){  int val = (pFunc->zName==leadName ? 1 : -1);  sqlite3VdbeAddOp2(v, OP_AddImm, tmpReg, val);  }else{  int op = (pFunc->zName==leadName ? OP_Add : OP_Subtract);  int tmpReg2 = sqlite3GetTempReg(pParse);  sqlite3VdbeAddOp3(v, OP_Column, iEph, pWin->iArgCol+1, tmpReg2);  sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);  sqlite3ReleaseTempReg(pParse, tmpReg2);  }  sqlite3VdbeAddOp3(v, OP_SeekRowid, csr, lbl, tmpReg);  VdbeCoverage(v);  sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol, pWin->regResult);  sqlite3VdbeResolveLabel(v, lbl);  sqlite3ReleaseTempReg(pParse, tmpReg);  }  }  }  sqlite3VdbeAddOp2(v, OP_Gosub, p->regGosub, p->addrGosub); } static int windowInitAccum(Parse *pParse, Window *pMWin){  Vdbe *v = sqlite3GetVdbe(pParse);  int regArg;  int nArg = 0;  Window *pWin;  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  FuncDef *pFunc = pWin->pFunc;  assert( pWin->regAccum );  sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum);  nArg = MAX(nArg, windowArgCount(pWin));  if( pMWin->regStartRowid==0 ){  if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){  sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp);  sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);  }  if( (pFunc->funcFlags & SQLITE_FUNC_MINMAX) && pWin->csrApp ){  assert( pWin->eStart!=TK_UNBOUNDED );  sqlite3VdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);  sqlite3VdbeAddOp2(v, OP_Integer, 0, pWin->regApp+1);  }  }  }  regArg = pParse->nMem+1;  pParse->nMem += nArg;  return regArg; } static int windowCacheFrame(Window *pMWin){  Window *pWin;  if( pMWin->regStartRowid ) return 1;  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){  FuncDef *pFunc = pWin->pFunc;  if( (pFunc->zName==nth_valueName)   || (pFunc->zName==first_valueName)   || (pFunc->zName==leadName)   || (pFunc->zName==lagName)  ){  return 1;  }  }  return 0; } static void windowIfNewPeer(  Parse *pParse,  ExprList *pOrderBy,  int regNew,  int regOld,  int addr ){  Vdbe *v = sqlite3GetVdbe(pParse);  if( pOrderBy ){  int nVal = pOrderBy->nExpr;  KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);  sqlite3VdbeAddOp3(v, OP_Compare, regOld, regNew, nVal);  sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);  sqlite3VdbeAddOp3(v, OP_Jump,  sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1  );  VdbeCoverageEqNe(v);  sqlite3VdbeAddOp3(v, OP_Copy, regNew, regOld, nVal-1);  }else{  sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);  } } static void windowCodeRangeTest(  WindowCodeArg *p,  int op,  int csr1,  int regVal,  int csr2,  int lbl ){  Parse *pParse = p->pParse;  Vdbe *v = sqlite3GetVdbe(pParse);  ExprList *pOrderBy = p->pMWin->pOrderBy;  int reg1 = sqlite3GetTempReg(pParse);  int reg2 = sqlite3GetTempReg(pParse);  int regString = ++pParse->nMem;  int arith = OP_Add;  int addrGe;  int addrDone = sqlite3VdbeMakeLabel(pParse);  CollSeq *pColl;  windowReadPeerValues(p, csr1, reg1);  windowReadPeerValues(p, csr2, reg2);  assert( op==OP_Ge || op==OP_Gt || op==OP_Le );  assert( pOrderBy && pOrderBy->nExpr==1 );  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_DESC ){  switch( op ){  case OP_Ge: op = OP_Le; break;  case OP_Gt: op = OP_Lt; break;  default: assert( op==OP_Le ); op = OP_Ge; break;  }  arith = OP_Subtract;  }  VdbeModuleComment((v, "CodeRangeTest: if( R%d %s R%d %s R%d ) goto lbl",  reg1, (arith==OP_Add ? "+" : "-"), regVal,  ((op==OP_Ge) ? ">=" : (op==OP_Le) ? "<=" : (op==OP_Gt) ? ">" : "<"), reg2  ));  if( pOrderBy->a[0].sortFlags & KEYINFO_ORDER_BIGNULL ){  int addr = sqlite3VdbeAddOp1(v, OP_NotNull, reg1); VdbeCoverage(v);  switch( op ){  case OP_Ge:  sqlite3VdbeAddOp2(v, OP_Goto, 0, lbl);  break;  case OP_Gt:  sqlite3VdbeAddOp2(v, OP_NotNull, reg2, lbl);  VdbeCoverage(v);  break;  case OP_Le:  sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl);  VdbeCoverage(v);  break;  default: assert( op==OP_Lt ); break;  }  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrDone);  sqlite3VdbeJumpHere(v, addr);  sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); VdbeCoverage(v);  if( op==OP_Gt || op==OP_Ge ){  sqlite3VdbeChangeP2(v, -1, addrDone);  }  }  sqlite3VdbeAddOp4(v, OP_String8, 0, regString, 0, "", P4_STATIC);  addrGe = sqlite3VdbeAddOp3(v, OP_Ge, regString, 0, reg1);  VdbeCoverage(v);  if( (op==OP_Ge && arith==OP_Add) || (op==OP_Le && arith==OP_Subtract) ){  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);  }  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);  sqlite3VdbeJumpHere(v, addrGe);  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); VdbeCoverage(v);  pColl = sqlite3ExprNNCollSeq(pParse, pOrderBy->a[0].pExpr);  sqlite3VdbeAppendP4(v, (void*)pColl, P4_COLLSEQ);  sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);  sqlite3VdbeResolveLabel(v, addrDone);  assert( op==OP_Ge || op==OP_Gt || op==OP_Lt || op==OP_Le );  testcase(op==OP_Ge); VdbeCoverageIf(v, op==OP_Ge);  testcase(op==OP_Lt); VdbeCoverageIf(v, op==OP_Lt);  testcase(op==OP_Le); VdbeCoverageIf(v, op==OP_Le);  testcase(op==OP_Gt); VdbeCoverageIf(v, op==OP_Gt);  sqlite3ReleaseTempReg(pParse, reg1);  sqlite3ReleaseTempReg(pParse, reg2);  VdbeModuleComment((v, "CodeRangeTest: end")); } static int windowCodeOp(  WindowCodeArg *p,  int op,  int regCountdown,  int jumpOnEof ){  int csr, reg;  Parse *pParse = p->pParse;  Window *pMWin = p->pMWin;  int ret = 0;  Vdbe *v = p->pVdbe;  int addrContinue = 0;  int bPeer = (pMWin->eFrmType!=TK_ROWS);  int lblDone = sqlite3VdbeMakeLabel(pParse);  int addrNextRange = 0;  if( op==WINDOW_AGGINVERSE && pMWin->eStart==TK_UNBOUNDED ){  assert( regCountdown==0 && jumpOnEof==0 );  return 0;  }  if( regCountdown>0 ){  if( pMWin->eFrmType==TK_RANGE ){  addrNextRange = sqlite3VdbeCurrentAddr(v);  assert( op==WINDOW_AGGINVERSE || op==WINDOW_AGGSTEP );  if( op==WINDOW_AGGINVERSE ){  if( pMWin->eStart==TK_FOLLOWING ){  windowCodeRangeTest(  p, OP_Le, p->current.csr, regCountdown, p->start.csr, lblDone  );  }else{  windowCodeRangeTest(  p, OP_Ge, p->start.csr, regCountdown, p->current.csr, lblDone  );  }  }else{  windowCodeRangeTest(  p, OP_Gt, p->end.csr, regCountdown, p->current.csr, lblDone  );  }  }else{  sqlite3VdbeAddOp3(v, OP_IfPos, regCountdown, lblDone, 1);  VdbeCoverage(v);  }  }  if( op==WINDOW_RETURN_ROW && pMWin->regStartRowid==0 ){  windowAggFinal(p, 0);  }  addrContinue = sqlite3VdbeCurrentAddr(v);  if( pMWin->eStart==pMWin->eEnd && regCountdown   && pMWin->eFrmType==TK_RANGE  ){  int regRowid1 = sqlite3GetTempReg(pParse);  int regRowid2 = sqlite3GetTempReg(pParse);  if( op==WINDOW_AGGINVERSE ){  sqlite3VdbeAddOp2(v, OP_Rowid, p->start.csr, regRowid1);  sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid2);  sqlite3VdbeAddOp3(v, OP_Ge, regRowid2, lblDone, regRowid1);  VdbeCoverage(v);  }else if( p->regRowid ){  sqlite3VdbeAddOp2(v, OP_Rowid, p->end.csr, regRowid1);  sqlite3VdbeAddOp3(v, OP_Ge, p->regRowid, lblDone, regRowid1);  VdbeCoverageNeverNull(v);  }  sqlite3ReleaseTempReg(pParse, regRowid1);  sqlite3ReleaseTempReg(pParse, regRowid2);  assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING );  }  switch( op ){  case WINDOW_RETURN_ROW:  csr = p->current.csr;  reg = p->current.reg;  windowReturnOneRow(p);  break;  case WINDOW_AGGINVERSE:  csr = p->start.csr;  reg = p->start.reg;  if( pMWin->regStartRowid ){  assert( pMWin->regEndRowid );  sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regStartRowid, 1);  }else{  windowAggStep(p, pMWin, csr, 1, p->regArg);  }  break;  default:  assert( op==WINDOW_AGGSTEP );  csr = p->end.csr;  reg = p->end.reg;  if( pMWin->regStartRowid ){  assert( pMWin->regEndRowid );  sqlite3VdbeAddOp2(v, OP_AddImm, pMWin->regEndRowid, 1);  }else{  windowAggStep(p, pMWin, csr, 0, p->regArg);  }  break;  }  if( op==p->eDelete ){  sqlite3VdbeAddOp1(v, OP_Delete, csr);  sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);  }  if( jumpOnEof ){  sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+2);  VdbeCoverage(v);  ret = sqlite3VdbeAddOp0(v, OP_Goto);  }else{  sqlite3VdbeAddOp2(v, OP_Next, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);  VdbeCoverage(v);  if( bPeer ){  sqlite3VdbeAddOp2(v, OP_Goto, 0, lblDone);  }  }  if( bPeer ){  int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);  int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);  windowReadPeerValues(p, csr, regTmp);  windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);  sqlite3ReleaseTempRange(pParse, regTmp, nReg);  }  if( addrNextRange ){  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNextRange);  }  sqlite3VdbeResolveLabel(v, lblDone);  return ret; } SQLITE_PRIVATE Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){  Window *pNew = 0;  if( ALWAYS(p) ){  pNew = sqlite3DbMallocZero(db, sizeof(Window));  if( pNew ){  pNew->zName = sqlite3DbStrDup(db, p->zName);  pNew->zBase = sqlite3DbStrDup(db, p->zBase);  pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);  pNew->pFunc = p->pFunc;  pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);  pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);  pNew->eFrmType = p->eFrmType;  pNew->eEnd = p->eEnd;  pNew->eStart = p->eStart;  pNew->eExclude = p->eExclude;  pNew->regResult = p->regResult;  pNew->regAccum = p->regAccum;  pNew->iArgCol = p->iArgCol;  pNew->iEphCsr = p->iEphCsr;  pNew->bExprArgs = p->bExprArgs;  pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);  pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);  pNew->pOwner = pOwner;  pNew->bImplicitFrame = p->bImplicitFrame;  }  }  return pNew; } SQLITE_PRIVATE Window *sqlite3WindowListDup(sqlite3 *db, Window *p){  Window *pWin;  Window *pRet = 0;  Window **pp = &pRet;  for(pWin=p; pWin; pWin=pWin->pNextWin){  *pp = sqlite3WindowDup(db, 0, pWin);  if( *pp==0 ) break;  pp = &((*pp)->pNextWin);  }  return pRet; } static int windowExprGtZero(Parse *pParse, Expr *pExpr){  int ret = 0;  sqlite3 *db = pParse->db;  sqlite3_value *pVal = 0;  sqlite3ValueFromExpr(db, pExpr, db->enc, SQLITE_AFF_NUMERIC, &pVal);  if( pVal && sqlite3_value_int(pVal)>0 ){  ret = 1;  }  sqlite3ValueFree(pVal);  return ret; } SQLITE_PRIVATE void sqlite3WindowCodeStep(  Parse *pParse,  Select *p,  WhereInfo *pWInfo,  int regGosub,  int addrGosub ){  Window *pMWin = p->pWin;  ExprList *pOrderBy = pMWin->pOrderBy;  Vdbe *v = sqlite3GetVdbe(pParse);  int csrWrite;  int csrInput = p->pSrc->a[0].iCursor;  int nInput = p->pSrc->a[0].pTab->nCol;  int iInput;  int addrNe;  int addrGosubFlush = 0;  int addrInteger = 0;  int addrEmpty;  int regNew;  int regRecord;  int regNewPeer = 0;  int regPeer = 0;  int regFlushPart = 0;  WindowCodeArg s;  int lblWhereEnd;  int regStart = 0;  int regEnd = 0;  assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT   || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED  );  assert( pMWin->eEnd==TK_FOLLOWING || pMWin->eEnd==TK_CURRENT   || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING  );  assert( pMWin->eExclude==0 || pMWin->eExclude==TK_CURRENT   || pMWin->eExclude==TK_GROUP || pMWin->eExclude==TK_TIES   || pMWin->eExclude==TK_NO  );  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);  memset(&s, 0, sizeof(WindowCodeArg));  s.pParse = pParse;  s.pMWin = pMWin;  s.pVdbe = v;  s.regGosub = regGosub;  s.addrGosub = addrGosub;  s.current.csr = pMWin->iEphCsr;  csrWrite = s.current.csr+1;  s.start.csr = s.current.csr+2;  s.end.csr = s.current.csr+3;  switch( pMWin->eStart ){  case TK_FOLLOWING:  if( pMWin->eFrmType!=TK_RANGE   && windowExprGtZero(pParse, pMWin->pStart)  ){  s.eDelete = WINDOW_RETURN_ROW;  }  break;  case TK_UNBOUNDED:  if( windowCacheFrame(pMWin)==0 ){  if( pMWin->eEnd==TK_PRECEDING ){  if( pMWin->eFrmType!=TK_RANGE   && windowExprGtZero(pParse, pMWin->pEnd)  ){  s.eDelete = WINDOW_AGGSTEP;  }  }else{  s.eDelete = WINDOW_RETURN_ROW;  }  }  break;  default:  s.eDelete = WINDOW_AGGINVERSE;  break;  }  regNew = pParse->nMem+1;  pParse->nMem += nInput;  regRecord = ++pParse->nMem;  s.regRowid = ++pParse->nMem;  if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){  regStart = ++pParse->nMem;  }  if( pMWin->eEnd==TK_PRECEDING || pMWin->eEnd==TK_FOLLOWING ){  regEnd = ++pParse->nMem;  }  if( pMWin->eFrmType!=TK_ROWS ){  int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);  regNewPeer = regNew + pMWin->nBufferCol;  if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;  regPeer = pParse->nMem+1;  pParse->nMem += nPeer;  s.start.reg = pParse->nMem+1;  pParse->nMem += nPeer;  s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;  s.end.reg = pParse->nMem+1;  pParse->nMem += nPeer;  }  for(iInput=0; iInput<nInput; iInput++){  sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);  }  sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);  if( pMWin->pPartition ){  int addr;  ExprList *pPart = pMWin->pPartition;  int nPart = pPart->nExpr;  int regNewPart = regNew + pMWin->nBufferCol;  KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);  regFlushPart = ++pParse->nMem;  addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);  sqlite3VdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);  sqlite3VdbeAddOp3(v, OP_Jump, addr+2, addr+4, addr+2);  VdbeCoverageEqNe(v);  addrGosubFlush = sqlite3VdbeAddOp1(v, OP_Gosub, regFlushPart);  VdbeComment((v, "call flush_partition"));  sqlite3VdbeAddOp3(v, OP_Copy, regNewPart, pMWin->regPart, nPart-1);  }  sqlite3VdbeAddOp2(v, OP_NewRowid, csrWrite, s.regRowid);  sqlite3VdbeAddOp3(v, OP_Insert, csrWrite, regRecord, s.regRowid);  addrNe = sqlite3VdbeAddOp3(v, OP_Ne, pMWin->regOne, 0, s.regRowid);  VdbeCoverageNeverNull(v);  s.regArg = windowInitAccum(pParse, pMWin);  if( regStart ){  sqlite3ExprCode(pParse, pMWin->pStart, regStart);  windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==TK_RANGE?3:0));  }  if( regEnd ){  sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);  windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==TK_RANGE?3:0));  }  if( pMWin->eFrmType!=TK_RANGE && pMWin->eStart==pMWin->eEnd && regStart ){  int op = ((pMWin->eStart==TK_FOLLOWING) ? OP_Ge : OP_Le);  int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);  VdbeCoverageNeverNullIf(v, op==OP_Ge);  VdbeCoverageNeverNullIf(v, op==OP_Le);  windowAggFinal(&s, 0);  sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);  VdbeCoverageNeverTaken(v);  windowReturnOneRow(&s);  sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);  sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);  sqlite3VdbeJumpHere(v, addrGe);  }  if( pMWin->eStart==TK_FOLLOWING && pMWin->eFrmType!=TK_RANGE && regEnd ){  assert( pMWin->eEnd==TK_FOLLOWING );  sqlite3VdbeAddOp3(v, OP_Subtract, regStart, regEnd, regStart);  }  if( pMWin->eStart!=TK_UNBOUNDED ){  sqlite3VdbeAddOp2(v, OP_Rewind, s.start.csr, 1);  VdbeCoverageNeverTaken(v);  }  sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);  VdbeCoverageNeverTaken(v);  sqlite3VdbeAddOp2(v, OP_Rewind, s.end.csr, 1);  VdbeCoverageNeverTaken(v);  if( regPeer && pOrderBy ){  sqlite3VdbeAddOp3(v, OP_Copy, regNewPeer, regPeer, pOrderBy->nExpr-1);  sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.start.reg, pOrderBy->nExpr-1);  sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.current.reg, pOrderBy->nExpr-1);  sqlite3VdbeAddOp3(v, OP_Copy, regPeer, s.end.reg, pOrderBy->nExpr-1);  }  sqlite3VdbeAddOp2(v, OP_Goto, 0, lblWhereEnd);  sqlite3VdbeJumpHere(v, addrNe);  if( regPeer ){  windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);  }  if( pMWin->eStart==TK_FOLLOWING ){  windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);  if( pMWin->eEnd!=TK_UNBOUNDED ){  if( pMWin->eFrmType==TK_RANGE ){  int lbl = sqlite3VdbeMakeLabel(pParse);  int addrNext = sqlite3VdbeCurrentAddr(v);  windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);  windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrNext);  sqlite3VdbeResolveLabel(v, lbl);  }else{  windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 0);  windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  }  }  }else  if( pMWin->eEnd==TK_PRECEDING ){  int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);  windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);  if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);  if( !bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  }else{  int addr = 0;  windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);  if( pMWin->eEnd!=TK_UNBOUNDED ){  if( pMWin->eFrmType==TK_RANGE ){  int lbl = 0;  addr = sqlite3VdbeCurrentAddr(v);  if( regEnd ){  lbl = sqlite3VdbeMakeLabel(pParse);  windowCodeRangeTest(&s, OP_Ge, s.current.csr, regEnd, s.end.csr, lbl);  }  windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);  windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  if( regEnd ){  sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);  sqlite3VdbeResolveLabel(v, lbl);  }  }else{  if( regEnd ){  addr = sqlite3VdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);  VdbeCoverage(v);  }  windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);  windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  if( regEnd ) sqlite3VdbeJumpHere(v, addr);  }  }  }  sqlite3VdbeResolveLabel(v, lblWhereEnd);  sqlite3WhereEnd(pWInfo);  if( pMWin->pPartition ){  addrInteger = sqlite3VdbeAddOp2(v, OP_Integer, 0, regFlushPart);  sqlite3VdbeJumpHere(v, addrGosubFlush);  }  s.regRowid = 0;  addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);  VdbeCoverage(v);  if( pMWin->eEnd==TK_PRECEDING ){  int bRPS = (pMWin->eStart==TK_PRECEDING && pMWin->eFrmType==TK_RANGE);  windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);  if( bRPS ) windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);  }else if( pMWin->eStart==TK_FOLLOWING ){  int addrStart;  int addrBreak1;  int addrBreak2;  int addrBreak3;  windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);  if( pMWin->eFrmType==TK_RANGE ){  addrStart = sqlite3VdbeCurrentAddr(v);  addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);  addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);  }else  if( pMWin->eEnd==TK_UNBOUNDED ){  addrStart = sqlite3VdbeCurrentAddr(v);  addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regStart, 1);  addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, 0, 1);  }else{  assert( pMWin->eEnd==TK_FOLLOWING );  addrStart = sqlite3VdbeCurrentAddr(v);  addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 1);  addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);  }  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);  sqlite3VdbeJumpHere(v, addrBreak2);  addrStart = sqlite3VdbeCurrentAddr(v);  addrBreak3 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);  sqlite3VdbeJumpHere(v, addrBreak1);  sqlite3VdbeJumpHere(v, addrBreak3);  }else{  int addrBreak;  int addrStart;  windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);  addrStart = sqlite3VdbeCurrentAddr(v);  addrBreak = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);  windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);  sqlite3VdbeAddOp2(v, OP_Goto, 0, addrStart);  sqlite3VdbeJumpHere(v, addrBreak);  }  sqlite3VdbeJumpHere(v, addrEmpty);  sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);  if( pMWin->pPartition ){  if( pMWin->regStartRowid ){  sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regStartRowid);  sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regEndRowid);  }  sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));  sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);  } }
#endif
#define YYNOERRORRECOVERY 1
#define yytestcase(X) testcase(X)
#define YYPARSEFREENEVERNULL 1
#ifdef SQLITE_AMALGAMATION
# define sqlite3Parser_ENGINEALWAYSONSTACK 1
#endif
#define YYMALLOCARGTYPE u64
struct TrigEvent { int a; IdList * b; }; struct FrameBound  { int eType; Expr *pExpr; }; static void disableLookaside(Parse *pParse){  sqlite3 *db = pParse->db;  pParse->disableLookaside++;  DisableLookaside; }
#if !defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)  && defined(SQLITE_UDL_CAPABLE_PARSER)

static void updateDeleteLimitError(  Parse *pParse,  ExprList *pOrderBy,  Expr *pLimit ){  if( pOrderBy ){  sqlite3ErrorMsg(pParse, "syntax error near \"ORDER BY\"");  }else{  sqlite3ErrorMsg(pParse, "syntax error near \"LIMIT\"");  }  sqlite3ExprListDelete(pParse->db, pOrderBy);  sqlite3ExprDelete(pParse->db, pLimit); }
#endif
 static void parserDoubleLinkSelect(Parse *pParse, Select *p){  assert( p!=0 );  if( p->pPrior ){  Select *pNext = 0, *pLoop = p;  int mxSelect, cnt = 1;  while(1){  pLoop->pNext = pNext;  pLoop->selFlags |= SF_Compound;  pNext = pLoop;  pLoop = pLoop->pPrior;  if( pLoop==0 ) break;  cnt++;  if( pLoop->pOrderBy || pLoop->pLimit ){  sqlite3ErrorMsg(pParse,"%s clause should come after %s not before",   pLoop->pOrderBy!=0 ? "ORDER BY" : "LIMIT",   sqlite3SelectOpName(pNext->op));  break;  }  }  if( (p->selFlags & SF_MultiValue)==0 &&  (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0 &&  cnt>mxSelect  ){  sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");  }  }  }  static Select *attachWithToSelect(Parse *pParse, Select *pSelect, With *pWith){  if( pSelect ){  pSelect->pWith = pWith;  parserDoubleLinkSelect(pParse, pSelect);  }else{  sqlite3WithDelete(pParse->db, pWith);  }  return pSelect;  }  static Expr *tokenExpr(Parse *pParse, int op, Token t){  Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr)+t.n+1);  if( p ){  p->op = (u8)op;  p->affExpr = 0;  p->flags = EP_Leaf;  ExprClearVVAProperties(p);  p->iAgg = -1;  p->pLeft = p->pRight = 0;  p->pAggInfo = 0;  memset(&p->x, 0, sizeof(p->x));  memset(&p->y, 0, sizeof(p->y));  p->op2 = 0;  p->iTable = 0;  p->iColumn = 0;  p->u.zToken = (char*)&p[1];  memcpy(p->u.zToken, t.z, t.n);  p->u.zToken[t.n] = 0;  if( sqlite3Isquote(p->u.zToken[0]) ){  sqlite3DequoteExpr(p);  }
#if SQLITE_MAX_EXPR_DEPTH>0
 p->nHeight = 1;
#endif
 if( IN_RENAME_OBJECT ){  return (Expr*)sqlite3RenameTokenMap(pParse, (void*)p, &t);  }  }  return p;  }  static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){  sqlite3 *db = pParse->db;  if( pA && pY && pY->op==TK_NULL && !IN_RENAME_OBJECT ){  pA->op = (u8)op;  sqlite3ExprDelete(db, pA->pRight);  pA->pRight = 0;  }  }  static ExprList *parserAddExprIdListTerm(  Parse *pParse,  ExprList *pPrior,  Token *pIdToken,  int hasCollate,  int sortOrder  ){  ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);  if( (hasCollate || sortOrder!=SQLITE_SO_UNDEFINED)  && pParse->db->init.busy==0  ){  sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",   pIdToken->n, pIdToken->z);  }  sqlite3ExprListSetName(pParse, p, pIdToken, 1);  return p;  }
#if TK_SPAN>255
# error too many tokens in the grammar
#endif
#ifndef TK_SEMI
#define TK_SEMI 1
#define TK_EXPLAIN  2
#define TK_QUERY  3
#define TK_PLAN 4
#define TK_BEGIN  5
#define TK_TRANSACTION  6
#define TK_DEFERRED 7
#define TK_IMMEDIATE  8
#define TK_EXCLUSIVE  9
#define TK_COMMIT  10
#define TK_END 11
#define TK_ROLLBACK  12
#define TK_SAVEPOINT 13
#define TK_RELEASE 14
#define TK_TO  15
#define TK_TABLE 16
#define TK_CREATE  17
#define TK_IF  18
#define TK_NOT 19
#define TK_EXISTS  20
#define TK_TEMP  21
#define TK_LP  22
#define TK_RP  23
#define TK_AS  24
#define TK_COMMA 25
#define TK_WITHOUT 26
#define TK_ABORT 27
#define TK_ACTION  28
#define TK_AFTER 29
#define TK_ANALYZE 30
#define TK_ASC 31
#define TK_ATTACH  32
#define TK_BEFORE  33
#define TK_BY  34
#define TK_CASCADE 35
#define TK_CAST  36
#define TK_CONFLICT  37
#define TK_DATABASE  38
#define TK_DESC  39
#define TK_DETACH  40
#define TK_EACH  41
#define TK_FAIL  42
#define TK_OR  43
#define TK_AND 44
#define TK_IS  45
#define TK_MATCH 46
#define TK_LIKE_KW 47
#define TK_BETWEEN 48
#define TK_IN  49
#define TK_ISNULL  50
#define TK_NOTNULL 51
#define TK_NE  52
#define TK_EQ  53
#define TK_GT  54
#define TK_LE  55
#define TK_LT  56
#define TK_GE  57
#define TK_ESCAPE  58
#define TK_ID  59
#define TK_COLUMNKW  60
#define TK_DO  61
#define TK_FOR 62
#define TK_IGNORE  63
#define TK_INITIALLY 64
#define TK_INSTEAD 65
#define TK_NO  66
#define TK_KEY 67
#define TK_OF  68
#define TK_OFFSET  69
#define TK_PRAGMA  70
#define TK_RAISE 71
#define TK_RECURSIVE 72
#define TK_REPLACE 73
#define TK_RESTRICT  74
#define TK_ROW 75
#define TK_ROWS  76
#define TK_TRIGGER 77
#define TK_VACUUM  78
#define TK_VIEW  79
#define TK_VIRTUAL 80
#define TK_WITH  81
#define TK_NULLS 82
#define TK_FIRST 83
#define TK_LAST  84
#define TK_CURRENT 85
#define TK_FOLLOWING 86
#define TK_PARTITION 87
#define TK_PRECEDING 88
#define TK_RANGE 89
#define TK_UNBOUNDED 90
#define TK_EXCLUDE 91
#define TK_GROUPS  92
#define TK_OTHERS  93
#define TK_TIES  94
#define TK_GENERATED 95
#define TK_ALWAYS  96
#define TK_MATERIALIZED  97
#define TK_REINDEX 98
#define TK_RENAME  99
#define TK_CTIME_KW  100
#define TK_ANY 101
#define TK_BITAND  102
#define TK_BITOR 103
#define TK_LSHIFT  104
#define TK_RSHIFT  105
#define TK_PLUS  106
#define TK_MINUS 107
#define TK_STAR  108
#define TK_SLASH 109
#define TK_REM 110
#define TK_CONCAT  111
#define TK_COLLATE 112
#define TK_BITNOT  113
#define TK_ON  114
#define TK_INDEXED 115
#define TK_STRING  116
#define TK_JOIN_KW 117
#define TK_CONSTRAINT  118
#define TK_DEFAULT 119
#define TK_NULL  120
#define TK_PRIMARY 121
#define TK_UNIQUE  122
#define TK_CHECK 123
#define TK_REFERENCES  124
#define TK_AUTOINCR  125
#define TK_INSERT  126
#define TK_DELETE  127
#define TK_UPDATE  128
#define TK_SET 129
#define TK_DEFERRABLE  130
#define TK_FOREIGN 131
#define TK_DROP  132
#define TK_UNION 133
#define TK_ALL 134
#define TK_EXCEPT  135
#define TK_INTERSECT 136
#define TK_SELECT  137
#define TK_VALUES  138
#define TK_DISTINCT  139
#define TK_DOT 140
#define TK_FROM  141
#define TK_JOIN  142
#define TK_USING 143
#define TK_ORDER 144
#define TK_GROUP 145
#define TK_HAVING  146
#define TK_LIMIT 147
#define TK_WHERE 148
#define TK_RETURNING 149
#define TK_INTO  150
#define TK_NOTHING 151
#define TK_FLOAT 152
#define TK_BLOB  153
#define TK_INTEGER 154
#define TK_VARIABLE  155
#define TK_CASE  156
#define TK_WHEN  157
#define TK_THEN  158
#define TK_ELSE  159
#define TK_INDEX 160
#define TK_ALTER 161
#define TK_ADD 162
#define TK_WINDOW  163
#define TK_OVER  164
#define TK_FILTER  165
#define TK_COLUMN  166
#define TK_AGG_FUNCTION  167
#define TK_AGG_COLUMN  168
#define TK_TRUEFALSE 169
#define TK_ISNOT 170
#define TK_FUNCTION  171
#define TK_UMINUS  172
#define TK_UPLUS 173
#define TK_TRUTH 174
#define TK_REGISTER  175
#define TK_VECTOR  176
#define TK_SELECT_COLUMN 177
#define TK_IF_NULL_ROW 178
#define TK_ASTERISK  179
#define TK_SPAN  180
#define TK_ERROR 181
#define TK_SPACE 182
#define TK_ILLEGAL 183
#endif
#ifndef INTERFACE
# define INTERFACE 1
#endif
#define YYCODETYPE unsigned short int
#define YYNOCODE 318
#define YYACTIONTYPE unsigned short int
#define YYWILDCARD 101
#define sqlite3ParserTOKENTYPE Token
typedef union {  int yyinit;  sqlite3ParserTOKENTYPE yy0;  With* yy43;  u32 yy51;  int yy64;  struct FrameBound yy81;  struct {int value; int mask;} yy83;  TriggerStep* yy95;  Upsert* yy138;  IdList* yy240;  Cte* yy255;  Select* yy303;  Window* yy375;  u8 yy534;  ExprList* yy562;  struct TrigEvent yy570;  const char* yy600;  SrcList* yy607;  Expr* yy626; } YYMINORTYPE;
#ifndef YYSTACKDEPTH
#define YYSTACKDEPTH 100
#endif
#define sqlite3ParserARG_SDECL
#define sqlite3ParserARG_PDECL
#define sqlite3ParserARG_PARAM
#define sqlite3ParserARG_FETCH
#define sqlite3ParserARG_STORE
#define sqlite3ParserCTX_SDECL Parse *pParse;
#define sqlite3ParserCTX_PDECL ,Parse *pParse
#define sqlite3ParserCTX_PARAM ,pParse
#define sqlite3ParserCTX_FETCH Parse *pParse=yypParser->pParse;
#define sqlite3ParserCTX_STORE yypParser->pParse=pParse;
#define YYFALLBACK 1
#define YYNSTATE  576
#define YYNRULE 401
#define YYNRULE_WITH_ACTION 339
#define YYNTOKEN  184
#define YY_MAX_SHIFT  575
#define YY_MIN_SHIFTREDUCE  833
#define YY_MAX_SHIFTREDUCE  1233
#define YY_ERROR_ACTION 1234
#define YY_ACCEPT_ACTION  1235
#define YY_NO_ACTION  1236
#define YY_MIN_REDUCE 1237
#define YY_MAX_REDUCE 1637
#define YY_NLOOKAHEAD ((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))
#ifndef yytestcase
# define yytestcase(X)
#endif
#define YY_ACTTAB_COUNT (2041)
static const YYACTIONTYPE yy_action[] = {   568, 115, 112, 220, 169, 199, 115, 112, 220, 568,   379, 1270, 568, 380, 568, 270, 1313, 1313, 410, 411,  1088, 199, 1517, 41, 41, 519, 493, 525, 562, 562,   562, 969, 41, 41, 399, 41, 41, 51, 51, 970,   296, 1273, 296, 122, 123, 113, 1211, 1211, 1045, 1048,  1038, 1038, 120, 120, 121, 121, 121, 121, 568, 411,   275, 275, 275, 275, 1272, 115, 112, 220, 115, 112,   220, 1516, 850, 565, 520, 565, 115, 112, 220, 250,   217, 71, 71, 122, 123, 113, 1211, 1211, 1045, 1048,  1038, 1038, 120, 120, 121, 121, 121, 121, 444, 444,   444, 1153, 119, 119, 119, 119, 118, 118, 117, 117,   117, 116, 446, 1187, 1153, 116, 446, 1153, 550, 517,  1552, 1558, 378, 446, 6, 1187, 1158, 526, 1158, 411,  1560, 465, 377, 1558, 539, 99, 467, 336, 121, 121,   121, 121, 119, 119, 119, 119, 118, 118, 117, 117,   117, 116, 446, 122, 123, 113, 1211, 1211, 1045, 1048,  1038, 1038, 120, 120, 121, 121, 121, 121, 1261, 1187,  1188, 1189, 243, 1068, 568, 506, 503, 502, 571, 124,   571, 1187, 1188, 1189, 478, 501, 119, 119, 119, 119,   118, 118, 117, 117, 117, 116, 446, 70, 70, 411,   121, 121, 121, 121, 114, 117, 117, 117, 116, 446,  1413, 1473, 119, 119, 119, 119, 118, 118, 117, 117,   117, 116, 446, 122, 123, 113, 1211, 1211, 1045, 1048,  1038, 1038, 120, 120, 121, 121, 121, 121, 411, 1035,  1035, 1046, 1049, 81, 386, 545, 382, 80, 119, 119,   119, 119, 118, 118, 117, 117, 117, 116, 446, 385,   467, 336, 122, 123, 113, 1211, 1211, 1045, 1048, 1038,  1038, 120, 120, 121, 121, 121, 121, 262, 215, 516,  1428, 426, 119, 119, 119, 119, 118, 118, 117, 117,   117, 116, 446, 1235, 1, 1, 575, 2, 1239, 1577,   575, 2, 1239, 307, 1153, 141, 1604, 307, 411, 141,  1187, 365, 1321, 1039, 870, 535, 1321, 1153, 363, 1571,  1153, 119, 119, 119, 119, 118, 118, 117, 117, 117,   116, 446, 122, 123, 113, 1211, 1211, 1045, 1048, 1038,  1038, 120, 120, 121, 121, 121, 121, 275, 275, 1005,   430, 275, 275, 1132, 1631, 1025, 1631, 137, 546, 1545,   565, 272, 954, 954, 565, 1427, 1187, 1188, 1189, 1598,   870, 1016, 534, 315, 231, 1015, 472, 1280, 231, 119,   119, 119, 119, 118, 118, 117, 117, 117, 116, 446,  1574, 119, 119, 119, 119, 118, 118, 117, 117, 117,   116, 446, 334, 363, 1571, 568, 450, 1015, 1015, 1017,   450, 207, 568, 306, 559, 411, 367, 1025, 367, 350,   184, 118, 118, 117, 117, 117, 116, 446, 71, 71,   443, 442, 1130, 1016, 476, 71, 71, 1015, 205, 122,   123, 113, 1211, 1211, 1045, 1048, 1038, 1038, 120, 120,   121, 121, 121, 121, 219, 219, 476, 1187, 411, 574,  1187, 1239, 507, 1481, 149, 550, 307, 493, 141, 1015,  1015, 1017, 550, 140, 549, 1321, 1218, 191, 1218, 954,   954, 518, 122, 123, 113, 1211, 1211, 1045, 1048, 1038,  1038, 120, 120, 121, 121, 121, 121, 567, 119, 119,   119, 119, 118, 118, 117, 117, 117, 116, 446, 283,   275, 275, 419, 1187, 1188, 1189, 1187, 1188, 1189, 376,  1187, 243, 348, 565, 506, 503, 502, 1543, 411, 1544,  1187, 288, 874, 143, 501, 1553, 185, 231, 9, 6,   253, 119, 119, 119, 119, 118, 118, 117, 117, 117,   116, 446, 122, 123, 113, 1211, 1211, 1045, 1048, 1038,  1038, 120, 120, 121, 121, 121, 121, 411, 137, 450,   451, 867, 169, 1187, 401, 1208, 1187, 1188, 1189, 935,   530, 1005, 98, 343, 568, 346, 1187, 1188, 1189, 306,   559, 122, 123, 113, 1211, 1211, 1045, 1048, 1038, 1038,   120, 120, 121, 121, 121, 121, 456, 71, 71, 275,   275, 119, 119, 119, 119, 118, 118, 117, 117, 117,   116, 446, 565, 421, 306, 559, 1187, 1311, 1311, 1187,  1188, 1189, 1208, 1153, 334, 462, 320, 411, 367, 474,   435, 1171, 32, 545, 531, 354, 1153, 1633, 397, 1153,   119, 119, 119, 119, 118, 118, 117, 117, 117, 116,   446, 122, 123, 113, 1211, 1211, 1045, 1048, 1038, 1038,   120, 120, 121, 121, 121, 121, 411, 199, 476, 1187,  1026, 476, 1187, 1188, 1189, 390, 151, 543, 1552, 277,   404, 137, 6, 317, 5, 568, 566, 3, 924, 924,   122, 123, 113, 1211, 1211, 1045, 1048, 1038, 1038, 120,   120, 121, 121, 121, 121, 415, 509, 83, 71, 71,   119, 119, 119, 119, 118, 118, 117, 117, 117, 116,   446, 1187, 218, 432, 1187, 1187, 1188, 1189, 367, 261,   278, 362, 512, 357, 511, 248, 411, 306, 559, 1543,  1010, 353, 367, 291, 493, 302, 293, 1546, 281, 119,   119, 119, 119, 118, 118, 117, 117, 117, 116, 446,   122, 123, 113, 1211, 1211, 1045, 1048, 1038, 1038, 120,   120, 121, 121, 121, 121, 411, 148, 1187, 1188, 1189,  1187, 1188, 1189, 275, 275, 1308, 1261, 1287, 487, 1480,   150, 493, 484, 568, 1191, 1308, 565, 1591, 1259, 122,   123, 113, 1211, 1211, 1045, 1048, 1038, 1038, 120, 120,   121, 121, 121, 121, 568, 890, 13, 13, 524, 119,   119, 119, 119, 118, 118, 117, 117, 117, 116, 446,  1187, 424, 421, 568, 269, 269, 1320, 13, 13, 1543,  1550, 16, 16, 326, 6, 411, 510, 565, 1093, 1093,   490, 1191, 429, 1543, 891, 292, 71, 71, 119, 119,   119, 119, 118, 118, 117, 117, 117, 116, 446, 122,   123, 113, 1211, 1211, 1045, 1048, 1038, 1038, 120, 120,   121, 121, 121, 121, 568, 12, 1187, 1188, 1189, 411,   275, 275, 455, 303, 838, 839, 840, 421, 493, 276,   276, 1551, 284, 565, 323, 6, 325, 71, 71, 433,   455, 454, 565, 956, 101, 113, 1211, 1211, 1045, 1048,  1038, 1038, 120, 120, 121, 121, 121, 121, 119, 119,   119, 119, 118, 118, 117, 117, 117, 116, 446, 1109,  1187, 493, 568, 1316, 441, 459, 482, 568, 246, 245,   244, 1413, 1549, 551, 1110, 409, 6, 1548, 196, 1262,   417, 6, 105, 466, 103, 71, 71, 286, 568, 1111,  13, 13, 119, 119, 119, 119, 118, 118, 117, 117,   117, 116, 446, 455, 104, 431, 341, 324, 275, 275,   910, 13, 13, 568, 1486, 1109, 1187, 1188, 1189, 126,   911, 565, 550, 568, 411, 482, 295, 1325, 253, 200,  1110, 552, 1486, 1488, 280, 1413, 55, 55, 1291, 565,   482, 384, 427, 955, 411, 1111, 71, 71, 122, 123,   113, 1211, 1211, 1045, 1048, 1038, 1038, 120, 120, 121,   121, 121, 121, 1208, 411, 287, 556, 309, 122, 123,   113, 1211, 1211, 1045, 1048, 1038, 1038, 120, 120, 121,   121, 121, 121, 445, 1132, 1632, 146, 1632, 122, 111,   113, 1211, 1211, 1045, 1048, 1038, 1038, 120, 120, 121,   121, 121, 121, 408, 407, 1486, 428, 119, 119, 119,   119, 118, 118, 117, 117, 117, 116, 446, 1187, 568,  1208, 548, 1090, 862, 333, 365, 1090, 119, 119, 119,   119, 118, 118, 117, 117, 117, 116, 446, 568, 294,   144, 527, 56, 56, 224, 568, 514, 119, 119, 119,   119, 118, 118, 117, 117, 117, 116, 446, 488, 1413,   541, 15, 15, 1130, 438, 443, 442, 411, 13, 13,  1527, 12, 930, 1215, 1187, 1188, 1189, 929, 1217, 540,   862, 561, 417, 193, 1529, 498, 1216, 452, 1164, 1226,  1187, 568, 123, 113, 1211, 1211, 1045, 1048, 1038, 1038,   120, 120, 121, 121, 121, 121, 1525, 1153, 568, 969,   568, 1218, 247, 1218, 13, 13, 1413, 970, 542, 568,  1153, 108, 560, 1153, 4, 310, 396, 1231, 17, 194,   489, 43, 43, 57, 57, 306, 559, 528, 563, 1164,   468, 568, 44, 44, 396, 1131, 1187, 1188, 1189, 483,   119, 119, 119, 119, 118, 118, 117, 117, 117, 116,   446, 447, 568, 331, 13, 13, 568, 422, 1319, 418,   171, 568, 311, 557, 213, 533, 1257, 568, 521, 547,   416, 108, 560, 137, 4, 58, 58, 439, 314, 59,  59, 274, 217, 553, 60, 60, 353, 480, 563, 1357,  61, 61, 1025, 275, 275, 1232, 213, 568, 106, 106,   8, 275, 275, 275, 275, 107, 565, 447, 570, 569,   568, 447, 1015, 1232, 565, 568, 565, 568, 275, 275,  62, 62, 1356, 557, 247, 460, 568, 98, 110, 306,   559, 565, 568, 45, 45, 409, 1207, 537, 46, 46,  47, 47, 536, 469, 1015, 1015, 1017, 1018, 27, 49,  49, 568, 1025, 409, 473, 50, 50, 568, 106, 106,   305, 568, 84, 204, 409, 107, 568, 447, 570, 569,   409, 568, 1015, 568, 63, 63, 568, 1603, 568, 899,  64, 64, 461, 481, 65, 65, 147, 96, 38, 14,  14, 1532, 416, 568, 66, 66, 128, 128, 930, 67,  67, 52, 52, 929, 1015, 1015, 1017, 1018, 27, 1576,  1175, 449, 208, 1127, 279, 398, 68, 68, 228, 394,   394, 393, 264, 391, 1175, 449, 847, 881, 279, 108,   560, 457, 4, 394, 394, 393, 264, 391, 568, 225,   847, 313, 332, 1007, 98, 252, 563, 548, 475, 312,   252, 568, 208, 225, 568, 313, 477, 30, 252, 279,   470, 69, 69, 312, 394, 394, 393, 264, 391, 447,   337, 847, 98, 568, 53, 53, 327, 157, 157, 227,   499, 557, 249, 289, 225, 568, 313, 162, 31, 1505,   135, 568, 1504, 227, 312, 537, 158, 158, 889, 888,   538, 162, 877, 301, 135, 568, 485, 226, 76, 76,  1025, 351, 1075, 98, 54, 54, 106, 106, 1071, 568,   249, 226, 523, 107, 227, 447, 570, 569, 72, 72,  1015, 338, 162, 568, 230, 135, 108, 560, 963, 4,   252, 412, 129, 129, 568, 1353, 306, 559, 568, 927,   568, 110, 226, 563, 568, 412, 73, 73, 568, 877,   306, 559, 1015, 1015, 1017, 1018, 27, 130, 130, 1075,   453, 131, 131, 127, 127, 361, 447, 156, 156, 896,   897, 155, 155, 342, 453, 360, 412, 568, 557, 972,   973, 306, 559, 1019, 345, 568, 108, 560, 568, 4,  1136, 1290, 537, 568, 860, 347, 145, 536, 349, 1304,   136, 136, 1087, 563, 1087, 453, 568, 1025, 134, 134,  1288, 132, 132, 106, 106, 1289, 133, 133, 568, 356,   107, 568, 447, 570, 569, 1344, 447, 1015, 366, 75,  75, 1086, 568, 1086, 568, 928, 1565, 110, 557, 555,  1019, 77, 77, 1365, 74, 74, 1412, 1340, 1351, 554,  1418, 1269, 1260, 1248, 1247, 42, 42, 48, 48, 1015,  1015, 1017, 1018, 27, 1249, 1584, 494, 1025, 267, 202,  1337, 369, 11, 106, 106, 934, 371, 210, 373, 395,   107, 1399, 447, 570, 569, 223, 319, 1015, 504, 458,   282, 1404, 285, 108, 560, 214, 4, 329, 322, 1287,   479, 359, 1477, 1587, 1476, 1403, 375, 1226, 330, 402,   563, 290, 335, 197, 100, 560, 209, 4, 198, 1015,  1015, 1017, 1018, 27, 389, 256, 1524, 1522, 558, 1223,   420, 563, 83, 447, 173, 206, 182, 221, 125, 1394,   548, 167, 318, 175, 1387, 557, 79, 321, 1400, 463,  35, 177, 464, 178, 447, 179, 180, 497, 1482, 233,  89, 96, 1406, 400, 82, 1408, 557, 471, 1405, 36,   403, 186, 486, 237, 1025, 1471, 1493, 492, 268, 239,   106, 106, 190, 495, 405, 240, 340, 107, 344, 447,   570, 569, 1250, 241, 1015, 1025, 513, 1307, 434, 91,  1306, 106, 106, 1298, 881, 1305, 215, 1602, 107, 1277,   447, 570, 569, 1601, 406, 1015, 1276, 358, 1275, 1600,  1570, 436, 437, 299, 1297, 522, 1015, 1015, 1017, 1018,  27, 300, 529, 95, 364, 254, 1348, 368, 255, 1556,   440, 10, 1555, 383, 1457, 102, 97, 1015, 1015, 1017,  1018, 27, 304, 532, 34, 572, 1181, 263, 265, 1349,  1330, 266, 201, 370, 381, 1347, 372, 1329, 1346, 374,  1372, 387, 388, 1371, 573, 1245, 1240, 159, 1509, 1510,  1508, 1507, 160, 142, 297, 211, 212, 78, 834, 448,   203, 308, 161, 222, 1085, 139, 1083, 316, 174, 163,  1207, 229, 176, 913, 328, 232, 1099, 181, 164, 165,   423, 425, 85, 183, 86, 87, 88, 166, 1102, 413,   172, 414, 235, 234, 1098, 152, 18, 236, 339, 1220,   238, 252, 1091, 187, 491, 188, 37, 849, 496, 360,   242, 352, 508, 189, 90, 168, 19, 500, 20, 505,   879, 355, 92, 892, 298, 153, 93, 515, 94, 1169,   154, 1051, 1138, 39, 1137, 216, 271, 273, 962, 192,   957, 110, 1159, 1155, 251, 7, 21, 1163, 1157, 22,  1143, 33, 23, 24, 25, 544, 26, 1162, 195, 98,  1066, 1052, 1050, 1054, 1108, 1055, 1107, 257, 258, 28,  40, 1177, 1020, 861, 109, 29, 564, 392, 138, 259,   923, 170, 260, 1176, 1236, 1236, 1236, 1236, 1236, 1236,  1236, 1593, 1236, 1236, 1236, 1236, 1236, 1236, 1236, 1236,  1592, }; static const YYCODETYPE yy_lookahead[] = {   192, 273, 274, 275, 192, 192, 273, 274, 275, 192,   218, 215, 192, 218, 192, 212, 234, 235, 205, 19,  11, 192, 294, 215, 216, 203, 192, 203, 209, 210,   211, 31, 215, 216, 205, 215, 216, 215, 216, 39,   227, 215, 229, 43, 44, 45, 46, 47, 48, 49,  50, 51, 52, 53, 54, 55, 56, 57, 192, 19,   238, 239, 238, 239, 215, 273, 274, 275, 273, 274,   275, 237, 21, 251, 252, 251, 273, 274, 275, 255,   256, 215, 216, 43, 44, 45, 46, 47, 48, 49,  50, 51, 52, 53, 54, 55, 56, 57, 209, 210,   211, 76, 102, 103, 104, 105, 106, 107, 108, 109,   110, 111, 112, 59, 89, 111, 112, 92, 252, 307,   308, 313, 314, 112, 312, 59, 86, 261, 88, 19,   313, 80, 315, 313, 314, 25, 127, 128, 54, 55,  56, 57, 102, 103, 104, 105, 106, 107, 108, 109,   110, 111, 112, 43, 44, 45, 46, 47, 48, 49,  50, 51, 52, 53, 54, 55, 56, 57, 192, 115,   116, 117, 118, 122, 192, 121, 122, 123, 202, 69,   204, 115, 116, 117, 192, 131, 102, 103, 104, 105,   106, 107, 108, 109, 110, 111, 112, 215, 216, 19,  54, 55, 56, 57, 58, 108, 109, 110, 111, 112,   192, 160, 102, 103, 104, 105, 106, 107, 108, 109,   110, 111, 112, 43, 44, 45, 46, 47, 48, 49,  50, 51, 52, 53, 54, 55, 56, 57, 19, 46,  47, 48, 49, 24, 248, 192, 250, 67, 102, 103,   104, 105, 106, 107, 108, 109, 110, 111, 112, 277,   127, 128, 43, 44, 45, 46, 47, 48, 49, 50,  51, 52, 53, 54, 55, 56, 57, 26, 164, 165,   272, 263, 102, 103, 104, 105, 106, 107, 108, 109,   110, 111, 112, 184, 185, 186, 187, 188, 189, 186,   187, 188, 189, 194, 76, 196, 229, 194, 19, 196,  59, 192, 203, 120, 59, 87, 203, 89, 310, 311,  92, 102, 103, 104, 105, 106, 107, 108, 109, 110,   111, 112, 43, 44, 45, 46, 47, 48, 49, 50,  51, 52, 53, 54, 55, 56, 57, 238, 239, 73,   231, 238, 239, 22, 23, 100, 25, 81, 305, 306,   251, 23, 25, 25, 251, 272, 115, 116, 117, 214,   115, 116, 144, 192, 265, 120, 114, 222, 265, 102,   103, 104, 105, 106, 107, 108, 109, 110, 111, 112,   192, 102, 103, 104, 105, 106, 107, 108, 109, 110,   111, 112, 126, 310, 311, 192, 297, 152, 153, 154,   297, 149, 192, 137, 138, 19, 192, 100, 192, 23,  22, 106, 107, 108, 109, 110, 111, 112, 215, 216,   106, 107, 101, 116, 192, 215, 216, 120, 149, 43,  44, 45, 46, 47, 48, 49, 50, 51, 52, 53,  54, 55, 56, 57, 117, 117, 192, 59, 19, 187,  59, 189, 23, 282, 240, 252, 194, 192, 196, 152,   153, 154, 252, 72, 261, 203, 152, 25, 154, 142,   142, 261, 43, 44, 45, 46, 47, 48, 49, 50,  51, 52, 53, 54, 55, 56, 57, 192, 102, 103,   104, 105, 106, 107, 108, 109, 110, 111, 112, 267,   238, 239, 237, 115, 116, 117, 115, 116, 117, 192,  59, 118, 16, 251, 121, 122, 123, 303, 19, 303,  59, 267, 23, 72, 131, 308, 22, 265, 22, 312,  24, 102, 103, 104, 105, 106, 107, 108, 109, 110,   111, 112, 43, 44, 45, 46, 47, 48, 49, 50,  51, 52, 53, 54, 55, 56, 57, 19, 81, 297,   295, 23, 192, 59, 203, 59, 115, 116, 117, 108,   192, 73, 25, 77, 192, 79, 115, 116, 117, 137,   138, 43, 44, 45, 46, 47, 48, 49, 50, 51,  52, 53, 54, 55, 56, 57, 119, 215, 216, 238,   239, 102, 103, 104, 105, 106, 107, 108, 109, 110,   111, 112, 251, 192, 137, 138, 59, 234, 235, 115,   116, 117, 116, 76, 126, 127, 128, 19, 192, 268,  19, 23, 22, 192, 252, 24, 89, 300, 301, 92,   102, 103, 104, 105, 106, 107, 108, 109, 110, 111,   112, 43, 44, 45, 46, 47, 48, 49, 50, 51,  52, 53, 54, 55, 56, 57, 19, 192, 192, 59,  23, 192, 115, 116, 117, 200, 240, 307, 308, 22,   205, 81, 312, 262, 22, 192, 133, 22, 135, 136,  43, 44, 45, 46, 47, 48, 49, 50, 51, 52,  53, 54, 55, 56, 57, 197, 95, 150, 215, 216,   102, 103, 104, 105, 106, 107, 108, 109, 110, 111,   112, 59, 192, 112, 59, 115, 116, 117, 192, 118,   119, 120, 121, 122, 123, 124, 19, 137, 138, 303,  23, 130, 192, 267, 192, 252, 267, 306, 203, 102,   103, 104, 105, 106, 107, 108, 109, 110, 111, 112,  43, 44, 45, 46, 47, 48, 49, 50, 51, 52,  53, 54, 55, 56, 57, 19, 240, 115, 116, 117,   115, 116, 117, 238, 239, 222, 192, 224, 280, 237,   240, 192, 284, 192, 59, 232, 251, 140, 204, 43,  44, 45, 46, 47, 48, 49, 50, 51, 52, 53,  54, 55, 56, 57, 192, 35, 215, 216, 192, 102,   103, 104, 105, 106, 107, 108, 109, 110, 111, 112,  59, 230, 192, 192, 238, 239, 237, 215, 216, 303,   308, 215, 216, 16, 312, 19, 66, 251, 126, 127,   128, 116, 230, 303, 74, 203, 215, 216, 102, 103,   104, 105, 106, 107, 108, 109, 110, 111, 112, 43,  44, 45, 46, 47, 48, 49, 50, 51, 52, 53,  54, 55, 56, 57, 192, 212, 115, 116, 117, 19,   238, 239, 192, 252, 7, 8, 9, 192, 192, 238,   239, 308, 262, 251, 77, 312, 79, 215, 216, 129,   210, 211, 251, 142, 158, 45, 46, 47, 48, 49,  50, 51, 52, 53, 54, 55, 56, 57, 102, 103,   104, 105, 106, 107, 108, 109, 110, 111, 112, 12,  59, 192, 192, 237, 252, 243, 192, 192, 126, 127,   128, 192, 308, 203, 27, 253, 312, 308, 285, 207,   208, 312, 157, 290, 159, 215, 216, 262, 192, 42,   215, 216, 102, 103, 104, 105, 106, 107, 108, 109,   110, 111, 112, 283, 158, 230, 237, 160, 238, 239,  63, 215, 216, 192, 192, 12, 115, 116, 117, 22,  73, 251, 252, 192, 19, 192, 230, 239, 24, 24,  27, 261, 210, 211, 99, 192, 215, 216, 225, 251,   192, 192, 263, 142, 19, 42, 215, 216, 43, 44,  45, 46, 47, 48, 49, 50, 51, 52, 53, 54,  55, 56, 57, 59, 19, 291, 63, 132, 43, 44,  45, 46, 47, 48, 49, 50, 51, 52, 53, 54,  55, 56, 57, 252, 22, 23, 22, 25, 43, 44,  45, 46, 47, 48, 49, 50, 51, 52, 53, 54,  55, 56, 57, 106, 107, 283, 263, 102, 103, 104,   105, 106, 107, 108, 109, 110, 111, 112, 59, 192,   116, 144, 29, 59, 291, 192, 33, 102, 103, 104,   105, 106, 107, 108, 109, 110, 111, 112, 192, 291,   163, 19, 215, 216, 15, 192, 108, 102, 103, 104,   105, 106, 107, 108, 109, 110, 111, 112, 65, 192,  66, 215, 216, 101, 231, 106, 107, 19, 215, 216,   192, 212, 134, 114, 115, 116, 117, 139, 119, 85,   116, 207, 208, 230, 192, 19, 127, 192, 94, 60,  59, 192, 44, 45, 46, 47, 48, 49, 50, 51,  52, 53, 54, 55, 56, 57, 192, 76, 192, 31,   192, 152, 46, 154, 215, 216, 192, 39, 87, 192,  89, 19, 20, 92, 22, 192, 22, 23, 22, 230,   263, 215, 216, 215, 216, 137, 138, 115, 36, 145,   128, 192, 215, 216, 22, 23, 115, 116, 117, 290,   102, 103, 104, 105, 106, 107, 108, 109, 110, 111,   112, 59, 192, 151, 215, 216, 192, 61, 203, 298,   299, 192, 192, 71, 25, 144, 203, 192, 203, 230,   114, 19, 20, 81, 22, 215, 216, 263, 192, 215,   216, 255, 256, 203, 215, 216, 130, 19, 36, 192,   215, 216, 100, 238, 239, 101, 25, 192, 106, 107,  48, 238, 239, 238, 239, 113, 251, 115, 116, 117,   192, 59, 120, 101, 251, 192, 251, 192, 238, 239,   215, 216, 192, 71, 46, 243, 192, 25, 25, 137,   138, 251, 192, 215, 216, 253, 25, 85, 215, 216,   215, 216, 90, 243, 152, 153, 154, 155, 156, 215,   216, 192, 100, 253, 243, 215, 216, 192, 106, 107,   243, 192, 148, 149, 253, 113, 192, 115, 116, 117,   253, 192, 120, 192, 215, 216, 192, 23, 192, 25,   215, 216, 192, 115, 215, 216, 22, 148, 24, 215,   216, 192, 114, 192, 215, 216, 215, 216, 134, 215,   216, 215, 216, 139, 152, 153, 154, 155, 156, 0,   1, 2, 141, 23, 5, 25, 215, 216, 24, 10,  11, 12, 13, 14, 1, 2, 17, 125, 5, 19,  20, 268, 22, 10, 11, 12, 13, 14, 192, 30,  17, 32, 23, 23, 25, 25, 36, 144, 23, 40,  25, 192, 141, 30, 192, 32, 23, 22, 25, 5,   128, 215, 216, 40, 10, 11, 12, 13, 14, 59,  23, 17, 25, 192, 215, 216, 192, 215, 216, 70,  23, 71, 25, 151, 30, 192, 32, 78, 53, 192,  81, 192, 192, 70, 40, 85, 215, 216, 119, 120,  90, 78, 59, 254, 81, 192, 192, 98, 215, 216,   100, 23, 59, 25, 215, 216, 106, 107, 23, 192,  25, 98, 19, 113, 70, 115, 116, 117, 215, 216,   120, 192, 78, 192, 140, 81, 19, 20, 23, 22,  25, 132, 215, 216, 192, 192, 137, 138, 192, 23,   192, 25, 98, 36, 192, 132, 215, 216, 192, 116,   137, 138, 152, 153, 154, 155, 156, 215, 216, 116,   161, 215, 216, 215, 216, 120, 59, 215, 216, 7,   8, 215, 216, 192, 161, 130, 132, 192, 71, 83,  84, 137, 138, 59, 192, 192, 19, 20, 192, 22,  97, 225, 85, 192, 23, 192, 25, 90, 192, 192,   215, 216, 152, 36, 154, 161, 192, 100, 215, 216,   192, 215, 216, 106, 107, 225, 215, 216, 192, 192,   113, 192, 115, 116, 117, 257, 59, 120, 192, 215,   216, 152, 192, 154, 192, 23, 317, 25, 71, 235,   116, 215, 216, 192, 215, 216, 192, 192, 192, 192,   192, 192, 192, 192, 192, 215, 216, 215, 216, 152,   153, 154, 155, 156, 192, 192, 287, 100, 286, 241,   254, 254, 242, 106, 107, 108, 254, 213, 254, 190,   113, 270, 115, 116, 117, 296, 266, 120, 219, 258,   244, 270, 258, 19, 20, 228, 22, 292, 266, 224,   292, 218, 218, 195, 218, 270, 258, 60, 245, 270,  36, 245, 244, 248, 19, 20, 242, 22, 248, 152,   153, 154, 155, 156, 244, 140, 199, 199, 279, 38,   199, 36, 150, 59, 296, 149, 22, 296, 147, 249,   144, 43, 248, 233, 249, 71, 293, 248, 271, 18,   269, 236, 199, 236, 59, 236, 236, 18, 282, 198,   157, 148, 271, 245, 293, 233, 71, 245, 271, 269,   245, 233, 199, 198, 100, 245, 289, 62, 199, 198,   106, 107, 22, 220, 220, 198, 288, 113, 199, 115,   116, 117, 199, 198, 120, 100, 114, 217, 64, 22,   217, 106, 107, 226, 125, 217, 164, 223, 113, 217,   115, 116, 117, 223, 220, 120, 219, 217, 217, 217,   311, 24, 112, 281, 226, 304, 152, 153, 154, 155,   156, 281, 143, 114, 220, 199, 260, 259, 91, 316,  82, 22, 316, 199, 276, 157, 146, 152, 153, 154,   155, 156, 278, 145, 25, 201, 13, 193, 193, 260,   249, 6, 247, 259, 248, 260, 259, 249, 260, 259,   264, 246, 245, 264, 191, 191, 191, 206, 212, 212,   212, 212, 206, 221, 221, 213, 213, 212, 4, 3,  22, 162, 206, 15, 23, 16, 23, 138, 150, 129,  25, 24, 141, 20, 16, 143, 1, 141, 129, 129,  61, 37, 53, 150, 53, 53, 53, 129, 115, 302,   299, 302, 140, 34, 1, 5, 22, 114, 160, 75,   140, 25, 68, 68, 41, 114, 24, 20, 19, 130,   124, 23, 96, 22, 22, 37, 22, 67, 22, 67,  59, 24, 22, 28, 67, 23, 148, 22, 25, 23,  23, 23, 23, 22, 97, 140, 23, 23, 115, 22,   142, 25, 75, 88, 34, 44, 34, 75, 86, 34,  23, 22, 34, 34, 34, 24, 34, 93, 25, 25,  23, 23, 23, 23, 23, 11, 23, 25, 22, 22,  22, 1, 23, 23, 22, 22, 25, 15, 23, 140,   134, 25, 140, 1, 318, 318, 318, 318, 318, 318,   318, 140, 318, 318, 318, 318, 318, 318, 318, 318,   140, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, 318, 318, 318, 318, 318,   318, 318, 318, 318, 318, };
#define YY_SHIFT_COUNT (575)
#define YY_SHIFT_MIN (0)
#define YY_SHIFT_MAX (2022)
static const unsigned short int yy_shift_ofst[] = {  1423, 1409, 1454, 1192, 1192, 610, 1252, 1410, 1517, 1684,  1684, 1684, 276, 0, 0, 180, 1015, 1684, 1684, 1684,  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,  1049, 1049, 1121, 1121, 54, 487, 610, 610, 610, 610,   610, 40, 110, 219, 289, 396, 439, 509, 548, 618,   657, 727, 766, 836, 995, 1015, 1015, 1015, 1015, 1015,  1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015, 1015,  1015, 1015, 1015, 1035, 1015, 1138, 880, 880, 1577, 1684,  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,  1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,  1684, 1684, 1684, 1705, 1684, 1684, 1684, 1684, 1684, 1684,  1684, 1684, 1684, 1684, 1684, 1684, 1684, 146, 84, 84,  84, 84, 84, 277, 315, 401, 97, 461, 251, 66,  66, 51, 1156, 66, 66, 324, 324, 66, 452, 452,   452, 452, 133, 114, 114, 4, 11, 2041, 2041, 621,   621, 621, 567, 398, 398, 398, 398, 937, 937, 228,   251, 331, 1052, 66, 66, 66, 66, 66, 66, 66,  66, 66, 66, 66, 66, 66, 66, 66, 66, 66,  66, 66, 66, 557, 557, 66, 9, 25, 25, 745,   745, 967, 1088, 2041, 2041, 2041, 2041, 2041, 2041, 2041,   255, 317, 317, 514, 403, 620, 471, 672, 781, 891,   675, 66, 66, 66, 66, 66, 66, 66, 66, 66,  66, 508, 66, 66, 66, 66, 66, 66, 66, 66,  66, 66, 66, 66, 790, 790, 790, 66, 66, 66,   338, 66, 66, 66, 516, 1084, 66, 66, 993, 66,  66, 66, 66, 66, 66, 66, 66, 732, 1083, 563,   994, 994, 994, 994, 337, 563, 563, 1028, 987, 897,  1119, 262, 1214, 1271, 1112, 1214, 1112, 1268, 1239, 262,   262, 1239, 262, 1271, 1268, 1302, 1354, 1278, 1168, 1168,  1168, 1112, 1303, 1303, 815, 1311, 1264, 1364, 1657, 1657,  1595, 1595, 1701, 1701, 1595, 1592, 1596, 1724, 1601, 1606,  1708, 1601, 1606, 1741, 1741, 1741, 1741, 1595, 1749, 1623,  1596, 1596, 1623, 1724, 1708, 1623, 1708, 1623, 1595, 1749,  1613, 1725, 1595, 1749, 1770, 1595, 1749, 1595, 1749, 1770,  1692, 1692, 1692, 1744, 1787, 1787, 1770, 1692, 1689, 1692,  1744, 1692, 1692, 1652, 1807, 1720, 1720, 1770, 1699, 1729,  1699, 1729, 1699, 1729, 1699, 1729, 1595, 1757, 1757, 1768,  1768, 1601, 1606, 1829, 1595, 1698, 1601, 1710, 1718, 1623,  1839, 1853, 1853, 1865, 1865, 1865, 2041, 2041, 2041, 2041,  2041, 2041, 2041, 2041, 2041, 2041, 2041, 2041, 2041, 2041,  2041, 193, 837, 1194, 1212, 506, 832, 1054, 1390, 925,  1435, 1394, 1102, 1332, 1419, 1196, 1420, 1425, 1433, 1447,  1457, 1488, 1443, 1379, 1572, 1455, 1503, 1453, 1495, 1515,  1506, 1526, 1460, 1489, 1581, 1622, 1534, 667, 1894, 1896,  1878, 1739, 1888, 1889, 1881, 1883, 1769, 1758, 1780, 1885,  1885, 1887, 1771, 1893, 1772, 1898, 1915, 1776, 1789, 1885,  1790, 1859, 1884, 1885, 1773, 1869, 1871, 1872, 1873, 1798,  1813, 1899, 1792, 1933, 1930, 1914, 1823, 1778, 1874, 1916,  1875, 1864, 1903, 1800, 1831, 1922, 1927, 1929, 1819, 1826,  1931, 1890, 1932, 1934, 1928, 1936, 1892, 1901, 1937, 1856,  1935, 1940, 1897, 1918, 1942, 1818, 1945, 1946, 1947, 1948,  1943, 1949, 1951, 1877, 1835, 1953, 1954, 1863, 1950, 1957,  1838, 1956, 1952, 1955, 1958, 1959, 1895, 1907, 1902, 1941,  1912, 1904, 1960, 1967, 1969, 1971, 1973, 1974, 1962, 1977,  1956, 1978, 1979, 1980, 1981, 1982, 1983, 1986, 1994, 1987,  1988, 1989, 1990, 1992, 1993, 1991, 1886, 1879, 1882, 1891,  1900, 1996, 1995, 2002, 2010, 2022, };
#define YY_REDUCE_COUNT (410)
#define YY_REDUCE_MIN  (-272)
#define YY_REDUCE_MAX  (1696)
static const short yy_reduce_ofst[] = {   109, 113, 272, 760, -178, -176, -192, -183, -180, -134,   213, 220, 371, -208, -205, -272, -197, 611, 632, 765,   786, 392, 943, 989, 503, 651, 1039, -18, 702, 821,   710, 812, -188, 380, -187, 555, 662, 1055, 1063, 1065,  1080, -267, -267, -267, -267, -267, -267, -267, -267, -267,  -267, -267, -267, -267, -267, -267, -267, -267, -267, -267,  -267, -267, -267, -267, -267, -267, -267, -267, -267, -267,  -267, -267, -267, -267, -267, -267, -267, -267, 636, 811,   917, 936, 1006, 1008, 1017, 1060, 1064, 1069, 1075, 1105,  1118, 1123, 1125, 1134, 1140, 1159, 1165, 1169, 1174, 1179,  1181, 1184, 1186, 1201, 1246, 1259, 1262, 1281, 1293, 1299,  1313, 1327, 1341, 1352, 1356, 1358, 1362, 1366, 1395, 1403,  1406, 1411, 1424, 1436, 1439, 1450, 1452, -267, -267, -267,  -267, -267, -267, -267, -267, 224, -267, 446, -24, 275,   546, 518, 573, 560, 53, -181, -111, 485, 606, 671,   606, 671, 683, 8, 93, -267, -267, -267, -267, 155,   155, 155, 181, 242, 264, 486, 489, -218, 393, 227,   604, 347, 347, -171, 431, 650, 715, -166, 562, 609,   716, 764, 18, 823, 769, 833, 838, 957, 759, 119,   923, 226, 1014, 542, 603, 451, 949, 654, 659, 762,   964, -4, 778, 961, 712, 1082, 1100, 1111, 1026, 1117,  -204, -174, -151, -8, 77, 198, 305, 327, 388, 540,   839, 968, 982, 985, 1004, 1023, 1070, 1086, 1097, 1130,  1190, 1163, 1199, 1284, 1297, 1300, 1314, 1339, 1353, 1391,  1402, 1413, 1416, 1417, 803, 1376, 1400, 1428, 1437, 1446,  1378, 1461, 1464, 1465, 1249, 1329, 1466, 1467, 1414, 1468,   305, 1469, 1470, 1471, 1472, 1482, 1483, 1389, 1392, 1438,  1426, 1427, 1432, 1434, 1378, 1438, 1438, 1440, 1474, 1499,  1399, 1421, 1430, 1456, 1441, 1442, 1444, 1415, 1473, 1431,  1445, 1476, 1449, 1478, 1418, 1479, 1477, 1485, 1493, 1494,  1496, 1458, 1475, 1480, 1459, 1490, 1484, 1518, 1448, 1451,  1537, 1538, 1463, 1481, 1541, 1486, 1487, 1491, 1500, 1504,  1520, 1505, 1509, 1525, 1527, 1529, 1530, 1563, 1571, 1528,  1501, 1507, 1532, 1510, 1542, 1535, 1548, 1540, 1583, 1585,  1497, 1508, 1589, 1591, 1573, 1599, 1597, 1603, 1605, 1574,  1590, 1593, 1598, 1587, 1594, 1600, 1604, 1602, 1607, 1610,  1608, 1611, 1612, 1519, 1531, 1552, 1560, 1624, 1586, 1588,  1609, 1614, 1615, 1617, 1618, 1620, 1646, 1533, 1536, 1616,  1619, 1621, 1626, 1578, 1654, 1584, 1628, 1625, 1635, 1637,  1664, 1674, 1675, 1693, 1694, 1695, 1627, 1629, 1631, 1681,  1676, 1677, 1678, 1679, 1686, 1672, 1673, 1682, 1683, 1685,  1696, }; static const YYACTIONTYPE yy_default[] = {  1637, 1637, 1637, 1466, 1234, 1345, 1234, 1234, 1234, 1466,  1466, 1466, 1234, 1375, 1375, 1519, 1267, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1465, 1234, 1234,  1234, 1234, 1554, 1554, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1384, 1234, 1391, 1234, 1234, 1234, 1234, 1234,  1467, 1468, 1234, 1234, 1234, 1518, 1520, 1483, 1398, 1397,  1396, 1395, 1501, 1362, 1389, 1382, 1386, 1461, 1462, 1460,  1464, 1468, 1467, 1234, 1385, 1432, 1446, 1431, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1440, 1445, 1451,  1444, 1441, 1434, 1433, 1435, 1234, 1436, 1234, 1258, 1234,  1234, 1255, 1309, 1234, 1234, 1234, 1234, 1234, 1538, 1537,  1234, 1234, 1267, 1426, 1425, 1437, 1438, 1448, 1447, 1526,  1590, 1589, 1484, 1234, 1234, 1234, 1234, 1234, 1234, 1554,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1554, 1554, 1234, 1267, 1554, 1554, 1263,  1263, 1369, 1234, 1533, 1336, 1336, 1336, 1336, 1345, 1336,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1523, 1521, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1341, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1583, 1234, 1496, 1323,  1341, 1341, 1341, 1341, 1343, 1324, 1322, 1335, 1268, 1241,  1629, 1401, 1390, 1342, 1364, 1390, 1364, 1626, 1388, 1401,  1401, 1388, 1401, 1342, 1626, 1284, 1606, 1279, 1375, 1375,  1375, 1364, 1369, 1369, 1463, 1342, 1335, 1234, 1629, 1629,  1350, 1350, 1628, 1628, 1350, 1484, 1613, 1410, 1383, 1369,  1312, 1383, 1369, 1318, 1318, 1318, 1318, 1350, 1252, 1388,  1613, 1613, 1388, 1410, 1312, 1388, 1312, 1388, 1350, 1252,  1500, 1623, 1350, 1252, 1474, 1350, 1252, 1350, 1252, 1474,  1310, 1310, 1310, 1299, 1234, 1234, 1474, 1310, 1284, 1310,  1299, 1310, 1310, 1572, 1234, 1478, 1478, 1474, 1368, 1363,  1368, 1363, 1368, 1363, 1368, 1363, 1350, 1564, 1564, 1378,  1378, 1383, 1369, 1469, 1350, 1234, 1383, 1381, 1379, 1388,  1302, 1586, 1586, 1582, 1582, 1582, 1634, 1634, 1533, 1599,  1267, 1267, 1267, 1267, 1599, 1286, 1286, 1268, 1268, 1267,  1599, 1234, 1234, 1234, 1234, 1234, 1234, 1594, 1234, 1528,  1485, 1354, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1539, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1415, 1234, 1237,  1530, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1392,  1393, 1355, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1407,  1234, 1234, 1234, 1402, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1625, 1234, 1234, 1234, 1234, 1234, 1234, 1499,  1498, 1234, 1234, 1352, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1282, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1380, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1234, 1569, 1370, 1234, 1234,  1616, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234, 1234,  1234, 1234, 1234, 1234, 1234, 1610, 1326, 1417, 1234, 1416,  1420, 1256, 1234, 1246, 1234, 1234, };
#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {  0,  0,   59,   59,   59,   59,  0,   59,   59,   59,  0,   59,   59,   59,   59,  0,  0,  0,   59,  0,  0,   59,  0,  0,  0,  0,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,  0,  0,  0,   59,   59,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,   59,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, };
#endif
struct yyStackEntry {  YYACTIONTYPE stateno;  YYCODETYPE major;  YYMINORTYPE minor; }; typedef struct yyStackEntry yyStackEntry; struct yyParser {  yyStackEntry *yytos;
#ifdef YYTRACKMAXSTACKDEPTH
 int yyhwm;
#endif
#ifndef YYNOERRORRECOVERY
 int yyerrcnt;
#endif
 sqlite3ParserARG_SDECL  sqlite3ParserCTX_SDECL
#if YYSTACKDEPTH<=0
 int yystksz;  yyStackEntry *yystack;  yyStackEntry yystk0;
#else
 yyStackEntry yystack[YYSTACKDEPTH];  yyStackEntry *yystackEnd;
#endif
}; typedef struct yyParser yyParser;
#ifndef NDEBUG
static FILE *yyTraceFILE = 0; static char *yyTracePrompt = 0;
#endif
#ifndef NDEBUG
SQLITE_PRIVATE void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt){  yyTraceFILE = TraceFILE;  yyTracePrompt = zTracePrompt;  if( yyTraceFILE==0 ) yyTracePrompt = 0;  else if( yyTracePrompt==0 ) yyTraceFILE = 0; }
#endif
#if defined(YYCOVERAGE) || !defined(NDEBUG)
static const char *const yyTokenName[] = {  "$",  "SEMI",  "EXPLAIN",  "QUERY",  "PLAN",  "BEGIN",  "TRANSACTION",  "DEFERRED",  "IMMEDIATE",  "EXCLUSIVE",  "COMMIT",  "END",  "ROLLBACK",  "SAVEPOINT",  "RELEASE",  "TO",  "TABLE",  "CREATE",  "IF",  "NOT",  "EXISTS",  "TEMP",  "LP",  "RP",  "AS",  "COMMA",  "WITHOUT",  "ABORT",  "ACTION",  "AFTER",  "ANALYZE",  "ASC",  "ATTACH",  "BEFORE",  "BY",  "CASCADE",  "CAST",  "CONFLICT",  "DATABASE",  "DESC",  "DETACH",  "EACH",  "FAIL",  "OR",  "AND",  "IS",  "MATCH",  "LIKE_KW",  "BETWEEN",  "IN",  "ISNULL",  "NOTNULL",  "NE",  "EQ",  "GT",  "LE",  "LT",  "GE",  "ESCAPE",  "ID",  "COLUMNKW",  "DO",  "FOR",  "IGNORE",  "INITIALLY",  "INSTEAD",  "NO",  "KEY",  "OF",  "OFFSET",  "PRAGMA",  "RAISE",  "RECURSIVE",  "REPLACE",  "RESTRICT",  "ROW",  "ROWS",  "TRIGGER",  "VACUUM",  "VIEW",  "VIRTUAL",  "WITH",  "NULLS",  "FIRST",  "LAST",  "CURRENT",  "FOLLOWING",  "PARTITION",  "PRECEDING",  "RANGE",  "UNBOUNDED",  "EXCLUDE",  "GROUPS",  "OTHERS",  "TIES",  "GENERATED",  "ALWAYS",  "MATERIALIZED",  "REINDEX",  "RENAME",  "CTIME_KW",  "ANY",  "BITAND",  "BITOR",  "LSHIFT",  "RSHIFT",  "PLUS",  "MINUS",  "STAR",  "SLASH",  "REM",  "CONCAT",  "COLLATE",  "BITNOT",  "ON",  "INDEXED",  "STRING",  "JOIN_KW",  "CONSTRAINT",  "DEFAULT",  "NULL",  "PRIMARY",  "UNIQUE",  "CHECK",  "REFERENCES",  "AUTOINCR",  "INSERT",  "DELETE",  "UPDATE",  "SET",  "DEFERRABLE",  "FOREIGN",  "DROP",  "UNION",  "ALL",  "EXCEPT",  "INTERSECT",  "SELECT",  "VALUES",  "DISTINCT",  "DOT",  "FROM",  "JOIN",  "USING",  "ORDER",  "GROUP",  "HAVING",  "LIMIT",  "WHERE",  "RETURNING",  "INTO",  "NOTHING",  "FLOAT",  "BLOB",  "INTEGER",  "VARIABLE",  "CASE",  "WHEN",  "THEN",  "ELSE",  "INDEX",  "ALTER",  "ADD",  "WINDOW",  "OVER",  "FILTER",  "COLUMN",  "AGG_FUNCTION",  "AGG_COLUMN",  "TRUEFALSE",  "ISNOT",  "FUNCTION",  "UMINUS",  "UPLUS",  "TRUTH",  "REGISTER",  "VECTOR",  "SELECT_COLUMN",  "IF_NULL_ROW",  "ASTERISK",  "SPAN",  "ERROR",  "SPACE",  "ILLEGAL",  "input",  "cmdlist",  "ecmd",  "cmdx",  "explain",  "cmd",  "transtype",  "trans_opt",  "nm",  "savepoint_opt",  "create_table",  "create_table_args",  "createkw",  "temp",  "ifnotexists",  "dbnm",  "columnlist",  "conslist_opt",  "table_option_set",  "select",  "table_option",  "columnname",  "carglist",  "typetoken",  "typename",  "signed",  "plus_num",  "minus_num",  "scanpt",  "scantok",  "ccons",  "term",  "expr",  "onconf",  "sortorder",  "autoinc",  "eidlist_opt",  "refargs",  "defer_subclause",  "generated",  "refarg",  "refact",  "init_deferred_pred_opt",  "conslist",  "tconscomma",  "tcons",  "sortlist",  "eidlist",  "defer_subclause_opt",  "orconf",  "resolvetype",  "raisetype",  "ifexists",  "fullname",  "selectnowith",  "oneselect",  "wqlist",  "multiselect_op",  "distinct",  "selcollist",  "from",  "where_opt",  "groupby_opt",  "having_opt",  "orderby_opt",  "limit_opt",  "window_clause",  "values",  "nexprlist",  "sclp",  "as",  "seltablist",  "stl_prefix",  "joinop",  "indexed_opt",  "on_opt",  "using_opt",  "exprlist",  "xfullname",  "idlist",  "nulls",  "with",  "where_opt_ret",  "setlist",  "insert_cmd",  "idlist_opt",  "upsert",  "returning",  "filter_over",  "likeop",  "between_op",  "in_op",  "paren_exprlist",  "case_operand",  "case_exprlist",  "case_else",  "uniqueflag",  "collate",  "vinto",  "nmnum",  "trigger_decl",  "trigger_cmd_list",  "trigger_time",  "trigger_event",  "foreach_clause",  "when_clause",  "trigger_cmd",  "trnm",  "tridxby",  "database_kw_opt",  "key_opt",  "add_column_fullname",  "kwcolumn_opt",  "create_vtab",  "vtabarglist",  "vtabarg",  "vtabargtoken",  "lp",  "anylist",  "wqitem",  "wqas",  "windowdefn_list",  "windowdefn",  "window",  "frame_opt",  "part_opt",  "filter_clause",  "over_clause",  "range_or_rows",  "frame_bound",  "frame_bound_s",  "frame_bound_e",  "frame_exclude_opt",  "frame_exclude", };
#endif
#ifndef NDEBUG
static const char *const yyRuleName[] = {  "explain ::= EXPLAIN",  "explain ::= EXPLAIN QUERY PLAN",  "cmdx ::= cmd",  "cmd ::= BEGIN transtype trans_opt",  "transtype ::=",  "transtype ::= DEFERRED",  "transtype ::= IMMEDIATE",  "transtype ::= EXCLUSIVE",  "cmd ::= COMMIT|END trans_opt",  "cmd ::= ROLLBACK trans_opt",  "cmd ::= SAVEPOINT nm",  "cmd ::= RELEASE savepoint_opt nm",  "cmd ::= ROLLBACK trans_opt TO savepoint_opt nm",  "create_table ::= createkw temp TABLE ifnotexists nm dbnm",  "createkw ::= CREATE",  "ifnotexists ::=",  "ifnotexists ::= IF NOT EXISTS",  "temp ::= TEMP",  "temp ::=",  "create_table_args ::= LP columnlist conslist_opt RP table_option_set",  "create_table_args ::= AS select",  "table_option_set ::=",  "table_option_set ::= table_option_set COMMA table_option",  "table_option ::= WITHOUT nm",  "table_option ::= nm",  "columnname ::= nm typetoken",  "typetoken ::=",  "typetoken ::= typename LP signed RP",  "typetoken ::= typename LP signed COMMA signed RP",  "typename ::= typename ID|STRING",  "scanpt ::=",  "scantok ::=",  "ccons ::= CONSTRAINT nm",  "ccons ::= DEFAULT scantok term",  "ccons ::= DEFAULT LP expr RP",  "ccons ::= DEFAULT PLUS scantok term",  "ccons ::= DEFAULT MINUS scantok term",  "ccons ::= DEFAULT scantok ID|INDEXED",  "ccons ::= NOT NULL onconf",  "ccons ::= PRIMARY KEY sortorder onconf autoinc",  "ccons ::= UNIQUE onconf",  "ccons ::= CHECK LP expr RP",  "ccons ::= REFERENCES nm eidlist_opt refargs",  "ccons ::= defer_subclause",  "ccons ::= COLLATE ID|STRING",  "generated ::= LP expr RP",  "generated ::= LP expr RP ID",  "autoinc ::=",  "autoinc ::= AUTOINCR",  "refargs ::=",  "refargs ::= refargs refarg",  "refarg ::= MATCH nm",  "refarg ::= ON INSERT refact",  "refarg ::= ON DELETE refact",  "refarg ::= ON UPDATE refact",  "refact ::= SET NULL",  "refact ::= SET DEFAULT",  "refact ::= CASCADE",  "refact ::= RESTRICT",  "refact ::= NO ACTION",  "defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt",  "defer_subclause ::= DEFERRABLE init_deferred_pred_opt",  "init_deferred_pred_opt ::=",  "init_deferred_pred_opt ::= INITIALLY DEFERRED",  "init_deferred_pred_opt ::= INITIALLY IMMEDIATE",  "conslist_opt ::=",  "tconscomma ::= COMMA",  "tcons ::= CONSTRAINT nm",  "tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf",  "tcons ::= UNIQUE LP sortlist RP onconf",  "tcons ::= CHECK LP expr RP onconf",  "tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt",  "defer_subclause_opt ::=",  "onconf ::=",  "onconf ::= ON CONFLICT resolvetype",  "orconf ::=",  "orconf ::= OR resolvetype",  "resolvetype ::= IGNORE",  "resolvetype ::= REPLACE",  "cmd ::= DROP TABLE ifexists fullname",  "ifexists ::= IF EXISTS",  "ifexists ::=",  "cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select",  "cmd ::= DROP VIEW ifexists fullname",  "cmd ::= select",  "select ::= WITH wqlist selectnowith",  "select ::= WITH RECURSIVE wqlist selectnowith",  "select ::= selectnowith",  "selectnowith ::= selectnowith multiselect_op oneselect",  "multiselect_op ::= UNION",  "multiselect_op ::= UNION ALL",  "multiselect_op ::= EXCEPT|INTERSECT",  "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt",  "oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt",  "values ::= VALUES LP nexprlist RP",  "values ::= values COMMA LP nexprlist RP",  "distinct ::= DISTINCT",  "distinct ::= ALL",  "distinct ::=",  "sclp ::=",  "selcollist ::= sclp scanpt expr scanpt as",  "selcollist ::= sclp scanpt STAR",  "selcollist ::= sclp scanpt nm DOT STAR",  "as ::= AS nm",  "as ::=",  "from ::=",  "from ::= FROM seltablist",  "stl_prefix ::= seltablist joinop",  "stl_prefix ::=",  "seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt",  "seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_opt using_opt",  "seltablist ::= stl_prefix LP select RP as on_opt using_opt",  "seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt",  "dbnm ::=",  "dbnm ::= DOT nm",  "fullname ::= nm",  "fullname ::= nm DOT nm",  "xfullname ::= nm",  "xfullname ::= nm DOT nm",  "xfullname ::= nm DOT nm AS nm",  "xfullname ::= nm AS nm",  "joinop ::= COMMA|JOIN",  "joinop ::= JOIN_KW JOIN",  "joinop ::= JOIN_KW nm JOIN",  "joinop ::= JOIN_KW nm nm JOIN",  "on_opt ::= ON expr",  "on_opt ::=",  "indexed_opt ::=",  "indexed_opt ::= INDEXED BY nm",  "indexed_opt ::= NOT INDEXED",  "using_opt ::= USING LP idlist RP",  "using_opt ::=",  "orderby_opt ::=",  "orderby_opt ::= ORDER BY sortlist",  "sortlist ::= sortlist COMMA expr sortorder nulls",  "sortlist ::= expr sortorder nulls",  "sortorder ::= ASC",  "sortorder ::= DESC",  "sortorder ::=",  "nulls ::= NULLS FIRST",  "nulls ::= NULLS LAST",  "nulls ::=",  "groupby_opt ::=",  "groupby_opt ::= GROUP BY nexprlist",  "having_opt ::=",  "having_opt ::= HAVING expr",  "limit_opt ::=",  "limit_opt ::= LIMIT expr",  "limit_opt ::= LIMIT expr OFFSET expr",  "limit_opt ::= LIMIT expr COMMA expr",  "cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret orderby_opt limit_opt",  "where_opt ::=",  "where_opt ::= WHERE expr",  "where_opt_ret ::=",  "where_opt_ret ::= WHERE expr",  "where_opt_ret ::= RETURNING selcollist",  "where_opt_ret ::= WHERE expr RETURNING selcollist",  "cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret orderby_opt limit_opt",  "setlist ::= setlist COMMA nm EQ expr",  "setlist ::= setlist COMMA LP idlist RP EQ expr",  "setlist ::= nm EQ expr",  "setlist ::= LP idlist RP EQ expr",  "cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert",  "cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning",  "upsert ::=",  "upsert ::= RETURNING selcollist",  "upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert",  "upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert",  "upsert ::= ON CONFLICT DO NOTHING returning",  "upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning",  "returning ::= RETURNING selcollist",  "insert_cmd ::= INSERT orconf",  "insert_cmd ::= REPLACE",  "idlist_opt ::=",  "idlist_opt ::= LP idlist RP",  "idlist ::= idlist COMMA nm",  "idlist ::= nm",  "expr ::= LP expr RP",  "expr ::= ID|INDEXED",  "expr ::= JOIN_KW",  "expr ::= nm DOT nm",  "expr ::= nm DOT nm DOT nm",  "term ::= NULL|FLOAT|BLOB",  "term ::= STRING",  "term ::= INTEGER",  "expr ::= VARIABLE",  "expr ::= expr COLLATE ID|STRING",  "expr ::= CAST LP expr AS typetoken RP",  "expr ::= ID|INDEXED LP distinct exprlist RP",  "expr ::= ID|INDEXED LP STAR RP",  "expr ::= ID|INDEXED LP distinct exprlist RP filter_over",  "expr ::= ID|INDEXED LP STAR RP filter_over",  "term ::= CTIME_KW",  "expr ::= LP nexprlist COMMA expr RP",  "expr ::= expr AND expr",  "expr ::= expr OR expr",  "expr ::= expr LT|GT|GE|LE expr",  "expr ::= expr EQ|NE expr",  "expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr",  "expr ::= expr PLUS|MINUS expr",  "expr ::= expr STAR|SLASH|REM expr",  "expr ::= expr CONCAT expr",  "likeop ::= NOT LIKE_KW|MATCH",  "expr ::= expr likeop expr",  "expr ::= expr likeop expr ESCAPE expr",  "expr ::= expr ISNULL|NOTNULL",  "expr ::= expr NOT NULL",  "expr ::= expr IS expr",  "expr ::= expr IS NOT expr",  "expr ::= NOT expr",  "expr ::= BITNOT expr",  "expr ::= PLUS|MINUS expr",  "between_op ::= BETWEEN",  "between_op ::= NOT BETWEEN",  "expr ::= expr between_op expr AND expr",  "in_op ::= IN",  "in_op ::= NOT IN",  "expr ::= expr in_op LP exprlist RP",  "expr ::= LP select RP",  "expr ::= expr in_op LP select RP",  "expr ::= expr in_op nm dbnm paren_exprlist",  "expr ::= EXISTS LP select RP",  "expr ::= CASE case_operand case_exprlist case_else END",  "case_exprlist ::= case_exprlist WHEN expr THEN expr",  "case_exprlist ::= WHEN expr THEN expr",  "case_else ::= ELSE expr",  "case_else ::=",  "case_operand ::= expr",  "case_operand ::=",  "exprlist ::=",  "nexprlist ::= nexprlist COMMA expr",  "nexprlist ::= expr",  "paren_exprlist ::=",  "paren_exprlist ::= LP exprlist RP",  "cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt",  "uniqueflag ::= UNIQUE",  "uniqueflag ::=",  "eidlist_opt ::=",  "eidlist_opt ::= LP eidlist RP",  "eidlist ::= eidlist COMMA nm collate sortorder",  "eidlist ::= nm collate sortorder",  "collate ::=",  "collate ::= COLLATE ID|STRING",  "cmd ::= DROP INDEX ifexists fullname",  "cmd ::= VACUUM vinto",  "cmd ::= VACUUM nm vinto",  "vinto ::= INTO expr",  "vinto ::=",  "cmd ::= PRAGMA nm dbnm",  "cmd ::= PRAGMA nm dbnm EQ nmnum",  "cmd ::= PRAGMA nm dbnm LP nmnum RP",  "cmd ::= PRAGMA nm dbnm EQ minus_num",  "cmd ::= PRAGMA nm dbnm LP minus_num RP",  "plus_num ::= PLUS INTEGER|FLOAT",  "minus_num ::= MINUS INTEGER|FLOAT",  "cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END",  "trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause",  "trigger_time ::= BEFORE|AFTER",  "trigger_time ::= INSTEAD OF",  "trigger_time ::=",  "trigger_event ::= DELETE|INSERT",  "trigger_event ::= UPDATE",  "trigger_event ::= UPDATE OF idlist",  "when_clause ::=",  "when_clause ::= WHEN expr",  "trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI",  "trigger_cmd_list ::= trigger_cmd SEMI",  "trnm ::= nm DOT nm",  "tridxby ::= INDEXED BY nm",  "tridxby ::= NOT INDEXED",  "trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt",  "trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt",  "trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt",  "trigger_cmd ::= scanpt select scanpt",  "expr ::= RAISE LP IGNORE RP",  "expr ::= RAISE LP raisetype COMMA nm RP",  "raisetype ::= ROLLBACK",  "raisetype ::= ABORT",  "raisetype ::= FAIL",  "cmd ::= DROP TRIGGER ifexists fullname",  "cmd ::= ATTACH database_kw_opt expr AS expr key_opt",  "cmd ::= DETACH database_kw_opt expr",  "key_opt ::=",  "key_opt ::= KEY expr",  "cmd ::= REINDEX",  "cmd ::= REINDEX nm dbnm",  "cmd ::= ANALYZE",  "cmd ::= ANALYZE nm dbnm",  "cmd ::= ALTER TABLE fullname RENAME TO nm",  "cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist",  "cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm",  "add_column_fullname ::= fullname",  "cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm",  "cmd ::= create_vtab",  "cmd ::= create_vtab LP vtabarglist RP",  "create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm",  "vtabarg ::=",  "vtabargtoken ::= ANY",  "vtabargtoken ::= lp anylist RP",  "lp ::= LP",  "with ::= WITH wqlist",  "with ::= WITH RECURSIVE wqlist",  "wqas ::= AS",  "wqas ::= AS MATERIALIZED",  "wqas ::= AS NOT MATERIALIZED",  "wqitem ::= nm eidlist_opt wqas LP select RP",  "wqlist ::= wqitem",  "wqlist ::= wqlist COMMA wqitem",  "windowdefn_list ::= windowdefn",  "windowdefn_list ::= windowdefn_list COMMA windowdefn",  "windowdefn ::= nm AS LP window RP",  "window ::= PARTITION BY nexprlist orderby_opt frame_opt",  "window ::= nm PARTITION BY nexprlist orderby_opt frame_opt",  "window ::= ORDER BY sortlist frame_opt",  "window ::= nm ORDER BY sortlist frame_opt",  "window ::= frame_opt",  "window ::= nm frame_opt",  "frame_opt ::=",  "frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt",  "frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt",  "range_or_rows ::= RANGE|ROWS|GROUPS",  "frame_bound_s ::= frame_bound",  "frame_bound_s ::= UNBOUNDED PRECEDING",  "frame_bound_e ::= frame_bound",  "frame_bound_e ::= UNBOUNDED FOLLOWING",  "frame_bound ::= expr PRECEDING|FOLLOWING",  "frame_bound ::= CURRENT ROW",  "frame_exclude_opt ::=",  "frame_exclude_opt ::= EXCLUDE frame_exclude",  "frame_exclude ::= NO OTHERS",  "frame_exclude ::= CURRENT ROW",  "frame_exclude ::= GROUP|TIES",  "window_clause ::= WINDOW windowdefn_list",  "filter_over ::= filter_clause over_clause",  "filter_over ::= over_clause",  "filter_over ::= filter_clause",  "over_clause ::= OVER LP window RP",  "over_clause ::= OVER nm",  "filter_clause ::= FILTER LP WHERE expr RP",  "input ::= cmdlist",  "cmdlist ::= cmdlist ecmd",  "cmdlist ::= ecmd",  "ecmd ::= SEMI",  "ecmd ::= cmdx SEMI",  "ecmd ::= explain cmdx SEMI",  "trans_opt ::=",  "trans_opt ::= TRANSACTION",  "trans_opt ::= TRANSACTION nm",  "savepoint_opt ::= SAVEPOINT",  "savepoint_opt ::=",  "cmd ::= create_table create_table_args",  "table_option_set ::= table_option",  "columnlist ::= columnlist COMMA columnname carglist",  "columnlist ::= columnname carglist",  "nm ::= ID|INDEXED",  "nm ::= STRING",  "nm ::= JOIN_KW",  "typetoken ::= typename",  "typename ::= ID|STRING",  "signed ::= plus_num",  "signed ::= minus_num",  "carglist ::= carglist ccons",  "carglist ::=",  "ccons ::= NULL onconf",  "ccons ::= GENERATED ALWAYS AS generated",  "ccons ::= AS generated",  "conslist_opt ::= COMMA conslist",  "conslist ::= conslist tconscomma tcons",  "conslist ::= tcons",  "tconscomma ::=",  "defer_subclause_opt ::= defer_subclause",  "resolvetype ::= raisetype",  "selectnowith ::= oneselect",  "oneselect ::= values",  "sclp ::= selcollist COMMA",  "as ::= ID|STRING",  "returning ::=",  "expr ::= term",  "likeop ::= LIKE_KW|MATCH",  "exprlist ::= nexprlist",  "nmnum ::= plus_num",  "nmnum ::= nm",  "nmnum ::= ON",  "nmnum ::= DELETE",  "nmnum ::= DEFAULT",  "plus_num ::= INTEGER|FLOAT",  "foreach_clause ::=",  "foreach_clause ::= FOR EACH ROW",  "trnm ::= nm",  "tridxby ::=",  "database_kw_opt ::= DATABASE",  "database_kw_opt ::=",  "kwcolumn_opt ::=",  "kwcolumn_opt ::= COLUMNKW",  "vtabarglist ::= vtabarg",  "vtabarglist ::= vtabarglist COMMA vtabarg",  "vtabarg ::= vtabarg vtabargtoken",  "anylist ::=",  "anylist ::= anylist LP anylist RP",  "anylist ::= anylist ANY",  "with ::=", };
#endif
#if YYSTACKDEPTH<=0
static int yyGrowStack(yyParser *p){  int newSize;  int idx;  yyStackEntry *pNew;  newSize = p->yystksz*2 + 100;  idx = p->yytos ? (int)(p->yytos - p->yystack) : 0;  if( p->yystack==&p->yystk0 ){  pNew = malloc(newSize*sizeof(pNew[0]));  if( pNew ) pNew[0] = p->yystk0;  }else{  pNew = realloc(p->yystack, newSize*sizeof(pNew[0]));  }  if( pNew ){  p->yystack = pNew;  p->yytos = &p->yystack[idx];
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE,"%sStack grows from %d to %d entries.\n",  yyTracePrompt, p->yystksz, newSize);  }
#endif
 p->yystksz = newSize;  }  return pNew==0; }
#endif
#ifndef YYMALLOCARGTYPE
# define YYMALLOCARGTYPE size_t
#endif
SQLITE_PRIVATE void sqlite3ParserInit(void *yypRawParser sqlite3ParserCTX_PDECL){  yyParser *yypParser = (yyParser*)yypRawParser;  sqlite3ParserCTX_STORE
#ifdef YYTRACKMAXSTACKDEPTH
 yypParser->yyhwm = 0;
#endif
#if YYSTACKDEPTH<=0
 yypParser->yytos = NULL;  yypParser->yystack = NULL;  yypParser->yystksz = 0;  if( yyGrowStack(yypParser) ){  yypParser->yystack = &yypParser->yystk0;  yypParser->yystksz = 1;  }
#endif
#ifndef YYNOERRORRECOVERY
 yypParser->yyerrcnt = -1;
#endif
 yypParser->yytos = yypParser->yystack;  yypParser->yystack[0].stateno = 0;  yypParser->yystack[0].major = 0;
#if YYSTACKDEPTH>0
 yypParser->yystackEnd = &yypParser->yystack[YYSTACKDEPTH-1];
#endif
}
#ifndef sqlite3Parser_ENGINEALWAYSONSTACK
SQLITE_PRIVATE void *sqlite3ParserAlloc(void *(*mallocProc)(YYMALLOCARGTYPE) sqlite3ParserCTX_PDECL){  yyParser *yypParser;  yypParser = (yyParser*)(*mallocProc)( (YYMALLOCARGTYPE)sizeof(yyParser) );  if( yypParser ){  sqlite3ParserCTX_STORE  sqlite3ParserInit(yypParser sqlite3ParserCTX_PARAM);  }  return (void*)yypParser; }
#endif
static void yy_destructor(  yyParser *yypParser,  YYCODETYPE yymajor,  YYMINORTYPE *yypminor ){  sqlite3ParserARG_FETCH  sqlite3ParserCTX_FETCH  switch( yymajor ){  case 203:  case 238:  case 239:  case 251: { sqlite3SelectDelete(pParse->db, (yypminor->yy303)); }  break;  case 215:  case 216:  case 245:  case 247:  case 259:  case 266:  case 277:  case 279:  case 282:  case 289:  case 294:  case 310: { sqlite3ExprDelete(pParse->db, (yypminor->yy626)); }  break;  case 220:  case 230:  case 231:  case 243:  case 246:  case 248:  case 252:  case 253:  case 261:  case 267:  case 276:  case 278:  case 309: { sqlite3ExprListDelete(pParse->db, (yypminor->yy562)); }  break;  case 237:  case 244:  case 255:  case 256:  case 262: { sqlite3SrcListDelete(pParse->db, (yypminor->yy607)); }  break;  case 240: { sqlite3WithDelete(pParse->db, (yypminor->yy43)); }  break;  case 250:  case 305: { sqlite3WindowListDelete(pParse->db, (yypminor->yy375)); }  break;  case 260:  case 263:  case 269: { sqlite3IdListDelete(pParse->db, (yypminor->yy240)); }  break;  case 272:  case 306:  case 307:  case 308:  case 311: { sqlite3WindowDelete(pParse->db, (yypminor->yy375)); }  break;  case 285:  case 290: { sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy95)); }  break;  case 287: { sqlite3IdListDelete(pParse->db, (yypminor->yy570).b); }  break;  case 313:  case 314:  case 315: { sqlite3ExprDelete(pParse->db, (yypminor->yy81).pExpr); }  break;  default: break;  } } static void yy_pop_parser_stack(yyParser *pParser){  yyStackEntry *yytos;  assert( pParser->yytos!=0 );  assert( pParser->yytos > pParser->yystack );  yytos = pParser->yytos--;
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE,"%sPopping %s\n",  yyTracePrompt,  yyTokenName[yytos->major]);  }
#endif
 yy_destructor(pParser, yytos->major, &yytos->minor); } SQLITE_PRIVATE void sqlite3ParserFinalize(void *p){  yyParser *pParser = (yyParser*)p;  while( pParser->yytos>pParser->yystack ) yy_pop_parser_stack(pParser);
#if YYSTACKDEPTH<=0
 if( pParser->yystack!=&pParser->yystk0 ) free(pParser->yystack);
#endif
}
#ifndef sqlite3Parser_ENGINEALWAYSONSTACK
SQLITE_PRIVATE void sqlite3ParserFree(  void *p,  void (*freeProc)(void*) ){
#ifndef YYPARSEFREENEVERNULL
 if( p==0 ) return;
#endif
 sqlite3ParserFinalize(p);  (*freeProc)(p); }
#endif
#ifdef YYTRACKMAXSTACKDEPTH
SQLITE_PRIVATE int sqlite3ParserStackPeak(void *p){  yyParser *pParser = (yyParser*)p;  return pParser->yyhwm; }
#endif
#if defined(YYCOVERAGE)
static unsigned char yycoverage[YYNSTATE][YYNTOKEN];
#endif
#if defined(YYCOVERAGE)
SQLITE_PRIVATE int sqlite3ParserCoverage(FILE *out){  int stateno, iLookAhead, i;  int nMissed = 0;  for(stateno=0; stateno<YYNSTATE; stateno++){  i = yy_shift_ofst[stateno];  for(iLookAhead=0; iLookAhead<YYNTOKEN; iLookAhead++){  if( yy_lookahead[i+iLookAhead]!=iLookAhead ) continue;  if( yycoverage[stateno][iLookAhead]==0 ) nMissed++;  if( out ){  fprintf(out,"State %d lookahead %s %s\n", stateno,  yyTokenName[iLookAhead],  yycoverage[stateno][iLookAhead] ? "ok" : "missed");  }  }  }  return nMissed; }
#endif
static YYACTIONTYPE yy_find_shift_action(  YYCODETYPE iLookAhead,  YYACTIONTYPE stateno ){  int i;  if( stateno>YY_MAX_SHIFT ) return stateno;  assert( stateno <= YY_SHIFT_COUNT );
#if defined(YYCOVERAGE)
 yycoverage[stateno][iLookAhead] = 1;
#endif
 do{  i = yy_shift_ofst[stateno];  assert( i>=0 );  assert( i<=YY_ACTTAB_COUNT );  assert( i+YYNTOKEN<=(int)YY_NLOOKAHEAD );  assert( iLookAhead!=YYNOCODE );  assert( iLookAhead < YYNTOKEN );  i += iLookAhead;  assert( i<(int)YY_NLOOKAHEAD );  if( yy_lookahead[i]!=iLookAhead ){
#ifdef YYFALLBACK
 YYCODETYPE iFallback;  assert( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0]) );  iFallback = yyFallback[iLookAhead];  if( iFallback!=0 ){
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",   yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);  }
#endif
 assert( yyFallback[iFallback]==0 );  iLookAhead = iFallback;  continue;  }
#endif
#ifdef YYWILDCARD
 {  int j = i - iLookAhead + YYWILDCARD;  assert( j<(int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])) );  if( yy_lookahead[j]==YYWILDCARD && iLookAhead>0 ){
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",   yyTracePrompt, yyTokenName[iLookAhead],   yyTokenName[YYWILDCARD]);  }
#endif
 return yy_action[j];  }  }
#endif
 return yy_default[stateno];  }else{  assert( i>=0 && i<(int)(sizeof(yy_action)/sizeof(yy_action[0])) );  return yy_action[i];  }  }while(1); } static YYACTIONTYPE yy_find_reduce_action(  YYACTIONTYPE stateno,  YYCODETYPE iLookAhead ){  int i;
#ifdef YYERRORSYMBOL
 if( stateno>YY_REDUCE_COUNT ){  return yy_default[stateno];  }
#else
 assert( stateno<=YY_REDUCE_COUNT );
#endif
 i = yy_reduce_ofst[stateno];  assert( iLookAhead!=YYNOCODE );  i += iLookAhead;
#ifdef YYERRORSYMBOL
 if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){  return yy_default[stateno];  }
#else
 assert( i>=0 && i<YY_ACTTAB_COUNT );  assert( yy_lookahead[i]==iLookAhead );
#endif
 return yy_action[i]; } static void yyStackOverflow(yyParser *yypParser){   sqlite3ParserARG_FETCH   sqlite3ParserCTX_FETCH
#ifndef NDEBUG
  if( yyTraceFILE ){   fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);   }
#endif
  while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);  sqlite3ErrorMsg(pParse, "parser stack overflow");   sqlite3ParserARG_STORE   sqlite3ParserCTX_STORE }
#ifndef NDEBUG
static void yyTraceShift(yyParser *yypParser, int yyNewState, const char *zTag){  if( yyTraceFILE ){  if( yyNewState<YYNSTATE ){  fprintf(yyTraceFILE,"%s%s '%s', go to state %d\n",   yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],   yyNewState);  }else{  fprintf(yyTraceFILE,"%s%s '%s', pending reduce %d\n",   yyTracePrompt, zTag, yyTokenName[yypParser->yytos->major],   yyNewState - YY_MIN_REDUCE);  }  } }
#else
# define yyTraceShift(X,Y,Z)
#endif
static void yy_shift(  yyParser *yypParser,  YYACTIONTYPE yyNewState,  YYCODETYPE yyMajor,  sqlite3ParserTOKENTYPE yyMinor ){  yyStackEntry *yytos;  yypParser->yytos++;
#ifdef YYTRACKMAXSTACKDEPTH
 if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){  yypParser->yyhwm++;  assert( yypParser->yyhwm == (int)(yypParser->yytos - yypParser->yystack) );  }
#endif
#if YYSTACKDEPTH>0
 if( yypParser->yytos>yypParser->yystackEnd ){  yypParser->yytos--;  yyStackOverflow(yypParser);  return;  }
#else
 if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz] ){  if( yyGrowStack(yypParser) ){  yypParser->yytos--;  yyStackOverflow(yypParser);  return;  }  }
#endif
 if( yyNewState > YY_MAX_SHIFT ){  yyNewState += YY_MIN_REDUCE - YY_MIN_SHIFTREDUCE;  }  yytos = yypParser->yytos;  yytos->stateno = yyNewState;  yytos->major = yyMajor;  yytos->minor.yy0 = yyMinor;  yyTraceShift(yypParser, yyNewState, "Shift"); } static const YYCODETYPE yyRuleInfoLhs[] = {   188,   188,   187,   189,   190,   190,   190,   190,   189,   189,   189,   189,   189,   194,   196,   198,   198,   197,   197,   195,   195,   202,   202,   204,   204,   205,   207,   207,   207,   208,   212,   213,   214,   214,   214,   214,   214,   214,   214,   214,   214,   214,   214,   214,   214,   223,   223,   219,   219,   221,   221,   224,   224,   224,   224,   225,   225,   225,   225,   225,   222,   222,   226,   226,   226,   201,   228,   229,   229,   229,   229,   229,   232,   217,   217,   233,   233,   234,   234,   189,   236,   236,   189,   189,   189,   203,   203,   203,   238,   241,   241,   241,   239,   239,   251,   251,   242,   242,   242,   253,   243,   243,   243,   254,   254,   244,   244,   256,   256,   255,   255,   255,   255,   199,   199,   237,   237,   262,   262,   262,   262,   257,   257,   257,   257,   259,   259,   258,   258,   258,   260,   260,   248,   248,   230,   230,   218,   218,   218,   264,   264,   264,   246,   246,   247,   247,   249,   249,   249,   249,   189,   245,   245,   266,   266,   266,   266,   189,   267,   267,   267,   267,   189,   189,   270,   270,   270,   270,   270,   270,   271,   268,   268,   269,   269,   263,   263,   216,   216,   216,   216,   216,   215,   215,   215,   216,   216,   216,   216,   216,   216,   216,   215,   216,   216,   216,   216,   216,   216,   216,   216,   216,   273,   216,   216,   216,   216,   216,   216,   216,   216,   216,   274,   274,   216,   275,   275,   216,   216,   216,   216,   216,   216,   278,   278,   279,   279,   277,   277,   261,   252,   252,   276,   276,   189,   280,   280,   220,   220,   231,   231,   281,   281,   189,   189,   189,   282,   282,   189,   189,   189,   189,   189,   210,   211,   189,   284,   286,   286,   286,   287,   287,   287,   289,   289,   285,   285,   291,   292,   292,   290,   290,   290,   290,   216,   216,   235,   235,   235,   189,   189,   189,   294,   294,   189,   189,   189,   189,   189,   189,   189,   295,   189,   189,   189,   297,   299,   300,   300,   301,   265,   265,   304,   304,   304,   303,   240,   240,   305,   305,   306,   307,   307,   307,   307,   307,   307,   308,   308,   308,   312,   314,   314,   315,   315,   313,   313,   316,   316,   317,   317,   317,   250,   272,   272,   272,   311,   311,   310,   184,   185,   185,   186,   186,   186,   191,   191,   191,   193,   193,   189,   202,   200,   200,   192,   192,   192,   207,   208,   209,   209,   206,   206,   214,   214,   214,   201,   227,   227,   228,   232,   234,   238,   239,   253,   254,   271,   216,   273,   261,   283,   283,   283,   283,   283,   210,   288,   288,   291,   292,   293,   293,   296,   296,   298,   298,   299,   302,   302,   302,   265, }; static const signed char yyRuleInfoNRhs[] = {   -1,   -3,   -1,   -3,  0,   -1,   -1,   -1,   -2,   -2,   -2,   -3,   -5,   -6,   -1,  0,   -3,   -1,  0,   -5,   -2,  0,   -3,   -2,   -1,   -2,  0,   -4,   -6,   -2,  0,  0,   -2,   -3,   -4,   -4,   -4,   -3,   -3,   -5,   -2,   -4,   -4,   -1,   -2,   -3,   -4,  0,   -1,  0,   -2,   -2,   -3,   -3,   -3,   -2,   -2,   -1,   -1,   -2,   -3,   -2,  0,   -2,   -2,  0,   -1,   -2,   -7,   -5,   -5,  -10,  0,  0,   -3,  0,   -2,   -1,   -1,   -4,   -2,  0,   -9,   -4,   -1,   -3,   -4,   -1,   -3,   -1,   -2,   -1,   -9,  -10,   -4,   -5,   -1,   -1,  0,  0,   -5,   -3,   -5,   -2,  0,  0,   -2,   -2,  0,   -7,   -9,   -7,   -7,  0,   -2,   -1,   -3,   -1,   -3,   -5,   -3,   -1,   -2,   -3,   -4,   -2,  0,  0,   -3,   -2,   -4,  0,  0,   -3,   -5,   -3,   -1,   -1,  0,   -2,   -2,  0,  0,   -3,  0,   -2,  0,   -2,   -4,   -4,   -8,  0,   -2,  0,   -2,   -2,   -4,  -11,   -5,   -7,   -3,   -5,   -7,   -8,  0,   -2,  -12,   -9,   -5,   -8,   -2,   -2,   -1,  0,   -3,   -3,   -1,   -3,   -1,   -1,   -3,   -5,   -1,   -1,   -1,   -1,   -3,   -6,   -5,   -4,   -6,   -5,   -1,   -5,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -2,   -3,   -5,   -2,   -3,   -3,   -4,   -2,   -2,   -2,   -1,   -2,   -5,   -1,   -2,   -5,   -3,   -5,   -5,   -4,   -5,   -5,   -4,   -2,  0,   -1,  0,  0,   -3,   -1,  0,   -3,  -12,   -1,  0,  0,   -3,   -5,   -3,  0,   -2,   -4,   -2,   -3,   -2,  0,   -3,   -5,   -6,   -5,   -6,   -2,   -2,   -5,  -11,   -1,   -2,  0,   -1,   -1,   -3,  0,   -2,   -3,   -2,   -3,   -3,   -2,   -9,   -8,   -6,   -3,   -4,   -6,   -1,   -1,   -1,   -4,   -6,   -3,  0,   -2,   -1,   -3,   -1,   -3,   -6,   -7,   -6,   -1,   -8,   -1,   -4,   -8,  0,   -1,   -3,   -1,   -2,   -3,   -1,   -2,   -3,   -6,   -1,   -3,   -1,   -3,   -5,   -5,   -6,   -4,   -5,   -1,   -2,  0,   -3,   -6,   -1,   -1,   -2,   -1,   -2,   -2,   -2,  0,   -2,   -2,   -2,   -1,   -2,   -2,   -1,   -1,   -4,   -2,   -5,   -1,   -2,   -1,   -1,   -2,   -3,  0,   -1,   -2,   -1,  0,   -2,   -1,   -4,   -2,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -2,  0,   -2,   -4,   -2,   -2,   -3,   -1,  0,   -1,   -1,   -1,   -1,   -2,   -1,  0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  0,   -3,   -1,  0,   -1,  0,  0,   -1,   -1,   -3,   -2,  0,   -4,   -2,  0, }; static void yy_accept(yyParser*); static YYACTIONTYPE yy_reduce(  yyParser *yypParser,  unsigned int yyruleno,  int yyLookahead,  sqlite3ParserTOKENTYPE yyLookaheadToken  sqlite3ParserCTX_PDECL ){  int yygoto;  YYACTIONTYPE yyact;  yyStackEntry *yymsp;  int yysize;  sqlite3ParserARG_FETCH  (void)yyLookahead;  (void)yyLookaheadToken;  yymsp = yypParser->yytos;  switch( yyruleno ){  YYMINORTYPE yylhsminor;  case 0: { pParse->explain = 1; }  break;  case 1: { pParse->explain = 2; }  break;  case 2: { sqlite3FinishCoding(pParse); }  break;  case 3: {sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy64);}  break;  case 4: {yymsp[1].minor.yy64 = TK_DEFERRED;}  break;  case 5:  case 6: yytestcase(yyruleno==6);  case 7: yytestcase(yyruleno==7);  case 320: yytestcase(yyruleno==320); {yymsp[0].minor.yy64 = yymsp[0].major; }  break;  case 8:  case 9: yytestcase(yyruleno==9); {sqlite3EndTransaction(pParse,yymsp[-1].major);}  break;  case 10: {  sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, &yymsp[0].minor.yy0); }  break;  case 11: {  sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, &yymsp[0].minor.yy0); }  break;  case 12: {  sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &yymsp[0].minor.yy0); }  break;  case 13: {   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy64,0,0,yymsp[-2].minor.yy64); }  break;  case 14: {disableLookaside(pParse);}  break;  case 15:  case 18: yytestcase(yyruleno==18);  case 47: yytestcase(yyruleno==47);  case 62: yytestcase(yyruleno==62);  case 72: yytestcase(yyruleno==72);  case 81: yytestcase(yyruleno==81);  case 98: yytestcase(yyruleno==98);  case 241: yytestcase(yyruleno==241); {yymsp[1].minor.yy64 = 0;}  break;  case 16: {yymsp[-2].minor.yy64 = 1;}  break;  case 17: {yymsp[0].minor.yy64 = pParse->db->init.busy==0;}  break;  case 19: {  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy51,0); }  break;  case 20: {  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy303);  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy303); }  break;  case 21: {yymsp[1].minor.yy51 = 0;}  break;  case 22: {yylhsminor.yy51 = yymsp[-2].minor.yy51|yymsp[0].minor.yy51;}  yymsp[-2].minor.yy51 = yylhsminor.yy51;  break;  case 23: {  if( yymsp[0].minor.yy0.n==5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"rowid",5)==0 ){  yymsp[-1].minor.yy51 = TF_WithoutRowid | TF_NoVisibleRowid;  }else{  yymsp[-1].minor.yy51 = 0;  sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);  } }  break;  case 24: {  if( yymsp[0].minor.yy0.n==6 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"strict",6)==0 ){  yylhsminor.yy51 = TF_Strict;  }else{  yylhsminor.yy51 = 0;  sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);  } }  yymsp[0].minor.yy51 = yylhsminor.yy51;  break;  case 25: {sqlite3AddColumn(pParse,yymsp[-1].minor.yy0,yymsp[0].minor.yy0);}  break;  case 26:  case 65: yytestcase(yyruleno==65);  case 104: yytestcase(yyruleno==104); {yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0;}  break;  case 27: {  yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z); }  break;  case 28: {  yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z); }  break;  case 29: {yymsp[-1].minor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}  break;  case 30: {  assert( yyLookahead!=YYNOCODE );  yymsp[1].minor.yy600 = yyLookaheadToken.z; }  break;  case 31: {  assert( yyLookahead!=YYNOCODE );  yymsp[1].minor.yy0 = yyLookaheadToken; }  break;  case 32:  case 67: yytestcase(yyruleno==67); {pParse->constraintName = yymsp[0].minor.yy0;}  break;  case 33: {sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy626,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}  break;  case 34: {sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy626,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}  break;  case 35: {sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy626,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}  break;  case 36: {  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy626, 0);  sqlite3AddDefaultValue(pParse,p,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]); }  break;  case 37: {  Expr *p = tokenExpr(pParse, TK_STRING, yymsp[0].minor.yy0);  if( p ){  sqlite3ExprIdToTrueFalse(p);  testcase( p->op==TK_TRUEFALSE && sqlite3ExprTruthValue(p) );  }  sqlite3AddDefaultValue(pParse,p,yymsp[0].minor.yy0.z,yymsp[0].minor.yy0.z+yymsp[0].minor.yy0.n); }  break;  case 38: {sqlite3AddNotNull(pParse, yymsp[0].minor.yy64);}  break;  case 39: {sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy64,yymsp[0].minor.yy64,yymsp[-2].minor.yy64);}  break;  case 40: {sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy64,0,0,0,0,   SQLITE_IDXTYPE_UNIQUE);}  break;  case 41: {sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy626,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy0.z);}  break;  case 42: {sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy562,yymsp[0].minor.yy64);}  break;  case 43: {sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy64);}  break;  case 44: {sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}  break;  case 45: {sqlite3AddGenerated(pParse,yymsp[-1].minor.yy626,0);}  break;  case 46: {sqlite3AddGenerated(pParse,yymsp[-2].minor.yy626,&yymsp[0].minor.yy0);}  break;  case 48: {yymsp[0].minor.yy64 = 1;}  break;  case 49: { yymsp[1].minor.yy64 = OE_None*0x0101; }  break;  case 50: { yymsp[-1].minor.yy64 = (yymsp[-1].minor.yy64 & ~yymsp[0].minor.yy83.mask) | yymsp[0].minor.yy83.value; }  break;  case 51: { yymsp[-1].minor.yy83.value = 0;  yymsp[-1].minor.yy83.mask = 0x000000; }  break;  case 52: { yymsp[-2].minor.yy83.value = 0;  yymsp[-2].minor.yy83.mask = 0x000000; }  break;  case 53: { yymsp[-2].minor.yy83.value = yymsp[0].minor.yy64;  yymsp[-2].minor.yy83.mask = 0x0000ff; }  break;  case 54: { yymsp[-2].minor.yy83.value = yymsp[0].minor.yy64<<8; yymsp[-2].minor.yy83.mask = 0x00ff00; }  break;  case 55: { yymsp[-1].minor.yy64 = OE_SetNull; }  break;  case 56: { yymsp[-1].minor.yy64 = OE_SetDflt; }  break;  case 57: { yymsp[0].minor.yy64 = OE_Cascade; }  break;  case 58: { yymsp[0].minor.yy64 = OE_Restrict; }  break;  case 59: { yymsp[-1].minor.yy64 = OE_None;  }  break;  case 60: {yymsp[-2].minor.yy64 = 0;}  break;  case 61:  case 76: yytestcase(yyruleno==76);  case 171: yytestcase(yyruleno==171); {yymsp[-1].minor.yy64 = yymsp[0].minor.yy64;}  break;  case 63:  case 80: yytestcase(yyruleno==80);  case 213: yytestcase(yyruleno==213);  case 216: yytestcase(yyruleno==216);  case 242: yytestcase(yyruleno==242); {yymsp[-1].minor.yy64 = 1;}  break;  case 64: {yymsp[-1].minor.yy64 = 0;}  break;  case 66: {pParse->constraintName.n = 0;}  break;  case 68: {sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy562,yymsp[0].minor.yy64,yymsp[-2].minor.yy64,0);}  break;  case 69: {sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy562,yymsp[0].minor.yy64,0,0,0,0,   SQLITE_IDXTYPE_UNIQUE);}  break;  case 70: {sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy626,yymsp[-3].minor.yy0.z,yymsp[-1].minor.yy0.z);}  break;  case 71: {  sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy562, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy562, yymsp[-1].minor.yy64);  sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy64); }  break;  case 73:  case 75: yytestcase(yyruleno==75); {yymsp[1].minor.yy64 = OE_Default;}  break;  case 74: {yymsp[-2].minor.yy64 = yymsp[0].minor.yy64;}  break;  case 77: {yymsp[0].minor.yy64 = OE_Ignore;}  break;  case 78:  case 172: yytestcase(yyruleno==172); {yymsp[0].minor.yy64 = OE_Replace;}  break;  case 79: {  sqlite3DropTable(pParse, yymsp[0].minor.yy607, 0, yymsp[-1].minor.yy64); }  break;  case 82: {  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy562, yymsp[0].minor.yy303, yymsp[-7].minor.yy64, yymsp[-5].minor.yy64); }  break;  case 83: {  sqlite3DropTable(pParse, yymsp[0].minor.yy607, 1, yymsp[-1].minor.yy64); }  break;  case 84: {  SelectDest dest = {SRT_Output, 0, 0, 0, 0, 0, 0};  sqlite3Select(pParse, yymsp[0].minor.yy303, &dest);  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy303); }  break;  case 85: {yymsp[-2].minor.yy303 = attachWithToSelect(pParse,yymsp[0].minor.yy303,yymsp[-1].minor.yy43);}  break;  case 86: {yymsp[-3].minor.yy303 = attachWithToSelect(pParse,yymsp[0].minor.yy303,yymsp[-1].minor.yy43);}  break;  case 87: {  Select *p = yymsp[0].minor.yy303;  if( p ){  parserDoubleLinkSelect(pParse, p);  }  yymsp[0].minor.yy303 = p; }  break;  case 88: {  Select *pRhs = yymsp[0].minor.yy303;  Select *pLhs = yymsp[-2].minor.yy303;  if( pRhs && pRhs->pPrior ){  SrcList *pFrom;  Token x;  x.n = 0;  parserDoubleLinkSelect(pParse, pRhs);  pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0,0);  pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0);  }  if( pRhs ){  pRhs->op = (u8)yymsp[-1].minor.yy64;  pRhs->pPrior = pLhs;  if( ALWAYS(pLhs) ) pLhs->selFlags &= ~SF_MultiValue;  pRhs->selFlags &= ~SF_MultiValue;  if( yymsp[-1].minor.yy64!=TK_ALL ) pParse->hasCompound = 1;  }else{  sqlite3SelectDelete(pParse->db, pLhs);  }  yymsp[-2].minor.yy303 = pRhs; }  break;  case 89:  case 91: yytestcase(yyruleno==91); {yymsp[0].minor.yy64 = yymsp[0].major; }  break;  case 90: {yymsp[-1].minor.yy64 = TK_ALL;}  break;  case 92: {  yymsp[-8].minor.yy303 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy562,yymsp[-5].minor.yy607,yymsp[-4].minor.yy626,yymsp[-3].minor.yy562,yymsp[-2].minor.yy626,yymsp[-1].minor.yy562,yymsp[-7].minor.yy64,yymsp[0].minor.yy626); }  break;  case 93: {  yymsp[-9].minor.yy303 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy562,yymsp[-6].minor.yy607,yymsp[-5].minor.yy626,yymsp[-4].minor.yy562,yymsp[-3].minor.yy626,yymsp[-1].minor.yy562,yymsp[-8].minor.yy64,yymsp[0].minor.yy626);  if( yymsp[-9].minor.yy303 ){  yymsp[-9].minor.yy303->pWinDefn = yymsp[-2].minor.yy375;  }else{  sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy375);  } }  break;  case 94: {  yymsp[-3].minor.yy303 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy562,0,0,0,0,0,SF_Values,0); }  break;  case 95: {  Select *pRight, *pLeft = yymsp[-4].minor.yy303;  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy562,0,0,0,0,0,SF_Values|SF_MultiValue,0);  if( ALWAYS(pLeft) ) pLeft->selFlags &= ~SF_MultiValue;  if( pRight ){  pRight->op = TK_ALL;  pRight->pPrior = pLeft;  yymsp[-4].minor.yy303 = pRight;  }else{  yymsp[-4].minor.yy303 = pLeft;  } }  break;  case 96: {yymsp[0].minor.yy64 = SF_Distinct;}  break;  case 97: {yymsp[0].minor.yy64 = SF_All;}  break;  case 99:  case 132: yytestcase(yyruleno==132);  case 142: yytestcase(yyruleno==142);  case 229: yytestcase(yyruleno==229);  case 232: yytestcase(yyruleno==232);  case 237: yytestcase(yyruleno==237); {yymsp[1].minor.yy562 = 0;}  break;  case 100: {   yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy562, yymsp[-2].minor.yy626);   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy562, &yymsp[0].minor.yy0, 1);   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy562,yymsp[-3].minor.yy600,yymsp[-1].minor.yy600); }  break;  case 101: {  Expr *p = sqlite3Expr(pParse->db, TK_ASTERISK, 0);  yymsp[-2].minor.yy562 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy562, p); }  break;  case 102: {  Expr *pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);  Expr *pLeft = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);  Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562, pDot); }  break;  case 103:  case 114: yytestcase(yyruleno==114);  case 253: yytestcase(yyruleno==253);  case 254: yytestcase(yyruleno==254); {yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;}  break;  case 105:  case 108: yytestcase(yyruleno==108); {yymsp[1].minor.yy607 = 0;}  break;  case 106: {  yymsp[-1].minor.yy607 = yymsp[0].minor.yy607;  sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy607); }  break;  case 107: {   if( ALWAYS(yymsp[-1].minor.yy607 && yymsp[-1].minor.yy607->nSrc>0) ) yymsp[-1].minor.yy607->a[yymsp[-1].minor.yy607->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy64; }  break;  case 109: {  yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);  sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy607, &yymsp[-2].minor.yy0); }  break;  case 110: {  yymsp[-8].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy607,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);  sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy607, yymsp[-4].minor.yy562); }  break;  case 111: {  yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy303,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);  }  break;  case 112: {  if( yymsp[-6].minor.yy607==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy626==0 && yymsp[0].minor.yy240==0 ){  yymsp[-6].minor.yy607 = yymsp[-4].minor.yy607;  }else if( yymsp[-4].minor.yy607->nSrc==1 ){  yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,0,0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);  if( yymsp[-6].minor.yy607 ){  SrcItem *pNew = &yymsp[-6].minor.yy607->a[yymsp[-6].minor.yy607->nSrc-1];  SrcItem *pOld = yymsp[-4].minor.yy607->a;  pNew->zName = pOld->zName;  pNew->zDatabase = pOld->zDatabase;  pNew->pSelect = pOld->pSelect;  if( pOld->fg.isTabFunc ){  pNew->u1.pFuncArg = pOld->u1.pFuncArg;  pOld->u1.pFuncArg = 0;  pOld->fg.isTabFunc = 0;  pNew->fg.isTabFunc = 1;  }  pOld->zName = pOld->zDatabase = 0;  pOld->pSelect = 0;  }  sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy607);  }else{  Select *pSubquery;  sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy607);  pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy607,0,0,0,0,SF_NestedFrom,0);  yymsp[-6].minor.yy607 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy607,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy626,yymsp[0].minor.yy240);  }  }  break;  case 113:  case 127: yytestcase(yyruleno==127); {yymsp[1].minor.yy0.z=0; yymsp[1].minor.yy0.n=0;}  break;  case 115: {  yylhsminor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);  if( IN_RENAME_OBJECT && yylhsminor.yy607 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy607->a[0].zName, &yymsp[0].minor.yy0); }  yymsp[0].minor.yy607 = yylhsminor.yy607;  break;  case 116: {  yylhsminor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);  if( IN_RENAME_OBJECT && yylhsminor.yy607 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy607->a[0].zName, &yymsp[0].minor.yy0); }  yymsp[-2].minor.yy607 = yylhsminor.yy607;  break;  case 117: {yymsp[0].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); }  break;  case 118: {yymsp[-2].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); }  break;  case 119: {   yymsp[-4].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0);   if( yymsp[-4].minor.yy607 ) yymsp[-4].minor.yy607->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0); }  break;  case 120: {   yymsp[-2].minor.yy607 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0);   if( yymsp[-2].minor.yy607 ) yymsp[-2].minor.yy607->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0); }  break;  case 121: { yymsp[0].minor.yy64 = JT_INNER; }  break;  case 122: {yymsp[-1].minor.yy64 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); }  break;  case 123: {yymsp[-2].minor.yy64 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); }  break;  case 124: {yymsp[-3].minor.yy64 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);}  break;  case 125:  case 145: yytestcase(yyruleno==145);  case 152: yytestcase(yyruleno==152);  case 154: yytestcase(yyruleno==154);  case 225: yytestcase(yyruleno==225);  case 246: yytestcase(yyruleno==246); {yymsp[-1].minor.yy626 = yymsp[0].minor.yy626;}  break;  case 126:  case 144: yytestcase(yyruleno==144);  case 146: yytestcase(yyruleno==146);  case 151: yytestcase(yyruleno==151);  case 153: yytestcase(yyruleno==153);  case 226: yytestcase(yyruleno==226);  case 228: yytestcase(yyruleno==228);  case 247: yytestcase(yyruleno==247); {yymsp[1].minor.yy626 = 0;}  break;  case 128: {yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;}  break;  case 129: {yymsp[-1].minor.yy0.z=0; yymsp[-1].minor.yy0.n=1;}  break;  case 130: {yymsp[-3].minor.yy240 = yymsp[-1].minor.yy240;}  break;  case 131:  case 173: yytestcase(yyruleno==173); {yymsp[1].minor.yy240 = 0;}  break;  case 133:  case 143: yytestcase(yyruleno==143); {yymsp[-2].minor.yy562 = yymsp[0].minor.yy562;}  break;  case 134: {  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562,yymsp[-2].minor.yy626);  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy562,yymsp[-1].minor.yy64,yymsp[0].minor.yy64); }  break;  case 135: {  yymsp[-2].minor.yy562 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy626);  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy562,yymsp[-1].minor.yy64,yymsp[0].minor.yy64); }  break;  case 136: {yymsp[0].minor.yy64 = SQLITE_SO_ASC;}  break;  case 137: {yymsp[0].minor.yy64 = SQLITE_SO_DESC;}  break;  case 138:  case 141: yytestcase(yyruleno==141); {yymsp[1].minor.yy64 = SQLITE_SO_UNDEFINED;}  break;  case 139: {yymsp[-1].minor.yy64 = SQLITE_SO_ASC;}  break;  case 140: {yymsp[-1].minor.yy64 = SQLITE_SO_DESC;}  break;  case 147: {yymsp[-1].minor.yy626 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy626,0);}  break;  case 148: {yymsp[-3].minor.yy626 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);}  break;  case 149: {yymsp[-3].minor.yy626 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy626,yymsp[-2].minor.yy626);}  break;  case 150: {  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy607, &yymsp[-3].minor.yy0);
#ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( yymsp[-1].minor.yy562 || yymsp[0].minor.yy626 ){  updateDeleteLimitError(pParse,yymsp[-1].minor.yy562,yymsp[0].minor.yy626);  yymsp[-1].minor.yy562 = 0;  yymsp[0].minor.yy626 = 0;  }
#endif
 sqlite3DeleteFrom(pParse,yymsp[-4].minor.yy607,yymsp[-2].minor.yy626,yymsp[-1].minor.yy562,yymsp[0].minor.yy626); }  break;  case 155: {sqlite3AddReturning(pParse,yymsp[0].minor.yy562); yymsp[-1].minor.yy626 = 0;}  break;  case 156: {sqlite3AddReturning(pParse,yymsp[0].minor.yy562); yymsp[-3].minor.yy626 = yymsp[-2].minor.yy626;}  break;  case 157: {  sqlite3SrcListIndexedBy(pParse, yymsp[-7].minor.yy607, &yymsp[-6].minor.yy0);  yymsp[-7].minor.yy607 = sqlite3SrcListAppendList(pParse, yymsp[-7].minor.yy607, yymsp[-3].minor.yy607);  sqlite3ExprListCheckLength(pParse,yymsp[-4].minor.yy562,"set list");
#ifndef SQLITE_ENABLE_UPDATE_DELETE_LIMIT
 if( yymsp[-1].minor.yy562 || yymsp[0].minor.yy626 ){  updateDeleteLimitError(pParse,yymsp[-1].minor.yy562,yymsp[0].minor.yy626);  yymsp[-1].minor.yy562 = 0;  yymsp[0].minor.yy626 = 0;  }
#endif
 sqlite3Update(pParse,yymsp[-7].minor.yy607,yymsp[-4].minor.yy562,yymsp[-2].minor.yy626,yymsp[-8].minor.yy64,yymsp[-1].minor.yy562,yymsp[0].minor.yy626,0); }  break;  case 158: {  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy562, yymsp[0].minor.yy626);  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy562, &yymsp[-2].minor.yy0, 1); }  break;  case 159: {  yymsp[-6].minor.yy562 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy562, yymsp[-3].minor.yy240, yymsp[0].minor.yy626); }  break;  case 160: {  yylhsminor.yy562 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy626);  sqlite3ExprListSetName(pParse, yylhsminor.yy562, &yymsp[-2].minor.yy0, 1); }  yymsp[-2].minor.yy562 = yylhsminor.yy562;  break;  case 161: {  yymsp[-4].minor.yy562 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy240, yymsp[0].minor.yy626); }  break;  case 162: {  sqlite3Insert(pParse, yymsp[-3].minor.yy607, yymsp[-1].minor.yy303, yymsp[-2].minor.yy240, yymsp[-5].minor.yy64, yymsp[0].minor.yy138); }  break;  case 163: {  sqlite3Insert(pParse, yymsp[-4].minor.yy607, 0, yymsp[-3].minor.yy240, yymsp[-6].minor.yy64, 0); }  break;  case 164: { yymsp[1].minor.yy138 = 0; }  break;  case 165: { yymsp[-1].minor.yy138 = 0; sqlite3AddReturning(pParse,yymsp[0].minor.yy562); }  break;  case 166: { yymsp[-11].minor.yy138 = sqlite3UpsertNew(pParse->db,yymsp[-8].minor.yy562,yymsp[-6].minor.yy626,yymsp[-2].minor.yy562,yymsp[-1].minor.yy626,yymsp[0].minor.yy138);}  break;  case 167: { yymsp[-8].minor.yy138 = sqlite3UpsertNew(pParse->db,yymsp[-5].minor.yy562,yymsp[-3].minor.yy626,0,0,yymsp[0].minor.yy138); }  break;  case 168: { yymsp[-4].minor.yy138 = sqlite3UpsertNew(pParse->db,0,0,0,0,0); }  break;  case 169: { yymsp[-7].minor.yy138 = sqlite3UpsertNew(pParse->db,0,0,yymsp[-2].minor.yy562,yymsp[-1].minor.yy626,0);}  break;  case 170: {sqlite3AddReturning(pParse,yymsp[0].minor.yy562);}  break;  case 174: {yymsp[-2].minor.yy240 = yymsp[-1].minor.yy240;}  break;  case 175: {yymsp[-2].minor.yy240 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy240,&yymsp[0].minor.yy0);}  break;  case 176: {yymsp[0].minor.yy240 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); }  break;  case 177: {yymsp[-2].minor.yy626 = yymsp[-1].minor.yy626;}  break;  case 178:  case 179: yytestcase(yyruleno==179); {yymsp[0].minor.yy626=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); }  break;  case 180: {  Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);  Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenMap(pParse, (void*)temp2, &yymsp[0].minor.yy0);  sqlite3RenameTokenMap(pParse, (void*)temp1, &yymsp[-2].minor.yy0);  }  yylhsminor.yy626 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2); }  yymsp[-2].minor.yy626 = yylhsminor.yy626;  break;  case 181: {  Expr *temp1 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-4].minor.yy0, 1);  Expr *temp2 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[-2].minor.yy0, 1);  Expr *temp3 = sqlite3ExprAlloc(pParse->db, TK_ID, &yymsp[0].minor.yy0, 1);  Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3);  if( IN_RENAME_OBJECT ){  sqlite3RenameTokenMap(pParse, (void*)temp3, &yymsp[0].minor.yy0);  sqlite3RenameTokenMap(pParse, (void*)temp2, &yymsp[-2].minor.yy0);  }  yylhsminor.yy626 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4); }  yymsp[-4].minor.yy626 = yylhsminor.yy626;  break;  case 182:  case 183: yytestcase(yyruleno==183); {yymsp[0].minor.yy626=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); }  break;  case 184: {  yylhsminor.yy626 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1); }  yymsp[0].minor.yy626 = yylhsminor.yy626;  break;  case 185: {  if( !(yymsp[0].minor.yy0.z[0]=='#' && sqlite3Isdigit(yymsp[0].minor.yy0.z[1])) ){  u32 n = yymsp[0].minor.yy0.n;  yymsp[0].minor.yy626 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);  sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy626, n);  }else{  Token t = yymsp[0].minor.yy0;  assert( t.n>=2 );  if( pParse->nested==0 ){  sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &t);  yymsp[0].minor.yy626 = 0;  }else{  yymsp[0].minor.yy626 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);  if( yymsp[0].minor.yy626 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy626->iTable);  }  } }  break;  case 186: {  yymsp[-2].minor.yy626 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy626, &yymsp[0].minor.yy0, 1); }  break;  case 187: {  yymsp[-5].minor.yy626 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy626, yymsp[-3].minor.yy626, 0); }  break;  case 188: {  yylhsminor.yy626 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy562, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy64); }  yymsp[-4].minor.yy626 = yylhsminor.yy626;  break;  case 189: {  yylhsminor.yy626 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0); }  yymsp[-3].minor.yy626 = yylhsminor.yy626;  break;  case 190: {  yylhsminor.yy626 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy562, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy64);  sqlite3WindowAttach(pParse, yylhsminor.yy626, yymsp[0].minor.yy375); }  yymsp[-5].minor.yy626 = yylhsminor.yy626;  break;  case 191: {  yylhsminor.yy626 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);  sqlite3WindowAttach(pParse, yylhsminor.yy626, yymsp[0].minor.yy375); }  yymsp[-4].minor.yy626 = yylhsminor.yy626;  break;  case 192: {  yylhsminor.yy626 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0); }  yymsp[0].minor.yy626 = yylhsminor.yy626;  break;  case 193: {  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy562, yymsp[-1].minor.yy626);  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);  if( yymsp[-4].minor.yy626 ){  yymsp[-4].minor.yy626->x.pList = pList;  if( ALWAYS(pList->nExpr) ){  yymsp[-4].minor.yy626->flags |= pList->a[0].pExpr->flags & EP_Propagate;  }  }else{  sqlite3ExprListDelete(pParse->db, pList);  } }  break;  case 194: {yymsp[-2].minor.yy626=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);}  break;  case 195:  case 196: yytestcase(yyruleno==196);  case 197: yytestcase(yyruleno==197);  case 198: yytestcase(yyruleno==198);  case 199: yytestcase(yyruleno==199);  case 200: yytestcase(yyruleno==200);  case 201: yytestcase(yyruleno==201); {yymsp[-2].minor.yy626=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);}  break;  case 202: {yymsp[-1].minor.yy0=yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n|=0x80000000; }  break;  case 203: {  ExprList *pList;  int bNot = yymsp[-1].minor.yy0.n & 0x80000000;  yymsp[-1].minor.yy0.n &= 0x7fffffff;  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy626);  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy626);  yymsp[-2].minor.yy626 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);  if( bNot ) yymsp[-2].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy626, 0);  if( yymsp[-2].minor.yy626 ) yymsp[-2].minor.yy626->flags |= EP_InfixFunc; }  break;  case 204: {  ExprList *pList;  int bNot = yymsp[-3].minor.yy0.n & 0x80000000;  yymsp[-3].minor.yy0.n &= 0x7fffffff;  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy626);  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy626);  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy626);  yymsp[-4].minor.yy626 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);  if( bNot ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);  if( yymsp[-4].minor.yy626 ) yymsp[-4].minor.yy626->flags |= EP_InfixFunc; }  break;  case 205: {yymsp[-1].minor.yy626 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy626,0);}  break;  case 206: {yymsp[-2].minor.yy626 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy626,0);}  break;  case 207: {  yymsp[-2].minor.yy626 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy626,yymsp[0].minor.yy626);  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy626, yymsp[-2].minor.yy626, TK_ISNULL); }  break;  case 208: {  yymsp[-3].minor.yy626 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy626,yymsp[0].minor.yy626);  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy626, yymsp[-3].minor.yy626, TK_NOTNULL); }  break;  case 209:  case 210: yytestcase(yyruleno==210); {yymsp[-1].minor.yy626 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy626, 0);}  break;  case 211: {  yymsp[-1].minor.yy626 = sqlite3PExpr(pParse, yymsp[-1].major==TK_PLUS ? TK_UPLUS : TK_UMINUS, yymsp[0].minor.yy626, 0); }  break;  case 212:  case 215: yytestcase(yyruleno==215); {yymsp[0].minor.yy64 = 0;}  break;  case 214: {  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy626);  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy626);  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy626, 0);  if( yymsp[-4].minor.yy626 ){  yymsp[-4].minor.yy626->x.pList = pList;  }else{  sqlite3ExprListDelete(pParse->db, pList);  }  if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0); }  break;  case 217: {  if( yymsp[-1].minor.yy562==0 ){  sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy626);  yymsp[-4].minor.yy626 = sqlite3Expr(pParse->db, TK_INTEGER, yymsp[-3].minor.yy64 ? "1" : "0");  }else{  Expr *pRHS = yymsp[-1].minor.yy562->a[0].pExpr;  if( yymsp[-1].minor.yy562->nExpr==1 && sqlite3ExprIsConstant(pRHS) && yymsp[-4].minor.yy626->op!=TK_VECTOR ){  yymsp[-1].minor.yy562->a[0].pExpr = 0;  sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy562);  pRHS = sqlite3PExpr(pParse, TK_UPLUS, pRHS, 0);  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy626, pRHS);  }else{  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy626, 0);  if( yymsp[-4].minor.yy626==0 ){  sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy562);  }else if( yymsp[-4].minor.yy626->pLeft->op==TK_VECTOR ){  int nExpr = yymsp[-4].minor.yy626->pLeft->x.pList->nExpr;  Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy562);  if( pSelectRHS ){  parserDoubleLinkSelect(pParse, pSelectRHS);  sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy626, pSelectRHS);  }  }else{  yymsp[-4].minor.yy626->x.pList = yymsp[-1].minor.yy562;  sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy626);  }  }  if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);  }  }  break;  case 218: {  yymsp[-2].minor.yy626 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);  sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy626, yymsp[-1].minor.yy303);  }  break;  case 219: {  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy626, 0);  sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy626, yymsp[-1].minor.yy303);  if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);  }  break;  case 220: {  SrcList *pSrc = sqlite3SrcListAppend(pParse, 0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);  Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0);  if( yymsp[0].minor.yy562 ) sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy562);  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy626, 0);  sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy626, pSelect);  if( yymsp[-3].minor.yy64 ) yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy626, 0);  }  break;  case 221: {  Expr *p;  p = yymsp[-3].minor.yy626 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);  sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy303);  }  break;  case 222: {  yymsp[-4].minor.yy626 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy626, 0);  if( yymsp[-4].minor.yy626 ){  yymsp[-4].minor.yy626->x.pList = yymsp[-1].minor.yy626 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy562,yymsp[-1].minor.yy626) : yymsp[-2].minor.yy562;  sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy626);  }else{  sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy562);  sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy626);  } }  break;  case 223: {  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562, yymsp[-2].minor.yy626);  yymsp[-4].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy562, yymsp[0].minor.yy626); }  break;  case 224: {  yymsp[-3].minor.yy562 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy626);  yymsp[-3].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy562, yymsp[0].minor.yy626); }  break;  case 227: {yymsp[0].minor.yy626 = yymsp[0].minor.yy626; }  break;  case 230: {yymsp[-2].minor.yy562 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy562,yymsp[0].minor.yy626);}  break;  case 231: {yymsp[0].minor.yy562 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy626); }  break;  case 233:  case 238: yytestcase(yyruleno==238); {yymsp[-2].minor.yy562 = yymsp[-1].minor.yy562;}  break;  case 234: {  sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0,   sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy562, yymsp[-10].minor.yy64,  &yymsp[-11].minor.yy0, yymsp[0].minor.yy626, SQLITE_SO_ASC, yymsp[-8].minor.yy64, SQLITE_IDXTYPE_APPDEF);  if( IN_RENAME_OBJECT && pParse->pNewIndex ){  sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);  } }  break;  case 235:  case 277: yytestcase(yyruleno==277); {yymsp[0].minor.yy64 = OE_Abort;}  break;  case 236: {yymsp[1].minor.yy64 = OE_None;}  break;  case 239: {  yymsp[-4].minor.yy562 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy562, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy64, yymsp[0].minor.yy64); }  break;  case 240: {  yymsp[-2].minor.yy562 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy64, yymsp[0].minor.yy64); }  break;  case 243: {sqlite3DropIndex(pParse, yymsp[0].minor.yy607, yymsp[-1].minor.yy64);}  break;  case 244: {sqlite3Vacuum(pParse,0,yymsp[0].minor.yy626);}  break;  case 245: {sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy626);}  break;  case 248: {sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}  break;  case 249: {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}  break;  case 250: {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}  break;  case 251: {sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}  break;  case 252: {sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}  break;  case 255: {  Token all;  all.z = yymsp[-3].minor.yy0.z;  all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy95, &all); }  break;  case 256: {  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy64, yymsp[-4].minor.yy570.a, yymsp[-4].minor.yy570.b, yymsp[-2].minor.yy607, yymsp[0].minor.yy626, yymsp[-10].minor.yy64, yymsp[-8].minor.yy64);  yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0); }  break;  case 257: { yymsp[0].minor.yy64 = yymsp[0].major; }  break;  case 258: { yymsp[-1].minor.yy64 = TK_INSTEAD;}  break;  case 259: { yymsp[1].minor.yy64 = TK_BEFORE; }  break;  case 260:  case 261: yytestcase(yyruleno==261); {yymsp[0].minor.yy570.a = yymsp[0].major; yymsp[0].minor.yy570.b = 0;}  break;  case 262: {yymsp[-2].minor.yy570.a = TK_UPDATE; yymsp[-2].minor.yy570.b = yymsp[0].minor.yy240;}  break;  case 263:  case 282: yytestcase(yyruleno==282); { yymsp[1].minor.yy626 = 0; }  break;  case 264:  case 283: yytestcase(yyruleno==283); { yymsp[-1].minor.yy626 = yymsp[0].minor.yy626; }  break;  case 265: {  assert( yymsp[-2].minor.yy95!=0 );  yymsp[-2].minor.yy95->pLast->pNext = yymsp[-1].minor.yy95;  yymsp[-2].minor.yy95->pLast = yymsp[-1].minor.yy95; }  break;  case 266: {  assert( yymsp[-1].minor.yy95!=0 );  yymsp[-1].minor.yy95->pLast = yymsp[-1].minor.yy95; }  break;  case 267: {  yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;  sqlite3ErrorMsg(pParse,  "qualified table names are not allowed on INSERT, UPDATE, and DELETE "  "statements within triggers"); }  break;  case 268: {  sqlite3ErrorMsg(pParse,  "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "  "within triggers"); }  break;  case 269: {  sqlite3ErrorMsg(pParse,  "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "  "within triggers"); }  break;  case 270: {yylhsminor.yy95 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy607, yymsp[-3].minor.yy562, yymsp[-1].minor.yy626, yymsp[-7].minor.yy64, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy600);}  yymsp[-8].minor.yy95 = yylhsminor.yy95;  break;  case 271: {   yylhsminor.yy95 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy240,yymsp[-2].minor.yy303,yymsp[-6].minor.yy64,yymsp[-1].minor.yy138,yymsp[-7].minor.yy600,yymsp[0].minor.yy600); }  yymsp[-7].minor.yy95 = yylhsminor.yy95;  break;  case 272: {yylhsminor.yy95 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy626, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy600);}  yymsp[-5].minor.yy95 = yylhsminor.yy95;  break;  case 273: {yylhsminor.yy95 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy303, yymsp[-2].minor.yy600, yymsp[0].minor.yy600); }  yymsp[-2].minor.yy95 = yylhsminor.yy95;  break;  case 274: {  yymsp[-3].minor.yy626 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);  if( yymsp[-3].minor.yy626 ){  yymsp[-3].minor.yy626->affExpr = OE_Ignore;  } }  break;  case 275: {  yymsp[-5].minor.yy626 = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1);  if( yymsp[-5].minor.yy626 ) {  yymsp[-5].minor.yy626->affExpr = (char)yymsp[-3].minor.yy64;  } }  break;  case 276: {yymsp[0].minor.yy64 = OE_Rollback;}  break;  case 278: {yymsp[0].minor.yy64 = OE_Fail;}  break;  case 279: {  sqlite3DropTrigger(pParse,yymsp[0].minor.yy607,yymsp[-1].minor.yy64); }  break;  case 280: {  sqlite3Attach(pParse, yymsp[-3].minor.yy626, yymsp[-1].minor.yy626, yymsp[0].minor.yy626); }  break;  case 281: {  sqlite3Detach(pParse, yymsp[0].minor.yy626); }  break;  case 284: {sqlite3Reindex(pParse, 0, 0);}  break;  case 285: {sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}  break;  case 286: {sqlite3Analyze(pParse, 0, 0);}  break;  case 287: {sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}  break;  case 288: {  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy607,&yymsp[0].minor.yy0); }  break;  case 289: {  yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;  sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0); }  break;  case 290: {  sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy607, &yymsp[0].minor.yy0); }  break;  case 291: {  disableLookaside(pParse);  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy607); }  break;  case 292: {  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy607, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0); }  break;  case 293: {sqlite3VtabFinishParse(pParse,0);}  break;  case 294: {sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}  break;  case 295: {  sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy64); }  break;  case 296: {sqlite3VtabArgInit(pParse);}  break;  case 297:  case 298: yytestcase(yyruleno==298);  case 299: yytestcase(yyruleno==299); {sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}  break;  case 300:  case 301: yytestcase(yyruleno==301); { sqlite3WithPush(pParse, yymsp[0].minor.yy43, 1); }  break;  case 302: {yymsp[0].minor.yy534 = M10d_Any;}  break;  case 303: {yymsp[-1].minor.yy534 = M10d_Yes;}  break;  case 304: {yymsp[-2].minor.yy534 = M10d_No;}  break;  case 305: {  yymsp[-5].minor.yy255 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy562, yymsp[-1].minor.yy303, yymsp[-3].minor.yy534); }  break;  case 306: {  yymsp[0].minor.yy43 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy255); }  break;  case 307: {  yymsp[-2].minor.yy43 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy43, yymsp[0].minor.yy255); }  break;  case 308: { yylhsminor.yy375 = yymsp[0].minor.yy375; }  yymsp[0].minor.yy375 = yylhsminor.yy375;  break;  case 309: {  assert( yymsp[0].minor.yy375!=0 );  sqlite3WindowChain(pParse, yymsp[0].minor.yy375, yymsp[-2].minor.yy375);  yymsp[0].minor.yy375->pNextWin = yymsp[-2].minor.yy375;  yylhsminor.yy375 = yymsp[0].minor.yy375; }  yymsp[-2].minor.yy375 = yylhsminor.yy375;  break;  case 310: {  if( ALWAYS(yymsp[-1].minor.yy375) ){  yymsp[-1].minor.yy375->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);  }  yylhsminor.yy375 = yymsp[-1].minor.yy375; }  yymsp[-4].minor.yy375 = yylhsminor.yy375;  break;  case 311: {  yymsp[-4].minor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, yymsp[-2].minor.yy562, yymsp[-1].minor.yy562, 0); }  break;  case 312: {  yylhsminor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, yymsp[-2].minor.yy562, yymsp[-1].minor.yy562, &yymsp[-5].minor.yy0); }  yymsp[-5].minor.yy375 = yylhsminor.yy375;  break;  case 313: {  yymsp[-3].minor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, 0, yymsp[-1].minor.yy562, 0); }  break;  case 314: {  yylhsminor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, 0, yymsp[-1].minor.yy562, &yymsp[-4].minor.yy0); }  yymsp[-4].minor.yy375 = yylhsminor.yy375;  break;  case 315:  case 334: yytestcase(yyruleno==334); {  yylhsminor.yy375 = yymsp[0].minor.yy375; }  yymsp[0].minor.yy375 = yylhsminor.yy375;  break;  case 316: {  yylhsminor.yy375 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy375, 0, 0, &yymsp[-1].minor.yy0); }  yymsp[-1].minor.yy375 = yylhsminor.yy375;  break;  case 317: {  yymsp[1].minor.yy375 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0); }  break;  case 318: {  yylhsminor.yy375 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy64, yymsp[-1].minor.yy81.eType, yymsp[-1].minor.yy81.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy534); }  yymsp[-2].minor.yy375 = yylhsminor.yy375;  break;  case 319: {  yylhsminor.yy375 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy64, yymsp[-3].minor.yy81.eType, yymsp[-3].minor.yy81.pExpr, yymsp[-1].minor.yy81.eType, yymsp[-1].minor.yy81.pExpr, yymsp[0].minor.yy534); }  yymsp[-5].minor.yy375 = yylhsminor.yy375;  break;  case 321:  case 323: yytestcase(yyruleno==323); {yylhsminor.yy81 = yymsp[0].minor.yy81;}  yymsp[0].minor.yy81 = yylhsminor.yy81;  break;  case 322:  case 324: yytestcase(yyruleno==324);  case 326: yytestcase(yyruleno==326); {yylhsminor.yy81.eType = yymsp[-1].major; yylhsminor.yy81.pExpr = 0;}  yymsp[-1].minor.yy81 = yylhsminor.yy81;  break;  case 325: {yylhsminor.yy81.eType = yymsp[0].major; yylhsminor.yy81.pExpr = yymsp[-1].minor.yy626;}  yymsp[-1].minor.yy81 = yylhsminor.yy81;  break;  case 327: {yymsp[1].minor.yy534 = 0;}  break;  case 328: {yymsp[-1].minor.yy534 = yymsp[0].minor.yy534;}  break;  case 329:  case 330: yytestcase(yyruleno==330); {yymsp[-1].minor.yy534 = yymsp[-1].major; }  break;  case 331: {yymsp[0].minor.yy534 = yymsp[0].major; }  break;  case 332: { yymsp[-1].minor.yy375 = yymsp[0].minor.yy375; }  break;  case 333: {  if( yymsp[0].minor.yy375 ){  yymsp[0].minor.yy375->pFilter = yymsp[-1].minor.yy626;  }else{  sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy626);  }  yylhsminor.yy375 = yymsp[0].minor.yy375; }  yymsp[-1].minor.yy375 = yylhsminor.yy375;  break;  case 335: {  yylhsminor.yy375 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));  if( yylhsminor.yy375 ){  yylhsminor.yy375->eFrmType = TK_FILTER;  yylhsminor.yy375->pFilter = yymsp[0].minor.yy626;  }else{  sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy626);  } }  yymsp[0].minor.yy375 = yylhsminor.yy375;  break;  case 336: {  yymsp[-3].minor.yy375 = yymsp[-1].minor.yy375;  assert( yymsp[-3].minor.yy375!=0 ); }  break;  case 337: {  yymsp[-1].minor.yy375 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));  if( yymsp[-1].minor.yy375 ){  yymsp[-1].minor.yy375->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);  } }  break;  case 338: { yymsp[-4].minor.yy626 = yymsp[-1].minor.yy626; }  break;  default:  yytestcase(yyruleno==339);  yytestcase(yyruleno==340);  assert(yyruleno!=341);  yytestcase(yyruleno==342);  yytestcase(yyruleno==343);  assert(yyruleno!=344);  yytestcase(yyruleno==345);  yytestcase(yyruleno==346);  yytestcase(yyruleno==347);  yytestcase(yyruleno==348);  yytestcase(yyruleno==349);  yytestcase(yyruleno==350);  assert(yyruleno!=351);  yytestcase(yyruleno==352);  yytestcase(yyruleno==353);  yytestcase(yyruleno==354);  yytestcase(yyruleno==355);  yytestcase(yyruleno==356);  yytestcase(yyruleno==357);  yytestcase(yyruleno==358);  assert(yyruleno!=359);  assert(yyruleno!=360);  yytestcase(yyruleno==361);  yytestcase(yyruleno==362);  yytestcase(yyruleno==363);  yytestcase(yyruleno==364);  yytestcase(yyruleno==365);  yytestcase(yyruleno==366);  yytestcase(yyruleno==367);  assert(yyruleno!=368);  yytestcase(yyruleno==369);  assert(yyruleno!=370);  assert(yyruleno!=371);  assert(yyruleno!=372);  yytestcase(yyruleno==373);  yytestcase(yyruleno==374);  yytestcase(yyruleno==375);  yytestcase(yyruleno==376);  assert(yyruleno!=377);  yytestcase(yyruleno==378);  yytestcase(yyruleno==379);  assert(yyruleno!=380);  assert(yyruleno!=381);  yytestcase(yyruleno==382);  yytestcase(yyruleno==383);  yytestcase(yyruleno==384);  yytestcase(yyruleno==385);  yytestcase(yyruleno==386);  yytestcase(yyruleno==387);  yytestcase(yyruleno==388);  yytestcase(yyruleno==389);  yytestcase(yyruleno==390);  yytestcase(yyruleno==391);  yytestcase(yyruleno==392);  yytestcase(yyruleno==393);  yytestcase(yyruleno==394);  yytestcase(yyruleno==395);  yytestcase(yyruleno==396);  yytestcase(yyruleno==397);  yytestcase(yyruleno==398);  yytestcase(yyruleno==399);  yytestcase(yyruleno==400);  break;  };  assert( yyruleno<sizeof(yyRuleInfoLhs)/sizeof(yyRuleInfoLhs[0]) );  yygoto = yyRuleInfoLhs[yyruleno];  yysize = yyRuleInfoNRhs[yyruleno];  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(YYCODETYPE)yygoto);  assert( !(yyact>YY_MAX_SHIFT && yyact<=YY_MAX_SHIFTREDUCE) );  assert( yyact!=YY_ERROR_ACTION );  yymsp += yysize+1;  yypParser->yytos = yymsp;  yymsp->stateno = (YYACTIONTYPE)yyact;  yymsp->major = (YYCODETYPE)yygoto;  yyTraceShift(yypParser, yyact, "... then shift");  return yyact; }
#ifndef YYNOERRORRECOVERY
static void yy_parse_failed(  yyParser *yypParser ){  sqlite3ParserARG_FETCH  sqlite3ParserCTX_FETCH
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);  }
#endif
 while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);  sqlite3ParserARG_STORE  sqlite3ParserCTX_STORE }
#endif
static void yy_syntax_error(  yyParser *yypParser,  int yymajor,  sqlite3ParserTOKENTYPE yyminor ){  sqlite3ParserARG_FETCH  sqlite3ParserCTX_FETCH
#define TOKEN yyminor
 UNUSED_PARAMETER(yymajor);  if( TOKEN.z[0] ){  sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &TOKEN);  }else{  sqlite3ErrorMsg(pParse, "incomplete input");  }  sqlite3ParserARG_STORE  sqlite3ParserCTX_STORE } static void yy_accept(  yyParser *yypParser ){  sqlite3ParserARG_FETCH  sqlite3ParserCTX_FETCH
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);  }
#endif
#ifndef YYNOERRORRECOVERY
 yypParser->yyerrcnt = -1;
#endif
 assert( yypParser->yytos==yypParser->yystack );  sqlite3ParserARG_STORE  sqlite3ParserCTX_STORE } SQLITE_PRIVATE void sqlite3Parser(  void *yyp,  int yymajor,  sqlite3ParserTOKENTYPE yyminor  sqlite3ParserARG_PDECL ){  YYMINORTYPE yyminorunion;  YYACTIONTYPE yyact;
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
 int yyendofinput;
#endif
#ifdef YYERRORSYMBOL
 int yyerrorhit = 0;
#endif
 yyParser *yypParser = (yyParser*)yyp;  sqlite3ParserCTX_FETCH  sqlite3ParserARG_STORE  assert( yypParser->yytos!=0 );
#if !defined(YYERRORSYMBOL) && !defined(YYNOERRORRECOVERY)
 yyendofinput = (yymajor==0);
#endif
 yyact = yypParser->yytos->stateno;
#ifndef NDEBUG
 if( yyTraceFILE ){  if( yyact < YY_MIN_REDUCE ){  fprintf(yyTraceFILE,"%sInput '%s' in state %d\n",  yyTracePrompt,yyTokenName[yymajor],yyact);  }else{  fprintf(yyTraceFILE,"%sInput '%s' with pending reduce %d\n",  yyTracePrompt,yyTokenName[yymajor],yyact-YY_MIN_REDUCE);  }  }
#endif
 while(1){  assert( yypParser->yytos>=yypParser->yystack );  assert( yyact==yypParser->yytos->stateno );  yyact = yy_find_shift_action((YYCODETYPE)yymajor,yyact);  if( yyact >= YY_MIN_REDUCE ){  unsigned int yyruleno = yyact - YY_MIN_REDUCE;
#ifndef NDEBUG
 assert( yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) );  if( yyTraceFILE ){  int yysize = yyRuleInfoNRhs[yyruleno];  if( yysize ){  fprintf(yyTraceFILE, "%sReduce %d [%s]%s, pop back to state %d.\n",  yyTracePrompt,  yyruleno, yyRuleName[yyruleno],  yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action",  yypParser->yytos[yysize].stateno);  }else{  fprintf(yyTraceFILE, "%sReduce %d [%s]%s.\n",  yyTracePrompt, yyruleno, yyRuleName[yyruleno],  yyruleno<YYNRULE_WITH_ACTION ? "" : " without external action");  }  }
#endif
 if( yyRuleInfoNRhs[yyruleno]==0 ){
#ifdef YYTRACKMAXSTACKDEPTH
 if( (int)(yypParser->yytos - yypParser->yystack)>yypParser->yyhwm ){  yypParser->yyhwm++;  assert( yypParser->yyhwm ==  (int)(yypParser->yytos - yypParser->yystack));  }
#endif
#if YYSTACKDEPTH>0
 if( yypParser->yytos>=yypParser->yystackEnd ){  yyStackOverflow(yypParser);  break;  }
#else
 if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){  if( yyGrowStack(yypParser) ){  yyStackOverflow(yypParser);  break;  }  }
#endif
 }  yyact = yy_reduce(yypParser,yyruleno,yymajor,yyminor sqlite3ParserCTX_PARAM);  }else if( yyact <= YY_MAX_SHIFTREDUCE ){  yy_shift(yypParser,yyact,(YYCODETYPE)yymajor,yyminor);
#ifndef YYNOERRORRECOVERY
 yypParser->yyerrcnt--;
#endif
 break;  }else if( yyact==YY_ACCEPT_ACTION ){  yypParser->yytos--;  yy_accept(yypParser);  return;  }else{  assert( yyact == YY_ERROR_ACTION );  yyminorunion.yy0 = yyminor;
#ifdef YYERRORSYMBOL
 int yymx;
#endif
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);  }
#endif
#ifdef YYERRORSYMBOL
 if( yypParser->yyerrcnt<0 ){  yy_syntax_error(yypParser,yymajor,yyminor);  }  yymx = yypParser->yytos->major;  if( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
 if( yyTraceFILE ){  fprintf(yyTraceFILE,"%sDiscard input token %s\n",   yyTracePrompt,yyTokenName[yymajor]);  }
#endif
 yy_destructor(yypParser, (YYCODETYPE)yymajor, &yyminorunion);  yymajor = YYNOCODE;  }else{  while( yypParser->yytos > yypParser->yystack ){  yyact = yy_find_reduce_action(yypParser->yytos->stateno,  YYERRORSYMBOL);  if( yyact<=YY_MAX_SHIFTREDUCE ) break;  yy_pop_parser_stack(yypParser);  }  if( yypParser->yytos <= yypParser->yystack || yymajor==0 ){  yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);  yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
 yypParser->yyerrcnt = -1;
#endif
 yymajor = YYNOCODE;  }else if( yymx!=YYERRORSYMBOL ){  yy_shift(yypParser,yyact,YYERRORSYMBOL,yyminor);  }  }  yypParser->yyerrcnt = 3;  yyerrorhit = 1;  if( yymajor==YYNOCODE ) break;  yyact = yypParser->yytos->stateno;
#elif defined(YYNOERRORRECOVERY)
 yy_syntax_error(yypParser,yymajor, yyminor);  yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);  break;
#else
 if( yypParser->yyerrcnt<=0 ){  yy_syntax_error(yypParser,yymajor, yyminor);  }  yypParser->yyerrcnt = 3;  yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);  if( yyendofinput ){  yy_parse_failed(yypParser);
#ifndef YYNOERRORRECOVERY
 yypParser->yyerrcnt = -1;
#endif
 }  break;
#endif
 }  }
#ifndef NDEBUG
 if( yyTraceFILE ){  yyStackEntry *i;  char cDiv = '[';  fprintf(yyTraceFILE,"%sReturn. Stack=",yyTracePrompt);  for(i=&yypParser->yystack[1]; i<=yypParser->yytos; i++){  fprintf(yyTraceFILE,"%c%s", cDiv, yyTokenName[i->major]);  cDiv = ' ';  }  fprintf(yyTraceFILE,"]\n");  }
#endif
 return; } SQLITE_PRIVATE int sqlite3ParserFallback(int iToken){
#ifdef YYFALLBACK
 assert( iToken<(int)(sizeof(yyFallback)/sizeof(yyFallback[0])) );  return yyFallback[iToken];
#else
 (void)iToken;  return 0;
#endif
}
#define CC_X 0
#define CC_KYWD0 1
#define CC_KYWD  2
#define CC_DIGIT 3
#define CC_DOLLAR  4
#define CC_VARALPHA  5
#define CC_VARNUM  6
#define CC_SPACE 7
#define CC_QUOTE 8
#define CC_QUOTE2  9
#define CC_PIPE 10
#define CC_MINUS  11
#define CC_LT 12
#define CC_GT 13
#define CC_EQ 14
#define CC_BANG 15
#define CC_SLASH  16
#define CC_LP 17
#define CC_RP 18
#define CC_SEMI 19
#define CC_PLUS 20
#define CC_STAR 21
#define CC_PERCENT  22
#define CC_COMMA  23
#define CC_AND  24
#define CC_TILDA  25
#define CC_DOT  26
#define CC_ID 27
#define CC_ILLEGAL  28
#define CC_NUL  29
#define CC_BOM  30
static const unsigned char aiClass[] = {
#ifdef SQLITE_ASCII
  29, 28, 28, 28, 28, 28, 28, 28, 28, 7, 7, 28, 7, 7, 28, 28,   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,  7, 15, 8, 5, 4, 22, 24, 8, 17, 18, 21, 20, 23, 11, 26, 16,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 19, 12, 14, 13, 6,  5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 9, 28, 28, 28, 2,  8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 28, 10, 28, 25, 28,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 30,   27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27
#endif
#ifdef SQLITE_EBCDIC
  29, 28, 28, 28, 28, 7, 28, 28, 28, 28, 28, 28, 7, 7, 28, 28,   28, 28, 28, 28, 28, 7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,   28, 28, 28, 28, 28, 7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,  7, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 26, 12, 17, 20, 10,   24, 28, 28, 28, 28, 28, 28, 28, 28, 28, 15, 4, 21, 18, 19, 28,   11, 16, 28, 28, 28, 28, 28, 28, 28, 28, 28, 23, 22, 2, 13, 6,   28, 28, 28, 28, 28, 28, 28, 28, 28, 8, 5, 5, 5, 8, 14, 8,   28, 1, 1, 1, 1, 1, 1, 1, 1, 1, 28, 28, 28, 28, 28, 28,   28, 1, 1, 1, 1, 1, 1, 1, 1, 1, 28, 28, 28, 28, 28, 28,   28, 25, 1, 1, 1, 1, 1, 0, 2, 2, 28, 28, 28, 28, 28, 28,   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 9, 28, 28, 28, 28, 28,   28, 1, 1, 1, 1, 1, 1, 1, 1, 1, 28, 28, 28, 28, 28, 28,   28, 1, 1, 1, 1, 1, 1, 1, 1, 1, 28, 28, 28, 28, 28, 28,   28, 28, 1, 1, 1, 1, 1, 0, 2, 2, 28, 28, 28, 28, 28, 28,  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 28, 28, 28, 28, 28, 28,
#endif
};
#ifdef SQLITE_ASCII
# define charMap(X) sqlite3UpperToLower[(unsigned char)X]
#endif
#ifdef SQLITE_EBCDIC
# define charMap(X) ebcdicToAscii[(unsigned char)X]
const unsigned char ebcdicToAscii[] = {   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 95, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 97, 98, 99,100,101,102,103,104,105, 0, 0, 0, 0, 0, 0,   0,106,107,108,109,110,111,112,113,114, 0, 0, 0, 0, 0, 0,   0, 0,115,116,117,118,119,120,121,122, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 97, 98, 99,100,101,102,103,104,105, 0, 0, 0, 0, 0, 0,   0,106,107,108,109,110,111,112,113,114, 0, 0, 0, 0, 0, 0,   0, 0,115,116,117,118,119,120,121,122, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
#endif
static const char zKWText[666] = {  'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',  'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',  'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',  'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',  'E','R','R','A','B','L','E','L','S','E','X','C','L','U','D','E','L','E',  'T','E','M','P','O','R','A','R','Y','I','S','N','U','L','L','S','A','V',  'E','P','O','I','N','T','E','R','S','E','C','T','I','E','S','N','O','T',  'N','U','L','L','I','K','E','X','C','E','P','T','R','A','N','S','A','C',  'T','I','O','N','A','T','U','R','A','L','T','E','R','A','I','S','E','X',  'C','L','U','S','I','V','E','X','I','S','T','S','C','O','N','S','T','R',  'A','I','N','T','O','F','F','S','E','T','R','I','G','G','E','R','A','N',  'G','E','N','E','R','A','T','E','D','E','T','A','C','H','A','V','I','N',  'G','L','O','B','E','G','I','N','N','E','R','E','F','E','R','E','N','C',  'E','S','U','N','I','Q','U','E','R','Y','W','I','T','H','O','U','T','E',  'R','E','L','E','A','S','E','A','T','T','A','C','H','B','E','T','W','E',  'E','N','O','T','H','I','N','G','R','O','U','P','S','C','A','S','C','A',  'D','E','F','A','U','L','T','C','A','S','E','C','O','L','L','A','T','E',  'C','R','E','A','T','E','C','U','R','R','E','N','T','_','D','A','T','E',  'I','M','M','E','D','I','A','T','E','J','O','I','N','S','E','R','T','M',  'A','T','C','H','P','L','A','N','A','L','Y','Z','E','P','R','A','G','M',  'A','T','E','R','I','A','L','I','Z','E','D','E','F','E','R','R','E','D',  'I','S','T','I','N','C','T','U','P','D','A','T','E','V','A','L','U','E',  'S','V','I','R','T','U','A','L','W','A','Y','S','W','H','E','N','W','H',  'E','R','E','C','U','R','S','I','V','E','A','B','O','R','T','A','F','T',  'E','R','E','N','A','M','E','A','N','D','R','O','P','A','R','T','I','T',  'I','O','N','A','U','T','O','I','N','C','R','E','M','E','N','T','C','A',  'S','T','C','O','L','U','M','N','C','O','M','M','I','T','C','O','N','F',  'L','I','C','T','C','R','O','S','S','C','U','R','R','E','N','T','_','T',  'I','M','E','S','T','A','M','P','R','E','C','E','D','I','N','G','F','A',  'I','L','A','S','T','F','I','L','T','E','R','E','P','L','A','C','E','F',  'I','R','S','T','F','O','L','L','O','W','I','N','G','F','R','O','M','F',  'U','L','L','I','M','I','T','I','F','O','R','D','E','R','E','S','T','R',  'I','C','T','O','T','H','E','R','S','O','V','E','R','E','T','U','R','N',  'I','N','G','R','I','G','H','T','R','O','L','L','B','A','C','K','R','O',  'W','S','U','N','B','O','U','N','D','E','D','U','N','I','O','N','U','S',  'I','N','G','V','A','C','U','U','M','V','I','E','W','I','N','D','O','W',  'B','Y','I','N','I','T','I','A','L','L','Y','P','R','I','M','A','R','Y', }; static const unsigned char aKWHash[127] = {  84, 92, 134, 82, 105, 29, 0, 0, 94, 0, 85, 72, 0,  53, 35, 86, 15, 0, 42, 97, 54, 89, 135, 19, 0, 0,   140, 0, 40, 129, 0, 22, 107, 0, 9, 0, 0, 123, 80,   0, 78, 6, 0, 65, 103, 147, 0, 136, 115, 0, 0, 48,   0, 90, 24, 0, 17, 0, 27, 70, 23, 26, 5, 60, 142,   110, 122, 0, 73, 91, 71, 145, 61, 120, 74, 0, 49, 0,  11, 41, 0, 113, 0, 0, 0, 109, 10, 111, 116, 125, 14,  50, 124, 0, 100, 0, 18, 121, 144, 56, 130, 139, 88, 83,  37, 30, 126, 0, 0, 108, 51, 131, 128, 0, 34, 0, 0,   132, 0, 98, 38, 39, 0, 20, 45, 117, 93, }; static const unsigned char aKWNext[147] = {   0, 0, 0, 0, 4, 0, 43, 0, 0, 106, 114, 0, 0,   0, 2, 0, 0, 143, 0, 0, 0, 13, 0, 0, 0, 0,   141, 0, 0, 119, 52, 0, 0, 137, 12, 0, 0, 62, 0,   138, 0, 133, 0, 0, 36, 0, 0, 28, 77, 0, 0, 0,   0, 59, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 69, 0, 0, 0, 0, 0, 146, 3, 0, 58, 0, 1,  75, 0, 0, 0, 31, 0, 0, 0, 0, 0, 127, 0, 104,   0, 64, 66, 63, 0, 0, 0, 0, 0, 46, 0, 16, 8,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 81, 101, 0,   112, 21, 7, 67, 0, 79, 96, 118, 0, 0, 68, 0, 0,  99, 44, 0, 55, 0, 76, 0, 95, 32, 33, 57, 25, 0,   102, 0, 0, 87, }; static const unsigned char aKWLen[147] = {   7, 7, 5, 4, 6, 4, 5, 3, 6, 7, 3, 6, 6,   7, 7, 3, 8, 2, 6, 5, 4, 4, 3, 10, 4, 7,   6, 9, 4, 2, 6, 5, 9, 9, 4, 7, 3, 2, 4,   4, 6, 11, 6, 2, 7, 5, 5, 9, 6, 10, 4, 6,   2, 3, 7, 5, 9, 6, 6, 4, 5, 5, 10, 6, 5,   7, 4, 5, 7, 6, 7, 7, 6, 5, 7, 3, 7, 4,   7, 6, 12, 9, 4, 6, 5, 4, 7, 6, 12, 8, 8,   2, 6, 6, 7, 6, 4, 5, 9, 5, 5, 6, 3, 4,   9, 13, 2, 2, 4, 6, 6, 8, 5, 17, 12, 7, 9,   4, 4, 6, 7, 5, 9, 4, 4, 5, 2, 5, 8, 6,   4, 9, 5, 8, 4, 3, 9, 5, 5, 6, 4, 6, 2,   2, 9, 3, 7, }; static const unsigned short int aKWOffset[147] = {   0, 2, 2, 8, 9, 14, 16, 20, 23, 25, 25, 29, 33,  36, 41, 46, 48, 53, 54, 59, 62, 65, 67, 69, 78, 81,  86, 90, 90, 94, 99, 101, 105, 111, 119, 123, 123, 123, 126,   129, 132, 137, 142, 146, 147, 152, 156, 160, 168, 174, 181, 184,   184, 187, 189, 195, 198, 206, 211, 216, 219, 222, 226, 236, 239,   244, 244, 248, 252, 259, 265, 271, 277, 277, 283, 284, 288, 295,   299, 306, 312, 324, 333, 335, 341, 346, 348, 355, 359, 370, 377,   378, 385, 391, 397, 402, 408, 412, 415, 424, 429, 433, 439, 441,   444, 453, 455, 457, 466, 470, 476, 482, 490, 495, 495, 495, 511,   520, 523, 527, 532, 539, 544, 553, 557, 560, 565, 567, 571, 579,   585, 588, 597, 602, 610, 610, 614, 623, 628, 633, 639, 642, 645,   648, 650, 655, 659, }; static const unsigned char aKWCode[147] = {  TK_REINDEX, TK_INDEXED, TK_INDEX, TK_DESC, TK_ESCAPE,  TK_EACH, TK_CHECK, TK_KEY, TK_BEFORE, TK_FOREIGN,  TK_FOR, TK_IGNORE, TK_LIKE_KW, TK_EXPLAIN, TK_INSTEAD,  TK_ADD, TK_DATABASE, TK_AS, TK_SELECT, TK_TABLE,  TK_JOIN_KW, TK_THEN, TK_END, TK_DEFERRABLE, TK_ELSE,  TK_EXCLUDE, TK_DELETE, TK_TEMP, TK_TEMP, TK_OR,  TK_ISNULL, TK_NULLS, TK_SAVEPOINT, TK_INTERSECT, TK_TIES,  TK_NOTNULL, TK_NOT, TK_NO, TK_NULL, TK_LIKE_KW,  TK_EXCEPT, TK_TRANSACTION,TK_ACTION, TK_ON, TK_JOIN_KW,  TK_ALTER, TK_RAISE, TK_EXCLUSIVE, TK_EXISTS, TK_CONSTRAINT,  TK_INTO, TK_OFFSET, TK_OF, TK_SET, TK_TRIGGER,  TK_RANGE, TK_GENERATED, TK_DETACH, TK_HAVING, TK_LIKE_KW,  TK_BEGIN, TK_JOIN_KW, TK_REFERENCES, TK_UNIQUE, TK_QUERY,  TK_WITHOUT, TK_WITH, TK_JOIN_KW, TK_RELEASE, TK_ATTACH,  TK_BETWEEN, TK_NOTHING, TK_GROUPS, TK_GROUP, TK_CASCADE,  TK_ASC, TK_DEFAULT, TK_CASE, TK_COLLATE, TK_CREATE,  TK_CTIME_KW, TK_IMMEDIATE, TK_JOIN, TK_INSERT, TK_MATCH,  TK_PLAN, TK_ANALYZE, TK_PRAGMA, TK_MATERIALIZED, TK_DEFERRED,  TK_DISTINCT, TK_IS, TK_UPDATE, TK_VALUES, TK_VIRTUAL,  TK_ALWAYS, TK_WHEN, TK_WHERE, TK_RECURSIVE, TK_ABORT,  TK_AFTER, TK_RENAME, TK_AND, TK_DROP, TK_PARTITION,  TK_AUTOINCR, TK_TO, TK_IN, TK_CAST, TK_COLUMNKW,  TK_COMMIT, TK_CONFLICT, TK_JOIN_KW, TK_CTIME_KW, TK_CTIME_KW,  TK_CURRENT, TK_PRECEDING, TK_FAIL, TK_LAST, TK_FILTER,  TK_REPLACE, TK_FIRST, TK_FOLLOWING, TK_FROM, TK_JOIN_KW,  TK_LIMIT, TK_IF, TK_ORDER, TK_RESTRICT, TK_OTHERS,  TK_OVER, TK_RETURNING, TK_JOIN_KW, TK_ROLLBACK, TK_ROWS,  TK_ROW, TK_UNBOUNDED, TK_UNION, TK_USING, TK_VACUUM,  TK_VIEW, TK_WINDOW, TK_DO, TK_BY, TK_INITIALLY,  TK_ALL, TK_PRIMARY, }; static int keywordCode(const char *z, int n, int *pType){  int i, j;  const char *zKW;  if( n>=2 ){  i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n*1) % 127;  for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){  if( aKWLen[i]!=n ) continue;  zKW = &zKWText[aKWOffset[i]];
#ifdef SQLITE_ASCII
 if( (z[0]&~0x20)!=zKW[0] ) continue;  if( (z[1]&~0x20)!=zKW[1] ) continue;  j = 2;  while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }
#endif
#ifdef SQLITE_EBCDIC
 if( toupper(z[0])!=zKW[0] ) continue;  if( toupper(z[1])!=zKW[1] ) continue;  j = 2;  while( j<n && toupper(z[j])==zKW[j] ){ j++; }
#endif
 if( j<n ) continue;  testcase( i==0 );  testcase( i==1 );  testcase( i==2 );  testcase( i==3 );  testcase( i==4 );  testcase( i==5 );  testcase( i==6 );  testcase( i==7 );  testcase( i==8 );  testcase( i==9 );  testcase( i==10 );  testcase( i==11 );  testcase( i==12 );  testcase( i==13 );  testcase( i==14 );  testcase( i==15 );  testcase( i==16 );  testcase( i==17 );  testcase( i==18 );  testcase( i==19 );  testcase( i==20 );  testcase( i==21 );  testcase( i==22 );  testcase( i==23 );  testcase( i==24 );  testcase( i==25 );  testcase( i==26 );  testcase( i==27 );  testcase( i==28 );  testcase( i==29 );  testcase( i==30 );  testcase( i==31 );  testcase( i==32 );  testcase( i==33 );  testcase( i==34 );  testcase( i==35 );  testcase( i==36 );  testcase( i==37 );  testcase( i==38 );  testcase( i==39 );  testcase( i==40 );  testcase( i==41 );  testcase( i==42 );  testcase( i==43 );  testcase( i==44 );  testcase( i==45 );  testcase( i==46 );  testcase( i==47 );  testcase( i==48 );  testcase( i==49 );  testcase( i==50 );  testcase( i==51 );  testcase( i==52 );  testcase( i==53 );  testcase( i==54 );  testcase( i==55 );  testcase( i==56 );  testcase( i==57 );  testcase( i==58 );  testcase( i==59 );  testcase( i==60 );  testcase( i==61 );  testcase( i==62 );  testcase( i==63 );  testcase( i==64 );  testcase( i==65 );  testcase( i==66 );  testcase( i==67 );  testcase( i==68 );  testcase( i==69 );  testcase( i==70 );  testcase( i==71 );  testcase( i==72 );  testcase( i==73 );  testcase( i==74 );  testcase( i==75 );  testcase( i==76 );  testcase( i==77 );  testcase( i==78 );  testcase( i==79 );  testcase( i==80 );  testcase( i==81 );  testcase( i==82 );  testcase( i==83 );  testcase( i==84 );  testcase( i==85 );  testcase( i==86 );  testcase( i==87 );  testcase( i==88 );  testcase( i==89 );  testcase( i==90 );  testcase( i==91 );  testcase( i==92 );  testcase( i==93 );  testcase( i==94 );  testcase( i==95 );  testcase( i==96 );  testcase( i==97 );  testcase( i==98 );  testcase( i==99 );  testcase( i==100 );  testcase( i==101 );  testcase( i==102 );  testcase( i==103 );  testcase( i==104 );  testcase( i==105 );  testcase( i==106 );  testcase( i==107 );  testcase( i==108 );  testcase( i==109 );  testcase( i==110 );  testcase( i==111 );  testcase( i==112 );  testcase( i==113 );  testcase( i==114 );  testcase( i==115 );  testcase( i==116 );  testcase( i==117 );  testcase( i==118 );  testcase( i==119 );  testcase( i==120 );  testcase( i==121 );  testcase( i==122 );  testcase( i==123 );  testcase( i==124 );  testcase( i==125 );  testcase( i==126 );  testcase( i==127 );  testcase( i==128 );  testcase( i==129 );  testcase( i==130 );  testcase( i==131 );  testcase( i==132 );  testcase( i==133 );  testcase( i==134 );  testcase( i==135 );  testcase( i==136 );  testcase( i==137 );  testcase( i==138 );  testcase( i==139 );  testcase( i==140 );  testcase( i==141 );  testcase( i==142 );  testcase( i==143 );  testcase( i==144 );  testcase( i==145 );  testcase( i==146 );  *pType = aKWCode[i];  break;  }  }  return n; } SQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char *z, int n){  int id = TK_ID;  keywordCode((char*)z, n, &id);  return id; }
#define SQLITE_N_KEYWORD 147
SQLITE_API int sqlite3_keyword_name(int i,const char **pzName,int *pnName){  if( i<0 || i>=SQLITE_N_KEYWORD ) return SQLITE_ERROR;  *pzName = zKWText + aKWOffset[i];  *pnName = aKWLen[i];  return SQLITE_OK; } SQLITE_API int sqlite3_keyword_count(void){ return SQLITE_N_KEYWORD; } SQLITE_API int sqlite3_keyword_check(const char *zName, int nName){  return TK_ID!=sqlite3KeywordCode((const u8*)zName, nName); }
#ifdef SQLITE_ASCII
#define IdChar(C) ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
#endif
#ifdef SQLITE_EBCDIC
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[] = {  0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, };
#define IdChar(C) (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))
#endif
SQLITE_PRIVATE int sqlite3IsIdChar(u8 c){ return IdChar(c); }
#ifndef SQLITE_OMIT_WINDOWFUNC
static int getToken(const unsigned char **pz){  const unsigned char *z = *pz;  int t;  do {  z += sqlite3GetToken(z, &t);  }while( t==TK_SPACE );  if( t==TK_ID   || t==TK_STRING   || t==TK_JOIN_KW   || t==TK_WINDOW   || t==TK_OVER   || sqlite3ParserFallback(t)==TK_ID  ){  t = TK_ID;  }  *pz = z;  return t; } static int analyzeWindowKeyword(const unsigned char *z){  int t;  t = getToken(&z);  if( t!=TK_ID ) return TK_ID;  t = getToken(&z);  if( t!=TK_AS ) return TK_ID;  return TK_WINDOW; } static int analyzeOverKeyword(const unsigned char *z, int lastToken){  if( lastToken==TK_RP ){  int t = getToken(&z);  if( t==TK_LP || t==TK_ID ) return TK_OVER;  }  return TK_ID; } static int analyzeFilterKeyword(const unsigned char *z, int lastToken){  if( lastToken==TK_RP && getToken(&z)==TK_LP ){  return TK_FILTER;  }  return TK_ID; }
#endif
SQLITE_PRIVATE int sqlite3GetToken(const unsigned char *z, int *tokenType){  int i, c;  switch( aiClass[*z] ){  case CC_SPACE: {  testcase( z[0]==' ' );  testcase( z[0]=='\t' );  testcase( z[0]=='\n' );  testcase( z[0]=='\f' );  testcase( z[0]=='\r' );  for(i=1; sqlite3Isspace(z[i]); i++){}  *tokenType = TK_SPACE;  return i;  }  case CC_MINUS: {  if( z[1]=='-' ){  for(i=2; (c=z[i])!=0 && c!='\n'; i++){}  *tokenType = TK_SPACE;  return i;  }  *tokenType = TK_MINUS;  return 1;  }  case CC_LP: {  *tokenType = TK_LP;  return 1;  }  case CC_RP: {  *tokenType = TK_RP;  return 1;  }  case CC_SEMI: {  *tokenType = TK_SEMI;  return 1;  }  case CC_PLUS: {  *tokenType = TK_PLUS;  return 1;  }  case CC_STAR: {  *tokenType = TK_STAR;  return 1;  }  case CC_SLASH: {  if( z[1]!='*' || z[2]==0 ){  *tokenType = TK_SLASH;  return 1;  }  for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}  if( c ) i++;  *tokenType = TK_SPACE;  return i;  }  case CC_PERCENT: {  *tokenType = TK_REM;  return 1;  }  case CC_EQ: {  *tokenType = TK_EQ;  return 1 + (z[1]=='=');  }  case CC_LT: {  if( (c=z[1])=='=' ){  *tokenType = TK_LE;  return 2;  }else if( c=='>' ){  *tokenType = TK_NE;  return 2;  }else if( c=='<' ){  *tokenType = TK_LSHIFT;  return 2;  }else{  *tokenType = TK_LT;  return 1;  }  }  case CC_GT: {  if( (c=z[1])=='=' ){  *tokenType = TK_GE;  return 2;  }else if( c=='>' ){  *tokenType = TK_RSHIFT;  return 2;  }else{  *tokenType = TK_GT;  return 1;  }  }  case CC_BANG: {  if( z[1]!='=' ){  *tokenType = TK_ILLEGAL;  return 1;  }else{  *tokenType = TK_NE;  return 2;  }  }  case CC_PIPE: {  if( z[1]!='|' ){  *tokenType = TK_BITOR;  return 1;  }else{  *tokenType = TK_CONCAT;  return 2;  }  }  case CC_COMMA: {  *tokenType = TK_COMMA;  return 1;  }  case CC_AND: {  *tokenType = TK_BITAND;  return 1;  }  case CC_TILDA: {  *tokenType = TK_BITNOT;  return 1;  }  case CC_QUOTE: {  int delim = z[0];  testcase( delim=='`' );  testcase( delim=='\'' );  testcase( delim=='"' );  for(i=1; (c=z[i])!=0; i++){  if( c==delim ){  if( z[i+1]==delim ){  i++;  }else{  break;  }  }  }  if( c=='\'' ){  *tokenType = TK_STRING;  return i+1;  }else if( c!=0 ){  *tokenType = TK_ID;  return i+1;  }else{  *tokenType = TK_ILLEGAL;  return i;  }  }  case CC_DOT: {
#ifndef SQLITE_OMIT_FLOATING_POINT
 if( !sqlite3Isdigit(z[1]) )
#endif
 {  *tokenType = TK_DOT;  return 1;  }  deliberate_fall_through  }  case CC_DIGIT: {  testcase( z[0]=='0' ); testcase( z[0]=='1' ); testcase( z[0]=='2' );  testcase( z[0]=='3' ); testcase( z[0]=='4' ); testcase( z[0]=='5' );  testcase( z[0]=='6' ); testcase( z[0]=='7' ); testcase( z[0]=='8' );  testcase( z[0]=='9' );  *tokenType = TK_INTEGER;
#ifndef SQLITE_OMIT_HEX_INTEGER
 if( z[0]=='0' && (z[1]=='x' || z[1]=='X') && sqlite3Isxdigit(z[2]) ){  for(i=3; sqlite3Isxdigit(z[i]); i++){}  return i;  }
#endif
 for(i=0; sqlite3Isdigit(z[i]); i++){}
#ifndef SQLITE_OMIT_FLOATING_POINT
 if( z[i]=='.' ){  i++;  while( sqlite3Isdigit(z[i]) ){ i++; }  *tokenType = TK_FLOAT;  }  if( (z[i]=='e' || z[i]=='E') &&   ( sqlite3Isdigit(z[i+1])  || ((z[i+1]=='+' || z[i+1]=='-') && sqlite3Isdigit(z[i+2]))   )  ){  i += 2;  while( sqlite3Isdigit(z[i]) ){ i++; }  *tokenType = TK_FLOAT;  }
#endif
 while( IdChar(z[i]) ){  *tokenType = TK_ILLEGAL;  i++;  }  return i;  }  case CC_QUOTE2: {  for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}  *tokenType = c==']' ? TK_ID : TK_ILLEGAL;  return i;  }  case CC_VARNUM: {  *tokenType = TK_VARIABLE;  for(i=1; sqlite3Isdigit(z[i]); i++){}  return i;  }  case CC_DOLLAR:  case CC_VARALPHA: {  int n = 0;  testcase( z[0]=='$' ); testcase( z[0]=='@' );  testcase( z[0]==':' ); testcase( z[0]=='#' );  *tokenType = TK_VARIABLE;  for(i=1; (c=z[i])!=0; i++){  if( IdChar(c) ){  n++;
#ifndef SQLITE_OMIT_TCL_VARIABLE
 }else if( c=='(' && n>0 ){  do{  i++;  }while( (c=z[i])!=0 && !sqlite3Isspace(c) && c!=')' );  if( c==')' ){  i++;  }else{  *tokenType = TK_ILLEGAL;  }  break;  }else if( c==':' && z[i+1]==':' ){  i++;
#endif
 }else{  break;  }  }  if( n==0 ) *tokenType = TK_ILLEGAL;  return i;  }  case CC_KYWD0: {  for(i=1; aiClass[z[i]]<=CC_KYWD; i++){}  if( IdChar(z[i]) ){  i++;  break;  }  *tokenType = TK_ID;  return keywordCode((char*)z, i, tokenType);  }  case CC_X: {
#ifndef SQLITE_OMIT_BLOB_LITERAL
 testcase( z[0]=='x' ); testcase( z[0]=='X' );  if( z[1]=='\'' ){  *tokenType = TK_BLOB;  for(i=2; sqlite3Isxdigit(z[i]); i++){}  if( z[i]!='\'' || i%2 ){  *tokenType = TK_ILLEGAL;  while( z[i] && z[i]!='\'' ){ i++; }  }  if( z[i] ) i++;  return i;  }
#endif
 deliberate_fall_through  }  case CC_KYWD:  case CC_ID: {  i = 1;  break;  }  case CC_BOM: {  if( z[1]==0xbb && z[2]==0xbf ){  *tokenType = TK_SPACE;  return 3;  }  i = 1;  break;  }  case CC_NUL: {  *tokenType = TK_ILLEGAL;  return 0;  }  default: {  *tokenType = TK_ILLEGAL;  return 1;  }  }  while( IdChar(z[i]) ){ i++; }  *tokenType = TK_ID;  return i; } SQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){  int nErr = 0;  void *pEngine;  int n = 0;  int tokenType;  int lastTokenParsed = -1;  sqlite3 *db = pParse->db;  int mxSqlLen;  Parse *pParentParse = 0;
#ifdef sqlite3Parser_ENGINEALWAYSONSTACK
 yyParser sEngine;
#endif
 VVA_ONLY( u8 startedWithOom = db->mallocFailed );  assert( zSql!=0 );  mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];  if( db->nVdbeActive==0 ){  AtomicStore(&db->u1.isInterrupted, 0);  }  pParse->rc = SQLITE_OK;  pParse->zTail = zSql;  assert( pzErrMsg!=0 );
#ifdef SQLITE_DEBUG
 if( db->flags & SQLITE_ParserTrace ){  printf("parser: [[[%s]]]\n", zSql);  sqlite3ParserTrace(stdout, "parser: ");  }else{  sqlite3ParserTrace(0, 0);  }
#endif
#ifdef sqlite3Parser_ENGINEALWAYSONSTACK
 pEngine = &sEngine;  sqlite3ParserInit(pEngine, pParse);
#else
 pEngine = sqlite3ParserAlloc(sqlite3Malloc, pParse);  if( pEngine==0 ){  sqlite3OomFault(db);  return SQLITE_NOMEM_BKPT;  }
#endif
 assert( pParse->pNewTable==0 );  assert( pParse->pNewTrigger==0 );  assert( pParse->nVar==0 );  assert( pParse->pVList==0 );  pParentParse = db->pParse;  db->pParse = pParse;  while( 1 ){  n = sqlite3GetToken((u8*)zSql, &tokenType);  mxSqlLen -= n;  if( mxSqlLen<0 ){  pParse->rc = SQLITE_TOOBIG;  break;  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 if( tokenType>=TK_WINDOW ){  assert( tokenType==TK_SPACE || tokenType==TK_OVER || tokenType==TK_FILTER   || tokenType==TK_ILLEGAL || tokenType==TK_WINDOW  );
#else
 if( tokenType>=TK_SPACE ){  assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );
#endif
 if( AtomicLoad(&db->u1.isInterrupted) ){  pParse->rc = SQLITE_INTERRUPT;  break;  }  if( tokenType==TK_SPACE ){  zSql += n;  continue;  }  if( zSql[0]==0 ){  if( lastTokenParsed==TK_SEMI ){  tokenType = 0;  }else if( lastTokenParsed==0 ){  break;  }else{  tokenType = TK_SEMI;  }  n = 0;
#ifndef SQLITE_OMIT_WINDOWFUNC
 }else if( tokenType==TK_WINDOW ){  assert( n==6 );  tokenType = analyzeWindowKeyword((const u8*)&zSql[6]);  }else if( tokenType==TK_OVER ){  assert( n==4 );  tokenType = analyzeOverKeyword((const u8*)&zSql[4], lastTokenParsed);  }else if( tokenType==TK_FILTER ){  assert( n==6 );  tokenType = analyzeFilterKeyword((const u8*)&zSql[6], lastTokenParsed);
#endif
 }else{  sqlite3ErrorMsg(pParse, "unrecognized token: \"%.*s\"", n, zSql);  break;  }  }  pParse->sLastToken.z = zSql;  pParse->sLastToken.n = n;  sqlite3Parser(pEngine, tokenType, pParse->sLastToken);  lastTokenParsed = tokenType;  zSql += n;  assert( db->mallocFailed==0 || pParse->rc!=SQLITE_OK || startedWithOom );  if( pParse->rc!=SQLITE_OK ) break;  }  assert( nErr==0 );
#ifdef YYTRACKMAXSTACKDEPTH
 sqlite3_mutex_enter(sqlite3MallocMutex());  sqlite3StatusHighwater(SQLITE_STATUS_PARSER_STACK,  sqlite3ParserStackPeak(pEngine)  );  sqlite3_mutex_leave(sqlite3MallocMutex());
#endif
#ifdef sqlite3Parser_ENGINEALWAYSONSTACK
 sqlite3ParserFinalize(pEngine);
#else
 sqlite3ParserFree(pEngine, sqlite3_free);
#endif
 if( db->mallocFailed ){  pParse->rc = SQLITE_NOMEM_BKPT;  }  if( pParse->rc!=SQLITE_OK && pParse->rc!=SQLITE_DONE && pParse->zErrMsg==0 ){  pParse->zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr(pParse->rc));  }  assert( pzErrMsg!=0 );  if( pParse->zErrMsg ){  *pzErrMsg = pParse->zErrMsg;  sqlite3_log(pParse->rc, "%s in \"%s\"",  *pzErrMsg, pParse->zTail);  pParse->zErrMsg = 0;  nErr++;  }  pParse->zTail = zSql;  if( pParse->pVdbe && pParse->nErr>0 && pParse->nested==0 ){  sqlite3VdbeDelete(pParse->pVdbe);  pParse->pVdbe = 0;  }
#ifndef SQLITE_OMIT_SHARED_CACHE
 if( pParse->nested==0 ){  sqlite3DbFree(db, pParse->aTableLock);  pParse->aTableLock = 0;  pParse->nTableLock = 0;  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 sqlite3_free(pParse->apVtabLock);
#endif
 if( !IN_SPECIAL_PARSE ){  sqlite3DeleteTable(db, pParse->pNewTable);  }  if( !IN_RENAME_OBJECT ){  sqlite3DeleteTrigger(db, pParse->pNewTrigger);  }  sqlite3DbFree(db, pParse->pVList);  db->pParse = pParentParse;  assert( nErr==0 || pParse->rc!=SQLITE_OK );  return nErr; }
#ifdef SQLITE_ENABLE_NORMALIZE
static void addSpaceSeparator(sqlite3_str *pStr){  if( pStr->nChar && sqlite3IsIdChar(pStr->zText[pStr->nChar-1]) ){  sqlite3_str_append(pStr, " ", 1);  } } SQLITE_PRIVATE char *sqlite3Normalize(  Vdbe *pVdbe,  const char *zSql ){  sqlite3 *db;  int i;  int n;  int tokenType;  int prevType = 0;  int nParen;  int iStartIN;  int nParenAtIN;  u32 j;  sqlite3_str *pStr;  db = sqlite3VdbeDb(pVdbe);  tokenType = -1;  nParen = iStartIN = nParenAtIN = 0;  pStr = sqlite3_str_new(db);  assert( pStr!=0 );  for(i=0; zSql[i] && pStr->accError==0; i+=n){  if( tokenType!=TK_SPACE ){  prevType = tokenType;  }  n = sqlite3GetToken((unsigned char*)zSql+i, &tokenType);  if( NEVER(n<=0) ) break;  switch( tokenType ){  case TK_SPACE: {  break;  }  case TK_NULL: {  if( prevType==TK_IS || prevType==TK_NOT ){  sqlite3_str_append(pStr, " NULL", 5);  break;  }  }  case TK_STRING:  case TK_INTEGER:  case TK_FLOAT:  case TK_VARIABLE:  case TK_BLOB: {  sqlite3_str_append(pStr, "?", 1);  break;  }  case TK_LP: {  nParen++;  if( prevType==TK_IN ){  iStartIN = pStr->nChar;  nParenAtIN = nParen;  }  sqlite3_str_append(pStr, "(", 1);  break;  }  case TK_RP: {  if( iStartIN>0 && nParen==nParenAtIN ){  assert( pStr->nChar>=(u32)iStartIN );  pStr->nChar = iStartIN+1;  sqlite3_str_append(pStr, "?,?,?", 5);  iStartIN = 0;  }  nParen--;  sqlite3_str_append(pStr, ")", 1);  break;  }  case TK_ID: {  iStartIN = 0;  j = pStr->nChar;  if( sqlite3Isquote(zSql[i]) ){  char *zId = sqlite3DbStrNDup(db, zSql+i, n);  int nId;  int eType = 0;  if( zId==0 ) break;  sqlite3Dequote(zId);  if( zSql[i]=='"' && sqlite3VdbeUsesDoubleQuotedString(pVdbe, zId) ){  sqlite3_str_append(pStr, "?", 1);  sqlite3DbFree(db, zId);  break;  }  nId = sqlite3Strlen30(zId);  if( sqlite3GetToken((u8*)zId, &eType)==nId && eType==TK_ID ){  addSpaceSeparator(pStr);  sqlite3_str_append(pStr, zId, nId);  }else{  sqlite3_str_appendf(pStr, "\"%w\"", zId);  }  sqlite3DbFree(db, zId);  }else{  addSpaceSeparator(pStr);  sqlite3_str_append(pStr, zSql+i, n);  }  while( j<pStr->nChar ){  pStr->zText[j] = sqlite3Tolower(pStr->zText[j]);  j++;  }  break;  }  case TK_SELECT: {  iStartIN = 0;  }  default: {  if( sqlite3IsIdChar(zSql[i]) ) addSpaceSeparator(pStr);  j = pStr->nChar;  sqlite3_str_append(pStr, zSql+i, n);  while( j<pStr->nChar ){  pStr->zText[j] = sqlite3Toupper(pStr->zText[j]);  j++;  }  break;  }  }  }  if( tokenType!=TK_SEMI ) sqlite3_str_append(pStr, ";", 1);  return sqlite3_str_finish(pStr); }
#endif
#ifndef SQLITE_OMIT_COMPLETE
#ifndef SQLITE_AMALGAMATION
#ifdef SQLITE_ASCII
#define IdChar(C) ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
#endif
#ifdef SQLITE_EBCDIC
SQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[];
#define IdChar(C) (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))
#endif
#endif
#define tkSEMI 0
#define tkWS 1
#define tkOTHER  2
#ifndef SQLITE_OMIT_TRIGGER
#define tkEXPLAIN 3
#define tkCREATE 4
#define tkTEMP 5
#define tkTRIGGER 6
#define tkEND  7
#endif
SQLITE_API int sqlite3_complete(const char *zSql){  u8 state = 0;  u8 token;
#ifndef SQLITE_OMIT_TRIGGER
 static const u8 trans[8][8] = {  { 1, 0, 2, 3, 4, 2, 2, 2, },  { 1, 1, 2, 3, 4, 2, 2, 2, },  { 1, 2, 2, 2, 2, 2, 2, 2, },  { 1, 3, 3, 2, 4, 2, 2, 2, },  { 1, 4, 2, 2, 2, 4, 5, 2, },  { 6, 5, 5, 5, 5, 5, 5, 5, },  { 6, 6, 5, 5, 5, 5, 5, 7, },  { 1, 7, 5, 5, 5, 5, 5, 5, },  };
#else
 static const u8 trans[3][3] = {  { 1, 0, 2, },  { 1, 1, 2, },  { 1, 2, 2, },  };
#endif
#ifdef SQLITE_ENABLE_API_ARMOR
 if( zSql==0 ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 while( *zSql ){  switch( *zSql ){  case ';': {  token = tkSEMI;  break;  }  case ' ':  case '\r':  case '\t':  case '\n':  case '\f': {  token = tkWS;  break;  }  case '/': {  if( zSql[1]!='*' ){  token = tkOTHER;  break;  }  zSql += 2;  while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }  if( zSql[0]==0 ) return 0;  zSql++;  token = tkWS;  break;  }  case '-': {  if( zSql[1]!='-' ){  token = tkOTHER;  break;  }  while( *zSql && *zSql!='\n' ){ zSql++; }  if( *zSql==0 ) return state==1;  token = tkWS;  break;  }  case '[': {  zSql++;  while( *zSql && *zSql!=']' ){ zSql++; }  if( *zSql==0 ) return 0;  token = tkOTHER;  break;  }  case '`':  case '"':  case '\'': {  int c = *zSql;  zSql++;  while( *zSql && *zSql!=c ){ zSql++; }  if( *zSql==0 ) return 0;  token = tkOTHER;  break;  }  default: {
#ifdef SQLITE_EBCDIC
 unsigned char c;
#endif
 if( IdChar((u8)*zSql) ){  int nId;  for(nId=1; IdChar(zSql[nId]); nId++){}
#ifdef SQLITE_OMIT_TRIGGER
 token = tkOTHER;
#else
 switch( *zSql ){  case 'c': case 'C': {  if( nId==6 && sqlite3StrNICmp(zSql, "create", 6)==0 ){  token = tkCREATE;  }else{  token = tkOTHER;  }  break;  }  case 't': case 'T': {  if( nId==7 && sqlite3StrNICmp(zSql, "trigger", 7)==0 ){  token = tkTRIGGER;  }else if( nId==4 && sqlite3StrNICmp(zSql, "temp", 4)==0 ){  token = tkTEMP;  }else if( nId==9 && sqlite3StrNICmp(zSql, "temporary", 9)==0 ){  token = tkTEMP;  }else{  token = tkOTHER;  }  break;  }  case 'e': case 'E': {  if( nId==3 && sqlite3StrNICmp(zSql, "end", 3)==0 ){  token = tkEND;  }else
#ifndef SQLITE_OMIT_EXPLAIN
 if( nId==7 && sqlite3StrNICmp(zSql, "explain", 7)==0 ){  token = tkEXPLAIN;  }else
#endif
 {  token = tkOTHER;  }  break;  }  default: {  token = tkOTHER;  break;  }  }
#endif
 zSql += nId-1;  }else{  token = tkOTHER;  }  break;  }  }  state = trans[state][token];  zSql++;  }  return state==1; }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_complete16(const void *zSql){  sqlite3_value *pVal;  char const *zSql8;  int rc;
#ifndef SQLITE_OMIT_AUTOINIT
 rc = sqlite3_initialize();  if( rc ) return rc;
#endif
 pVal = sqlite3ValueNew(0);  sqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC);  zSql8 = sqlite3ValueText(pVal, SQLITE_UTF8);  if( zSql8 ){  rc = sqlite3_complete(zSql8);  }else{  rc = SQLITE_NOMEM_BKPT;  }  sqlite3ValueFree(pVal);  return rc & 0xff; }
#endif
#endif
#ifdef SQLITE_ENABLE_FTS3
#if 0
extern "C" {
#endif
SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db);
#if 0
}
#endif
#endif
#ifdef SQLITE_ENABLE_RTREE
#ifdef SQLITE_OMIT_VIRTUALTABLE
# undef SQLITE_ENABLE_RTREE
#endif
#if 0
extern "C" {
#endif
SQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db);
#if 0
}
#endif
#endif
#if defined(SQLITE_ENABLE_ICU) || defined(SQLITE_ENABLE_ICU_COLLATIONS)
#if 0
extern "C" {
#endif
SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db);
#if 0
}
#endif
#endif
static int sqlite3TestExtInit(sqlite3 *db){  (void)db;  return sqlite3FaultSim(500); }
#ifdef SQLITE_ENABLE_FTS1
SQLITE_PRIVATE int sqlite3Fts1Init(sqlite3*);
#endif
#ifdef SQLITE_ENABLE_FTS2
SQLITE_PRIVATE int sqlite3Fts2Init(sqlite3*);
#endif
#ifdef SQLITE_ENABLE_FTS5
SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3*);
#endif
#ifdef SQLITE_ENABLE_JSON1
SQLITE_PRIVATE int sqlite3Json1Init(sqlite3*);
#endif
#ifdef SQLITE_ENABLE_STMTVTAB
SQLITE_PRIVATE int sqlite3StmtVtabInit(sqlite3*);
#endif
static int (*const sqlite3BuiltinExtensions[])(sqlite3*) = {
#ifdef SQLITE_ENABLE_FTS1
 sqlite3Fts1Init,
#endif
#ifdef SQLITE_ENABLE_FTS2
 sqlite3Fts2Init,
#endif
#ifdef SQLITE_ENABLE_FTS3
 sqlite3Fts3Init,
#endif
#ifdef SQLITE_ENABLE_FTS5
 sqlite3Fts5Init,
#endif
#if defined(SQLITE_ENABLE_ICU) || defined(SQLITE_ENABLE_ICU_COLLATIONS)
 sqlite3IcuInit,
#endif
#ifdef SQLITE_ENABLE_RTREE
 sqlite3RtreeInit,
#endif
#ifdef SQLITE_ENABLE_DBPAGE_VTAB
 sqlite3DbpageRegister,
#endif
#ifdef SQLITE_ENABLE_DBSTAT_VTAB
 sqlite3DbstatRegister,
#endif
 sqlite3TestExtInit,
#ifdef SQLITE_ENABLE_JSON1
 sqlite3Json1Init,
#endif
#ifdef SQLITE_ENABLE_STMTVTAB
 sqlite3StmtVtabInit,
#endif
#ifdef SQLITE_ENABLE_BYTECODE_VTAB
 sqlite3VdbeBytecodeVtabInit,
#endif
};
#ifndef SQLITE_AMALGAMATION
SQLITE_API const char sqlite3_version[] = SQLITE_VERSION;
#endif
SQLITE_API const char *sqlite3_libversion(void){ return sqlite3_version; } SQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; } SQLITE_API int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }
#ifdef SQLITE_HAVE_OS_TRACE
# ifndef SQLITE_DEBUG_OS_TRACE
#  define SQLITE_DEBUG_OS_TRACE 0
# endif
 int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;
#endif
#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)
SQLITE_API void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...) = 0;
#endif
SQLITE_API char *sqlite3_temp_directory = 0; SQLITE_API char *sqlite3_data_directory = 0; SQLITE_API int sqlite3_initialize(void){  MUTEX_LOGIC( sqlite3_mutex *pMainMtx; )  int rc;
#ifdef SQLITE_EXTRA_INIT
 int bRunExtraInit = 0;
#endif
#ifdef SQLITE_OMIT_WSD
 rc = sqlite3_wsd_init(4096, 24);  if( rc!=SQLITE_OK ){  return rc;  }
#endif
 assert( SQLITE_PTRSIZE==sizeof(char*) );  if( sqlite3GlobalConfig.isInit ){  sqlite3MemoryBarrier();  return SQLITE_OK;  }  rc = sqlite3MutexInit();  if( rc ) return rc;  MUTEX_LOGIC( pMainMtx = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN); )  sqlite3_mutex_enter(pMainMtx);  sqlite3GlobalConfig.isMutexInit = 1;  if( !sqlite3GlobalConfig.isMallocInit ){  rc = sqlite3MallocInit();  }  if( rc==SQLITE_OK ){  sqlite3GlobalConfig.isMallocInit = 1;  if( !sqlite3GlobalConfig.pInitMutex ){  sqlite3GlobalConfig.pInitMutex =   sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);  if( sqlite3GlobalConfig.bCoreMutex && !sqlite3GlobalConfig.pInitMutex ){  rc = SQLITE_NOMEM_BKPT;  }  }  }  if( rc==SQLITE_OK ){  sqlite3GlobalConfig.nRefInitMutex++;  }  sqlite3_mutex_leave(pMainMtx);  if( rc!=SQLITE_OK ){  return rc;  }  sqlite3_mutex_enter(sqlite3GlobalConfig.pInitMutex);  if( sqlite3GlobalConfig.isInit==0 && sqlite3GlobalConfig.inProgress==0 ){  sqlite3GlobalConfig.inProgress = 1;
#ifdef SQLITE_ENABLE_SQLLOG
 {  extern void sqlite3_init_sqllog(void);  sqlite3_init_sqllog();  }
#endif
 memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));  sqlite3RegisterBuiltinFunctions();  if( sqlite3GlobalConfig.isPCacheInit==0 ){  rc = sqlite3PcacheInitialize();  }  if( rc==SQLITE_OK ){  sqlite3GlobalConfig.isPCacheInit = 1;  rc = sqlite3OsInit();  }
#ifndef SQLITE_OMIT_DESERIALIZE
 if( rc==SQLITE_OK ){  rc = sqlite3MemdbInit();  }
#endif
 if( rc==SQLITE_OK ){  sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage,  sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage);  sqlite3MemoryBarrier();  sqlite3GlobalConfig.isInit = 1;
#ifdef SQLITE_EXTRA_INIT
 bRunExtraInit = 1;
#endif
 }  sqlite3GlobalConfig.inProgress = 0;  }  sqlite3_mutex_leave(sqlite3GlobalConfig.pInitMutex);  sqlite3_mutex_enter(pMainMtx);  sqlite3GlobalConfig.nRefInitMutex--;  if( sqlite3GlobalConfig.nRefInitMutex<=0 ){  assert( sqlite3GlobalConfig.nRefInitMutex==0 );  sqlite3_mutex_free(sqlite3GlobalConfig.pInitMutex);  sqlite3GlobalConfig.pInitMutex = 0;  }  sqlite3_mutex_leave(pMainMtx);
#ifndef NDEBUG
#ifndef SQLITE_OMIT_FLOATING_POINT
 if( rc==SQLITE_OK ){  u64 x = (((u64)1)<<63)-1;  double y;  assert(sizeof(x)==8);  assert(sizeof(x)==sizeof(y));  memcpy(&y, &x, 8);  assert( sqlite3IsNaN(y) );  }
#endif
#endif
#ifdef SQLITE_EXTRA_INIT
 if( bRunExtraInit ){  int SQLITE_EXTRA_INIT(const char*);  rc = SQLITE_EXTRA_INIT(0);  }
#endif
 return rc; } SQLITE_API int sqlite3_shutdown(void){
#ifdef SQLITE_OMIT_WSD
 int rc = sqlite3_wsd_init(4096, 24);  if( rc!=SQLITE_OK ){  return rc;  }
#endif
 if( sqlite3GlobalConfig.isInit ){
#ifdef SQLITE_EXTRA_SHUTDOWN
 void SQLITE_EXTRA_SHUTDOWN(void);  SQLITE_EXTRA_SHUTDOWN();
#endif
 sqlite3_os_end();  sqlite3_reset_auto_extension();  sqlite3GlobalConfig.isInit = 0;  }  if( sqlite3GlobalConfig.isPCacheInit ){  sqlite3PcacheShutdown();  sqlite3GlobalConfig.isPCacheInit = 0;  }  if( sqlite3GlobalConfig.isMallocInit ){  sqlite3MallocEnd();  sqlite3GlobalConfig.isMallocInit = 0;
#ifndef SQLITE_OMIT_SHUTDOWN_DIRECTORIES
 sqlite3_data_directory = 0;  sqlite3_temp_directory = 0;
#endif
 }  if( sqlite3GlobalConfig.isMutexInit ){  sqlite3MutexEnd();  sqlite3GlobalConfig.isMutexInit = 0;  }  return SQLITE_OK; } SQLITE_API int sqlite3_config(int op, ...){  va_list ap;  int rc = SQLITE_OK;  if( sqlite3GlobalConfig.isInit ) return SQLITE_MISUSE_BKPT;  va_start(ap, op);  switch( op ){
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0
 case SQLITE_CONFIG_SINGLETHREAD: {  sqlite3GlobalConfig.bCoreMutex = 0;  sqlite3GlobalConfig.bFullMutex = 0;  break;  }
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0
 case SQLITE_CONFIG_MULTITHREAD: {  sqlite3GlobalConfig.bCoreMutex = 1;  sqlite3GlobalConfig.bFullMutex = 0;  break;  }
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0
 case SQLITE_CONFIG_SERIALIZED: {  sqlite3GlobalConfig.bCoreMutex = 1;  sqlite3GlobalConfig.bFullMutex = 1;  break;  }
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0
 case SQLITE_CONFIG_MUTEX: {  sqlite3GlobalConfig.mutex = *va_arg(ap, sqlite3_mutex_methods*);  break;  }
#endif
#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0
 case SQLITE_CONFIG_GETMUTEX: {  *va_arg(ap, sqlite3_mutex_methods*) = sqlite3GlobalConfig.mutex;  break;  }
#endif
 case SQLITE_CONFIG_MALLOC: {  sqlite3GlobalConfig.m = *va_arg(ap, sqlite3_mem_methods*);  break;  }  case SQLITE_CONFIG_GETMALLOC: {  if( sqlite3GlobalConfig.m.xMalloc==0 ) sqlite3MemSetDefault();  *va_arg(ap, sqlite3_mem_methods*) = sqlite3GlobalConfig.m;  break;  }  case SQLITE_CONFIG_MEMSTATUS: {  sqlite3GlobalConfig.bMemstat = va_arg(ap, int);  break;  }  case SQLITE_CONFIG_SMALL_MALLOC: {  sqlite3GlobalConfig.bSmallMalloc = va_arg(ap, int);  break;  }  case SQLITE_CONFIG_PAGECACHE: {  sqlite3GlobalConfig.pPage = va_arg(ap, void*);  sqlite3GlobalConfig.szPage = va_arg(ap, int);  sqlite3GlobalConfig.nPage = va_arg(ap, int);  break;  }  case SQLITE_CONFIG_PCACHE_HDRSZ: {  *va_arg(ap, int*) =  sqlite3HeaderSizeBtree() +  sqlite3HeaderSizePcache() +  sqlite3HeaderSizePcache1();  break;  }  case SQLITE_CONFIG_PCACHE: {  break;  }  case SQLITE_CONFIG_GETPCACHE: {  rc = SQLITE_ERROR;  break;  }  case SQLITE_CONFIG_PCACHE2: {  sqlite3GlobalConfig.pcache2 = *va_arg(ap, sqlite3_pcache_methods2*);  break;  }  case SQLITE_CONFIG_GETPCACHE2: {  if( sqlite3GlobalConfig.pcache2.xInit==0 ){  sqlite3PCacheSetDefault();  }  *va_arg(ap, sqlite3_pcache_methods2*) = sqlite3GlobalConfig.pcache2;  break;  }
#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)
 case SQLITE_CONFIG_HEAP: {  sqlite3GlobalConfig.pHeap = va_arg(ap, void*);  sqlite3GlobalConfig.nHeap = va_arg(ap, int);  sqlite3GlobalConfig.mnReq = va_arg(ap, int);  if( sqlite3GlobalConfig.mnReq<1 ){  sqlite3GlobalConfig.mnReq = 1;  }else if( sqlite3GlobalConfig.mnReq>(1<<12) ){  sqlite3GlobalConfig.mnReq = (1<<12);  }  if( sqlite3GlobalConfig.pHeap==0 ){  memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m));  }else{
#ifdef SQLITE_ENABLE_MEMSYS3
 sqlite3GlobalConfig.m = *sqlite3MemGetMemsys3();
#endif
#ifdef SQLITE_ENABLE_MEMSYS5
 sqlite3GlobalConfig.m = *sqlite3MemGetMemsys5();
#endif
 }  break;  }
#endif
 case SQLITE_CONFIG_LOOKASIDE: {  sqlite3GlobalConfig.szLookaside = va_arg(ap, int);  sqlite3GlobalConfig.nLookaside = va_arg(ap, int);  break;  }  case SQLITE_CONFIG_LOG: {  typedef void(*LOGFUNC_t)(void*,int,const char*);  sqlite3GlobalConfig.xLog = va_arg(ap, LOGFUNC_t);  sqlite3GlobalConfig.pLogArg = va_arg(ap, void*);  break;  }  case SQLITE_CONFIG_URI: {  sqlite3GlobalConfig.bOpenUri = va_arg(ap, int);  break;  }  case SQLITE_CONFIG_COVERING_INDEX_SCAN: {  sqlite3GlobalConfig.bUseCis = va_arg(ap, int);  break;  }
#ifdef SQLITE_ENABLE_SQLLOG
 case SQLITE_CONFIG_SQLLOG: {  typedef void(*SQLLOGFUNC_t)(void*, sqlite3*, const char*, int);  sqlite3GlobalConfig.xSqllog = va_arg(ap, SQLLOGFUNC_t);  sqlite3GlobalConfig.pSqllogArg = va_arg(ap, void *);  break;  }
#endif
 case SQLITE_CONFIG_MMAP_SIZE: {  sqlite3_int64 szMmap = va_arg(ap, sqlite3_int64);  sqlite3_int64 mxMmap = va_arg(ap, sqlite3_int64);  if( mxMmap<0 || mxMmap>SQLITE_MAX_MMAP_SIZE ){  mxMmap = SQLITE_MAX_MMAP_SIZE;  }  if( szMmap<0 ) szMmap = SQLITE_DEFAULT_MMAP_SIZE;  if( szMmap>mxMmap) szMmap = mxMmap;  sqlite3GlobalConfig.mxMmap = mxMmap;  sqlite3GlobalConfig.szMmap = szMmap;  break;  }
#if SQLITE_OS_WIN && defined(SQLITE_WIN32_MALLOC)
 case SQLITE_CONFIG_WIN32_HEAPSIZE: {  sqlite3GlobalConfig.nHeap = va_arg(ap, int);  break;  }
#endif
 case SQLITE_CONFIG_PMASZ: {  sqlite3GlobalConfig.szPma = va_arg(ap, unsigned int);  break;  }  case SQLITE_CONFIG_STMTJRNL_SPILL: {  sqlite3GlobalConfig.nStmtSpill = va_arg(ap, int);  break;  }
#ifdef SQLITE_ENABLE_SORTER_REFERENCES
 case SQLITE_CONFIG_SORTERREF_SIZE: {  int iVal = va_arg(ap, int);  if( iVal<0 ){  iVal = SQLITE_DEFAULT_SORTERREF_SIZE;  }  sqlite3GlobalConfig.szSorterRef = (u32)iVal;  break;  }
#endif
#ifndef SQLITE_OMIT_DESERIALIZE
 case SQLITE_CONFIG_MEMDB_MAXSIZE: {  sqlite3GlobalConfig.mxMemdbSize = va_arg(ap, sqlite3_int64);  break;  }
#endif
 default: {  rc = SQLITE_ERROR;  break;  }  }  va_end(ap);  return rc; } static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
#ifndef SQLITE_OMIT_LOOKASIDE
 void *pStart;  sqlite3_int64 szAlloc = sz*(sqlite3_int64)cnt;  int nBig;  int nSm;  if( sqlite3LookasideUsed(db,0)>0 ){  return SQLITE_BUSY;  }  if( db->lookaside.bMalloced ){  sqlite3_free(db->lookaside.pStart);  }  sz = ROUNDDOWN8(sz);  if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;  if( cnt<0 ) cnt = 0;  if( sz==0 || cnt==0 ){  sz = 0;  pStart = 0;  }else if( pBuf==0 ){  sqlite3BeginBenignMalloc();  pStart = sqlite3Malloc( szAlloc );  sqlite3EndBenignMalloc();  if( pStart ) szAlloc = sqlite3MallocSize(pStart);  }else{  pStart = pBuf;  }
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 if( sz>=LOOKASIDE_SMALL*3 ){  nBig = szAlloc/(3*LOOKASIDE_SMALL+sz);  nSm = (szAlloc - sz*nBig)/LOOKASIDE_SMALL;  }else if( sz>=LOOKASIDE_SMALL*2 ){  nBig = szAlloc/(LOOKASIDE_SMALL+sz);  nSm = (szAlloc - sz*nBig)/LOOKASIDE_SMALL;  }else
#endif
 if( sz>0 ){  nBig = szAlloc/sz;  nSm = 0;  }else{  nBig = nSm = 0;  }  db->lookaside.pStart = pStart;  db->lookaside.pInit = 0;  db->lookaside.pFree = 0;  db->lookaside.sz = (u16)sz;  db->lookaside.szTrue = (u16)sz;  if( pStart ){  int i;  LookasideSlot *p;  assert( sz > (int)sizeof(LookasideSlot*) );  p = (LookasideSlot*)pStart;  for(i=0; i<nBig; i++){  p->pNext = db->lookaside.pInit;  db->lookaside.pInit = p;  p = (LookasideSlot*)&((u8*)p)[sz];  }
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 db->lookaside.pSmallInit = 0;  db->lookaside.pSmallFree = 0;  db->lookaside.pMiddle = p;  for(i=0; i<nSm; i++){  p->pNext = db->lookaside.pSmallInit;  db->lookaside.pSmallInit = p;  p = (LookasideSlot*)&((u8*)p)[LOOKASIDE_SMALL];  }
#endif
 assert( ((uptr)p)<=szAlloc + (uptr)pStart );  db->lookaside.pEnd = p;  db->lookaside.bDisable = 0;  db->lookaside.bMalloced = pBuf==0 ?1:0;  db->lookaside.nSlot = nBig+nSm;  }else{  db->lookaside.pStart = db;
#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE
 db->lookaside.pSmallInit = 0;  db->lookaside.pSmallFree = 0;  db->lookaside.pMiddle = db;
#endif
 db->lookaside.pEnd = db;  db->lookaside.bDisable = 1;  db->lookaside.sz = 0;  db->lookaside.bMalloced = 0;  db->lookaside.nSlot = 0;  }  assert( sqlite3LookasideUsed(db,0)==0 );
#endif
 return SQLITE_OK; } SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return db->mutex; } SQLITE_API int sqlite3_db_release_memory(sqlite3 *db){  int i;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  sqlite3BtreeEnterAll(db);  for(i=0; i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ){  Pager *pPager = sqlite3BtreePager(pBt);  sqlite3PagerShrink(pPager);  }  }  sqlite3BtreeLeaveAll(db);  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; } SQLITE_API int sqlite3_db_cacheflush(sqlite3 *db){  int i;  int rc = SQLITE_OK;  int bSeenBusy = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  sqlite3BtreeEnterAll(db);  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt && sqlite3BtreeTxnState(pBt)==SQLITE_TXN_WRITE ){  Pager *pPager = sqlite3BtreePager(pBt);  rc = sqlite3PagerFlush(pPager);  if( rc==SQLITE_BUSY ){  bSeenBusy = 1;  rc = SQLITE_OK;  }  }  }  sqlite3BtreeLeaveAll(db);  sqlite3_mutex_leave(db->mutex);  return ((rc==SQLITE_OK && bSeenBusy) ? SQLITE_BUSY : rc); } SQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){  va_list ap;  int rc;  va_start(ap, op);  switch( op ){  case SQLITE_DBCONFIG_MAINDBNAME: {  db->aDb[0].zDbSName = va_arg(ap,char*);  rc = SQLITE_OK;  break;  }  case SQLITE_DBCONFIG_LOOKASIDE: {  void *pBuf = va_arg(ap, void*);  int sz = va_arg(ap, int);  int cnt = va_arg(ap, int);  rc = setupLookaside(db, pBuf, sz, cnt);  break;  }  default: {  static const struct {  int op;  u32 mask;  } aFlagOp[] = {  { SQLITE_DBCONFIG_ENABLE_FKEY, SQLITE_ForeignKeys },  { SQLITE_DBCONFIG_ENABLE_TRIGGER, SQLITE_EnableTrigger },  { SQLITE_DBCONFIG_ENABLE_VIEW, SQLITE_EnableView  },  { SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, SQLITE_Fts3Tokenizer },  { SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, SQLITE_LoadExtension },  { SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE, SQLITE_NoCkptOnClose },  { SQLITE_DBCONFIG_ENABLE_QPSG, SQLITE_EnableQPSG  },  { SQLITE_DBCONFIG_TRIGGER_EQP, SQLITE_TriggerEQP  },  { SQLITE_DBCONFIG_RESET_DATABASE, SQLITE_ResetDatabase },  { SQLITE_DBCONFIG_DEFENSIVE, SQLITE_Defensive },  { SQLITE_DBCONFIG_WRITABLE_SCHEMA, SQLITE_WriteSchema|   SQLITE_NoSchemaError },  { SQLITE_DBCONFIG_LEGACY_ALTER_TABLE, SQLITE_LegacyAlter },  { SQLITE_DBCONFIG_DQS_DDL, SQLITE_DqsDDL  },  { SQLITE_DBCONFIG_DQS_DML, SQLITE_DqsDML  },  { SQLITE_DBCONFIG_LEGACY_FILE_FORMAT, SQLITE_LegacyFileFmt },  { SQLITE_DBCONFIG_TRUSTED_SCHEMA, SQLITE_TrustedSchema },  };  unsigned int i;  rc = SQLITE_ERROR;  for(i=0; i<ArraySize(aFlagOp); i++){  if( aFlagOp[i].op==op ){  int onoff = va_arg(ap, int);  int *pRes = va_arg(ap, int*);  u64 oldFlags = db->flags;  if( onoff>0 ){  db->flags |= aFlagOp[i].mask;  }else if( onoff==0 ){  db->flags &= ~(u64)aFlagOp[i].mask;  }  if( oldFlags!=db->flags ){  sqlite3ExpirePreparedStatements(db, 0);  }  if( pRes ){  *pRes = (db->flags & aFlagOp[i].mask)!=0;  }  rc = SQLITE_OK;  break;  }  }  break;  }  }  va_end(ap);  return rc; } static int binCollFunc(  void *NotUsed,  int nKey1, const void *pKey1,  int nKey2, const void *pKey2 ){  int rc, n;  UNUSED_PARAMETER(NotUsed);  n = nKey1<nKey2 ? nKey1 : nKey2;  assert( pKey1 && pKey2 );  rc = memcmp(pKey1, pKey2, n);  if( rc==0 ){  rc = nKey1 - nKey2;  }  return rc; } static int rtrimCollFunc(  void *pUser,  int nKey1, const void *pKey1,  int nKey2, const void *pKey2 ){  const u8 *pK1 = (const u8*)pKey1;  const u8 *pK2 = (const u8*)pKey2;  while( nKey1 && pK1[nKey1-1]==' ' ) nKey1--;  while( nKey2 && pK2[nKey2-1]==' ' ) nKey2--;  return binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2); } SQLITE_PRIVATE int sqlite3IsBinary(const CollSeq *p){  assert( p==0 || p->xCmp!=binCollFunc || strcmp(p->zName,"BINARY")==0 );  return p==0 || p->xCmp==binCollFunc; } static int nocaseCollatingFunc(  void *NotUsed,  int nKey1, const void *pKey1,  int nKey2, const void *pKey2 ){  int r = sqlite3StrNICmp(  (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);  UNUSED_PARAMETER(NotUsed);  if( 0==r ){  r = nKey1-nKey2;  }  return r; } SQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return db->lastRowid; } SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3 *db, sqlite3_int64 iRowid){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return;  }
#endif
 sqlite3_mutex_enter(db->mutex);  db->lastRowid = iRowid;  sqlite3_mutex_leave(db->mutex); } SQLITE_API sqlite3_int64 sqlite3_changes64(sqlite3 *db){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return db->nChange; } SQLITE_API int sqlite3_changes(sqlite3 *db){  return (int)sqlite3_changes64(db); } SQLITE_API sqlite3_int64 sqlite3_total_changes64(sqlite3 *db){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return db->nTotalChange; } SQLITE_API int sqlite3_total_changes(sqlite3 *db){  return (int)sqlite3_total_changes64(db); } SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *db){  while( db->pSavepoint ){  Savepoint *pTmp = db->pSavepoint;  db->pSavepoint = pTmp->pNext;  sqlite3DbFree(db, pTmp);  }  db->nSavepoint = 0;  db->nStatement = 0;  db->isTransactionSavepoint = 0; } static void functionDestroy(sqlite3 *db, FuncDef *p){  FuncDestructor *pDestructor;  assert( (p->funcFlags & SQLITE_FUNC_BUILTIN)==0 );  pDestructor = p->u.pDestructor;  if( pDestructor ){  pDestructor->nRef--;  if( pDestructor->nRef==0 ){  pDestructor->xDestroy(pDestructor->pUserData);  sqlite3DbFree(db, pDestructor);  }  } } static void disconnectAllVtab(sqlite3 *db){
#ifndef SQLITE_OMIT_VIRTUALTABLE
 int i;  HashElem *p;  sqlite3BtreeEnterAll(db);  for(i=0; i<db->nDb; i++){  Schema *pSchema = db->aDb[i].pSchema;  if( pSchema ){  for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){  Table *pTab = (Table *)sqliteHashData(p);  if( IsVirtual(pTab) ) sqlite3VtabDisconnect(db, pTab);  }  }  }  for(p=sqliteHashFirst(&db->aModule); p; p=sqliteHashNext(p)){  Module *pMod = (Module *)sqliteHashData(p);  if( pMod->pEpoTab ){  sqlite3VtabDisconnect(db, pMod->pEpoTab);  }  }  sqlite3VtabUnlockList(db);  sqlite3BtreeLeaveAll(db);
#else
 UNUSED_PARAMETER(db);
#endif
} static int connectionIsBusy(sqlite3 *db){  int j;  assert( sqlite3_mutex_held(db->mutex) );  if( db->pVdbe ) return 1;  for(j=0; j<db->nDb; j++){  Btree *pBt = db->aDb[j].pBt;  if( pBt && sqlite3BtreeIsInBackup(pBt) ) return 1;  }  return 0; } static int sqlite3Close(sqlite3 *db, int forceZombie){  if( !db ){  return SQLITE_OK;  }  if( !sqlite3SafetyCheckSickOrOk(db) ){  return SQLITE_MISUSE_BKPT;  }  sqlite3_mutex_enter(db->mutex);  if( db->mTrace & SQLITE_TRACE_CLOSE ){  db->trace.xV2(SQLITE_TRACE_CLOSE, db->pTraceArg, db, 0);  }  disconnectAllVtab(db);  sqlite3VtabRollback(db);  if( !forceZombie && connectionIsBusy(db) ){  sqlite3ErrorWithMsg(db, SQLITE_BUSY, "unable to close due to unfinalized "   "statements or unfinished backups");  sqlite3_mutex_leave(db->mutex);  return SQLITE_BUSY;  }
#ifdef SQLITE_ENABLE_SQLLOG
 if( sqlite3GlobalConfig.xSqllog ){  sqlite3GlobalConfig.xSqllog(sqlite3GlobalConfig.pSqllogArg, db, 0, 2);  }
#endif
 db->eOpenState = SQLITE_STATE_ZOMBIE;  sqlite3LeaveMutexAndCloseZombie(db);  return SQLITE_OK; } SQLITE_API int sqlite3_txn_state(sqlite3 *db, const char *zSchema){  int iDb, nDb;  int iTxn = -1;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return -1;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( zSchema ){  nDb = iDb = sqlite3FindDbName(db, zSchema);  if( iDb<0 ) nDb--;  }else{  iDb = 0;  nDb = db->nDb-1;  }  for(; iDb<=nDb; iDb++){  Btree *pBt = db->aDb[iDb].pBt;  int x = pBt!=0 ? sqlite3BtreeTxnState(pBt) : SQLITE_TXN_NONE;  if( x>iTxn ) iTxn = x;  }  sqlite3_mutex_leave(db->mutex);  return iTxn; } SQLITE_API int sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); } SQLITE_API int sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); } SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db){  HashElem *i;  int j;  if( db->eOpenState!=SQLITE_STATE_ZOMBIE || connectionIsBusy(db) ){  sqlite3_mutex_leave(db->mutex);  return;  }  sqlite3RollbackAll(db, SQLITE_OK);  sqlite3CloseSavepoints(db);  for(j=0; j<db->nDb; j++){  struct Db *pDb = &db->aDb[j];  if( pDb->pBt ){  sqlite3BtreeClose(pDb->pBt);  pDb->pBt = 0;  if( j!=1 ){  pDb->pSchema = 0;  }  }  }  if( db->aDb[1].pSchema ){  sqlite3SchemaClear(db->aDb[1].pSchema);  }  sqlite3VtabUnlockList(db);  sqlite3CollapseDatabaseArray(db);  assert( db->nDb<=2 );  assert( db->aDb==db->aDbStatic );  sqlite3ConnectionClosed(db);  for(i=sqliteHashFirst(&db->aFunc); i; i=sqliteHashNext(i)){  FuncDef *pNext, *p;  p = sqliteHashData(i);  do{  functionDestroy(db, p);  pNext = p->pNext;  sqlite3DbFree(db, p);  p = pNext;  }while( p );  }  sqlite3HashClear(&db->aFunc);  for(i=sqliteHashFirst(&db->aCollSeq); i; i=sqliteHashNext(i)){  CollSeq *pColl = (CollSeq *)sqliteHashData(i);  for(j=0; j<3; j++){  if( pColl[j].xDel ){  pColl[j].xDel(pColl[j].pUser);  }  }  sqlite3DbFree(db, pColl);  }  sqlite3HashClear(&db->aCollSeq);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 for(i=sqliteHashFirst(&db->aModule); i; i=sqliteHashNext(i)){  Module *pMod = (Module *)sqliteHashData(i);  sqlite3VtabEponymousTableClear(db, pMod);  sqlite3VtabModuleUnref(db, pMod);  }  sqlite3HashClear(&db->aModule);
#endif
 sqlite3Error(db, SQLITE_OK);  sqlite3ValueFree(db->pErr);  sqlite3CloseExtensions(db);
#if SQLITE_USER_AUTHENTICATION
 sqlite3_free(db->auth.zAuthUser);  sqlite3_free(db->auth.zAuthPW);
#endif
 db->eOpenState = SQLITE_STATE_ERROR;  sqlite3DbFree(db, db->aDb[1].pSchema);  if( db->xAutovacDestr ){  db->xAutovacDestr(db->pAutovacPagesArg);  }  sqlite3_mutex_leave(db->mutex);  db->eOpenState = SQLITE_STATE_CLOSED;  sqlite3_mutex_free(db->mutex);  assert( sqlite3LookasideUsed(db,0)==0 );  if( db->lookaside.bMalloced ){  sqlite3_free(db->lookaside.pStart);  }  sqlite3_free(db); } SQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db, int tripCode){  int i;  int inTrans = 0;  int schemaChange;  assert( sqlite3_mutex_held(db->mutex) );  sqlite3BeginBenignMalloc();  sqlite3BtreeEnterAll(db);  schemaChange = (db->mDbFlags & DBFLAG_SchemaChange)!=0 && db->init.busy==0;  for(i=0; i<db->nDb; i++){  Btree *p = db->aDb[i].pBt;  if( p ){  if( sqlite3BtreeTxnState(p)==SQLITE_TXN_WRITE ){  inTrans = 1;  }  sqlite3BtreeRollback(p, tripCode, !schemaChange);  }  }  sqlite3VtabRollback(db);  sqlite3EndBenignMalloc();  if( schemaChange ){  sqlite3ExpirePreparedStatements(db, 0);  sqlite3ResetAllSchemasOfConnection(db);  }  sqlite3BtreeLeaveAll(db);  db->nDeferredCons = 0;  db->nDeferredImmCons = 0;  db->flags &= ~(u64)(SQLITE_DeferFKs|SQLITE_CorruptRdOnly);  if( db->xRollbackCallback && (inTrans || !db->autoCommit) ){  db->xRollbackCallback(db->pRollbackArg);  } }
#if defined(SQLITE_NEED_ERR_NAME)
SQLITE_PRIVATE const char *sqlite3ErrName(int rc){  const char *zName = 0;  int i, origRc = rc;  for(i=0; i<2 && zName==0; i++, rc &= 0xff){  switch( rc ){  case SQLITE_OK:  zName = "SQLITE_OK"; break;  case SQLITE_ERROR: zName = "SQLITE_ERROR";  break;  case SQLITE_ERROR_SNAPSHOT:  zName = "SQLITE_ERROR_SNAPSHOT"; break;  case SQLITE_INTERNAL:  zName = "SQLITE_INTERNAL"; break;  case SQLITE_PERM:  zName = "SQLITE_PERM"; break;  case SQLITE_ABORT: zName = "SQLITE_ABORT";  break;  case SQLITE_ABORT_ROLLBACK:  zName = "SQLITE_ABORT_ROLLBACK"; break;  case SQLITE_BUSY:  zName = "SQLITE_BUSY"; break;  case SQLITE_BUSY_RECOVERY: zName = "SQLITE_BUSY_RECOVERY";  break;  case SQLITE_BUSY_SNAPSHOT: zName = "SQLITE_BUSY_SNAPSHOT";  break;  case SQLITE_LOCKED:  zName = "SQLITE_LOCKED"; break;  case SQLITE_LOCKED_SHAREDCACHE: zName = "SQLITE_LOCKED_SHAREDCACHE";break;  case SQLITE_NOMEM: zName = "SQLITE_NOMEM";  break;  case SQLITE_READONLY:  zName = "SQLITE_READONLY"; break;  case SQLITE_READONLY_RECOVERY: zName = "SQLITE_READONLY_RECOVERY"; break;  case SQLITE_READONLY_CANTINIT: zName = "SQLITE_READONLY_CANTINIT"; break;  case SQLITE_READONLY_ROLLBACK: zName = "SQLITE_READONLY_ROLLBACK"; break;  case SQLITE_READONLY_DBMOVED:  zName = "SQLITE_READONLY_DBMOVED"; break;  case SQLITE_READONLY_DIRECTORY: zName = "SQLITE_READONLY_DIRECTORY";break;  case SQLITE_INTERRUPT: zName = "SQLITE_INTERRUPT";  break;  case SQLITE_IOERR: zName = "SQLITE_IOERR";  break;  case SQLITE_IOERR_READ:  zName = "SQLITE_IOERR_READ"; break;  case SQLITE_IOERR_SHORT_READ:  zName = "SQLITE_IOERR_SHORT_READ"; break;  case SQLITE_IOERR_WRITE: zName = "SQLITE_IOERR_WRITE";  break;  case SQLITE_IOERR_FSYNC: zName = "SQLITE_IOERR_FSYNC";  break;  case SQLITE_IOERR_DIR_FSYNC: zName = "SQLITE_IOERR_DIR_FSYNC";  break;  case SQLITE_IOERR_TRUNCATE:  zName = "SQLITE_IOERR_TRUNCATE"; break;  case SQLITE_IOERR_FSTAT: zName = "SQLITE_IOERR_FSTAT";  break;  case SQLITE_IOERR_UNLOCK:  zName = "SQLITE_IOERR_UNLOCK"; break;  case SQLITE_IOERR_RDLOCK:  zName = "SQLITE_IOERR_RDLOCK"; break;  case SQLITE_IOERR_DELETE:  zName = "SQLITE_IOERR_DELETE"; break;  case SQLITE_IOERR_NOMEM: zName = "SQLITE_IOERR_NOMEM";  break;  case SQLITE_IOERR_ACCESS:  zName = "SQLITE_IOERR_ACCESS"; break;  case SQLITE_IOERR_CHECKRESERVEDLOCK:  zName = "SQLITE_IOERR_CHECKRESERVEDLOCK"; break;  case SQLITE_IOERR_LOCK:  zName = "SQLITE_IOERR_LOCK"; break;  case SQLITE_IOERR_CLOSE: zName = "SQLITE_IOERR_CLOSE";  break;  case SQLITE_IOERR_DIR_CLOSE: zName = "SQLITE_IOERR_DIR_CLOSE";  break;  case SQLITE_IOERR_SHMOPEN: zName = "SQLITE_IOERR_SHMOPEN";  break;  case SQLITE_IOERR_SHMSIZE: zName = "SQLITE_IOERR_SHMSIZE";  break;  case SQLITE_IOERR_SHMLOCK: zName = "SQLITE_IOERR_SHMLOCK";  break;  case SQLITE_IOERR_SHMMAP:  zName = "SQLITE_IOERR_SHMMAP"; break;  case SQLITE_IOERR_SEEK:  zName = "SQLITE_IOERR_SEEK"; break;  case SQLITE_IOERR_DELETE_NOENT: zName = "SQLITE_IOERR_DELETE_NOENT";break;  case SQLITE_IOERR_MMAP:  zName = "SQLITE_IOERR_MMAP"; break;  case SQLITE_IOERR_GETTEMPPATH: zName = "SQLITE_IOERR_GETTEMPPATH"; break;  case SQLITE_IOERR_CONVPATH:  zName = "SQLITE_IOERR_CONVPATH"; break;  case SQLITE_CORRUPT: zName = "SQLITE_CORRUPT";  break;  case SQLITE_CORRUPT_VTAB:  zName = "SQLITE_CORRUPT_VTAB"; break;  case SQLITE_NOTFOUND:  zName = "SQLITE_NOTFOUND"; break;  case SQLITE_FULL:  zName = "SQLITE_FULL"; break;  case SQLITE_CANTOPEN:  zName = "SQLITE_CANTOPEN"; break;  case SQLITE_CANTOPEN_NOTEMPDIR: zName = "SQLITE_CANTOPEN_NOTEMPDIR";break;  case SQLITE_CANTOPEN_ISDIR:  zName = "SQLITE_CANTOPEN_ISDIR"; break;  case SQLITE_CANTOPEN_FULLPATH: zName = "SQLITE_CANTOPEN_FULLPATH"; break;  case SQLITE_CANTOPEN_CONVPATH: zName = "SQLITE_CANTOPEN_CONVPATH"; break;  case SQLITE_CANTOPEN_SYMLINK:  zName = "SQLITE_CANTOPEN_SYMLINK"; break;  case SQLITE_PROTOCOL:  zName = "SQLITE_PROTOCOL"; break;  case SQLITE_EMPTY: zName = "SQLITE_EMPTY";  break;  case SQLITE_SCHEMA:  zName = "SQLITE_SCHEMA"; break;  case SQLITE_TOOBIG:  zName = "SQLITE_TOOBIG"; break;  case SQLITE_CONSTRAINT:  zName = "SQLITE_CONSTRAINT"; break;  case SQLITE_CONSTRAINT_UNIQUE: zName = "SQLITE_CONSTRAINT_UNIQUE"; break;  case SQLITE_CONSTRAINT_TRIGGER: zName = "SQLITE_CONSTRAINT_TRIGGER";break;  case SQLITE_CONSTRAINT_FOREIGNKEY:  zName = "SQLITE_CONSTRAINT_FOREIGNKEY";  break;  case SQLITE_CONSTRAINT_CHECK:  zName = "SQLITE_CONSTRAINT_CHECK"; break;  case SQLITE_CONSTRAINT_PRIMARYKEY:  zName = "SQLITE_CONSTRAINT_PRIMARYKEY";  break;  case SQLITE_CONSTRAINT_NOTNULL: zName = "SQLITE_CONSTRAINT_NOTNULL";break;  case SQLITE_CONSTRAINT_COMMITHOOK:  zName = "SQLITE_CONSTRAINT_COMMITHOOK";  break;  case SQLITE_CONSTRAINT_VTAB: zName = "SQLITE_CONSTRAINT_VTAB";  break;  case SQLITE_CONSTRAINT_FUNCTION:  zName = "SQLITE_CONSTRAINT_FUNCTION";  break;  case SQLITE_CONSTRAINT_ROWID:  zName = "SQLITE_CONSTRAINT_ROWID"; break;  case SQLITE_MISMATCH:  zName = "SQLITE_MISMATCH"; break;  case SQLITE_MISUSE:  zName = "SQLITE_MISUSE"; break;  case SQLITE_NOLFS: zName = "SQLITE_NOLFS";  break;  case SQLITE_AUTH:  zName = "SQLITE_AUTH"; break;  case SQLITE_FORMAT:  zName = "SQLITE_FORMAT"; break;  case SQLITE_RANGE: zName = "SQLITE_RANGE";  break;  case SQLITE_NOTADB:  zName = "SQLITE_NOTADB"; break;  case SQLITE_ROW: zName = "SQLITE_ROW";  break;  case SQLITE_NOTICE:  zName = "SQLITE_NOTICE"; break;  case SQLITE_NOTICE_RECOVER_WAL: zName = "SQLITE_NOTICE_RECOVER_WAL";break;  case SQLITE_NOTICE_RECOVER_ROLLBACK:  zName = "SQLITE_NOTICE_RECOVER_ROLLBACK"; break;  case SQLITE_WARNING: zName = "SQLITE_WARNING";  break;  case SQLITE_WARNING_AUTOINDEX: zName = "SQLITE_WARNING_AUTOINDEX"; break;  case SQLITE_DONE:  zName = "SQLITE_DONE"; break;  }  }  if( zName==0 ){  static char zBuf[50];  sqlite3_snprintf(sizeof(zBuf), zBuf, "SQLITE_UNKNOWN(%d)", origRc);  zName = zBuf;  }  return zName; }
#endif
SQLITE_PRIVATE const char *sqlite3ErrStr(int rc){  static const char* const aMsg[] = {  "not an error",  "SQL logic error",  0,  "access permission denied",  "query aborted",  "database is locked",  "database table is locked",  "out of memory",  "attempt to write a readonly database",  "interrupted",  "disk I/O error",  "database disk image is malformed",  "unknown operation",  "database or disk is full",  "unable to open database file",  "locking protocol",  0,  "database schema has changed",  "string or blob too big",  "constraint failed",  "datatype mismatch",  "bad parameter or other API misuse",
#ifdef SQLITE_DISABLE_LFS
 "large file support is disabled",
#else
 0,
#endif
 "authorization denied",  0,  "column index out of range",  "file is not a database",  "notification message",  "warning message",  };  const char *zErr = "unknown error";  switch( rc ){  case SQLITE_ABORT_ROLLBACK: {  zErr = "abort due to ROLLBACK";  break;  }  case SQLITE_ROW: {  zErr = "another row available";  break;  }  case SQLITE_DONE: {  zErr = "no more rows available";  break;  }  default: {  rc &= 0xff;  if( ALWAYS(rc>=0) && rc<ArraySize(aMsg) && aMsg[rc]!=0 ){  zErr = aMsg[rc];  }  break;  }  }  return zErr; } static int sqliteDefaultBusyCallback(  void *ptr,  int count ){
#if SQLITE_OS_WIN || HAVE_USLEEP
 static const u8 delays[] =   { 1, 2, 5, 10, 15, 20, 25, 25, 25, 50, 50, 100 };  static const u8 totals[] =   { 0, 1, 3, 8, 18, 33, 53, 78, 103, 128, 178, 228 };
# define NDELAY ArraySize(delays)
 sqlite3 *db = (sqlite3 *)ptr;  int tmout = db->busyTimeout;  int delay, prior;  assert( count>=0 );  if( count < NDELAY ){  delay = delays[count];  prior = totals[count];  }else{  delay = delays[NDELAY-1];  prior = totals[NDELAY-1] + delay*(count-(NDELAY-1));  }  if( prior + delay > tmout ){  delay = tmout - prior;  if( delay<=0 ) return 0;  }  sqlite3OsSleep(db->pVfs, delay*1000);  return 1;
#else
 sqlite3 *db = (sqlite3 *)ptr;  int tmout = ((sqlite3 *)ptr)->busyTimeout;  if( (count+1)*1000 > tmout ){  return 0;  }  sqlite3OsSleep(db->pVfs, 1000000);  return 1;
#endif
} SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){  int rc;  if( p->xBusyHandler==0 || p->nBusy<0 ) return 0;  rc = p->xBusyHandler(p->pBusyArg, p->nBusy);  if( rc==0 ){  p->nBusy = -1;  }else{  p->nBusy++;  }  return rc; } SQLITE_API int sqlite3_busy_handler(  sqlite3 *db,  int (*xBusy)(void*,int),  void *pArg ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  db->busyHandler.xBusyHandler = xBusy;  db->busyHandler.pBusyArg = pArg;  db->busyHandler.nBusy = 0;  db->busyTimeout = 0;  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; }
#ifndef SQLITE_OMIT_PROGRESS_CALLBACK
SQLITE_API void sqlite3_progress_handler(  sqlite3 *db,  int nOps,  int (*xProgress)(void*),  void *pArg ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( nOps>0 ){  db->xProgress = xProgress;  db->nProgressOps = (unsigned)nOps;  db->pProgressArg = pArg;  }else{  db->xProgress = 0;  db->nProgressOps = 0;  db->pProgressArg = 0;  }  sqlite3_mutex_leave(db->mutex); }
#endif
SQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 if( ms>0 ){  sqlite3_busy_handler(db, (int(*)(void*,int))sqliteDefaultBusyCallback,   (void*)db);  db->busyTimeout = ms;  }else{  sqlite3_busy_handler(db, 0, 0);  }  return SQLITE_OK; } SQLITE_API void sqlite3_interrupt(sqlite3 *db){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) && (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE) ){  (void)SQLITE_MISUSE_BKPT;  return;  }
#endif
 AtomicStore(&db->u1.isInterrupted, 1); } SQLITE_PRIVATE int sqlite3CreateFunc(  sqlite3 *db,  const char *zFunctionName,  int nArg,  int enc,  void *pUserData,  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),  void (*xStep)(sqlite3_context*,int,sqlite3_value **),  void (*xFinal)(sqlite3_context*),  void (*xValue)(sqlite3_context*),  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),  FuncDestructor *pDestructor ){  FuncDef *p;  int extraFlags;  assert( sqlite3_mutex_held(db->mutex) );  assert( xValue==0 || xSFunc==0 );  if( zFunctionName==0   || (xSFunc!=0 && xFinal!=0)   || ((xFinal==0)!=(xStep==0))   || ((xValue==0)!=(xInverse==0))   || (nArg<-1 || nArg>SQLITE_MAX_FUNCTION_ARG)   || (255<sqlite3Strlen30(zFunctionName))  ){  return SQLITE_MISUSE_BKPT;  }  assert( SQLITE_FUNC_CONSTANT==SQLITE_DETERMINISTIC );  assert( SQLITE_FUNC_DIRECT==SQLITE_DIRECTONLY );  extraFlags = enc & (SQLITE_DETERMINISTIC|SQLITE_DIRECTONLY|   SQLITE_SUBTYPE|SQLITE_INNOCUOUS);  enc &= (SQLITE_FUNC_ENCMASK|SQLITE_ANY);  assert( SQLITE_FUNC_UNSAFE==SQLITE_INNOCUOUS );  extraFlags ^= SQLITE_FUNC_UNSAFE;
#ifndef SQLITE_OMIT_UTF16
 switch( enc ){  case SQLITE_UTF16:  enc = SQLITE_UTF16NATIVE;  break;  case SQLITE_ANY: {  int rc;  rc = sqlite3CreateFunc(db, zFunctionName, nArg,   (SQLITE_UTF8|extraFlags)^SQLITE_FUNC_UNSAFE,   pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);  if( rc==SQLITE_OK ){  rc = sqlite3CreateFunc(db, zFunctionName, nArg,   (SQLITE_UTF16LE|extraFlags)^SQLITE_FUNC_UNSAFE,   pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);  }  if( rc!=SQLITE_OK ){  return rc;  }  enc = SQLITE_UTF16BE;  break;  }  case SQLITE_UTF8:  case SQLITE_UTF16LE:  case SQLITE_UTF16BE:  break;  default:  enc = SQLITE_UTF8;  break;  }
#else
 enc = SQLITE_UTF8;
#endif
 p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 0);  if( p && (p->funcFlags & SQLITE_FUNC_ENCMASK)==(u32)enc && p->nArg==nArg ){  if( db->nVdbeActive ){  sqlite3ErrorWithMsg(db, SQLITE_BUSY,  "unable to delete/modify user-function due to active statements");  assert( !db->mallocFailed );  return SQLITE_BUSY;  }else{  sqlite3ExpirePreparedStatements(db, 0);  }  }else if( xSFunc==0 && xFinal==0 ){  return SQLITE_OK;  }  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 1);  assert(p || db->mallocFailed);  if( !p ){  return SQLITE_NOMEM_BKPT;  }  functionDestroy(db, p);  if( pDestructor ){  pDestructor->nRef++;  }  p->u.pDestructor = pDestructor;  p->funcFlags = (p->funcFlags & SQLITE_FUNC_ENCMASK) | extraFlags;  testcase( p->funcFlags & SQLITE_DETERMINISTIC );  testcase( p->funcFlags & SQLITE_DIRECTONLY );  p->xSFunc = xSFunc ? xSFunc : xStep;  p->xFinalize = xFinal;  p->xValue = xValue;  p->xInverse = xInverse;  p->pUserData = pUserData;  p->nArg = (u16)nArg;  return SQLITE_OK; } static int createFunctionApi(  sqlite3 *db,  const char *zFunc,  int nArg,  int enc,  void *p,  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*),  void (*xValue)(sqlite3_context*),  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),  void(*xDestroy)(void*) ){  int rc = SQLITE_ERROR;  FuncDestructor *pArg = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( xDestroy ){  pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));  if( !pArg ){  sqlite3OomFault(db);  xDestroy(p);  goto out;  }  pArg->nRef = 0;  pArg->xDestroy = xDestroy;  pArg->pUserData = p;  }  rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p,  xSFunc, xStep, xFinal, xValue, xInverse, pArg  );  if( pArg && pArg->nRef==0 ){  assert( rc!=SQLITE_OK || (xStep==0 && xFinal==0) );  xDestroy(p);  sqlite3_free(pArg);  }  out:  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_create_function(  sqlite3 *db,  const char *zFunc,  int nArg,  int enc,  void *p,  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),  void (*xStep)(sqlite3_context*,int,sqlite3_value **),  void (*xFinal)(sqlite3_context*) ){  return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,  xFinal, 0, 0, 0); } SQLITE_API int sqlite3_create_function_v2(  sqlite3 *db,  const char *zFunc,  int nArg,  int enc,  void *p,  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),  void (*xStep)(sqlite3_context*,int,sqlite3_value **),  void (*xFinal)(sqlite3_context*),  void (*xDestroy)(void *) ){  return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,  xFinal, 0, 0, xDestroy); } SQLITE_API int sqlite3_create_window_function(  sqlite3 *db,  const char *zFunc,  int nArg,  int enc,  void *p,  void (*xStep)(sqlite3_context*,int,sqlite3_value **),  void (*xFinal)(sqlite3_context*),  void (*xValue)(sqlite3_context*),  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),  void (*xDestroy)(void *) ){  return createFunctionApi(db, zFunc, nArg, enc, p, 0, xStep,  xFinal, xValue, xInverse, xDestroy); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_create_function16(  sqlite3 *db,  const void *zFunctionName,  int nArg,  int eTextRep,  void *p,  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),  void (*xStep)(sqlite3_context*,int,sqlite3_value**),  void (*xFinal)(sqlite3_context*) ){  int rc;  char *zFunc8;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zFunctionName==0 ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  assert( !db->mallocFailed );  zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, SQLITE_UTF16NATIVE);  rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xSFunc,xStep,xFinal,0,0,0);  sqlite3DbFree(db, zFunc8);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; }
#endif
static void sqlite3InvalidFunction(  sqlite3_context *context,  int NotUsed,  sqlite3_value **NotUsed2 ){  const char *zName = (const char*)sqlite3_user_data(context);  char *zErr;  UNUSED_PARAMETER2(NotUsed, NotUsed2);  zErr = sqlite3_mprintf(  "unable to use function %s in the requested context", zName);  sqlite3_result_error(context, zErr, -1);  sqlite3_free(zErr); } SQLITE_API int sqlite3_overload_function(  sqlite3 *db,  const char *zName,  int nArg ){  int rc;  char *zCopy;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zName==0 || nArg<-2 ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  rc = sqlite3FindFunction(db, zName, nArg, SQLITE_UTF8, 0)!=0;  sqlite3_mutex_leave(db->mutex);  if( rc ) return SQLITE_OK;  zCopy = sqlite3_mprintf(zName);  if( zCopy==0 ) return SQLITE_NOMEM;  return sqlite3_create_function_v2(db, zName, nArg, SQLITE_UTF8,   zCopy, sqlite3InvalidFunction, 0, 0, sqlite3_free); }
#ifndef SQLITE_OMIT_TRACE
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*,const char*), void *pArg){  void *pOld;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pOld = db->pTraceArg;  db->mTrace = xTrace ? SQLITE_TRACE_LEGACY : 0;  db->trace.xLegacy = xTrace;  db->pTraceArg = pArg;  sqlite3_mutex_leave(db->mutex);  return pOld; }
#endif
SQLITE_API int sqlite3_trace_v2(  sqlite3 *db,  unsigned mTrace,  int(*xTrace)(unsigned,void*,void*,void*),  void *pArg ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( mTrace==0 ) xTrace = 0;  if( xTrace==0 ) mTrace = 0;  db->mTrace = mTrace;  db->trace.xV2 = xTrace;  db->pTraceArg = pArg;  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; }
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API void *sqlite3_profile(  sqlite3 *db,  void (*xProfile)(void*,const char*,sqlite_uint64),  void *pArg ){  void *pOld;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pOld = db->pProfileArg;  db->xProfile = xProfile;  db->pProfileArg = pArg;  db->mTrace &= SQLITE_TRACE_NONLEGACY_MASK;  if( db->xProfile ) db->mTrace |= SQLITE_TRACE_XPROFILE;  sqlite3_mutex_leave(db->mutex);  return pOld; }
#endif
#endif
SQLITE_API void *sqlite3_commit_hook(  sqlite3 *db,  int (*xCallback)(void*),  void *pArg ){  void *pOld;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pOld = db->pCommitArg;  db->xCommitCallback = xCallback;  db->pCommitArg = pArg;  sqlite3_mutex_leave(db->mutex);  return pOld; } SQLITE_API void *sqlite3_update_hook(  sqlite3 *db,  void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),  void *pArg ){  void *pRet;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pRet = db->pUpdateArg;  db->xUpdateCallback = xCallback;  db->pUpdateArg = pArg;  sqlite3_mutex_leave(db->mutex);  return pRet; } SQLITE_API void *sqlite3_rollback_hook(  sqlite3 *db,  void (*xCallback)(void*),  void *pArg ){  void *pRet;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pRet = db->pRollbackArg;  db->xRollbackCallback = xCallback;  db->pRollbackArg = pArg;  sqlite3_mutex_leave(db->mutex);  return pRet; }
#ifdef SQLITE_ENABLE_PREUPDATE_HOOK
SQLITE_API void *sqlite3_preupdate_hook(  sqlite3 *db,  void(*xCallback)(  void*,sqlite3*,int,char const*,char const*,sqlite3_int64,sqlite3_int64),  void *pArg ){  void *pRet;  sqlite3_mutex_enter(db->mutex);  pRet = db->pPreUpdateArg;  db->xPreUpdateCallback = xCallback;  db->pPreUpdateArg = pArg;  sqlite3_mutex_leave(db->mutex);  return pRet; }
#endif
SQLITE_API int sqlite3_autovacuum_pages(  sqlite3 *db,  unsigned int (*xCallback)(void*,const char*,u32,u32,u32),  void *pArg,  void (*xDestructor)(void*) ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  if( xDestructor ) xDestructor(pArg);  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( db->xAutovacDestr ){  db->xAutovacDestr(db->pAutovacPagesArg);  }  db->xAutovacPages = xCallback;  db->pAutovacPagesArg = pArg;  db->xAutovacDestr = xDestructor;  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; }
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3WalDefaultHook(  void *pClientData,  sqlite3 *db,  const char *zDb,  int nFrame ){  if( nFrame>=SQLITE_PTR_TO_INT(pClientData) ){  sqlite3BeginBenignMalloc();  sqlite3_wal_checkpoint(db, zDb);  sqlite3EndBenignMalloc();  }  return SQLITE_OK; }
#endif
SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){
#ifdef SQLITE_OMIT_WAL
 UNUSED_PARAMETER(db);  UNUSED_PARAMETER(nFrame);
#else
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 if( nFrame>0 ){  sqlite3_wal_hook(db, sqlite3WalDefaultHook, SQLITE_INT_TO_PTR(nFrame));  }else{  sqlite3_wal_hook(db, 0, 0);  }
#endif
 return SQLITE_OK; } SQLITE_API void *sqlite3_wal_hook(  sqlite3 *db,  int(*xCallback)(void *, sqlite3*, const char*, int),  void *pArg ){
#ifndef SQLITE_OMIT_WAL
 void *pRet;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 sqlite3_mutex_enter(db->mutex);  pRet = db->pWalArg;  db->xWalCallback = xCallback;  db->pWalArg = pArg;  sqlite3_mutex_leave(db->mutex);  return pRet;
#else
 return 0;
#endif
} SQLITE_API int sqlite3_wal_checkpoint_v2(  sqlite3 *db,  const char *zDb,  int eMode,  int *pnLog,  int *pnCkpt ){
#ifdef SQLITE_OMIT_WAL
 return SQLITE_OK;
#else
 int rc;  int iDb;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 if( pnLog ) *pnLog = -1;  if( pnCkpt ) *pnCkpt = -1;  assert( SQLITE_CHECKPOINT_PASSIVE==0 );  assert( SQLITE_CHECKPOINT_FULL==1 );  assert( SQLITE_CHECKPOINT_RESTART==2 );  assert( SQLITE_CHECKPOINT_TRUNCATE==3 );  if( eMode<SQLITE_CHECKPOINT_PASSIVE || eMode>SQLITE_CHECKPOINT_TRUNCATE ){  return SQLITE_MISUSE;  }  sqlite3_mutex_enter(db->mutex);  if( zDb && zDb[0] ){  iDb = sqlite3FindDbName(db, zDb);  }else{  iDb = SQLITE_MAX_DB;  }  if( iDb<0 ){  rc = SQLITE_ERROR;  sqlite3ErrorWithMsg(db, SQLITE_ERROR, "unknown database: %s", zDb);  }else{  db->busyHandler.nBusy = 0;  rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);  sqlite3Error(db, rc);  }  rc = sqlite3ApiExit(db, rc);  if( db->nVdbeActive==0 ){  AtomicStore(&db->u1.isInterrupted, 0);  }  sqlite3_mutex_leave(db->mutex);  return rc;
#endif
} SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){  return sqlite3_wal_checkpoint_v2(db,zDb,SQLITE_CHECKPOINT_PASSIVE,0,0); }
#ifndef SQLITE_OMIT_WAL
SQLITE_PRIVATE int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){  int rc = SQLITE_OK;  int i;  int bBusy = 0;  assert( sqlite3_mutex_held(db->mutex) );  assert( !pnLog || *pnLog==-1 );  assert( !pnCkpt || *pnCkpt==-1 );  testcase( iDb==SQLITE_MAX_ATTACHED );  testcase( iDb==SQLITE_MAX_DB );  for(i=0; i<db->nDb && rc==SQLITE_OK; i++){  if( i==iDb || iDb==SQLITE_MAX_DB ){  rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt);  pnLog = 0;  pnCkpt = 0;  if( rc==SQLITE_BUSY ){  bBusy = 1;  rc = SQLITE_OK;  }  }  }  return (rc==SQLITE_OK && bBusy) ? SQLITE_BUSY : rc; }
#endif
SQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3 *db){
#if SQLITE_TEMP_STORE==1
 return ( db->temp_store==2 );
#endif
#if SQLITE_TEMP_STORE==2
 return ( db->temp_store!=1 );
#endif
#if SQLITE_TEMP_STORE==3
 UNUSED_PARAMETER(db);  return 1;
#endif
#if SQLITE_TEMP_STORE<1 || SQLITE_TEMP_STORE>3
 UNUSED_PARAMETER(db);  return 0;
#endif
} SQLITE_API const char *sqlite3_errmsg(sqlite3 *db){  const char *z;  if( !db ){  return sqlite3ErrStr(SQLITE_NOMEM_BKPT);  }  if( !sqlite3SafetyCheckSickOrOk(db) ){  return sqlite3ErrStr(SQLITE_MISUSE_BKPT);  }  sqlite3_mutex_enter(db->mutex);  if( db->mallocFailed ){  z = sqlite3ErrStr(SQLITE_NOMEM_BKPT);  }else{  testcase( db->pErr==0 );  z = db->errCode ? (char*)sqlite3_value_text(db->pErr) : 0;  assert( !db->mallocFailed );  if( z==0 ){  z = sqlite3ErrStr(db->errCode);  }  }  sqlite3_mutex_leave(db->mutex);  return z; }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){  static const u16 outOfMem[] = {  'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0  };  static const u16 misuse[] = {  'b', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ',  'o', 'r', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'A', 'P', 'I', ' ',  'm', 'i', 's', 'u', 's', 'e', 0  };  const void *z;  if( !db ){  return (void *)outOfMem;  }  if( !sqlite3SafetyCheckSickOrOk(db) ){  return (void *)misuse;  }  sqlite3_mutex_enter(db->mutex);  if( db->mallocFailed ){  z = (void *)outOfMem;  }else{  z = sqlite3_value_text16(db->pErr);  if( z==0 ){  sqlite3ErrorWithMsg(db, db->errCode, sqlite3ErrStr(db->errCode));  z = sqlite3_value_text16(db->pErr);  }  sqlite3OomClear(db);  }  sqlite3_mutex_leave(db->mutex);  return z; }
#endif
SQLITE_API int sqlite3_errcode(sqlite3 *db){  if( db && !sqlite3SafetyCheckSickOrOk(db) ){  return SQLITE_MISUSE_BKPT;  }  if( !db || db->mallocFailed ){  return SQLITE_NOMEM_BKPT;  }  return db->errCode & db->errMask; } SQLITE_API int sqlite3_extended_errcode(sqlite3 *db){  if( db && !sqlite3SafetyCheckSickOrOk(db) ){  return SQLITE_MISUSE_BKPT;  }  if( !db || db->mallocFailed ){  return SQLITE_NOMEM_BKPT;  }  return db->errCode; } SQLITE_API int sqlite3_system_errno(sqlite3 *db){  return db ? db->iSysErrno : 0; } SQLITE_API const char *sqlite3_errstr(int rc){  return sqlite3ErrStr(rc); } static int createCollation(  sqlite3* db,  const char *zName,  u8 enc,  void* pCtx,  int(*xCompare)(void*,int,const void*,int,const void*),  void(*xDel)(void*) ){  CollSeq *pColl;  int enc2;  assert( sqlite3_mutex_held(db->mutex) );  enc2 = enc;  testcase( enc2==SQLITE_UTF16 );  testcase( enc2==SQLITE_UTF16_ALIGNED );  if( enc2==SQLITE_UTF16 || enc2==SQLITE_UTF16_ALIGNED ){  enc2 = SQLITE_UTF16NATIVE;  }  if( enc2<SQLITE_UTF8 || enc2>SQLITE_UTF16BE ){  return SQLITE_MISUSE_BKPT;  }  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);  if( pColl && pColl->xCmp ){  if( db->nVdbeActive ){  sqlite3ErrorWithMsg(db, SQLITE_BUSY,  "unable to delete/modify collation sequence due to active statements");  return SQLITE_BUSY;  }  sqlite3ExpirePreparedStatements(db, 0);  if( (pColl->enc & ~SQLITE_UTF16_ALIGNED)==enc2 ){  CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName);  int j;  for(j=0; j<3; j++){  CollSeq *p = &aColl[j];  if( p->enc==pColl->enc ){  if( p->xDel ){  p->xDel(p->pUser);  }  p->xCmp = 0;  }  }  }  }  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);  if( pColl==0 ) return SQLITE_NOMEM_BKPT;  pColl->xCmp = xCompare;  pColl->pUser = pCtx;  pColl->xDel = xDel;  pColl->enc = (u8)(enc2 | (enc & SQLITE_UTF16_ALIGNED));  sqlite3Error(db, SQLITE_OK);  return SQLITE_OK; } static const int aHardLimit[] = {  SQLITE_MAX_LENGTH,  SQLITE_MAX_SQL_LENGTH,  SQLITE_MAX_COLUMN,  SQLITE_MAX_EXPR_DEPTH,  SQLITE_MAX_COMPOUND_SELECT,  SQLITE_MAX_VDBE_OP,  SQLITE_MAX_FUNCTION_ARG,  SQLITE_MAX_ATTACHED,  SQLITE_MAX_LIKE_PATTERN_LENGTH,  SQLITE_MAX_VARIABLE_NUMBER,  SQLITE_MAX_TRIGGER_DEPTH,  SQLITE_MAX_WORKER_THREADS, };
#if SQLITE_MAX_LENGTH<100
# error SQLITE_MAX_LENGTH must be at least 100
#endif
#if SQLITE_MAX_SQL_LENGTH<100
# error SQLITE_MAX_SQL_LENGTH must be at least 100
#endif
#if SQLITE_MAX_SQL_LENGTH>SQLITE_MAX_LENGTH
# error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH
#endif
#if SQLITE_MAX_COMPOUND_SELECT<2
# error SQLITE_MAX_COMPOUND_SELECT must be at least 2
#endif
#if SQLITE_MAX_VDBE_OP<40
# error SQLITE_MAX_VDBE_OP must be at least 40
#endif
#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>127
# error SQLITE_MAX_FUNCTION_ARG must be between 0 and 127
#endif
#if SQLITE_MAX_ATTACHED<0 || SQLITE_MAX_ATTACHED>125
# error SQLITE_MAX_ATTACHED must be between 0 and 125
#endif
#if SQLITE_MAX_LIKE_PATTERN_LENGTH<1
# error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1
#endif
#if SQLITE_MAX_COLUMN>32767
# error SQLITE_MAX_COLUMN must not exceed 32767
#endif
#if SQLITE_MAX_TRIGGER_DEPTH<1
# error SQLITE_MAX_TRIGGER_DEPTH must be at least 1
#endif
#if SQLITE_MAX_WORKER_THREADS<0 || SQLITE_MAX_WORKER_THREADS>50
# error SQLITE_MAX_WORKER_THREADS must be between 0 and 50
#endif
SQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){  int oldLimit;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return -1;  }
#endif
 assert( aHardLimit[SQLITE_LIMIT_LENGTH]==SQLITE_MAX_LENGTH );  assert( aHardLimit[SQLITE_LIMIT_SQL_LENGTH]==SQLITE_MAX_SQL_LENGTH );  assert( aHardLimit[SQLITE_LIMIT_COLUMN]==SQLITE_MAX_COLUMN );  assert( aHardLimit[SQLITE_LIMIT_EXPR_DEPTH]==SQLITE_MAX_EXPR_DEPTH );  assert( aHardLimit[SQLITE_LIMIT_COMPOUND_SELECT]==SQLITE_MAX_COMPOUND_SELECT);  assert( aHardLimit[SQLITE_LIMIT_VDBE_OP]==SQLITE_MAX_VDBE_OP );  assert( aHardLimit[SQLITE_LIMIT_FUNCTION_ARG]==SQLITE_MAX_FUNCTION_ARG );  assert( aHardLimit[SQLITE_LIMIT_ATTACHED]==SQLITE_MAX_ATTACHED );  assert( aHardLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]==   SQLITE_MAX_LIKE_PATTERN_LENGTH );  assert( aHardLimit[SQLITE_LIMIT_VARIABLE_NUMBER]==SQLITE_MAX_VARIABLE_NUMBER);  assert( aHardLimit[SQLITE_LIMIT_TRIGGER_DEPTH]==SQLITE_MAX_TRIGGER_DEPTH );  assert( aHardLimit[SQLITE_LIMIT_WORKER_THREADS]==SQLITE_MAX_WORKER_THREADS );  assert( SQLITE_LIMIT_WORKER_THREADS==(SQLITE_N_LIMIT-1) );  if( limitId<0 || limitId>=SQLITE_N_LIMIT ){  return -1;  }  oldLimit = db->aLimit[limitId];  if( newLimit>=0 ){  if( newLimit>aHardLimit[limitId] ){  newLimit = aHardLimit[limitId];  }else if( newLimit<1 && limitId==SQLITE_LIMIT_LENGTH ){  newLimit = 1;  }  db->aLimit[limitId] = newLimit;  }  return oldLimit; } SQLITE_PRIVATE int sqlite3ParseUri(  const char *zDefaultVfs,  const char *zUri,  unsigned int *pFlags,  sqlite3_vfs **ppVfs,  char **pzFile,  char **pzErrMsg ){  int rc = SQLITE_OK;  unsigned int flags = *pFlags;  const char *zVfs = zDefaultVfs;  char *zFile;  char c;  int nUri = sqlite3Strlen30(zUri);  assert( *pzErrMsg==0 );  if( ((flags & SQLITE_OPEN_URI)  || sqlite3GlobalConfig.bOpenUri)   && nUri>=5 && memcmp(zUri, "file:", 5)==0  ){  char *zOpt;  int eState;  int iIn;  int iOut = 0;  u64 nByte = nUri+8;  flags |= SQLITE_OPEN_URI;  for(iIn=0; iIn<nUri; iIn++) nByte += (zUri[iIn]=='&');  zFile = sqlite3_malloc64(nByte);  if( !zFile ) return SQLITE_NOMEM_BKPT;  memset(zFile, 0, 4);  zFile += 4;  iIn = 5;
#ifdef SQLITE_ALLOW_URI_AUTHORITY
 if( strncmp(zUri+5, " iIn = 7;  if( strncmp(zUri+7, " }else if( strncmp(zUri+5, " iIn = 16;  }
#else
 if( zUri[5]=='/' && zUri[6]=='/' ){  iIn = 7;  while( zUri[iIn] && zUri[iIn]!='/' ) iIn++;  if( iIn!=7 && (iIn!=16 || memcmp("localhost", &zUri[7], 9)) ){  *pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s",  iIn-7, &zUri[7]);  rc = SQLITE_ERROR;  goto parse_uri_out;  }  }
#endif
 eState = 0;  while( (c = zUri[iIn])!=0 && c!='#' ){  iIn++;  if( c=='%'   && sqlite3Isxdigit(zUri[iIn])   && sqlite3Isxdigit(zUri[iIn+1])  ){  int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);  octet += sqlite3HexToInt(zUri[iIn++]);  assert( octet>=0 && octet<256 );  if( octet==0 ){
#ifndef SQLITE_ENABLE_URI_00_ERROR
 while( (c = zUri[iIn])!=0 && c!='#'  && (eState!=0 || c!='?')  && (eState!=1 || (c!='=' && c!='&'))  && (eState!=2 || c!='&')  ){  iIn++;  }  continue;
#else
 *pzErrMsg = sqlite3_mprintf("unexpected %%00 in uri");  rc = SQLITE_ERROR;  goto parse_uri_out;
#endif
 }  c = octet;  }else if( eState==1 && (c=='&' || c=='=') ){  if( zFile[iOut-1]==0 ){  while( zUri[iIn] && zUri[iIn]!='#' && zUri[iIn-1]!='&' ) iIn++;  continue;  }  if( c=='&' ){  zFile[iOut++] = '\0';  }else{  eState = 2;  }  c = 0;  }else if( (eState==0 && c=='?') || (eState==2 && c=='&') ){  c = 0;  eState = 1;  }  zFile[iOut++] = c;  }  if( eState==1 ) zFile[iOut++] = '\0';  memset(zFile+iOut, 0, 4);  zOpt = &zFile[sqlite3Strlen30(zFile)+1];  while( zOpt[0] ){  int nOpt = sqlite3Strlen30(zOpt);  char *zVal = &zOpt[nOpt+1];  int nVal = sqlite3Strlen30(zVal);  if( nOpt==3 && memcmp("vfs", zOpt, 3)==0 ){  zVfs = zVal;  }else{  struct OpenMode {  const char *z;  int mode;  } *aMode = 0;  char *zModeType = 0;  int mask = 0;  int limit = 0;  if( nOpt==5 && memcmp("cache", zOpt, 5)==0 ){  static struct OpenMode aCacheMode[] = {  { "shared", SQLITE_OPEN_SHAREDCACHE },  { "private", SQLITE_OPEN_PRIVATECACHE },  { 0, 0 }  };  mask = SQLITE_OPEN_SHAREDCACHE|SQLITE_OPEN_PRIVATECACHE;  aMode = aCacheMode;  limit = mask;  zModeType = "cache";  }  if( nOpt==4 && memcmp("mode", zOpt, 4)==0 ){  static struct OpenMode aOpenMode[] = {  { "ro", SQLITE_OPEN_READONLY },  { "rw", SQLITE_OPEN_READWRITE },  { "rwc", SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE },  { "memory", SQLITE_OPEN_MEMORY },  { 0, 0 }  };  mask = SQLITE_OPEN_READONLY | SQLITE_OPEN_READWRITE   | SQLITE_OPEN_CREATE | SQLITE_OPEN_MEMORY;  aMode = aOpenMode;  limit = mask & flags;  zModeType = "access";  }  if( aMode ){  int i;  int mode = 0;  for(i=0; aMode[i].z; i++){  const char *z = aMode[i].z;  if( nVal==sqlite3Strlen30(z) && 0==memcmp(zVal, z, nVal) ){  mode = aMode[i].mode;  break;  }  }  if( mode==0 ){  *pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);  rc = SQLITE_ERROR;  goto parse_uri_out;  }  if( (mode & ~SQLITE_OPEN_MEMORY)>limit ){  *pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s",  zModeType, zVal);  rc = SQLITE_PERM;  goto parse_uri_out;  }  flags = (flags & ~mask) | mode;  }  }  zOpt = &zVal[nVal+1];  }  }else{  zFile = sqlite3_malloc64(nUri+8);  if( !zFile ) return SQLITE_NOMEM_BKPT;  memset(zFile, 0, 4);  zFile += 4;  if( nUri ){  memcpy(zFile, zUri, nUri);  }  memset(zFile+nUri, 0, 4);  flags &= ~SQLITE_OPEN_URI;  }  *ppVfs = sqlite3_vfs_find(zVfs);  if( *ppVfs==0 ){  *pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);  rc = SQLITE_ERROR;  }  parse_uri_out:  if( rc!=SQLITE_OK ){  sqlite3_free_filename(zFile);  zFile = 0;  }  *pFlags = flags;  *pzFile = zFile;  return rc; } static const char *uriParameter(const char *zFilename, const char *zParam){  zFilename += sqlite3Strlen30(zFilename) + 1;  while( ALWAYS(zFilename!=0) && zFilename[0] ){  int x = strcmp(zFilename, zParam);  zFilename += sqlite3Strlen30(zFilename) + 1;  if( x==0 ) return zFilename;  zFilename += sqlite3Strlen30(zFilename) + 1;  }  return 0; } static int openDatabase(  const char *zFilename,  sqlite3 **ppDb,  unsigned int flags,  const char *zVfs ){  sqlite3 *db;  int rc;  int isThreadsafe;  char *zOpen = 0;  char *zErrMsg = 0;  int i;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( ppDb==0 ) return SQLITE_MISUSE_BKPT;
#endif
 *ppDb = 0;
#ifndef SQLITE_OMIT_AUTOINIT
 rc = sqlite3_initialize();  if( rc ) return rc;
#endif
 if( sqlite3GlobalConfig.bCoreMutex==0 ){  isThreadsafe = 0;  }else if( flags & SQLITE_OPEN_NOMUTEX ){  isThreadsafe = 0;  }else if( flags & SQLITE_OPEN_FULLMUTEX ){  isThreadsafe = 1;  }else{  isThreadsafe = sqlite3GlobalConfig.bFullMutex;  }  if( flags & SQLITE_OPEN_PRIVATECACHE ){  flags &= ~SQLITE_OPEN_SHAREDCACHE;  }else if( sqlite3GlobalConfig.sharedCacheEnabled ){  flags |= SQLITE_OPEN_SHAREDCACHE;  }  flags &= ~( SQLITE_OPEN_DELETEONCLOSE |   SQLITE_OPEN_EXCLUSIVE |   SQLITE_OPEN_MAIN_DB |   SQLITE_OPEN_TEMP_DB |   SQLITE_OPEN_TRANSIENT_DB |   SQLITE_OPEN_MAIN_JOURNAL |   SQLITE_OPEN_TEMP_JOURNAL |   SQLITE_OPEN_SUBJOURNAL |   SQLITE_OPEN_SUPER_JOURNAL |   SQLITE_OPEN_NOMUTEX |   SQLITE_OPEN_FULLMUTEX |   SQLITE_OPEN_WAL   );  db = sqlite3MallocZero( sizeof(sqlite3) );  if( db==0 ) goto opendb_out;  if( isThreadsafe
#ifdef SQLITE_ENABLE_MULTITHREADED_CHECKS
  || sqlite3GlobalConfig.bCoreMutex
#endif
 ){  db->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);  if( db->mutex==0 ){  sqlite3_free(db);  db = 0;  goto opendb_out;  }  if( isThreadsafe==0 ){  sqlite3MutexWarnOnContention(db->mutex);  }  }  sqlite3_mutex_enter(db->mutex);  db->errMask = (flags & SQLITE_OPEN_EXRESCODE)!=0 ? 0xffffffff : 0xff;  db->nDb = 2;  db->eOpenState = SQLITE_STATE_BUSY;  db->aDb = db->aDbStatic;  db->lookaside.bDisable = 1;  db->lookaside.sz = 0;  assert( sizeof(db->aLimit)==sizeof(aHardLimit) );  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));  db->aLimit[SQLITE_LIMIT_WORKER_THREADS] = SQLITE_DEFAULT_WORKER_THREADS;  db->autoCommit = 1;  db->nextAutovac = -1;  db->szMmap = sqlite3GlobalConfig.szMmap;  db->nextPagesize = 0;  db->init.azInit = sqlite3StdType;
#ifdef SQLITE_ENABLE_SORTER_MMAP
 db->nMaxSorterMmap = 0x7FFFFFFF;
#endif
 db->flags |= SQLITE_ShortColNames   | SQLITE_EnableTrigger   | SQLITE_EnableView   | SQLITE_CacheSpill
#if !defined(SQLITE_TRUSTED_SCHEMA) || SQLITE_TRUSTED_SCHEMA+0!=0
  | SQLITE_TrustedSchema
#endif
#if !defined(SQLITE_DQS)
# define SQLITE_DQS 3
#endif
#if (SQLITE_DQS&1)==1
  | SQLITE_DqsDML
#endif
#if (SQLITE_DQS&2)==2
  | SQLITE_DqsDDL
#endif
#if !defined(SQLITE_DEFAULT_AUTOMATIC_INDEX) || SQLITE_DEFAULT_AUTOMATIC_INDEX
  | SQLITE_AutoIndex
#endif
#if SQLITE_DEFAULT_CKPTFULLFSYNC
  | SQLITE_CkptFullFSync
#endif
#if SQLITE_DEFAULT_FILE_FORMAT<4
  | SQLITE_LegacyFileFmt
#endif
#ifdef SQLITE_ENABLE_LOAD_EXTENSION
  | SQLITE_LoadExtension
#endif
#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS
  | SQLITE_RecTriggers
#endif
#if defined(SQLITE_DEFAULT_FOREIGN_KEYS) && SQLITE_DEFAULT_FOREIGN_KEYS
  | SQLITE_ForeignKeys
#endif
#if defined(SQLITE_REVERSE_UNORDERED_SELECTS)
  | SQLITE_ReverseOrder
#endif
#if defined(SQLITE_ENABLE_OVERSIZE_CELL_CHECK)
  | SQLITE_CellSizeCk
#endif
#if defined(SQLITE_ENABLE_FTS3_TOKENIZER)
  | SQLITE_Fts3Tokenizer
#endif
#if defined(SQLITE_ENABLE_QPSG)
  | SQLITE_EnableQPSG
#endif
#if defined(SQLITE_DEFAULT_DEFENSIVE)
  | SQLITE_Defensive
#endif
#if defined(SQLITE_DEFAULT_LEGACY_ALTER_TABLE)
  | SQLITE_LegacyAlter
#endif
 ;  sqlite3HashInit(&db->aCollSeq);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 sqlite3HashInit(&db->aModule);
#endif
 createCollation(db, sqlite3StrBINARY, SQLITE_UTF8, 0, binCollFunc, 0);  createCollation(db, sqlite3StrBINARY, SQLITE_UTF16BE, 0, binCollFunc, 0);  createCollation(db, sqlite3StrBINARY, SQLITE_UTF16LE, 0, binCollFunc, 0);  createCollation(db, "NOCASE", SQLITE_UTF8, 0, nocaseCollatingFunc, 0);  createCollation(db, "RTRIM", SQLITE_UTF8, 0, rtrimCollFunc, 0);  if( db->mallocFailed ){  goto opendb_out;  }  db->openFlags = flags;  assert( SQLITE_OPEN_READONLY == 0x01 );  assert( SQLITE_OPEN_READWRITE == 0x02 );  assert( SQLITE_OPEN_CREATE == 0x04 );  testcase( (1<<(flags&7))==0x02 );  testcase( (1<<(flags&7))==0x04 );  testcase( (1<<(flags&7))==0x40 );  if( ((1<<(flags&7)) & 0x46)==0 ){  rc = SQLITE_MISUSE_BKPT;  }else{  rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);  }  if( rc!=SQLITE_OK ){  if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);  sqlite3ErrorWithMsg(db, rc, zErrMsg ? "%s" : 0, zErrMsg);  sqlite3_free(zErrMsg);  goto opendb_out;  }  rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0,  flags | SQLITE_OPEN_MAIN_DB);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_IOERR_NOMEM ){  rc = SQLITE_NOMEM_BKPT;  }  sqlite3Error(db, rc);  goto opendb_out;  }  sqlite3BtreeEnter(db->aDb[0].pBt);  db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);  if( !db->mallocFailed ){  sqlite3SetTextEncoding(db, SCHEMA_ENC(db));  }  sqlite3BtreeLeave(db->aDb[0].pBt);  db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);  db->aDb[0].zDbSName = "main";  db->aDb[0].safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;  db->aDb[1].zDbSName = "temp";  db->aDb[1].safety_level = PAGER_SYNCHRONOUS_OFF;  db->eOpenState = SQLITE_STATE_OPEN;  if( db->mallocFailed ){  goto opendb_out;  }  sqlite3Error(db, SQLITE_OK);  sqlite3RegisterPerConnectionBuiltinFunctions(db);  rc = sqlite3_errcode(db);  for(i=0; rc==SQLITE_OK && i<ArraySize(sqlite3BuiltinExtensions); i++){  rc = sqlite3BuiltinExtensions[i](db);  }  if( rc==SQLITE_OK ){  sqlite3AutoLoadExtensions(db);  rc = sqlite3_errcode(db);  if( rc!=SQLITE_OK ){  goto opendb_out;  }  }
#ifdef SQLITE_ENABLE_INTERNAL_FUNCTIONS
 db->mDbFlags |= DBFLAG_InternalFunc;
#endif
#ifdef SQLITE_DEFAULT_LOCKING_MODE
 db->dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE;  sqlite3PagerLockingMode(sqlite3BtreePager(db->aDb[0].pBt),  SQLITE_DEFAULT_LOCKING_MODE);
#endif
 if( rc ) sqlite3Error(db, rc);  setupLookaside(db, 0, sqlite3GlobalConfig.szLookaside,  sqlite3GlobalConfig.nLookaside);  sqlite3_wal_autocheckpoint(db, SQLITE_DEFAULT_WAL_AUTOCHECKPOINT); opendb_out:  if( db ){  assert( db->mutex!=0 || isThreadsafe==0   || sqlite3GlobalConfig.bFullMutex==0 );  sqlite3_mutex_leave(db->mutex);  }  rc = sqlite3_errcode(db);  assert( db!=0 || (rc&0xff)==SQLITE_NOMEM );  if( (rc&0xff)==SQLITE_NOMEM ){  sqlite3_close(db);  db = 0;  }else if( rc!=SQLITE_OK ){  db->eOpenState = SQLITE_STATE_SICK;  }  *ppDb = db;
#ifdef SQLITE_ENABLE_SQLLOG
 if( sqlite3GlobalConfig.xSqllog ){  void *pArg = sqlite3GlobalConfig.pSqllogArg;  sqlite3GlobalConfig.xSqllog(pArg, db, zFilename, 0);  }
#endif
 sqlite3_free_filename(zOpen);  return rc; } SQLITE_API int sqlite3_open(  const char *zFilename,  sqlite3 **ppDb ){  return openDatabase(zFilename, ppDb,  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0); } SQLITE_API int sqlite3_open_v2(  const char *filename,  sqlite3 **ppDb,  int flags,  const char *zVfs ){  return openDatabase(filename, ppDb, (unsigned int)flags, zVfs); }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_open16(  const void *zFilename,  sqlite3 **ppDb ){  char const *zFilename8;  sqlite3_value *pVal;  int rc;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( ppDb==0 ) return SQLITE_MISUSE_BKPT;
#endif
 *ppDb = 0;
#ifndef SQLITE_OMIT_AUTOINIT
 rc = sqlite3_initialize();  if( rc ) return rc;
#endif
 if( zFilename==0 ) zFilename = "\000\000";  pVal = sqlite3ValueNew(0);  sqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC);  zFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8);  if( zFilename8 ){  rc = openDatabase(zFilename8, ppDb,  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);  assert( *ppDb || rc==SQLITE_NOMEM );  if( rc==SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded) ){  SCHEMA_ENC(*ppDb) = ENC(*ppDb) = SQLITE_UTF16NATIVE;  }  }else{  rc = SQLITE_NOMEM_BKPT;  }  sqlite3ValueFree(pVal);  return rc & 0xff; }
#endif
SQLITE_API int sqlite3_create_collation(  sqlite3* db,  const char *zName,  int enc,  void* pCtx,  int(*xCompare)(void*,int,const void*,int,const void*) ){  return sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, 0); } SQLITE_API int sqlite3_create_collation_v2(  sqlite3* db,  const char *zName,  int enc,  void* pCtx,  int(*xCompare)(void*,int,const void*,int,const void*),  void(*xDel)(void*) ){  int rc;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  assert( !db->mallocFailed );  rc = createCollation(db, zName, (u8)enc, pCtx, xCompare, xDel);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_create_collation16(  sqlite3* db,  const void *zName,  int enc,  void* pCtx,  int(*xCompare)(void*,int,const void*,int,const void*) ){  int rc = SQLITE_OK;  char *zName8;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  assert( !db->mallocFailed );  zName8 = sqlite3Utf16to8(db, zName, -1, SQLITE_UTF16NATIVE);  if( zName8 ){  rc = createCollation(db, zName8, (u8)enc, pCtx, xCompare, 0);  sqlite3DbFree(db, zName8);  }  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; }
#endif
SQLITE_API int sqlite3_collation_needed(  sqlite3 *db,  void *pCollNeededArg,  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*) ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  db->xCollNeeded = xCollNeeded;  db->xCollNeeded16 = 0;  db->pCollNeededArg = pCollNeededArg;  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; }
#ifndef SQLITE_OMIT_UTF16
SQLITE_API int sqlite3_collation_needed16(  sqlite3 *db,  void *pCollNeededArg,  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*) ){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  db->xCollNeeded = 0;  db->xCollNeeded16 = xCollNeeded16;  db->pCollNeededArg = pCollNeededArg;  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; }
#endif
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API int sqlite3_global_recover(void){  return SQLITE_OK; }
#endif
SQLITE_API int sqlite3_get_autocommit(sqlite3 *db){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 return db->autoCommit; } SQLITE_PRIVATE int sqlite3ReportError(int iErr, int lineno, const char *zType){  sqlite3_log(iErr, "%s at line %d of [%.10s]",  zType, lineno, 20+sqlite3_sourceid());  return iErr; } SQLITE_PRIVATE int sqlite3CorruptError(int lineno){  testcase( sqlite3GlobalConfig.xLog!=0 );  return sqlite3ReportError(SQLITE_CORRUPT, lineno, "database corruption"); } SQLITE_PRIVATE int sqlite3MisuseError(int lineno){  testcase( sqlite3GlobalConfig.xLog!=0 );  return sqlite3ReportError(SQLITE_MISUSE, lineno, "misuse"); } SQLITE_PRIVATE int sqlite3CantopenError(int lineno){  testcase( sqlite3GlobalConfig.xLog!=0 );  return sqlite3ReportError(SQLITE_CANTOPEN, lineno, "cannot open file"); }
#if defined(SQLITE_DEBUG) || defined(SQLITE_ENABLE_CORRUPT_PGNO)
SQLITE_PRIVATE int sqlite3CorruptPgnoError(int lineno, Pgno pgno){  char zMsg[100];  sqlite3_snprintf(sizeof(zMsg), zMsg, "database corruption page %d", pgno);  testcase( sqlite3GlobalConfig.xLog!=0 );  return sqlite3ReportError(SQLITE_CORRUPT, lineno, zMsg); }
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3NomemError(int lineno){  testcase( sqlite3GlobalConfig.xLog!=0 );  return sqlite3ReportError(SQLITE_NOMEM, lineno, "OOM"); } SQLITE_PRIVATE int sqlite3IoerrnomemError(int lineno){  testcase( sqlite3GlobalConfig.xLog!=0 );  return sqlite3ReportError(SQLITE_IOERR_NOMEM, lineno, "I/O OOM error"); }
#endif
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API void sqlite3_thread_cleanup(void){ }
#endif
SQLITE_API int sqlite3_table_column_metadata(  sqlite3 *db,  const char *zDbName,  const char *zTableName,  const char *zColumnName,  char const **pzDataType,  char const **pzCollSeq,  int *pNotNull,  int *pPrimaryKey,  int *pAutoinc ){  int rc;  char *zErrMsg = 0;  Table *pTab = 0;  Column *pCol = 0;  int iCol = 0;  char const *zDataType = 0;  char const *zCollSeq = 0;  int notnull = 0;  int primarykey = 0;  int autoinc = 0;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) || zTableName==0 ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  sqlite3BtreeEnterAll(db);  rc = sqlite3Init(db, &zErrMsg);  if( SQLITE_OK!=rc ){  goto error_out;  }  pTab = sqlite3FindTable(db, zTableName, zDbName);  if( !pTab || IsView(pTab) ){  pTab = 0;  goto error_out;  }  if( zColumnName==0 ){  }else{  for(iCol=0; iCol<pTab->nCol; iCol++){  pCol = &pTab->aCol[iCol];  if( 0==sqlite3StrICmp(pCol->zCnName, zColumnName) ){  break;  }  }  if( iCol==pTab->nCol ){  if( HasRowid(pTab) && sqlite3IsRowid(zColumnName) ){  iCol = pTab->iPKey;  pCol = iCol>=0 ? &pTab->aCol[iCol] : 0;  }else{  pTab = 0;  goto error_out;  }  }  }  if( pCol ){  zDataType = sqlite3ColumnType(pCol,0);  zCollSeq = sqlite3ColumnColl(pCol);  notnull = pCol->notNull!=0;  primarykey = (pCol->colFlags & COLFLAG_PRIMKEY)!=0;  autoinc = pTab->iPKey==iCol && (pTab->tabFlags & TF_Autoincrement)!=0;  }else{  zDataType = "INTEGER";  primarykey = 1;  }  if( !zCollSeq ){  zCollSeq = sqlite3StrBINARY;  } error_out:  sqlite3BtreeLeaveAll(db);  if( pzDataType ) *pzDataType = zDataType;  if( pzCollSeq ) *pzCollSeq = zCollSeq;  if( pNotNull ) *pNotNull = notnull;  if( pPrimaryKey ) *pPrimaryKey = primarykey;  if( pAutoinc ) *pAutoinc = autoinc;  if( SQLITE_OK==rc && !pTab ){  sqlite3DbFree(db, zErrMsg);  zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,  zColumnName);  rc = SQLITE_ERROR;  }  sqlite3ErrorWithMsg(db, rc, (zErrMsg?"%s":0), zErrMsg);  sqlite3DbFree(db, zErrMsg);  rc = sqlite3ApiExit(db, rc);  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_sleep(int ms){  sqlite3_vfs *pVfs;  int rc;  pVfs = sqlite3_vfs_find(0);  if( pVfs==0 ) return 0;  rc = (sqlite3OsSleep(pVfs, 1000*ms)/1000);  return rc; } SQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  db->errMask = onoff ? 0xffffffff : 0xff;  sqlite3_mutex_leave(db->mutex);  return SQLITE_OK; } SQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){  int rc = SQLITE_ERROR;  Btree *pBtree;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
#endif
 sqlite3_mutex_enter(db->mutex);  pBtree = sqlite3DbNameToBtree(db, zDbName);  if( pBtree ){  Pager *pPager;  sqlite3_file *fd;  sqlite3BtreeEnter(pBtree);  pPager = sqlite3BtreePager(pBtree);  assert( pPager!=0 );  fd = sqlite3PagerFile(pPager);  assert( fd!=0 );  if( op==SQLITE_FCNTL_FILE_POINTER ){  *(sqlite3_file**)pArg = fd;  rc = SQLITE_OK;  }else if( op==SQLITE_FCNTL_VFS_POINTER ){  *(sqlite3_vfs**)pArg = sqlite3PagerVfs(pPager);  rc = SQLITE_OK;  }else if( op==SQLITE_FCNTL_JOURNAL_POINTER ){  *(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);  rc = SQLITE_OK;  }else if( op==SQLITE_FCNTL_DATA_VERSION ){  *(unsigned int*)pArg = sqlite3PagerDataVersion(pPager);  rc = SQLITE_OK;  }else if( op==SQLITE_FCNTL_RESERVE_BYTES ){  int iNew = *(int*)pArg;  *(int*)pArg = sqlite3BtreeGetRequestedReserve(pBtree);  if( iNew>=0 && iNew<=255 ){  sqlite3BtreeSetPageSize(pBtree, 0, iNew, 0);  }  rc = SQLITE_OK;  }else{  int nSave = db->busyHandler.nBusy;  rc = sqlite3OsFileControl(fd, op, pArg);  db->busyHandler.nBusy = nSave;  }  sqlite3BtreeLeave(pBtree);  }  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_API int sqlite3_test_control(int op, ...){  int rc = 0;
#ifdef SQLITE_UNTESTABLE
 UNUSED_PARAMETER(op);
#else
 va_list ap;  va_start(ap, op);  switch( op ){  case SQLITE_TESTCTRL_PRNG_SAVE: {  sqlite3PrngSaveState();  break;  }  case SQLITE_TESTCTRL_PRNG_RESTORE: {  sqlite3PrngRestoreState();  break;  }
#ifndef SQLITE_OMIT_WSD
 case SQLITE_TESTCTRL_PRNG_SEED: {  int x = va_arg(ap, int);  int y;  sqlite3 *db = va_arg(ap, sqlite3*);  assert( db==0 || db->aDb[0].pSchema!=0 );  if( db && (y = db->aDb[0].pSchema->schema_cookie)!=0 ){ x = y; }  sqlite3Config.iPrngSeed = x;  sqlite3_randomness(0,0);  break;  }
#endif
 case SQLITE_TESTCTRL_BITVEC_TEST: {  int sz = va_arg(ap, int);  int *aProg = va_arg(ap, int*);  rc = sqlite3BitvecBuiltinTest(sz, aProg);  break;  }  case SQLITE_TESTCTRL_FAULT_INSTALL: {  typedef int(*TESTCALLBACKFUNC_t)(int);  sqlite3GlobalConfig.xTestCallback = va_arg(ap, TESTCALLBACKFUNC_t);  rc = sqlite3FaultSim(0);  break;  }  case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: {  typedef void (*void_function)(void);  void_function xBenignBegin;  void_function xBenignEnd;  xBenignBegin = va_arg(ap, void_function);  xBenignEnd = va_arg(ap, void_function);  sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);  break;  }  case SQLITE_TESTCTRL_PENDING_BYTE: {  rc = PENDING_BYTE;
#ifndef SQLITE_OMIT_WSD
 {  unsigned int newVal = va_arg(ap, unsigned int);  if( newVal ) sqlite3PendingByte = newVal;  }
#endif
 break;  }  case SQLITE_TESTCTRL_ASSERT: {  volatile int x = 0;  assert( (x = va_arg(ap,int))!=0 );  rc = x;  break;  }  case SQLITE_TESTCTRL_ALWAYS: {  int x = va_arg(ap,int);  rc = x ? ALWAYS(x) : 0;  break;  }  case SQLITE_TESTCTRL_BYTEORDER: {  rc = SQLITE_BYTEORDER*100 + SQLITE_LITTLEENDIAN*10 + SQLITE_BIGENDIAN;  break;  }  case SQLITE_TESTCTRL_OPTIMIZATIONS: {  sqlite3 *db = va_arg(ap, sqlite3*);  db->dbOptFlags = va_arg(ap, u32);  break;  }  case SQLITE_TESTCTRL_LOCALTIME_FAULT: {  sqlite3GlobalConfig.bLocaltimeFault = va_arg(ap, int);  break;  }  case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS: {  sqlite3 *db = va_arg(ap, sqlite3*);  db->mDbFlags ^= DBFLAG_InternalFunc;  break;  }  case SQLITE_TESTCTRL_NEVER_CORRUPT: {  sqlite3GlobalConfig.neverCorrupt = va_arg(ap, int);  break;  }  case SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS: {  sqlite3GlobalConfig.bExtraSchemaChecks = va_arg(ap, int);  break;  }  case SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD: {  sqlite3GlobalConfig.iOnceResetThreshold = va_arg(ap, int);  break;  }  case SQLITE_TESTCTRL_VDBE_COVERAGE: {
#ifdef SQLITE_VDBE_COVERAGE
 typedef void (*branch_callback)(void*,unsigned int,  unsigned char,unsigned char);  sqlite3GlobalConfig.xVdbeBranch = va_arg(ap,branch_callback);  sqlite3GlobalConfig.pVdbeBranchArg = va_arg(ap,void*);
#endif
 break;  }  case SQLITE_TESTCTRL_SORTER_MMAP: {  sqlite3 *db = va_arg(ap, sqlite3*);  db->nMaxSorterMmap = va_arg(ap, int);  break;  }  case SQLITE_TESTCTRL_ISINIT: {  if( sqlite3GlobalConfig.isInit==0 ) rc = SQLITE_ERROR;  break;  }  case SQLITE_TESTCTRL_IMPOSTER: {  sqlite3 *db = va_arg(ap, sqlite3*);  int iDb;  sqlite3_mutex_enter(db->mutex);  iDb = sqlite3FindDbName(db, va_arg(ap,const char*));  if( iDb>=0 ){  db->init.iDb = iDb;  db->init.busy = db->init.imposterTable = va_arg(ap,int);  db->init.newTnum = va_arg(ap,int);  if( db->init.busy==0 && db->init.newTnum>0 ){  sqlite3ResetAllSchemasOfConnection(db);  }  }  sqlite3_mutex_leave(db->mutex);  break;  }
#if defined(YYCOVERAGE)
 case SQLITE_TESTCTRL_PARSER_COVERAGE: {  FILE *out = va_arg(ap, FILE*);  if( sqlite3ParserCoverage(out) ) rc = SQLITE_ERROR;  break;  }
#endif
 case SQLITE_TESTCTRL_RESULT_INTREAL: {  sqlite3_context *pCtx = va_arg(ap, sqlite3_context*);  sqlite3ResultIntReal(pCtx);  break;  }  case SQLITE_TESTCTRL_SEEK_COUNT: {  sqlite3 *db = va_arg(ap, sqlite3*);  u64 *pn = va_arg(ap, sqlite3_uint64*);  *pn = sqlite3BtreeSeekCount(db->aDb->pBt);  (void)db;  break;  }  case SQLITE_TESTCTRL_TRACEFLAGS: {   int opTrace = va_arg(ap, int);   u32 *ptr = va_arg(ap, u32*);   switch( opTrace ){   case 0:  *ptr = sqlite3SelectTrace; break;   case 1:  sqlite3SelectTrace = *ptr; break;   case 2:  *ptr = sqlite3WhereTrace;  break;   case 3:  sqlite3WhereTrace = *ptr;  break;   }   break;  }
#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_WSD)
 case SQLITE_TESTCTRL_TUNE: {  int id = va_arg(ap, int);  int *piValue = va_arg(ap, int*);  if( id>0 && id<=SQLITE_NTUNE ){  Tuning(id) = *piValue;  }else if( id<0 && id>=-SQLITE_NTUNE ){  *piValue = Tuning(-id);  }else{  rc = SQLITE_NOTFOUND;  }  break;  }
#endif
 }  va_end(ap);
#endif
 return rc; } static const char *databaseName(const char *zName){  while( zName[-1]!=0 || zName[-2]!=0 || zName[-3]!=0 || zName[-4]!=0 ){  zName--;  }  return zName; } static char *appendText(char *p, const char *z){  size_t n = strlen(z);  memcpy(p, z, n+1);  return p+n+1; } SQLITE_API char *sqlite3_create_filename(  const char *zDatabase,  const char *zJournal,  const char *zWal,  int nParam,  const char **azParam ){  sqlite3_int64 nByte;  int i;  char *pResult, *p;  nByte = strlen(zDatabase) + strlen(zJournal) + strlen(zWal) + 10;  for(i=0; i<nParam*2; i++){  nByte += strlen(azParam[i])+1;  }  pResult = p = sqlite3_malloc64( nByte );  if( p==0 ) return 0;  memset(p, 0, 4);  p += 4;  p = appendText(p, zDatabase);  for(i=0; i<nParam*2; i++){  p = appendText(p, azParam[i]);  }  *(p++) = 0;  p = appendText(p, zJournal);  p = appendText(p, zWal);  *(p++) = 0;  *(p++) = 0;  assert( (sqlite3_int64)(p - pResult)==nByte );  return pResult + 4; } SQLITE_API void sqlite3_free_filename(char *p){  if( p==0 ) return;  p = (char*)databaseName(p);  sqlite3_free(p - 4); } SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){  if( zFilename==0 || zParam==0 ) return 0;  zFilename = databaseName(zFilename);  return uriParameter(zFilename, zParam); } SQLITE_API const char *sqlite3_uri_key(const char *zFilename, int N){  if( zFilename==0 || N<0 ) return 0;  zFilename = databaseName(zFilename);  zFilename += sqlite3Strlen30(zFilename) + 1;  while( ALWAYS(zFilename) && zFilename[0] && (N--)>0 ){  zFilename += sqlite3Strlen30(zFilename) + 1;  zFilename += sqlite3Strlen30(zFilename) + 1;  }  return zFilename[0] ? zFilename : 0; } SQLITE_API int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){  const char *z = sqlite3_uri_parameter(zFilename, zParam);  bDflt = bDflt!=0;  return z ? sqlite3GetBoolean(z, bDflt) : bDflt; } SQLITE_API sqlite3_int64 sqlite3_uri_int64(  const char *zFilename,  const char *zParam,  sqlite3_int64 bDflt ){  const char *z = sqlite3_uri_parameter(zFilename, zParam);  sqlite3_int64 v;  if( z && sqlite3DecOrHexToI64(z, &v)==0 ){  bDflt = v;  }  return bDflt; } SQLITE_API const char *sqlite3_filename_database(const char *zFilename){  if( zFilename==0 ) return 0;  return databaseName(zFilename); } SQLITE_API const char *sqlite3_filename_journal(const char *zFilename){  if( zFilename==0 ) return 0;  zFilename = databaseName(zFilename);  zFilename += sqlite3Strlen30(zFilename) + 1;  while( ALWAYS(zFilename) && zFilename[0] ){  zFilename += sqlite3Strlen30(zFilename) + 1;  zFilename += sqlite3Strlen30(zFilename) + 1;  }  return zFilename + 1; } SQLITE_API const char *sqlite3_filename_wal(const char *zFilename){
#ifdef SQLITE_OMIT_WAL
 return 0;
#else
 zFilename = sqlite3_filename_journal(zFilename);  if( zFilename ) zFilename += sqlite3Strlen30(zFilename) + 1;  return zFilename;
#endif
} SQLITE_PRIVATE Btree *sqlite3DbNameToBtree(sqlite3 *db, const char *zDbName){  int iDb = zDbName ? sqlite3FindDbName(db, zDbName) : 0;  return iDb<0 ? 0 : db->aDb[iDb].pBt; } SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){  Btree *pBt;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 pBt = sqlite3DbNameToBtree(db, zDbName);  return pBt ? sqlite3BtreeGetFilename(pBt) : 0; } SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){  Btree *pBt;
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  (void)SQLITE_MISUSE_BKPT;  return -1;  }
#endif
 pBt = sqlite3DbNameToBtree(db, zDbName);  return pBt ? sqlite3BtreeIsReadonly(pBt) : -1; }
#ifdef SQLITE_ENABLE_SNAPSHOT
SQLITE_API int sqlite3_snapshot_get(  sqlite3 *db,  const char *zDb,  sqlite3_snapshot **ppSnapshot ){  int rc = SQLITE_ERROR;
#ifndef SQLITE_OMIT_WAL
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( db->autoCommit==0 ){  int iDb = sqlite3FindDbName(db, zDb);  if( iDb==0 || iDb>1 ){  Btree *pBt = db->aDb[iDb].pBt;  if( SQLITE_TXN_WRITE!=sqlite3BtreeTxnState(pBt) ){  rc = sqlite3BtreeBeginTrans(pBt, 0, 0);  if( rc==SQLITE_OK ){  rc = sqlite3PagerSnapshotGet(sqlite3BtreePager(pBt), ppSnapshot);  }  }  }  }  sqlite3_mutex_leave(db->mutex);
#endif
 return rc; } SQLITE_API int sqlite3_snapshot_open(  sqlite3 *db,  const char *zDb,  sqlite3_snapshot *pSnapshot ){  int rc = SQLITE_ERROR;
#ifndef SQLITE_OMIT_WAL
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  if( db->autoCommit==0 ){  int iDb;  iDb = sqlite3FindDbName(db, zDb);  if( iDb==0 || iDb>1 ){  Btree *pBt = db->aDb[iDb].pBt;  if( sqlite3BtreeTxnState(pBt)!=SQLITE_TXN_WRITE ){  Pager *pPager = sqlite3BtreePager(pBt);  int bUnlock = 0;  if( sqlite3BtreeTxnState(pBt)!=SQLITE_TXN_NONE ){  if( db->nVdbeActive==0 ){  rc = sqlite3PagerSnapshotCheck(pPager, pSnapshot);  if( rc==SQLITE_OK ){  bUnlock = 1;  rc = sqlite3BtreeCommit(pBt);  }  }  }else{  rc = SQLITE_OK;  }  if( rc==SQLITE_OK ){  rc = sqlite3PagerSnapshotOpen(pPager, pSnapshot);  }  if( rc==SQLITE_OK ){  rc = sqlite3BtreeBeginTrans(pBt, 0, 0);  sqlite3PagerSnapshotOpen(pPager, 0);  }  if( bUnlock ){  sqlite3PagerSnapshotUnlock(pPager);  }  }  }  }  sqlite3_mutex_leave(db->mutex);
#endif
 return rc; } SQLITE_API int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb){  int rc = SQLITE_ERROR;  int iDb;
#ifndef SQLITE_OMIT_WAL
#ifdef SQLITE_ENABLE_API_ARMOR
 if( !sqlite3SafetyCheckOk(db) ){  return SQLITE_MISUSE_BKPT;  }
#endif
 sqlite3_mutex_enter(db->mutex);  iDb = sqlite3FindDbName(db, zDb);  if( iDb==0 || iDb>1 ){  Btree *pBt = db->aDb[iDb].pBt;  if( SQLITE_TXN_NONE==sqlite3BtreeTxnState(pBt) ){  rc = sqlite3BtreeBeginTrans(pBt, 0, 0);  if( rc==SQLITE_OK ){  rc = sqlite3PagerSnapshotRecover(sqlite3BtreePager(pBt));  sqlite3BtreeCommit(pBt);  }  }  }  sqlite3_mutex_leave(db->mutex);
#endif
 return rc; } SQLITE_API void sqlite3_snapshot_free(sqlite3_snapshot *pSnapshot){  sqlite3_free(pSnapshot); }
#endif
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
SQLITE_API int sqlite3_compileoption_used(const char *zOptName){  int i, n;  int nOpt;  const char **azCompileOpt;
#if SQLITE_ENABLE_API_ARMOR
 if( zOptName==0 ){  (void)SQLITE_MISUSE_BKPT;  return 0;  }
#endif
 azCompileOpt = sqlite3CompileOptions(&nOpt);  if( sqlite3StrNICmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;  n = sqlite3Strlen30(zOptName);  for(i=0; i<nOpt; i++){  if( sqlite3StrNICmp(zOptName, azCompileOpt[i], n)==0   && sqlite3IsIdChar((unsigned char)azCompileOpt[i][n])==0  ){  return 1;  }  }  return 0; } SQLITE_API const char *sqlite3_compileoption_get(int N){  int nOpt;  const char **azCompileOpt;  azCompileOpt = sqlite3CompileOptions(&nOpt);  if( N>=0 && N<nOpt ){  return azCompileOpt[N];  }  return 0; }
#endif
#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY
#define assertMutexHeld()  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN)) )

static sqlite3 *SQLITE_WSD sqlite3BlockedList = 0;
#ifndef NDEBUG
static void checkListProperties(sqlite3 *db){  sqlite3 *p;  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){  int seen = 0;  sqlite3 *p2;  assert( p->pUnlockConnection || p->pBlockingConnection );  for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){  if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;  assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );  assert( db==0 || p->pUnlockConnection!=db );  assert( db==0 || p->pBlockingConnection!=db );  }  } }
#else
# define checkListProperties(x)
#endif
static void removeFromBlockedList(sqlite3 *db){  sqlite3 **pp;  assertMutexHeld();  for(pp=&sqlite3BlockedList; *pp; pp = &(*pp)->pNextBlocked){  if( *pp==db ){  *pp = (*pp)->pNextBlocked;  break;  }  } } static void addToBlockedList(sqlite3 *db){  sqlite3 **pp;  assertMutexHeld();  for(  pp=&sqlite3BlockedList;  *pp && (*pp)->xUnlockNotify!=db->xUnlockNotify;  pp=&(*pp)->pNextBlocked  );  db->pNextBlocked = *pp;  *pp = db; } static void enterMutex(void){  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN));  checkListProperties(0); } static void leaveMutex(void){  assertMutexHeld();  checkListProperties(0);  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MAIN)); } SQLITE_API int sqlite3_unlock_notify(  sqlite3 *db,  void (*xNotify)(void **, int),  void *pArg ){  int rc = SQLITE_OK;  sqlite3_mutex_enter(db->mutex);  enterMutex();  if( xNotify==0 ){  removeFromBlockedList(db);  db->pBlockingConnection = 0;  db->pUnlockConnection = 0;  db->xUnlockNotify = 0;  db->pUnlockArg = 0;  }else if( 0==db->pBlockingConnection ){  xNotify(&pArg, 1);  }else{  sqlite3 *p;  for(p=db->pBlockingConnection; p && p!=db; p=p->pUnlockConnection){}  if( p ){  rc = SQLITE_LOCKED;  }else{  db->pUnlockConnection = db->pBlockingConnection;  db->xUnlockNotify = xNotify;  db->pUnlockArg = pArg;  removeFromBlockedList(db);  addToBlockedList(db);  }  }  leaveMutex();  assert( !db->mallocFailed );  sqlite3ErrorWithMsg(db, rc, (rc?"database is deadlocked":0));  sqlite3_mutex_leave(db->mutex);  return rc; } SQLITE_PRIVATE void sqlite3ConnectionBlocked(sqlite3 *db, sqlite3 *pBlocker){  enterMutex();  if( db->pBlockingConnection==0 && db->pUnlockConnection==0 ){  addToBlockedList(db);  }  db->pBlockingConnection = pBlocker;  leaveMutex(); } SQLITE_PRIVATE void sqlite3ConnectionUnlocked(sqlite3 *db){  void (*xUnlockNotify)(void **, int) = 0;  int nArg = 0;  sqlite3 **pp;  void **aArg;  void **aDyn = 0;  void *aStatic[16];  aArg = aStatic;  enterMutex();  for(pp=&sqlite3BlockedList; *pp; ){  sqlite3 *p = *pp;  if( p->pBlockingConnection==db ){  p->pBlockingConnection = 0;  }  if( p->pUnlockConnection==db ){  assert( p->xUnlockNotify );  if( p->xUnlockNotify!=xUnlockNotify && nArg!=0 ){  xUnlockNotify(aArg, nArg);  nArg = 0;  }  sqlite3BeginBenignMalloc();  assert( aArg==aDyn || (aDyn==0 && aArg==aStatic) );  assert( nArg<=(int)ArraySize(aStatic) || aArg==aDyn );  if( (!aDyn && nArg==(int)ArraySize(aStatic))   || (aDyn && nArg==(int)(sqlite3MallocSize(aDyn)/sizeof(void*)))  ){  void **pNew = (void **)sqlite3Malloc(nArg*sizeof(void *)*2);  if( pNew ){  memcpy(pNew, aArg, nArg*sizeof(void *));  sqlite3_free(aDyn);  aDyn = aArg = pNew;  }else{  xUnlockNotify(aArg, nArg);  nArg = 0;  }  }  sqlite3EndBenignMalloc();  aArg[nArg++] = p->pUnlockArg;  xUnlockNotify = p->xUnlockNotify;  p->pUnlockConnection = 0;  p->xUnlockNotify = 0;  p->pUnlockArg = 0;  }  if( p->pBlockingConnection==0 && p->pUnlockConnection==0 ){  *pp = p->pNextBlocked;  p->pNextBlocked = 0;  }else{  pp = &p->pNextBlocked;  }  }  if( nArg!=0 ){  xUnlockNotify(aArg, nArg);  }  sqlite3_free(aDyn);  leaveMutex(); } SQLITE_PRIVATE void sqlite3ConnectionClosed(sqlite3 *db){  sqlite3ConnectionUnlocked(db);  enterMutex();  removeFromBlockedList(db);  checkListProperties(db);  leaveMutex(); }
#endif
#ifndef _FTSINT_H
#define _FTSINT_H
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
# define NDEBUG 1
#endif
#ifdef SQLITE_OMIT_VIRTUALTABLE
# undef SQLITE_ENABLE_FTS3
# undef SQLITE_ENABLE_FTS4
#endif
#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)
# define SQLITE_ENABLE_FTS3
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#ifndef SQLITE_CORE
SQLITE_EXTENSION_INIT3
#endif
#ifndef _FTS3_TOKENIZER_H_
#define _FTS3_TOKENIZER_H_
typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module; typedef struct sqlite3_tokenizer sqlite3_tokenizer; typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor; struct sqlite3_tokenizer_module {  int iVersion;  int (*xCreate)(  int argc,  const char *const*argv,  sqlite3_tokenizer **ppTokenizer  );  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);  int (*xOpen)(  sqlite3_tokenizer *pTokenizer,  const char *pInput, int nBytes,  sqlite3_tokenizer_cursor **ppCursor  );  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);  int (*xNext)(  sqlite3_tokenizer_cursor *pCursor,  const char **ppToken, int *pnBytes,  int *piStartOffset,  int *piEndOffset,  int *piPosition  );  int (*xLanguageid)(sqlite3_tokenizer_cursor *pCsr, int iLangid); }; struct sqlite3_tokenizer {  const sqlite3_tokenizer_module *pModule; }; struct sqlite3_tokenizer_cursor {  sqlite3_tokenizer *pTokenizer; }; int fts3_global_term_cnt(int iTerm, int iCol); int fts3_term_cnt(int iTerm, int iCol);
#endif
#ifndef _FTS3_HASH_H_
#define _FTS3_HASH_H_
typedef struct Fts3Hash Fts3Hash; typedef struct Fts3HashElem Fts3HashElem; struct Fts3Hash {  char keyClass;  char copyKey;  int count;  Fts3HashElem *first;  int htsize;  struct _fts3ht {  int count;  Fts3HashElem *chain;  } *ht; }; struct Fts3HashElem {  Fts3HashElem *next, *prev;  void *data;  void *pKey; int nKey; };
#define FTS3_HASH_STRING 1
#define FTS3_HASH_BINARY 2
SQLITE_PRIVATE void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey); SQLITE_PRIVATE void *sqlite3Fts3HashInsert(Fts3Hash*, const void *pKey, int nKey, void *pData); SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash*, const void *pKey, int nKey); SQLITE_PRIVATE void sqlite3Fts3HashClear(Fts3Hash*); SQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(const Fts3Hash *, const void *, int);
#define fts3HashInit  sqlite3Fts3HashInit
#define fts3HashInsert  sqlite3Fts3HashInsert
#define fts3HashFind  sqlite3Fts3HashFind
#define fts3HashClear sqlite3Fts3HashClear
#define fts3HashFindElem sqlite3Fts3HashFindElem
#define fts3HashFirst(H) ((H)->first)
#define fts3HashNext(E)  ((E)->next)
#define fts3HashData(E)  ((E)->data)
#define fts3HashKey(E) ((E)->pKey)
#define fts3HashKeysize(E) ((E)->nKey)
#define fts3HashCount(H) ((H)->count)
#endif
#ifndef SQLITE_FTS3_MAX_EXPR_DEPTH
# define SQLITE_FTS3_MAX_EXPR_DEPTH 12
#endif
#define FTS3_MERGE_COUNT 16
#define FTS3_MAX_PENDING_DATA (1*1024*1024)
#define SizeofArray(X) ((int)(sizeof(X)/sizeof(X[0])))
#ifndef MIN
# define MIN(x,y) ((x)<(y)?(x):(y))
#endif
#ifndef MAX
# define MAX(x,y) ((x)>(y)?(x):(y))
#endif
#define FTS3_VARINT_MAX 10
#define FTS3_BUFFER_PADDING 8
#define FTS3_SEGDIR_MAXLEVEL 1024
#define FTS3_SEGDIR_MAXLEVEL_STR "1024"
#ifndef testcase
# define testcase(X)
#endif
#define POS_COLUMN (1)
#define POS_END  (0)
#ifdef SQLITE_DEBUG
SQLITE_API extern int sqlite3_fts3_may_be_corrupt;
# define assert_fts3_nc(x) assert(sqlite3_fts3_may_be_corrupt || (x))
#else
# define assert_fts3_nc(x) assert(x)
#endif
#ifndef SQLITE_AMALGAMATION
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1
#endif
#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)
# define ALWAYS(X) (1)
# define NEVER(X)  (0)
#elif !defined(NDEBUG)
# define ALWAYS(X) ((X)?1:(assert(0),0))
# define NEVER(X)  ((X)?(assert(0),1):0)
#else
# define ALWAYS(X) (X)
# define NEVER(X)  (X)
#endif
typedef unsigned char u8; typedef short int i16; typedef unsigned int u32; typedef sqlite3_uint64 u64; typedef sqlite3_int64 i64;
#define UNUSED_PARAMETER(x) (void)(x)
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
# define NDEBUG 1
#endif
#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
# define TESTONLY(X) X
#else
# define TESTONLY(X)
#endif
#define LARGEST_INT64 (0xffffffff|(((i64)0x7fffffff)<<32))
#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
#define deliberate_fall_through
#endif
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3Fts3Corrupt(void);
# define FTS_CORRUPT_VTAB sqlite3Fts3Corrupt()
#else
# define FTS_CORRUPT_VTAB SQLITE_CORRUPT_VTAB
#endif
typedef struct Fts3Table Fts3Table; typedef struct Fts3Cursor Fts3Cursor; typedef struct Fts3Expr Fts3Expr; typedef struct Fts3Phrase Fts3Phrase; typedef struct Fts3PhraseToken Fts3PhraseToken; typedef struct Fts3Doclist Fts3Doclist; typedef struct Fts3SegFilter Fts3SegFilter; typedef struct Fts3DeferredToken Fts3DeferredToken; typedef struct Fts3SegReader Fts3SegReader; typedef struct Fts3MultiSegReader Fts3MultiSegReader; typedef struct MatchinfoBuffer MatchinfoBuffer; struct Fts3Table {  sqlite3_vtab base;  sqlite3 *db;  const char *zDb;  const char *zName;  int nColumn;  char **azColumn;  u8 *abNotindexed;  sqlite3_tokenizer *pTokenizer;  char *zContentTbl;  char *zLanguageid;  int nAutoincrmerge;  u32 nLeafAdd;  int bLock;  sqlite3_stmt *aStmt[40];  sqlite3_stmt *pSeekStmt;  char *zReadExprlist;  char *zWriteExprlist;  int nNodeSize;  u8 bFts4;  u8 bHasStat;  u8 bHasDocsize;  u8 bDescIdx;  u8 bIgnoreSavepoint;  int nPgsz;  char *zSegmentsTbl;  sqlite3_blob *pSegments;  int nIndex;  struct Fts3Index {  int nPrefix;  Fts3Hash hPending;  } *aIndex;  int nMaxPendingData;  int nPendingData;  sqlite_int64 iPrevDocid;  int iPrevLangid;  int bPrevDelete;
#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)
 int inTransaction;  int mxSavepoint;
#endif
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 int bNoIncrDoclist;  int nMergeCount;
#endif
};
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
# define MergeCount(P) ((P)->nMergeCount)
#else
# define MergeCount(P) FTS3_MERGE_COUNT
#endif
struct Fts3Cursor {  sqlite3_vtab_cursor base;  i16 eSearch;  u8 isEof;  u8 isRequireSeek;  u8 bSeekStmt;  sqlite3_stmt *pStmt;  Fts3Expr *pExpr;  int iLangid;  int nPhrase;  Fts3DeferredToken *pDeferred;  sqlite3_int64 iPrevId;  char *pNextId;  char *aDoclist;  int nDoclist;  u8 bDesc;  int eEvalmode;  int nRowAvg;  sqlite3_int64 nDoc;  i64 iMinDocid;  i64 iMaxDocid;  int isMatchinfoNeeded;  MatchinfoBuffer *pMIBuffer; };
#define FTS3_EVAL_FILTER 0
#define FTS3_EVAL_NEXT 1
#define FTS3_EVAL_MATCHINFO 2
#define FTS3_FULLSCAN_SEARCH 0
#define FTS3_DOCID_SEARCH 1
#define FTS3_FULLTEXT_SEARCH 2
#define FTS3_HAVE_LANGID 0x00010000
#define FTS3_HAVE_DOCID_GE 0x00020000
#define FTS3_HAVE_DOCID_LE 0x00040000
struct Fts3Doclist {  char *aAll;  int nAll;  char *pNextDocid;  sqlite3_int64 iDocid;  int bFreeList;  char *pList;  int nList; }; struct Fts3PhraseToken {  char *z;  int n;  int isPrefix;  int bFirst;  Fts3DeferredToken *pDeferred;  Fts3MultiSegReader *pSegcsr; }; struct Fts3Phrase {  Fts3Doclist doclist;  int bIncr;  int iDoclistToken;  char *pOrPoslist;  i64 iOrDocid;  int nToken;  int iColumn;  Fts3PhraseToken aToken[1]; }; struct Fts3Expr {  int eType;  int nNear;  Fts3Expr *pParent;  Fts3Expr *pLeft;  Fts3Expr *pRight;  Fts3Phrase *pPhrase;  sqlite3_int64 iDocid;  u8 bEof;  u8 bStart;  u8 bDeferred;  int iPhrase;  u32 *aMI; };
#define FTSQUERY_NEAR  1
#define FTSQUERY_NOT 2
#define FTSQUERY_AND 3
#define FTSQUERY_OR  4
#define FTSQUERY_PHRASE 5
SQLITE_PRIVATE int sqlite3Fts3UpdateMethod(sqlite3_vtab*,int,sqlite3_value**,sqlite3_int64*); SQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush(Fts3Table *); SQLITE_PRIVATE void sqlite3Fts3PendingTermsClear(Fts3Table *); SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *); SQLITE_PRIVATE int sqlite3Fts3SegReaderNew(int, int, sqlite3_int64,  sqlite3_int64, sqlite3_int64, const char *, int, Fts3SegReader**); SQLITE_PRIVATE int sqlite3Fts3SegReaderPending(  Fts3Table*,int,const char*,int,int,Fts3SegReader**); SQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *); SQLITE_PRIVATE int sqlite3Fts3AllSegdirs(Fts3Table*, int, int, int, sqlite3_stmt **); SQLITE_PRIVATE int sqlite3Fts3ReadBlock(Fts3Table*, sqlite3_int64, char **, int*, int*); SQLITE_PRIVATE int sqlite3Fts3SelectDoctotal(Fts3Table *, sqlite3_stmt **); SQLITE_PRIVATE int sqlite3Fts3SelectDocsize(Fts3Table *, sqlite3_int64, sqlite3_stmt **);
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
SQLITE_PRIVATE void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *); SQLITE_PRIVATE int sqlite3Fts3DeferToken(Fts3Cursor *, Fts3PhraseToken *, int); SQLITE_PRIVATE int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *); SQLITE_PRIVATE void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *); SQLITE_PRIVATE int sqlite3Fts3DeferredTokenList(Fts3DeferredToken *, char **, int *);
#else
# define sqlite3Fts3FreeDeferredTokens(x)
# define sqlite3Fts3DeferToken(x,y,z) SQLITE_OK
# define sqlite3Fts3CacheDeferredDoclists(x) SQLITE_OK
# define sqlite3Fts3FreeDeferredDoclists(x)
# define sqlite3Fts3DeferredTokenList(x,y,z) SQLITE_OK
#endif
SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *); SQLITE_PRIVATE int sqlite3Fts3MaxLevel(Fts3Table *, int *);
#define FTS3_SEGCURSOR_PENDING -1
#define FTS3_SEGCURSOR_ALL -2
SQLITE_PRIVATE int sqlite3Fts3SegReaderStart(Fts3Table*, Fts3MultiSegReader*, Fts3SegFilter*); SQLITE_PRIVATE int sqlite3Fts3SegReaderStep(Fts3Table *, Fts3MultiSegReader *); SQLITE_PRIVATE void sqlite3Fts3SegReaderFinish(Fts3MultiSegReader *); SQLITE_PRIVATE int sqlite3Fts3SegReaderCursor(Fts3Table *,  int, int, int, const char *, int, int, int, Fts3MultiSegReader *);
#define FTS3_SEGMENT_REQUIRE_POS  0x00000001
#define FTS3_SEGMENT_IGNORE_EMPTY 0x00000002
#define FTS3_SEGMENT_COLUMN_FILTER 0x00000004
#define FTS3_SEGMENT_PREFIX 0x00000008
#define FTS3_SEGMENT_SCAN 0x00000010
#define FTS3_SEGMENT_FIRST  0x00000020
struct Fts3SegFilter {  const char *zTerm;  int nTerm;  int iCol;  int flags; }; struct Fts3MultiSegReader {  Fts3SegReader **apSegment;  int nSegment;  int nAdvance;  Fts3SegFilter *pFilter;  char *aBuffer;  int nBuffer;  int iColFilter;  int bRestart;  int nCost;  int bLookup;  char *zTerm;  int nTerm;  char *aDoclist;  int nDoclist; }; SQLITE_PRIVATE int sqlite3Fts3Incrmerge(Fts3Table*,int,int);
#define fts3GetVarint32(p, piVal) (   (*(u8*)(p)&0x80) ? sqlite3Fts3GetVarint32(p, piVal) : (*piVal=*(u8*)(p), 1) )

SQLITE_PRIVATE void sqlite3Fts3ErrMsg(char**,const char*,...); SQLITE_PRIVATE int sqlite3Fts3PutVarint(char *, sqlite3_int64); SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *, sqlite_int64 *); SQLITE_PRIVATE int sqlite3Fts3GetVarintU(const char *, sqlite_uint64 *); SQLITE_PRIVATE int sqlite3Fts3GetVarintBounded(const char*,const char*,sqlite3_int64*); SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *, int *); SQLITE_PRIVATE int sqlite3Fts3VarintLen(sqlite3_uint64); SQLITE_PRIVATE void sqlite3Fts3Dequote(char *); SQLITE_PRIVATE void sqlite3Fts3DoclistPrev(int,char*,int,char**,sqlite3_int64*,int*,u8*); SQLITE_PRIVATE int sqlite3Fts3EvalPhraseStats(Fts3Cursor *, Fts3Expr *, u32 *); SQLITE_PRIVATE int sqlite3Fts3FirstFilter(sqlite3_int64, char *, int, char *); SQLITE_PRIVATE void sqlite3Fts3CreateStatTable(int*, Fts3Table*); SQLITE_PRIVATE int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc); SQLITE_PRIVATE int sqlite3Fts3ReadInt(const char *z, int *pnOut); SQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *, int *); SQLITE_PRIVATE int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *); SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *,  sqlite3_tokenizer **, char ** ); SQLITE_PRIVATE int sqlite3Fts3IsIdChar(char); SQLITE_PRIVATE void sqlite3Fts3Offsets(sqlite3_context*, Fts3Cursor*); SQLITE_PRIVATE void sqlite3Fts3Snippet(sqlite3_context *, Fts3Cursor *, const char *,  const char *, const char *, int, int ); SQLITE_PRIVATE void sqlite3Fts3Matchinfo(sqlite3_context *, Fts3Cursor *, const char *); SQLITE_PRIVATE void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p); SQLITE_PRIVATE int sqlite3Fts3ExprParse(sqlite3_tokenizer *, int,  char **, int, int, int, const char *, int, Fts3Expr **, char ** ); SQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *);
#ifdef SQLITE_TEST
SQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface(sqlite3 *db, Fts3Hash*); SQLITE_PRIVATE int sqlite3Fts3InitTerm(sqlite3 *db);
#endif
SQLITE_PRIVATE void *sqlite3Fts3MallocZero(i64 nByte); SQLITE_PRIVATE int sqlite3Fts3OpenTokenizer(sqlite3_tokenizer *, int, const char *, int,  sqlite3_tokenizer_cursor ** ); SQLITE_PRIVATE int sqlite3Fts3InitAux(sqlite3 *db); SQLITE_PRIVATE void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *); SQLITE_PRIVATE int sqlite3Fts3MsrIncrStart(  Fts3Table*, Fts3MultiSegReader*, int, const char*, int); SQLITE_PRIVATE int sqlite3Fts3MsrIncrNext(  Fts3Table *, Fts3MultiSegReader *, sqlite3_int64 *, char **, int *); SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(Fts3Cursor *, Fts3Expr *, int iCol, char **); SQLITE_PRIVATE int sqlite3Fts3MsrOvfl(Fts3Cursor *, Fts3MultiSegReader *, int *); SQLITE_PRIVATE int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr); SQLITE_PRIVATE int sqlite3Fts3InitTok(sqlite3*, Fts3Hash *);
#ifndef SQLITE_DISABLE_FTS3_UNICODE
SQLITE_PRIVATE int sqlite3FtsUnicodeFold(int, int); SQLITE_PRIVATE int sqlite3FtsUnicodeIsalnum(int); SQLITE_PRIVATE int sqlite3FtsUnicodeIsdiacritic(int);
#endif
#endif
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#if defined(SQLITE_ENABLE_FTS3) && !defined(SQLITE_CORE)
# define SQLITE_CORE 1
#endif
#ifndef SQLITE_CORE
 SQLITE_EXTENSION_INIT1
#endif
static int fts3EvalNext(Fts3Cursor *pCsr); static int fts3EvalStart(Fts3Cursor *pCsr); static int fts3TermSegReaderCursor(  Fts3Cursor *, const char *, int, int, Fts3MultiSegReader **);
#ifdef SQLITE_DEBUG
SQLITE_API int sqlite3_fts3_may_be_corrupt = 1;
#endif
SQLITE_PRIVATE int sqlite3Fts3PutVarint(char *p, sqlite_int64 v){  unsigned char *q = (unsigned char *) p;  sqlite_uint64 vu = v;  do{  *q++ = (unsigned char) ((vu & 0x7f) | 0x80);  vu >>= 7;  }while( vu!=0 );  q[-1] &= 0x7f;  assert( q - (unsigned char *)p <= FTS3_VARINT_MAX );  return (int) (q - (unsigned char *)p); }
#define GETVARINT_STEP(v, ptr, shift, mask1, mask2, var, ret)  v = (v & mask1) | ( (*(const unsigned char*)(ptr++)) << shift );  if( (v & mask2)==0 ){ var = v; return ret; }

#define GETVARINT_INIT(v, ptr, shift, mask1, mask2, var, ret)  v = (*ptr++);   if( (v & mask2)==0 ){ var = v; return ret; }

SQLITE_PRIVATE int sqlite3Fts3GetVarintU(const char *pBuf, sqlite_uint64 *v){  const unsigned char *p = (const unsigned char*)pBuf;  const unsigned char *pStart = p;  u32 a;  u64 b;  int shift;  GETVARINT_INIT(a, p, 0, 0x00, 0x80, *v, 1);  GETVARINT_STEP(a, p, 7, 0x7F, 0x4000, *v, 2);  GETVARINT_STEP(a, p, 14, 0x3FFF, 0x200000, *v, 3);  GETVARINT_STEP(a, p, 21, 0x1FFFFF, 0x10000000, *v, 4);  b = (a & 0x0FFFFFFF );  for(shift=28; shift<=63; shift+=7){  u64 c = *p++;  b += (c&0x7F) << shift;  if( (c & 0x80)==0 ) break;  }  *v = b;  return (int)(p - pStart); } SQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *pBuf, sqlite_int64 *v){  return sqlite3Fts3GetVarintU(pBuf, (sqlite3_uint64*)v); } SQLITE_PRIVATE int sqlite3Fts3GetVarintBounded(  const char *pBuf,  const char *pEnd,  sqlite_int64 *v ){  const unsigned char *p = (const unsigned char*)pBuf;  const unsigned char *pStart = p;  const unsigned char *pX = (const unsigned char*)pEnd;  u64 b = 0;  int shift;  for(shift=0; shift<=63; shift+=7){  u64 c = p<pX ? *p : 0;  p++;  b += (c&0x7F) << shift;  if( (c & 0x80)==0 ) break;  }  *v = b;  return (int)(p - pStart); } SQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *p, int *pi){  const unsigned char *ptr = (const unsigned char*)p;  u32 a;
#ifndef fts3GetVarint32
 GETVARINT_INIT(a, ptr, 0, 0x00, 0x80, *pi, 1);
#else
 a = (*ptr++);  assert( a & 0x80 );
#endif
 GETVARINT_STEP(a, ptr, 7, 0x7F, 0x4000, *pi, 2);  GETVARINT_STEP(a, ptr, 14, 0x3FFF, 0x200000, *pi, 3);  GETVARINT_STEP(a, ptr, 21, 0x1FFFFF, 0x10000000, *pi, 4);  a = (a & 0x0FFFFFFF );  *pi = (int)(a | ((u32)(*ptr & 0x07) << 28));  assert( 0==(a & 0x80000000) );  assert( *pi>=0 );  return 5; } SQLITE_PRIVATE int sqlite3Fts3VarintLen(sqlite3_uint64 v){  int i = 0;  do{  i++;  v >>= 7;  }while( v!=0 );  return i; } SQLITE_PRIVATE void sqlite3Fts3Dequote(char *z){  char quote;  quote = z[0];  if( quote=='[' || quote=='\'' || quote=='"' || quote=='`' ){  int iIn = 1;  int iOut = 0;  if( quote=='[' ) quote = ']';  while( z[iIn] ){  if( z[iIn]==quote ){  if( z[iIn+1]!=quote ) break;  z[iOut++] = quote;  iIn += 2;  }else{  z[iOut++] = z[iIn++];  }  }  z[iOut] = '\0';  } } static void fts3GetDeltaVarint(char **pp, sqlite3_int64 *pVal){  sqlite3_int64 iVal;  *pp += sqlite3Fts3GetVarint(*pp, &iVal);  *pVal += iVal; } static void fts3GetReverseVarint(  char **pp,  char *pStart,  sqlite3_int64 *pVal ){  sqlite3_int64 iVal;  char *p;  for(p = (*pp)-2; p>=pStart && *p&0x80; p--);  p++;  *pp = p;  sqlite3Fts3GetVarint(p, &iVal);  *pVal = iVal; } static int fts3DisconnectMethod(sqlite3_vtab *pVtab){  Fts3Table *p = (Fts3Table *)pVtab;  int i;  assert( p->nPendingData==0 );  assert( p->pSegments==0 );  sqlite3_finalize(p->pSeekStmt);  for(i=0; i<SizeofArray(p->aStmt); i++){  sqlite3_finalize(p->aStmt[i]);  }  sqlite3_free(p->zSegmentsTbl);  sqlite3_free(p->zReadExprlist);  sqlite3_free(p->zWriteExprlist);  sqlite3_free(p->zContentTbl);  sqlite3_free(p->zLanguageid);  p->pTokenizer->pModule->xDestroy(p->pTokenizer);  sqlite3_free(p);  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3Fts3ErrMsg(char **pzErr, const char *zFormat, ...){  va_list ap;  sqlite3_free(*pzErr);  va_start(ap, zFormat);  *pzErr = sqlite3_vmprintf(zFormat, ap);  va_end(ap); } static void fts3DbExec(  int *pRc,  sqlite3 *db,  const char *zFormat,  ... ){  va_list ap;  char *zSql;  if( *pRc ) return;  va_start(ap, zFormat);  zSql = sqlite3_vmprintf(zFormat, ap);  va_end(ap);  if( zSql==0 ){  *pRc = SQLITE_NOMEM;  }else{  *pRc = sqlite3_exec(db, zSql, 0, 0, 0);  sqlite3_free(zSql);  } } static int fts3DestroyMethod(sqlite3_vtab *pVtab){  Fts3Table *p = (Fts3Table *)pVtab;  int rc = SQLITE_OK;  const char *zDb = p->zDb;  sqlite3 *db = p->db;  fts3DbExec(&rc, db,  "DROP TABLE IF EXISTS %Q.'%q_segments';"  "DROP TABLE IF EXISTS %Q.'%q_segdir';"  "DROP TABLE IF EXISTS %Q.'%q_docsize';"  "DROP TABLE IF EXISTS %Q.'%q_stat';"  "%s DROP TABLE IF EXISTS %Q.'%q_content';",  zDb, p->zName,  zDb, p->zName,  zDb, p->zName,  zDb, p->zName,  (p->zContentTbl ? "--" : ""), zDb,p->zName  );  return (rc==SQLITE_OK ? fts3DisconnectMethod(pVtab) : rc); } static void fts3DeclareVtab(int *pRc, Fts3Table *p){  if( *pRc==SQLITE_OK ){  int i;  int rc;  char *zSql;  char *zCols;  const char *zLanguageid;  zLanguageid = (p->zLanguageid ? p->zLanguageid : "__langid");  sqlite3_vtab_config(p->db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);  zCols = sqlite3_mprintf("%Q, ", p->azColumn[0]);  for(i=1; zCols && i<p->nColumn; i++){  zCols = sqlite3_mprintf("%z%Q, ", zCols, p->azColumn[i]);  }  zSql = sqlite3_mprintf(  "CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN, %Q HIDDEN)",  zCols, p->zName, zLanguageid  );  if( !zCols || !zSql ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_declare_vtab(p->db, zSql);  }  sqlite3_free(zSql);  sqlite3_free(zCols);  *pRc = rc;  } } SQLITE_PRIVATE void sqlite3Fts3CreateStatTable(int *pRc, Fts3Table *p){  fts3DbExec(pRc, p->db,  "CREATE TABLE IF NOT EXISTS %Q.'%q_stat'"  "(id INTEGER PRIMARY KEY, value BLOB);",  p->zDb, p->zName  );  if( (*pRc)==SQLITE_OK ) p->bHasStat = 1; } static int fts3CreateTables(Fts3Table *p){  int rc = SQLITE_OK;  int i;  sqlite3 *db = p->db;  if( p->zContentTbl==0 ){  const char *zLanguageid = p->zLanguageid;  char *zContentCols;  zContentCols = sqlite3_mprintf("docid INTEGER PRIMARY KEY");  for(i=0; zContentCols && i<p->nColumn; i++){  char *z = p->azColumn[i];  zContentCols = sqlite3_mprintf("%z, 'c%d%q'", zContentCols, i, z);  }  if( zLanguageid && zContentCols ){  zContentCols = sqlite3_mprintf("%z, langid", zContentCols, zLanguageid);  }  if( zContentCols==0 ) rc = SQLITE_NOMEM;  fts3DbExec(&rc, db,   "CREATE TABLE %Q.'%q_content'(%s)",   p->zDb, p->zName, zContentCols  );  sqlite3_free(zContentCols);  }  fts3DbExec(&rc, db,  "CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);",  p->zDb, p->zName  );  fts3DbExec(&rc, db,  "CREATE TABLE %Q.'%q_segdir'("  "level INTEGER,"  "idx INTEGER,"  "start_block INTEGER,"  "leaves_end_block INTEGER,"  "end_block INTEGER,"  "root BLOB,"  "PRIMARY KEY(level, idx)"  ");",  p->zDb, p->zName  );  if( p->bHasDocsize ){  fts3DbExec(&rc, db,  "CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);",  p->zDb, p->zName  );  }  assert( p->bHasStat==p->bFts4 );  if( p->bHasStat ){  sqlite3Fts3CreateStatTable(&rc, p);  }  return rc; } static void fts3DatabasePageSize(int *pRc, Fts3Table *p){  if( *pRc==SQLITE_OK ){  int rc;  char *zSql;  sqlite3_stmt *pStmt;  zSql = sqlite3_mprintf("PRAGMA %Q.page_size", p->zDb);  if( !zSql ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_step(pStmt);  p->nPgsz = sqlite3_column_int(pStmt, 0);  rc = sqlite3_finalize(pStmt);  }else if( rc==SQLITE_AUTH ){  p->nPgsz = 1024;  rc = SQLITE_OK;  }  }  assert( p->nPgsz>0 || rc!=SQLITE_OK );  sqlite3_free(zSql);  *pRc = rc;  } } static int fts3IsSpecialColumn(  const char *z,  int *pnKey,  char **pzValue ){  char *zValue;  const char *zCsr = z;  while( *zCsr!='=' ){  if( *zCsr=='\0' ) return 0;  zCsr++;  }  *pnKey = (int)(zCsr-z);  zValue = sqlite3_mprintf("%s", &zCsr[1]);  if( zValue ){  sqlite3Fts3Dequote(zValue);  }  *pzValue = zValue;  return 1; } static void fts3Appendf(  int *pRc,  char **pz,  const char *zFormat,  ... ){  if( *pRc==SQLITE_OK ){  va_list ap;  char *z;  va_start(ap, zFormat);  z = sqlite3_vmprintf(zFormat, ap);  va_end(ap);  if( z && *pz ){  char *z2 = sqlite3_mprintf("%s%s", *pz, z);  sqlite3_free(z);  z = z2;  }  if( z==0 ) *pRc = SQLITE_NOMEM;  sqlite3_free(*pz);  *pz = z;  } } static char *fts3QuoteId(char const *zInput){  sqlite3_int64 nRet;  char *zRet;  nRet = 2 + (int)strlen(zInput)*2 + 1;  zRet = sqlite3_malloc64(nRet);  if( zRet ){  int i;  char *z = zRet;  *(z++) = '"';  for(i=0; zInput[i]; i++){  if( zInput[i]=='"' ) *(z++) = '"';  *(z++) = zInput[i];  }  *(z++) = '"';  *(z++) = '\0';  }  return zRet; } static char *fts3ReadExprList(Fts3Table *p, const char *zFunc, int *pRc){  char *zRet = 0;  char *zFree = 0;  char *zFunction;  int i;  if( p->zContentTbl==0 ){  if( !zFunc ){  zFunction = "";  }else{  zFree = zFunction = fts3QuoteId(zFunc);  }  fts3Appendf(pRc, &zRet, "docid");  for(i=0; i<p->nColumn; i++){  fts3Appendf(pRc, &zRet, ",%s(x.'c%d%q')", zFunction, i, p->azColumn[i]);  }  if( p->zLanguageid ){  fts3Appendf(pRc, &zRet, ", x.%Q", "langid");  }  sqlite3_free(zFree);  }else{  fts3Appendf(pRc, &zRet, "rowid");  for(i=0; i<p->nColumn; i++){  fts3Appendf(pRc, &zRet, ", x.'%q'", p->azColumn[i]);  }  if( p->zLanguageid ){  fts3Appendf(pRc, &zRet, ", x.%Q", p->zLanguageid);  }  }  fts3Appendf(pRc, &zRet, " FROM '%q'.'%q%s' AS x",  p->zDb,  (p->zContentTbl ? p->zContentTbl : p->zName),  (p->zContentTbl ? "" : "_content")  );  return zRet; } static char *fts3WriteExprList(Fts3Table *p, const char *zFunc, int *pRc){  char *zRet = 0;  char *zFree = 0;  char *zFunction;  int i;  if( !zFunc ){  zFunction = "";  }else{  zFree = zFunction = fts3QuoteId(zFunc);  }  fts3Appendf(pRc, &zRet, "?");  for(i=0; i<p->nColumn; i++){  fts3Appendf(pRc, &zRet, ",%s(?)", zFunction);  }  if( p->zLanguageid ){  fts3Appendf(pRc, &zRet, ", ?");  }  sqlite3_free(zFree);  return zRet; } SQLITE_PRIVATE int sqlite3Fts3ReadInt(const char *z, int *pnOut){  u64 iVal = 0;  int i;  for(i=0; z[i]>='0' && z[i]<='9'; i++){  iVal = iVal*10 + (z[i] - '0');  if( iVal>0x7FFFFFFF ) return -1;  }  *pnOut = (int)iVal;  return i; } static int fts3GobbleInt(const char **pp, int *pnOut){  const int MAX_NPREFIX = 10000000;  int nInt = 0;  int nByte;  nByte = sqlite3Fts3ReadInt(*pp, &nInt);  if( nInt>MAX_NPREFIX ){  nInt = 0;  }  if( nByte==0 ){  return SQLITE_ERROR;  }  *pnOut = nInt;  *pp += nByte;  return SQLITE_OK; } static int fts3PrefixParameter(  const char *zParam,  int *pnIndex,  struct Fts3Index **apIndex ){  struct Fts3Index *aIndex;  int nIndex = 1;  if( zParam && zParam[0] ){  const char *p;  nIndex++;  for(p=zParam; *p; p++){  if( *p==',' ) nIndex++;  }  }  aIndex = sqlite3_malloc64(sizeof(struct Fts3Index) * nIndex);  *apIndex = aIndex;  if( !aIndex ){  return SQLITE_NOMEM;  }  memset(aIndex, 0, sizeof(struct Fts3Index) * nIndex);  if( zParam ){  const char *p = zParam;  int i;  for(i=1; i<nIndex; i++){  int nPrefix = 0;  if( fts3GobbleInt(&p, &nPrefix) ) return SQLITE_ERROR;  assert( nPrefix>=0 );  if( nPrefix==0 ){  nIndex--;  i--;  }else{  aIndex[i].nPrefix = nPrefix;  }  p++;  }  }  *pnIndex = nIndex;  return SQLITE_OK; } static int fts3ContentColumns(  sqlite3 *db,  const char *zDb,  const char *zTbl,  const char ***pazCol,  int *pnCol,  int *pnStr,  char **pzErr ){  int rc = SQLITE_OK;  char *zSql;  sqlite3_stmt *pStmt = 0;  zSql = sqlite3_mprintf("SELECT * FROM %Q.%Q", zDb, zTbl);  if( !zSql ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);  if( rc!=SQLITE_OK ){  sqlite3Fts3ErrMsg(pzErr, "%s", sqlite3_errmsg(db));  }  }  sqlite3_free(zSql);  if( rc==SQLITE_OK ){  const char **azCol;  sqlite3_int64 nStr = 0;  int nCol;  int i;  nCol = sqlite3_column_count(pStmt);  for(i=0; i<nCol; i++){  const char *zCol = sqlite3_column_name(pStmt, i);  nStr += strlen(zCol) + 1;  }  azCol = (const char **)sqlite3_malloc64(sizeof(char *) * nCol + nStr);  if( azCol==0 ){  rc = SQLITE_NOMEM;  }else{  char *p = (char *)&azCol[nCol];  for(i=0; i<nCol; i++){  const char *zCol = sqlite3_column_name(pStmt, i);  int n = (int)strlen(zCol)+1;  memcpy(p, zCol, n);  azCol[i] = p;  p += n;  }  }  sqlite3_finalize(pStmt);  *pnCol = nCol;  *pnStr = nStr;  *pazCol = azCol;  }  return rc; } static int fts3InitVtab(  int isCreate,  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVTab,  char **pzErr ){  Fts3Hash *pHash = (Fts3Hash *)pAux;  Fts3Table *p = 0;  int rc = SQLITE_OK;  int i;  sqlite3_int64 nByte;  int iCol;  int nString = 0;  int nCol = 0;  char *zCsr;  int nDb;  int nName;  int isFts4 = (argv[0][3]=='4');  const char **aCol;  sqlite3_tokenizer *pTokenizer = 0;  int nIndex = 0;  struct Fts3Index *aIndex = 0;  int bNoDocsize = 0;  int bDescIdx = 0;  char *zPrefix = 0;  char *zCompress = 0;  char *zUncompress = 0;  char *zContent = 0;  char *zLanguageid = 0;  char **azNotindexed = 0;  int nNotindexed = 0;  assert( strlen(argv[0])==4 );  assert( (sqlite3_strnicmp(argv[0], "fts4", 4)==0 && isFts4)   || (sqlite3_strnicmp(argv[0], "fts3", 4)==0 && !isFts4)  );  nDb = (int)strlen(argv[1]) + 1;  nName = (int)strlen(argv[2]) + 1;  nByte = sizeof(const char *) * (argc-2);  aCol = (const char **)sqlite3_malloc64(nByte);  if( aCol ){  memset((void*)aCol, 0, nByte);  azNotindexed = (char **)sqlite3_malloc64(nByte);  }  if( azNotindexed ){  memset(azNotindexed, 0, nByte);  }  if( !aCol || !azNotindexed ){  rc = SQLITE_NOMEM;  goto fts3_init_out;  }  for(i=3; rc==SQLITE_OK && i<argc; i++){  char const *z = argv[i];  int nKey;  char *zVal;  if( !pTokenizer   && strlen(z)>8   && 0==sqlite3_strnicmp(z, "tokenize", 8)   && 0==sqlite3Fts3IsIdChar(z[8])  ){  rc = sqlite3Fts3InitTokenizer(pHash, &z[9], &pTokenizer, pzErr);  }  else if( isFts4 && fts3IsSpecialColumn(z, &nKey, &zVal) ){  struct Fts4Option {  const char *zOpt;  int nOpt;  } aFts4Opt[] = {  { "matchinfo", 9 },  { "prefix", 6 },  { "compress", 8 },  { "uncompress", 10 },  { "order", 5 },  { "content", 7 },  { "languageid", 10 },  { "notindexed", 10 }  };  int iOpt;  if( !zVal ){  rc = SQLITE_NOMEM;  }else{  for(iOpt=0; iOpt<SizeofArray(aFts4Opt); iOpt++){  struct Fts4Option *pOp = &aFts4Opt[iOpt];  if( nKey==pOp->nOpt && !sqlite3_strnicmp(z, pOp->zOpt, pOp->nOpt) ){  break;  }  }  switch( iOpt ){  case 0:  if( strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "fts3", 4) ){  sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo: %s", zVal);  rc = SQLITE_ERROR;  }  bNoDocsize = 1;  break;  case 1:  sqlite3_free(zPrefix);  zPrefix = zVal;  zVal = 0;  break;  case 2:  sqlite3_free(zCompress);  zCompress = zVal;  zVal = 0;  break;  case 3:  sqlite3_free(zUncompress);  zUncompress = zVal;  zVal = 0;  break;  case 4:  if( (strlen(zVal)!=3 || sqlite3_strnicmp(zVal, "asc", 3))   && (strlen(zVal)!=4 || sqlite3_strnicmp(zVal, "desc", 4))  ){  sqlite3Fts3ErrMsg(pzErr, "unrecognized order: %s", zVal);  rc = SQLITE_ERROR;  }  bDescIdx = (zVal[0]=='d' || zVal[0]=='D');  break;  case 5:  sqlite3_free(zContent);  zContent = zVal;  zVal = 0;  break;  case 6:  assert( iOpt==6 );  sqlite3_free(zLanguageid);  zLanguageid = zVal;  zVal = 0;  break;  case 7:  azNotindexed[nNotindexed++] = zVal;  zVal = 0;  break;  default:  assert( iOpt==SizeofArray(aFts4Opt) );  sqlite3Fts3ErrMsg(pzErr, "unrecognized parameter: %s", z);  rc = SQLITE_ERROR;  break;  }  sqlite3_free(zVal);  }  }  else {  nString += (int)(strlen(z) + 1);  aCol[nCol++] = z;  }  }  if( rc==SQLITE_OK && zContent ){  sqlite3_free(zCompress);  sqlite3_free(zUncompress);  zCompress = 0;  zUncompress = 0;  if( nCol==0 ){  sqlite3_free((void*)aCol);  aCol = 0;  rc = fts3ContentColumns(db, argv[1], zContent,&aCol,&nCol,&nString,pzErr);  if( rc==SQLITE_OK && zLanguageid ){  int j;  for(j=0; j<nCol; j++){  if( sqlite3_stricmp(zLanguageid, aCol[j])==0 ){  int k;  for(k=j; k<nCol; k++) aCol[k] = aCol[k+1];  nCol--;  break;  }  }  }  }  }  if( rc!=SQLITE_OK ) goto fts3_init_out;  if( nCol==0 ){  assert( nString==0 );  aCol[0] = "content";  nString = 8;  nCol = 1;  }  if( pTokenizer==0 ){  rc = sqlite3Fts3InitTokenizer(pHash, "simple", &pTokenizer, pzErr);  if( rc!=SQLITE_OK ) goto fts3_init_out;  }  assert( pTokenizer );  rc = fts3PrefixParameter(zPrefix, &nIndex, &aIndex);  if( rc==SQLITE_ERROR ){  assert( zPrefix );  sqlite3Fts3ErrMsg(pzErr, "error parsing prefix parameter: %s", zPrefix);  }  if( rc!=SQLITE_OK ) goto fts3_init_out;  nByte = sizeof(Fts3Table) +  nCol * sizeof(char *) +  nIndex * sizeof(struct Fts3Index) +  nCol * sizeof(u8) +  nName +  nDb +  nString;  p = (Fts3Table*)sqlite3_malloc64(nByte);  if( p==0 ){  rc = SQLITE_NOMEM;  goto fts3_init_out;  }  memset(p, 0, nByte);  p->db = db;  p->nColumn = nCol;  p->nPendingData = 0;  p->azColumn = (char **)&p[1];  p->pTokenizer = pTokenizer;  p->nMaxPendingData = FTS3_MAX_PENDING_DATA;  p->bHasDocsize = (isFts4 && bNoDocsize==0);  p->bHasStat = (u8)isFts4;  p->bFts4 = (u8)isFts4;  p->bDescIdx = (u8)bDescIdx;  p->nAutoincrmerge = 0xff;  p->zContentTbl = zContent;  p->zLanguageid = zLanguageid;  zContent = 0;  zLanguageid = 0;  TESTONLY( p->inTransaction = -1 );  TESTONLY( p->mxSavepoint = -1 );  p->aIndex = (struct Fts3Index *)&p->azColumn[nCol];  memcpy(p->aIndex, aIndex, sizeof(struct Fts3Index) * nIndex);  p->nIndex = nIndex;  for(i=0; i<nIndex; i++){  fts3HashInit(&p->aIndex[i].hPending, FTS3_HASH_STRING, 1);  }  p->abNotindexed = (u8 *)&p->aIndex[nIndex];  zCsr = (char *)&p->abNotindexed[nCol];  p->zName = zCsr;  memcpy(zCsr, argv[2], nName);  zCsr += nName;  p->zDb = zCsr;  memcpy(zCsr, argv[1], nDb);  zCsr += nDb;  for(iCol=0; iCol<nCol; iCol++){  char *z;  int n = 0;  z = (char *)sqlite3Fts3NextToken(aCol[iCol], &n);  if( n>0 ){  memcpy(zCsr, z, n);  }  zCsr[n] = '\0';  sqlite3Fts3Dequote(zCsr);  p->azColumn[iCol] = zCsr;  zCsr += n+1;  assert( zCsr <= &((char *)p)[nByte] );  }  for(iCol=0; iCol<nCol; iCol++){  int n = (int)strlen(p->azColumn[iCol]);  for(i=0; i<nNotindexed; i++){  char *zNot = azNotindexed[i];  if( zNot && n==(int)strlen(zNot)   && 0==sqlite3_strnicmp(p->azColumn[iCol], zNot, n)  ){  p->abNotindexed[iCol] = 1;  sqlite3_free(zNot);  azNotindexed[i] = 0;  }  }  }  for(i=0; i<nNotindexed; i++){  if( azNotindexed[i] ){  sqlite3Fts3ErrMsg(pzErr, "no such column: %s", azNotindexed[i]);  rc = SQLITE_ERROR;  }  }  if( rc==SQLITE_OK && (zCompress==0)!=(zUncompress==0) ){  char const *zMiss = (zCompress==0 ? "compress" : "uncompress");  rc = SQLITE_ERROR;  sqlite3Fts3ErrMsg(pzErr, "missing %s parameter in fts4 constructor", zMiss);  }  p->zReadExprlist = fts3ReadExprList(p, zUncompress, &rc);  p->zWriteExprlist = fts3WriteExprList(p, zCompress, &rc);  if( rc!=SQLITE_OK ) goto fts3_init_out;  if( isCreate ){  rc = fts3CreateTables(p);  }  if( !isFts4 && !isCreate ){  p->bHasStat = 2;  }  fts3DatabasePageSize(&rc, p);  p->nNodeSize = p->nPgsz-35;
#if defined(SQLITE_DEBUG)||defined(SQLITE_TEST)
 p->nMergeCount = FTS3_MERGE_COUNT;
#endif
 fts3DeclareVtab(&rc, p); fts3_init_out:  sqlite3_free(zPrefix);  sqlite3_free(aIndex);  sqlite3_free(zCompress);  sqlite3_free(zUncompress);  sqlite3_free(zContent);  sqlite3_free(zLanguageid);  for(i=0; i<nNotindexed; i++) sqlite3_free(azNotindexed[i]);  sqlite3_free((void *)aCol);  sqlite3_free((void *)azNotindexed);  if( rc!=SQLITE_OK ){  if( p ){  fts3DisconnectMethod((sqlite3_vtab *)p);  }else if( pTokenizer ){  pTokenizer->pModule->xDestroy(pTokenizer);  }  }else{  assert( p->pSegments==0 );  *ppVTab = &p->base;  }  return rc; } static int fts3ConnectMethod(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr); } static int fts3CreateMethod(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return fts3InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr); } static void fts3SetEstimatedRows(sqlite3_index_info *pIdxInfo, i64 nRow){
#if SQLITE_VERSION_NUMBER>=3008002
 if( sqlite3_libversion_number()>=3008002 ){  pIdxInfo->estimatedRows = nRow;  }
#endif
} static void fts3SetUniqueFlag(sqlite3_index_info *pIdxInfo){
#if SQLITE_VERSION_NUMBER>=3008012
 if( sqlite3_libversion_number()>=3008012 ){  pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_UNIQUE;  }
#endif
} static int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){  Fts3Table *p = (Fts3Table *)pVTab;  int i;  int iCons = -1;  int iLangidCons = -1;  int iDocidGe = -1;  int iDocidLe = -1;  int iIdx;  if( p->bLock ){  return SQLITE_ERROR;  }  pInfo->idxNum = FTS3_FULLSCAN_SEARCH;  pInfo->estimatedCost = 5000000;  for(i=0; i<pInfo->nConstraint; i++){  int bDocid;  struct sqlite3_index_constraint *pCons = &pInfo->aConstraint[i];  if( pCons->usable==0 ){  if( pCons->op==SQLITE_INDEX_CONSTRAINT_MATCH ){  pInfo->idxNum = FTS3_FULLSCAN_SEARCH;  pInfo->estimatedCost = 1e50;  fts3SetEstimatedRows(pInfo, ((sqlite3_int64)1) << 50);  return SQLITE_OK;  }  continue;  }  bDocid = (pCons->iColumn<0 || pCons->iColumn==p->nColumn+1);  if( iCons<0 && pCons->op==SQLITE_INDEX_CONSTRAINT_EQ && bDocid ){  pInfo->idxNum = FTS3_DOCID_SEARCH;  pInfo->estimatedCost = 1.0;  iCons = i;  }  if( pCons->op==SQLITE_INDEX_CONSTRAINT_MATCH   && pCons->iColumn>=0 && pCons->iColumn<=p->nColumn  ){  pInfo->idxNum = FTS3_FULLTEXT_SEARCH + pCons->iColumn;  pInfo->estimatedCost = 2.0;  iCons = i;  }  if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ   && pCons->iColumn==p->nColumn + 2  ){  iLangidCons = i;  }  if( bDocid ){  switch( pCons->op ){  case SQLITE_INDEX_CONSTRAINT_GE:  case SQLITE_INDEX_CONSTRAINT_GT:  iDocidGe = i;  break;  case SQLITE_INDEX_CONSTRAINT_LE:  case SQLITE_INDEX_CONSTRAINT_LT:  iDocidLe = i;  break;  }  }  }  if( pInfo->idxNum==FTS3_DOCID_SEARCH ) fts3SetUniqueFlag(pInfo);  iIdx = 1;  if( iCons>=0 ){  pInfo->aConstraintUsage[iCons].argvIndex = iIdx++;  pInfo->aConstraintUsage[iCons].omit = 1;  }  if( iLangidCons>=0 ){  pInfo->idxNum |= FTS3_HAVE_LANGID;  pInfo->aConstraintUsage[iLangidCons].argvIndex = iIdx++;  }  if( iDocidGe>=0 ){  pInfo->idxNum |= FTS3_HAVE_DOCID_GE;  pInfo->aConstraintUsage[iDocidGe].argvIndex = iIdx++;  }  if( iDocidLe>=0 ){  pInfo->idxNum |= FTS3_HAVE_DOCID_LE;  pInfo->aConstraintUsage[iDocidLe].argvIndex = iIdx++;  }  if( pInfo->nOrderBy==1 ){  struct sqlite3_index_orderby *pOrder = &pInfo->aOrderBy[0];  if( pOrder->iColumn<0 || pOrder->iColumn==p->nColumn+1 ){  if( pOrder->desc ){  pInfo->idxStr = "DESC";  }else{  pInfo->idxStr = "ASC";  }  pInfo->orderByConsumed = 1;  }  }  assert( p->pSegments==0 );  return SQLITE_OK; } static int fts3OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){  sqlite3_vtab_cursor *pCsr;  UNUSED_PARAMETER(pVTab);  *ppCsr = pCsr = (sqlite3_vtab_cursor *)sqlite3_malloc(sizeof(Fts3Cursor));  if( !pCsr ){  return SQLITE_NOMEM;  }  memset(pCsr, 0, sizeof(Fts3Cursor));  return SQLITE_OK; } static void fts3CursorFinalizeStmt(Fts3Cursor *pCsr){  if( pCsr->bSeekStmt ){  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;  if( p->pSeekStmt==0 ){  p->pSeekStmt = pCsr->pStmt;  sqlite3_reset(pCsr->pStmt);  pCsr->pStmt = 0;  }  pCsr->bSeekStmt = 0;  }  sqlite3_finalize(pCsr->pStmt); } static void fts3ClearCursor(Fts3Cursor *pCsr){  fts3CursorFinalizeStmt(pCsr);  sqlite3Fts3FreeDeferredTokens(pCsr);  sqlite3_free(pCsr->aDoclist);  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);  sqlite3Fts3ExprFree(pCsr->pExpr);  memset(&(&pCsr->base)[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor)); } static int fts3CloseMethod(sqlite3_vtab_cursor *pCursor){  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );  fts3ClearCursor(pCsr);  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );  sqlite3_free(pCsr);  return SQLITE_OK; } static int fts3CursorSeekStmt(Fts3Cursor *pCsr){  int rc = SQLITE_OK;  if( pCsr->pStmt==0 ){  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;  char *zSql;  if( p->pSeekStmt ){  pCsr->pStmt = p->pSeekStmt;  p->pSeekStmt = 0;  }else{  zSql = sqlite3_mprintf("SELECT %s WHERE rowid = ?", p->zReadExprlist);  if( !zSql ) return SQLITE_NOMEM;  p->bLock++;  rc = sqlite3_prepare_v3(  p->db, zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0  );  p->bLock--;  sqlite3_free(zSql);  }  if( rc==SQLITE_OK ) pCsr->bSeekStmt = 1;  }  return rc; } static int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr){  int rc = SQLITE_OK;  if( pCsr->isRequireSeek ){  rc = fts3CursorSeekStmt(pCsr);  if( rc==SQLITE_OK ){  Fts3Table *pTab = (Fts3Table*)pCsr->base.pVtab;  pTab->bLock++;  sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);  pCsr->isRequireSeek = 0;  if( SQLITE_ROW==sqlite3_step(pCsr->pStmt) ){  pTab->bLock--;  return SQLITE_OK;  }else{  pTab->bLock--;  rc = sqlite3_reset(pCsr->pStmt);  if( rc==SQLITE_OK && ((Fts3Table *)pCsr->base.pVtab)->zContentTbl==0 ){  rc = FTS_CORRUPT_VTAB;  pCsr->isEof = 1;  }  }  }  }  if( rc!=SQLITE_OK && pContext ){  sqlite3_result_error_code(pContext, rc);  }  return rc; } static int fts3ScanInteriorNode(  const char *zTerm,  int nTerm,  const char *zNode,  int nNode,  sqlite3_int64 *piFirst,  sqlite3_int64 *piLast ){  int rc = SQLITE_OK;  const char *zCsr = zNode;  const char *zEnd = &zCsr[nNode];  char *zBuffer = 0;  i64 nAlloc = 0;  int isFirstTerm = 1;  u64 iChild;  int nBuffer = 0;  zCsr += sqlite3Fts3GetVarintU(zCsr, &iChild);  zCsr += sqlite3Fts3GetVarintU(zCsr, &iChild);  if( zCsr>zEnd ){  return FTS_CORRUPT_VTAB;  }  while( zCsr<zEnd && (piFirst || piLast) ){  int cmp;  int nSuffix;  int nPrefix = 0;  if( !isFirstTerm ){  zCsr += fts3GetVarint32(zCsr, &nPrefix);  if( nPrefix>nBuffer ){  rc = FTS_CORRUPT_VTAB;  goto finish_scan;  }  }  isFirstTerm = 0;  zCsr += fts3GetVarint32(zCsr, &nSuffix);  assert( nPrefix>=0 && nSuffix>=0 );  if( nPrefix>zCsr-zNode || nSuffix>zEnd-zCsr || nSuffix==0 ){  rc = FTS_CORRUPT_VTAB;  goto finish_scan;  }  if( (i64)nPrefix+nSuffix>nAlloc ){  char *zNew;  nAlloc = ((i64)nPrefix+nSuffix) * 2;  zNew = (char *)sqlite3_realloc64(zBuffer, nAlloc);  if( !zNew ){  rc = SQLITE_NOMEM;  goto finish_scan;  }  zBuffer = zNew;  }  assert( zBuffer );  memcpy(&zBuffer[nPrefix], zCsr, nSuffix);  nBuffer = nPrefix + nSuffix;  zCsr += nSuffix;  cmp = memcmp(zTerm, zBuffer, (nBuffer>nTerm ? nTerm : nBuffer));  if( piFirst && (cmp<0 || (cmp==0 && nBuffer>nTerm)) ){  *piFirst = (i64)iChild;  piFirst = 0;  }  if( piLast && cmp<0 ){  *piLast = (i64)iChild;  piLast = 0;  }  iChild++;  };  if( piFirst ) *piFirst = (i64)iChild;  if( piLast ) *piLast = (i64)iChild;  finish_scan:  sqlite3_free(zBuffer);  return rc; } static int fts3SelectLeaf(  Fts3Table *p,  const char *zTerm,  int nTerm,  const char *zNode,  int nNode,  sqlite3_int64 *piLeaf,  sqlite3_int64 *piLeaf2 ){  int rc = SQLITE_OK;  int iHeight;  assert( piLeaf || piLeaf2 );  fts3GetVarint32(zNode, &iHeight);  rc = fts3ScanInteriorNode(zTerm, nTerm, zNode, nNode, piLeaf, piLeaf2);  assert_fts3_nc( !piLeaf2 || !piLeaf || rc!=SQLITE_OK || (*piLeaf<=*piLeaf2) );  if( rc==SQLITE_OK && iHeight>1 ){  char *zBlob = 0;  int nBlob = 0;  if( piLeaf && piLeaf2 && (*piLeaf!=*piLeaf2) ){  rc = sqlite3Fts3ReadBlock(p, *piLeaf, &zBlob, &nBlob, 0);  if( rc==SQLITE_OK ){  rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, 0);  }  sqlite3_free(zBlob);  piLeaf = 0;  zBlob = 0;  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts3ReadBlock(p, piLeaf?*piLeaf:*piLeaf2, &zBlob, &nBlob, 0);  }  if( rc==SQLITE_OK ){  int iNewHeight = 0;  fts3GetVarint32(zBlob, &iNewHeight);  if( iNewHeight>=iHeight ){  rc = FTS_CORRUPT_VTAB;  }else{  rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, piLeaf2);  }  }  sqlite3_free(zBlob);  }  return rc; } static void fts3PutDeltaVarint(  char **pp,  sqlite3_int64 *piPrev,  sqlite3_int64 iVal ){  assert_fts3_nc( iVal-*piPrev > 0 || (*piPrev==0 && iVal==0) );  *pp += sqlite3Fts3PutVarint(*pp, iVal-*piPrev);  *piPrev = iVal; } static void fts3PoslistCopy(char **pp, char **ppPoslist){  char *pEnd = *ppPoslist;  char c = 0;  while( *pEnd | c ){  c = *pEnd++ & 0x80;  testcase( c!=0 && (*pEnd)==0 );  }  pEnd++;  if( pp ){  int n = (int)(pEnd - *ppPoslist);  char *p = *pp;  memcpy(p, *ppPoslist, n);  p += n;  *pp = p;  }  *ppPoslist = pEnd; } static void fts3ColumnlistCopy(char **pp, char **ppPoslist){  char *pEnd = *ppPoslist;  char c = 0;  while( 0xFE & (*pEnd | c) ){  c = *pEnd++ & 0x80;  testcase( c!=0 && ((*pEnd)&0xfe)==0 );  }  if( pp ){  int n = (int)(pEnd - *ppPoslist);  char *p = *pp;  memcpy(p, *ppPoslist, n);  p += n;  *pp = p;  }  *ppPoslist = pEnd; }
#define POSITION_LIST_END LARGEST_INT64
static void fts3ReadNextPos(  char **pp,  sqlite3_int64 *pi ){  if( (**pp)&0xFE ){  int iVal;  *pp += fts3GetVarint32((*pp), &iVal);  *pi += iVal;  *pi -= 2;  }else{  *pi = POSITION_LIST_END;  } } static int fts3PutColNumber(char **pp, int iCol){  int n = 0;  if( iCol ){  char *p = *pp;  n = 1 + sqlite3Fts3PutVarint(&p[1], iCol);  *p = 0x01;  *pp = &p[n];  }  return n; } static int fts3PoslistMerge(  char **pp,  char **pp1,  char **pp2 ){  char *p = *pp;  char *p1 = *pp1;  char *p2 = *pp2;  while( *p1 || *p2 ){  int iCol1;  int iCol2;  if( *p1==POS_COLUMN ){  fts3GetVarint32(&p1[1], &iCol1);  if( iCol1==0 ) return FTS_CORRUPT_VTAB;  }  else if( *p1==POS_END ) iCol1 = 0x7fffffff;  else iCol1 = 0;  if( *p2==POS_COLUMN ){  fts3GetVarint32(&p2[1], &iCol2);  if( iCol2==0 ) return FTS_CORRUPT_VTAB;  }  else if( *p2==POS_END ) iCol2 = 0x7fffffff;  else iCol2 = 0;  if( iCol1==iCol2 ){  sqlite3_int64 i1 = 0;  sqlite3_int64 i2 = 0;  sqlite3_int64 iPrev = 0;  int n = fts3PutColNumber(&p, iCol1);  p1 += n;  p2 += n;  fts3GetDeltaVarint(&p1, &i1);  fts3GetDeltaVarint(&p2, &i2);  if( i1<2 || i2<2 ){  break;  }  do {  fts3PutDeltaVarint(&p, &iPrev, (i1<i2) ? i1 : i2);  iPrev -= 2;  if( i1==i2 ){  fts3ReadNextPos(&p1, &i1);  fts3ReadNextPos(&p2, &i2);  }else if( i1<i2 ){  fts3ReadNextPos(&p1, &i1);  }else{  fts3ReadNextPos(&p2, &i2);  }  }while( i1!=POSITION_LIST_END || i2!=POSITION_LIST_END );  }else if( iCol1<iCol2 ){  p1 += fts3PutColNumber(&p, iCol1);  fts3ColumnlistCopy(&p, &p1);  }else{  p2 += fts3PutColNumber(&p, iCol2);  fts3ColumnlistCopy(&p, &p2);  }  }  *p++ = POS_END;  *pp = p;  *pp1 = p1 + 1;  *pp2 = p2 + 1;  return SQLITE_OK; } static int fts3PoslistPhraseMerge(  char **pp,  int nToken,  int isSaveLeft,  int isExact,  char **pp1,  char **pp2 ){  char *p = *pp;  char *p1 = *pp1;  char *p2 = *pp2;  int iCol1 = 0;  int iCol2 = 0;  assert( isSaveLeft==0 || isExact==0 );  assert_fts3_nc( p!=0 && *p1!=0 && *p2!=0 );  if( *p1==POS_COLUMN ){  p1++;  p1 += fts3GetVarint32(p1, &iCol1);  }  if( *p2==POS_COLUMN ){  p2++;  p2 += fts3GetVarint32(p2, &iCol2);  }  while( 1 ){  if( iCol1==iCol2 ){  char *pSave = p;  sqlite3_int64 iPrev = 0;  sqlite3_int64 iPos1 = 0;  sqlite3_int64 iPos2 = 0;  if( iCol1 ){  *p++ = POS_COLUMN;  p += sqlite3Fts3PutVarint(p, iCol1);  }  fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;  fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;  if( iPos1<0 || iPos2<0 ) break;  while( 1 ){  if( iPos2==iPos1+nToken   || (isExact==0 && iPos2>iPos1 && iPos2<=iPos1+nToken)  ){  sqlite3_int64 iSave;  iSave = isSaveLeft ? iPos1 : iPos2;  fts3PutDeltaVarint(&p, &iPrev, iSave+2); iPrev -= 2;  pSave = 0;  assert( p );  }  if( (!isSaveLeft && iPos2<=(iPos1+nToken)) || iPos2<=iPos1 ){  if( (*p2&0xFE)==0 ) break;  fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;  }else{  if( (*p1&0xFE)==0 ) break;  fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;  }  }  if( pSave ){  assert( pp && p );  p = pSave;  }  fts3ColumnlistCopy(0, &p1);  fts3ColumnlistCopy(0, &p2);  assert( (*p1&0xFE)==0 && (*p2&0xFE)==0 );  if( 0==*p1 || 0==*p2 ) break;  p1++;  p1 += fts3GetVarint32(p1, &iCol1);  p2++;  p2 += fts3GetVarint32(p2, &iCol2);  }  else if( iCol1<iCol2 ){  fts3ColumnlistCopy(0, &p1);  if( 0==*p1 ) break;  p1++;  p1 += fts3GetVarint32(p1, &iCol1);  }else{  fts3ColumnlistCopy(0, &p2);  if( 0==*p2 ) break;  p2++;  p2 += fts3GetVarint32(p2, &iCol2);  }  }  fts3PoslistCopy(0, &p2);  fts3PoslistCopy(0, &p1);  *pp1 = p1;  *pp2 = p2;  if( *pp==p ){  return 0;  }  *p++ = 0x00;  *pp = p;  return 1; } static int fts3PoslistNearMerge(  char **pp,  char *aTmp,  int nRight,  int nLeft,  char **pp1,  char **pp2 ){  char *p1 = *pp1;  char *p2 = *pp2;  char *pTmp1 = aTmp;  char *pTmp2;  char *aTmp2;  int res = 1;  fts3PoslistPhraseMerge(&pTmp1, nRight, 0, 0, pp1, pp2);  aTmp2 = pTmp2 = pTmp1;  *pp1 = p1;  *pp2 = p2;  fts3PoslistPhraseMerge(&pTmp2, nLeft, 1, 0, pp2, pp1);  if( pTmp1!=aTmp && pTmp2!=aTmp2 ){  fts3PoslistMerge(pp, &aTmp, &aTmp2);  }else if( pTmp1!=aTmp ){  fts3PoslistCopy(pp, &aTmp);  }else if( pTmp2!=aTmp2 ){  fts3PoslistCopy(pp, &aTmp2);  }else{  res = 0;  }  return res; } typedef struct TermSelect TermSelect; struct TermSelect {  char *aaOutput[16];  int anOutput[16]; }; static void fts3GetDeltaVarint3(  char **pp,  char *pEnd,  int bDescIdx,  sqlite3_int64 *pVal ){  if( *pp>=pEnd ){  *pp = 0;  }else{  u64 iVal;  *pp += sqlite3Fts3GetVarintU(*pp, &iVal);  if( bDescIdx ){  *pVal = (i64)((u64)*pVal - iVal);  }else{  *pVal = (i64)((u64)*pVal + iVal);  }  } } static void fts3PutDeltaVarint3(  char **pp,  int bDescIdx,  sqlite3_int64 *piPrev,  int *pbFirst,  sqlite3_int64 iVal ){  sqlite3_uint64 iWrite;  if( bDescIdx==0 || *pbFirst==0 ){  assert_fts3_nc( *pbFirst==0 || iVal>=*piPrev );  iWrite = (u64)iVal - (u64)*piPrev;  }else{  assert_fts3_nc( *piPrev>=iVal );  iWrite = (u64)*piPrev - (u64)iVal;  }  assert( *pbFirst || *piPrev==0 );  assert_fts3_nc( *pbFirst==0 || iWrite>0 );  *pp += sqlite3Fts3PutVarint(*pp, iWrite);  *piPrev = iVal;  *pbFirst = 1; }
#define DOCID_CMP(i1, i2) ((bDescDoclist?-1:1) * (i1>i2?1:((i1==i2)?0:-1)))
static int fts3DoclistOrMerge(  int bDescDoclist,  char *a1, int n1,  char *a2, int n2,  char **paOut, int *pnOut ){  int rc = SQLITE_OK;  sqlite3_int64 i1 = 0;  sqlite3_int64 i2 = 0;  sqlite3_int64 iPrev = 0;  char *pEnd1 = &a1[n1];  char *pEnd2 = &a2[n2];  char *p1 = a1;  char *p2 = a2;  char *p;  char *aOut;  int bFirstOut = 0;  *paOut = 0;  *pnOut = 0;  aOut = sqlite3_malloc64((i64)n1+n2+FTS3_VARINT_MAX-1+FTS3_BUFFER_PADDING);  if( !aOut ) return SQLITE_NOMEM;  p = aOut;  fts3GetDeltaVarint3(&p1, pEnd1, 0, &i1);  fts3GetDeltaVarint3(&p2, pEnd2, 0, &i2);  while( p1 || p2 ){  sqlite3_int64 iDiff = DOCID_CMP(i1, i2);  if( p2 && p1 && iDiff==0 ){  fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i1);  rc = fts3PoslistMerge(&p, &p1, &p2);  if( rc ) break;  fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);  fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);  }else if( !p2 || (p1 && iDiff<0) ){  fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i1);  fts3PoslistCopy(&p, &p1);  fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);  }else{  fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i2);  fts3PoslistCopy(&p, &p2);  fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);  }  assert( (p-aOut)<=((p1?(p1-a1):n1)+(p2?(p2-a2):n2)+FTS3_VARINT_MAX-1) );  }  if( rc!=SQLITE_OK ){  sqlite3_free(aOut);  p = aOut = 0;  }else{  assert( (p-aOut)<=n1+n2+FTS3_VARINT_MAX-1 );  memset(&aOut[(p-aOut)], 0, FTS3_BUFFER_PADDING);  }  *paOut = aOut;  *pnOut = (int)(p-aOut);  return rc; } static int fts3DoclistPhraseMerge(  int bDescDoclist,  int nDist,  char *aLeft, int nLeft,  char **paRight, int *pnRight ){  sqlite3_int64 i1 = 0;  sqlite3_int64 i2 = 0;  sqlite3_int64 iPrev = 0;  char *aRight = *paRight;  char *pEnd1 = &aLeft[nLeft];  char *pEnd2 = &aRight[*pnRight];  char *p1 = aLeft;  char *p2 = aRight;  char *p;  int bFirstOut = 0;  char *aOut;  assert( nDist>0 );  if( bDescDoclist ){  aOut = sqlite3_malloc64((sqlite3_int64)*pnRight + FTS3_VARINT_MAX);  if( aOut==0 ) return SQLITE_NOMEM;  }else{  aOut = aRight;  }  p = aOut;  fts3GetDeltaVarint3(&p1, pEnd1, 0, &i1);  fts3GetDeltaVarint3(&p2, pEnd2, 0, &i2);  while( p1 && p2 ){  sqlite3_int64 iDiff = DOCID_CMP(i1, i2);  if( iDiff==0 ){  char *pSave = p;  sqlite3_int64 iPrevSave = iPrev;  int bFirstOutSave = bFirstOut;  fts3PutDeltaVarint3(&p, bDescDoclist, &iPrev, &bFirstOut, i1);  if( 0==fts3PoslistPhraseMerge(&p, nDist, 0, 1, &p1, &p2) ){  p = pSave;  iPrev = iPrevSave;  bFirstOut = bFirstOutSave;  }  fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);  fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);  }else if( iDiff<0 ){  fts3PoslistCopy(0, &p1);  fts3GetDeltaVarint3(&p1, pEnd1, bDescDoclist, &i1);  }else{  fts3PoslistCopy(0, &p2);  fts3GetDeltaVarint3(&p2, pEnd2, bDescDoclist, &i2);  }  }  *pnRight = (int)(p - aOut);  if( bDescDoclist ){  sqlite3_free(aRight);  *paRight = aOut;  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3FirstFilter(  sqlite3_int64 iDelta,  char *pList,  int nList,  char *pOut ){  int nOut = 0;  int bWritten = 0;  char *p = pList;  char *pEnd = &pList[nList];  if( *p!=0x01 ){  if( *p==0x02 ){  nOut += sqlite3Fts3PutVarint(&pOut[nOut], iDelta);  pOut[nOut++] = 0x02;  bWritten = 1;  }  fts3ColumnlistCopy(0, &p);  }  while( p<pEnd ){  sqlite3_int64 iCol;  p++;  p += sqlite3Fts3GetVarint(p, &iCol);  if( *p==0x02 ){  if( bWritten==0 ){  nOut += sqlite3Fts3PutVarint(&pOut[nOut], iDelta);  bWritten = 1;  }  pOut[nOut++] = 0x01;  nOut += sqlite3Fts3PutVarint(&pOut[nOut], iCol);  pOut[nOut++] = 0x02;  }  fts3ColumnlistCopy(0, &p);  }  if( bWritten ){  pOut[nOut++] = 0x00;  }  return nOut; } static int fts3TermSelectFinishMerge(Fts3Table *p, TermSelect *pTS){  char *aOut = 0;  int nOut = 0;  int i;  for(i=0; i<SizeofArray(pTS->aaOutput); i++){  if( pTS->aaOutput[i] ){  if( !aOut ){  aOut = pTS->aaOutput[i];  nOut = pTS->anOutput[i];  pTS->aaOutput[i] = 0;  }else{  int nNew;  char *aNew;  int rc = fts3DoclistOrMerge(p->bDescIdx,  pTS->aaOutput[i], pTS->anOutput[i], aOut, nOut, &aNew, &nNew  );  if( rc!=SQLITE_OK ){  sqlite3_free(aOut);  return rc;  }  sqlite3_free(pTS->aaOutput[i]);  sqlite3_free(aOut);  pTS->aaOutput[i] = 0;  aOut = aNew;  nOut = nNew;  }  }  }  pTS->aaOutput[0] = aOut;  pTS->anOutput[0] = nOut;  return SQLITE_OK; } static int fts3TermSelectMerge(  Fts3Table *p,  TermSelect *pTS,  char *aDoclist,  int nDoclist ){  if( pTS->aaOutput[0]==0 ){  pTS->aaOutput[0] = sqlite3_malloc(nDoclist + FTS3_VARINT_MAX + 1);  pTS->anOutput[0] = nDoclist;  if( pTS->aaOutput[0] ){  memcpy(pTS->aaOutput[0], aDoclist, nDoclist);  memset(&pTS->aaOutput[0][nDoclist], 0, FTS3_VARINT_MAX);  }else{  return SQLITE_NOMEM;  }  }else{  char *aMerge = aDoclist;  int nMerge = nDoclist;  int iOut;  for(iOut=0; iOut<SizeofArray(pTS->aaOutput); iOut++){  if( pTS->aaOutput[iOut]==0 ){  assert( iOut>0 );  pTS->aaOutput[iOut] = aMerge;  pTS->anOutput[iOut] = nMerge;  break;  }else{  char *aNew;  int nNew;  int rc = fts3DoclistOrMerge(p->bDescIdx, aMerge, nMerge,  pTS->aaOutput[iOut], pTS->anOutput[iOut], &aNew, &nNew  );  if( rc!=SQLITE_OK ){  if( aMerge!=aDoclist ) sqlite3_free(aMerge);  return rc;  }  if( aMerge!=aDoclist ) sqlite3_free(aMerge);  sqlite3_free(pTS->aaOutput[iOut]);  pTS->aaOutput[iOut] = 0;  aMerge = aNew;  nMerge = nNew;  if( (iOut+1)==SizeofArray(pTS->aaOutput) ){  pTS->aaOutput[iOut] = aMerge;  pTS->anOutput[iOut] = nMerge;  }  }  }  }  return SQLITE_OK; } static int fts3SegReaderCursorAppend(  Fts3MultiSegReader *pCsr,  Fts3SegReader *pNew ){  if( (pCsr->nSegment%16)==0 ){  Fts3SegReader **apNew;  sqlite3_int64 nByte = (pCsr->nSegment + 16)*sizeof(Fts3SegReader*);  apNew = (Fts3SegReader **)sqlite3_realloc64(pCsr->apSegment, nByte);  if( !apNew ){  sqlite3Fts3SegReaderFree(pNew);  return SQLITE_NOMEM;  }  pCsr->apSegment = apNew;  }  pCsr->apSegment[pCsr->nSegment++] = pNew;  return SQLITE_OK; } static int fts3SegReaderCursor(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel,  const char *zTerm,  int nTerm,  int isPrefix,  int isScan,  Fts3MultiSegReader *pCsr ){  int rc = SQLITE_OK;  sqlite3_stmt *pStmt = 0;  int rc2;  if( iLevel<0 && p->aIndex && p->iPrevLangid==iLangid ){  Fts3SegReader *pSeg = 0;  rc = sqlite3Fts3SegReaderPending(p, iIndex, zTerm, nTerm, isPrefix||isScan, &pSeg);  if( rc==SQLITE_OK && pSeg ){  rc = fts3SegReaderCursorAppend(pCsr, pSeg);  }  }  if( iLevel!=FTS3_SEGCURSOR_PENDING ){  if( rc==SQLITE_OK ){  rc = sqlite3Fts3AllSegdirs(p, iLangid, iIndex, iLevel, &pStmt);  }  while( rc==SQLITE_OK && SQLITE_ROW==(rc = sqlite3_step(pStmt)) ){  Fts3SegReader *pSeg = 0;  sqlite3_int64 iStartBlock = sqlite3_column_int64(pStmt, 1);  sqlite3_int64 iLeavesEndBlock = sqlite3_column_int64(pStmt, 2);  sqlite3_int64 iEndBlock = sqlite3_column_int64(pStmt, 3);  int nRoot = sqlite3_column_bytes(pStmt, 4);  char const *zRoot = sqlite3_column_blob(pStmt, 4);  if( iStartBlock && zTerm && zRoot ){  sqlite3_int64 *pi = (isPrefix ? &iLeavesEndBlock : 0);  rc = fts3SelectLeaf(p, zTerm, nTerm, zRoot, nRoot, &iStartBlock, pi);  if( rc!=SQLITE_OK ) goto finished;  if( isPrefix==0 && isScan==0 ) iLeavesEndBlock = iStartBlock;  }  rc = sqlite3Fts3SegReaderNew(pCsr->nSegment+1,  (isPrefix==0 && isScan==0),  iStartBlock, iLeavesEndBlock,  iEndBlock, zRoot, nRoot, &pSeg  );  if( rc!=SQLITE_OK ) goto finished;  rc = fts3SegReaderCursorAppend(pCsr, pSeg);  }  }  finished:  rc2 = sqlite3_reset(pStmt);  if( rc==SQLITE_DONE ) rc = rc2;  return rc; } SQLITE_PRIVATE int sqlite3Fts3SegReaderCursor(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel,  const char *zTerm,  int nTerm,  int isPrefix,  int isScan,  Fts3MultiSegReader *pCsr ){  assert( iIndex>=0 && iIndex<p->nIndex );  assert( iLevel==FTS3_SEGCURSOR_ALL  || iLevel==FTS3_SEGCURSOR_PENDING  || iLevel>=0  );  assert( iLevel<FTS3_SEGDIR_MAXLEVEL );  assert( FTS3_SEGCURSOR_ALL<0 && FTS3_SEGCURSOR_PENDING<0 );  assert( isPrefix==0 || isScan==0 );  memset(pCsr, 0, sizeof(Fts3MultiSegReader));  return fts3SegReaderCursor(  p, iLangid, iIndex, iLevel, zTerm, nTerm, isPrefix, isScan, pCsr  ); } static int fts3SegReaderCursorAddZero(  Fts3Table *p,  int iLangid,  const char *zTerm,  int nTerm,  Fts3MultiSegReader *pCsr ){  return fts3SegReaderCursor(p,  iLangid, 0, FTS3_SEGCURSOR_ALL, zTerm, nTerm, 0, 0,pCsr  ); } static int fts3TermSegReaderCursor(  Fts3Cursor *pCsr,  const char *zTerm,  int nTerm,  int isPrefix,  Fts3MultiSegReader **ppSegcsr ){  Fts3MultiSegReader *pSegcsr;  int rc = SQLITE_NOMEM;  pSegcsr = sqlite3_malloc(sizeof(Fts3MultiSegReader));  if( pSegcsr ){  int i;  int bFound = 0;  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;  if( isPrefix ){  for(i=1; bFound==0 && i<p->nIndex; i++){  if( p->aIndex[i].nPrefix==nTerm ){  bFound = 1;  rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid,  i, FTS3_SEGCURSOR_ALL, zTerm, nTerm, 0, 0, pSegcsr  );  pSegcsr->bLookup = 1;  }  }  for(i=1; bFound==0 && i<p->nIndex; i++){  if( p->aIndex[i].nPrefix==nTerm+1 ){  bFound = 1;  rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid,  i, FTS3_SEGCURSOR_ALL, zTerm, nTerm, 1, 0, pSegcsr  );  if( rc==SQLITE_OK ){  rc = fts3SegReaderCursorAddZero(  p, pCsr->iLangid, zTerm, nTerm, pSegcsr  );  }  }  }  }  if( bFound==0 ){  rc = sqlite3Fts3SegReaderCursor(p, pCsr->iLangid,  0, FTS3_SEGCURSOR_ALL, zTerm, nTerm, isPrefix, 0, pSegcsr  );  pSegcsr->bLookup = !isPrefix;  }  }  *ppSegcsr = pSegcsr;  return rc; } static void fts3SegReaderCursorFree(Fts3MultiSegReader *pSegcsr){  sqlite3Fts3SegReaderFinish(pSegcsr);  sqlite3_free(pSegcsr); } static int fts3TermSelect(  Fts3Table *p,  Fts3PhraseToken *pTok,  int iColumn,  int *pnOut,  char **ppOut ){  int rc;  Fts3MultiSegReader *pSegcsr;  TermSelect tsc;  Fts3SegFilter filter;  pSegcsr = pTok->pSegcsr;  memset(&tsc, 0, sizeof(TermSelect));  filter.flags = FTS3_SEGMENT_IGNORE_EMPTY | FTS3_SEGMENT_REQUIRE_POS  | (pTok->isPrefix ? FTS3_SEGMENT_PREFIX : 0)  | (pTok->bFirst ? FTS3_SEGMENT_FIRST : 0)  | (iColumn<p->nColumn ? FTS3_SEGMENT_COLUMN_FILTER : 0);  filter.iCol = iColumn;  filter.zTerm = pTok->z;  filter.nTerm = pTok->n;  rc = sqlite3Fts3SegReaderStart(p, pSegcsr, &filter);  while( SQLITE_OK==rc  && SQLITE_ROW==(rc = sqlite3Fts3SegReaderStep(p, pSegcsr))  ){  rc = fts3TermSelectMerge(p, &tsc, pSegcsr->aDoclist, pSegcsr->nDoclist);  }  if( rc==SQLITE_OK ){  rc = fts3TermSelectFinishMerge(p, &tsc);  }  if( rc==SQLITE_OK ){  *ppOut = tsc.aaOutput[0];  *pnOut = tsc.anOutput[0];  }else{  int i;  for(i=0; i<SizeofArray(tsc.aaOutput); i++){  sqlite3_free(tsc.aaOutput[i]);  }  }  fts3SegReaderCursorFree(pSegcsr);  pTok->pSegcsr = 0;  return rc; } static int fts3DoclistCountDocids(char *aList, int nList){  int nDoc = 0;  if( aList ){  char *aEnd = &aList[nList];  char *p = aList;  while( p<aEnd ){  nDoc++;  while( (*p++)&0x80 );  fts3PoslistCopy(0, &p);  }  }  return nDoc; } static int fts3NextMethod(sqlite3_vtab_cursor *pCursor){  int rc;  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;  if( pCsr->eSearch==FTS3_DOCID_SEARCH || pCsr->eSearch==FTS3_FULLSCAN_SEARCH ){  Fts3Table *pTab = (Fts3Table*)pCursor->pVtab;  pTab->bLock++;  if( SQLITE_ROW!=sqlite3_step(pCsr->pStmt) ){  pCsr->isEof = 1;  rc = sqlite3_reset(pCsr->pStmt);  }else{  pCsr->iPrevId = sqlite3_column_int64(pCsr->pStmt, 0);  rc = SQLITE_OK;  }  pTab->bLock--;  }else{  rc = fts3EvalNext((Fts3Cursor *)pCursor);  }  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );  return rc; } static sqlite3_int64 fts3DocidRange(sqlite3_value *pVal, i64 iDefault){  if( pVal ){  int eType = sqlite3_value_numeric_type(pVal);  if( eType==SQLITE_INTEGER ){  return sqlite3_value_int64(pVal);  }  }  return iDefault; } static int fts3FilterMethod(  sqlite3_vtab_cursor *pCursor,  int idxNum,  const char *idxStr,  int nVal,  sqlite3_value **apVal ){  int rc = SQLITE_OK;  char *zSql;  int eSearch;  Fts3Table *p = (Fts3Table *)pCursor->pVtab;  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;  sqlite3_value *pCons = 0;  sqlite3_value *pLangid = 0;  sqlite3_value *pDocidGe = 0;  sqlite3_value *pDocidLe = 0;  int iIdx;  UNUSED_PARAMETER(idxStr);  UNUSED_PARAMETER(nVal);  if( p->bLock ){  return SQLITE_ERROR;  }  eSearch = (idxNum & 0x0000FFFF);  assert( eSearch>=0 && eSearch<=(FTS3_FULLTEXT_SEARCH+p->nColumn) );  assert( p->pSegments==0 );  iIdx = 0;  if( eSearch!=FTS3_FULLSCAN_SEARCH ) pCons = apVal[iIdx++];  if( idxNum & FTS3_HAVE_LANGID ) pLangid = apVal[iIdx++];  if( idxNum & FTS3_HAVE_DOCID_GE ) pDocidGe = apVal[iIdx++];  if( idxNum & FTS3_HAVE_DOCID_LE ) pDocidLe = apVal[iIdx++];  assert( iIdx==nVal );  fts3ClearCursor(pCsr);  pCsr->iMinDocid = fts3DocidRange(pDocidGe, SMALLEST_INT64);  pCsr->iMaxDocid = fts3DocidRange(pDocidLe, LARGEST_INT64);  if( idxStr ){  pCsr->bDesc = (idxStr[0]=='D');  }else{  pCsr->bDesc = p->bDescIdx;  }  pCsr->eSearch = (i16)eSearch;  if( eSearch!=FTS3_DOCID_SEARCH && eSearch!=FTS3_FULLSCAN_SEARCH ){  int iCol = eSearch-FTS3_FULLTEXT_SEARCH;  const char *zQuery = (const char *)sqlite3_value_text(pCons);  if( zQuery==0 && sqlite3_value_type(pCons)!=SQLITE_NULL ){  return SQLITE_NOMEM;  }  pCsr->iLangid = 0;  if( pLangid ) pCsr->iLangid = sqlite3_value_int(pLangid);  assert( p->base.zErrMsg==0 );  rc = sqlite3Fts3ExprParse(p->pTokenizer, pCsr->iLangid,  p->azColumn, p->bFts4, p->nColumn, iCol, zQuery, -1, &pCsr->pExpr,  &p->base.zErrMsg  );  if( rc!=SQLITE_OK ){  return rc;  }  rc = fts3EvalStart(pCsr);  sqlite3Fts3SegmentsClose(p);  if( rc!=SQLITE_OK ) return rc;  pCsr->pNextId = pCsr->aDoclist;  pCsr->iPrevId = 0;  }  if( eSearch==FTS3_FULLSCAN_SEARCH ){  if( pDocidGe || pDocidLe ){  zSql = sqlite3_mprintf(  "SELECT %s WHERE rowid BETWEEN %lld AND %lld ORDER BY rowid %s",  p->zReadExprlist, pCsr->iMinDocid, pCsr->iMaxDocid,  (pCsr->bDesc ? "DESC" : "ASC")  );  }else{  zSql = sqlite3_mprintf("SELECT %s ORDER BY rowid %s",  p->zReadExprlist, (pCsr->bDesc ? "DESC" : "ASC")  );  }  if( zSql ){  p->bLock++;  rc = sqlite3_prepare_v3(  p->db,zSql,-1,SQLITE_PREPARE_PERSISTENT,&pCsr->pStmt,0  );  p->bLock--;  sqlite3_free(zSql);  }else{  rc = SQLITE_NOMEM;  }  }else if( eSearch==FTS3_DOCID_SEARCH ){  rc = fts3CursorSeekStmt(pCsr);  if( rc==SQLITE_OK ){  rc = sqlite3_bind_value(pCsr->pStmt, 1, pCons);  }  }  if( rc!=SQLITE_OK ) return rc;  return fts3NextMethod(pCursor); } static int fts3EofMethod(sqlite3_vtab_cursor *pCursor){  Fts3Cursor *pCsr = (Fts3Cursor*)pCursor;  if( pCsr->isEof ){  fts3ClearCursor(pCsr);  pCsr->isEof = 1;  }  return pCsr->isEof; } static int fts3RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){  Fts3Cursor *pCsr = (Fts3Cursor *) pCursor;  *pRowid = pCsr->iPrevId;  return SQLITE_OK; } static int fts3ColumnMethod(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *pCtx,  int iCol ){  int rc = SQLITE_OK;  Fts3Cursor *pCsr = (Fts3Cursor *) pCursor;  Fts3Table *p = (Fts3Table *)pCursor->pVtab;  assert( iCol>=0 && iCol<=p->nColumn+2 );  switch( iCol-p->nColumn ){  case 0:  sqlite3_result_pointer(pCtx, pCsr, "fts3cursor", 0);  break;  case 1:  sqlite3_result_int64(pCtx, pCsr->iPrevId);  break;  case 2:  if( pCsr->pExpr ){  sqlite3_result_int64(pCtx, pCsr->iLangid);  break;  }else if( p->zLanguageid==0 ){  sqlite3_result_int(pCtx, 0);  break;  }else{  iCol = p->nColumn;   deliberate_fall_through  }  default:  rc = fts3CursorSeek(0, pCsr);  if( rc==SQLITE_OK && sqlite3_data_count(pCsr->pStmt)-1>iCol ){  sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));  }  break;  }  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );  return rc; } static int fts3UpdateMethod(  sqlite3_vtab *pVtab,  int nArg,  sqlite3_value **apVal,  sqlite_int64 *pRowid ){  return sqlite3Fts3UpdateMethod(pVtab, nArg, apVal, pRowid); } static int fts3SyncMethod(sqlite3_vtab *pVtab){  const u32 nMinMerge = 64;  Fts3Table *p = (Fts3Table*)pVtab;  int rc;  i64 iLastRowid = sqlite3_last_insert_rowid(p->db);  rc = sqlite3Fts3PendingTermsFlush(p);  if( rc==SQLITE_OK   && p->nLeafAdd>(nMinMerge/16)   && p->nAutoincrmerge && p->nAutoincrmerge!=0xff  ){  int mxLevel = 0;  int A;  rc = sqlite3Fts3MaxLevel(p, &mxLevel);  assert( rc==SQLITE_OK || mxLevel==0 );  A = p->nLeafAdd * mxLevel;  A += (A/2);  if( A>(int)nMinMerge ) rc = sqlite3Fts3Incrmerge(p, A, p->nAutoincrmerge);  }  sqlite3Fts3SegmentsClose(p);  sqlite3_set_last_insert_rowid(p->db, iLastRowid);  return rc; } static int fts3SetHasStat(Fts3Table *p){  int rc = SQLITE_OK;  if( p->bHasStat==2 ){  char *zTbl = sqlite3_mprintf("%s_stat", p->zName);  if( zTbl ){  int res = sqlite3_table_column_metadata(p->db, p->zDb, zTbl, 0,0,0,0,0,0);  sqlite3_free(zTbl);  p->bHasStat = (res==SQLITE_OK);  }else{  rc = SQLITE_NOMEM;  }  }  return rc; } static int fts3BeginMethod(sqlite3_vtab *pVtab){  Fts3Table *p = (Fts3Table*)pVtab;  int rc;  UNUSED_PARAMETER(pVtab);  assert( p->pSegments==0 );  assert( p->nPendingData==0 );  assert( p->inTransaction!=1 );  p->nLeafAdd = 0;  rc = fts3SetHasStat(p);
#ifdef SQLITE_DEBUG
 if( rc==SQLITE_OK ){  p->inTransaction = 1;  p->mxSavepoint = -1;  }
#endif
 return rc; } static int fts3CommitMethod(sqlite3_vtab *pVtab){  TESTONLY( Fts3Table *p = (Fts3Table*)pVtab );  UNUSED_PARAMETER(pVtab);  assert( p->nPendingData==0 );  assert( p->inTransaction!=0 );  assert( p->pSegments==0 );  TESTONLY( p->inTransaction = 0 );  TESTONLY( p->mxSavepoint = -1; );  return SQLITE_OK; } static int fts3RollbackMethod(sqlite3_vtab *pVtab){  Fts3Table *p = (Fts3Table*)pVtab;  sqlite3Fts3PendingTermsClear(p);  assert( p->inTransaction!=0 );  TESTONLY( p->inTransaction = 0 );  TESTONLY( p->mxSavepoint = -1; );  return SQLITE_OK; } static void fts3ReversePoslist(char *pStart, char **ppPoslist){  char *p = &(*ppPoslist)[-2];  char c = 0;  while( p>pStart && (c=*p--)==0 );  while( p>pStart && (*p & 0x80) | c ){  c = *p--;  }  assert( p==pStart || c==0 );  if( p>pStart || (c==0 && *ppPoslist>&p[2]) ){ p = &p[2]; }  while( *p++&0x80 );  *ppPoslist = p; } static int fts3FunctionArg(  sqlite3_context *pContext,  const char *zFunc,  sqlite3_value *pVal,  Fts3Cursor **ppCsr ){  int rc;  *ppCsr = (Fts3Cursor*)sqlite3_value_pointer(pVal, "fts3cursor");  if( (*ppCsr)!=0 ){  rc = SQLITE_OK;  }else{  char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);  sqlite3_result_error(pContext, zErr, -1);  sqlite3_free(zErr);  rc = SQLITE_ERROR;  }  return rc; } static void fts3SnippetFunc(  sqlite3_context *pContext,  int nVal,  sqlite3_value **apVal ){  Fts3Cursor *pCsr;  const char *zStart = "<b>";  const char *zEnd = "</b>";  const char *zEllipsis = "<b>...</b>";  int iCol = -1;  int nToken = 15;  assert( nVal>=1 );  if( nVal>6 ){  sqlite3_result_error(pContext,  "wrong number of arguments to function snippet()", -1);  return;  }  if( fts3FunctionArg(pContext, "snippet", apVal[0], &pCsr) ) return;  switch( nVal ){  case 6: nToken = sqlite3_value_int(apVal[5]);   deliberate_fall_through  case 5: iCol = sqlite3_value_int(apVal[4]);   deliberate_fall_through  case 4: zEllipsis = (const char*)sqlite3_value_text(apVal[3]);   deliberate_fall_through  case 3: zEnd = (const char*)sqlite3_value_text(apVal[2]);   deliberate_fall_through  case 2: zStart = (const char*)sqlite3_value_text(apVal[1]);  }  if( !zEllipsis || !zEnd || !zStart ){  sqlite3_result_error_nomem(pContext);  }else if( nToken==0 ){  sqlite3_result_text(pContext, "", -1, SQLITE_STATIC);  }else if( SQLITE_OK==fts3CursorSeek(pContext, pCsr) ){  sqlite3Fts3Snippet(pContext, pCsr, zStart, zEnd, zEllipsis, iCol, nToken);  } } static void fts3OffsetsFunc(  sqlite3_context *pContext,  int nVal,  sqlite3_value **apVal ){  Fts3Cursor *pCsr;  UNUSED_PARAMETER(nVal);  assert( nVal==1 );  if( fts3FunctionArg(pContext, "offsets", apVal[0], &pCsr) ) return;  assert( pCsr );  if( SQLITE_OK==fts3CursorSeek(pContext, pCsr) ){  sqlite3Fts3Offsets(pContext, pCsr);  } } static void fts3OptimizeFunc(  sqlite3_context *pContext,  int nVal,  sqlite3_value **apVal ){  int rc;  Fts3Table *p;  Fts3Cursor *pCursor;  UNUSED_PARAMETER(nVal);  assert( nVal==1 );  if( fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor) ) return;  p = (Fts3Table *)pCursor->base.pVtab;  assert( p );  rc = sqlite3Fts3Optimize(p);  switch( rc ){  case SQLITE_OK:  sqlite3_result_text(pContext, "Index optimized", -1, SQLITE_STATIC);  break;  case SQLITE_DONE:  sqlite3_result_text(pContext, "Index already optimal", -1, SQLITE_STATIC);  break;  default:  sqlite3_result_error_code(pContext, rc);  break;  } } static void fts3MatchinfoFunc(  sqlite3_context *pContext,  int nVal,  sqlite3_value **apVal ){  Fts3Cursor *pCsr;  assert( nVal==1 || nVal==2 );  if( SQLITE_OK==fts3FunctionArg(pContext, "matchinfo", apVal[0], &pCsr) ){  const char *zArg = 0;  if( nVal>1 ){  zArg = (const char *)sqlite3_value_text(apVal[1]);  }  sqlite3Fts3Matchinfo(pContext, pCsr, zArg);  } } static int fts3FindFunctionMethod(  sqlite3_vtab *pVtab,  int nArg,  const char *zName,  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),  void **ppArg ){  struct Overloaded {  const char *zName;  void (*xFunc)(sqlite3_context*,int,sqlite3_value**);  } aOverload[] = {  { "snippet", fts3SnippetFunc },  { "offsets", fts3OffsetsFunc },  { "optimize", fts3OptimizeFunc },  { "matchinfo", fts3MatchinfoFunc },  };  int i;  UNUSED_PARAMETER(pVtab);  UNUSED_PARAMETER(nArg);  UNUSED_PARAMETER(ppArg);  for(i=0; i<SizeofArray(aOverload); i++){  if( strcmp(zName, aOverload[i].zName)==0 ){  *pxFunc = aOverload[i].xFunc;  return 1;  }  }  return 0; } static int fts3RenameMethod(  sqlite3_vtab *pVtab,  const char *zName ){  Fts3Table *p = (Fts3Table *)pVtab;  sqlite3 *db = p->db;  int rc;  rc = fts3SetHasStat(p);  assert( p->nPendingData==0 );  if( rc==SQLITE_OK ){  rc = sqlite3Fts3PendingTermsFlush(p);  }  if( p->zContentTbl==0 ){  fts3DbExec(&rc, db,  "ALTER TABLE %Q.'%q_content' RENAME TO '%q_content';",  p->zDb, p->zName, zName  );  }  if( p->bHasDocsize ){  fts3DbExec(&rc, db,  "ALTER TABLE %Q.'%q_docsize' RENAME TO '%q_docsize';",  p->zDb, p->zName, zName  );  }  if( p->bHasStat ){  fts3DbExec(&rc, db,  "ALTER TABLE %Q.'%q_stat' RENAME TO '%q_stat';",  p->zDb, p->zName, zName  );  }  fts3DbExec(&rc, db,  "ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';",  p->zDb, p->zName, zName  );  fts3DbExec(&rc, db,  "ALTER TABLE %Q.'%q_segdir'  RENAME TO '%q_segdir';",  p->zDb, p->zName, zName  );  return rc; } static int fts3SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){  int rc = SQLITE_OK;  UNUSED_PARAMETER(iSavepoint);  assert( ((Fts3Table *)pVtab)->inTransaction );  assert( ((Fts3Table *)pVtab)->mxSavepoint <= iSavepoint );  TESTONLY( ((Fts3Table *)pVtab)->mxSavepoint = iSavepoint );  if( ((Fts3Table *)pVtab)->bIgnoreSavepoint==0 ){  rc = fts3SyncMethod(pVtab);  }  return rc; } static int fts3ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){  TESTONLY( Fts3Table *p = (Fts3Table*)pVtab );  UNUSED_PARAMETER(iSavepoint);  UNUSED_PARAMETER(pVtab);  assert( p->inTransaction );  assert( p->mxSavepoint >= iSavepoint );  TESTONLY( p->mxSavepoint = iSavepoint-1 );  return SQLITE_OK; } static int fts3RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){  Fts3Table *p = (Fts3Table*)pVtab;  UNUSED_PARAMETER(iSavepoint);  assert( p->inTransaction );  TESTONLY( p->mxSavepoint = iSavepoint );  sqlite3Fts3PendingTermsClear(p);  return SQLITE_OK; } static int fts3ShadowName(const char *zName){  static const char *azName[] = {  "content", "docsize", "segdir", "segments", "stat",  };  unsigned int i;  for(i=0; i<sizeof(azName)/sizeof(azName[0]); i++){  if( sqlite3_stricmp(zName, azName[i])==0 ) return 1;  }  return 0; } static const sqlite3_module fts3Module = {  3,  fts3CreateMethod,  fts3ConnectMethod,  fts3BestIndexMethod,  fts3DisconnectMethod,  fts3DestroyMethod,  fts3OpenMethod,  fts3CloseMethod,  fts3FilterMethod,  fts3NextMethod,  fts3EofMethod,  fts3ColumnMethod,  fts3RowidMethod,  fts3UpdateMethod,  fts3BeginMethod,  fts3SyncMethod,  fts3CommitMethod,  fts3RollbackMethod,  fts3FindFunctionMethod,   fts3RenameMethod,  fts3SavepointMethod,  fts3ReleaseMethod,  fts3RollbackToMethod,  fts3ShadowName, }; static void hashDestroy(void *p){  Fts3Hash *pHash = (Fts3Hash *)p;  sqlite3Fts3HashClear(pHash);  sqlite3_free(pHash); } SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule); SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(sqlite3_tokenizer_module const**ppModule);
#ifndef SQLITE_DISABLE_FTS3_UNICODE
SQLITE_PRIVATE void sqlite3Fts3UnicodeTokenizer(sqlite3_tokenizer_module const**ppModule);
#endif
#ifdef SQLITE_ENABLE_ICU
SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(sqlite3_tokenizer_module const**ppModule);
#endif
SQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db){  int rc = SQLITE_OK;  Fts3Hash *pHash = 0;  const sqlite3_tokenizer_module *pSimple = 0;  const sqlite3_tokenizer_module *pPorter = 0;
#ifndef SQLITE_DISABLE_FTS3_UNICODE
 const sqlite3_tokenizer_module *pUnicode = 0;
#endif
#ifdef SQLITE_ENABLE_ICU
 const sqlite3_tokenizer_module *pIcu = 0;  sqlite3Fts3IcuTokenizerModule(&pIcu);
#endif
#ifndef SQLITE_DISABLE_FTS3_UNICODE
 sqlite3Fts3UnicodeTokenizer(&pUnicode);
#endif
#ifdef SQLITE_TEST
 rc = sqlite3Fts3InitTerm(db);  if( rc!=SQLITE_OK ) return rc;
#endif
 rc = sqlite3Fts3InitAux(db);  if( rc!=SQLITE_OK ) return rc;  sqlite3Fts3SimpleTokenizerModule(&pSimple);  sqlite3Fts3PorterTokenizerModule(&pPorter);  pHash = sqlite3_malloc(sizeof(Fts3Hash));  if( !pHash ){  rc = SQLITE_NOMEM;  }else{  sqlite3Fts3HashInit(pHash, FTS3_HASH_STRING, 1);  }  if( rc==SQLITE_OK ){  if( sqlite3Fts3HashInsert(pHash, "simple", 7, (void *)pSimple)   || sqlite3Fts3HashInsert(pHash, "porter", 7, (void *)pPorter)
#ifndef SQLITE_DISABLE_FTS3_UNICODE
  || sqlite3Fts3HashInsert(pHash, "unicode61", 10, (void *)pUnicode)
#endif
#ifdef SQLITE_ENABLE_ICU
  || (pIcu && sqlite3Fts3HashInsert(pHash, "icu", 4, (void *)pIcu))
#endif
 ){  rc = SQLITE_NOMEM;  }  }
#ifdef SQLITE_TEST
 if( rc==SQLITE_OK ){  rc = sqlite3Fts3ExprInitTestInterface(db, pHash);  }
#endif
 if( SQLITE_OK==rc   && SQLITE_OK==(rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))   && SQLITE_OK==(rc = sqlite3_overload_function(db, "snippet", -1))   && SQLITE_OK==(rc = sqlite3_overload_function(db, "offsets", 1))   && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 1))   && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 2))   && SQLITE_OK==(rc = sqlite3_overload_function(db, "optimize", 1))  ){  rc = sqlite3_create_module_v2(  db, "fts3", &fts3Module, (void *)pHash, hashDestroy  );  if( rc==SQLITE_OK ){  rc = sqlite3_create_module_v2(  db, "fts4", &fts3Module, (void *)pHash, 0  );  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts3InitTok(db, (void *)pHash);  }  return rc;  }  assert( rc!=SQLITE_OK );  if( pHash ){  sqlite3Fts3HashClear(pHash);  sqlite3_free(pHash);  }  return rc; } static void fts3EvalAllocateReaders(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  int *pnToken,  int *pnOr,  int *pRc ){  if( pExpr && SQLITE_OK==*pRc ){  if( pExpr->eType==FTSQUERY_PHRASE ){  int i;  int nToken = pExpr->pPhrase->nToken;  *pnToken += nToken;  for(i=0; i<nToken; i++){  Fts3PhraseToken *pToken = &pExpr->pPhrase->aToken[i];  int rc = fts3TermSegReaderCursor(pCsr,  pToken->z, pToken->n, pToken->isPrefix, &pToken->pSegcsr  );  if( rc!=SQLITE_OK ){  *pRc = rc;  return;  }  }  assert( pExpr->pPhrase->iDoclistToken==0 );  pExpr->pPhrase->iDoclistToken = -1;  }else{  *pnOr += (pExpr->eType==FTSQUERY_OR);  fts3EvalAllocateReaders(pCsr, pExpr->pLeft, pnToken, pnOr, pRc);  fts3EvalAllocateReaders(pCsr, pExpr->pRight, pnToken, pnOr, pRc);  }  } } static int fts3EvalPhraseMergeToken(  Fts3Table *pTab,  Fts3Phrase *p,  int iToken,  char *pList,  int nList ){  int rc = SQLITE_OK;  assert( iToken!=p->iDoclistToken );  if( pList==0 ){  sqlite3_free(p->doclist.aAll);  p->doclist.aAll = 0;  p->doclist.nAll = 0;  }  else if( p->iDoclistToken<0 ){  p->doclist.aAll = pList;  p->doclist.nAll = nList;  }  else if( p->doclist.aAll==0 ){  sqlite3_free(pList);  }  else {  char *pLeft;  char *pRight;  int nLeft;  int nRight;  int nDiff;  if( p->iDoclistToken<iToken ){  pLeft = p->doclist.aAll;  nLeft = p->doclist.nAll;  pRight = pList;  nRight = nList;  nDiff = iToken - p->iDoclistToken;  }else{  pRight = p->doclist.aAll;  nRight = p->doclist.nAll;  pLeft = pList;  nLeft = nList;  nDiff = p->iDoclistToken - iToken;  }  rc = fts3DoclistPhraseMerge(  pTab->bDescIdx, nDiff, pLeft, nLeft, &pRight, &nRight  );  sqlite3_free(pLeft);  p->doclist.aAll = pRight;  p->doclist.nAll = nRight;  }  if( iToken>p->iDoclistToken ) p->iDoclistToken = iToken;  return rc; } static int fts3EvalPhraseLoad(  Fts3Cursor *pCsr,  Fts3Phrase *p ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int iToken;  int rc = SQLITE_OK;  for(iToken=0; rc==SQLITE_OK && iToken<p->nToken; iToken++){  Fts3PhraseToken *pToken = &p->aToken[iToken];  assert( pToken->pDeferred==0 || pToken->pSegcsr==0 );  if( pToken->pSegcsr ){  int nThis = 0;  char *pThis = 0;  rc = fts3TermSelect(pTab, pToken, p->iColumn, &nThis, &pThis);  if( rc==SQLITE_OK ){  rc = fts3EvalPhraseMergeToken(pTab, p, iToken, pThis, nThis);  }  }  assert( pToken->pSegcsr==0 );  }  return rc; }
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
static int fts3EvalDeferredPhrase(Fts3Cursor *pCsr, Fts3Phrase *pPhrase){  int iToken;  char *aPoslist = 0;  int nPoslist = 0;  int iPrev = -1;  assert( pPhrase->doclist.bFreeList==0 );  for(iToken=0; iToken<pPhrase->nToken; iToken++){  Fts3PhraseToken *pToken = &pPhrase->aToken[iToken];  Fts3DeferredToken *pDeferred = pToken->pDeferred;  if( pDeferred ){  char *pList;  int nList;  int rc = sqlite3Fts3DeferredTokenList(pDeferred, &pList, &nList);  if( rc!=SQLITE_OK ) return rc;  if( pList==0 ){  sqlite3_free(aPoslist);  pPhrase->doclist.pList = 0;  pPhrase->doclist.nList = 0;  return SQLITE_OK;  }else if( aPoslist==0 ){  aPoslist = pList;  nPoslist = nList;  }else{  char *aOut = pList;  char *p1 = aPoslist;  char *p2 = aOut;  assert( iPrev>=0 );  fts3PoslistPhraseMerge(&aOut, iToken-iPrev, 0, 1, &p1, &p2);  sqlite3_free(aPoslist);  aPoslist = pList;  nPoslist = (int)(aOut - aPoslist);  if( nPoslist==0 ){  sqlite3_free(aPoslist);  pPhrase->doclist.pList = 0;  pPhrase->doclist.nList = 0;  return SQLITE_OK;  }  }  iPrev = iToken;  }  }  if( iPrev>=0 ){  int nMaxUndeferred = pPhrase->iDoclistToken;  if( nMaxUndeferred<0 ){  pPhrase->doclist.pList = aPoslist;  pPhrase->doclist.nList = nPoslist;  pPhrase->doclist.iDocid = pCsr->iPrevId;  pPhrase->doclist.bFreeList = 1;  }else{  int nDistance;  char *p1;  char *p2;  char *aOut;  if( nMaxUndeferred>iPrev ){  p1 = aPoslist;  p2 = pPhrase->doclist.pList;  nDistance = nMaxUndeferred - iPrev;  }else{  p1 = pPhrase->doclist.pList;  p2 = aPoslist;  nDistance = iPrev - nMaxUndeferred;  }  aOut = (char *)sqlite3_malloc(nPoslist+8);  if( !aOut ){  sqlite3_free(aPoslist);  return SQLITE_NOMEM;  }  pPhrase->doclist.pList = aOut;  if( fts3PoslistPhraseMerge(&aOut, nDistance, 0, 1, &p1, &p2) ){  pPhrase->doclist.bFreeList = 1;  pPhrase->doclist.nList = (int)(aOut - pPhrase->doclist.pList);  }else{  sqlite3_free(aOut);  pPhrase->doclist.pList = 0;  pPhrase->doclist.nList = 0;  }  sqlite3_free(aPoslist);  }  }  return SQLITE_OK; }
#endif
#define MAX_INCR_PHRASE_TOKENS 4
static int fts3EvalPhraseStart(Fts3Cursor *pCsr, int bOptOk, Fts3Phrase *p){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int rc = SQLITE_OK;  int i;  int bHaveIncr = 0;  int bIncrOk = (bOptOk   && pCsr->bDesc==pTab->bDescIdx   && p->nToken<=MAX_INCR_PHRASE_TOKENS && p->nToken>0
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
  && pTab->bNoIncrDoclist==0
#endif
 );  for(i=0; bIncrOk==1 && i<p->nToken; i++){  Fts3PhraseToken *pToken = &p->aToken[i];  if( pToken->bFirst || (pToken->pSegcsr!=0 && !pToken->pSegcsr->bLookup) ){  bIncrOk = 0;  }  if( pToken->pSegcsr ) bHaveIncr = 1;  }  if( bIncrOk && bHaveIncr ){  int iCol = (p->iColumn >= pTab->nColumn ? -1 : p->iColumn);  for(i=0; rc==SQLITE_OK && i<p->nToken; i++){  Fts3PhraseToken *pToken = &p->aToken[i];  Fts3MultiSegReader *pSegcsr = pToken->pSegcsr;  if( pSegcsr ){  rc = sqlite3Fts3MsrIncrStart(pTab, pSegcsr, iCol, pToken->z, pToken->n);  }  }  p->bIncr = 1;  }else{  rc = fts3EvalPhraseLoad(pCsr, p);  p->bIncr = 0;  }  assert( rc!=SQLITE_OK || p->nToken<1 || p->aToken[0].pSegcsr==0 || p->bIncr );  return rc; } SQLITE_PRIVATE void sqlite3Fts3DoclistPrev(  int bDescIdx,  char *aDoclist,  int nDoclist,  char **ppIter,  sqlite3_int64 *piDocid,  int *pnList,  u8 *pbEof ){  char *p = *ppIter;  assert( nDoclist>0 );  assert( *pbEof==0 );  assert_fts3_nc( p || *piDocid==0 );  assert( !p || (p>aDoclist && p<&aDoclist[nDoclist]) );  if( p==0 ){  sqlite3_int64 iDocid = 0;  char *pNext = 0;  char *pDocid = aDoclist;  char *pEnd = &aDoclist[nDoclist];  int iMul = 1;  while( pDocid<pEnd ){  sqlite3_int64 iDelta;  pDocid += sqlite3Fts3GetVarint(pDocid, &iDelta);  iDocid += (iMul * iDelta);  pNext = pDocid;  fts3PoslistCopy(0, &pDocid);  while( pDocid<pEnd && *pDocid==0 ) pDocid++;  iMul = (bDescIdx ? -1 : 1);  }  *pnList = (int)(pEnd - pNext);  *ppIter = pNext;  *piDocid = iDocid;  }else{  int iMul = (bDescIdx ? -1 : 1);  sqlite3_int64 iDelta;  fts3GetReverseVarint(&p, aDoclist, &iDelta);  *piDocid -= (iMul * iDelta);  if( p==aDoclist ){  *pbEof = 1;  }else{  char *pSave = p;  fts3ReversePoslist(aDoclist, &p);  *pnList = (int)(pSave - p);  }  *ppIter = p;  } } SQLITE_PRIVATE void sqlite3Fts3DoclistNext(  int bDescIdx,  char *aDoclist,  int nDoclist,  char **ppIter,  sqlite3_int64 *piDocid,  u8 *pbEof ){  char *p = *ppIter;  assert( nDoclist>0 );  assert( *pbEof==0 );  assert_fts3_nc( p || *piDocid==0 );  assert( !p || (p>=aDoclist && p<=&aDoclist[nDoclist]) );  if( p==0 ){  p = aDoclist;  p += sqlite3Fts3GetVarint(p, piDocid);  }else{  fts3PoslistCopy(0, &p);  while( p<&aDoclist[nDoclist] && *p==0 ) p++;  if( p>=&aDoclist[nDoclist] ){  *pbEof = 1;  }else{  sqlite3_int64 iVar;  p += sqlite3Fts3GetVarint(p, &iVar);  *piDocid += ((bDescIdx ? -1 : 1) * iVar);  }  }  *ppIter = p; } static void fts3EvalDlPhraseNext(  Fts3Table *pTab,  Fts3Doclist *pDL,  u8 *pbEof ){  char *pIter;  char *pEnd;  if( pDL->pNextDocid ){  pIter = pDL->pNextDocid;  assert( pDL->aAll!=0 || pIter==0 );  }else{  pIter = pDL->aAll;  }  if( pIter==0 || pIter>=(pEnd = pDL->aAll + pDL->nAll) ){  *pbEof = 1;  }else{  sqlite3_int64 iDelta;  pIter += sqlite3Fts3GetVarint(pIter, &iDelta);  if( pTab->bDescIdx==0 || pDL->pNextDocid==0 ){  pDL->iDocid += iDelta;  }else{  pDL->iDocid -= iDelta;  }  pDL->pList = pIter;  fts3PoslistCopy(0, &pIter);  pDL->nList = (int)(pIter - pDL->pList);  while( pIter<pEnd && *pIter==0 ) pIter++;  pDL->pNextDocid = pIter;  assert( pIter>=&pDL->aAll[pDL->nAll] || *pIter );  *pbEof = 0;  } } typedef struct TokenDoclist TokenDoclist; struct TokenDoclist {  int bIgnore;  sqlite3_int64 iDocid;  char *pList;  int nList; }; static int incrPhraseTokenNext(  Fts3Table *pTab,  Fts3Phrase *pPhrase,  int iToken,  TokenDoclist *p,  u8 *pbEof ){  int rc = SQLITE_OK;  if( pPhrase->iDoclistToken==iToken ){  assert( p->bIgnore==0 );  assert( pPhrase->aToken[iToken].pSegcsr==0 );  fts3EvalDlPhraseNext(pTab, &pPhrase->doclist, pbEof);  p->pList = pPhrase->doclist.pList;  p->nList = pPhrase->doclist.nList;  p->iDocid = pPhrase->doclist.iDocid;  }else{  Fts3PhraseToken *pToken = &pPhrase->aToken[iToken];  assert( pToken->pDeferred==0 );  assert( pToken->pSegcsr || pPhrase->iDoclistToken>=0 );  if( pToken->pSegcsr ){  assert( p->bIgnore==0 );  rc = sqlite3Fts3MsrIncrNext(  pTab, pToken->pSegcsr, &p->iDocid, &p->pList, &p->nList  );  if( p->pList==0 ) *pbEof = 1;  }else{  p->bIgnore = 1;  }  }  return rc; } static int fts3EvalIncrPhraseNext(  Fts3Cursor *pCsr,  Fts3Phrase *p,  u8 *pbEof ){  int rc = SQLITE_OK;  Fts3Doclist *pDL = &p->doclist;  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  u8 bEof = 0;  assert( p->bIncr==1 );  if( p->nToken==1 ){  rc = sqlite3Fts3MsrIncrNext(pTab, p->aToken[0].pSegcsr,  &pDL->iDocid, &pDL->pList, &pDL->nList  );  if( pDL->pList==0 ) bEof = 1;  }else{  int bDescDoclist = pCsr->bDesc;  struct TokenDoclist a[MAX_INCR_PHRASE_TOKENS];  memset(a, 0, sizeof(a));  assert( p->nToken<=MAX_INCR_PHRASE_TOKENS );  assert( p->iDoclistToken<MAX_INCR_PHRASE_TOKENS );  while( bEof==0 ){  int bMaxSet = 0;  sqlite3_int64 iMax = 0;  int i;  for(i=0; rc==SQLITE_OK && i<p->nToken && bEof==0; i++){  rc = incrPhraseTokenNext(pTab, p, i, &a[i], &bEof);  if( a[i].bIgnore==0 && (bMaxSet==0 || DOCID_CMP(iMax, a[i].iDocid)<0) ){  iMax = a[i].iDocid;  bMaxSet = 1;  }  }  assert( rc!=SQLITE_OK || (p->nToken>=1 && a[p->nToken-1].bIgnore==0) );  assert( rc!=SQLITE_OK || bMaxSet );  for(i=0; i<p->nToken; i++){  while( rc==SQLITE_OK && bEof==0  && a[i].bIgnore==0 && DOCID_CMP(a[i].iDocid, iMax)<0  ){  rc = incrPhraseTokenNext(pTab, p, i, &a[i], &bEof);  if( DOCID_CMP(a[i].iDocid, iMax)>0 ){  iMax = a[i].iDocid;  i = 0;  }  }  }  if( bEof==0 ){  int nList = 0;  int nByte = a[p->nToken-1].nList;  char *aDoclist = sqlite3_malloc(nByte+FTS3_BUFFER_PADDING);  if( !aDoclist ) return SQLITE_NOMEM;  memcpy(aDoclist, a[p->nToken-1].pList, nByte+1);  memset(&aDoclist[nByte], 0, FTS3_BUFFER_PADDING);  for(i=0; i<(p->nToken-1); i++){  if( a[i].bIgnore==0 ){  char *pL = a[i].pList;  char *pR = aDoclist;  char *pOut = aDoclist;  int nDist = p->nToken-1-i;  int res = fts3PoslistPhraseMerge(&pOut, nDist, 0, 1, &pL, &pR);  if( res==0 ) break;  nList = (int)(pOut - aDoclist);  }  }  if( i==(p->nToken-1) ){  pDL->iDocid = iMax;  pDL->pList = aDoclist;  pDL->nList = nList;  pDL->bFreeList = 1;  break;  }  sqlite3_free(aDoclist);  }  }  }  *pbEof = bEof;  return rc; } static int fts3EvalPhraseNext(  Fts3Cursor *pCsr,  Fts3Phrase *p,  u8 *pbEof ){  int rc = SQLITE_OK;  Fts3Doclist *pDL = &p->doclist;  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  if( p->bIncr ){  rc = fts3EvalIncrPhraseNext(pCsr, p, pbEof);  }else if( pCsr->bDesc!=pTab->bDescIdx && pDL->nAll ){  sqlite3Fts3DoclistPrev(pTab->bDescIdx, pDL->aAll, pDL->nAll,  &pDL->pNextDocid, &pDL->iDocid, &pDL->nList, pbEof  );  pDL->pList = pDL->pNextDocid;  }else{  fts3EvalDlPhraseNext(pTab, pDL, pbEof);  }  return rc; } static void fts3EvalStartReaders(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  int *pRc ){  if( pExpr && SQLITE_OK==*pRc ){  if( pExpr->eType==FTSQUERY_PHRASE ){  int nToken = pExpr->pPhrase->nToken;  if( nToken ){  int i;  for(i=0; i<nToken; i++){  if( pExpr->pPhrase->aToken[i].pDeferred==0 ) break;  }  pExpr->bDeferred = (i==nToken);  }  *pRc = fts3EvalPhraseStart(pCsr, 1, pExpr->pPhrase);  }else{  fts3EvalStartReaders(pCsr, pExpr->pLeft, pRc);  fts3EvalStartReaders(pCsr, pExpr->pRight, pRc);  pExpr->bDeferred = (pExpr->pLeft->bDeferred && pExpr->pRight->bDeferred);  }  } } typedef struct Fts3TokenAndCost Fts3TokenAndCost; struct Fts3TokenAndCost {  Fts3Phrase *pPhrase;  int iToken;  Fts3PhraseToken *pToken;  Fts3Expr *pRoot;  int nOvfl;  int iCol; }; static void fts3EvalTokenCosts(  Fts3Cursor *pCsr,  Fts3Expr *pRoot,  Fts3Expr *pExpr,  Fts3TokenAndCost **ppTC,  Fts3Expr ***ppOr,  int *pRc ){  if( *pRc==SQLITE_OK ){  if( pExpr->eType==FTSQUERY_PHRASE ){  Fts3Phrase *pPhrase = pExpr->pPhrase;  int i;  for(i=0; *pRc==SQLITE_OK && i<pPhrase->nToken; i++){  Fts3TokenAndCost *pTC = (*ppTC)++;  pTC->pPhrase = pPhrase;  pTC->iToken = i;  pTC->pRoot = pRoot;  pTC->pToken = &pPhrase->aToken[i];  pTC->iCol = pPhrase->iColumn;  *pRc = sqlite3Fts3MsrOvfl(pCsr, pTC->pToken->pSegcsr, &pTC->nOvfl);  }  }else if( pExpr->eType!=FTSQUERY_NOT ){  assert( pExpr->eType==FTSQUERY_OR   || pExpr->eType==FTSQUERY_AND   || pExpr->eType==FTSQUERY_NEAR  );  assert( pExpr->pLeft && pExpr->pRight );  if( pExpr->eType==FTSQUERY_OR ){  pRoot = pExpr->pLeft;  **ppOr = pRoot;  (*ppOr)++;  }  fts3EvalTokenCosts(pCsr, pRoot, pExpr->pLeft, ppTC, ppOr, pRc);  if( pExpr->eType==FTSQUERY_OR ){  pRoot = pExpr->pRight;  **ppOr = pRoot;  (*ppOr)++;  }  fts3EvalTokenCosts(pCsr, pRoot, pExpr->pRight, ppTC, ppOr, pRc);  }  } } static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage){  int rc = SQLITE_OK;  if( pCsr->nRowAvg==0 ){  Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;  sqlite3_stmt *pStmt;  sqlite3_int64 nDoc = 0;  sqlite3_int64 nByte = 0;  const char *pEnd;  const char *a;  rc = sqlite3Fts3SelectDoctotal(p, &pStmt);  if( rc!=SQLITE_OK ) return rc;  a = sqlite3_column_blob(pStmt, 0);  testcase( a==0 );  if( a ){  pEnd = &a[sqlite3_column_bytes(pStmt, 0)];  a += sqlite3Fts3GetVarintBounded(a, pEnd, &nDoc);  while( a<pEnd ){  a += sqlite3Fts3GetVarintBounded(a, pEnd, &nByte);  }  }  if( nDoc==0 || nByte==0 ){  sqlite3_reset(pStmt);  return FTS_CORRUPT_VTAB;  }  pCsr->nDoc = nDoc;  pCsr->nRowAvg = (int)(((nByte / nDoc) + p->nPgsz) / p->nPgsz);  assert( pCsr->nRowAvg>0 );  rc = sqlite3_reset(pStmt);  }  *pnPage = pCsr->nRowAvg;  return rc; } static int fts3EvalSelectDeferred(  Fts3Cursor *pCsr,  Fts3Expr *pRoot,  Fts3TokenAndCost *aTC,  int nTC ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int nDocSize = 0;  int rc = SQLITE_OK;  int ii;  int nOvfl = 0;  int nToken = 0;  int nMinEst = 0;  int nLoad4 = 1;  if( pTab->zContentTbl ){  return SQLITE_OK;  }  for(ii=0; ii<nTC; ii++){  if( aTC[ii].pRoot==pRoot ){  nOvfl += aTC[ii].nOvfl;  nToken++;  }  }  if( nOvfl==0 || nToken<2 ) return SQLITE_OK;  rc = fts3EvalAverageDocsize(pCsr, &nDocSize);  assert( rc!=SQLITE_OK || nDocSize>0 );  for(ii=0; ii<nToken && rc==SQLITE_OK; ii++){  int iTC;  Fts3TokenAndCost *pTC = 0;  for(iTC=0; iTC<nTC; iTC++){  if( aTC[iTC].pToken && aTC[iTC].pRoot==pRoot   && (!pTC || aTC[iTC].nOvfl<pTC->nOvfl)  ){  pTC = &aTC[iTC];  }  }  assert( pTC );  if( ii && pTC->nOvfl>=((nMinEst+(nLoad4/4)-1)/(nLoad4/4))*nDocSize ){  Fts3PhraseToken *pToken = pTC->pToken;  rc = sqlite3Fts3DeferToken(pCsr, pToken, pTC->iCol);  fts3SegReaderCursorFree(pToken->pSegcsr);  pToken->pSegcsr = 0;  }else{  if( ii<12 ) nLoad4 = nLoad4*4;  if( ii==0 || (pTC->pPhrase->nToken>1 && ii!=nToken-1) ){  Fts3PhraseToken *pToken = pTC->pToken;  int nList = 0;  char *pList = 0;  rc = fts3TermSelect(pTab, pToken, pTC->iCol, &nList, &pList);  assert( rc==SQLITE_OK || pList==0 );  if( rc==SQLITE_OK ){  rc = fts3EvalPhraseMergeToken(  pTab, pTC->pPhrase, pTC->iToken,pList,nList  );  }  if( rc==SQLITE_OK ){  int nCount;  nCount = fts3DoclistCountDocids(  pTC->pPhrase->doclist.aAll, pTC->pPhrase->doclist.nAll  );  if( ii==0 || nCount<nMinEst ) nMinEst = nCount;  }  }  }  pTC->pToken = 0;  }  return rc; } static int fts3EvalStart(Fts3Cursor *pCsr){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int rc = SQLITE_OK;  int nToken = 0;  int nOr = 0;  fts3EvalAllocateReaders(pCsr, pCsr->pExpr, &nToken, &nOr, &rc);
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
 if( rc==SQLITE_OK && nToken>1 && pTab->bFts4 ){  Fts3TokenAndCost *aTC;  aTC = (Fts3TokenAndCost *)sqlite3_malloc64(  sizeof(Fts3TokenAndCost) * nToken  + sizeof(Fts3Expr *) * nOr * 2  );  if( !aTC ){  rc = SQLITE_NOMEM;  }else{  Fts3Expr **apOr = (Fts3Expr **)&aTC[nToken];  int ii;  Fts3TokenAndCost *pTC = aTC;  Fts3Expr **ppOr = apOr;  fts3EvalTokenCosts(pCsr, 0, pCsr->pExpr, &pTC, &ppOr, &rc);  nToken = (int)(pTC-aTC);  nOr = (int)(ppOr-apOr);  if( rc==SQLITE_OK ){  rc = fts3EvalSelectDeferred(pCsr, 0, aTC, nToken);  for(ii=0; rc==SQLITE_OK && ii<nOr; ii++){  rc = fts3EvalSelectDeferred(pCsr, apOr[ii], aTC, nToken);  }  }  sqlite3_free(aTC);  }  }
#endif
 fts3EvalStartReaders(pCsr, pCsr->pExpr, &rc);  return rc; } static void fts3EvalInvalidatePoslist(Fts3Phrase *pPhrase){  if( pPhrase->doclist.bFreeList ){  sqlite3_free(pPhrase->doclist.pList);  }  pPhrase->doclist.pList = 0;  pPhrase->doclist.nList = 0;  pPhrase->doclist.bFreeList = 0; } static int fts3EvalNearTrim(  int nNear,  char *aTmp,  char **paPoslist,  int *pnToken,  Fts3Phrase *pPhrase ){  int nParam1 = nNear + pPhrase->nToken;  int nParam2 = nNear + *pnToken;  int nNew;  char *p2;  char *pOut;  int res;  assert( pPhrase->doclist.pList );  p2 = pOut = pPhrase->doclist.pList;  res = fts3PoslistNearMerge(  &pOut, aTmp, nParam1, nParam2, paPoslist, &p2  );  if( res ){  nNew = (int)(pOut - pPhrase->doclist.pList) - 1;  assert_fts3_nc( nNew<=pPhrase->doclist.nList && nNew>0 );  if( nNew>=0 && nNew<=pPhrase->doclist.nList ){  assert( pPhrase->doclist.pList[nNew]=='\0' );  memset(&pPhrase->doclist.pList[nNew], 0, pPhrase->doclist.nList - nNew);  pPhrase->doclist.nList = nNew;  }  *paPoslist = pPhrase->doclist.pList;  *pnToken = pPhrase->nToken;  }  return res; } static void fts3EvalNextRow(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  int *pRc ){  if( *pRc==SQLITE_OK ){  int bDescDoclist = pCsr->bDesc;  assert( pExpr->bEof==0 );  pExpr->bStart = 1;  switch( pExpr->eType ){  case FTSQUERY_NEAR:  case FTSQUERY_AND: {  Fts3Expr *pLeft = pExpr->pLeft;  Fts3Expr *pRight = pExpr->pRight;  assert( !pLeft->bDeferred || !pRight->bDeferred );  if( pLeft->bDeferred ){  fts3EvalNextRow(pCsr, pRight, pRc);  pExpr->iDocid = pRight->iDocid;  pExpr->bEof = pRight->bEof;  }else if( pRight->bDeferred ){  fts3EvalNextRow(pCsr, pLeft, pRc);  pExpr->iDocid = pLeft->iDocid;  pExpr->bEof = pLeft->bEof;  }else{  fts3EvalNextRow(pCsr, pLeft, pRc);  fts3EvalNextRow(pCsr, pRight, pRc);  while( !pLeft->bEof && !pRight->bEof && *pRc==SQLITE_OK ){  sqlite3_int64 iDiff = DOCID_CMP(pLeft->iDocid, pRight->iDocid);  if( iDiff==0 ) break;  if( iDiff<0 ){  fts3EvalNextRow(pCsr, pLeft, pRc);  }else{  fts3EvalNextRow(pCsr, pRight, pRc);  }  }  pExpr->iDocid = pLeft->iDocid;  pExpr->bEof = (pLeft->bEof || pRight->bEof);  if( pExpr->eType==FTSQUERY_NEAR && pExpr->bEof ){  assert( pRight->eType==FTSQUERY_PHRASE );  if( pRight->pPhrase->doclist.aAll ){  Fts3Doclist *pDl = &pRight->pPhrase->doclist;  while( *pRc==SQLITE_OK && pRight->bEof==0 ){  memset(pDl->pList, 0, pDl->nList);  fts3EvalNextRow(pCsr, pRight, pRc);  }  }  if( pLeft->pPhrase && pLeft->pPhrase->doclist.aAll ){  Fts3Doclist *pDl = &pLeft->pPhrase->doclist;  while( *pRc==SQLITE_OK && pLeft->bEof==0 ){  memset(pDl->pList, 0, pDl->nList);  fts3EvalNextRow(pCsr, pLeft, pRc);  }  }  pRight->bEof = pLeft->bEof = 1;  }  }  break;  }  case FTSQUERY_OR: {  Fts3Expr *pLeft = pExpr->pLeft;  Fts3Expr *pRight = pExpr->pRight;  sqlite3_int64 iCmp = DOCID_CMP(pLeft->iDocid, pRight->iDocid);  assert_fts3_nc( pLeft->bStart || pLeft->iDocid==pRight->iDocid );  assert_fts3_nc( pRight->bStart || pLeft->iDocid==pRight->iDocid );  if( pRight->bEof || (pLeft->bEof==0 && iCmp<0) ){  fts3EvalNextRow(pCsr, pLeft, pRc);  }else if( pLeft->bEof || iCmp>0 ){  fts3EvalNextRow(pCsr, pRight, pRc);  }else{  fts3EvalNextRow(pCsr, pLeft, pRc);  fts3EvalNextRow(pCsr, pRight, pRc);  }  pExpr->bEof = (pLeft->bEof && pRight->bEof);  iCmp = DOCID_CMP(pLeft->iDocid, pRight->iDocid);  if( pRight->bEof || (pLeft->bEof==0 && iCmp<0) ){  pExpr->iDocid = pLeft->iDocid;  }else{  pExpr->iDocid = pRight->iDocid;  }  break;  }  case FTSQUERY_NOT: {  Fts3Expr *pLeft = pExpr->pLeft;  Fts3Expr *pRight = pExpr->pRight;  if( pRight->bStart==0 ){  fts3EvalNextRow(pCsr, pRight, pRc);  assert( *pRc!=SQLITE_OK || pRight->bStart );  }  fts3EvalNextRow(pCsr, pLeft, pRc);  if( pLeft->bEof==0 ){  while( !*pRc  && !pRight->bEof  && DOCID_CMP(pLeft->iDocid, pRight->iDocid)>0  ){  fts3EvalNextRow(pCsr, pRight, pRc);  }  }  pExpr->iDocid = pLeft->iDocid;  pExpr->bEof = pLeft->bEof;  break;  }  default: {  Fts3Phrase *pPhrase = pExpr->pPhrase;  fts3EvalInvalidatePoslist(pPhrase);  *pRc = fts3EvalPhraseNext(pCsr, pPhrase, &pExpr->bEof);  pExpr->iDocid = pPhrase->doclist.iDocid;  break;  }  }  } } static int fts3EvalNearTest(Fts3Expr *pExpr, int *pRc){  int res = 1;  if( *pRc==SQLITE_OK   && pExpr->eType==FTSQUERY_NEAR   && (pExpr->pParent==0 || pExpr->pParent->eType!=FTSQUERY_NEAR)  ){  Fts3Expr *p;  sqlite3_int64 nTmp = 0;  char *aTmp;  for(p=pExpr; p->pLeft; p=p->pLeft){  assert( p->pRight->pPhrase->doclist.nList>0 );  nTmp += p->pRight->pPhrase->doclist.nList;  }  nTmp += p->pPhrase->doclist.nList;  aTmp = sqlite3_malloc64(nTmp*2);  if( !aTmp ){  *pRc = SQLITE_NOMEM;  res = 0;  }else{  char *aPoslist = p->pPhrase->doclist.pList;  int nToken = p->pPhrase->nToken;  for(p=p->pParent;res && p && p->eType==FTSQUERY_NEAR; p=p->pParent){  Fts3Phrase *pPhrase = p->pRight->pPhrase;  int nNear = p->nNear;  res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);  }  aPoslist = pExpr->pRight->pPhrase->doclist.pList;  nToken = pExpr->pRight->pPhrase->nToken;  for(p=pExpr->pLeft; p && res; p=p->pLeft){  int nNear;  Fts3Phrase *pPhrase;  assert( p->pParent && p->pParent->pLeft==p );  nNear = p->pParent->nNear;  pPhrase = (  p->eType==FTSQUERY_NEAR ? p->pRight->pPhrase : p->pPhrase  );  res = fts3EvalNearTrim(nNear, aTmp, &aPoslist, &nToken, pPhrase);  }  }  sqlite3_free(aTmp);  }  return res; } static int fts3EvalTestExpr(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  int *pRc ){  int bHit = 1;  if( *pRc==SQLITE_OK ){  switch( pExpr->eType ){  case FTSQUERY_NEAR:  case FTSQUERY_AND:  bHit = (  fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc)   && fts3EvalTestExpr(pCsr, pExpr->pRight, pRc)   && fts3EvalNearTest(pExpr, pRc)  );  if( bHit==0   && pExpr->eType==FTSQUERY_NEAR   && (pExpr->pParent==0 || pExpr->pParent->eType!=FTSQUERY_NEAR)  ){  Fts3Expr *p;  for(p=pExpr; p->pPhrase==0; p=p->pLeft){  if( p->pRight->iDocid==pCsr->iPrevId ){  fts3EvalInvalidatePoslist(p->pRight->pPhrase);  }  }  if( p->iDocid==pCsr->iPrevId ){  fts3EvalInvalidatePoslist(p->pPhrase);  }  }  break;  case FTSQUERY_OR: {  int bHit1 = fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc);  int bHit2 = fts3EvalTestExpr(pCsr, pExpr->pRight, pRc);  bHit = bHit1 || bHit2;  break;  }  case FTSQUERY_NOT:  bHit = (  fts3EvalTestExpr(pCsr, pExpr->pLeft, pRc)   && !fts3EvalTestExpr(pCsr, pExpr->pRight, pRc)  );  break;  default: {
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
 if( pCsr->pDeferred   && (pExpr->iDocid==pCsr->iPrevId || pExpr->bDeferred)  ){  Fts3Phrase *pPhrase = pExpr->pPhrase;  assert( pExpr->bDeferred || pPhrase->doclist.bFreeList==0 );  if( pExpr->bDeferred ){  fts3EvalInvalidatePoslist(pPhrase);  }  *pRc = fts3EvalDeferredPhrase(pCsr, pPhrase);  bHit = (pPhrase->doclist.pList!=0);  pExpr->iDocid = pCsr->iPrevId;  }else
#endif
 {  bHit = (  pExpr->bEof==0 && pExpr->iDocid==pCsr->iPrevId   && pExpr->pPhrase->doclist.nList>0  );  }  break;  }  }  }  return bHit; } SQLITE_PRIVATE int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc){  int rc = *pRc;  int bMiss = 0;  if( rc==SQLITE_OK ){  if( pCsr->pDeferred ){  rc = fts3CursorSeek(0, pCsr);  if( rc==SQLITE_OK ){  rc = sqlite3Fts3CacheDeferredDoclists(pCsr);  }  }  bMiss = (0==fts3EvalTestExpr(pCsr, pCsr->pExpr, &rc));  sqlite3Fts3FreeDeferredDoclists(pCsr);  *pRc = rc;  }  return (rc==SQLITE_OK && bMiss); } static int fts3EvalNext(Fts3Cursor *pCsr){  int rc = SQLITE_OK;  Fts3Expr *pExpr = pCsr->pExpr;  assert( pCsr->isEof==0 );  if( pExpr==0 ){  pCsr->isEof = 1;  }else{  do {  if( pCsr->isRequireSeek==0 ){  sqlite3_reset(pCsr->pStmt);  }  assert( sqlite3_data_count(pCsr->pStmt)==0 );  fts3EvalNextRow(pCsr, pExpr, &rc);  pCsr->isEof = pExpr->bEof;  pCsr->isRequireSeek = 1;  pCsr->isMatchinfoNeeded = 1;  pCsr->iPrevId = pExpr->iDocid;  }while( pCsr->isEof==0 && sqlite3Fts3EvalTestDeferred(pCsr, &rc) );  }  if( rc==SQLITE_OK && (  (pCsr->bDesc==0 && pCsr->iPrevId>pCsr->iMaxDocid)   || (pCsr->bDesc!=0 && pCsr->iPrevId<pCsr->iMinDocid)  )){  pCsr->isEof = 1;  }  return rc; } static void fts3EvalRestart(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  int *pRc ){  if( pExpr && *pRc==SQLITE_OK ){  Fts3Phrase *pPhrase = pExpr->pPhrase;  if( pPhrase ){  fts3EvalInvalidatePoslist(pPhrase);  if( pPhrase->bIncr ){  int i;  for(i=0; i<pPhrase->nToken; i++){  Fts3PhraseToken *pToken = &pPhrase->aToken[i];  assert( pToken->pDeferred==0 );  if( pToken->pSegcsr ){  sqlite3Fts3MsrIncrRestart(pToken->pSegcsr);  }  }  *pRc = fts3EvalPhraseStart(pCsr, 0, pPhrase);  }  pPhrase->doclist.pNextDocid = 0;  pPhrase->doclist.iDocid = 0;  pPhrase->pOrPoslist = 0;  }  pExpr->iDocid = 0;  pExpr->bEof = 0;  pExpr->bStart = 0;  fts3EvalRestart(pCsr, pExpr->pLeft, pRc);  fts3EvalRestart(pCsr, pExpr->pRight, pRc);  } } static void fts3EvalUpdateCounts(Fts3Expr *pExpr, int nCol){  if( pExpr ){  Fts3Phrase *pPhrase = pExpr->pPhrase;  if( pPhrase && pPhrase->doclist.pList ){  int iCol = 0;  char *p = pPhrase->doclist.pList;  do{  u8 c = 0;  int iCnt = 0;  while( 0xFE & (*p | c) ){  if( (c&0x80)==0 ) iCnt++;  c = *p++ & 0x80;  }  pExpr->aMI[iCol*3 + 1] += iCnt;  pExpr->aMI[iCol*3 + 2] += (iCnt>0);  if( *p==0x00 ) break;  p++;  p += fts3GetVarint32(p, &iCol);  }while( iCol<nCol );  }  fts3EvalUpdateCounts(pExpr->pLeft, nCol);  fts3EvalUpdateCounts(pExpr->pRight, nCol);  } } static int fts3EvalGatherStats(  Fts3Cursor *pCsr,  Fts3Expr *pExpr ){  int rc = SQLITE_OK;  assert( pExpr->eType==FTSQUERY_PHRASE );  if( pExpr->aMI==0 ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  Fts3Expr *pRoot;  Fts3Expr *p;  sqlite3_int64 iPrevId = pCsr->iPrevId;  sqlite3_int64 iDocid;  u8 bEof;  pRoot = pExpr;  while( pRoot->pParent && pRoot->pParent->eType==FTSQUERY_NEAR ){  pRoot = pRoot->pParent;  }  iDocid = pRoot->iDocid;  bEof = pRoot->bEof;  assert( pRoot->bStart );  for(p=pRoot; p; p=p->pLeft){  Fts3Expr *pE = (p->eType==FTSQUERY_PHRASE?p:p->pRight);  assert( pE->aMI==0 );  pE->aMI = (u32 *)sqlite3_malloc64(pTab->nColumn * 3 * sizeof(u32));  if( !pE->aMI ) return SQLITE_NOMEM;  memset(pE->aMI, 0, pTab->nColumn * 3 * sizeof(u32));  }  fts3EvalRestart(pCsr, pRoot, &rc);  while( pCsr->isEof==0 && rc==SQLITE_OK ){  do {  if( pCsr->isRequireSeek==0 ) sqlite3_reset(pCsr->pStmt);  assert( sqlite3_data_count(pCsr->pStmt)==0 );  fts3EvalNextRow(pCsr, pRoot, &rc);  pCsr->isEof = pRoot->bEof;  pCsr->isRequireSeek = 1;  pCsr->isMatchinfoNeeded = 1;  pCsr->iPrevId = pRoot->iDocid;  }while( pCsr->isEof==0   && pRoot->eType==FTSQUERY_NEAR   && sqlite3Fts3EvalTestDeferred(pCsr, &rc)  );  if( rc==SQLITE_OK && pCsr->isEof==0 ){  fts3EvalUpdateCounts(pRoot, pTab->nColumn);  }  }  pCsr->isEof = 0;  pCsr->iPrevId = iPrevId;  if( bEof ){  pRoot->bEof = bEof;  }else{  fts3EvalRestart(pCsr, pRoot, &rc);  do {  fts3EvalNextRow(pCsr, pRoot, &rc);  assert_fts3_nc( pRoot->bEof==0 );  if( pRoot->bEof ) rc = FTS_CORRUPT_VTAB;  }while( pRoot->iDocid!=iDocid && rc==SQLITE_OK );  }  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3EvalPhraseStats(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  u32 *aiOut ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int rc = SQLITE_OK;  int iCol;  if( pExpr->bDeferred && pExpr->pParent->eType!=FTSQUERY_NEAR ){  assert( pCsr->nDoc>0 );  for(iCol=0; iCol<pTab->nColumn; iCol++){  aiOut[iCol*3 + 1] = (u32)pCsr->nDoc;  aiOut[iCol*3 + 2] = (u32)pCsr->nDoc;  }  }else{  rc = fts3EvalGatherStats(pCsr, pExpr);  if( rc==SQLITE_OK ){  assert( pExpr->aMI );  for(iCol=0; iCol<pTab->nColumn; iCol++){  aiOut[iCol*3 + 1] = pExpr->aMI[iCol*3 + 1];  aiOut[iCol*3 + 2] = pExpr->aMI[iCol*3 + 2];  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3EvalPhrasePoslist(  Fts3Cursor *pCsr,  Fts3Expr *pExpr,  int iCol,  char **ppOut ){  Fts3Phrase *pPhrase = pExpr->pPhrase;  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  char *pIter;  int iThis;  sqlite3_int64 iDocid;  *ppOut = 0;  assert( iCol>=0 && iCol<pTab->nColumn );  if( (pPhrase->iColumn<pTab->nColumn && pPhrase->iColumn!=iCol) ){  return SQLITE_OK;  }  iDocid = pExpr->iDocid;  pIter = pPhrase->doclist.pList;  if( iDocid!=pCsr->iPrevId || pExpr->bEof ){  int rc = SQLITE_OK;  int bDescDoclist = pTab->bDescIdx;  int bOr = 0;  u8 bTreeEof = 0;  Fts3Expr *p;  Fts3Expr *pNear;  int bMatch;  pNear = pExpr;  for(p=pExpr->pParent; p; p=p->pParent){  if( p->eType==FTSQUERY_OR ) bOr = 1;  if( p->eType==FTSQUERY_NEAR ) pNear = p;  if( p->bEof ) bTreeEof = 1;  }  if( bOr==0 ) return SQLITE_OK;  if( pPhrase->bIncr ){  int bEofSave = pNear->bEof;  fts3EvalRestart(pCsr, pNear, &rc);  while( rc==SQLITE_OK && !pNear->bEof ){  fts3EvalNextRow(pCsr, pNear, &rc);  if( bEofSave==0 && pNear->iDocid==iDocid ) break;  }  assert( rc!=SQLITE_OK || pPhrase->bIncr==0 );  if( rc==SQLITE_OK && pNear->bEof!=bEofSave ){  rc = FTS_CORRUPT_VTAB;  }  }  if( bTreeEof ){  while( rc==SQLITE_OK && !pNear->bEof ){  fts3EvalNextRow(pCsr, pNear, &rc);  }  }  if( rc!=SQLITE_OK ) return rc;  bMatch = 1;  for(p=pNear; p; p=p->pLeft){  u8 bEof = 0;  Fts3Expr *pTest = p;  Fts3Phrase *pPh;  assert( pTest->eType==FTSQUERY_NEAR || pTest->eType==FTSQUERY_PHRASE );  if( pTest->eType==FTSQUERY_NEAR ) pTest = pTest->pRight;  assert( pTest->eType==FTSQUERY_PHRASE );  pPh = pTest->pPhrase;  pIter = pPh->pOrPoslist;  iDocid = pPh->iOrDocid;  if( pCsr->bDesc==bDescDoclist ){  bEof = !pPh->doclist.nAll ||  (pIter >= (pPh->doclist.aAll + pPh->doclist.nAll));  while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)<0 ) && bEof==0 ){  sqlite3Fts3DoclistNext(  bDescDoclist, pPh->doclist.aAll, pPh->doclist.nAll,  &pIter, &iDocid, &bEof  );  }  }else{  bEof = !pPh->doclist.nAll || (pIter && pIter<=pPh->doclist.aAll);  while( (pIter==0 || DOCID_CMP(iDocid, pCsr->iPrevId)>0 ) && bEof==0 ){  int dummy;  sqlite3Fts3DoclistPrev(  bDescDoclist, pPh->doclist.aAll, pPh->doclist.nAll,  &pIter, &iDocid, &dummy, &bEof  );  }  }  pPh->pOrPoslist = pIter;  pPh->iOrDocid = iDocid;  if( bEof || iDocid!=pCsr->iPrevId ) bMatch = 0;  }  if( bMatch ){  pIter = pPhrase->pOrPoslist;  }else{  pIter = 0;  }  }  if( pIter==0 ) return SQLITE_OK;  if( *pIter==0x01 ){  pIter++;  pIter += fts3GetVarint32(pIter, &iThis);  }else{  iThis = 0;  }  while( iThis<iCol ){  fts3ColumnlistCopy(0, &pIter);  if( *pIter==0x00 ) return SQLITE_OK;  pIter++;  pIter += fts3GetVarint32(pIter, &iThis);  }  if( *pIter==0x00 ){  pIter = 0;  }  *ppOut = ((iCol==iThis)?pIter:0);  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *pPhrase){  if( pPhrase ){  int i;  sqlite3_free(pPhrase->doclist.aAll);  fts3EvalInvalidatePoslist(pPhrase);  memset(&pPhrase->doclist, 0, sizeof(Fts3Doclist));  for(i=0; i<pPhrase->nToken; i++){  fts3SegReaderCursorFree(pPhrase->aToken[i].pSegcsr);  pPhrase->aToken[i].pSegcsr = 0;  }  } }
#ifdef SQLITE_DEBUG
SQLITE_PRIVATE int sqlite3Fts3Corrupt(){  return SQLITE_CORRUPT_VTAB; }
#endif
#if !SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_fts3_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  SQLITE_EXTENSION_INIT2(pApi)  return sqlite3Fts3Init(db); }
#endif
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
typedef struct Fts3auxTable Fts3auxTable; typedef struct Fts3auxCursor Fts3auxCursor; struct Fts3auxTable {  sqlite3_vtab base;  Fts3Table *pFts3Tab; }; struct Fts3auxCursor {  sqlite3_vtab_cursor base;  Fts3MultiSegReader csr;  Fts3SegFilter filter;  char *zStop;  int nStop;  int iLangid;  int isEof;  sqlite3_int64 iRowid;  int iCol;  int nStat;  struct Fts3auxColstats {  sqlite3_int64 nDoc;  sqlite3_int64 nOcc;  } *aStat; };
#define FTS3_AUX_SCHEMA  "CREATE TABLE x(term, col, documents, occurrences, languageid HIDDEN)"

static int fts3auxConnectMethod(  sqlite3 *db,  void *pUnused,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  char const *zDb;  char const *zFts3;  int nDb;  int nFts3;  sqlite3_int64 nByte;  int rc;  Fts3auxTable *p;  UNUSED_PARAMETER(pUnused);  if( argc!=4 && argc!=5 ) goto bad_args;  zDb = argv[1];  nDb = (int)strlen(zDb);  if( argc==5 ){  if( nDb==4 && 0==sqlite3_strnicmp("temp", zDb, 4) ){  zDb = argv[3];  nDb = (int)strlen(zDb);  zFts3 = argv[4];  }else{  goto bad_args;  }  }else{  zFts3 = argv[3];  }  nFts3 = (int)strlen(zFts3);  rc = sqlite3_declare_vtab(db, FTS3_AUX_SCHEMA);  if( rc!=SQLITE_OK ) return rc;  nByte = sizeof(Fts3auxTable) + sizeof(Fts3Table) + nDb + nFts3 + 2;  p = (Fts3auxTable *)sqlite3_malloc64(nByte);  if( !p ) return SQLITE_NOMEM;  memset(p, 0, nByte);  p->pFts3Tab = (Fts3Table *)&p[1];  p->pFts3Tab->zDb = (char *)&p->pFts3Tab[1];  p->pFts3Tab->zName = &p->pFts3Tab->zDb[nDb+1];  p->pFts3Tab->db = db;  p->pFts3Tab->nIndex = 1;  memcpy((char *)p->pFts3Tab->zDb, zDb, nDb);  memcpy((char *)p->pFts3Tab->zName, zFts3, nFts3);  sqlite3Fts3Dequote((char *)p->pFts3Tab->zName);  *ppVtab = (sqlite3_vtab *)p;  return SQLITE_OK;  bad_args:  sqlite3Fts3ErrMsg(pzErr, "invalid arguments to fts4aux constructor");  return SQLITE_ERROR; } static int fts3auxDisconnectMethod(sqlite3_vtab *pVtab){  Fts3auxTable *p = (Fts3auxTable *)pVtab;  Fts3Table *pFts3 = p->pFts3Tab;  int i;  for(i=0; i<SizeofArray(pFts3->aStmt); i++){  sqlite3_finalize(pFts3->aStmt[i]);  }  sqlite3_free(pFts3->zSegmentsTbl);  sqlite3_free(p);  return SQLITE_OK; }
#define FTS4AUX_EQ_CONSTRAINT 1
#define FTS4AUX_GE_CONSTRAINT 2
#define FTS4AUX_LE_CONSTRAINT 4
static int fts3auxBestIndexMethod(  sqlite3_vtab *pVTab,  sqlite3_index_info *pInfo ){  int i;  int iEq = -1;  int iGe = -1;  int iLe = -1;  int iLangid = -1;  int iNext = 1;  UNUSED_PARAMETER(pVTab);  if( pInfo->nOrderBy==1   && pInfo->aOrderBy[0].iColumn==0   && pInfo->aOrderBy[0].desc==0  ){  pInfo->orderByConsumed = 1;  }  for(i=0; i<pInfo->nConstraint; i++){  if( pInfo->aConstraint[i].usable ){  int op = pInfo->aConstraint[i].op;  int iCol = pInfo->aConstraint[i].iColumn;  if( iCol==0 ){  if( op==SQLITE_INDEX_CONSTRAINT_EQ ) iEq = i;  if( op==SQLITE_INDEX_CONSTRAINT_LT ) iLe = i;  if( op==SQLITE_INDEX_CONSTRAINT_LE ) iLe = i;  if( op==SQLITE_INDEX_CONSTRAINT_GT ) iGe = i;  if( op==SQLITE_INDEX_CONSTRAINT_GE ) iGe = i;  }  if( iCol==4 ){  if( op==SQLITE_INDEX_CONSTRAINT_EQ ) iLangid = i;  }  }  }  if( iEq>=0 ){  pInfo->idxNum = FTS4AUX_EQ_CONSTRAINT;  pInfo->aConstraintUsage[iEq].argvIndex = iNext++;  pInfo->estimatedCost = 5;  }else{  pInfo->idxNum = 0;  pInfo->estimatedCost = 20000;  if( iGe>=0 ){  pInfo->idxNum += FTS4AUX_GE_CONSTRAINT;  pInfo->aConstraintUsage[iGe].argvIndex = iNext++;  pInfo->estimatedCost /= 2;  }  if( iLe>=0 ){  pInfo->idxNum += FTS4AUX_LE_CONSTRAINT;  pInfo->aConstraintUsage[iLe].argvIndex = iNext++;  pInfo->estimatedCost /= 2;  }  }  if( iLangid>=0 ){  pInfo->aConstraintUsage[iLangid].argvIndex = iNext++;  pInfo->estimatedCost--;  }  return SQLITE_OK; } static int fts3auxOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){  Fts3auxCursor *pCsr;  UNUSED_PARAMETER(pVTab);  pCsr = (Fts3auxCursor *)sqlite3_malloc(sizeof(Fts3auxCursor));  if( !pCsr ) return SQLITE_NOMEM;  memset(pCsr, 0, sizeof(Fts3auxCursor));  *ppCsr = (sqlite3_vtab_cursor *)pCsr;  return SQLITE_OK; } static int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor){  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;  sqlite3Fts3SegmentsClose(pFts3);  sqlite3Fts3SegReaderFinish(&pCsr->csr);  sqlite3_free((void *)pCsr->filter.zTerm);  sqlite3_free(pCsr->zStop);  sqlite3_free(pCsr->aStat);  sqlite3_free(pCsr);  return SQLITE_OK; } static int fts3auxGrowStatArray(Fts3auxCursor *pCsr, int nSize){  if( nSize>pCsr->nStat ){  struct Fts3auxColstats *aNew;  aNew = (struct Fts3auxColstats *)sqlite3_realloc64(pCsr->aStat,  sizeof(struct Fts3auxColstats) * nSize  );  if( aNew==0 ) return SQLITE_NOMEM;  memset(&aNew[pCsr->nStat], 0,  sizeof(struct Fts3auxColstats) * (nSize - pCsr->nStat)  );  pCsr->aStat = aNew;  pCsr->nStat = nSize;  }  return SQLITE_OK; } static int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor){  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;  int rc;  pCsr->iRowid++;  for(pCsr->iCol++; pCsr->iCol<pCsr->nStat; pCsr->iCol++){  if( pCsr->aStat[pCsr->iCol].nDoc>0 ) return SQLITE_OK;  }  rc = sqlite3Fts3SegReaderStep(pFts3, &pCsr->csr);  if( rc==SQLITE_ROW ){  int i = 0;  int nDoclist = pCsr->csr.nDoclist;  char *aDoclist = pCsr->csr.aDoclist;  int iCol;  int eState = 0;  if( pCsr->zStop ){  int n = (pCsr->nStop<pCsr->csr.nTerm) ? pCsr->nStop : pCsr->csr.nTerm;  int mc = memcmp(pCsr->zStop, pCsr->csr.zTerm, n);  if( mc<0 || (mc==0 && pCsr->csr.nTerm>pCsr->nStop) ){  pCsr->isEof = 1;  return SQLITE_OK;  }  }  if( fts3auxGrowStatArray(pCsr, 2) ) return SQLITE_NOMEM;  memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);  iCol = 0;  rc = SQLITE_OK;  while( i<nDoclist ){  sqlite3_int64 v = 0;  i += sqlite3Fts3GetVarint(&aDoclist[i], &v);  switch( eState ){  case 0:  pCsr->aStat[0].nDoc++;  eState = 1;  iCol = 0;  break;  case 1:  assert( iCol==0 );  if( v>1 ){  pCsr->aStat[1].nDoc++;  }  eState = 2;  case 2:  if( v==0 ){  eState = 0;  }else if( v==1 ){  eState = 3;  }else{  pCsr->aStat[iCol+1].nOcc++;  pCsr->aStat[0].nOcc++;  }  break;  default: assert( eState==3 );  iCol = (int)v;  if( iCol<1 ){  rc = SQLITE_CORRUPT_VTAB;  break;  }  if( fts3auxGrowStatArray(pCsr, iCol+2) ) return SQLITE_NOMEM;  pCsr->aStat[iCol+1].nDoc++;  eState = 2;  break;  }  }  pCsr->iCol = 0;  }else{  pCsr->isEof = 1;  }  return rc; } static int fts3auxFilterMethod(  sqlite3_vtab_cursor *pCursor,  int idxNum,  const char *idxStr,  int nVal,  sqlite3_value **apVal ){  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;  int rc;  int isScan = 0;  int iLangVal = 0;  int iEq = -1;  int iGe = -1;  int iLe = -1;  int iLangid = -1;  int iNext = 0;  UNUSED_PARAMETER(nVal);  UNUSED_PARAMETER(idxStr);  assert( idxStr==0 );  assert( idxNum==FTS4AUX_EQ_CONSTRAINT || idxNum==0   || idxNum==FTS4AUX_LE_CONSTRAINT || idxNum==FTS4AUX_GE_CONSTRAINT   || idxNum==(FTS4AUX_LE_CONSTRAINT|FTS4AUX_GE_CONSTRAINT)  );  if( idxNum==FTS4AUX_EQ_CONSTRAINT ){  iEq = iNext++;  }else{  isScan = 1;  if( idxNum & FTS4AUX_GE_CONSTRAINT ){  iGe = iNext++;  }  if( idxNum & FTS4AUX_LE_CONSTRAINT ){  iLe = iNext++;  }  }  if( iNext<nVal ){  iLangid = iNext++;  }  testcase(pCsr->filter.zTerm);  sqlite3Fts3SegReaderFinish(&pCsr->csr);  sqlite3_free((void *)pCsr->filter.zTerm);  sqlite3_free(pCsr->aStat);  sqlite3_free(pCsr->zStop);  memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);  pCsr->filter.flags = FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;  if( isScan ) pCsr->filter.flags |= FTS3_SEGMENT_SCAN;  if( iEq>=0 || iGe>=0 ){  const unsigned char *zStr = sqlite3_value_text(apVal[0]);  assert( (iEq==0 && iGe==-1) || (iEq==-1 && iGe==0) );  if( zStr ){  pCsr->filter.zTerm = sqlite3_mprintf("%s", zStr);  if( pCsr->filter.zTerm==0 ) return SQLITE_NOMEM;  pCsr->filter.nTerm = (int)strlen(pCsr->filter.zTerm);  }  }  if( iLe>=0 ){  pCsr->zStop = sqlite3_mprintf("%s", sqlite3_value_text(apVal[iLe]));  if( pCsr->zStop==0 ) return SQLITE_NOMEM;  pCsr->nStop = (int)strlen(pCsr->zStop);  }  if( iLangid>=0 ){  iLangVal = sqlite3_value_int(apVal[iLangid]);  if( iLangVal<0 ) iLangVal = 0;  }  pCsr->iLangid = iLangVal;  rc = sqlite3Fts3SegReaderCursor(pFts3, iLangVal, 0, FTS3_SEGCURSOR_ALL,  pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr  );  if( rc==SQLITE_OK ){  rc = sqlite3Fts3SegReaderStart(pFts3, &pCsr->csr, &pCsr->filter);  }  if( rc==SQLITE_OK ) rc = fts3auxNextMethod(pCursor);  return rc; } static int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor){  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;  return pCsr->isEof; } static int fts3auxColumnMethod(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *pCtx,  int iCol ){  Fts3auxCursor *p = (Fts3auxCursor *)pCursor;  assert( p->isEof==0 );  switch( iCol ){  case 0:  sqlite3_result_text(pCtx, p->csr.zTerm, p->csr.nTerm, SQLITE_TRANSIENT);  break;  case 1:  if( p->iCol ){  sqlite3_result_int(pCtx, p->iCol-1);  }else{  sqlite3_result_text(pCtx, "*", -1, SQLITE_STATIC);  }  break;  case 2:  sqlite3_result_int64(pCtx, p->aStat[p->iCol].nDoc);  break;  case 3:  sqlite3_result_int64(pCtx, p->aStat[p->iCol].nOcc);  break;  default:  assert( iCol==4 );  sqlite3_result_int(pCtx, p->iLangid);  break;  }  return SQLITE_OK; } static int fts3auxRowidMethod(  sqlite3_vtab_cursor *pCursor,  sqlite_int64 *pRowid ){  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;  *pRowid = pCsr->iRowid;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3InitAux(sqlite3 *db){  static const sqlite3_module fts3aux_module = {   0,   fts3auxConnectMethod,   fts3auxConnectMethod,   fts3auxBestIndexMethod,   fts3auxDisconnectMethod,   fts3auxDisconnectMethod,   fts3auxOpenMethod,   fts3auxCloseMethod,   fts3auxFilterMethod,   fts3auxNextMethod,   fts3auxEofMethod,   fts3auxColumnMethod,   fts3auxRowidMethod,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0  };  int rc;  rc = sqlite3_create_module(db, "fts4aux", &fts3aux_module, 0);  return rc; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#ifdef SQLITE_TEST
SQLITE_API int sqlite3_fts3_enable_parentheses = 0;
#else
# ifdef SQLITE_ENABLE_FTS3_PARENTHESIS
# define sqlite3_fts3_enable_parentheses 1
# else
# define sqlite3_fts3_enable_parentheses 0
# endif
#endif
#define SQLITE_FTS3_DEFAULT_NEAR_PARAM 10
typedef struct ParseContext ParseContext; struct ParseContext {  sqlite3_tokenizer *pTokenizer;  int iLangid;  const char **azCol;  int bFts4;  int nCol;  int iDefaultCol;  int isNot;  sqlite3_context *pCtx;  int nNest; }; static int fts3isspace(char c){  return c==' ' || c=='\t' || c=='\n' || c=='\r' || c=='\v' || c=='\f'; } SQLITE_PRIVATE void *sqlite3Fts3MallocZero(sqlite3_int64 nByte){  void *pRet = sqlite3_malloc64(nByte);  if( pRet ) memset(pRet, 0, nByte);  return pRet; } SQLITE_PRIVATE int sqlite3Fts3OpenTokenizer(  sqlite3_tokenizer *pTokenizer,  int iLangid,  const char *z,  int n,  sqlite3_tokenizer_cursor **ppCsr ){  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;  sqlite3_tokenizer_cursor *pCsr = 0;  int rc;  rc = pModule->xOpen(pTokenizer, z, n, &pCsr);  assert( rc==SQLITE_OK || pCsr==0 );  if( rc==SQLITE_OK ){  pCsr->pTokenizer = pTokenizer;  if( pModule->iVersion>=1 ){  rc = pModule->xLanguageid(pCsr, iLangid);  if( rc!=SQLITE_OK ){  pModule->xClose(pCsr);  pCsr = 0;  }  }  }  *ppCsr = pCsr;  return rc; } static int fts3ExprParse(ParseContext *, const char *, int, Fts3Expr **, int *); static int getNextToken(  ParseContext *pParse,  int iCol,  const char *z, int n,  Fts3Expr **ppExpr,  int *pnConsumed ){  sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;  int rc;  sqlite3_tokenizer_cursor *pCursor;  Fts3Expr *pRet = 0;  int i = 0;  for(i=0; i<n; i++){  if( sqlite3_fts3_enable_parentheses && (z[i]=='(' || z[i]==')') ) break;  if( z[i]=='"' ) break;  }  *pnConsumed = i;  rc = sqlite3Fts3OpenTokenizer(pTokenizer, pParse->iLangid, z, i, &pCursor);  if( rc==SQLITE_OK ){  const char *zToken;  int nToken = 0, iStart = 0, iEnd = 0, iPosition = 0;  sqlite3_int64 nByte;  rc = pModule->xNext(pCursor, &zToken, &nToken, &iStart, &iEnd, &iPosition);  if( rc==SQLITE_OK ){  nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase) + nToken;  pRet = (Fts3Expr *)sqlite3Fts3MallocZero(nByte);  if( !pRet ){  rc = SQLITE_NOMEM;  }else{  pRet->eType = FTSQUERY_PHRASE;  pRet->pPhrase = (Fts3Phrase *)&pRet[1];  pRet->pPhrase->nToken = 1;  pRet->pPhrase->iColumn = iCol;  pRet->pPhrase->aToken[0].n = nToken;  pRet->pPhrase->aToken[0].z = (char *)&pRet->pPhrase[1];  memcpy(pRet->pPhrase->aToken[0].z, zToken, nToken);  if( iEnd<n && z[iEnd]=='*' ){  pRet->pPhrase->aToken[0].isPrefix = 1;  iEnd++;  }  while( 1 ){  if( !sqlite3_fts3_enable_parentheses   && iStart>0 && z[iStart-1]=='-'  ){  pParse->isNot = 1;  iStart--;  }else if( pParse->bFts4 && iStart>0 && z[iStart-1]=='^' ){  pRet->pPhrase->aToken[0].bFirst = 1;  iStart--;  }else{  break;  }  }  }  *pnConsumed = iEnd;  }else if( i && rc==SQLITE_DONE ){  rc = SQLITE_OK;  }  pModule->xClose(pCursor);  }  *ppExpr = pRet;  return rc; } static void *fts3ReallocOrFree(void *pOrig, sqlite3_int64 nNew){  void *pRet = sqlite3_realloc64(pOrig, nNew);  if( !pRet ){  sqlite3_free(pOrig);  }  return pRet; } static int getNextString(  ParseContext *pParse,  const char *zInput, int nInput,  Fts3Expr **ppExpr ){  sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;  int rc;  Fts3Expr *p = 0;  sqlite3_tokenizer_cursor *pCursor = 0;  char *zTemp = 0;  int nTemp = 0;  const int nSpace = sizeof(Fts3Expr) + sizeof(Fts3Phrase);  int nToken = 0;  rc = sqlite3Fts3OpenTokenizer(  pTokenizer, pParse->iLangid, zInput, nInput, &pCursor);  if( rc==SQLITE_OK ){  int ii;  for(ii=0; rc==SQLITE_OK; ii++){  const char *zByte;  int nByte = 0, iBegin = 0, iEnd = 0, iPos = 0;  rc = pModule->xNext(pCursor, &zByte, &nByte, &iBegin, &iEnd, &iPos);  if( rc==SQLITE_OK ){  Fts3PhraseToken *pToken;  p = fts3ReallocOrFree(p, nSpace + ii*sizeof(Fts3PhraseToken));  if( !p ) goto no_mem;  zTemp = fts3ReallocOrFree(zTemp, nTemp + nByte);  if( !zTemp ) goto no_mem;  assert( nToken==ii );  pToken = &((Fts3Phrase *)(&p[1]))->aToken[ii];  memset(pToken, 0, sizeof(Fts3PhraseToken));  memcpy(&zTemp[nTemp], zByte, nByte);  nTemp += nByte;  pToken->n = nByte;  pToken->isPrefix = (iEnd<nInput && zInput[iEnd]=='*');  pToken->bFirst = (iBegin>0 && zInput[iBegin-1]=='^');  nToken = ii+1;  }  }  pModule->xClose(pCursor);  pCursor = 0;  }  if( rc==SQLITE_DONE ){  int jj;  char *zBuf = 0;  p = fts3ReallocOrFree(p, nSpace + nToken*sizeof(Fts3PhraseToken) + nTemp);  if( !p ) goto no_mem;  memset(p, 0, (char *)&(((Fts3Phrase *)&p[1])->aToken[0])-(char *)p);  p->eType = FTSQUERY_PHRASE;  p->pPhrase = (Fts3Phrase *)&p[1];  p->pPhrase->iColumn = pParse->iDefaultCol;  p->pPhrase->nToken = nToken;  zBuf = (char *)&p->pPhrase->aToken[nToken];  if( zTemp ){  memcpy(zBuf, zTemp, nTemp);  sqlite3_free(zTemp);  }else{  assert( nTemp==0 );  }  for(jj=0; jj<p->pPhrase->nToken; jj++){  p->pPhrase->aToken[jj].z = zBuf;  zBuf += p->pPhrase->aToken[jj].n;  }  rc = SQLITE_OK;  }  *ppExpr = p;  return rc;
no_mem:  if( pCursor ){  pModule->xClose(pCursor);  }  sqlite3_free(zTemp);  sqlite3_free(p);  *ppExpr = 0;  return SQLITE_NOMEM; } static int getNextNode(  ParseContext *pParse,  const char *z, int n,  Fts3Expr **ppExpr,  int *pnConsumed ){  static const struct Fts3Keyword {  char *z;  unsigned char n;  unsigned char parenOnly;  unsigned char eType;  } aKeyword[] = {  { "OR" , 2, 0, FTSQUERY_OR  },  { "AND", 3, 1, FTSQUERY_AND },  { "NOT", 3, 1, FTSQUERY_NOT },  { "NEAR", 4, 0, FTSQUERY_NEAR }  };  int ii;  int iCol;  int iColLen;  int rc;  Fts3Expr *pRet = 0;  const char *zInput = z;  int nInput = n;  pParse->isNot = 0;  while( nInput>0 && fts3isspace(*zInput) ){  nInput--;  zInput++;  }  if( nInput==0 ){  return SQLITE_DONE;  }  for(ii=0; ii<(int)(sizeof(aKeyword)/sizeof(struct Fts3Keyword)); ii++){  const struct Fts3Keyword *pKey = &aKeyword[ii];  if( (pKey->parenOnly & ~sqlite3_fts3_enable_parentheses)!=0 ){  continue;  }  if( nInput>=pKey->n && 0==memcmp(zInput, pKey->z, pKey->n) ){  int nNear = SQLITE_FTS3_DEFAULT_NEAR_PARAM;  int nKey = pKey->n;  char cNext;  if( pKey->eType==FTSQUERY_NEAR ){  assert( nKey==4 );  if( zInput[4]=='/' && zInput[5]>='0' && zInput[5]<='9' ){  nKey += 1+sqlite3Fts3ReadInt(&zInput[nKey+1], &nNear);  }  }  cNext = zInput[nKey];  if( fts3isspace(cNext)   || cNext=='"' || cNext=='(' || cNext==')' || cNext==0  ){  pRet = (Fts3Expr *)sqlite3Fts3MallocZero(sizeof(Fts3Expr));  if( !pRet ){  return SQLITE_NOMEM;  }  pRet->eType = pKey->eType;  pRet->nNear = nNear;  *ppExpr = pRet;  *pnConsumed = (int)((zInput - z) + nKey);  return SQLITE_OK;  }  }  }  if( *zInput=='"' ){  for(ii=1; ii<nInput && zInput[ii]!='"'; ii++);  *pnConsumed = (int)((zInput - z) + ii + 1);  if( ii==nInput ){  return SQLITE_ERROR;  }  return getNextString(pParse, &zInput[1], ii-1, ppExpr);  }  if( sqlite3_fts3_enable_parentheses ){  if( *zInput=='(' ){  int nConsumed = 0;  pParse->nNest++;
#if !defined(SQLITE_MAX_EXPR_DEPTH)
 if( pParse->nNest>1000 ) return SQLITE_ERROR;
#elif SQLITE_MAX_EXPR_DEPTH>0
 if( pParse->nNest>SQLITE_MAX_EXPR_DEPTH ) return SQLITE_ERROR;
#endif
 rc = fts3ExprParse(pParse, zInput+1, nInput-1, ppExpr, &nConsumed);  *pnConsumed = (int)(zInput - z) + 1 + nConsumed;  return rc;  }else if( *zInput==')' ){  pParse->nNest--;  *pnConsumed = (int)((zInput - z) + 1);  *ppExpr = 0;  return SQLITE_DONE;  }  }  iCol = pParse->iDefaultCol;  iColLen = 0;  for(ii=0; ii<pParse->nCol; ii++){  const char *zStr = pParse->azCol[ii];  int nStr = (int)strlen(zStr);  if( nInput>nStr && zInput[nStr]==':'   && sqlite3_strnicmp(zStr, zInput, nStr)==0  ){  iCol = ii;  iColLen = (int)((zInput - z) + nStr + 1);  break;  }  }  rc = getNextToken(pParse, iCol, &z[iColLen], n-iColLen, ppExpr, pnConsumed);  *pnConsumed += iColLen;  return rc; } static int opPrecedence(Fts3Expr *p){  assert( p->eType!=FTSQUERY_PHRASE );  if( sqlite3_fts3_enable_parentheses ){  return p->eType;  }else if( p->eType==FTSQUERY_NEAR ){  return 1;  }else if( p->eType==FTSQUERY_OR ){  return 2;  }  assert( p->eType==FTSQUERY_AND );  return 3; } static void insertBinaryOperator(  Fts3Expr **ppHead,  Fts3Expr *pPrev,  Fts3Expr *pNew ){  Fts3Expr *pSplit = pPrev;  while( pSplit->pParent && opPrecedence(pSplit->pParent)<=opPrecedence(pNew) ){  pSplit = pSplit->pParent;  }  if( pSplit->pParent ){  assert( pSplit->pParent->pRight==pSplit );  pSplit->pParent->pRight = pNew;  pNew->pParent = pSplit->pParent;  }else{  *ppHead = pNew;  }  pNew->pLeft = pSplit;  pSplit->pParent = pNew; } static int fts3ExprParse(  ParseContext *pParse,  const char *z, int n,  Fts3Expr **ppExpr,  int *pnConsumed ){  Fts3Expr *pRet = 0;  Fts3Expr *pPrev = 0;  Fts3Expr *pNotBranch = 0;  int nIn = n;  const char *zIn = z;  int rc = SQLITE_OK;  int isRequirePhrase = 1;  while( rc==SQLITE_OK ){  Fts3Expr *p = 0;  int nByte = 0;  rc = getNextNode(pParse, zIn, nIn, &p, &nByte);  assert( nByte>0 || (rc!=SQLITE_OK && p==0) );  if( rc==SQLITE_OK ){  if( p ){  int isPhrase;  if( !sqlite3_fts3_enable_parentheses  && p->eType==FTSQUERY_PHRASE && pParse->isNot  ){  Fts3Expr *pNot = sqlite3Fts3MallocZero(sizeof(Fts3Expr));  if( !pNot ){  sqlite3Fts3ExprFree(p);  rc = SQLITE_NOMEM;  goto exprparse_out;  }  pNot->eType = FTSQUERY_NOT;  pNot->pRight = p;  p->pParent = pNot;  if( pNotBranch ){  pNot->pLeft = pNotBranch;  pNotBranch->pParent = pNot;  }  pNotBranch = pNot;  p = pPrev;  }else{  int eType = p->eType;  isPhrase = (eType==FTSQUERY_PHRASE || p->pLeft);  if( !isPhrase && isRequirePhrase ){  sqlite3Fts3ExprFree(p);  rc = SQLITE_ERROR;  goto exprparse_out;  }  if( isPhrase && !isRequirePhrase ){  Fts3Expr *pAnd;  assert( pRet && pPrev );  pAnd = sqlite3Fts3MallocZero(sizeof(Fts3Expr));  if( !pAnd ){  sqlite3Fts3ExprFree(p);  rc = SQLITE_NOMEM;  goto exprparse_out;  }  pAnd->eType = FTSQUERY_AND;  insertBinaryOperator(&pRet, pPrev, pAnd);  pPrev = pAnd;  }  if( pPrev && (  (eType==FTSQUERY_NEAR && !isPhrase && pPrev->eType!=FTSQUERY_PHRASE)   || (eType!=FTSQUERY_PHRASE && isPhrase && pPrev->eType==FTSQUERY_NEAR)  )){  sqlite3Fts3ExprFree(p);  rc = SQLITE_ERROR;  goto exprparse_out;  }  if( isPhrase ){  if( pRet ){  assert( pPrev && pPrev->pLeft && pPrev->pRight==0 );  pPrev->pRight = p;  p->pParent = pPrev;  }else{  pRet = p;  }  }else{  insertBinaryOperator(&pRet, pPrev, p);  }  isRequirePhrase = !isPhrase;  }  pPrev = p;  }  assert( nByte>0 );  }  assert( rc!=SQLITE_OK || (nByte>0 && nByte<=nIn) );  nIn -= nByte;  zIn += nByte;  }  if( rc==SQLITE_DONE && pRet && isRequirePhrase ){  rc = SQLITE_ERROR;  }  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  if( !sqlite3_fts3_enable_parentheses && pNotBranch ){  if( !pRet ){  rc = SQLITE_ERROR;  }else{  Fts3Expr *pIter = pNotBranch;  while( pIter->pLeft ){  pIter = pIter->pLeft;  }  pIter->pLeft = pRet;  pRet->pParent = pIter;  pRet = pNotBranch;  }  }  }  *pnConsumed = n - nIn; exprparse_out:  if( rc!=SQLITE_OK ){  sqlite3Fts3ExprFree(pRet);  sqlite3Fts3ExprFree(pNotBranch);  pRet = 0;  }  *ppExpr = pRet;  return rc; } static int fts3ExprCheckDepth(Fts3Expr *p, int nMaxDepth){  int rc = SQLITE_OK;  if( p ){  if( nMaxDepth<0 ){  rc = SQLITE_TOOBIG;  }else{  rc = fts3ExprCheckDepth(p->pLeft, nMaxDepth-1);  if( rc==SQLITE_OK ){  rc = fts3ExprCheckDepth(p->pRight, nMaxDepth-1);  }  }  }  return rc; } static int fts3ExprBalance(Fts3Expr **pp, int nMaxDepth){  int rc = SQLITE_OK;  Fts3Expr *pRoot = *pp;  Fts3Expr *pFree = 0;  int eType = pRoot->eType;  if( nMaxDepth==0 ){  rc = SQLITE_ERROR;  }  if( rc==SQLITE_OK ){  if( (eType==FTSQUERY_AND || eType==FTSQUERY_OR) ){  Fts3Expr **apLeaf;  apLeaf = (Fts3Expr **)sqlite3_malloc64(sizeof(Fts3Expr *) * nMaxDepth);  if( 0==apLeaf ){  rc = SQLITE_NOMEM;  }else{  memset(apLeaf, 0, sizeof(Fts3Expr *) * nMaxDepth);  }  if( rc==SQLITE_OK ){  int i;  Fts3Expr *p;  for(p=pRoot; p->eType==eType; p=p->pLeft){  assert( p->pParent==0 || p->pParent->pLeft==p );  assert( p->pLeft && p->pRight );  }  while( 1 ){  int iLvl;  Fts3Expr *pParent = p->pParent;  assert( pParent==0 || pParent->pLeft==p );  p->pParent = 0;  if( pParent ){  pParent->pLeft = 0;  }else{  pRoot = 0;  }  rc = fts3ExprBalance(&p, nMaxDepth-1);  if( rc!=SQLITE_OK ) break;  for(iLvl=0; p && iLvl<nMaxDepth; iLvl++){  if( apLeaf[iLvl]==0 ){  apLeaf[iLvl] = p;  p = 0;  }else{  assert( pFree );  pFree->pLeft = apLeaf[iLvl];  pFree->pRight = p;  pFree->pLeft->pParent = pFree;  pFree->pRight->pParent = pFree;  p = pFree;  pFree = pFree->pParent;  p->pParent = 0;  apLeaf[iLvl] = 0;  }  }  if( p ){  sqlite3Fts3ExprFree(p);  rc = SQLITE_TOOBIG;  break;  }  if( pParent==0 ) break;  for(p=pParent->pRight; p->eType==eType; p=p->pLeft);  assert( pParent->pParent==0 || pParent->pParent->pLeft==pParent );  pParent->pRight->pParent = pParent->pParent;  if( pParent->pParent ){  pParent->pParent->pLeft = pParent->pRight;  }else{  assert( pParent==pRoot );  pRoot = pParent->pRight;  }  pParent->pParent = pFree;  pFree = pParent;  }  if( rc==SQLITE_OK ){  p = 0;  for(i=0; i<nMaxDepth; i++){  if( apLeaf[i] ){  if( p==0 ){  p = apLeaf[i];  p->pParent = 0;  }else{  assert( pFree!=0 );  pFree->pRight = p;  pFree->pLeft = apLeaf[i];  pFree->pLeft->pParent = pFree;  pFree->pRight->pParent = pFree;  p = pFree;  pFree = pFree->pParent;  p->pParent = 0;  }  }  }  pRoot = p;  }else{  Fts3Expr *pDel;  for(i=0; i<nMaxDepth; i++){  sqlite3Fts3ExprFree(apLeaf[i]);  }  while( (pDel=pFree)!=0 ){  pFree = pDel->pParent;  sqlite3_free(pDel);  }  }  assert( pFree==0 );  sqlite3_free( apLeaf );  }  }else if( eType==FTSQUERY_NOT ){  Fts3Expr *pLeft = pRoot->pLeft;  Fts3Expr *pRight = pRoot->pRight;  pRoot->pLeft = 0;  pRoot->pRight = 0;  pLeft->pParent = 0;  pRight->pParent = 0;  rc = fts3ExprBalance(&pLeft, nMaxDepth-1);  if( rc==SQLITE_OK ){  rc = fts3ExprBalance(&pRight, nMaxDepth-1);  }  if( rc!=SQLITE_OK ){  sqlite3Fts3ExprFree(pRight);  sqlite3Fts3ExprFree(pLeft);  }else{  assert( pLeft && pRight );  pRoot->pLeft = pLeft;  pLeft->pParent = pRoot;  pRoot->pRight = pRight;  pRight->pParent = pRoot;  }  }  }  if( rc!=SQLITE_OK ){  sqlite3Fts3ExprFree(pRoot);  pRoot = 0;  }  *pp = pRoot;  return rc; } static int fts3ExprParseUnbalanced(  sqlite3_tokenizer *pTokenizer,  int iLangid,  char **azCol,  int bFts4,  int nCol,  int iDefaultCol,  const char *z, int n,  Fts3Expr **ppExpr ){  int nParsed;  int rc;  ParseContext sParse;  memset(&sParse, 0, sizeof(ParseContext));  sParse.pTokenizer = pTokenizer;  sParse.iLangid = iLangid;  sParse.azCol = (const char **)azCol;  sParse.nCol = nCol;  sParse.iDefaultCol = iDefaultCol;  sParse.bFts4 = bFts4;  if( z==0 ){  *ppExpr = 0;  return SQLITE_OK;  }  if( n<0 ){  n = (int)strlen(z);  }  rc = fts3ExprParse(&sParse, z, n, ppExpr, &nParsed);  assert( rc==SQLITE_OK || *ppExpr==0 );  if( rc==SQLITE_OK && sParse.nNest ){  rc = SQLITE_ERROR;  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3ExprParse(  sqlite3_tokenizer *pTokenizer,  int iLangid,  char **azCol,  int bFts4,  int nCol,  int iDefaultCol,  const char *z, int n,  Fts3Expr **ppExpr,  char **pzErr ){  int rc = fts3ExprParseUnbalanced(  pTokenizer, iLangid, azCol, bFts4, nCol, iDefaultCol, z, n, ppExpr  );  if( rc==SQLITE_OK && *ppExpr ){  rc = fts3ExprBalance(ppExpr, SQLITE_FTS3_MAX_EXPR_DEPTH);  if( rc==SQLITE_OK ){  rc = fts3ExprCheckDepth(*ppExpr, SQLITE_FTS3_MAX_EXPR_DEPTH);  }  }  if( rc!=SQLITE_OK ){  sqlite3Fts3ExprFree(*ppExpr);  *ppExpr = 0;  if( rc==SQLITE_TOOBIG ){  sqlite3Fts3ErrMsg(pzErr,  "FTS expression tree is too large (maximum depth %d)",  SQLITE_FTS3_MAX_EXPR_DEPTH  );  rc = SQLITE_ERROR;  }else if( rc==SQLITE_ERROR ){  sqlite3Fts3ErrMsg(pzErr, "malformed MATCH expression: [%s]", z);  }  }  return rc; } static void fts3FreeExprNode(Fts3Expr *p){  assert( p->eType==FTSQUERY_PHRASE || p->pPhrase==0 );  sqlite3Fts3EvalPhraseCleanup(p->pPhrase);  sqlite3_free(p->aMI);  sqlite3_free(p); } SQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *pDel){  Fts3Expr *p;  assert( pDel==0 || pDel->pParent==0 );  for(p=pDel; p && (p->pLeft||p->pRight); p=(p->pLeft ? p->pLeft : p->pRight)){  assert( p->pParent==0 || p==p->pParent->pRight || p==p->pParent->pLeft );  }  while( p ){  Fts3Expr *pParent = p->pParent;  fts3FreeExprNode(p);  if( pParent && p==pParent->pLeft && pParent->pRight ){  p = pParent->pRight;  while( p && (p->pLeft || p->pRight) ){  assert( p==p->pParent->pRight || p==p->pParent->pLeft );  p = (p->pLeft ? p->pLeft : p->pRight);  }  }else{  p = pParent;  }  } }
#ifdef SQLITE_TEST
static char *exprToString(Fts3Expr *pExpr, char *zBuf){  if( pExpr==0 ){  return sqlite3_mprintf("");  }  switch( pExpr->eType ){  case FTSQUERY_PHRASE: {  Fts3Phrase *pPhrase = pExpr->pPhrase;  int i;  zBuf = sqlite3_mprintf(  "%zPHRASE %d 0", zBuf, pPhrase->iColumn);  for(i=0; zBuf && i<pPhrase->nToken; i++){  zBuf = sqlite3_mprintf("%z %.*s%s", zBuf,  pPhrase->aToken[i].n, pPhrase->aToken[i].z,  (pPhrase->aToken[i].isPrefix?"+":"")  );  }  return zBuf;  }  case FTSQUERY_NEAR:  zBuf = sqlite3_mprintf("%zNEAR/%d ", zBuf, pExpr->nNear);  break;  case FTSQUERY_NOT:  zBuf = sqlite3_mprintf("%zNOT ", zBuf);  break;  case FTSQUERY_AND:  zBuf = sqlite3_mprintf("%zAND ", zBuf);  break;  case FTSQUERY_OR:  zBuf = sqlite3_mprintf("%zOR ", zBuf);  break;  }  if( zBuf ) zBuf = sqlite3_mprintf("%z{", zBuf);  if( zBuf ) zBuf = exprToString(pExpr->pLeft, zBuf);  if( zBuf ) zBuf = sqlite3_mprintf("%z} {", zBuf);  if( zBuf ) zBuf = exprToString(pExpr->pRight, zBuf);  if( zBuf ) zBuf = sqlite3_mprintf("%z}", zBuf);  return zBuf; } static void fts3ExprTestCommon(  int bRebalance,  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  sqlite3_tokenizer *pTokenizer = 0;  int rc;  char **azCol = 0;  const char *zExpr;  int nExpr;  int nCol;  int ii;  Fts3Expr *pExpr;  char *zBuf = 0;  Fts3Hash *pHash = (Fts3Hash*)sqlite3_user_data(context);  const char *zTokenizer = 0;  char *zErr = 0;  if( argc<3 ){  sqlite3_result_error(context,  "Usage: fts3_exprtest(tokenizer, expr, col1, ...", -1  );  return;  }  zTokenizer = (const char*)sqlite3_value_text(argv[0]);  rc = sqlite3Fts3InitTokenizer(pHash, zTokenizer, &pTokenizer, &zErr);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_NOMEM ){  sqlite3_result_error_nomem(context);  }else{  sqlite3_result_error(context, zErr, -1);  }  sqlite3_free(zErr);  return;  }  zExpr = (const char *)sqlite3_value_text(argv[1]);  nExpr = sqlite3_value_bytes(argv[1]);  nCol = argc-2;  azCol = (char **)sqlite3_malloc64(nCol*sizeof(char *));  if( !azCol ){  sqlite3_result_error_nomem(context);  goto exprtest_out;  }  for(ii=0; ii<nCol; ii++){  azCol[ii] = (char *)sqlite3_value_text(argv[ii+2]);  }  if( bRebalance ){  char *zDummy = 0;  rc = sqlite3Fts3ExprParse(  pTokenizer, 0, azCol, 0, nCol, nCol, zExpr, nExpr, &pExpr, &zDummy  );  assert( rc==SQLITE_OK || pExpr==0 );  sqlite3_free(zDummy);  }else{  rc = fts3ExprParseUnbalanced(  pTokenizer, 0, azCol, 0, nCol, nCol, zExpr, nExpr, &pExpr  );  }  if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM ){  sqlite3Fts3ExprFree(pExpr);  sqlite3_result_error(context, "Error parsing expression", -1);  }else if( rc==SQLITE_NOMEM || !(zBuf = exprToString(pExpr, 0)) ){  sqlite3_result_error_nomem(context);  }else{  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);  sqlite3_free(zBuf);  }  sqlite3Fts3ExprFree(pExpr); exprtest_out:  if( pTokenizer ){  rc = pTokenizer->pModule->xDestroy(pTokenizer);  }  sqlite3_free(azCol); } static void fts3ExprTest(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  fts3ExprTestCommon(0, context, argc, argv); } static void fts3ExprTestRebalance(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  fts3ExprTestCommon(1, context, argc, argv); } SQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface(sqlite3 *db, Fts3Hash *pHash){  int rc = sqlite3_create_function(  db, "fts3_exprtest", -1, SQLITE_UTF8, (void*)pHash, fts3ExprTest, 0, 0  );  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(db, "fts3_exprtest_rebalance",  -1, SQLITE_UTF8, (void*)pHash, fts3ExprTestRebalance, 0, 0  );  }  return rc; }
#endif
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
static void *fts3HashMalloc(sqlite3_int64 n){  void *p = sqlite3_malloc64(n);  if( p ){  memset(p, 0, n);  }  return p; } static void fts3HashFree(void *p){  sqlite3_free(p); } SQLITE_PRIVATE void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey){  assert( pNew!=0 );  assert( keyClass>=FTS3_HASH_STRING && keyClass<=FTS3_HASH_BINARY );  pNew->keyClass = keyClass;  pNew->copyKey = copyKey;  pNew->first = 0;  pNew->count = 0;  pNew->htsize = 0;  pNew->ht = 0; } SQLITE_PRIVATE void sqlite3Fts3HashClear(Fts3Hash *pH){  Fts3HashElem *elem;  assert( pH!=0 );  elem = pH->first;  pH->first = 0;  fts3HashFree(pH->ht);  pH->ht = 0;  pH->htsize = 0;  while( elem ){  Fts3HashElem *next_elem = elem->next;  if( pH->copyKey && elem->pKey ){  fts3HashFree(elem->pKey);  }  fts3HashFree(elem);  elem = next_elem;  }  pH->count = 0; } static int fts3StrHash(const void *pKey, int nKey){  const char *z = (const char *)pKey;  unsigned h = 0;  if( nKey<=0 ) nKey = (int) strlen(z);  while( nKey > 0 ){  h = (h<<3) ^ h ^ *z++;  nKey--;  }  return (int)(h & 0x7fffffff); } static int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2){  if( n1!=n2 ) return 1;  return strncmp((const char*)pKey1,(const char*)pKey2,n1); } static int fts3BinHash(const void *pKey, int nKey){  int h = 0;  const char *z = (const char *)pKey;  while( nKey-- > 0 ){  h = (h<<3) ^ h ^ *(z++);  }  return h & 0x7fffffff; } static int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2){  if( n1!=n2 ) return 1;  return memcmp(pKey1,pKey2,n1); } static int (*ftsHashFunction(int keyClass))(const void*,int){  if( keyClass==FTS3_HASH_STRING ){  return &fts3StrHash;  }else{  assert( keyClass==FTS3_HASH_BINARY );  return &fts3BinHash;  } } static int (*ftsCompareFunction(int keyClass))(const void*,int,const void*,int){  if( keyClass==FTS3_HASH_STRING ){  return &fts3StrCompare;  }else{  assert( keyClass==FTS3_HASH_BINARY );  return &fts3BinCompare;  } } static void fts3HashInsertElement(  Fts3Hash *pH,  struct _fts3ht *pEntry,  Fts3HashElem *pNew ){  Fts3HashElem *pHead;  pHead = pEntry->chain;  if( pHead ){  pNew->next = pHead;  pNew->prev = pHead->prev;  if( pHead->prev ){ pHead->prev->next = pNew; }  else  { pH->first = pNew; }  pHead->prev = pNew;  }else{  pNew->next = pH->first;  if( pH->first ){ pH->first->prev = pNew; }  pNew->prev = 0;  pH->first = pNew;  }  pEntry->count++;  pEntry->chain = pNew; } static int fts3Rehash(Fts3Hash *pH, int new_size){  struct _fts3ht *new_ht;  Fts3HashElem *elem, *next_elem;  int (*xHash)(const void*,int);  assert( (new_size & (new_size-1))==0 );  new_ht = (struct _fts3ht *)fts3HashMalloc( new_size*sizeof(struct _fts3ht) );  if( new_ht==0 ) return 1;  fts3HashFree(pH->ht);  pH->ht = new_ht;  pH->htsize = new_size;  xHash = ftsHashFunction(pH->keyClass);  for(elem=pH->first, pH->first=0; elem; elem = next_elem){  int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1);  next_elem = elem->next;  fts3HashInsertElement(pH, &new_ht[h], elem);  }  return 0; } static Fts3HashElem *fts3FindElementByHash(  const Fts3Hash *pH,  const void *pKey,  int nKey,  int h ){  Fts3HashElem *elem;  int count;  int (*xCompare)(const void*,int,const void*,int);  if( pH->ht ){  struct _fts3ht *pEntry = &pH->ht[h];  elem = pEntry->chain;  count = pEntry->count;  xCompare = ftsCompareFunction(pH->keyClass);  while( count-- && elem ){  if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){  return elem;  }  elem = elem->next;  }  }  return 0; } static void fts3RemoveElementByHash(  Fts3Hash *pH,  Fts3HashElem* elem,  int h ){  struct _fts3ht *pEntry;  if( elem->prev ){  elem->prev->next = elem->next;  }else{  pH->first = elem->next;  }  if( elem->next ){  elem->next->prev = elem->prev;  }  pEntry = &pH->ht[h];  if( pEntry->chain==elem ){  pEntry->chain = elem->next;  }  pEntry->count--;  if( pEntry->count<=0 ){  pEntry->chain = 0;  }  if( pH->copyKey && elem->pKey ){  fts3HashFree(elem->pKey);  }  fts3HashFree( elem );  pH->count--;  if( pH->count<=0 ){  assert( pH->first==0 );  assert( pH->count==0 );  fts3HashClear(pH);  } } SQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(  const Fts3Hash *pH,  const void *pKey,  int nKey ){  int h;  int (*xHash)(const void*,int);  if( pH==0 || pH->ht==0 ) return 0;  xHash = ftsHashFunction(pH->keyClass);  assert( xHash!=0 );  h = (*xHash)(pKey,nKey);  assert( (pH->htsize & (pH->htsize-1))==0 );  return fts3FindElementByHash(pH,pKey,nKey, h & (pH->htsize-1)); } SQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey){  Fts3HashElem *pElem;  pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);  return pElem ? pElem->data : 0; } SQLITE_PRIVATE void *sqlite3Fts3HashInsert(  Fts3Hash *pH,  const void *pKey,  int nKey,  void *data ){  int hraw;  int h;  Fts3HashElem *elem;  Fts3HashElem *new_elem;  int (*xHash)(const void*,int);  assert( pH!=0 );  xHash = ftsHashFunction(pH->keyClass);  assert( xHash!=0 );  hraw = (*xHash)(pKey, nKey);  assert( (pH->htsize & (pH->htsize-1))==0 );  h = hraw & (pH->htsize-1);  elem = fts3FindElementByHash(pH,pKey,nKey,h);  if( elem ){  void *old_data = elem->data;  if( data==0 ){  fts3RemoveElementByHash(pH,elem,h);  }else{  elem->data = data;  }  return old_data;  }  if( data==0 ) return 0;  if( (pH->htsize==0 && fts3Rehash(pH,8))   || (pH->count>=pH->htsize && fts3Rehash(pH, pH->htsize*2))  ){  pH->count = 0;  return data;  }  assert( pH->htsize>0 );  new_elem = (Fts3HashElem*)fts3HashMalloc( sizeof(Fts3HashElem) );  if( new_elem==0 ) return data;  if( pH->copyKey && pKey!=0 ){  new_elem->pKey = fts3HashMalloc( nKey );  if( new_elem->pKey==0 ){  fts3HashFree(new_elem);  return data;  }  memcpy((void*)new_elem->pKey, pKey, nKey);  }else{  new_elem->pKey = (void*)pKey;  }  new_elem->nKey = nKey;  pH->count++;  assert( pH->htsize>0 );  assert( (pH->htsize & (pH->htsize-1))==0 );  h = hraw & (pH->htsize-1);  fts3HashInsertElement(pH, &pH->ht[h], new_elem);  new_elem->data = data;  return 0; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
typedef struct porter_tokenizer {  sqlite3_tokenizer base; } porter_tokenizer; typedef struct porter_tokenizer_cursor {  sqlite3_tokenizer_cursor base;  const char *zInput;  int nInput;  int iOffset;  int iToken;  char *zToken;  int nAllocated; } porter_tokenizer_cursor; static int porterCreate(  int argc, const char * const *argv,  sqlite3_tokenizer **ppTokenizer ){  porter_tokenizer *t;  UNUSED_PARAMETER(argc);  UNUSED_PARAMETER(argv);  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));  if( t==NULL ) return SQLITE_NOMEM;  memset(t, 0, sizeof(*t));  *ppTokenizer = &t->base;  return SQLITE_OK; } static int porterDestroy(sqlite3_tokenizer *pTokenizer){  sqlite3_free(pTokenizer);  return SQLITE_OK; } static int porterOpen(  sqlite3_tokenizer *pTokenizer,  const char *zInput, int nInput,  sqlite3_tokenizer_cursor **ppCursor ){  porter_tokenizer_cursor *c;  UNUSED_PARAMETER(pTokenizer);  c = (porter_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));  if( c==NULL ) return SQLITE_NOMEM;  c->zInput = zInput;  if( zInput==0 ){  c->nInput = 0;  }else if( nInput<0 ){  c->nInput = (int)strlen(zInput);  }else{  c->nInput = nInput;  }  c->iOffset = 0;  c->iToken = 0;  c->zToken = NULL;  c->nAllocated = 0;  *ppCursor = &c->base;  return SQLITE_OK; } static int porterClose(sqlite3_tokenizer_cursor *pCursor){  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;  sqlite3_free(c->zToken);  sqlite3_free(c);  return SQLITE_OK; } static const char cType[] = {   0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,   1, 1, 1, 2, 1 }; static int isVowel(const char*); static int isConsonant(const char *z){  int j;  char x = *z;  if( x==0 ) return 0;  assert( x>='a' && x<='z' );  j = cType[x-'a'];  if( j<2 ) return j;  return z[1]==0 || isVowel(z + 1); } static int isVowel(const char *z){  int j;  char x = *z;  if( x==0 ) return 0;  assert( x>='a' && x<='z' );  j = cType[x-'a'];  if( j<2 ) return 1-j;  return isConsonant(z + 1); } static int m_gt_0(const char *z){  while( isVowel(z) ){ z++; }  if( *z==0 ) return 0;  while( isConsonant(z) ){ z++; }  return *z!=0; } static int m_eq_1(const char *z){  while( isVowel(z) ){ z++; }  if( *z==0 ) return 0;  while( isConsonant(z) ){ z++; }  if( *z==0 ) return 0;  while( isVowel(z) ){ z++; }  if( *z==0 ) return 1;  while( isConsonant(z) ){ z++; }  return *z==0; } static int m_gt_1(const char *z){  while( isVowel(z) ){ z++; }  if( *z==0 ) return 0;  while( isConsonant(z) ){ z++; }  if( *z==0 ) return 0;  while( isVowel(z) ){ z++; }  if( *z==0 ) return 0;  while( isConsonant(z) ){ z++; }  return *z!=0; } static int hasVowel(const char *z){  while( isConsonant(z) ){ z++; }  return *z!=0; } static int doubleConsonant(const char *z){  return isConsonant(z) && z[0]==z[1]; } static int star_oh(const char *z){  return  isConsonant(z) &&  z[0]!='w' && z[0]!='x' && z[0]!='y' &&  isVowel(z+1) &&  isConsonant(z+2); } static int stem(  char **pz,  const char *zFrom,  const char *zTo,  int (*xCond)(const char*) ){  char *z = *pz;  while( *zFrom && *zFrom==*z ){ z++; zFrom++; }  if( *zFrom!=0 ) return 0;  if( xCond && !xCond(z) ) return 1;  while( *zTo ){  *(--z) = *(zTo++);  }  *pz = z;  return 1; } static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){  int i, mx, j;  int hasDigit = 0;  for(i=0; i<nIn; i++){  char c = zIn[i];  if( c>='A' && c<='Z' ){  zOut[i] = c - 'A' + 'a';  }else{  if( c>='0' && c<='9' ) hasDigit = 1;  zOut[i] = c;  }  }  mx = hasDigit ? 3 : 10;  if( nIn>mx*2 ){  for(j=mx, i=nIn-mx; i<nIn; i++, j++){  zOut[j] = zOut[i];  }  i = j;  }  zOut[i] = 0;  *pnOut = i; } static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){  int i, j;  char zReverse[28];  char *z, *z2;  if( nIn<3 || nIn>=(int)sizeof(zReverse)-7 ){  copy_stemmer(zIn, nIn, zOut, pnOut);  return;  }  for(i=0, j=sizeof(zReverse)-6; i<nIn; i++, j--){  char c = zIn[i];  if( c>='A' && c<='Z' ){  zReverse[j] = c + 'a' - 'A';  }else if( c>='a' && c<='z' ){  zReverse[j] = c;  }else{  copy_stemmer(zIn, nIn, zOut, pnOut);  return;  }  }  memset(&zReverse[sizeof(zReverse)-5], 0, 5);  z = &zReverse[j+1];  if( z[0]=='s' ){  if(   !stem(&z, "sess", "ss", 0) &&   !stem(&z, "sei", "i", 0) &&   !stem(&z, "ss", "ss", 0)  ){  z++;  }  }  z2 = z;  if( stem(&z, "dee", "ee", m_gt_0) ){  }else if(   (stem(&z, "gni", "", hasVowel) || stem(&z, "de", "", hasVowel))  && z!=z2  ){   if( stem(&z, "ta", "ate", 0) ||   stem(&z, "lb", "ble", 0) ||   stem(&z, "zi", "ize", 0) ){   }else if( doubleConsonant(z) && (*z!='l' && *z!='s' && *z!='z') ){   z++;   }else if( m_eq_1(z) && star_oh(z) ){   *(--z) = 'e';   }  }  if( z[0]=='y' && hasVowel(z+1) ){  z[0] = 'i';  }  switch( z[1] ){   case 'a':   if( !stem(&z, "lanoita", "ate", m_gt_0) ){   stem(&z, "lanoit", "tion", m_gt_0);   }   break;   case 'c':   if( !stem(&z, "icne", "ence", m_gt_0) ){   stem(&z, "icna", "ance", m_gt_0);   }   break;   case 'e':   stem(&z, "rezi", "ize", m_gt_0);   break;   case 'g':   stem(&z, "igol", "log", m_gt_0);   break;   case 'l':   if( !stem(&z, "ilb", "ble", m_gt_0)  && !stem(&z, "illa", "al", m_gt_0)  && !stem(&z, "iltne", "ent", m_gt_0)  && !stem(&z, "ile", "e", m_gt_0)   ){   stem(&z, "ilsuo", "ous", m_gt_0);   }   break;   case 'o':   if( !stem(&z, "noitazi", "ize", m_gt_0)  && !stem(&z, "noita", "ate", m_gt_0)   ){   stem(&z, "rota", "ate", m_gt_0);   }   break;   case 's':   if( !stem(&z, "msila", "al", m_gt_0)  && !stem(&z, "ssenevi", "ive", m_gt_0)  && !stem(&z, "ssenluf", "ful", m_gt_0)   ){   stem(&z, "ssensuo", "ous", m_gt_0);   }   break;   case 't':   if( !stem(&z, "itila", "al", m_gt_0)  && !stem(&z, "itivi", "ive", m_gt_0)   ){   stem(&z, "itilib", "ble", m_gt_0);   }   break;  }  switch( z[0] ){   case 'e':   if( !stem(&z, "etaci", "ic", m_gt_0)  && !stem(&z, "evita", "", m_gt_0)   ){   stem(&z, "ezila", "al", m_gt_0);   }   break;   case 'i':   stem(&z, "itici", "ic", m_gt_0);   break;   case 'l':   if( !stem(&z, "laci", "ic", m_gt_0) ){   stem(&z, "luf", "", m_gt_0);   }   break;   case 's':   stem(&z, "ssen", "", m_gt_0);   break;  }  switch( z[1] ){   case 'a':   if( z[0]=='l' && m_gt_1(z+2) ){   z += 2;   }   break;   case 'c':   if( z[0]=='e' && z[2]=='n' && (z[3]=='a' || z[3]=='e') && m_gt_1(z+4) ){   z += 4;   }   break;   case 'e':   if( z[0]=='r' && m_gt_1(z+2) ){   z += 2;   }   break;   case 'i':   if( z[0]=='c' && m_gt_1(z+2) ){   z += 2;   }   break;   case 'l':   if( z[0]=='e' && z[2]=='b' && (z[3]=='a' || z[3]=='i') && m_gt_1(z+4) ){   z += 4;   }   break;   case 'n':   if( z[0]=='t' ){   if( z[2]=='a' ){   if( m_gt_1(z+3) ){   z += 3;   }   }else if( z[2]=='e' ){   if( !stem(&z, "tneme", "", m_gt_1)  && !stem(&z, "tnem", "", m_gt_1)   ){   stem(&z, "tne", "", m_gt_1);   }   }   }   break;   case 'o':   if( z[0]=='u' ){   if( m_gt_1(z+2) ){   z += 2;   }   }else if( z[3]=='s' || z[3]=='t' ){   stem(&z, "noi", "", m_gt_1);   }   break;   case 's':   if( z[0]=='m' && z[2]=='i' && m_gt_1(z+3) ){   z += 3;   }   break;   case 't':   if( !stem(&z, "eta", "", m_gt_1) ){   stem(&z, "iti", "", m_gt_1);   }   break;   case 'u':   if( z[0]=='s' && z[2]=='o' && m_gt_1(z+3) ){   z += 3;   }   break;   case 'v':   case 'z':   if( z[0]=='e' && z[2]=='i' && m_gt_1(z+3) ){   z += 3;   }   break;  }  if( z[0]=='e' ){  if( m_gt_1(z+1) ){  z++;  }else if( m_eq_1(z+1) && !star_oh(z+1) ){  z++;  }  }  if( m_gt_1(z) && z[0]=='l' && z[1]=='l' ){  z++;  }  *pnOut = i = (int)strlen(z);  zOut[i] = 0;  while( *z ){  zOut[--i] = *(z++);  } } static const char porterIdChar[] = {  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, };
#define isDelim(C) (((ch=C)&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30]))
static int porterNext(  sqlite3_tokenizer_cursor *pCursor,  const char **pzToken,  int *pnBytes,  int *piStartOffset,  int *piEndOffset,  int *piPosition ){  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;  const char *z = c->zInput;  while( c->iOffset<c->nInput ){  int iStartOffset, ch;  while( c->iOffset<c->nInput && isDelim(z[c->iOffset]) ){  c->iOffset++;  }  iStartOffset = c->iOffset;  while( c->iOffset<c->nInput && !isDelim(z[c->iOffset]) ){  c->iOffset++;  }  if( c->iOffset>iStartOffset ){  int n = c->iOffset-iStartOffset;  if( n>c->nAllocated ){  char *pNew;  c->nAllocated = n+20;  pNew = sqlite3_realloc(c->zToken, c->nAllocated);  if( !pNew ) return SQLITE_NOMEM;  c->zToken = pNew;  }  porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes);  *pzToken = c->zToken;  *piStartOffset = iStartOffset;  *piEndOffset = c->iOffset;  *piPosition = c->iToken++;  return SQLITE_OK;  }  }  return SQLITE_DONE; } static const sqlite3_tokenizer_module porterTokenizerModule = {  0,  porterCreate,  porterDestroy,  porterOpen,  porterClose,  porterNext,  0 }; SQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(  sqlite3_tokenizer_module const**ppModule ){  *ppModule = &porterTokenizerModule; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
static int fts3TokenizerEnabled(sqlite3_context *context){  sqlite3 *db = sqlite3_context_db_handle(context);  int isEnabled = 0;  sqlite3_db_config(db,SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER,-1,&isEnabled);  return isEnabled; } static void fts3TokenizerFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  Fts3Hash *pHash;  void *pPtr = 0;  const unsigned char *zName;  int nName;  assert( argc==1 || argc==2 );  pHash = (Fts3Hash *)sqlite3_user_data(context);  zName = sqlite3_value_text(argv[0]);  nName = sqlite3_value_bytes(argv[0])+1;  if( argc==2 ){  if( fts3TokenizerEnabled(context) || sqlite3_value_frombind(argv[1]) ){  void *pOld;  int n = sqlite3_value_bytes(argv[1]);  if( zName==0 || n!=sizeof(pPtr) ){  sqlite3_result_error(context, "argument type mismatch", -1);  return;  }  pPtr = *(void **)sqlite3_value_blob(argv[1]);  pOld = sqlite3Fts3HashInsert(pHash, (void *)zName, nName, pPtr);  if( pOld==pPtr ){  sqlite3_result_error(context, "out of memory", -1);  }  }else{  sqlite3_result_error(context, "fts3tokenize disabled", -1);  return;  }  }else{  if( zName ){  pPtr = sqlite3Fts3HashFind(pHash, zName, nName);  }  if( !pPtr ){  char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName);  sqlite3_result_error(context, zErr, -1);  sqlite3_free(zErr);  return;  }  }  if( fts3TokenizerEnabled(context) || sqlite3_value_frombind(argv[0]) ){  sqlite3_result_blob(context, (void *)&pPtr, sizeof(pPtr), SQLITE_TRANSIENT);  } } SQLITE_PRIVATE int sqlite3Fts3IsIdChar(char c){  static const char isFtsIdChar[] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  };  return (c&0x80 || isFtsIdChar[(int)(c)]); } SQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *zStr, int *pn){  const char *z1;  const char *z2 = 0;  z1 = zStr;  while( z2==0 ){  char c = *z1;  switch( c ){  case '\0': return 0;  case '\'':  case '"':  case '`': {  z2 = z1;  while( *++z2 && (*z2!=c || *++z2==c) );  break;  }  case '[':  z2 = &z1[1];  while( *z2 && z2[0]!=']' ) z2++;  if( *z2 ) z2++;  break;  default:  if( sqlite3Fts3IsIdChar(*z1) ){  z2 = &z1[1];  while( sqlite3Fts3IsIdChar(*z2) ) z2++;  }else{  z1++;  }  }  }  *pn = (int)(z2-z1);  return z1; } SQLITE_PRIVATE int sqlite3Fts3InitTokenizer(  Fts3Hash *pHash,  const char *zArg,  sqlite3_tokenizer **ppTok,  char **pzErr ){  int rc;  char *z = (char *)zArg;  int n = 0;  char *zCopy;  char *zEnd;  sqlite3_tokenizer_module *m;  zCopy = sqlite3_mprintf("%s", zArg);  if( !zCopy ) return SQLITE_NOMEM;  zEnd = &zCopy[strlen(zCopy)];  z = (char *)sqlite3Fts3NextToken(zCopy, &n);  if( z==0 ){  assert( n==0 );  z = zCopy;  }  z[n] = '\0';  sqlite3Fts3Dequote(z);  m = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash,z,(int)strlen(z)+1);  if( !m ){  sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer: %s", z);  rc = SQLITE_ERROR;  }else{  char const **aArg = 0;  int iArg = 0;  z = &z[n+1];  while( z<zEnd && (NULL!=(z = (char *)sqlite3Fts3NextToken(z, &n))) ){  sqlite3_int64 nNew = sizeof(char *)*(iArg+1);  char const **aNew = (const char **)sqlite3_realloc64((void *)aArg, nNew);  if( !aNew ){  sqlite3_free(zCopy);  sqlite3_free((void *)aArg);  return SQLITE_NOMEM;  }  aArg = aNew;  aArg[iArg++] = z;  z[n] = '\0';  sqlite3Fts3Dequote(z);  z = &z[n+1];  }  rc = m->xCreate(iArg, aArg, ppTok);  assert( rc!=SQLITE_OK || *ppTok );  if( rc!=SQLITE_OK ){  sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer");  }else{  (*ppTok)->pModule = m;  }  sqlite3_free((void *)aArg);  }  sqlite3_free(zCopy);  return rc; }
#ifdef SQLITE_TEST
#if defined(INCLUDE_SQLITE_TCL_H)
# include "sqlite_tcl.h"
#else
# include "tcl.h"
#endif
static void testFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  Fts3Hash *pHash;  sqlite3_tokenizer_module *p;  sqlite3_tokenizer *pTokenizer = 0;  sqlite3_tokenizer_cursor *pCsr = 0;  const char *zErr = 0;  const char *zName;  int nName;  const char *zInput;  int nInput;  const char *azArg[64];  const char *zToken;  int nToken = 0;  int iStart = 0;  int iEnd = 0;  int iPos = 0;  int i;  Tcl_Obj *pRet;  if( argc<2 ){  sqlite3_result_error(context, "insufficient arguments", -1);  return;  }  nName = sqlite3_value_bytes(argv[0]);  zName = (const char *)sqlite3_value_text(argv[0]);  nInput = sqlite3_value_bytes(argv[argc-1]);  zInput = (const char *)sqlite3_value_text(argv[argc-1]);  pHash = (Fts3Hash *)sqlite3_user_data(context);  p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName+1);  if( !p ){  char *zErr2 = sqlite3_mprintf("unknown tokenizer: %s", zName);  sqlite3_result_error(context, zErr2, -1);  sqlite3_free(zErr2);  return;  }  pRet = Tcl_NewObj();  Tcl_IncrRefCount(pRet);  for(i=1; i<argc-1; i++){  azArg[i-1] = (const char *)sqlite3_value_text(argv[i]);  }  if( SQLITE_OK!=p->xCreate(argc-2, azArg, &pTokenizer) ){  zErr = "error in xCreate()";  goto finish;  }  pTokenizer->pModule = p;  if( sqlite3Fts3OpenTokenizer(pTokenizer, 0, zInput, nInput, &pCsr) ){  zErr = "error in xOpen()";  goto finish;  }  while( SQLITE_OK==p->xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos) ){  Tcl_ListObjAppendElement(0, pRet, Tcl_NewIntObj(iPos));  Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));  zToken = &zInput[iStart];  nToken = iEnd-iStart;  Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));  }  if( SQLITE_OK!=p->xClose(pCsr) ){  zErr = "error in xClose()";  goto finish;  }  if( SQLITE_OK!=p->xDestroy(pTokenizer) ){  zErr = "error in xDestroy()";  goto finish;  } finish:  if( zErr ){  sqlite3_result_error(context, zErr, -1);  }else{  sqlite3_result_text(context, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT);  }  Tcl_DecrRefCount(pRet); } static int registerTokenizer(  sqlite3 *db,  char *zName,  const sqlite3_tokenizer_module *p ){  int rc;  sqlite3_stmt *pStmt;  const char zSql[] = "SELECT fts3_tokenizer(?, ?)";  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);  if( rc!=SQLITE_OK ){  return rc;  }  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);  sqlite3_bind_blob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC);  sqlite3_step(pStmt);  return sqlite3_finalize(pStmt); } static int queryTokenizer(  sqlite3 *db,  char *zName,  const sqlite3_tokenizer_module **pp ){  int rc;  sqlite3_stmt *pStmt;  const char zSql[] = "SELECT fts3_tokenizer(?)";  *pp = 0;  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);  if( rc!=SQLITE_OK ){  return rc;  }  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);  if( SQLITE_ROW==sqlite3_step(pStmt) ){  if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB   && sqlite3_column_bytes(pStmt, 0)==sizeof(*pp)  ){  memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));  }  }  return sqlite3_finalize(pStmt); } SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule); static void intTestFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  int rc;  const sqlite3_tokenizer_module *p1;  const sqlite3_tokenizer_module *p2;  sqlite3 *db = (sqlite3 *)sqlite3_user_data(context);  UNUSED_PARAMETER(argc);  UNUSED_PARAMETER(argv);  sqlite3Fts3SimpleTokenizerModule(&p1);  rc = queryTokenizer(db, "simple", &p2);  assert( rc==SQLITE_OK );  assert( p1==p2 );  rc = queryTokenizer(db, "nosuchtokenizer", &p2);  assert( rc==SQLITE_ERROR );  assert( p2==0 );  assert( 0==strcmp(sqlite3_errmsg(db), "unknown tokenizer: nosuchtokenizer") );  if( fts3TokenizerEnabled(context) ){  rc = registerTokenizer(db, "nosuchtokenizer", p1);  assert( rc==SQLITE_OK );  rc = queryTokenizer(db, "nosuchtokenizer", &p2);  assert( rc==SQLITE_OK );  assert( p2==p1 );  }  sqlite3_result_text(context, "ok", -1, SQLITE_STATIC); }
#endif
SQLITE_PRIVATE int sqlite3Fts3InitHashTable(  sqlite3 *db,  Fts3Hash *pHash,  const char *zName ){  int rc = SQLITE_OK;  void *p = (void *)pHash;  const int any = SQLITE_UTF8|SQLITE_DIRECTONLY;
#ifdef SQLITE_TEST
 char *zTest = 0;  char *zTest2 = 0;  void *pdb = (void *)db;  zTest = sqlite3_mprintf("%s_test", zName);  zTest2 = sqlite3_mprintf("%s_internal_test", zName);  if( !zTest || !zTest2 ){  rc = SQLITE_NOMEM;  }
#endif
 if( SQLITE_OK==rc ){  rc = sqlite3_create_function(db, zName, 1, any, p, fts3TokenizerFunc, 0, 0);  }  if( SQLITE_OK==rc ){  rc = sqlite3_create_function(db, zName, 2, any, p, fts3TokenizerFunc, 0, 0);  }
#ifdef SQLITE_TEST
 if( SQLITE_OK==rc ){  rc = sqlite3_create_function(db, zTest, -1, any, p, testFunc, 0, 0);  }  if( SQLITE_OK==rc ){  rc = sqlite3_create_function(db, zTest2, 0, any, pdb, intTestFunc, 0, 0);  }
#endif
#ifdef SQLITE_TEST
 sqlite3_free(zTest);  sqlite3_free(zTest2);
#endif
 return rc; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
typedef struct simple_tokenizer {  sqlite3_tokenizer base;  char delim[128]; } simple_tokenizer; typedef struct simple_tokenizer_cursor {  sqlite3_tokenizer_cursor base;  const char *pInput;  int nBytes;  int iOffset;  int iToken;  char *pToken;  int nTokenAllocated; } simple_tokenizer_cursor; static int simpleDelim(simple_tokenizer *t, unsigned char c){  return c<0x80 && t->delim[c]; } static int fts3_isalnum(int x){  return (x>='0' && x<='9') || (x>='A' && x<='Z') || (x>='a' && x<='z'); } static int simpleCreate(  int argc, const char * const *argv,  sqlite3_tokenizer **ppTokenizer ){  simple_tokenizer *t;  t = (simple_tokenizer *) sqlite3_malloc(sizeof(*t));  if( t==NULL ) return SQLITE_NOMEM;  memset(t, 0, sizeof(*t));  if( argc>1 ){  int i, n = (int)strlen(argv[1]);  for(i=0; i<n; i++){  unsigned char ch = argv[1][i];  if( ch>=0x80 ){  sqlite3_free(t);  return SQLITE_ERROR;  }  t->delim[ch] = 1;  }  } else {  int i;  for(i=1; i<0x80; i++){  t->delim[i] = !fts3_isalnum(i) ? -1 : 0;  }  }  *ppTokenizer = &t->base;  return SQLITE_OK; } static int simpleDestroy(sqlite3_tokenizer *pTokenizer){  sqlite3_free(pTokenizer);  return SQLITE_OK; } static int simpleOpen(  sqlite3_tokenizer *pTokenizer,  const char *pInput, int nBytes,  sqlite3_tokenizer_cursor **ppCursor ){  simple_tokenizer_cursor *c;  UNUSED_PARAMETER(pTokenizer);  c = (simple_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));  if( c==NULL ) return SQLITE_NOMEM;  c->pInput = pInput;  if( pInput==0 ){  c->nBytes = 0;  }else if( nBytes<0 ){  c->nBytes = (int)strlen(pInput);  }else{  c->nBytes = nBytes;  }  c->iOffset = 0;  c->iToken = 0;  c->pToken = NULL;  c->nTokenAllocated = 0;  *ppCursor = &c->base;  return SQLITE_OK; } static int simpleClose(sqlite3_tokenizer_cursor *pCursor){  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;  sqlite3_free(c->pToken);  sqlite3_free(c);  return SQLITE_OK; } static int simpleNext(  sqlite3_tokenizer_cursor *pCursor,  const char **ppToken,  int *pnBytes,  int *piStartOffset,  int *piEndOffset,  int *piPosition ){  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;  simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;  unsigned char *p = (unsigned char *)c->pInput;  while( c->iOffset<c->nBytes ){  int iStartOffset;  while( c->iOffset<c->nBytes && simpleDelim(t, p[c->iOffset]) ){  c->iOffset++;  }  iStartOffset = c->iOffset;  while( c->iOffset<c->nBytes && !simpleDelim(t, p[c->iOffset]) ){  c->iOffset++;  }  if( c->iOffset>iStartOffset ){  int i, n = c->iOffset-iStartOffset;  if( n>c->nTokenAllocated ){  char *pNew;  c->nTokenAllocated = n+20;  pNew = sqlite3_realloc(c->pToken, c->nTokenAllocated);  if( !pNew ) return SQLITE_NOMEM;  c->pToken = pNew;  }  for(i=0; i<n; i++){  unsigned char ch = p[iStartOffset+i];  c->pToken[i] = (char)((ch>='A' && ch<='Z') ? ch-'A'+'a' : ch);  }  *ppToken = c->pToken;  *pnBytes = n;  *piStartOffset = iStartOffset;  *piEndOffset = c->iOffset;  *piPosition = c->iToken++;  return SQLITE_OK;  }  }  return SQLITE_DONE; } static const sqlite3_tokenizer_module simpleTokenizerModule = {  0,  simpleCreate,  simpleDestroy,  simpleOpen,  simpleClose,  simpleNext,  0, }; SQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(  sqlite3_tokenizer_module const**ppModule ){  *ppModule = &simpleTokenizerModule; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
typedef struct Fts3tokTable Fts3tokTable; typedef struct Fts3tokCursor Fts3tokCursor; struct Fts3tokTable {  sqlite3_vtab base;  const sqlite3_tokenizer_module *pMod;  sqlite3_tokenizer *pTok; }; struct Fts3tokCursor {  sqlite3_vtab_cursor base;  char *zInput;  sqlite3_tokenizer_cursor *pCsr;  int iRowid;  const char *zToken;  int nToken;  int iStart;  int iEnd;  int iPos; }; static int fts3tokQueryTokenizer(  Fts3Hash *pHash,  const char *zName,  const sqlite3_tokenizer_module **pp,  char **pzErr ){  sqlite3_tokenizer_module *p;  int nName = (int)strlen(zName);  p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName+1);  if( !p ){  sqlite3Fts3ErrMsg(pzErr, "unknown tokenizer: %s", zName);  return SQLITE_ERROR;  }  *pp = p;  return SQLITE_OK; } static int fts3tokDequoteArray(  int argc,  const char * const *argv,  char ***pazDequote ){  int rc = SQLITE_OK;  if( argc==0 ){  *pazDequote = 0;  }else{  int i;  int nByte = 0;  char **azDequote;  for(i=0; i<argc; i++){  nByte += (int)(strlen(argv[i]) + 1);  }  *pazDequote = azDequote = sqlite3_malloc64(sizeof(char *)*argc + nByte);  if( azDequote==0 ){  rc = SQLITE_NOMEM;  }else{  char *pSpace = (char *)&azDequote[argc];  for(i=0; i<argc; i++){  int n = (int)strlen(argv[i]);  azDequote[i] = pSpace;  memcpy(pSpace, argv[i], n+1);  sqlite3Fts3Dequote(pSpace);  pSpace += (n+1);  }  }  }  return rc; }
#define FTS3_TOK_SCHEMA "CREATE TABLE x(input, token, start, end, position)"
static int fts3tokConnectMethod(  sqlite3 *db,  void *pHash,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  Fts3tokTable *pTab = 0;  const sqlite3_tokenizer_module *pMod = 0;  sqlite3_tokenizer *pTok = 0;  int rc;  char **azDequote = 0;  int nDequote;  rc = sqlite3_declare_vtab(db, FTS3_TOK_SCHEMA);  if( rc!=SQLITE_OK ) return rc;  nDequote = argc-3;  rc = fts3tokDequoteArray(nDequote, &argv[3], &azDequote);  if( rc==SQLITE_OK ){  const char *zModule;  if( nDequote<1 ){  zModule = "simple";  }else{  zModule = azDequote[0];  }  rc = fts3tokQueryTokenizer((Fts3Hash*)pHash, zModule, &pMod, pzErr);  }  assert( (rc==SQLITE_OK)==(pMod!=0) );  if( rc==SQLITE_OK ){  const char * const *azArg = 0;  if( nDequote>1 ) azArg = (const char * const *)&azDequote[1];  rc = pMod->xCreate((nDequote>1 ? nDequote-1 : 0), azArg, &pTok);  }  if( rc==SQLITE_OK ){  pTab = (Fts3tokTable *)sqlite3_malloc(sizeof(Fts3tokTable));  if( pTab==0 ){  rc = SQLITE_NOMEM;  }  }  if( rc==SQLITE_OK ){  memset(pTab, 0, sizeof(Fts3tokTable));  pTab->pMod = pMod;  pTab->pTok = pTok;  *ppVtab = &pTab->base;  }else{  if( pTok ){  pMod->xDestroy(pTok);  }  }  sqlite3_free(azDequote);  return rc; } static int fts3tokDisconnectMethod(sqlite3_vtab *pVtab){  Fts3tokTable *pTab = (Fts3tokTable *)pVtab;  pTab->pMod->xDestroy(pTab->pTok);  sqlite3_free(pTab);  return SQLITE_OK; } static int fts3tokBestIndexMethod(  sqlite3_vtab *pVTab,  sqlite3_index_info *pInfo ){  int i;  UNUSED_PARAMETER(pVTab);  for(i=0; i<pInfo->nConstraint; i++){  if( pInfo->aConstraint[i].usable   && pInfo->aConstraint[i].iColumn==0   && pInfo->aConstraint[i].op==SQLITE_INDEX_CONSTRAINT_EQ  ){  pInfo->idxNum = 1;  pInfo->aConstraintUsage[i].argvIndex = 1;  pInfo->aConstraintUsage[i].omit = 1;  pInfo->estimatedCost = 1;  return SQLITE_OK;  }  }  pInfo->idxNum = 0;  assert( pInfo->estimatedCost>1000000.0 );  return SQLITE_OK; } static int fts3tokOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){  Fts3tokCursor *pCsr;  UNUSED_PARAMETER(pVTab);  pCsr = (Fts3tokCursor *)sqlite3_malloc(sizeof(Fts3tokCursor));  if( pCsr==0 ){  return SQLITE_NOMEM;  }  memset(pCsr, 0, sizeof(Fts3tokCursor));  *ppCsr = (sqlite3_vtab_cursor *)pCsr;  return SQLITE_OK; } static void fts3tokResetCursor(Fts3tokCursor *pCsr){  if( pCsr->pCsr ){  Fts3tokTable *pTab = (Fts3tokTable *)(pCsr->base.pVtab);  pTab->pMod->xClose(pCsr->pCsr);  pCsr->pCsr = 0;  }  sqlite3_free(pCsr->zInput);  pCsr->zInput = 0;  pCsr->zToken = 0;  pCsr->nToken = 0;  pCsr->iStart = 0;  pCsr->iEnd = 0;  pCsr->iPos = 0;  pCsr->iRowid = 0; } static int fts3tokCloseMethod(sqlite3_vtab_cursor *pCursor){  Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;  fts3tokResetCursor(pCsr);  sqlite3_free(pCsr);  return SQLITE_OK; } static int fts3tokNextMethod(sqlite3_vtab_cursor *pCursor){  Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;  Fts3tokTable *pTab = (Fts3tokTable *)(pCursor->pVtab);  int rc;  pCsr->iRowid++;  rc = pTab->pMod->xNext(pCsr->pCsr,  &pCsr->zToken, &pCsr->nToken,  &pCsr->iStart, &pCsr->iEnd, &pCsr->iPos  );  if( rc!=SQLITE_OK ){  fts3tokResetCursor(pCsr);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  }  return rc; } static int fts3tokFilterMethod(  sqlite3_vtab_cursor *pCursor,  int idxNum,  const char *idxStr,  int nVal,  sqlite3_value **apVal ){  int rc = SQLITE_ERROR;  Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;  Fts3tokTable *pTab = (Fts3tokTable *)(pCursor->pVtab);  UNUSED_PARAMETER(idxStr);  UNUSED_PARAMETER(nVal);  fts3tokResetCursor(pCsr);  if( idxNum==1 ){  const char *zByte = (const char *)sqlite3_value_text(apVal[0]);  int nByte = sqlite3_value_bytes(apVal[0]);  pCsr->zInput = sqlite3_malloc64(nByte+1);  if( pCsr->zInput==0 ){  rc = SQLITE_NOMEM;  }else{  if( nByte>0 ) memcpy(pCsr->zInput, zByte, nByte);  pCsr->zInput[nByte] = 0;  rc = pTab->pMod->xOpen(pTab->pTok, pCsr->zInput, nByte, &pCsr->pCsr);  if( rc==SQLITE_OK ){  pCsr->pCsr->pTokenizer = pTab->pTok;  }  }  }  if( rc!=SQLITE_OK ) return rc;  return fts3tokNextMethod(pCursor); } static int fts3tokEofMethod(sqlite3_vtab_cursor *pCursor){  Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;  return (pCsr->zToken==0); } static int fts3tokColumnMethod(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *pCtx,  int iCol ){  Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;  switch( iCol ){  case 0:  sqlite3_result_text(pCtx, pCsr->zInput, -1, SQLITE_TRANSIENT);  break;  case 1:  sqlite3_result_text(pCtx, pCsr->zToken, pCsr->nToken, SQLITE_TRANSIENT);  break;  case 2:  sqlite3_result_int(pCtx, pCsr->iStart);  break;  case 3:  sqlite3_result_int(pCtx, pCsr->iEnd);  break;  default:  assert( iCol==4 );  sqlite3_result_int(pCtx, pCsr->iPos);  break;  }  return SQLITE_OK; } static int fts3tokRowidMethod(  sqlite3_vtab_cursor *pCursor,  sqlite_int64 *pRowid ){  Fts3tokCursor *pCsr = (Fts3tokCursor *)pCursor;  *pRowid = (sqlite3_int64)pCsr->iRowid;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3InitTok(sqlite3 *db, Fts3Hash *pHash){  static const sqlite3_module fts3tok_module = {   0,   fts3tokConnectMethod,   fts3tokConnectMethod,   fts3tokBestIndexMethod,   fts3tokDisconnectMethod,   fts3tokDisconnectMethod,   fts3tokOpenMethod,   fts3tokCloseMethod,   fts3tokFilterMethod,   fts3tokNextMethod,   fts3tokEofMethod,   fts3tokColumnMethod,   fts3tokRowidMethod,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0  };  int rc;  rc = sqlite3_create_module(db, "fts3tokenize", &fts3tok_module, (void*)pHash);  return rc; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#define FTS_MAX_APPENDABLE_HEIGHT 16
#define FTS3_NODE_PADDING (FTS3_VARINT_MAX*2)
#ifdef SQLITE_TEST
int test_fts3_node_chunksize = (4*1024); int test_fts3_node_chunk_threshold = (4*1024)*4;
# define FTS3_NODE_CHUNKSIZE  test_fts3_node_chunksize
# define FTS3_NODE_CHUNK_THRESHOLD test_fts3_node_chunk_threshold
#else
# define FTS3_NODE_CHUNKSIZE (4*1024)
# define FTS3_NODE_CHUNK_THRESHOLD (FTS3_NODE_CHUNKSIZE*4)
#endif
#define FTS_STAT_DOCTOTAL 0
#define FTS_STAT_INCRMERGEHINT 1
#define FTS_STAT_AUTOINCRMERGE 2
#ifdef FTS3_LOG_MERGES
static void fts3LogMerge(int nMerge, sqlite3_int64 iAbsLevel){  sqlite3_log(SQLITE_OK, "%d-way merge from level %d", nMerge, (int)iAbsLevel); }
#else
#define fts3LogMerge(x, y)
#endif
typedef struct PendingList PendingList; typedef struct SegmentNode SegmentNode; typedef struct SegmentWriter SegmentWriter; struct PendingList {  int nData;  char *aData;  int nSpace;  sqlite3_int64 iLastDocid;  sqlite3_int64 iLastCol;  sqlite3_int64 iLastPos; }; struct Fts3DeferredToken {  Fts3PhraseToken *pToken;  int iCol;  Fts3DeferredToken *pNext;  PendingList *pList; }; struct Fts3SegReader {  int iIdx;  u8 bLookup;  u8 rootOnly;  sqlite3_int64 iStartBlock;  sqlite3_int64 iLeafEndBlock;  sqlite3_int64 iEndBlock;  sqlite3_int64 iCurrentBlock;  char *aNode;  int nNode;  int nPopulate;  sqlite3_blob *pBlob;  Fts3HashElem **ppNextElem;  int nTerm;  char *zTerm;  int nTermAlloc;  char *aDoclist;  int nDoclist;  char *pOffsetList;  int nOffsetList;  sqlite3_int64 iDocid; };
#define fts3SegReaderIsPending(p) ((p)->ppNextElem!=0)
#define fts3SegReaderIsRootOnly(p) ((p)->rootOnly!=0)
struct SegmentWriter {  SegmentNode *pTree;  sqlite3_int64 iFirst;  sqlite3_int64 iFree;  char *zTerm;  int nTerm;  int nMalloc;  char *zMalloc;  int nSize;  int nData;  char *aData;  i64 nLeafData; }; struct SegmentNode {  SegmentNode *pParent;  SegmentNode *pRight;  SegmentNode *pLeftmost;  int nEntry;  char *zTerm;  int nTerm;  int nMalloc;  char *zMalloc;  int nData;  char *aData; };
#define SQL_DELETE_CONTENT  0
#define SQL_IS_EMPTY  1
#define SQL_DELETE_ALL_CONTENT  2
#define SQL_DELETE_ALL_SEGMENTS 3
#define SQL_DELETE_ALL_SEGDIR 4
#define SQL_DELETE_ALL_DOCSIZE  5
#define SQL_DELETE_ALL_STAT 6
#define SQL_SELECT_CONTENT_BY_ROWID 7
#define SQL_NEXT_SEGMENT_INDEX  8
#define SQL_INSERT_SEGMENTS 9
#define SQL_NEXT_SEGMENTS_ID 10
#define SQL_INSERT_SEGDIR  11
#define SQL_SELECT_LEVEL 12
#define SQL_SELECT_LEVEL_RANGE 13
#define SQL_SELECT_LEVEL_COUNT 14
#define SQL_SELECT_SEGDIR_MAX_LEVEL  15
#define SQL_DELETE_SEGDIR_LEVEL  16
#define SQL_DELETE_SEGMENTS_RANGE  17
#define SQL_CONTENT_INSERT 18
#define SQL_DELETE_DOCSIZE 19
#define SQL_REPLACE_DOCSIZE  20
#define SQL_SELECT_DOCSIZE 21
#define SQL_SELECT_STAT  22
#define SQL_REPLACE_STAT 23
#define SQL_SELECT_ALL_PREFIX_LEVEL  24
#define SQL_DELETE_ALL_TERMS_SEGDIR  25
#define SQL_DELETE_SEGDIR_RANGE  26
#define SQL_SELECT_ALL_LANGID  27
#define SQL_FIND_MERGE_LEVEL 28
#define SQL_MAX_LEAF_NODE_ESTIMATE 29
#define SQL_DELETE_SEGDIR_ENTRY  30
#define SQL_SHIFT_SEGDIR_ENTRY 31
#define SQL_SELECT_SEGDIR  32
#define SQL_CHOMP_SEGDIR 33
#define SQL_SEGMENT_IS_APPENDABLE  34
#define SQL_SELECT_INDEXES 35
#define SQL_SELECT_MXLEVEL 36
#define SQL_SELECT_LEVEL_RANGE2  37
#define SQL_UPDATE_LEVEL_IDX 38
#define SQL_UPDATE_LEVEL 39
static int fts3SqlStmt(  Fts3Table *p,  int eStmt,  sqlite3_stmt **pp,  sqlite3_value **apVal ){  const char *azSql[] = {  "DELETE FROM %Q.'%q_content' WHERE rowid = ?",  "SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)",  "DELETE FROM %Q.'%q_content'",  "DELETE FROM %Q.'%q_segments'",  "DELETE FROM %Q.'%q_segdir'",  "DELETE FROM %Q.'%q_docsize'",  "DELETE FROM %Q.'%q_stat'",  "SELECT %s WHERE rowid=?",  "SELECT (SELECT max(idx) FROM %Q.'%q_segdir' WHERE level = ?) + 1",  "REPLACE INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)",  "SELECT coalesce((SELECT max(blockid) FROM %Q.'%q_segments') + 1, 1)",  "REPLACE INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)",  "SELECT idx, start_block, leaves_end_block, end_block, root "  "FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC",  "SELECT idx, start_block, leaves_end_block, end_block, root "  "FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?"  "ORDER BY level DESC, idx ASC",  "SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?",  "SELECT max(level) FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",  "DELETE FROM %Q.'%q_segdir' WHERE level = ?",  "DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?",  "INSERT INTO %Q.'%q_content' VALUES(%s)",  "DELETE FROM %Q.'%q_docsize' WHERE docid = ?",  "REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",  "SELECT size FROM %Q.'%q_docsize' WHERE docid=?",  "SELECT value FROM %Q.'%q_stat' WHERE id=?",  "REPLACE INTO %Q.'%q_stat' VALUES(?,?)",  "",  "",  "DELETE FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ?",  "SELECT ? UNION SELECT level / (1024 * ?) FROM %Q.'%q_segdir'",  "SELECT level, count(*) AS cnt FROM %Q.'%q_segdir' "   " GROUP BY level HAVING cnt>=?"   " ORDER BY (level %% 1024) ASC, 2 DESC LIMIT 1",  "SELECT 2 * total(1 + leaves_end_block - start_block) "   " FROM (SELECT * FROM %Q.'%q_segdir' "   " WHERE level = ? ORDER BY idx ASC LIMIT ?"   " )",  "DELETE FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?",  "UPDATE %Q.'%q_segdir' SET idx = ? WHERE level=? AND idx=?",  "SELECT idx, start_block, leaves_end_block, end_block, root "  "FROM %Q.'%q_segdir' WHERE level = ? AND idx = ?",  "UPDATE %Q.'%q_segdir' SET start_block = ?, root = ?"  "WHERE level = ? AND idx = ?",  "SELECT 1 FROM %Q.'%q_segments' WHERE blockid=? AND block IS NULL",  "SELECT idx FROM %Q.'%q_segdir' WHERE level=? ORDER BY 1 ASC",  "SELECT max( level %% 1024 ) FROM %Q.'%q_segdir'",  "SELECT level, idx, end_block "  "FROM %Q.'%q_segdir' WHERE level BETWEEN ? AND ? "  "ORDER BY level DESC, idx ASC",  "UPDATE OR FAIL %Q.'%q_segdir' SET level=-1,idx=? "  "WHERE level=? AND idx=?",  "UPDATE OR FAIL %Q.'%q_segdir' SET level=? WHERE level=-1"  };  int rc = SQLITE_OK;  sqlite3_stmt *pStmt;  assert( SizeofArray(azSql)==SizeofArray(p->aStmt) );  assert( eStmt<SizeofArray(azSql) && eStmt>=0 );  pStmt = p->aStmt[eStmt];  if( !pStmt ){  int f = SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_NO_VTAB;  char *zSql;  if( eStmt==SQL_CONTENT_INSERT ){  zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName, p->zWriteExprlist);  }else if( eStmt==SQL_SELECT_CONTENT_BY_ROWID ){  f &= ~SQLITE_PREPARE_NO_VTAB;  zSql = sqlite3_mprintf(azSql[eStmt], p->zReadExprlist);  }else{  zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName);  }  if( !zSql ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v3(p->db, zSql, -1, f, &pStmt, NULL);  sqlite3_free(zSql);  assert( rc==SQLITE_OK || pStmt==0 );  p->aStmt[eStmt] = pStmt;  }  }  if( apVal ){  int i;  int nParam = sqlite3_bind_parameter_count(pStmt);  for(i=0; rc==SQLITE_OK && i<nParam; i++){  rc = sqlite3_bind_value(pStmt, i+1, apVal[i]);  }  }  *pp = pStmt;  return rc; } static int fts3SelectDocsize(  Fts3Table *pTab,  sqlite3_int64 iDocid,  sqlite3_stmt **ppStmt ){  sqlite3_stmt *pStmt = 0;  int rc;  rc = fts3SqlStmt(pTab, SQL_SELECT_DOCSIZE, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pStmt, 1, iDocid);  rc = sqlite3_step(pStmt);  if( rc!=SQLITE_ROW || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB ){  rc = sqlite3_reset(pStmt);  if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;  pStmt = 0;  }else{  rc = SQLITE_OK;  }  }  *ppStmt = pStmt;  return rc; } SQLITE_PRIVATE int sqlite3Fts3SelectDoctotal(  Fts3Table *pTab,  sqlite3_stmt **ppStmt ){  sqlite3_stmt *pStmt = 0;  int rc;  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);  if( sqlite3_step(pStmt)!=SQLITE_ROW   || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB  ){  rc = sqlite3_reset(pStmt);  if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;  pStmt = 0;  }  }  *ppStmt = pStmt;  return rc; } SQLITE_PRIVATE int sqlite3Fts3SelectDocsize(  Fts3Table *pTab,  sqlite3_int64 iDocid,  sqlite3_stmt **ppStmt ){  return fts3SelectDocsize(pTab, iDocid, ppStmt); } static void fts3SqlExec(  int *pRC,  Fts3Table *p,  int eStmt,  sqlite3_value **apVal ){  sqlite3_stmt *pStmt;  int rc;  if( *pRC ) return;  rc = fts3SqlStmt(p, eStmt, &pStmt, apVal);  if( rc==SQLITE_OK ){  sqlite3_step(pStmt);  rc = sqlite3_reset(pStmt);  }  *pRC = rc; } static int fts3Writelock(Fts3Table *p){  int rc = SQLITE_OK;  if( p->nPendingData==0 ){  sqlite3_stmt *pStmt;  rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_LEVEL, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_null(pStmt, 1);  sqlite3_step(pStmt);  rc = sqlite3_reset(pStmt);  }  }  return rc; } static sqlite3_int64 getAbsoluteLevel(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel ){  sqlite3_int64 iBase;  assert_fts3_nc( iLangid>=0 );  assert( p->nIndex>0 );  assert( iIndex>=0 && iIndex<p->nIndex );  iBase = ((sqlite3_int64)iLangid * p->nIndex + iIndex) * FTS3_SEGDIR_MAXLEVEL;  return iBase + iLevel; } SQLITE_PRIVATE int sqlite3Fts3AllSegdirs(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel,  sqlite3_stmt **ppStmt ){  int rc;  sqlite3_stmt *pStmt = 0;  assert( iLevel==FTS3_SEGCURSOR_ALL || iLevel>=0 );  assert( iLevel<FTS3_SEGDIR_MAXLEVEL );  assert( iIndex>=0 && iIndex<p->nIndex );  if( iLevel<0 ){  rc = fts3SqlStmt(p, SQL_SELECT_LEVEL_RANGE, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));  sqlite3_bind_int64(pStmt, 2,  getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL-1)  );  }  }else{  rc = fts3SqlStmt(p, SQL_SELECT_LEVEL, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex,iLevel));  }  }  *ppStmt = pStmt;  return rc; } static int fts3PendingListAppendVarint(  PendingList **pp,  sqlite3_int64 i ){  PendingList *p = *pp;  if( !p ){  p = sqlite3_malloc(sizeof(*p) + 100);  if( !p ){  return SQLITE_NOMEM;  }  p->nSpace = 100;  p->aData = (char *)&p[1];  p->nData = 0;  }  else if( p->nData+FTS3_VARINT_MAX+1>p->nSpace ){  int nNew = p->nSpace * 2;  p = sqlite3_realloc(p, sizeof(*p) + nNew);  if( !p ){  sqlite3_free(*pp);  *pp = 0;  return SQLITE_NOMEM;  }  p->nSpace = nNew;  p->aData = (char *)&p[1];  }  p->nData += sqlite3Fts3PutVarint(&p->aData[p->nData], i);  p->aData[p->nData] = '\0';  *pp = p;  return SQLITE_OK; } static int fts3PendingListAppend(  PendingList **pp,  sqlite3_int64 iDocid,  sqlite3_int64 iCol,  sqlite3_int64 iPos,  int *pRc ){  PendingList *p = *pp;  int rc = SQLITE_OK;  assert( !p || p->iLastDocid<=iDocid );  if( !p || p->iLastDocid!=iDocid ){  u64 iDelta = (u64)iDocid - (u64)(p ? p->iLastDocid : 0);  if( p ){  assert( p->nData<p->nSpace );  assert( p->aData[p->nData]==0 );  p->nData++;  }  if( SQLITE_OK!=(rc = fts3PendingListAppendVarint(&p, iDelta)) ){  goto pendinglistappend_out;  }  p->iLastCol = -1;  p->iLastPos = 0;  p->iLastDocid = iDocid;  }  if( iCol>0 && p->iLastCol!=iCol ){  if( SQLITE_OK!=(rc = fts3PendingListAppendVarint(&p, 1))   || SQLITE_OK!=(rc = fts3PendingListAppendVarint(&p, iCol))  ){  goto pendinglistappend_out;  }  p->iLastCol = iCol;  p->iLastPos = 0;  }  if( iCol>=0 ){  assert( iPos>p->iLastPos || (iPos==0 && p->iLastPos==0) );  rc = fts3PendingListAppendVarint(&p, 2+iPos-p->iLastPos);  if( rc==SQLITE_OK ){  p->iLastPos = iPos;  }  }  pendinglistappend_out:  *pRc = rc;  if( p!=*pp ){  *pp = p;  return 1;  }  return 0; } static void fts3PendingListDelete(PendingList *pList){  sqlite3_free(pList); } static int fts3PendingTermsAddOne(  Fts3Table *p,  int iCol,  int iPos,  Fts3Hash *pHash,  const char *zToken,  int nToken ){  PendingList *pList;  int rc = SQLITE_OK;  pList = (PendingList *)fts3HashFind(pHash, zToken, nToken);  if( pList ){  p->nPendingData -= (pList->nData + nToken + sizeof(Fts3HashElem));  }  if( fts3PendingListAppend(&pList, p->iPrevDocid, iCol, iPos, &rc) ){  if( pList==fts3HashInsert(pHash, zToken, nToken, pList) ){  assert( 0==fts3HashFind(pHash, zToken, nToken) );  sqlite3_free(pList);  rc = SQLITE_NOMEM;  }  }  if( rc==SQLITE_OK ){  p->nPendingData += (pList->nData + nToken + sizeof(Fts3HashElem));  }  return rc; } static int fts3PendingTermsAdd(  Fts3Table *p,  int iLangid,  const char *zText,  int iCol,  u32 *pnWord ){  int rc;  int iStart = 0;  int iEnd = 0;  int iPos = 0;  int nWord = 0;  char const *zToken;  int nToken = 0;  sqlite3_tokenizer *pTokenizer = p->pTokenizer;  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;  sqlite3_tokenizer_cursor *pCsr;  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,  const char**,int*,int*,int*,int*);  assert( pTokenizer && pModule );  if( zText==0 ){  *pnWord = 0;  return SQLITE_OK;  }  rc = sqlite3Fts3OpenTokenizer(pTokenizer, iLangid, zText, -1, &pCsr);  if( rc!=SQLITE_OK ){  return rc;  }  xNext = pModule->xNext;  while( SQLITE_OK==rc  && SQLITE_OK==(rc = xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos))  ){  int i;  if( iPos>=nWord ) nWord = iPos+1;  if( iPos<0 || !zToken || nToken<=0 ){  rc = SQLITE_ERROR;  break;  }  rc = fts3PendingTermsAddOne(  p, iCol, iPos, &p->aIndex[0].hPending, zToken, nToken  );  for(i=1; rc==SQLITE_OK && i<p->nIndex; i++){  struct Fts3Index *pIndex = &p->aIndex[i];  if( nToken<pIndex->nPrefix ) continue;  rc = fts3PendingTermsAddOne(  p, iCol, iPos, &pIndex->hPending, zToken, pIndex->nPrefix  );  }  }  pModule->xClose(pCsr);  *pnWord += nWord;  return (rc==SQLITE_DONE ? SQLITE_OK : rc); } static int fts3PendingTermsDocid(  Fts3Table *p,  int bDelete,  int iLangid,  sqlite_int64 iDocid ){  assert( iLangid>=0 );  assert( bDelete==1 || bDelete==0 );  if( iDocid<p->iPrevDocid   || (iDocid==p->iPrevDocid && p->bPrevDelete==0)   || p->iPrevLangid!=iLangid   || p->nPendingData>p->nMaxPendingData  ){  int rc = sqlite3Fts3PendingTermsFlush(p);  if( rc!=SQLITE_OK ) return rc;  }  p->iPrevDocid = iDocid;  p->iPrevLangid = iLangid;  p->bPrevDelete = bDelete;  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3Fts3PendingTermsClear(Fts3Table *p){  int i;  for(i=0; i<p->nIndex; i++){  Fts3HashElem *pElem;  Fts3Hash *pHash = &p->aIndex[i].hPending;  for(pElem=fts3HashFirst(pHash); pElem; pElem=fts3HashNext(pElem)){  PendingList *pList = (PendingList *)fts3HashData(pElem);  fts3PendingListDelete(pList);  }  fts3HashClear(pHash);  }  p->nPendingData = 0; } static int fts3InsertTerms(  Fts3Table *p,  int iLangid,  sqlite3_value **apVal,  u32 *aSz ){  int i;  for(i=2; i<p->nColumn+2; i++){  int iCol = i-2;  if( p->abNotindexed[iCol]==0 ){  const char *zText = (const char *)sqlite3_value_text(apVal[i]);  int rc = fts3PendingTermsAdd(p, iLangid, zText, iCol, &aSz[iCol]);  if( rc!=SQLITE_OK ){  return rc;  }  aSz[p->nColumn] += sqlite3_value_bytes(apVal[i]);  }  }  return SQLITE_OK; } static int fts3InsertData(  Fts3Table *p,  sqlite3_value **apVal,  sqlite3_int64 *piDocid ){  int rc;  sqlite3_stmt *pContentInsert;  if( p->zContentTbl ){  sqlite3_value *pRowid = apVal[p->nColumn+3];  if( sqlite3_value_type(pRowid)==SQLITE_NULL ){  pRowid = apVal[1];  }  if( sqlite3_value_type(pRowid)!=SQLITE_INTEGER ){  return SQLITE_CONSTRAINT;  }  *piDocid = sqlite3_value_int64(pRowid);  return SQLITE_OK;  }  rc = fts3SqlStmt(p, SQL_CONTENT_INSERT, &pContentInsert, &apVal[1]);  if( rc==SQLITE_OK && p->zLanguageid ){  rc = sqlite3_bind_int(  pContentInsert, p->nColumn+2,  sqlite3_value_int(apVal[p->nColumn+4])  );  }  if( rc!=SQLITE_OK ) return rc;  if( SQLITE_NULL!=sqlite3_value_type(apVal[3+p->nColumn]) ){  if( SQLITE_NULL==sqlite3_value_type(apVal[0])   && SQLITE_NULL!=sqlite3_value_type(apVal[1])  ){  return SQLITE_ERROR;  }  rc = sqlite3_bind_value(pContentInsert, 1, apVal[3+p->nColumn]);  if( rc!=SQLITE_OK ) return rc;  }  sqlite3_step(pContentInsert);  rc = sqlite3_reset(pContentInsert);  *piDocid = sqlite3_last_insert_rowid(p->db);  return rc; } static int fts3DeleteAll(Fts3Table *p, int bContent){  int rc = SQLITE_OK;  sqlite3Fts3PendingTermsClear(p);  assert( p->zContentTbl==0 || bContent==0 );  if( bContent ) fts3SqlExec(&rc, p, SQL_DELETE_ALL_CONTENT, 0);  fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGMENTS, 0);  fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGDIR, 0);  if( p->bHasDocsize ){  fts3SqlExec(&rc, p, SQL_DELETE_ALL_DOCSIZE, 0);  }  if( p->bHasStat ){  fts3SqlExec(&rc, p, SQL_DELETE_ALL_STAT, 0);  }  return rc; } static int langidFromSelect(Fts3Table *p, sqlite3_stmt *pSelect){  int iLangid = 0;  if( p->zLanguageid ) iLangid = sqlite3_column_int(pSelect, p->nColumn+1);  return iLangid; } static void fts3DeleteTerms(  int *pRC,  Fts3Table *p,  sqlite3_value *pRowid,  u32 *aSz,  int *pbFound ){  int rc;  sqlite3_stmt *pSelect;  assert( *pbFound==0 );  if( *pRC ) return;  rc = fts3SqlStmt(p, SQL_SELECT_CONTENT_BY_ROWID, &pSelect, &pRowid);  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pSelect) ){  int i;  int iLangid = langidFromSelect(p, pSelect);  i64 iDocid = sqlite3_column_int64(pSelect, 0);  rc = fts3PendingTermsDocid(p, 1, iLangid, iDocid);  for(i=1; rc==SQLITE_OK && i<=p->nColumn; i++){  int iCol = i-1;  if( p->abNotindexed[iCol]==0 ){  const char *zText = (const char *)sqlite3_column_text(pSelect, i);  rc = fts3PendingTermsAdd(p, iLangid, zText, -1, &aSz[iCol]);  aSz[p->nColumn] += sqlite3_column_bytes(pSelect, i);  }  }  if( rc!=SQLITE_OK ){  sqlite3_reset(pSelect);  *pRC = rc;  return;  }  *pbFound = 1;  }  rc = sqlite3_reset(pSelect);  }else{  sqlite3_reset(pSelect);  }  *pRC = rc; } static int fts3SegmentMerge(Fts3Table *, int, int, int); static int fts3AllocateSegdirIdx(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel,  int *piIdx ){  int rc;  sqlite3_stmt *pNextIdx;  int iNext = 0;  assert( iLangid>=0 );  assert( p->nIndex>=1 );  rc = fts3SqlStmt(p, SQL_NEXT_SEGMENT_INDEX, &pNextIdx, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(  pNextIdx, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel)  );  if( SQLITE_ROW==sqlite3_step(pNextIdx) ){  iNext = sqlite3_column_int(pNextIdx, 0);  }  rc = sqlite3_reset(pNextIdx);  }  if( rc==SQLITE_OK ){  if( iNext>=MergeCount(p) ){  fts3LogMerge(16, getAbsoluteLevel(p, iLangid, iIndex, iLevel));  rc = fts3SegmentMerge(p, iLangid, iIndex, iLevel);  *piIdx = 0;  }else{  *piIdx = iNext;  }  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3ReadBlock(  Fts3Table *p,  sqlite3_int64 iBlockid,  char **paBlob,  int *pnBlob,  int *pnLoad ){  int rc;  assert( pnBlob );  if( p->pSegments ){  rc = sqlite3_blob_reopen(p->pSegments, iBlockid);  }else{  if( 0==p->zSegmentsTbl ){  p->zSegmentsTbl = sqlite3_mprintf("%s_segments", p->zName);  if( 0==p->zSegmentsTbl ) return SQLITE_NOMEM;  }  rc = sqlite3_blob_open(   p->db, p->zDb, p->zSegmentsTbl, "block", iBlockid, 0, &p->pSegments  );  }  if( rc==SQLITE_OK ){  int nByte = sqlite3_blob_bytes(p->pSegments);  *pnBlob = nByte;  if( paBlob ){  char *aByte = sqlite3_malloc(nByte + FTS3_NODE_PADDING);  if( !aByte ){  rc = SQLITE_NOMEM;  }else{  if( pnLoad && nByte>(FTS3_NODE_CHUNK_THRESHOLD) ){  nByte = FTS3_NODE_CHUNKSIZE;  *pnLoad = nByte;  }  rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0);  memset(&aByte[nByte], 0, FTS3_NODE_PADDING);  if( rc!=SQLITE_OK ){  sqlite3_free(aByte);  aByte = 0;  }  }  *paBlob = aByte;  }  }else if( rc==SQLITE_ERROR ){  rc = FTS_CORRUPT_VTAB;  }  return rc; } SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *p){  sqlite3_blob_close(p->pSegments);  p->pSegments = 0; } static int fts3SegReaderIncrRead(Fts3SegReader *pReader){  int nRead;  int rc;  nRead = MIN(pReader->nNode - pReader->nPopulate, FTS3_NODE_CHUNKSIZE);  rc = sqlite3_blob_read(  pReader->pBlob,  &pReader->aNode[pReader->nPopulate],  nRead,  pReader->nPopulate  );  if( rc==SQLITE_OK ){  pReader->nPopulate += nRead;  memset(&pReader->aNode[pReader->nPopulate], 0, FTS3_NODE_PADDING);  if( pReader->nPopulate==pReader->nNode ){  sqlite3_blob_close(pReader->pBlob);  pReader->pBlob = 0;  pReader->nPopulate = 0;  }  }  return rc; } static int fts3SegReaderRequire(Fts3SegReader *pReader, char *pFrom, int nByte){  int rc = SQLITE_OK;  assert( !pReader->pBlob   || (pFrom>=pReader->aNode && pFrom<&pReader->aNode[pReader->nNode])  );  while( pReader->pBlob && rc==SQLITE_OK   && (pFrom - pReader->aNode + nByte)>pReader->nPopulate  ){  rc = fts3SegReaderIncrRead(pReader);  }  return rc; } static void fts3SegReaderSetEof(Fts3SegReader *pSeg){  if( !fts3SegReaderIsRootOnly(pSeg) ){  sqlite3_free(pSeg->aNode);  sqlite3_blob_close(pSeg->pBlob);  pSeg->pBlob = 0;  }  pSeg->aNode = 0; } static int fts3SegReaderNext(  Fts3Table *p,  Fts3SegReader *pReader,  int bIncr ){  int rc;  char *pNext;  int nPrefix;  int nSuffix;  if( !pReader->aDoclist ){  pNext = pReader->aNode;  }else{  pNext = &pReader->aDoclist[pReader->nDoclist];  }  if( !pNext || pNext>=&pReader->aNode[pReader->nNode] ){  if( fts3SegReaderIsPending(pReader) ){  Fts3HashElem *pElem = *(pReader->ppNextElem);  sqlite3_free(pReader->aNode);  pReader->aNode = 0;  if( pElem ){  char *aCopy;  PendingList *pList = (PendingList *)fts3HashData(pElem);  int nCopy = pList->nData+1;  int nTerm = fts3HashKeysize(pElem);  if( (nTerm+1)>pReader->nTermAlloc ){  sqlite3_free(pReader->zTerm);  pReader->zTerm = (char*)sqlite3_malloc((nTerm+1)*2);  if( !pReader->zTerm ) return SQLITE_NOMEM;  pReader->nTermAlloc = (nTerm+1)*2;  }  memcpy(pReader->zTerm, fts3HashKey(pElem), nTerm);  pReader->zTerm[nTerm] = '\0';  pReader->nTerm = nTerm;  aCopy = (char*)sqlite3_malloc(nCopy);  if( !aCopy ) return SQLITE_NOMEM;  memcpy(aCopy, pList->aData, nCopy);  pReader->nNode = pReader->nDoclist = nCopy;  pReader->aNode = pReader->aDoclist = aCopy;  pReader->ppNextElem++;  assert( pReader->aNode );  }  return SQLITE_OK;  }  fts3SegReaderSetEof(pReader);
#ifdef CORRUPT_DB
 assert( pReader->iCurrentBlock<=pReader->iLeafEndBlock || CORRUPT_DB );
#endif
 if( pReader->iCurrentBlock>=pReader->iLeafEndBlock ){  return SQLITE_OK;  }  rc = sqlite3Fts3ReadBlock(  p, ++pReader->iCurrentBlock, &pReader->aNode, &pReader->nNode,  (bIncr ? &pReader->nPopulate : 0)  );  if( rc!=SQLITE_OK ) return rc;  assert( pReader->pBlob==0 );  if( bIncr && pReader->nPopulate<pReader->nNode ){  pReader->pBlob = p->pSegments;  p->pSegments = 0;  }  pNext = pReader->aNode;  }  assert( !fts3SegReaderIsPending(pReader) );  rc = fts3SegReaderRequire(pReader, pNext, FTS3_VARINT_MAX*2);  if( rc!=SQLITE_OK ) return rc;  pNext += fts3GetVarint32(pNext, &nPrefix);  pNext += fts3GetVarint32(pNext, &nSuffix);  if( nSuffix<=0   || (&pReader->aNode[pReader->nNode] - pNext)<nSuffix   || nPrefix>pReader->nTerm  ){  return FTS_CORRUPT_VTAB;  }  if( (i64)nPrefix+nSuffix>(i64)pReader->nTermAlloc ){  i64 nNew = ((i64)nPrefix+nSuffix)*2;  char *zNew = sqlite3_realloc64(pReader->zTerm, nNew);  if( !zNew ){  return SQLITE_NOMEM;  }  pReader->zTerm = zNew;  pReader->nTermAlloc = nNew;  }  rc = fts3SegReaderRequire(pReader, pNext, nSuffix+FTS3_VARINT_MAX);  if( rc!=SQLITE_OK ) return rc;  memcpy(&pReader->zTerm[nPrefix], pNext, nSuffix);  pReader->nTerm = nPrefix+nSuffix;  pNext += nSuffix;  pNext += fts3GetVarint32(pNext, &pReader->nDoclist);  pReader->aDoclist = pNext;  pReader->pOffsetList = 0;  if( pReader->nDoclist > pReader->nNode-(pReader->aDoclist-pReader->aNode)   || (pReader->nPopulate==0 && pReader->aDoclist[pReader->nDoclist-1])   || pReader->nDoclist==0  ){  return FTS_CORRUPT_VTAB;  }  return SQLITE_OK; } static int fts3SegReaderFirstDocid(Fts3Table *pTab, Fts3SegReader *pReader){  int rc = SQLITE_OK;  assert( pReader->aDoclist );  assert( !pReader->pOffsetList );  if( pTab->bDescIdx && fts3SegReaderIsPending(pReader) ){  u8 bEof = 0;  pReader->iDocid = 0;  pReader->nOffsetList = 0;  sqlite3Fts3DoclistPrev(0,  pReader->aDoclist, pReader->nDoclist, &pReader->pOffsetList,  &pReader->iDocid, &pReader->nOffsetList, &bEof  );  }else{  rc = fts3SegReaderRequire(pReader, pReader->aDoclist, FTS3_VARINT_MAX);  if( rc==SQLITE_OK ){  int n = sqlite3Fts3GetVarint(pReader->aDoclist, &pReader->iDocid);  pReader->pOffsetList = &pReader->aDoclist[n];  }  }  return rc; } static int fts3SegReaderNextDocid(  Fts3Table *pTab,  Fts3SegReader *pReader,  char **ppOffsetList,  int *pnOffsetList ){  int rc = SQLITE_OK;  char *p = pReader->pOffsetList;  char c = 0;  assert( p );  if( pTab->bDescIdx && fts3SegReaderIsPending(pReader) ){  u8 bEof = 0;  if( ppOffsetList ){  *ppOffsetList = pReader->pOffsetList;  *pnOffsetList = pReader->nOffsetList - 1;  }  sqlite3Fts3DoclistPrev(0,  pReader->aDoclist, pReader->nDoclist, &p, &pReader->iDocid,  &pReader->nOffsetList, &bEof  );  if( bEof ){  pReader->pOffsetList = 0;  }else{  pReader->pOffsetList = p;  }  }else{  char *pEnd = &pReader->aDoclist[pReader->nDoclist];  while( 1 ){  while( *p | c ) c = *p++ & 0x80;  assert( *p==0 );  if( pReader->pBlob==0 || p<&pReader->aNode[pReader->nPopulate] ) break;  rc = fts3SegReaderIncrRead(pReader);  if( rc!=SQLITE_OK ) return rc;  }  p++;  if( ppOffsetList ){  *ppOffsetList = pReader->pOffsetList;  *pnOffsetList = (int)(p - pReader->pOffsetList - 1);  }  while( p<pEnd && *p==0 ) p++;  if( p>=pEnd ){  pReader->pOffsetList = 0;  }else{  rc = fts3SegReaderRequire(pReader, p, FTS3_VARINT_MAX);  if( rc==SQLITE_OK ){  u64 iDelta;  pReader->pOffsetList = p + sqlite3Fts3GetVarintU(p, &iDelta);  if( pTab->bDescIdx ){  pReader->iDocid = (i64)((u64)pReader->iDocid - iDelta);  }else{  pReader->iDocid = (i64)((u64)pReader->iDocid + iDelta);  }  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3MsrOvfl(  Fts3Cursor *pCsr,  Fts3MultiSegReader *pMsr,  int *pnOvfl ){  Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;  int nOvfl = 0;  int ii;  int rc = SQLITE_OK;  int pgsz = p->nPgsz;  assert( p->bFts4 );  assert( pgsz>0 );  for(ii=0; rc==SQLITE_OK && ii<pMsr->nSegment; ii++){  Fts3SegReader *pReader = pMsr->apSegment[ii];  if( !fts3SegReaderIsPending(pReader)   && !fts3SegReaderIsRootOnly(pReader)  ){  sqlite3_int64 jj;  for(jj=pReader->iStartBlock; jj<=pReader->iLeafEndBlock; jj++){  int nBlob;  rc = sqlite3Fts3ReadBlock(p, jj, 0, &nBlob, 0);  if( rc!=SQLITE_OK ) break;  if( (nBlob+35)>pgsz ){  nOvfl += (nBlob + 34)/pgsz;  }  }  }  }  *pnOvfl = nOvfl;  return rc; } SQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *pReader){  if( pReader ){  sqlite3_free(pReader->zTerm);  if( !fts3SegReaderIsRootOnly(pReader) ){  sqlite3_free(pReader->aNode);  }  sqlite3_blob_close(pReader->pBlob);  }  sqlite3_free(pReader); } SQLITE_PRIVATE int sqlite3Fts3SegReaderNew(  int iAge,  int bLookup,  sqlite3_int64 iStartLeaf,  sqlite3_int64 iEndLeaf,  sqlite3_int64 iEndBlock,  const char *zRoot,  int nRoot,  Fts3SegReader **ppReader ){  Fts3SegReader *pReader;  int nExtra = 0;  assert( zRoot!=0 || nRoot==0 );
#ifdef CORRUPT_DB
 assert( zRoot!=0 || CORRUPT_DB );
#endif
 if( iStartLeaf==0 ){  if( iEndLeaf!=0 ) return FTS_CORRUPT_VTAB;  nExtra = nRoot + FTS3_NODE_PADDING;  }  pReader = (Fts3SegReader *)sqlite3_malloc(sizeof(Fts3SegReader) + nExtra);  if( !pReader ){  return SQLITE_NOMEM;  }  memset(pReader, 0, sizeof(Fts3SegReader));  pReader->iIdx = iAge;  pReader->bLookup = bLookup!=0;  pReader->iStartBlock = iStartLeaf;  pReader->iLeafEndBlock = iEndLeaf;  pReader->iEndBlock = iEndBlock;  if( nExtra ){  pReader->aNode = (char *)&pReader[1];  pReader->rootOnly = 1;  pReader->nNode = nRoot;  if( nRoot ) memcpy(pReader->aNode, zRoot, nRoot);  memset(&pReader->aNode[nRoot], 0, FTS3_NODE_PADDING);  }else{  pReader->iCurrentBlock = iStartLeaf-1;  }  *ppReader = pReader;  return SQLITE_OK; } static int SQLITE_CDECL fts3CompareElemByTerm(  const void *lhs,  const void *rhs ){  char *z1 = fts3HashKey(*(Fts3HashElem **)lhs);  char *z2 = fts3HashKey(*(Fts3HashElem **)rhs);  int n1 = fts3HashKeysize(*(Fts3HashElem **)lhs);  int n2 = fts3HashKeysize(*(Fts3HashElem **)rhs);  int n = (n1<n2 ? n1 : n2);  int c = memcmp(z1, z2, n);  if( c==0 ){  c = n1 - n2;  }  return c; } SQLITE_PRIVATE int sqlite3Fts3SegReaderPending(  Fts3Table *p,  int iIndex,  const char *zTerm,  int nTerm,  int bPrefix,  Fts3SegReader **ppReader ){  Fts3SegReader *pReader = 0;  Fts3HashElem *pE;  Fts3HashElem **aElem = 0;  int nElem = 0;  int rc = SQLITE_OK;  Fts3Hash *pHash;  pHash = &p->aIndex[iIndex].hPending;  if( bPrefix ){  int nAlloc = 0;  for(pE=fts3HashFirst(pHash); pE; pE=fts3HashNext(pE)){  char *zKey = (char *)fts3HashKey(pE);  int nKey = fts3HashKeysize(pE);  if( nTerm==0 || (nKey>=nTerm && 0==memcmp(zKey, zTerm, nTerm)) ){  if( nElem==nAlloc ){  Fts3HashElem **aElem2;  nAlloc += 16;  aElem2 = (Fts3HashElem **)sqlite3_realloc(  aElem, nAlloc*sizeof(Fts3HashElem *)  );  if( !aElem2 ){  rc = SQLITE_NOMEM;  nElem = 0;  break;  }  aElem = aElem2;  }  aElem[nElem++] = pE;  }  }  if( nElem>1 ){  qsort(aElem, nElem, sizeof(Fts3HashElem *), fts3CompareElemByTerm);  }  }else{  pE = fts3HashFindElem(pHash, zTerm, nTerm);  if( pE ){  aElem = &pE;  nElem = 1;  }  }  if( nElem>0 ){  sqlite3_int64 nByte;  nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);  pReader = (Fts3SegReader *)sqlite3_malloc64(nByte);  if( !pReader ){  rc = SQLITE_NOMEM;  }else{  memset(pReader, 0, nByte);  pReader->iIdx = 0x7FFFFFFF;  pReader->ppNextElem = (Fts3HashElem **)&pReader[1];  memcpy(pReader->ppNextElem, aElem, nElem*sizeof(Fts3HashElem *));  }  }  if( bPrefix ){  sqlite3_free(aElem);  }  *ppReader = pReader;  return rc; } static int fts3SegReaderCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){  int rc;  if( pLhs->aNode && pRhs->aNode ){  int rc2 = pLhs->nTerm - pRhs->nTerm;  if( rc2<0 ){  rc = memcmp(pLhs->zTerm, pRhs->zTerm, pLhs->nTerm);  }else{  rc = memcmp(pLhs->zTerm, pRhs->zTerm, pRhs->nTerm);  }  if( rc==0 ){  rc = rc2;  }  }else{  rc = (pLhs->aNode==0) - (pRhs->aNode==0);  }  if( rc==0 ){  rc = pRhs->iIdx - pLhs->iIdx;  }  assert_fts3_nc( rc!=0 );  return rc; } static int fts3SegReaderDoclistCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){  int rc = (pLhs->pOffsetList==0)-(pRhs->pOffsetList==0);  if( rc==0 ){  if( pLhs->iDocid==pRhs->iDocid ){  rc = pRhs->iIdx - pLhs->iIdx;  }else{  rc = (pLhs->iDocid > pRhs->iDocid) ? 1 : -1;  }  }  assert( pLhs->aNode && pRhs->aNode );  return rc; } static int fts3SegReaderDoclistCmpRev(Fts3SegReader *pLhs, Fts3SegReader *pRhs){  int rc = (pLhs->pOffsetList==0)-(pRhs->pOffsetList==0);  if( rc==0 ){  if( pLhs->iDocid==pRhs->iDocid ){  rc = pRhs->iIdx - pLhs->iIdx;  }else{  rc = (pLhs->iDocid < pRhs->iDocid) ? 1 : -1;  }  }  assert( pLhs->aNode && pRhs->aNode );  return rc; } static int fts3SegReaderTermCmp(  Fts3SegReader *pSeg,  const char *zTerm,  int nTerm ){  int res = 0;  if( pSeg->aNode ){  if( pSeg->nTerm>nTerm ){  res = memcmp(pSeg->zTerm, zTerm, nTerm);  }else{  res = memcmp(pSeg->zTerm, zTerm, pSeg->nTerm);  }  if( res==0 ){  res = pSeg->nTerm-nTerm;  }  }  return res; } static void fts3SegReaderSort(  Fts3SegReader **apSegment,  int nSegment,  int nSuspect,  int (*xCmp)(Fts3SegReader *, Fts3SegReader *) ){  int i;  assert( nSuspect<=nSegment );  if( nSuspect==nSegment ) nSuspect--;  for(i=nSuspect-1; i>=0; i--){  int j;  for(j=i; j<(nSegment-1); j++){  Fts3SegReader *pTmp;  if( xCmp(apSegment[j], apSegment[j+1])<0 ) break;  pTmp = apSegment[j+1];  apSegment[j+1] = apSegment[j];  apSegment[j] = pTmp;  }  }
#ifndef NDEBUG
 for(i=0; i<(nSuspect-1); i++){  assert( xCmp(apSegment[i], apSegment[i+1])<0 );  }
#endif
} static int fts3WriteSegment(  Fts3Table *p,  sqlite3_int64 iBlock,  char *z,  int n ){  sqlite3_stmt *pStmt;  int rc = fts3SqlStmt(p, SQL_INSERT_SEGMENTS, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pStmt, 1, iBlock);  sqlite3_bind_blob(pStmt, 2, z, n, SQLITE_STATIC);  sqlite3_step(pStmt);  rc = sqlite3_reset(pStmt);  sqlite3_bind_null(pStmt, 2);  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3MaxLevel(Fts3Table *p, int *pnMax){  int rc;  int mxLevel = 0;  sqlite3_stmt *pStmt = 0;  rc = fts3SqlStmt(p, SQL_SELECT_MXLEVEL, &pStmt, 0);  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  mxLevel = sqlite3_column_int(pStmt, 0);  }  rc = sqlite3_reset(pStmt);  }  *pnMax = mxLevel;  return rc; } static int fts3WriteSegdir(  Fts3Table *p,  sqlite3_int64 iLevel,  int iIdx,  sqlite3_int64 iStartBlock,  sqlite3_int64 iLeafEndBlock,  sqlite3_int64 iEndBlock,  sqlite3_int64 nLeafData,  char *zRoot,  int nRoot ){  sqlite3_stmt *pStmt;  int rc = fts3SqlStmt(p, SQL_INSERT_SEGDIR, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pStmt, 1, iLevel);  sqlite3_bind_int(pStmt, 2, iIdx);  sqlite3_bind_int64(pStmt, 3, iStartBlock);  sqlite3_bind_int64(pStmt, 4, iLeafEndBlock);  if( nLeafData==0 ){  sqlite3_bind_int64(pStmt, 5, iEndBlock);  }else{  char *zEnd = sqlite3_mprintf("%lld %lld", iEndBlock, nLeafData);  if( !zEnd ) return SQLITE_NOMEM;  sqlite3_bind_text(pStmt, 5, zEnd, -1, sqlite3_free);  }  sqlite3_bind_blob(pStmt, 6, zRoot, nRoot, SQLITE_STATIC);  sqlite3_step(pStmt);  rc = sqlite3_reset(pStmt);  sqlite3_bind_null(pStmt, 6);  }  return rc; } static int fts3PrefixCompress(  const char *zPrev,  int nPrev,  const char *zNext,  int nNext ){  int n;  for(n=0; n<nPrev && n<nNext && zPrev[n]==zNext[n]; n++);  assert_fts3_nc( n<nNext );  return n; } static int fts3NodeAddTerm(  Fts3Table *p,  SegmentNode **ppTree,  int isCopyTerm,  const char *zTerm,  int nTerm ){  SegmentNode *pTree = *ppTree;  int rc;  SegmentNode *pNew;  if( pTree ){  int nData = pTree->nData;  int nReq = nData;  int nPrefix;  int nSuffix;  nPrefix = fts3PrefixCompress(pTree->zTerm, pTree->nTerm, zTerm, nTerm);  nSuffix = nTerm-nPrefix;  if( nSuffix<=0 ) return FTS_CORRUPT_VTAB;  nReq += sqlite3Fts3VarintLen(nPrefix)+sqlite3Fts3VarintLen(nSuffix)+nSuffix;  if( nReq<=p->nNodeSize || !pTree->zTerm ){  if( nReq>p->nNodeSize ){  assert( pTree->aData==(char *)&pTree[1] );  pTree->aData = (char *)sqlite3_malloc(nReq);  if( !pTree->aData ){  return SQLITE_NOMEM;  }  }  if( pTree->zTerm ){  nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nPrefix);  }  nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nSuffix);  memcpy(&pTree->aData[nData], &zTerm[nPrefix], nSuffix);  pTree->nData = nData + nSuffix;  pTree->nEntry++;  if( isCopyTerm ){  if( pTree->nMalloc<nTerm ){  char *zNew = sqlite3_realloc(pTree->zMalloc, nTerm*2);  if( !zNew ){  return SQLITE_NOMEM;  }  pTree->nMalloc = nTerm*2;  pTree->zMalloc = zNew;  }  pTree->zTerm = pTree->zMalloc;  memcpy(pTree->zTerm, zTerm, nTerm);  pTree->nTerm = nTerm;  }else{  pTree->zTerm = (char *)zTerm;  pTree->nTerm = nTerm;  }  return SQLITE_OK;  }  }  pNew = (SegmentNode *)sqlite3_malloc(sizeof(SegmentNode) + p->nNodeSize);  if( !pNew ){  return SQLITE_NOMEM;  }  memset(pNew, 0, sizeof(SegmentNode));  pNew->nData = 1 + FTS3_VARINT_MAX;  pNew->aData = (char *)&pNew[1];  if( pTree ){  SegmentNode *pParent = pTree->pParent;  rc = fts3NodeAddTerm(p, &pParent, isCopyTerm, zTerm, nTerm);  if( pTree->pParent==0 ){  pTree->pParent = pParent;  }  pTree->pRight = pNew;  pNew->pLeftmost = pTree->pLeftmost;  pNew->pParent = pParent;  pNew->zMalloc = pTree->zMalloc;  pNew->nMalloc = pTree->nMalloc;  pTree->zMalloc = 0;  }else{  pNew->pLeftmost = pNew;  rc = fts3NodeAddTerm(p, &pNew, isCopyTerm, zTerm, nTerm);  }  *ppTree = pNew;  return rc; } static int fts3TreeFinishNode(  SegmentNode *pTree,  int iHeight,  sqlite3_int64 iLeftChild ){  int nStart;  assert( iHeight>=1 && iHeight<128 );  nStart = FTS3_VARINT_MAX - sqlite3Fts3VarintLen(iLeftChild);  pTree->aData[nStart] = (char)iHeight;  sqlite3Fts3PutVarint(&pTree->aData[nStart+1], iLeftChild);  return nStart; } static int fts3NodeWrite(  Fts3Table *p,  SegmentNode *pTree,  int iHeight,  sqlite3_int64 iLeaf,  sqlite3_int64 iFree,  sqlite3_int64 *piLast,  char **paRoot,  int *pnRoot ){  int rc = SQLITE_OK;  if( !pTree->pParent ){  int nStart = fts3TreeFinishNode(pTree, iHeight, iLeaf);  *piLast = iFree-1;  *pnRoot = pTree->nData - nStart;  *paRoot = &pTree->aData[nStart];  }else{  SegmentNode *pIter;  sqlite3_int64 iNextFree = iFree;  sqlite3_int64 iNextLeaf = iLeaf;  for(pIter=pTree->pLeftmost; pIter && rc==SQLITE_OK; pIter=pIter->pRight){  int nStart = fts3TreeFinishNode(pIter, iHeight, iNextLeaf);  int nWrite = pIter->nData - nStart;  rc = fts3WriteSegment(p, iNextFree, &pIter->aData[nStart], nWrite);  iNextFree++;  iNextLeaf += (pIter->nEntry+1);  }  if( rc==SQLITE_OK ){  assert( iNextLeaf==iFree );  rc = fts3NodeWrite(  p, pTree->pParent, iHeight+1, iFree, iNextFree, piLast, paRoot, pnRoot  );  }  }  return rc; } static void fts3NodeFree(SegmentNode *pTree){  if( pTree ){  SegmentNode *p = pTree->pLeftmost;  fts3NodeFree(p->pParent);  while( p ){  SegmentNode *pRight = p->pRight;  if( p->aData!=(char *)&p[1] ){  sqlite3_free(p->aData);  }  assert( pRight==0 || p->zMalloc==0 );  sqlite3_free(p->zMalloc);  sqlite3_free(p);  p = pRight;  }  } } static int fts3SegWriterAdd(  Fts3Table *p,  SegmentWriter **ppWriter,  int isCopyTerm,  const char *zTerm,  int nTerm,  const char *aDoclist,  int nDoclist ){  int nPrefix;  int nSuffix;  int nReq;  int nData;  SegmentWriter *pWriter = *ppWriter;  if( !pWriter ){  int rc;  sqlite3_stmt *pStmt;  pWriter = (SegmentWriter *)sqlite3_malloc(sizeof(SegmentWriter));  if( !pWriter ) return SQLITE_NOMEM;  memset(pWriter, 0, sizeof(SegmentWriter));  *ppWriter = pWriter;  pWriter->aData = (char *)sqlite3_malloc(p->nNodeSize);  if( !pWriter->aData ) return SQLITE_NOMEM;  pWriter->nSize = p->nNodeSize;  rc = fts3SqlStmt(p, SQL_NEXT_SEGMENTS_ID, &pStmt, 0);  if( rc!=SQLITE_OK ) return rc;  if( SQLITE_ROW==sqlite3_step(pStmt) ){  pWriter->iFree = sqlite3_column_int64(pStmt, 0);  pWriter->iFirst = pWriter->iFree;  }  rc = sqlite3_reset(pStmt);  if( rc!=SQLITE_OK ) return rc;  }  nData = pWriter->nData;  nPrefix = fts3PrefixCompress(pWriter->zTerm, pWriter->nTerm, zTerm, nTerm);  nSuffix = nTerm-nPrefix;  if( nSuffix<=0 ) return FTS_CORRUPT_VTAB;  nReq = sqlite3Fts3VarintLen(nPrefix) +  sqlite3Fts3VarintLen(nSuffix) +  nSuffix +  sqlite3Fts3VarintLen(nDoclist) +  nDoclist;  if( nData>0 && nData+nReq>p->nNodeSize ){  int rc;  if( pWriter->iFree==LARGEST_INT64 ) return FTS_CORRUPT_VTAB;  rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, nData);  if( rc!=SQLITE_OK ) return rc;  p->nLeafAdd++;  assert( nPrefix<nTerm );  rc = fts3NodeAddTerm(p, &pWriter->pTree, isCopyTerm, zTerm, nPrefix+1);  if( rc!=SQLITE_OK ) return rc;  nData = 0;  pWriter->nTerm = 0;  nPrefix = 0;  nSuffix = nTerm;  nReq = 1 +  sqlite3Fts3VarintLen(nTerm) +  nTerm +  sqlite3Fts3VarintLen(nDoclist) +  nDoclist;  }  pWriter->nLeafData += nReq;  if( nReq>pWriter->nSize ){  char *aNew = sqlite3_realloc(pWriter->aData, nReq);  if( !aNew ) return SQLITE_NOMEM;  pWriter->aData = aNew;  pWriter->nSize = nReq;  }  assert( nData+nReq<=pWriter->nSize );  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nPrefix);  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nSuffix);  assert( nSuffix>0 );  memcpy(&pWriter->aData[nData], &zTerm[nPrefix], nSuffix);  nData += nSuffix;  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nDoclist);  assert( nDoclist>0 );  memcpy(&pWriter->aData[nData], aDoclist, nDoclist);  pWriter->nData = nData + nDoclist;  if( isCopyTerm ){  if( nTerm>pWriter->nMalloc ){  char *zNew = sqlite3_realloc(pWriter->zMalloc, nTerm*2);  if( !zNew ){  return SQLITE_NOMEM;  }  pWriter->nMalloc = nTerm*2;  pWriter->zMalloc = zNew;  pWriter->zTerm = zNew;  }  assert( pWriter->zTerm==pWriter->zMalloc );  assert( nTerm>0 );  memcpy(pWriter->zTerm, zTerm, nTerm);  }else{  pWriter->zTerm = (char *)zTerm;  }  pWriter->nTerm = nTerm;  return SQLITE_OK; } static int fts3SegWriterFlush(  Fts3Table *p,  SegmentWriter *pWriter,  sqlite3_int64 iLevel,  int iIdx ){  int rc;  if( pWriter->pTree ){  sqlite3_int64 iLast = 0;  sqlite3_int64 iLastLeaf;  char *zRoot = NULL;  int nRoot = 0;  iLastLeaf = pWriter->iFree;  rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, pWriter->nData);  if( rc==SQLITE_OK ){  rc = fts3NodeWrite(p, pWriter->pTree, 1,  pWriter->iFirst, pWriter->iFree, &iLast, &zRoot, &nRoot);  }  if( rc==SQLITE_OK ){  rc = fts3WriteSegdir(p, iLevel, iIdx,  pWriter->iFirst, iLastLeaf, iLast, pWriter->nLeafData, zRoot, nRoot);  }  }else{  rc = fts3WriteSegdir(p, iLevel, iIdx,  0, 0, 0, pWriter->nLeafData, pWriter->aData, pWriter->nData);  }  p->nLeafAdd++;  return rc; } static void fts3SegWriterFree(SegmentWriter *pWriter){  if( pWriter ){  sqlite3_free(pWriter->aData);  sqlite3_free(pWriter->zMalloc);  fts3NodeFree(pWriter->pTree);  sqlite3_free(pWriter);  } } static int fts3IsEmpty(Fts3Table *p, sqlite3_value *pRowid, int *pisEmpty){  sqlite3_stmt *pStmt;  int rc;  if( p->zContentTbl ){  *pisEmpty = 0;  rc = SQLITE_OK;  }else{  rc = fts3SqlStmt(p, SQL_IS_EMPTY, &pStmt, &pRowid);  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  *pisEmpty = sqlite3_column_int(pStmt, 0);  }  rc = sqlite3_reset(pStmt);  }  }  return rc; } static int fts3SegmentMaxLevel(  Fts3Table *p,  int iLangid,  int iIndex,  sqlite3_int64 *pnMax ){  sqlite3_stmt *pStmt;  int rc;  assert( iIndex>=0 && iIndex<p->nIndex );  rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_MAX_LEVEL, &pStmt, 0);  if( rc!=SQLITE_OK ) return rc;  sqlite3_bind_int64(pStmt, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));  sqlite3_bind_int64(pStmt, 2,  getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL-1)  );  if( SQLITE_ROW==sqlite3_step(pStmt) ){  *pnMax = sqlite3_column_int64(pStmt, 0);  }  return sqlite3_reset(pStmt); } static int fts3SegmentIsMaxLevel(Fts3Table *p, i64 iAbsLevel, int *pbMax){  sqlite3_stmt *pStmt;  int rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_MAX_LEVEL, &pStmt, 0);  if( rc!=SQLITE_OK ) return rc;  sqlite3_bind_int64(pStmt, 1, iAbsLevel+1);  sqlite3_bind_int64(pStmt, 2,  (((u64)iAbsLevel/FTS3_SEGDIR_MAXLEVEL)+1) * FTS3_SEGDIR_MAXLEVEL  );  *pbMax = 0;  if( SQLITE_ROW==sqlite3_step(pStmt) ){  *pbMax = sqlite3_column_type(pStmt, 0)==SQLITE_NULL;  }  return sqlite3_reset(pStmt); } static int fts3DeleteSegment(  Fts3Table *p,  Fts3SegReader *pSeg ){  int rc = SQLITE_OK;  if( pSeg->iStartBlock ){  sqlite3_stmt *pDelete;  rc = fts3SqlStmt(p, SQL_DELETE_SEGMENTS_RANGE, &pDelete, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pDelete, 1, pSeg->iStartBlock);  sqlite3_bind_int64(pDelete, 2, pSeg->iEndBlock);  sqlite3_step(pDelete);  rc = sqlite3_reset(pDelete);  }  }  return rc; } static int fts3DeleteSegdir(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel,  Fts3SegReader **apSegment,  int nReader ){  int rc = SQLITE_OK;  int i;  sqlite3_stmt *pDelete = 0;  for(i=0; rc==SQLITE_OK && i<nReader; i++){  rc = fts3DeleteSegment(p, apSegment[i]);  }  if( rc!=SQLITE_OK ){  return rc;  }  assert( iLevel>=0 || iLevel==FTS3_SEGCURSOR_ALL );  if( iLevel==FTS3_SEGCURSOR_ALL ){  rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_RANGE, &pDelete, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pDelete, 1, getAbsoluteLevel(p, iLangid, iIndex, 0));  sqlite3_bind_int64(pDelete, 2,  getAbsoluteLevel(p, iLangid, iIndex, FTS3_SEGDIR_MAXLEVEL-1)  );  }  }else{  rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_LEVEL, &pDelete, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(  pDelete, 1, getAbsoluteLevel(p, iLangid, iIndex, iLevel)  );  }  }  if( rc==SQLITE_OK ){  sqlite3_step(pDelete);  rc = sqlite3_reset(pDelete);  }  return rc; } static void fts3ColumnFilter(  int iCol,  int bZero,  char **ppList,  int *pnList ){  char *pList = *ppList;  int nList = *pnList;  char *pEnd = &pList[nList];  int iCurrent = 0;  char *p = pList;  assert( iCol>=0 );  while( 1 ){  char c = 0;  while( p<pEnd && (c | *p)&0xFE ) c = *p++ & 0x80;  if( iCol==iCurrent ){  nList = (int)(p - pList);  break;  }  nList -= (int)(p - pList);  pList = p;  if( nList<=0 ){  break;  }  p = &pList[1];  p += fts3GetVarint32(p, &iCurrent);  }  if( bZero && (pEnd - &pList[nList])>0){  memset(&pList[nList], 0, pEnd - &pList[nList]);  }  *ppList = pList;  *pnList = nList; } static int fts3MsrBufferData(  Fts3MultiSegReader *pMsr,  char *pList,  int nList ){  if( nList>pMsr->nBuffer ){  char *pNew;  pMsr->nBuffer = nList*2;  pNew = (char *)sqlite3_realloc(pMsr->aBuffer, pMsr->nBuffer);  if( !pNew ) return SQLITE_NOMEM;  pMsr->aBuffer = pNew;  }  assert( nList>0 );  memcpy(pMsr->aBuffer, pList, nList);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3MsrIncrNext(  Fts3Table *p,  Fts3MultiSegReader *pMsr,  sqlite3_int64 *piDocid,  char **paPoslist,  int *pnPoslist ){  int nMerge = pMsr->nAdvance;  Fts3SegReader **apSegment = pMsr->apSegment;  int (*xCmp)(Fts3SegReader *, Fts3SegReader *) = (  p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp  );  if( nMerge==0 ){  *paPoslist = 0;  return SQLITE_OK;  }  while( 1 ){  Fts3SegReader *pSeg;  pSeg = pMsr->apSegment[0];  if( pSeg->pOffsetList==0 ){  *paPoslist = 0;  break;  }else{  int rc;  char *pList;  int nList;  int j;  sqlite3_int64 iDocid = apSegment[0]->iDocid;  rc = fts3SegReaderNextDocid(p, apSegment[0], &pList, &nList);  j = 1;  while( rc==SQLITE_OK  && j<nMerge  && apSegment[j]->pOffsetList  && apSegment[j]->iDocid==iDocid  ){  rc = fts3SegReaderNextDocid(p, apSegment[j], 0, 0);  j++;  }  if( rc!=SQLITE_OK ) return rc;  fts3SegReaderSort(pMsr->apSegment, nMerge, j, xCmp);  if( nList>0 && fts3SegReaderIsPending(apSegment[0]) ){  rc = fts3MsrBufferData(pMsr, pList, nList+1);  if( rc!=SQLITE_OK ) return rc;  assert( (pMsr->aBuffer[nList] & 0xFE)==0x00 );  pList = pMsr->aBuffer;  }  if( pMsr->iColFilter>=0 ){  fts3ColumnFilter(pMsr->iColFilter, 1, &pList, &nList);  }  if( nList>0 ){  *paPoslist = pList;  *piDocid = iDocid;  *pnPoslist = nList;  break;  }  }  }  return SQLITE_OK; } static int fts3SegReaderStart(  Fts3Table *p,  Fts3MultiSegReader *pCsr,  const char *zTerm,  int nTerm ){  int i;  int nSeg = pCsr->nSegment;  for(i=0; pCsr->bRestart==0 && i<pCsr->nSegment; i++){  int res = 0;  Fts3SegReader *pSeg = pCsr->apSegment[i];  do {  int rc = fts3SegReaderNext(p, pSeg, 0);  if( rc!=SQLITE_OK ) return rc;  }while( zTerm && (res = fts3SegReaderTermCmp(pSeg, zTerm, nTerm))<0 );  if( pSeg->bLookup && res!=0 ){  fts3SegReaderSetEof(pSeg);  }  }  fts3SegReaderSort(pCsr->apSegment, nSeg, nSeg, fts3SegReaderCmp);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3SegReaderStart(  Fts3Table *p,  Fts3MultiSegReader *pCsr,  Fts3SegFilter *pFilter ){  pCsr->pFilter = pFilter;  return fts3SegReaderStart(p, pCsr, pFilter->zTerm, pFilter->nTerm); } SQLITE_PRIVATE int sqlite3Fts3MsrIncrStart(  Fts3Table *p,  Fts3MultiSegReader *pCsr,  int iCol,  const char *zTerm,  int nTerm ){  int i;  int rc;  int nSegment = pCsr->nSegment;  int (*xCmp)(Fts3SegReader *, Fts3SegReader *) = (  p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp  );  assert( pCsr->pFilter==0 );  assert( zTerm && nTerm>0 );  rc = fts3SegReaderStart(p, pCsr, zTerm, nTerm);  if( rc!=SQLITE_OK ) return rc;  for(i=0; i<nSegment; i++){  Fts3SegReader *pSeg = pCsr->apSegment[i];  if( !pSeg->aNode || fts3SegReaderTermCmp(pSeg, zTerm, nTerm) ){  break;  }  }  pCsr->nAdvance = i;  for(i=0; i<pCsr->nAdvance; i++){  rc = fts3SegReaderFirstDocid(p, pCsr->apSegment[i]);  if( rc!=SQLITE_OK ) return rc;  }  fts3SegReaderSort(pCsr->apSegment, i, i, xCmp);  assert( iCol<0 || iCol<p->nColumn );  pCsr->iColFilter = iCol;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr){  int i;  assert( pCsr->zTerm==0 );  assert( pCsr->nTerm==0 );  assert( pCsr->aDoclist==0 );  assert( pCsr->nDoclist==0 );  pCsr->nAdvance = 0;  pCsr->bRestart = 1;  for(i=0; i<pCsr->nSegment; i++){  pCsr->apSegment[i]->pOffsetList = 0;  pCsr->apSegment[i]->nOffsetList = 0;  pCsr->apSegment[i]->iDocid = 0;  }  return SQLITE_OK; } static int fts3GrowSegReaderBuffer(Fts3MultiSegReader *pCsr, int nReq){  if( nReq>pCsr->nBuffer ){  char *aNew;  pCsr->nBuffer = nReq*2;  aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);  if( !aNew ){  return SQLITE_NOMEM;  }  pCsr->aBuffer = aNew;  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3SegReaderStep(  Fts3Table *p,  Fts3MultiSegReader *pCsr ){  int rc = SQLITE_OK;  int isIgnoreEmpty = (pCsr->pFilter->flags & FTS3_SEGMENT_IGNORE_EMPTY);  int isRequirePos =  (pCsr->pFilter->flags & FTS3_SEGMENT_REQUIRE_POS);  int isColFilter = (pCsr->pFilter->flags & FTS3_SEGMENT_COLUMN_FILTER);  int isPrefix =  (pCsr->pFilter->flags & FTS3_SEGMENT_PREFIX);  int isScan =  (pCsr->pFilter->flags & FTS3_SEGMENT_SCAN);  int isFirst = (pCsr->pFilter->flags & FTS3_SEGMENT_FIRST);  Fts3SegReader **apSegment = pCsr->apSegment;  int nSegment = pCsr->nSegment;  Fts3SegFilter *pFilter = pCsr->pFilter;  int (*xCmp)(Fts3SegReader *, Fts3SegReader *) = (  p->bDescIdx ? fts3SegReaderDoclistCmpRev : fts3SegReaderDoclistCmp  );  if( pCsr->nSegment==0 ) return SQLITE_OK;  do {  int nMerge;  int i;  for(i=0; i<pCsr->nAdvance; i++){  Fts3SegReader *pSeg = apSegment[i];  if( pSeg->bLookup ){  fts3SegReaderSetEof(pSeg);  }else{  rc = fts3SegReaderNext(p, pSeg, 0);  }  if( rc!=SQLITE_OK ) return rc;  }  fts3SegReaderSort(apSegment, nSegment, pCsr->nAdvance, fts3SegReaderCmp);  pCsr->nAdvance = 0;  assert( rc==SQLITE_OK );  if( apSegment[0]->aNode==0 ) break;  pCsr->nTerm = apSegment[0]->nTerm;  pCsr->zTerm = apSegment[0]->zTerm;  if( pFilter->zTerm && !isScan ){  if( pCsr->nTerm<pFilter->nTerm   || (!isPrefix && pCsr->nTerm>pFilter->nTerm)   || memcmp(pCsr->zTerm, pFilter->zTerm, pFilter->nTerm)  ){  break;  }  }  nMerge = 1;  while( nMerge<nSegment  && apSegment[nMerge]->aNode  && apSegment[nMerge]->nTerm==pCsr->nTerm  && 0==memcmp(pCsr->zTerm, apSegment[nMerge]->zTerm, pCsr->nTerm)  ){  nMerge++;  }  assert( isIgnoreEmpty || (isRequirePos && !isColFilter) );  if( nMerge==1   && !isIgnoreEmpty   && !isFirst   && (p->bDescIdx==0 || fts3SegReaderIsPending(apSegment[0])==0)  ){  pCsr->nDoclist = apSegment[0]->nDoclist;  if( fts3SegReaderIsPending(apSegment[0]) ){  rc = fts3MsrBufferData(pCsr, apSegment[0]->aDoclist, pCsr->nDoclist);  pCsr->aDoclist = pCsr->aBuffer;  }else{  pCsr->aDoclist = apSegment[0]->aDoclist;  }  if( rc==SQLITE_OK ) rc = SQLITE_ROW;  }else{  int nDoclist = 0;  sqlite3_int64 iPrev = 0;  for(i=0; i<nMerge; i++){  fts3SegReaderFirstDocid(p, apSegment[i]);  }  fts3SegReaderSort(apSegment, nMerge, nMerge, xCmp);  while( apSegment[0]->pOffsetList ){  int j;  char *pList = 0;  int nList = 0;  int nByte;  sqlite3_int64 iDocid = apSegment[0]->iDocid;  fts3SegReaderNextDocid(p, apSegment[0], &pList, &nList);  j = 1;  while( j<nMerge  && apSegment[j]->pOffsetList  && apSegment[j]->iDocid==iDocid  ){  fts3SegReaderNextDocid(p, apSegment[j], 0, 0);  j++;  }  if( isColFilter ){  fts3ColumnFilter(pFilter->iCol, 0, &pList, &nList);  }  if( !isIgnoreEmpty || nList>0 ){  sqlite3_int64 iDelta;  if( p->bDescIdx && nDoclist>0 ){  if( iPrev<=iDocid ) return FTS_CORRUPT_VTAB;  iDelta = (i64)((u64)iPrev - (u64)iDocid);  }else{  if( nDoclist>0 && iPrev>=iDocid ) return FTS_CORRUPT_VTAB;  iDelta = (i64)((u64)iDocid - (u64)iPrev);  }  nByte = sqlite3Fts3VarintLen(iDelta) + (isRequirePos?nList+1:0);  rc = fts3GrowSegReaderBuffer(pCsr, nByte+nDoclist+FTS3_NODE_PADDING);  if( rc ) return rc;  if( isFirst ){  char *a = &pCsr->aBuffer[nDoclist];  int nWrite;  nWrite = sqlite3Fts3FirstFilter(iDelta, pList, nList, a);  if( nWrite ){  iPrev = iDocid;  nDoclist += nWrite;  }  }else{  nDoclist += sqlite3Fts3PutVarint(&pCsr->aBuffer[nDoclist], iDelta);  iPrev = iDocid;  if( isRequirePos ){  memcpy(&pCsr->aBuffer[nDoclist], pList, nList);  nDoclist += nList;  pCsr->aBuffer[nDoclist++] = '\0';  }  }  }  fts3SegReaderSort(apSegment, nMerge, j, xCmp);  }  if( nDoclist>0 ){  rc = fts3GrowSegReaderBuffer(pCsr, nDoclist+FTS3_NODE_PADDING);  if( rc ) return rc;  memset(&pCsr->aBuffer[nDoclist], 0, FTS3_NODE_PADDING);  pCsr->aDoclist = pCsr->aBuffer;  pCsr->nDoclist = nDoclist;  rc = SQLITE_ROW;  }  }  pCsr->nAdvance = nMerge;  }while( rc==SQLITE_OK );  return rc; } SQLITE_PRIVATE void sqlite3Fts3SegReaderFinish(  Fts3MultiSegReader *pCsr ){  if( pCsr ){  int i;  for(i=0; i<pCsr->nSegment; i++){  sqlite3Fts3SegReaderFree(pCsr->apSegment[i]);  }  sqlite3_free(pCsr->apSegment);  sqlite3_free(pCsr->aBuffer);  pCsr->nSegment = 0;  pCsr->apSegment = 0;  pCsr->aBuffer = 0;  } } static void fts3ReadEndBlockField(  sqlite3_stmt *pStmt,  int iCol,  i64 *piEndBlock,  i64 *pnByte ){  const unsigned char *zText = sqlite3_column_text(pStmt, iCol);  if( zText ){  int i;  int iMul = 1;  u64 iVal = 0;  for(i=0; zText[i]>='0' && zText[i]<='9'; i++){  iVal = iVal*10 + (zText[i] - '0');  }  *piEndBlock = (i64)iVal;  while( zText[i]==' ' ) i++;  iVal = 0;  if( zText[i]=='-' ){  i++;  iMul = -1;  }  for(; zText[i]>='0' && zText[i]<='9'; i++){  iVal = iVal*10 + (zText[i] - '0');  }  *pnByte = ((i64)iVal * (i64)iMul);  } } static int fts3PromoteSegments(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  sqlite3_int64 nByte ){  int rc = SQLITE_OK;  sqlite3_stmt *pRange;  rc = fts3SqlStmt(p, SQL_SELECT_LEVEL_RANGE2, &pRange, 0);  if( rc==SQLITE_OK ){  int bOk = 0;  i64 iLast = (iAbsLevel/FTS3_SEGDIR_MAXLEVEL + 1) * FTS3_SEGDIR_MAXLEVEL - 1;  i64 nLimit = (nByte*3)/2;  sqlite3_bind_int64(pRange, 1, iAbsLevel+1);  sqlite3_bind_int64(pRange, 2, iLast);  while( SQLITE_ROW==sqlite3_step(pRange) ){  i64 nSize = 0, dummy;  fts3ReadEndBlockField(pRange, 2, &dummy, &nSize);  if( nSize<=0 || nSize>nLimit ){  bOk = 0;  break;  }  bOk = 1;  }  rc = sqlite3_reset(pRange);  if( bOk ){  int iIdx = 0;  sqlite3_stmt *pUpdate1 = 0;  sqlite3_stmt *pUpdate2 = 0;  if( rc==SQLITE_OK ){  rc = fts3SqlStmt(p, SQL_UPDATE_LEVEL_IDX, &pUpdate1, 0);  }  if( rc==SQLITE_OK ){  rc = fts3SqlStmt(p, SQL_UPDATE_LEVEL, &pUpdate2, 0);  }  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pRange, 1, iAbsLevel);  while( SQLITE_ROW==sqlite3_step(pRange) ){  sqlite3_bind_int(pUpdate1, 1, iIdx++);  sqlite3_bind_int(pUpdate1, 2, sqlite3_column_int(pRange, 0));  sqlite3_bind_int(pUpdate1, 3, sqlite3_column_int(pRange, 1));  sqlite3_step(pUpdate1);  rc = sqlite3_reset(pUpdate1);  if( rc!=SQLITE_OK ){  sqlite3_reset(pRange);  break;  }  }  }  if( rc==SQLITE_OK ){  rc = sqlite3_reset(pRange);  }  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pUpdate2, 1, iAbsLevel);  sqlite3_step(pUpdate2);  rc = sqlite3_reset(pUpdate2);  }  }  }  return rc; } static int fts3SegmentMerge(  Fts3Table *p,  int iLangid,  int iIndex,  int iLevel ){  int rc;  int iIdx = 0;  sqlite3_int64 iNewLevel = 0;  SegmentWriter *pWriter = 0;  Fts3SegFilter filter;  Fts3MultiSegReader csr;  int bIgnoreEmpty = 0;  i64 iMaxLevel = 0;  assert( iLevel==FTS3_SEGCURSOR_ALL   || iLevel==FTS3_SEGCURSOR_PENDING   || iLevel>=0  );  assert( iLevel<FTS3_SEGDIR_MAXLEVEL );  assert( iIndex>=0 && iIndex<p->nIndex );  rc = sqlite3Fts3SegReaderCursor(p, iLangid, iIndex, iLevel, 0, 0, 1, 0, &csr);  if( rc!=SQLITE_OK || csr.nSegment==0 ) goto finished;  if( iLevel!=FTS3_SEGCURSOR_PENDING ){  rc = fts3SegmentMaxLevel(p, iLangid, iIndex, &iMaxLevel);  if( rc!=SQLITE_OK ) goto finished;  }  if( iLevel==FTS3_SEGCURSOR_ALL ){  if( csr.nSegment==1 && 0==fts3SegReaderIsPending(csr.apSegment[0]) ){  rc = SQLITE_DONE;  goto finished;  }  iNewLevel = iMaxLevel;  bIgnoreEmpty = 1;  }else{  assert( FTS3_SEGCURSOR_PENDING==-1 );  iNewLevel = getAbsoluteLevel(p, iLangid, iIndex, iLevel+1);  rc = fts3AllocateSegdirIdx(p, iLangid, iIndex, iLevel+1, &iIdx);  bIgnoreEmpty = (iLevel!=FTS3_SEGCURSOR_PENDING) && (iNewLevel>iMaxLevel);  }  if( rc!=SQLITE_OK ) goto finished;  assert( csr.nSegment>0 );  assert_fts3_nc( iNewLevel>=getAbsoluteLevel(p, iLangid, iIndex, 0) );  assert_fts3_nc(  iNewLevel<getAbsoluteLevel(p, iLangid, iIndex,FTS3_SEGDIR_MAXLEVEL)  );  memset(&filter, 0, sizeof(Fts3SegFilter));  filter.flags = FTS3_SEGMENT_REQUIRE_POS;  filter.flags |= (bIgnoreEmpty ? FTS3_SEGMENT_IGNORE_EMPTY : 0);  rc = sqlite3Fts3SegReaderStart(p, &csr, &filter);  while( SQLITE_OK==rc ){  rc = sqlite3Fts3SegReaderStep(p, &csr);  if( rc!=SQLITE_ROW ) break;  rc = fts3SegWriterAdd(p, &pWriter, 1,  csr.zTerm, csr.nTerm, csr.aDoclist, csr.nDoclist);  }  if( rc!=SQLITE_OK ) goto finished;  assert_fts3_nc( pWriter || bIgnoreEmpty );  if( iLevel!=FTS3_SEGCURSOR_PENDING ){  rc = fts3DeleteSegdir(  p, iLangid, iIndex, iLevel, csr.apSegment, csr.nSegment  );  if( rc!=SQLITE_OK ) goto finished;  }  if( pWriter ){  rc = fts3SegWriterFlush(p, pWriter, iNewLevel, iIdx);  if( rc==SQLITE_OK ){  if( iLevel==FTS3_SEGCURSOR_PENDING || iNewLevel<iMaxLevel ){  rc = fts3PromoteSegments(p, iNewLevel, pWriter->nLeafData);  }  }  }  finished:  fts3SegWriterFree(pWriter);  sqlite3Fts3SegReaderFinish(&csr);  return rc; } SQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush(Fts3Table *p){  int rc = SQLITE_OK;  int i;  for(i=0; rc==SQLITE_OK && i<p->nIndex; i++){  rc = fts3SegmentMerge(p, p->iPrevLangid, i, FTS3_SEGCURSOR_PENDING);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  }  sqlite3Fts3PendingTermsClear(p);  if( rc==SQLITE_OK && p->bHasStat   && p->nAutoincrmerge==0xff && p->nLeafAdd>0  ){  sqlite3_stmt *pStmt = 0;  rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pStmt, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);  rc = sqlite3_step(pStmt);  if( rc==SQLITE_ROW ){  p->nAutoincrmerge = sqlite3_column_int(pStmt, 0);  if( p->nAutoincrmerge==1 ) p->nAutoincrmerge = 8;  }else if( rc==SQLITE_DONE ){  p->nAutoincrmerge = 0;  }  rc = sqlite3_reset(pStmt);  }  }  return rc; } static void fts3EncodeIntArray(  int N,  u32 *a,  char *zBuf,  int *pNBuf ){  int i, j;  for(i=j=0; i<N; i++){  j += sqlite3Fts3PutVarint(&zBuf[j], (sqlite3_int64)a[i]);  }  *pNBuf = j; } static void fts3DecodeIntArray(  int N,  u32 *a,  const char *zBuf,  int nBuf ){  int i = 0;  if( nBuf && (zBuf[nBuf-1]&0x80)==0 ){  int j;  for(i=j=0; i<N && j<nBuf; i++){  sqlite3_int64 x;  j += sqlite3Fts3GetVarint(&zBuf[j], &x);  a[i] = (u32)(x & 0xffffffff);  }  }  while( i<N ) a[i++] = 0; } static void fts3InsertDocsize(  int *pRC,  Fts3Table *p,  u32 *aSz ){  char *pBlob;  int nBlob;  sqlite3_stmt *pStmt;  int rc;  if( *pRC ) return;  pBlob = sqlite3_malloc64( 10*(sqlite3_int64)p->nColumn );  if( pBlob==0 ){  *pRC = SQLITE_NOMEM;  return;  }  fts3EncodeIntArray(p->nColumn, aSz, pBlob, &nBlob);  rc = fts3SqlStmt(p, SQL_REPLACE_DOCSIZE, &pStmt, 0);  if( rc ){  sqlite3_free(pBlob);  *pRC = rc;  return;  }  sqlite3_bind_int64(pStmt, 1, p->iPrevDocid);  sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, sqlite3_free);  sqlite3_step(pStmt);  *pRC = sqlite3_reset(pStmt); } static void fts3UpdateDocTotals(  int *pRC,  Fts3Table *p,  u32 *aSzIns,  u32 *aSzDel,  int nChng ){  char *pBlob;  int nBlob;  u32 *a;  sqlite3_stmt *pStmt;  int i;  int rc;  const int nStat = p->nColumn+2;  if( *pRC ) return;  a = sqlite3_malloc64( (sizeof(u32)+10)*(sqlite3_int64)nStat );  if( a==0 ){  *pRC = SQLITE_NOMEM;  return;  }  pBlob = (char*)&a[nStat];  rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pStmt, 0);  if( rc ){  sqlite3_free(a);  *pRC = rc;  return;  }  sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);  if( sqlite3_step(pStmt)==SQLITE_ROW ){  fts3DecodeIntArray(nStat, a,   sqlite3_column_blob(pStmt, 0),   sqlite3_column_bytes(pStmt, 0));  }else{  memset(a, 0, sizeof(u32)*(nStat) );  }  rc = sqlite3_reset(pStmt);  if( rc!=SQLITE_OK ){  sqlite3_free(a);  *pRC = rc;  return;  }  if( nChng<0 && a[0]<(u32)(-nChng) ){  a[0] = 0;  }else{  a[0] += nChng;  }  for(i=0; i<p->nColumn+1; i++){  u32 x = a[i+1];  if( x+aSzIns[i] < aSzDel[i] ){  x = 0;  }else{  x = x + aSzIns[i] - aSzDel[i];  }  a[i+1] = x;  }  fts3EncodeIntArray(nStat, a, pBlob, &nBlob);  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);  if( rc ){  sqlite3_free(a);  *pRC = rc;  return;  }  sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);  sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, SQLITE_STATIC);  sqlite3_step(pStmt);  *pRC = sqlite3_reset(pStmt);  sqlite3_bind_null(pStmt, 2);  sqlite3_free(a); } static int fts3DoOptimize(Fts3Table *p, int bReturnDone){  int bSeenDone = 0;  int rc;  sqlite3_stmt *pAllLangid = 0;  rc = sqlite3Fts3PendingTermsFlush(p);  if( rc==SQLITE_OK ){  rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);  }  if( rc==SQLITE_OK ){  int rc2;  sqlite3_bind_int(pAllLangid, 1, p->iPrevLangid);  sqlite3_bind_int(pAllLangid, 2, p->nIndex);  while( sqlite3_step(pAllLangid)==SQLITE_ROW ){  int i;  int iLangid = sqlite3_column_int(pAllLangid, 0);  for(i=0; rc==SQLITE_OK && i<p->nIndex; i++){  rc = fts3SegmentMerge(p, iLangid, i, FTS3_SEGCURSOR_ALL);  if( rc==SQLITE_DONE ){  bSeenDone = 1;  rc = SQLITE_OK;  }  }  }  rc2 = sqlite3_reset(pAllLangid);  if( rc==SQLITE_OK ) rc = rc2;  }  sqlite3Fts3SegmentsClose(p);  return (rc==SQLITE_OK && bReturnDone && bSeenDone) ? SQLITE_DONE : rc; } static int fts3DoRebuild(Fts3Table *p){  int rc;  rc = fts3DeleteAll(p, 0);  if( rc==SQLITE_OK ){  u32 *aSz = 0;  u32 *aSzIns = 0;  u32 *aSzDel = 0;  sqlite3_stmt *pStmt = 0;  int nEntry = 0;  char *zSql = sqlite3_mprintf("SELECT %s" , p->zReadExprlist);  if( !zSql ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);  sqlite3_free(zSql);  }  if( rc==SQLITE_OK ){  sqlite3_int64 nByte = sizeof(u32) * ((sqlite3_int64)p->nColumn+1)*3;  aSz = (u32 *)sqlite3_malloc64(nByte);  if( aSz==0 ){  rc = SQLITE_NOMEM;  }else{  memset(aSz, 0, nByte);  aSzIns = &aSz[p->nColumn+1];  aSzDel = &aSzIns[p->nColumn+1];  }  }  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){  int iCol;  int iLangid = langidFromSelect(p, pStmt);  rc = fts3PendingTermsDocid(p, 0, iLangid, sqlite3_column_int64(pStmt, 0));  memset(aSz, 0, sizeof(aSz[0]) * (p->nColumn+1));  for(iCol=0; rc==SQLITE_OK && iCol<p->nColumn; iCol++){  if( p->abNotindexed[iCol]==0 ){  const char *z = (const char *) sqlite3_column_text(pStmt, iCol+1);  rc = fts3PendingTermsAdd(p, iLangid, z, iCol, &aSz[iCol]);  aSz[p->nColumn] += sqlite3_column_bytes(pStmt, iCol+1);  }  }  if( p->bHasDocsize ){  fts3InsertDocsize(&rc, p, aSz);  }  if( rc!=SQLITE_OK ){  sqlite3_finalize(pStmt);  pStmt = 0;  }else{  nEntry++;  for(iCol=0; iCol<=p->nColumn; iCol++){  aSzIns[iCol] += aSz[iCol];  }  }  }  if( p->bFts4 ){  fts3UpdateDocTotals(&rc, p, aSzIns, aSzDel, nEntry);  }  sqlite3_free(aSz);  if( pStmt ){  int rc2 = sqlite3_finalize(pStmt);  if( rc==SQLITE_OK ){  rc = rc2;  }  }  }  return rc; } static int fts3IncrmergeCsr(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  int nSeg,  Fts3MultiSegReader *pCsr ){  int rc;  sqlite3_stmt *pStmt = 0;  sqlite3_int64 nByte;  memset(pCsr, 0, sizeof(*pCsr));  nByte = sizeof(Fts3SegReader *) * nSeg;  pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc64(nByte);  if( pCsr->apSegment==0 ){  rc = SQLITE_NOMEM;  }else{  memset(pCsr->apSegment, 0, nByte);  rc = fts3SqlStmt(p, SQL_SELECT_LEVEL, &pStmt, 0);  }  if( rc==SQLITE_OK ){  int i;  int rc2;  sqlite3_bind_int64(pStmt, 1, iAbsLevel);  assert( pCsr->nSegment==0 );  for(i=0; rc==SQLITE_OK && sqlite3_step(pStmt)==SQLITE_ROW && i<nSeg; i++){  rc = sqlite3Fts3SegReaderNew(i, 0,  sqlite3_column_int64(pStmt, 1),  sqlite3_column_int64(pStmt, 2),  sqlite3_column_int64(pStmt, 3),  sqlite3_column_blob(pStmt, 4),  sqlite3_column_bytes(pStmt, 4),  &pCsr->apSegment[i]  );  pCsr->nSegment++;  }  rc2 = sqlite3_reset(pStmt);  if( rc==SQLITE_OK ) rc = rc2;  }  return rc; } typedef struct IncrmergeWriter IncrmergeWriter; typedef struct NodeWriter NodeWriter; typedef struct Blob Blob; typedef struct NodeReader NodeReader; struct Blob {  char *a;  int n;  int nAlloc; }; struct NodeWriter {  sqlite3_int64 iBlock;  Blob key;  Blob block; }; struct IncrmergeWriter {  int nLeafEst;  int nWork;  sqlite3_int64 iAbsLevel;  int iIdx;  sqlite3_int64 iStart;  sqlite3_int64 iEnd;  sqlite3_int64 nLeafData;  u8 bNoLeafData;  NodeWriter aNodeWriter[FTS_MAX_APPENDABLE_HEIGHT]; }; struct NodeReader {  const char *aNode;  int nNode;  int iOff;  sqlite3_int64 iChild;  Blob term;  const char *aDoclist;  int nDoclist; }; static void blobGrowBuffer(Blob *pBlob, int nMin, int *pRc){  if( *pRc==SQLITE_OK && nMin>pBlob->nAlloc ){  int nAlloc = nMin;  char *a = (char *)sqlite3_realloc(pBlob->a, nAlloc);  if( a ){  pBlob->nAlloc = nAlloc;  pBlob->a = a;  }else{  *pRc = SQLITE_NOMEM;  }  } } static int nodeReaderNext(NodeReader *p){  int bFirst = (p->term.n==0);  int nPrefix = 0;  int nSuffix = 0;  int rc = SQLITE_OK;  assert( p->aNode );  if( p->iChild && bFirst==0 ) p->iChild++;  if( p->iOff>=p->nNode ){  p->aNode = 0;  }else{  if( bFirst==0 ){  p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &nPrefix);  }  p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &nSuffix);  if( nPrefix>p->term.n || nSuffix>p->nNode-p->iOff || nSuffix==0 ){  return FTS_CORRUPT_VTAB;  }  blobGrowBuffer(&p->term, nPrefix+nSuffix, &rc);  if( rc==SQLITE_OK && ALWAYS(p->term.a!=0) ){  memcpy(&p->term.a[nPrefix], &p->aNode[p->iOff], nSuffix);  p->term.n = nPrefix+nSuffix;  p->iOff += nSuffix;  if( p->iChild==0 ){  p->iOff += fts3GetVarint32(&p->aNode[p->iOff], &p->nDoclist);  if( (p->nNode-p->iOff)<p->nDoclist ){  return FTS_CORRUPT_VTAB;  }  p->aDoclist = &p->aNode[p->iOff];  p->iOff += p->nDoclist;  }  }  }  assert_fts3_nc( p->iOff<=p->nNode );  return rc; } static void nodeReaderRelease(NodeReader *p){  sqlite3_free(p->term.a); } static int nodeReaderInit(NodeReader *p, const char *aNode, int nNode){  memset(p, 0, sizeof(NodeReader));  p->aNode = aNode;  p->nNode = nNode;  if( aNode && aNode[0] ){  p->iOff = 1 + sqlite3Fts3GetVarint(&p->aNode[1], &p->iChild);  }else{  p->iOff = 1;  }  return aNode ? nodeReaderNext(p) : SQLITE_OK; } static int fts3IncrmergePush(  Fts3Table *p,  IncrmergeWriter *pWriter,  const char *zTerm,  int nTerm ){  sqlite3_int64 iPtr = pWriter->aNodeWriter[0].iBlock;  int iLayer;  assert( nTerm>0 );  for(iLayer=1; ALWAYS(iLayer<FTS_MAX_APPENDABLE_HEIGHT); iLayer++){  sqlite3_int64 iNextPtr = 0;  NodeWriter *pNode = &pWriter->aNodeWriter[iLayer];  int rc = SQLITE_OK;  int nPrefix;  int nSuffix;  int nSpace;  nPrefix = fts3PrefixCompress(pNode->key.a, pNode->key.n, zTerm, nTerm);  nSuffix = nTerm - nPrefix;  if(nSuffix<=0 ) return FTS_CORRUPT_VTAB;  nSpace = sqlite3Fts3VarintLen(nPrefix);  nSpace += sqlite3Fts3VarintLen(nSuffix) + nSuffix;  if( pNode->key.n==0 || (pNode->block.n + nSpace)<=p->nNodeSize ){  Blob *pBlk = &pNode->block;  if( pBlk->n==0 ){  blobGrowBuffer(pBlk, p->nNodeSize, &rc);  if( rc==SQLITE_OK ){  pBlk->a[0] = (char)iLayer;  pBlk->n = 1 + sqlite3Fts3PutVarint(&pBlk->a[1], iPtr);  }  }  blobGrowBuffer(pBlk, pBlk->n + nSpace, &rc);  blobGrowBuffer(&pNode->key, nTerm, &rc);  if( rc==SQLITE_OK ){  if( pNode->key.n ){  pBlk->n += sqlite3Fts3PutVarint(&pBlk->a[pBlk->n], nPrefix);  }  pBlk->n += sqlite3Fts3PutVarint(&pBlk->a[pBlk->n], nSuffix);  memcpy(&pBlk->a[pBlk->n], &zTerm[nPrefix], nSuffix);  pBlk->n += nSuffix;  memcpy(pNode->key.a, zTerm, nTerm);  pNode->key.n = nTerm;  }  }else{  rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n);  assert( pNode->block.nAlloc>=p->nNodeSize );  pNode->block.a[0] = (char)iLayer;  pNode->block.n = 1 + sqlite3Fts3PutVarint(&pNode->block.a[1], iPtr+1);  iNextPtr = pNode->iBlock;  pNode->iBlock++;  pNode->key.n = 0;  }  if( rc!=SQLITE_OK || iNextPtr==0 ) return rc;  iPtr = iNextPtr;  }  assert( 0 );  return 0; } static int fts3AppendToNode(  Blob *pNode,  Blob *pPrev,  const char *zTerm,  int nTerm,  const char *aDoclist,  int nDoclist ){  int rc = SQLITE_OK;  int bFirst = (pPrev->n==0);  int nPrefix;  int nSuffix;  assert( pNode->n>0 );  assert_fts3_nc( (pNode->a[0]=='\0')==(aDoclist!=0) );  blobGrowBuffer(pPrev, nTerm, &rc);  if( rc!=SQLITE_OK ) return rc;  nPrefix = fts3PrefixCompress(pPrev->a, pPrev->n, zTerm, nTerm);  nSuffix = nTerm - nPrefix;  if( nSuffix<=0 ) return FTS_CORRUPT_VTAB;  memcpy(pPrev->a, zTerm, nTerm);  pPrev->n = nTerm;  if( bFirst==0 ){  pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nPrefix);  }  pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nSuffix);  memcpy(&pNode->a[pNode->n], &zTerm[nPrefix], nSuffix);  pNode->n += nSuffix;  if( aDoclist ){  pNode->n += sqlite3Fts3PutVarint(&pNode->a[pNode->n], nDoclist);  memcpy(&pNode->a[pNode->n], aDoclist, nDoclist);  pNode->n += nDoclist;  }  assert( pNode->n<=pNode->nAlloc );  return SQLITE_OK; } static int fts3IncrmergeAppend(  Fts3Table *p,  IncrmergeWriter *pWriter,  Fts3MultiSegReader *pCsr ){  const char *zTerm = pCsr->zTerm;  int nTerm = pCsr->nTerm;  const char *aDoclist = pCsr->aDoclist;  int nDoclist = pCsr->nDoclist;  int rc = SQLITE_OK;  int nSpace;  int nPrefix;  int nSuffix;  NodeWriter *pLeaf;  pLeaf = &pWriter->aNodeWriter[0];  nPrefix = fts3PrefixCompress(pLeaf->key.a, pLeaf->key.n, zTerm, nTerm);  nSuffix = nTerm - nPrefix;  nSpace = sqlite3Fts3VarintLen(nPrefix);  nSpace += sqlite3Fts3VarintLen(nSuffix) + nSuffix;  nSpace += sqlite3Fts3VarintLen(nDoclist) + nDoclist;  if( pLeaf->block.n>0 && (pLeaf->block.n + nSpace)>p->nNodeSize ){  rc = fts3WriteSegment(p, pLeaf->iBlock, pLeaf->block.a, pLeaf->block.n);  pWriter->nWork++;  if( rc==SQLITE_OK ){  rc = fts3IncrmergePush(p, pWriter, zTerm, nPrefix+1);  }  pLeaf->iBlock++;  pLeaf->key.n = 0;  pLeaf->block.n = 0;  nSuffix = nTerm;  nSpace = 1;  nSpace += sqlite3Fts3VarintLen(nSuffix) + nSuffix;  nSpace += sqlite3Fts3VarintLen(nDoclist) + nDoclist;  }  pWriter->nLeafData += nSpace;  blobGrowBuffer(&pLeaf->block, pLeaf->block.n + nSpace, &rc);  if( rc==SQLITE_OK ){  if( pLeaf->block.n==0 ){  pLeaf->block.n = 1;  pLeaf->block.a[0] = '\0';  }  rc = fts3AppendToNode(  &pLeaf->block, &pLeaf->key, zTerm, nTerm, aDoclist, nDoclist  );  }  return rc; } static void fts3IncrmergeRelease(  Fts3Table *p,  IncrmergeWriter *pWriter,  int *pRc ){  int i;  int iRoot;  NodeWriter *pRoot;  int rc = *pRc;  for(iRoot=FTS_MAX_APPENDABLE_HEIGHT-1; iRoot>=0; iRoot--){  NodeWriter *pNode = &pWriter->aNodeWriter[iRoot];  if( pNode->block.n>0 ) break;  assert( *pRc || pNode->block.nAlloc==0 );  assert( *pRc || pNode->key.nAlloc==0 );  sqlite3_free(pNode->block.a);  sqlite3_free(pNode->key.a);  }  if( iRoot<0 ) return;  if( iRoot==0 ){  Blob *pBlock = &pWriter->aNodeWriter[1].block;  blobGrowBuffer(pBlock, 1 + FTS3_VARINT_MAX, &rc);  if( rc==SQLITE_OK ){  pBlock->a[0] = 0x01;  pBlock->n = 1 + sqlite3Fts3PutVarint(  &pBlock->a[1], pWriter->aNodeWriter[0].iBlock  );  }  iRoot = 1;  }  pRoot = &pWriter->aNodeWriter[iRoot];  for(i=0; i<iRoot; i++){  NodeWriter *pNode = &pWriter->aNodeWriter[i];  if( pNode->block.n>0 && rc==SQLITE_OK ){  rc = fts3WriteSegment(p, pNode->iBlock, pNode->block.a, pNode->block.n);  }  sqlite3_free(pNode->block.a);  sqlite3_free(pNode->key.a);  }  if( rc==SQLITE_OK ){  rc = fts3WriteSegdir(p,  pWriter->iAbsLevel+1,  pWriter->iIdx,  pWriter->iStart,  pWriter->aNodeWriter[0].iBlock,  pWriter->iEnd,  (pWriter->bNoLeafData==0 ? pWriter->nLeafData : 0),  pRoot->block.a, pRoot->block.n  );  }  sqlite3_free(pRoot->block.a);  sqlite3_free(pRoot->key.a);  *pRc = rc; } static int fts3TermCmp(  const char *zLhs, int nLhs,  const char *zRhs, int nRhs ){  int nCmp = MIN(nLhs, nRhs);  int res;  if( nCmp && ALWAYS(zLhs) && ALWAYS(zRhs) ){  res = memcmp(zLhs, zRhs, nCmp);  }else{  res = 0;  }  if( res==0 ) res = nLhs - nRhs;  return res; } static int fts3IsAppendable(Fts3Table *p, sqlite3_int64 iEnd, int *pbRes){  int bRes = 0;  sqlite3_stmt *pCheck = 0;  int rc;  rc = fts3SqlStmt(p, SQL_SEGMENT_IS_APPENDABLE, &pCheck, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pCheck, 1, iEnd);  if( SQLITE_ROW==sqlite3_step(pCheck) ) bRes = 1;  rc = sqlite3_reset(pCheck);  }  *pbRes = bRes;  return rc; } static int fts3IncrmergeLoad(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  int iIdx,  const char *zKey,  int nKey,  IncrmergeWriter *pWriter ){  int rc;  sqlite3_stmt *pSelect = 0;  rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR, &pSelect, 0);  if( rc==SQLITE_OK ){  sqlite3_int64 iStart = 0;  sqlite3_int64 iLeafEnd = 0;  sqlite3_int64 iEnd = 0;  const char *aRoot = 0;  int nRoot = 0;  int rc2;  int bAppendable = 0;  sqlite3_bind_int64(pSelect, 1, iAbsLevel+1);  sqlite3_bind_int(pSelect, 2, iIdx);  if( sqlite3_step(pSelect)==SQLITE_ROW ){  iStart = sqlite3_column_int64(pSelect, 1);  iLeafEnd = sqlite3_column_int64(pSelect, 2);  fts3ReadEndBlockField(pSelect, 3, &iEnd, &pWriter->nLeafData);  if( pWriter->nLeafData<0 ){  pWriter->nLeafData = pWriter->nLeafData * -1;  }  pWriter->bNoLeafData = (pWriter->nLeafData==0);  nRoot = sqlite3_column_bytes(pSelect, 4);  aRoot = sqlite3_column_blob(pSelect, 4);  if( aRoot==0 ){  sqlite3_reset(pSelect);  return nRoot ? SQLITE_NOMEM : FTS_CORRUPT_VTAB;  }  }else{  return sqlite3_reset(pSelect);  }  rc = fts3IsAppendable(p, iEnd, &bAppendable);  if( rc==SQLITE_OK && bAppendable ){  char *aLeaf = 0;  int nLeaf = 0;  rc = sqlite3Fts3ReadBlock(p, iLeafEnd, &aLeaf, &nLeaf, 0);  if( rc==SQLITE_OK ){  NodeReader reader;  for(rc = nodeReaderInit(&reader, aLeaf, nLeaf);  rc==SQLITE_OK && reader.aNode;  rc = nodeReaderNext(&reader)  ){  assert( reader.aNode );  }  if( fts3TermCmp(zKey, nKey, reader.term.a, reader.term.n)<=0 ){  bAppendable = 0;  }  nodeReaderRelease(&reader);  }  sqlite3_free(aLeaf);  }  if( rc==SQLITE_OK && bAppendable ){  int i;  int nHeight = (int)aRoot[0];  NodeWriter *pNode;  if( nHeight<1 || nHeight>=FTS_MAX_APPENDABLE_HEIGHT ){  sqlite3_reset(pSelect);  return FTS_CORRUPT_VTAB;  }  pWriter->nLeafEst = (int)((iEnd - iStart) + 1)/FTS_MAX_APPENDABLE_HEIGHT;  pWriter->iStart = iStart;  pWriter->iEnd = iEnd;  pWriter->iAbsLevel = iAbsLevel;  pWriter->iIdx = iIdx;  for(i=nHeight+1; i<FTS_MAX_APPENDABLE_HEIGHT; i++){  pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;  }  pNode = &pWriter->aNodeWriter[nHeight];  pNode->iBlock = pWriter->iStart + pWriter->nLeafEst*nHeight;  blobGrowBuffer(&pNode->block,  MAX(nRoot, p->nNodeSize)+FTS3_NODE_PADDING, &rc  );  if( rc==SQLITE_OK ){  memcpy(pNode->block.a, aRoot, nRoot);  pNode->block.n = nRoot;  memset(&pNode->block.a[nRoot], 0, FTS3_NODE_PADDING);  }  for(i=nHeight; i>=0 && rc==SQLITE_OK; i--){  NodeReader reader;  pNode = &pWriter->aNodeWriter[i];  if( pNode->block.a){  rc = nodeReaderInit(&reader, pNode->block.a, pNode->block.n);  while( reader.aNode && rc==SQLITE_OK ) rc = nodeReaderNext(&reader);  blobGrowBuffer(&pNode->key, reader.term.n, &rc);  if( rc==SQLITE_OK ){  assert_fts3_nc( reader.term.n>0 || reader.aNode==0 );  if( reader.term.n>0 ){  memcpy(pNode->key.a, reader.term.a, reader.term.n);  }  pNode->key.n = reader.term.n;  if( i>0 ){  char *aBlock = 0;  int nBlock = 0;  pNode = &pWriter->aNodeWriter[i-1];  pNode->iBlock = reader.iChild;  rc = sqlite3Fts3ReadBlock(p, reader.iChild, &aBlock, &nBlock,0);  blobGrowBuffer(&pNode->block,  MAX(nBlock, p->nNodeSize)+FTS3_NODE_PADDING, &rc  );  if( rc==SQLITE_OK ){  memcpy(pNode->block.a, aBlock, nBlock);  pNode->block.n = nBlock;  memset(&pNode->block.a[nBlock], 0, FTS3_NODE_PADDING);  }  sqlite3_free(aBlock);  }  }  }  nodeReaderRelease(&reader);  }  }  rc2 = sqlite3_reset(pSelect);  if( rc==SQLITE_OK ) rc = rc2;  }  return rc; } static int fts3IncrmergeOutputIdx(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  int *piIdx ){  int rc;  sqlite3_stmt *pOutputIdx = 0;  rc = fts3SqlStmt(p, SQL_NEXT_SEGMENT_INDEX, &pOutputIdx, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pOutputIdx, 1, iAbsLevel+1);  sqlite3_step(pOutputIdx);  *piIdx = sqlite3_column_int(pOutputIdx, 0);  rc = sqlite3_reset(pOutputIdx);  }  return rc; } static int fts3IncrmergeWriter(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  int iIdx,  Fts3MultiSegReader *pCsr,  IncrmergeWriter *pWriter ){  int rc;  int i;  int nLeafEst = 0;  sqlite3_stmt *pLeafEst = 0;  sqlite3_stmt *pFirstBlock = 0;  rc = fts3SqlStmt(p, SQL_MAX_LEAF_NODE_ESTIMATE, &pLeafEst, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pLeafEst, 1, iAbsLevel);  sqlite3_bind_int64(pLeafEst, 2, pCsr->nSegment);  if( SQLITE_ROW==sqlite3_step(pLeafEst) ){  nLeafEst = sqlite3_column_int(pLeafEst, 0);  }  rc = sqlite3_reset(pLeafEst);  }  if( rc!=SQLITE_OK ) return rc;  rc = fts3SqlStmt(p, SQL_NEXT_SEGMENTS_ID, &pFirstBlock, 0);  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pFirstBlock) ){  pWriter->iStart = sqlite3_column_int64(pFirstBlock, 0);  pWriter->iEnd = pWriter->iStart - 1;  pWriter->iEnd += nLeafEst * FTS_MAX_APPENDABLE_HEIGHT;  }  rc = sqlite3_reset(pFirstBlock);  }  if( rc!=SQLITE_OK ) return rc;  rc = fts3WriteSegment(p, pWriter->iEnd, 0, 0);  if( rc!=SQLITE_OK ) return rc;  pWriter->iAbsLevel = iAbsLevel;  pWriter->nLeafEst = nLeafEst;  pWriter->iIdx = iIdx;  for(i=0; i<FTS_MAX_APPENDABLE_HEIGHT; i++){  pWriter->aNodeWriter[i].iBlock = pWriter->iStart + i*pWriter->nLeafEst;  }  return SQLITE_OK; } static int fts3RemoveSegdirEntry(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  int iIdx ){  int rc;  sqlite3_stmt *pDelete = 0;  rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_ENTRY, &pDelete, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pDelete, 1, iAbsLevel);  sqlite3_bind_int(pDelete, 2, iIdx);  sqlite3_step(pDelete);  rc = sqlite3_reset(pDelete);  }  return rc; } static int fts3RepackSegdirLevel(  Fts3Table *p,  sqlite3_int64 iAbsLevel ){  int rc;  int *aIdx = 0;  int nIdx = 0;  int nAlloc = 0;  int i;  sqlite3_stmt *pSelect = 0;  sqlite3_stmt *pUpdate = 0;  rc = fts3SqlStmt(p, SQL_SELECT_INDEXES, &pSelect, 0);  if( rc==SQLITE_OK ){  int rc2;  sqlite3_bind_int64(pSelect, 1, iAbsLevel);  while( SQLITE_ROW==sqlite3_step(pSelect) ){  if( nIdx>=nAlloc ){  int *aNew;  nAlloc += 16;  aNew = sqlite3_realloc(aIdx, nAlloc*sizeof(int));  if( !aNew ){  rc = SQLITE_NOMEM;  break;  }  aIdx = aNew;  }  aIdx[nIdx++] = sqlite3_column_int(pSelect, 0);  }  rc2 = sqlite3_reset(pSelect);  if( rc==SQLITE_OK ) rc = rc2;  }  if( rc==SQLITE_OK ){  rc = fts3SqlStmt(p, SQL_SHIFT_SEGDIR_ENTRY, &pUpdate, 0);  }  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pUpdate, 2, iAbsLevel);  }  assert( p->bIgnoreSavepoint==0 );  p->bIgnoreSavepoint = 1;  for(i=0; rc==SQLITE_OK && i<nIdx; i++){  if( aIdx[i]!=i ){  sqlite3_bind_int(pUpdate, 3, aIdx[i]);  sqlite3_bind_int(pUpdate, 1, i);  sqlite3_step(pUpdate);  rc = sqlite3_reset(pUpdate);  }  }  p->bIgnoreSavepoint = 0;  sqlite3_free(aIdx);  return rc; } static void fts3StartNode(Blob *pNode, int iHeight, sqlite3_int64 iChild){  pNode->a[0] = (char)iHeight;  if( iChild ){  assert( pNode->nAlloc>=1+sqlite3Fts3VarintLen(iChild) );  pNode->n = 1 + sqlite3Fts3PutVarint(&pNode->a[1], iChild);  }else{  assert( pNode->nAlloc>=1 );  pNode->n = 1;  } } static int fts3TruncateNode(  const char *aNode,  int nNode,  Blob *pNew,  const char *zTerm,  int nTerm,  sqlite3_int64 *piBlock ){  NodeReader reader;  Blob prev = {0, 0, 0};  int rc = SQLITE_OK;  int bLeaf;  if( nNode<1 ) return FTS_CORRUPT_VTAB;  bLeaf = aNode[0]=='\0';  blobGrowBuffer(pNew, nNode, &rc);  if( rc!=SQLITE_OK ) return rc;  pNew->n = 0;  for(rc = nodeReaderInit(&reader, aNode, nNode);  rc==SQLITE_OK && reader.aNode;  rc = nodeReaderNext(&reader)  ){  if( pNew->n==0 ){  int res = fts3TermCmp(reader.term.a, reader.term.n, zTerm, nTerm);  if( res<0 || (bLeaf==0 && res==0) ) continue;  fts3StartNode(pNew, (int)aNode[0], reader.iChild);  *piBlock = reader.iChild;  }  rc = fts3AppendToNode(  pNew, &prev, reader.term.a, reader.term.n,  reader.aDoclist, reader.nDoclist  );  if( rc!=SQLITE_OK ) break;  }  if( pNew->n==0 ){  fts3StartNode(pNew, (int)aNode[0], reader.iChild);  *piBlock = reader.iChild;  }  assert( pNew->n<=pNew->nAlloc );  nodeReaderRelease(&reader);  sqlite3_free(prev.a);  return rc; } static int fts3TruncateSegment(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  int iIdx,  const char *zTerm,  int nTerm ){  int rc = SQLITE_OK;  Blob root = {0,0,0};  Blob block = {0,0,0};  sqlite3_int64 iBlock = 0;  sqlite3_int64 iNewStart = 0;  sqlite3_int64 iOldStart = 0;  sqlite3_stmt *pFetch = 0;  rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR, &pFetch, 0);  if( rc==SQLITE_OK ){  int rc2;  sqlite3_bind_int64(pFetch, 1, iAbsLevel);  sqlite3_bind_int(pFetch, 2, iIdx);  if( SQLITE_ROW==sqlite3_step(pFetch) ){  const char *aRoot = sqlite3_column_blob(pFetch, 4);  int nRoot = sqlite3_column_bytes(pFetch, 4);  iOldStart = sqlite3_column_int64(pFetch, 1);  rc = fts3TruncateNode(aRoot, nRoot, &root, zTerm, nTerm, &iBlock);  }  rc2 = sqlite3_reset(pFetch);  if( rc==SQLITE_OK ) rc = rc2;  }  while( rc==SQLITE_OK && iBlock ){  char *aBlock = 0;  int nBlock = 0;  iNewStart = iBlock;  rc = sqlite3Fts3ReadBlock(p, iBlock, &aBlock, &nBlock, 0);  if( rc==SQLITE_OK ){  rc = fts3TruncateNode(aBlock, nBlock, &block, zTerm, nTerm, &iBlock);  }  if( rc==SQLITE_OK ){  rc = fts3WriteSegment(p, iNewStart, block.a, block.n);  }  sqlite3_free(aBlock);  }  if( rc==SQLITE_OK && iNewStart ){  sqlite3_stmt *pDel = 0;  rc = fts3SqlStmt(p, SQL_DELETE_SEGMENTS_RANGE, &pDel, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pDel, 1, iOldStart);  sqlite3_bind_int64(pDel, 2, iNewStart-1);  sqlite3_step(pDel);  rc = sqlite3_reset(pDel);  }  }  if( rc==SQLITE_OK ){  sqlite3_stmt *pChomp = 0;  rc = fts3SqlStmt(p, SQL_CHOMP_SEGDIR, &pChomp, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pChomp, 1, iNewStart);  sqlite3_bind_blob(pChomp, 2, root.a, root.n, SQLITE_STATIC);  sqlite3_bind_int64(pChomp, 3, iAbsLevel);  sqlite3_bind_int(pChomp, 4, iIdx);  sqlite3_step(pChomp);  rc = sqlite3_reset(pChomp);  sqlite3_bind_null(pChomp, 2);  }  }  sqlite3_free(root.a);  sqlite3_free(block.a);  return rc; } static int fts3IncrmergeChomp(  Fts3Table *p,  sqlite3_int64 iAbsLevel,  Fts3MultiSegReader *pCsr,  int *pnRem ){  int i;  int nRem = 0;  int rc = SQLITE_OK;  for(i=pCsr->nSegment-1; i>=0 && rc==SQLITE_OK; i--){  Fts3SegReader *pSeg = 0;  int j;  for(j=0; ALWAYS(j<pCsr->nSegment); j++){  pSeg = pCsr->apSegment[j];  if( pSeg->iIdx==i ) break;  }  assert( j<pCsr->nSegment && pSeg->iIdx==i );  if( pSeg->aNode==0 ){  rc = fts3DeleteSegment(p, pSeg);  if( rc==SQLITE_OK ){  rc = fts3RemoveSegdirEntry(p, iAbsLevel, pSeg->iIdx);  }  *pnRem = 0;  }else{  const char *zTerm = pSeg->zTerm;  int nTerm = pSeg->nTerm;  rc = fts3TruncateSegment(p, iAbsLevel, pSeg->iIdx, zTerm, nTerm);  nRem++;  }  }  if( rc==SQLITE_OK && nRem!=pCsr->nSegment ){  rc = fts3RepackSegdirLevel(p, iAbsLevel);  }  *pnRem = nRem;  return rc; } static int fts3IncrmergeHintStore(Fts3Table *p, Blob *pHint){  sqlite3_stmt *pReplace = 0;  int rc;  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pReplace, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int(pReplace, 1, FTS_STAT_INCRMERGEHINT);  sqlite3_bind_blob(pReplace, 2, pHint->a, pHint->n, SQLITE_STATIC);  sqlite3_step(pReplace);  rc = sqlite3_reset(pReplace);  sqlite3_bind_null(pReplace, 2);  }  return rc; } static int fts3IncrmergeHintLoad(Fts3Table *p, Blob *pHint){  sqlite3_stmt *pSelect = 0;  int rc;  pHint->n = 0;  rc = fts3SqlStmt(p, SQL_SELECT_STAT, &pSelect, 0);  if( rc==SQLITE_OK ){  int rc2;  sqlite3_bind_int(pSelect, 1, FTS_STAT_INCRMERGEHINT);  if( SQLITE_ROW==sqlite3_step(pSelect) ){  const char *aHint = sqlite3_column_blob(pSelect, 0);  int nHint = sqlite3_column_bytes(pSelect, 0);  if( aHint ){  blobGrowBuffer(pHint, nHint, &rc);  if( rc==SQLITE_OK ){  if( ALWAYS(pHint->a!=0) ) memcpy(pHint->a, aHint, nHint);  pHint->n = nHint;  }  }  }  rc2 = sqlite3_reset(pSelect);  if( rc==SQLITE_OK ) rc = rc2;  }  return rc; } static void fts3IncrmergeHintPush(  Blob *pHint,  i64 iAbsLevel,  int nInput,  int *pRc ){  blobGrowBuffer(pHint, pHint->n + 2*FTS3_VARINT_MAX, pRc);  if( *pRc==SQLITE_OK ){  pHint->n += sqlite3Fts3PutVarint(&pHint->a[pHint->n], iAbsLevel);  pHint->n += sqlite3Fts3PutVarint(&pHint->a[pHint->n], (i64)nInput);  } } static int fts3IncrmergeHintPop(Blob *pHint, i64 *piAbsLevel, int *pnInput){  const int nHint = pHint->n;  int i;  i = pHint->n-1;  if( (pHint->a[i] & 0x80) ) return FTS_CORRUPT_VTAB;  while( i>0 && (pHint->a[i-1] & 0x80) ) i--;  if( i==0 ) return FTS_CORRUPT_VTAB;  i--;  while( i>0 && (pHint->a[i-1] & 0x80) ) i--;  pHint->n = i;  i += sqlite3Fts3GetVarint(&pHint->a[i], piAbsLevel);  i += fts3GetVarint32(&pHint->a[i], pnInput);  assert( i<=nHint );  if( i!=nHint ) return FTS_CORRUPT_VTAB;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3Incrmerge(Fts3Table *p, int nMerge, int nMin){  int rc;  int nRem = nMerge;  Fts3MultiSegReader *pCsr;  Fts3SegFilter *pFilter;  IncrmergeWriter *pWriter;  int nSeg = 0;  sqlite3_int64 iAbsLevel = 0;  Blob hint = {0, 0, 0};  int bDirtyHint = 0;  const int nAlloc = sizeof(*pCsr) + sizeof(*pFilter) + sizeof(*pWriter);  pWriter = (IncrmergeWriter *)sqlite3_malloc(nAlloc);  if( !pWriter ) return SQLITE_NOMEM;  pFilter = (Fts3SegFilter *)&pWriter[1];  pCsr = (Fts3MultiSegReader *)&pFilter[1];  rc = fts3IncrmergeHintLoad(p, &hint);  while( rc==SQLITE_OK && nRem>0 ){  const i64 nMod = FTS3_SEGDIR_MAXLEVEL * p->nIndex;  sqlite3_stmt *pFindLevel = 0;  int bUseHint = 0;  int iIdx = 0;  rc = fts3SqlStmt(p, SQL_FIND_MERGE_LEVEL, &pFindLevel, 0);  sqlite3_bind_int(pFindLevel, 1, MAX(2, nMin));  if( sqlite3_step(pFindLevel)==SQLITE_ROW ){  iAbsLevel = sqlite3_column_int64(pFindLevel, 0);  nSeg = sqlite3_column_int(pFindLevel, 1);  assert( nSeg>=2 );  }else{  nSeg = -1;  }  rc = sqlite3_reset(pFindLevel);  if( rc==SQLITE_OK && hint.n ){  int nHint = hint.n;  sqlite3_int64 iHintAbsLevel = 0;  int nHintSeg = 0;  rc = fts3IncrmergeHintPop(&hint, &iHintAbsLevel, &nHintSeg);  if( nSeg<0 || (iAbsLevel % nMod) >= (iHintAbsLevel % nMod) ){  iAbsLevel = iHintAbsLevel;  nSeg = MIN(MAX(nMin,nSeg), nHintSeg);  bUseHint = 1;  bDirtyHint = 1;  }else{  hint.n = nHint;  }  }  if( nSeg<=0 ) break;  assert( nMod<=0x7FFFFFFF );  if( iAbsLevel<0 || iAbsLevel>(nMod<<32) ){  rc = FTS_CORRUPT_VTAB;  break;  }  memset(pWriter, 0, nAlloc);  pFilter->flags = FTS3_SEGMENT_REQUIRE_POS;  if( rc==SQLITE_OK ){  rc = fts3IncrmergeOutputIdx(p, iAbsLevel, &iIdx);  assert( bUseHint==1 || bUseHint==0 );  if( iIdx==0 || (bUseHint && iIdx==1) ){  int bIgnore = 0;  rc = fts3SegmentIsMaxLevel(p, iAbsLevel+1, &bIgnore);  if( bIgnore ){  pFilter->flags |= FTS3_SEGMENT_IGNORE_EMPTY;  }  }  }  if( rc==SQLITE_OK ){  rc = fts3IncrmergeCsr(p, iAbsLevel, nSeg, pCsr);  }  if( SQLITE_OK==rc && pCsr->nSegment==nSeg   && SQLITE_OK==(rc = sqlite3Fts3SegReaderStart(p, pCsr, pFilter))  ){  int bEmpty = 0;  rc = sqlite3Fts3SegReaderStep(p, pCsr);  if( rc==SQLITE_OK ){  bEmpty = 1;  }else if( rc!=SQLITE_ROW ){  sqlite3Fts3SegReaderFinish(pCsr);  break;  }  if( bUseHint && iIdx>0 ){  const char *zKey = pCsr->zTerm;  int nKey = pCsr->nTerm;  rc = fts3IncrmergeLoad(p, iAbsLevel, iIdx-1, zKey, nKey, pWriter);  }else{  rc = fts3IncrmergeWriter(p, iAbsLevel, iIdx, pCsr, pWriter);  }  if( rc==SQLITE_OK && pWriter->nLeafEst ){  fts3LogMerge(nSeg, iAbsLevel);  if( bEmpty==0 ){  do {  rc = fts3IncrmergeAppend(p, pWriter, pCsr);  if( rc==SQLITE_OK ) rc = sqlite3Fts3SegReaderStep(p, pCsr);  if( pWriter->nWork>=nRem && rc==SQLITE_ROW ) rc = SQLITE_OK;  }while( rc==SQLITE_ROW );  }  if( rc==SQLITE_OK ){  nRem -= (1 + pWriter->nWork);  rc = fts3IncrmergeChomp(p, iAbsLevel, pCsr, &nSeg);  if( nSeg!=0 ){  bDirtyHint = 1;  fts3IncrmergeHintPush(&hint, iAbsLevel, nSeg, &rc);  }  }  }  if( nSeg!=0 ){  pWriter->nLeafData = pWriter->nLeafData * -1;  }  fts3IncrmergeRelease(p, pWriter, &rc);  if( nSeg==0 && pWriter->bNoLeafData==0 ){  fts3PromoteSegments(p, iAbsLevel+1, pWriter->nLeafData);  }  }  sqlite3Fts3SegReaderFinish(pCsr);  }  if( bDirtyHint && rc==SQLITE_OK ){  rc = fts3IncrmergeHintStore(p, &hint);  }  sqlite3_free(pWriter);  sqlite3_free(hint.a);  return rc; } static int fts3Getint(const char **pz){  const char *z = *pz;  int i = 0;  while( (*z)>='0' && (*z)<='9' && i<214748363 ) i = 10*i + *(z++) - '0';  *pz = z;  return i; } static int fts3DoIncrmerge(  Fts3Table *p,  const char *zParam ){  int rc;  int nMin = (MergeCount(p) / 2);  int nMerge = 0;  const char *z = zParam;  nMerge = fts3Getint(&z);  if( z[0]==',' && z[1]!='\0' ){  z++;  nMin = fts3Getint(&z);  }  if( z[0]!='\0' || nMin<2 ){  rc = SQLITE_ERROR;  }else{  rc = SQLITE_OK;  if( !p->bHasStat ){  assert( p->bFts4==0 );  sqlite3Fts3CreateStatTable(&rc, p);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts3Incrmerge(p, nMerge, nMin);  }  sqlite3Fts3SegmentsClose(p);  }  return rc; } static int fts3DoAutoincrmerge(  Fts3Table *p,  const char *zParam ){  int rc = SQLITE_OK;  sqlite3_stmt *pStmt = 0;  p->nAutoincrmerge = fts3Getint(&zParam);  if( p->nAutoincrmerge==1 || p->nAutoincrmerge>MergeCount(p) ){  p->nAutoincrmerge = 8;  }  if( !p->bHasStat ){  assert( p->bFts4==0 );  sqlite3Fts3CreateStatTable(&rc, p);  if( rc ) return rc;  }  rc = fts3SqlStmt(p, SQL_REPLACE_STAT, &pStmt, 0);  if( rc ) return rc;  sqlite3_bind_int(pStmt, 1, FTS_STAT_AUTOINCRMERGE);  sqlite3_bind_int(pStmt, 2, p->nAutoincrmerge);  sqlite3_step(pStmt);  rc = sqlite3_reset(pStmt);  return rc; } static u64 fts3ChecksumEntry(  const char *zTerm,  int nTerm,  int iLangid,  int iIndex,  i64 iDocid,  int iCol,  int iPos ){  int i;  u64 ret = (u64)iDocid;  ret += (ret<<3) + iLangid;  ret += (ret<<3) + iIndex;  ret += (ret<<3) + iCol;  ret += (ret<<3) + iPos;  for(i=0; i<nTerm; i++) ret += (ret<<3) + zTerm[i];  return ret; } static u64 fts3ChecksumIndex(  Fts3Table *p,  int iLangid,  int iIndex,  int *pRc ){  Fts3SegFilter filter;  Fts3MultiSegReader csr;  int rc;  u64 cksum = 0;  assert( *pRc==SQLITE_OK );  memset(&filter, 0, sizeof(filter));  memset(&csr, 0, sizeof(csr));  filter.flags = FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;  filter.flags |= FTS3_SEGMENT_SCAN;  rc = sqlite3Fts3SegReaderCursor(  p, iLangid, iIndex, FTS3_SEGCURSOR_ALL, 0, 0, 0, 1,&csr  );  if( rc==SQLITE_OK ){  rc = sqlite3Fts3SegReaderStart(p, &csr, &filter);  }  if( rc==SQLITE_OK ){  while( SQLITE_ROW==(rc = sqlite3Fts3SegReaderStep(p, &csr)) ){  char *pCsr = csr.aDoclist;  char *pEnd = &pCsr[csr.nDoclist];  i64 iDocid = 0;  i64 iCol = 0;  u64 iPos = 0;  pCsr += sqlite3Fts3GetVarint(pCsr, &iDocid);  while( pCsr<pEnd ){  u64 iVal = 0;  pCsr += sqlite3Fts3GetVarintU(pCsr, &iVal);  if( pCsr<pEnd ){  if( iVal==0 || iVal==1 ){  iCol = 0;  iPos = 0;  if( iVal ){  pCsr += sqlite3Fts3GetVarint(pCsr, &iCol);  }else{  pCsr += sqlite3Fts3GetVarintU(pCsr, &iVal);  if( p->bDescIdx ){  iDocid = (i64)((u64)iDocid - iVal);  }else{  iDocid = (i64)((u64)iDocid + iVal);  }  }  }else{  iPos += (iVal - 2);  cksum = cksum ^ fts3ChecksumEntry(  csr.zTerm, csr.nTerm, iLangid, iIndex, iDocid,  (int)iCol, (int)iPos  );  }  }  }  }  }  sqlite3Fts3SegReaderFinish(&csr);  *pRc = rc;  return cksum; } static int fts3IntegrityCheck(Fts3Table *p, int *pbOk){  int rc = SQLITE_OK;  u64 cksum1 = 0;  u64 cksum2 = 0;  sqlite3_stmt *pAllLangid = 0;  rc = fts3SqlStmt(p, SQL_SELECT_ALL_LANGID, &pAllLangid, 0);  if( rc==SQLITE_OK ){  int rc2;  sqlite3_bind_int(pAllLangid, 1, p->iPrevLangid);  sqlite3_bind_int(pAllLangid, 2, p->nIndex);  while( rc==SQLITE_OK && sqlite3_step(pAllLangid)==SQLITE_ROW ){  int iLangid = sqlite3_column_int(pAllLangid, 0);  int i;  for(i=0; i<p->nIndex; i++){  cksum1 = cksum1 ^ fts3ChecksumIndex(p, iLangid, i, &rc);  }  }  rc2 = sqlite3_reset(pAllLangid);  if( rc==SQLITE_OK ) rc = rc2;  }  if( rc==SQLITE_OK ){  sqlite3_tokenizer_module const *pModule = p->pTokenizer->pModule;  sqlite3_stmt *pStmt = 0;  char *zSql;  zSql = sqlite3_mprintf("SELECT %s" , p->zReadExprlist);  if( !zSql ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, 0);  sqlite3_free(zSql);  }  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){  i64 iDocid = sqlite3_column_int64(pStmt, 0);  int iLang = langidFromSelect(p, pStmt);  int iCol;  for(iCol=0; rc==SQLITE_OK && iCol<p->nColumn; iCol++){  if( p->abNotindexed[iCol]==0 ){  const char *zText = (const char *)sqlite3_column_text(pStmt, iCol+1);  sqlite3_tokenizer_cursor *pT = 0;  rc = sqlite3Fts3OpenTokenizer(p->pTokenizer, iLang, zText, -1, &pT);  while( rc==SQLITE_OK ){  char const *zToken;  int nToken = 0;  int iDum1 = 0, iDum2 = 0;  int iPos = 0;  rc = pModule->xNext(pT, &zToken, &nToken, &iDum1, &iDum2, &iPos);  if( rc==SQLITE_OK ){  int i;  cksum2 = cksum2 ^ fts3ChecksumEntry(  zToken, nToken, iLang, 0, iDocid, iCol, iPos  );  for(i=1; i<p->nIndex; i++){  if( p->aIndex[i].nPrefix<=nToken ){  cksum2 = cksum2 ^ fts3ChecksumEntry(  zToken, p->aIndex[i].nPrefix, iLang, i, iDocid, iCol, iPos  );  }  }  }  }  if( pT ) pModule->xClose(pT);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  }  }  }  sqlite3_finalize(pStmt);  }  *pbOk = (cksum1==cksum2);  return rc; } static int fts3DoIntegrityCheck(  Fts3Table *p ){  int rc;  int bOk = 0;  rc = fts3IntegrityCheck(p, &bOk);  if( rc==SQLITE_OK && bOk==0 ) rc = FTS_CORRUPT_VTAB;  return rc; } static int fts3SpecialInsert(Fts3Table *p, sqlite3_value *pVal){  int rc = SQLITE_ERROR;  const char *zVal = (const char *)sqlite3_value_text(pVal);  int nVal = sqlite3_value_bytes(pVal);  if( !zVal ){  return SQLITE_NOMEM;  }else if( nVal==8 && 0==sqlite3_strnicmp(zVal, "optimize", 8) ){  rc = fts3DoOptimize(p, 0);  }else if( nVal==7 && 0==sqlite3_strnicmp(zVal, "rebuild", 7) ){  rc = fts3DoRebuild(p);  }else if( nVal==15 && 0==sqlite3_strnicmp(zVal, "integrity-check", 15) ){  rc = fts3DoIntegrityCheck(p);  }else if( nVal>6 && 0==sqlite3_strnicmp(zVal, "merge=", 6) ){  rc = fts3DoIncrmerge(p, &zVal[6]);  }else if( nVal>10 && 0==sqlite3_strnicmp(zVal, "automerge=", 10) ){  rc = fts3DoAutoincrmerge(p, &zVal[10]);
#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)
 }else{  int v;  if( nVal>9 && 0==sqlite3_strnicmp(zVal, "nodesize=", 9) ){  v = atoi(&zVal[9]);  if( v>=24 && v<=p->nPgsz-35 ) p->nNodeSize = v;  rc = SQLITE_OK;  }else if( nVal>11 && 0==sqlite3_strnicmp(zVal, "maxpending=", 9) ){  v = atoi(&zVal[11]);  if( v>=64 && v<=FTS3_MAX_PENDING_DATA ) p->nMaxPendingData = v;  rc = SQLITE_OK;  }else if( nVal>21 && 0==sqlite3_strnicmp(zVal,"test-no-incr-doclist=",21) ){  p->bNoIncrDoclist = atoi(&zVal[21]);  rc = SQLITE_OK;  }else if( nVal>11 && 0==sqlite3_strnicmp(zVal,"mergecount=",11) ){  v = atoi(&zVal[11]);  if( v>=4 && v<=FTS3_MERGE_COUNT && (v&1)==0 ) p->nMergeCount = v;  rc = SQLITE_OK;  }
#endif
 }  return rc; }
#ifndef SQLITE_DISABLE_FTS4_DEFERRED
SQLITE_PRIVATE void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *pCsr){  Fts3DeferredToken *pDef;  for(pDef=pCsr->pDeferred; pDef; pDef=pDef->pNext){  fts3PendingListDelete(pDef->pList);  pDef->pList = 0;  } } SQLITE_PRIVATE void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *pCsr){  Fts3DeferredToken *pDef;  Fts3DeferredToken *pNext;  for(pDef=pCsr->pDeferred; pDef; pDef=pNext){  pNext = pDef->pNext;  fts3PendingListDelete(pDef->pList);  sqlite3_free(pDef);  }  pCsr->pDeferred = 0; } SQLITE_PRIVATE int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *pCsr){  int rc = SQLITE_OK;  if( pCsr->pDeferred ){  int i;  sqlite3_int64 iDocid;  Fts3DeferredToken *pDef;  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;  sqlite3_tokenizer *pT = p->pTokenizer;  sqlite3_tokenizer_module const *pModule = pT->pModule;  assert( pCsr->isRequireSeek==0 );  iDocid = sqlite3_column_int64(pCsr->pStmt, 0);  for(i=0; i<p->nColumn && rc==SQLITE_OK; i++){  if( p->abNotindexed[i]==0 ){  const char *zText = (const char *)sqlite3_column_text(pCsr->pStmt, i+1);  sqlite3_tokenizer_cursor *pTC = 0;  rc = sqlite3Fts3OpenTokenizer(pT, pCsr->iLangid, zText, -1, &pTC);  while( rc==SQLITE_OK ){  char const *zToken;  int nToken = 0;  int iDum1 = 0, iDum2 = 0;  int iPos = 0;  rc = pModule->xNext(pTC, &zToken, &nToken, &iDum1, &iDum2, &iPos);  for(pDef=pCsr->pDeferred; pDef && rc==SQLITE_OK; pDef=pDef->pNext){  Fts3PhraseToken *pPT = pDef->pToken;  if( (pDef->iCol>=p->nColumn || pDef->iCol==i)  && (pPT->bFirst==0 || iPos==0)  && (pPT->n==nToken || (pPT->isPrefix && pPT->n<nToken))  && (0==memcmp(zToken, pPT->z, pPT->n))  ){  fts3PendingListAppend(&pDef->pList, iDocid, i, iPos, &rc);  }  }  }  if( pTC ) pModule->xClose(pTC);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  }  }  for(pDef=pCsr->pDeferred; pDef && rc==SQLITE_OK; pDef=pDef->pNext){  if( pDef->pList ){  rc = fts3PendingListAppendVarint(&pDef->pList, 0);  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3DeferredTokenList(  Fts3DeferredToken *p,  char **ppData,  int *pnData ){  char *pRet;  int nSkip;  sqlite3_int64 dummy;  *ppData = 0;  *pnData = 0;  if( p->pList==0 ){  return SQLITE_OK;  }  pRet = (char *)sqlite3_malloc(p->pList->nData);  if( !pRet ) return SQLITE_NOMEM;  nSkip = sqlite3Fts3GetVarint(p->pList->aData, &dummy);  *pnData = p->pList->nData - nSkip;  *ppData = pRet;  memcpy(pRet, &p->pList->aData[nSkip], *pnData);  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3Fts3DeferToken(  Fts3Cursor *pCsr,  Fts3PhraseToken *pToken,  int iCol ){  Fts3DeferredToken *pDeferred;  pDeferred = sqlite3_malloc(sizeof(*pDeferred));  if( !pDeferred ){  return SQLITE_NOMEM;  }  memset(pDeferred, 0, sizeof(*pDeferred));  pDeferred->pToken = pToken;  pDeferred->pNext = pCsr->pDeferred;  pDeferred->iCol = iCol;  pCsr->pDeferred = pDeferred;  assert( pToken->pDeferred==0 );  pToken->pDeferred = pDeferred;  return SQLITE_OK; }
#endif
static int fts3DeleteByRowid(  Fts3Table *p,  sqlite3_value *pRowid,  int *pnChng,  u32 *aSzDel ){  int rc = SQLITE_OK;  int bFound = 0;  fts3DeleteTerms(&rc, p, pRowid, aSzDel, &bFound);  if( bFound && rc==SQLITE_OK ){  int isEmpty = 0;  rc = fts3IsEmpty(p, pRowid, &isEmpty);  if( rc==SQLITE_OK ){  if( isEmpty ){  rc = fts3DeleteAll(p, 1);  *pnChng = 0;  memset(aSzDel, 0, sizeof(u32) * (p->nColumn+1) * 2);  }else{  *pnChng = *pnChng - 1;  if( p->zContentTbl==0 ){  fts3SqlExec(&rc, p, SQL_DELETE_CONTENT, &pRowid);  }  if( p->bHasDocsize ){  fts3SqlExec(&rc, p, SQL_DELETE_DOCSIZE, &pRowid);  }  }  }  }  return rc; } SQLITE_PRIVATE int sqlite3Fts3UpdateMethod(  sqlite3_vtab *pVtab,  int nArg,  sqlite3_value **apVal,  sqlite_int64 *pRowid ){  Fts3Table *p = (Fts3Table *)pVtab;  int rc = SQLITE_OK;  u32 *aSzIns = 0;  u32 *aSzDel = 0;  int nChng = 0;  int bInsertDone = 0;  assert( p->bHasStat==0 || p->bHasStat==1 );  assert( p->pSegments==0 );  assert(  nArg==1   || nArg==(2 + p->nColumn + 3)  );  if( nArg>1   && sqlite3_value_type(apVal[0])==SQLITE_NULL   && sqlite3_value_type(apVal[p->nColumn+2])!=SQLITE_NULL  ){  rc = fts3SpecialInsert(p, apVal[p->nColumn+2]);  goto update_out;  }  if( nArg>1 && sqlite3_value_int(apVal[2 + p->nColumn + 2])<0 ){  rc = SQLITE_CONSTRAINT;  goto update_out;  }  aSzDel = sqlite3_malloc64(sizeof(aSzDel[0])*((sqlite3_int64)p->nColumn+1)*2);  if( aSzDel==0 ){  rc = SQLITE_NOMEM;  goto update_out;  }  aSzIns = &aSzDel[p->nColumn+1];  memset(aSzDel, 0, sizeof(aSzDel[0])*(p->nColumn+1)*2);  rc = fts3Writelock(p);  if( rc!=SQLITE_OK ) goto update_out;  if( nArg>1 && p->zContentTbl==0 ){  sqlite3_value *pNewRowid = apVal[3+p->nColumn];  if( sqlite3_value_type(pNewRowid)==SQLITE_NULL ){  pNewRowid = apVal[1];  }  if( sqlite3_value_type(pNewRowid)!=SQLITE_NULL && (  sqlite3_value_type(apVal[0])==SQLITE_NULL   || sqlite3_value_int64(apVal[0])!=sqlite3_value_int64(pNewRowid)  )){  if( sqlite3_vtab_on_conflict(p->db)==SQLITE_REPLACE ){  rc = fts3DeleteByRowid(p, pNewRowid, &nChng, aSzDel);  }else{  rc = fts3InsertData(p, apVal, pRowid);  bInsertDone = 1;  }  }  }  if( rc!=SQLITE_OK ){  goto update_out;  }  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){  assert( sqlite3_value_type(apVal[0])==SQLITE_INTEGER );  rc = fts3DeleteByRowid(p, apVal[0], &nChng, aSzDel);  }  if( nArg>1 && rc==SQLITE_OK ){  int iLangid = sqlite3_value_int(apVal[2 + p->nColumn + 2]);  if( bInsertDone==0 ){  rc = fts3InsertData(p, apVal, pRowid);  if( rc==SQLITE_CONSTRAINT && p->zContentTbl==0 ){  rc = FTS_CORRUPT_VTAB;  }  }  if( rc==SQLITE_OK ){  rc = fts3PendingTermsDocid(p, 0, iLangid, *pRowid);  }  if( rc==SQLITE_OK ){  assert( p->iPrevDocid==*pRowid );  rc = fts3InsertTerms(p, iLangid, apVal, aSzIns);  }  if( p->bHasDocsize ){  fts3InsertDocsize(&rc, p, aSzIns);  }  nChng++;  }  if( p->bFts4 ){  fts3UpdateDocTotals(&rc, p, aSzIns, aSzDel, nChng);  }  update_out:  sqlite3_free(aSzDel);  sqlite3Fts3SegmentsClose(p);  return rc; } SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *p){  int rc;  rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);  if( rc==SQLITE_OK ){  rc = fts3DoOptimize(p, 1);  if( rc==SQLITE_OK || rc==SQLITE_DONE ){  int rc2 = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);  if( rc2!=SQLITE_OK ) rc = rc2;  }else{  sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);  sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);  }  }  sqlite3Fts3SegmentsClose(p);  return rc; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#ifndef SQLITE_AMALGAMATION
typedef sqlite3_int64 i64;
#endif
#define FTS3_MATCHINFO_NPHRASE  'p'
#define FTS3_MATCHINFO_NCOL 'c'
#define FTS3_MATCHINFO_NDOC 'n'
#define FTS3_MATCHINFO_AVGLENGTH 'a'
#define FTS3_MATCHINFO_LENGTH 'l'
#define FTS3_MATCHINFO_LCS  's'
#define FTS3_MATCHINFO_HITS 'x'
#define FTS3_MATCHINFO_LHITS  'y'
#define FTS3_MATCHINFO_LHITS_BM 'b'
#define FTS3_MATCHINFO_DEFAULT  "pcx"
typedef struct LoadDoclistCtx LoadDoclistCtx; struct LoadDoclistCtx {  Fts3Cursor *pCsr;  int nPhrase;  int nToken; }; typedef struct SnippetIter SnippetIter; typedef struct SnippetPhrase SnippetPhrase; typedef struct SnippetFragment SnippetFragment; struct SnippetIter {  Fts3Cursor *pCsr;  int iCol;  int nSnippet;  int nPhrase;  SnippetPhrase *aPhrase;  int iCurrent; }; struct SnippetPhrase {  int nToken;  char *pList;  i64 iHead;  char *pHead;  i64 iTail;  char *pTail; }; struct SnippetFragment {  int iCol;  int iPos;  u64 covered;  u64 hlmask; }; typedef struct MatchInfo MatchInfo; struct MatchInfo {  Fts3Cursor *pCursor;  int nCol;  int nPhrase;  sqlite3_int64 nDoc;  char flag;  u32 *aMatchinfo; }; struct MatchinfoBuffer {  u8 aRef[3];  int nElem;  int bGlobal;  char *zMatchinfo;  u32 aMatchinfo[1]; }; typedef struct StrBuffer StrBuffer; struct StrBuffer {  char *z;  int n;  int nAlloc; }; static MatchinfoBuffer *fts3MIBufferNew(size_t nElem, const char *zMatchinfo){  MatchinfoBuffer *pRet;  sqlite3_int64 nByte = sizeof(u32) * (2*(sqlite3_int64)nElem + 1)   + sizeof(MatchinfoBuffer);  sqlite3_int64 nStr = strlen(zMatchinfo);  pRet = sqlite3Fts3MallocZero(nByte + nStr+1);  if( pRet ){  pRet->aMatchinfo[0] = (u8*)(&pRet->aMatchinfo[1]) - (u8*)pRet;  pRet->aMatchinfo[1+nElem] = pRet->aMatchinfo[0]  + sizeof(u32)*((int)nElem+1);  pRet->nElem = (int)nElem;  pRet->zMatchinfo = ((char*)pRet) + nByte;  memcpy(pRet->zMatchinfo, zMatchinfo, nStr+1);  pRet->aRef[0] = 1;  }  return pRet; } static void fts3MIBufferFree(void *p){  MatchinfoBuffer *pBuf = (MatchinfoBuffer*)((u8*)p - ((u32*)p)[-1]);  assert( (u32*)p==&pBuf->aMatchinfo[1]   || (u32*)p==&pBuf->aMatchinfo[pBuf->nElem+2]  );  if( (u32*)p==&pBuf->aMatchinfo[1] ){  pBuf->aRef[1] = 0;  }else{  pBuf->aRef[2] = 0;  }  if( pBuf->aRef[0]==0 && pBuf->aRef[1]==0 && pBuf->aRef[2]==0 ){  sqlite3_free(pBuf);  } } static void (*fts3MIBufferAlloc(MatchinfoBuffer *p, u32 **paOut))(void*){  void (*xRet)(void*) = 0;  u32 *aOut = 0;  if( p->aRef[1]==0 ){  p->aRef[1] = 1;  aOut = &p->aMatchinfo[1];  xRet = fts3MIBufferFree;  }  else if( p->aRef[2]==0 ){  p->aRef[2] = 1;  aOut = &p->aMatchinfo[p->nElem+2];  xRet = fts3MIBufferFree;  }else{  aOut = (u32*)sqlite3_malloc64(p->nElem * sizeof(u32));  if( aOut ){  xRet = sqlite3_free;  if( p->bGlobal ) memcpy(aOut, &p->aMatchinfo[1], p->nElem*sizeof(u32));  }  }  *paOut = aOut;  return xRet; } static void fts3MIBufferSetGlobal(MatchinfoBuffer *p){  p->bGlobal = 1;  memcpy(&p->aMatchinfo[2+p->nElem], &p->aMatchinfo[1], p->nElem*sizeof(u32)); } SQLITE_PRIVATE void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p){  if( p ){  assert( p->aRef[0]==1 );  p->aRef[0] = 0;  if( p->aRef[0]==0 && p->aRef[1]==0 && p->aRef[2]==0 ){  sqlite3_free(p);  }  } } static void fts3GetDeltaPosition(char **pp, i64 *piPos){  int iVal;  *pp += fts3GetVarint32(*pp, &iVal);  *piPos += (iVal-2); } static int fts3ExprIterate2(  Fts3Expr *pExpr,  int *piPhrase,  int (*x)(Fts3Expr*,int,void*),  void *pCtx ){  int rc;  int eType = pExpr->eType;  if( eType!=FTSQUERY_PHRASE ){  assert( pExpr->pLeft && pExpr->pRight );  rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);  if( rc==SQLITE_OK && eType!=FTSQUERY_NOT ){  rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);  }  }else{  rc = x(pExpr, *piPhrase, pCtx);  (*piPhrase)++;  }  return rc; } static int fts3ExprIterate(  Fts3Expr *pExpr,  int (*x)(Fts3Expr*,int,void*),  void *pCtx ){  int iPhrase = 0;  return fts3ExprIterate2(pExpr, &iPhrase, x, pCtx); } static int fts3ExprLoadDoclistsCb(Fts3Expr *pExpr, int iPhrase, void *ctx){  int rc = SQLITE_OK;  Fts3Phrase *pPhrase = pExpr->pPhrase;  LoadDoclistCtx *p = (LoadDoclistCtx *)ctx;  UNUSED_PARAMETER(iPhrase);  p->nPhrase++;  p->nToken += pPhrase->nToken;  return rc; } static int fts3ExprLoadDoclists(  Fts3Cursor *pCsr,  int *pnPhrase,  int *pnToken ){  int rc;  LoadDoclistCtx sCtx = {0,0,0};  sCtx.pCsr = pCsr;  rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, (void *)&sCtx);  if( pnPhrase ) *pnPhrase = sCtx.nPhrase;  if( pnToken ) *pnToken = sCtx.nToken;  return rc; } static int fts3ExprPhraseCountCb(Fts3Expr *pExpr, int iPhrase, void *ctx){  (*(int *)ctx)++;  pExpr->iPhrase = iPhrase;  return SQLITE_OK; } static int fts3ExprPhraseCount(Fts3Expr *pExpr){  int nPhrase = 0;  (void)fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);  return nPhrase; } static void fts3SnippetAdvance(char **ppIter, i64 *piIter, int iNext){  char *pIter = *ppIter;  if( pIter ){  i64 iIter = *piIter;  while( iIter<iNext ){  if( 0==(*pIter & 0xFE) ){  iIter = -1;  pIter = 0;  break;  }  fts3GetDeltaPosition(&pIter, &iIter);  }  *piIter = iIter;  *ppIter = pIter;  } } static int fts3SnippetNextCandidate(SnippetIter *pIter){  int i;  if( pIter->iCurrent<0 ){  pIter->iCurrent = 0;  for(i=0; i<pIter->nPhrase; i++){  SnippetPhrase *pPhrase = &pIter->aPhrase[i];  fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, pIter->nSnippet);  }  }else{  int iStart;  int iEnd = 0x7FFFFFFF;  for(i=0; i<pIter->nPhrase; i++){  SnippetPhrase *pPhrase = &pIter->aPhrase[i];  if( pPhrase->pHead && pPhrase->iHead<iEnd ){  iEnd = pPhrase->iHead;  }  }  if( iEnd==0x7FFFFFFF ){  return 1;  }  pIter->iCurrent = iStart = iEnd - pIter->nSnippet + 1;  for(i=0; i<pIter->nPhrase; i++){  SnippetPhrase *pPhrase = &pIter->aPhrase[i];  fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);  fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);  }  }  return 0; } static void fts3SnippetDetails(  SnippetIter *pIter,  u64 mCovered,  int *piToken,  int *piScore,  u64 *pmCover,  u64 *pmHighlight ){  int iStart = pIter->iCurrent;  int iScore = 0;  int i;  u64 mCover = 0;  u64 mHighlight = 0;  for(i=0; i<pIter->nPhrase; i++){  SnippetPhrase *pPhrase = &pIter->aPhrase[i];  if( pPhrase->pTail ){  char *pCsr = pPhrase->pTail;  i64 iCsr = pPhrase->iTail;  while( iCsr<(iStart+pIter->nSnippet) && iCsr>=iStart ){  int j;  u64 mPhrase = (u64)1 << (i%64);  u64 mPos = (u64)1 << (iCsr - iStart);  assert( iCsr>=iStart && (iCsr - iStart)<=64 );  assert( i>=0 );  if( (mCover|mCovered)&mPhrase ){  iScore++;  }else{  iScore += 1000;  }  mCover |= mPhrase;  for(j=0; j<pPhrase->nToken; j++){  mHighlight |= (mPos>>j);  }  if( 0==(*pCsr & 0x0FE) ) break;  fts3GetDeltaPosition(&pCsr, &iCsr);  }  }  }  *piToken = iStart;  *piScore = iScore;  *pmCover = mCover;  *pmHighlight = mHighlight; } static int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx){  SnippetIter *p = (SnippetIter *)ctx;  SnippetPhrase *pPhrase = &p->aPhrase[iPhrase];  char *pCsr;  int rc;  pPhrase->nToken = pExpr->pPhrase->nToken;  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pCsr);  assert( rc==SQLITE_OK || pCsr==0 );  if( pCsr ){  i64 iFirst = 0;  pPhrase->pList = pCsr;  fts3GetDeltaPosition(&pCsr, &iFirst);  if( iFirst<0 ){  rc = FTS_CORRUPT_VTAB;  }else{  pPhrase->pHead = pCsr;  pPhrase->pTail = pCsr;  pPhrase->iHead = iFirst;  pPhrase->iTail = iFirst;  }  }else{  assert( rc!=SQLITE_OK || (   pPhrase->pList==0 && pPhrase->pHead==0 && pPhrase->pTail==0  ));  }  return rc; } static int fts3BestSnippet(  int nSnippet,  Fts3Cursor *pCsr,  int iCol,  u64 mCovered,  u64 *pmSeen,  SnippetFragment *pFragment,  int *piScore ){  int rc;  int nList;  SnippetIter sIter;  sqlite3_int64 nByte;  int iBestScore = -1;  int i;  memset(&sIter, 0, sizeof(sIter));  rc = fts3ExprLoadDoclists(pCsr, &nList, 0);  if( rc!=SQLITE_OK ){  return rc;  }  nByte = sizeof(SnippetPhrase) * nList;  sIter.aPhrase = (SnippetPhrase *)sqlite3Fts3MallocZero(nByte);  if( !sIter.aPhrase ){  return SQLITE_NOMEM;  }  sIter.pCsr = pCsr;  sIter.iCol = iCol;  sIter.nSnippet = nSnippet;  sIter.nPhrase = nList;  sIter.iCurrent = -1;  rc = fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void*)&sIter);  if( rc==SQLITE_OK ){  for(i=0; i<nList; i++){  if( sIter.aPhrase[i].pHead ){  *pmSeen |= (u64)1 << (i%64);  }  }  pFragment->iCol = iCol;  while( !fts3SnippetNextCandidate(&sIter) ){  int iPos;  int iScore;  u64 mCover;  u64 mHighlite;  fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover,&mHighlite);  assert( iScore>=0 );  if( iScore>iBestScore ){  pFragment->iPos = iPos;  pFragment->hlmask = mHighlite;  pFragment->covered = mCover;  iBestScore = iScore;  }  }  *piScore = iBestScore;  }  sqlite3_free(sIter.aPhrase);  return rc; } static int fts3StringAppend(  StrBuffer *pStr,  const char *zAppend,  int nAppend ){  if( nAppend<0 ){  nAppend = (int)strlen(zAppend);  }  if( pStr->n+nAppend+1>=pStr->nAlloc ){  sqlite3_int64 nAlloc = pStr->nAlloc+(sqlite3_int64)nAppend+100;  char *zNew = sqlite3_realloc64(pStr->z, nAlloc);  if( !zNew ){  return SQLITE_NOMEM;  }  pStr->z = zNew;  pStr->nAlloc = nAlloc;  }  assert( pStr->z!=0 && (pStr->nAlloc >= pStr->n+nAppend+1) );  memcpy(&pStr->z[pStr->n], zAppend, nAppend);  pStr->n += nAppend;  pStr->z[pStr->n] = '\0';  return SQLITE_OK; } static int fts3SnippetShift(  Fts3Table *pTab,  int iLangid,  int nSnippet,  const char *zDoc,  int nDoc,  int *piPos,  u64 *pHlmask ){  u64 hlmask = *pHlmask;  if( hlmask ){  int nLeft;  int nRight;  int nDesired;  for(nLeft=0; !(hlmask & ((u64)1 << nLeft)); nLeft++);  for(nRight=0; !(hlmask & ((u64)1 << (nSnippet-1-nRight))); nRight++);  assert( (nSnippet-1-nRight)<=63 && (nSnippet-1-nRight)>=0 );  nDesired = (nLeft-nRight)/2;  if( nDesired>0 ){  int nShift;  int iCurrent = 0;  int rc;  sqlite3_tokenizer_module *pMod;  sqlite3_tokenizer_cursor *pC;  pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;  rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, iLangid, zDoc, nDoc, &pC);  if( rc!=SQLITE_OK ){  return rc;  }  while( rc==SQLITE_OK && iCurrent<(nSnippet+nDesired) ){  const char *ZDUMMY; int DUMMY1 = 0, DUMMY2 = 0, DUMMY3 = 0;  rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &DUMMY2, &DUMMY3, &iCurrent);  }  pMod->xClose(pC);  if( rc!=SQLITE_OK && rc!=SQLITE_DONE ){ return rc; }  nShift = (rc==SQLITE_DONE)+iCurrent-nSnippet;  assert( nShift<=nDesired );  if( nShift>0 ){  *piPos += nShift;  *pHlmask = hlmask >> nShift;  }  }  }  return SQLITE_OK; } static int fts3SnippetText(  Fts3Cursor *pCsr,  SnippetFragment *pFragment,  int iFragment,  int isLast,  int nSnippet,  const char *zOpen,  const char *zClose,  const char *zEllipsis,  StrBuffer *pOut ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int rc;  const char *zDoc;  int nDoc;  int iCurrent = 0;  int iEnd = 0;  int isShiftDone = 0;  int iPos = pFragment->iPos;  u64 hlmask = pFragment->hlmask;  int iCol = pFragment->iCol+1;  sqlite3_tokenizer_module *pMod;  sqlite3_tokenizer_cursor *pC;  zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol);  if( zDoc==0 ){  if( sqlite3_column_type(pCsr->pStmt, iCol)!=SQLITE_NULL ){  return SQLITE_NOMEM;  }  return SQLITE_OK;  }  nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol);  pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;  rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid, zDoc,nDoc,&pC);  if( rc!=SQLITE_OK ){  return rc;  }  while( rc==SQLITE_OK ){  const char *ZDUMMY;  int DUMMY1 = -1;  int iBegin = 0;  int iFin = 0;  int isHighlight = 0;  rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &iBegin, &iFin, &iCurrent);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_DONE ){  rc = fts3StringAppend(pOut, &zDoc[iEnd], -1);  }  break;  }  if( iCurrent<iPos ){ continue; }  if( !isShiftDone ){  int n = nDoc - iBegin;  rc = fts3SnippetShift(  pTab, pCsr->iLangid, nSnippet, &zDoc[iBegin], n, &iPos, &hlmask  );  isShiftDone = 1;  if( rc==SQLITE_OK ){  if( iPos>0 || iFragment>0 ){  rc = fts3StringAppend(pOut, zEllipsis, -1);  }else if( iBegin ){  rc = fts3StringAppend(pOut, zDoc, iBegin);  }  }  if( rc!=SQLITE_OK || iCurrent<iPos ) continue;  }  if( iCurrent>=(iPos+nSnippet) ){  if( isLast ){  rc = fts3StringAppend(pOut, zEllipsis, -1);  }  break;  }  isHighlight = (hlmask & ((u64)1 << (iCurrent-iPos)))!=0;  if( iCurrent>iPos ) rc = fts3StringAppend(pOut, &zDoc[iEnd], iBegin-iEnd);  if( rc==SQLITE_OK && isHighlight ) rc = fts3StringAppend(pOut, zOpen, -1);  if( rc==SQLITE_OK ) rc = fts3StringAppend(pOut, &zDoc[iBegin], iFin-iBegin);  if( rc==SQLITE_OK && isHighlight ) rc = fts3StringAppend(pOut, zClose, -1);  iEnd = iFin;  }  pMod->xClose(pC);  return rc; } static int fts3ColumnlistCount(char **ppCollist){  char *pEnd = *ppCollist;  char c = 0;  int nEntry = 0;  while( 0xFE & (*pEnd | c) ){  c = *pEnd++ & 0x80;  if( !c ) nEntry++;  }  *ppCollist = pEnd;  return nEntry; } static int fts3ExprLHits(  Fts3Expr *pExpr,  MatchInfo *p ){  Fts3Table *pTab = (Fts3Table *)p->pCursor->base.pVtab;  int iStart;  Fts3Phrase *pPhrase = pExpr->pPhrase;  char *pIter = pPhrase->doclist.pList;  int iCol = 0;  assert( p->flag==FTS3_MATCHINFO_LHITS_BM || p->flag==FTS3_MATCHINFO_LHITS );  if( p->flag==FTS3_MATCHINFO_LHITS ){  iStart = pExpr->iPhrase * p->nCol;  }else{  iStart = pExpr->iPhrase * ((p->nCol + 31) / 32);  }  if( pIter ) while( 1 ){  int nHit = fts3ColumnlistCount(&pIter);  if( (pPhrase->iColumn>=pTab->nColumn || pPhrase->iColumn==iCol) ){  if( p->flag==FTS3_MATCHINFO_LHITS ){  p->aMatchinfo[iStart + iCol] = (u32)nHit;  }else if( nHit ){  p->aMatchinfo[iStart + (iCol+1)/32] |= (1 << (iCol&0x1F));  }  }  assert( *pIter==0x00 || *pIter==0x01 );  if( *pIter!=0x01 ) break;  pIter++;  pIter += fts3GetVarint32(pIter, &iCol);  if( iCol>=p->nCol ) return FTS_CORRUPT_VTAB;  }  return SQLITE_OK; } static int fts3ExprLHitGather(  Fts3Expr *pExpr,  MatchInfo *p ){  int rc = SQLITE_OK;  assert( (pExpr->pLeft==0)==(pExpr->pRight==0) );  if( pExpr->bEof==0 && pExpr->iDocid==p->pCursor->iPrevId ){  if( pExpr->pLeft ){  rc = fts3ExprLHitGather(pExpr->pLeft, p);  if( rc==SQLITE_OK ) rc = fts3ExprLHitGather(pExpr->pRight, p);  }else{  rc = fts3ExprLHits(pExpr, p);  }  }  return rc; } static int fts3ExprGlobalHitsCb(  Fts3Expr *pExpr,  int iPhrase,  void *pCtx ){  MatchInfo *p = (MatchInfo *)pCtx;  return sqlite3Fts3EvalPhraseStats(  p->pCursor, pExpr, &p->aMatchinfo[3*iPhrase*p->nCol]  ); } static int fts3ExprLocalHitsCb(  Fts3Expr *pExpr,  int iPhrase,  void *pCtx ){  int rc = SQLITE_OK;  MatchInfo *p = (MatchInfo *)pCtx;  int iStart = iPhrase * p->nCol * 3;  int i;  for(i=0; i<p->nCol && rc==SQLITE_OK; i++){  char *pCsr;  rc = sqlite3Fts3EvalPhrasePoslist(p->pCursor, pExpr, i, &pCsr);  if( pCsr ){  p->aMatchinfo[iStart+i*3] = fts3ColumnlistCount(&pCsr);  }else{  p->aMatchinfo[iStart+i*3] = 0;  }  }  return rc; } static int fts3MatchinfoCheck(  Fts3Table *pTab,  char cArg,  char **pzErr ){  if( (cArg==FTS3_MATCHINFO_NPHRASE)   || (cArg==FTS3_MATCHINFO_NCOL)   || (cArg==FTS3_MATCHINFO_NDOC && pTab->bFts4)   || (cArg==FTS3_MATCHINFO_AVGLENGTH && pTab->bFts4)   || (cArg==FTS3_MATCHINFO_LENGTH && pTab->bHasDocsize)   || (cArg==FTS3_MATCHINFO_LCS)   || (cArg==FTS3_MATCHINFO_HITS)   || (cArg==FTS3_MATCHINFO_LHITS)   || (cArg==FTS3_MATCHINFO_LHITS_BM)  ){  return SQLITE_OK;  }  sqlite3Fts3ErrMsg(pzErr, "unrecognized matchinfo request: %c", cArg);  return SQLITE_ERROR; } static size_t fts3MatchinfoSize(MatchInfo *pInfo, char cArg){  size_t nVal;  switch( cArg ){  case FTS3_MATCHINFO_NDOC:  case FTS3_MATCHINFO_NPHRASE:  case FTS3_MATCHINFO_NCOL:  nVal = 1;  break;  case FTS3_MATCHINFO_AVGLENGTH:  case FTS3_MATCHINFO_LENGTH:  case FTS3_MATCHINFO_LCS:  nVal = pInfo->nCol;  break;  case FTS3_MATCHINFO_LHITS:  nVal = pInfo->nCol * pInfo->nPhrase;  break;  case FTS3_MATCHINFO_LHITS_BM:  nVal = pInfo->nPhrase * ((pInfo->nCol + 31) / 32);  break;  default:  assert( cArg==FTS3_MATCHINFO_HITS );  nVal = pInfo->nCol * pInfo->nPhrase * 3;  break;  }  return nVal; } static int fts3MatchinfoSelectDoctotal(  Fts3Table *pTab,  sqlite3_stmt **ppStmt,  sqlite3_int64 *pnDoc,  const char **paLen,  const char **ppEnd ){  sqlite3_stmt *pStmt;  const char *a;  const char *pEnd;  sqlite3_int64 nDoc;  int n;  if( !*ppStmt ){  int rc = sqlite3Fts3SelectDoctotal(pTab, ppStmt);  if( rc!=SQLITE_OK ) return rc;  }  pStmt = *ppStmt;  assert( sqlite3_data_count(pStmt)==1 );  n = sqlite3_column_bytes(pStmt, 0);  a = sqlite3_column_blob(pStmt, 0);  if( a==0 ){  return FTS_CORRUPT_VTAB;  }  pEnd = a + n;  a += sqlite3Fts3GetVarintBounded(a, pEnd, &nDoc);  if( nDoc<=0 || a>pEnd ){  return FTS_CORRUPT_VTAB;  }  *pnDoc = nDoc;  if( paLen ) *paLen = a;  if( ppEnd ) *ppEnd = pEnd;  return SQLITE_OK; } typedef struct LcsIterator LcsIterator; struct LcsIterator {  Fts3Expr *pExpr;  int iPosOffset;  char *pRead;  int iPos; };
#define LCS_ITERATOR_FINISHED 0x7FFFFFFF;
static int fts3MatchinfoLcsCb(  Fts3Expr *pExpr,  int iPhrase,  void *pCtx ){  LcsIterator *aIter = (LcsIterator *)pCtx;  aIter[iPhrase].pExpr = pExpr;  return SQLITE_OK; } static int fts3LcsIteratorAdvance(LcsIterator *pIter){  char *pRead;  sqlite3_int64 iRead;  int rc = 0;  if( NEVER(pIter==0) ) return 1;  pRead = pIter->pRead;  pRead += sqlite3Fts3GetVarint(pRead, &iRead);  if( iRead==0 || iRead==1 ){  pRead = 0;  rc = 1;  }else{  pIter->iPos += (int)(iRead-2);  }  pIter->pRead = pRead;  return rc; } static int fts3MatchinfoLcs(Fts3Cursor *pCsr, MatchInfo *pInfo){  LcsIterator *aIter;  int i;  int iCol;  int nToken = 0;  int rc = SQLITE_OK;  aIter = sqlite3Fts3MallocZero(sizeof(LcsIterator) * pCsr->nPhrase);  if( !aIter ) return SQLITE_NOMEM;  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);  for(i=0; i<pInfo->nPhrase; i++){  LcsIterator *pIter = &aIter[i];  nToken -= pIter->pExpr->pPhrase->nToken;  pIter->iPosOffset = nToken;  }  for(iCol=0; iCol<pInfo->nCol; iCol++){  int nLcs = 0;  int nLive = 0;  for(i=0; i<pInfo->nPhrase; i++){  LcsIterator *pIt = &aIter[i];  rc = sqlite3Fts3EvalPhrasePoslist(pCsr, pIt->pExpr, iCol, &pIt->pRead);  if( rc!=SQLITE_OK ) goto matchinfo_lcs_out;  if( pIt->pRead ){  pIt->iPos = pIt->iPosOffset;  fts3LcsIteratorAdvance(pIt);  if( pIt->pRead==0 ){  rc = FTS_CORRUPT_VTAB;  goto matchinfo_lcs_out;  }  nLive++;  }  }  while( nLive>0 ){  LcsIterator *pAdv = 0;  int nThisLcs = 0;  for(i=0; i<pInfo->nPhrase; i++){  LcsIterator *pIter = &aIter[i];  if( pIter->pRead==0 ){  nThisLcs = 0;  }else{  if( pAdv==0 || pIter->iPos<pAdv->iPos ){  pAdv = pIter;  }  if( nThisLcs==0 || pIter->iPos==pIter[-1].iPos ){  nThisLcs++;  }else{  nThisLcs = 1;  }  if( nThisLcs>nLcs ) nLcs = nThisLcs;  }  }  if( fts3LcsIteratorAdvance(pAdv) ) nLive--;  }  pInfo->aMatchinfo[iCol] = nLcs;  }  matchinfo_lcs_out:  sqlite3_free(aIter);  return rc; } static int fts3MatchinfoValues(  Fts3Cursor *pCsr,  int bGlobal,  MatchInfo *pInfo,  const char *zArg ){  int rc = SQLITE_OK;  int i;  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  sqlite3_stmt *pSelect = 0;  for(i=0; rc==SQLITE_OK && zArg[i]; i++){  pInfo->flag = zArg[i];  switch( zArg[i] ){  case FTS3_MATCHINFO_NPHRASE:  if( bGlobal ) pInfo->aMatchinfo[0] = pInfo->nPhrase;  break;  case FTS3_MATCHINFO_NCOL:  if( bGlobal ) pInfo->aMatchinfo[0] = pInfo->nCol;  break;  case FTS3_MATCHINFO_NDOC:  if( bGlobal ){  sqlite3_int64 nDoc = 0;  rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, 0, 0);  pInfo->aMatchinfo[0] = (u32)nDoc;  }  break;  case FTS3_MATCHINFO_AVGLENGTH:  if( bGlobal ){  sqlite3_int64 nDoc;  const char *a;  const char *pEnd;  rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, &a, &pEnd);  if( rc==SQLITE_OK ){  int iCol;  for(iCol=0; iCol<pInfo->nCol; iCol++){  u32 iVal;  sqlite3_int64 nToken;  a += sqlite3Fts3GetVarint(a, &nToken);  if( a>pEnd ){  rc = SQLITE_CORRUPT_VTAB;  break;  }  iVal = (u32)(((u32)(nToken&0xffffffff)+nDoc/2)/nDoc);  pInfo->aMatchinfo[iCol] = iVal;  }  }  }  break;  case FTS3_MATCHINFO_LENGTH: {  sqlite3_stmt *pSelectDocsize = 0;  rc = sqlite3Fts3SelectDocsize(pTab, pCsr->iPrevId, &pSelectDocsize);  if( rc==SQLITE_OK ){  int iCol;  const char *a = sqlite3_column_blob(pSelectDocsize, 0);  const char *pEnd = a + sqlite3_column_bytes(pSelectDocsize, 0);  for(iCol=0; iCol<pInfo->nCol; iCol++){  sqlite3_int64 nToken;  a += sqlite3Fts3GetVarintBounded(a, pEnd, &nToken);  if( a>pEnd ){  rc = SQLITE_CORRUPT_VTAB;  break;  }  pInfo->aMatchinfo[iCol] = (u32)nToken;  }  }  sqlite3_reset(pSelectDocsize);  break;  }  case FTS3_MATCHINFO_LCS:  rc = fts3ExprLoadDoclists(pCsr, 0, 0);  if( rc==SQLITE_OK ){  rc = fts3MatchinfoLcs(pCsr, pInfo);  }  break;  case FTS3_MATCHINFO_LHITS_BM:  case FTS3_MATCHINFO_LHITS: {  size_t nZero = fts3MatchinfoSize(pInfo, zArg[i]) * sizeof(u32);  memset(pInfo->aMatchinfo, 0, nZero);  rc = fts3ExprLHitGather(pCsr->pExpr, pInfo);  break;  }  default: {  Fts3Expr *pExpr;  assert( zArg[i]==FTS3_MATCHINFO_HITS );  pExpr = pCsr->pExpr;  rc = fts3ExprLoadDoclists(pCsr, 0, 0);  if( rc!=SQLITE_OK ) break;  if( bGlobal ){  if( pCsr->pDeferred ){  rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &pInfo->nDoc,0,0);  if( rc!=SQLITE_OK ) break;  }  rc = fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb,(void*)pInfo);  sqlite3Fts3EvalTestDeferred(pCsr, &rc);  if( rc!=SQLITE_OK ) break;  }  (void)fts3ExprIterate(pExpr, fts3ExprLocalHitsCb,(void*)pInfo);  break;  }  }  pInfo->aMatchinfo += fts3MatchinfoSize(pInfo, zArg[i]);  }  sqlite3_reset(pSelect);  return rc; } static void fts3GetMatchinfo(  sqlite3_context *pCtx,  Fts3Cursor *pCsr,  const char *zArg ){  MatchInfo sInfo;  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int rc = SQLITE_OK;  int bGlobal = 0;  u32 *aOut = 0;  void (*xDestroyOut)(void*) = 0;  memset(&sInfo, 0, sizeof(MatchInfo));  sInfo.pCursor = pCsr;  sInfo.nCol = pTab->nColumn;  if( pCsr->pMIBuffer && strcmp(pCsr->pMIBuffer->zMatchinfo, zArg) ){  sqlite3Fts3MIBufferFree(pCsr->pMIBuffer);  pCsr->pMIBuffer = 0;  }  if( pCsr->pMIBuffer==0 ){  size_t nMatchinfo = 0;  int i;  pCsr->nPhrase = fts3ExprPhraseCount(pCsr->pExpr);  sInfo.nPhrase = pCsr->nPhrase;  for(i=0; zArg[i]; i++){  char *zErr = 0;  if( fts3MatchinfoCheck(pTab, zArg[i], &zErr) ){  sqlite3_result_error(pCtx, zErr, -1);  sqlite3_free(zErr);  return;  }  nMatchinfo += fts3MatchinfoSize(&sInfo, zArg[i]);  }  pCsr->pMIBuffer = fts3MIBufferNew(nMatchinfo, zArg);  if( !pCsr->pMIBuffer ) rc = SQLITE_NOMEM;  pCsr->isMatchinfoNeeded = 1;  bGlobal = 1;  }  if( rc==SQLITE_OK ){  xDestroyOut = fts3MIBufferAlloc(pCsr->pMIBuffer, &aOut);  if( xDestroyOut==0 ){  rc = SQLITE_NOMEM;  }  }  if( rc==SQLITE_OK ){  sInfo.aMatchinfo = aOut;  sInfo.nPhrase = pCsr->nPhrase;  rc = fts3MatchinfoValues(pCsr, bGlobal, &sInfo, zArg);  if( bGlobal ){  fts3MIBufferSetGlobal(pCsr->pMIBuffer);  }  }  if( rc!=SQLITE_OK ){  sqlite3_result_error_code(pCtx, rc);  if( xDestroyOut ) xDestroyOut(aOut);  }else{  int n = pCsr->pMIBuffer->nElem * sizeof(u32);  sqlite3_result_blob(pCtx, aOut, n, xDestroyOut);  } } SQLITE_PRIVATE void sqlite3Fts3Snippet(  sqlite3_context *pCtx,  Fts3Cursor *pCsr,  const char *zStart,  const char *zEnd,  const char *zEllipsis,  int iCol,  int nToken ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  int rc = SQLITE_OK;  int i;  StrBuffer res = {0, 0, 0};  int nSnippet = 0;  SnippetFragment aSnippet[4];  int nFToken = -1;  if( !pCsr->pExpr ){  sqlite3_result_text(pCtx, "", 0, SQLITE_STATIC);  return;  }  if( nToken<-64 ) nToken = -64;  if( nToken>+64 ) nToken = +64;  for(nSnippet=1; 1; nSnippet++){  int iSnip;  u64 mCovered = 0;  u64 mSeen = 0;  if( nToken>=0 ){  nFToken = (nToken+nSnippet-1) / nSnippet;  }else{  nFToken = -1 * nToken;  }  for(iSnip=0; iSnip<nSnippet; iSnip++){  int iBestScore = -1;  int iRead;  SnippetFragment *pFragment = &aSnippet[iSnip];  memset(pFragment, 0, sizeof(*pFragment));  for(iRead=0; iRead<pTab->nColumn; iRead++){  SnippetFragment sF = {0, 0, 0, 0};  int iS = 0;  if( iCol>=0 && iRead!=iCol ) continue;  rc = fts3BestSnippet(nFToken, pCsr, iRead, mCovered, &mSeen, &sF, &iS);  if( rc!=SQLITE_OK ){  goto snippet_out;  }  if( iS>iBestScore ){  *pFragment = sF;  iBestScore = iS;  }  }  mCovered |= pFragment->covered;  }  assert( (mCovered&mSeen)==mCovered );  if( mSeen==mCovered || nSnippet==SizeofArray(aSnippet) ) break;  }  assert( nFToken>0 );  for(i=0; i<nSnippet && rc==SQLITE_OK; i++){  rc = fts3SnippetText(pCsr, &aSnippet[i],  i, (i==nSnippet-1), nFToken, zStart, zEnd, zEllipsis, &res  );  }  snippet_out:  sqlite3Fts3SegmentsClose(pTab);  if( rc!=SQLITE_OK ){  sqlite3_result_error_code(pCtx, rc);  sqlite3_free(res.z);  }else{  sqlite3_result_text(pCtx, res.z, -1, sqlite3_free);  } } typedef struct TermOffset TermOffset; typedef struct TermOffsetCtx TermOffsetCtx; struct TermOffset {  char *pList;  i64 iPos;  i64 iOff; }; struct TermOffsetCtx {  Fts3Cursor *pCsr;  int iCol;  int iTerm;  sqlite3_int64 iDocid;  TermOffset *aTerm; }; static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){  TermOffsetCtx *p = (TermOffsetCtx *)ctx;  int nTerm;  int iTerm;  char *pList;  i64 iPos = 0;  int rc;  UNUSED_PARAMETER(iPhrase);  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pList);  nTerm = pExpr->pPhrase->nToken;  if( pList ){  fts3GetDeltaPosition(&pList, &iPos);  assert_fts3_nc( iPos>=0 );  }  for(iTerm=0; iTerm<nTerm; iTerm++){  TermOffset *pT = &p->aTerm[p->iTerm++];  pT->iOff = nTerm-iTerm-1;  pT->pList = pList;  pT->iPos = iPos;  }  return rc; } SQLITE_PRIVATE void sqlite3Fts3Offsets(  sqlite3_context *pCtx,  Fts3Cursor *pCsr ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  sqlite3_tokenizer_module const *pMod = pTab->pTokenizer->pModule;  int rc;  int nToken;  int iCol;  StrBuffer res = {0, 0, 0};  TermOffsetCtx sCtx;  if( !pCsr->pExpr ){  sqlite3_result_text(pCtx, "", 0, SQLITE_STATIC);  return;  }  memset(&sCtx, 0, sizeof(sCtx));  assert( pCsr->isRequireSeek==0 );  rc = fts3ExprLoadDoclists(pCsr, 0, &nToken);  if( rc!=SQLITE_OK ) goto offsets_out;  sCtx.aTerm = (TermOffset *)sqlite3Fts3MallocZero(sizeof(TermOffset)*nToken);  if( 0==sCtx.aTerm ){  rc = SQLITE_NOMEM;  goto offsets_out;  }  sCtx.iDocid = pCsr->iPrevId;  sCtx.pCsr = pCsr;  for(iCol=0; iCol<pTab->nColumn; iCol++){  sqlite3_tokenizer_cursor *pC;  const char *ZDUMMY;  int NDUMMY = 0;  int iStart = 0;  int iEnd = 0;  int iCurrent = 0;  const char *zDoc;  int nDoc;  sCtx.iCol = iCol;  sCtx.iTerm = 0;  rc = fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx);  if( rc!=SQLITE_OK ) goto offsets_out;  zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol+1);  nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol+1);  if( zDoc==0 ){  if( sqlite3_column_type(pCsr->pStmt, iCol+1)==SQLITE_NULL ){  continue;  }  rc = SQLITE_NOMEM;  goto offsets_out;  }  rc = sqlite3Fts3OpenTokenizer(pTab->pTokenizer, pCsr->iLangid,  zDoc, nDoc, &pC  );  if( rc!=SQLITE_OK ) goto offsets_out;  rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);  while( rc==SQLITE_OK ){  int i;  int iMinPos = 0x7FFFFFFF;  TermOffset *pTerm = 0;  for(i=0; i<nToken; i++){  TermOffset *pT = &sCtx.aTerm[i];  if( pT->pList && (pT->iPos-pT->iOff)<iMinPos ){  iMinPos = pT->iPos-pT->iOff;  pTerm = pT;  }  }  if( !pTerm ){  rc = SQLITE_DONE;  }else{  assert_fts3_nc( iCurrent<=iMinPos );  if( 0==(0xFE&*pTerm->pList) ){  pTerm->pList = 0;  }else{  fts3GetDeltaPosition(&pTerm->pList, &pTerm->iPos);  }  while( rc==SQLITE_OK && iCurrent<iMinPos ){  rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);  }  if( rc==SQLITE_OK ){  char aBuffer[64];  sqlite3_snprintf(sizeof(aBuffer), aBuffer,  "%d %d %d %d ", iCol, pTerm-sCtx.aTerm, iStart, iEnd-iStart  );  rc = fts3StringAppend(&res, aBuffer, -1);  }else if( rc==SQLITE_DONE && pTab->zContentTbl==0 ){  rc = FTS_CORRUPT_VTAB;  }  }  }  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  }  pMod->xClose(pC);  if( rc!=SQLITE_OK ) goto offsets_out;  }  offsets_out:  sqlite3_free(sCtx.aTerm);  assert( rc!=SQLITE_DONE );  sqlite3Fts3SegmentsClose(pTab);  if( rc!=SQLITE_OK ){  sqlite3_result_error_code(pCtx, rc);  sqlite3_free(res.z);  }else{  sqlite3_result_text(pCtx, res.z, res.n-1, sqlite3_free);  }  return; } SQLITE_PRIVATE void sqlite3Fts3Matchinfo(  sqlite3_context *pContext,  Fts3Cursor *pCsr,  const char *zArg ){  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;  const char *zFormat;  if( zArg ){  zFormat = zArg;  }else{  zFormat = FTS3_MATCHINFO_DEFAULT;  }  if( !pCsr->pExpr ){  sqlite3_result_blob(pContext, "", 0, SQLITE_STATIC);  return;  }else{  fts3GetMatchinfo(pContext, pCsr, zFormat);  sqlite3Fts3SegmentsClose(pTab);  } }
#endif
#ifndef SQLITE_DISABLE_FTS3_UNICODE
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#ifndef SQLITE_AMALGAMATION
static const unsigned char sqlite3Utf8Trans1[] = {  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, };
#define READ_UTF8(zIn, zTerm, c)   c = *(zIn++);  if( c>=0xc0 ){   c = sqlite3Utf8Trans1[c-0xc0];   while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){  c = (c<<6) + (0x3f & *(zIn++));  }  if( c<0x80   || (c&0xFFFFF800)==0xD800  || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }  }

#define WRITE_UTF8(zOut, c) {  if( c<0x00080 ){   *zOut++ = (u8)(c&0xFF);  }  else if( c<0x00800 ){  *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);  *zOut++ = 0x80 + (u8)(c & 0x3F);   }  else if( c<0x10000 ){  *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);   *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);  *zOut++ = 0x80 + (u8)(c & 0x3F);   }else{   *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);   *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);   *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);  *zOut++ = 0x80 + (u8)(c & 0x3F);   } }

#endif
typedef struct unicode_tokenizer unicode_tokenizer; typedef struct unicode_cursor unicode_cursor; struct unicode_tokenizer {  sqlite3_tokenizer base;  int eRemoveDiacritic;  int nException;  int *aiException; }; struct unicode_cursor {  sqlite3_tokenizer_cursor base;  const unsigned char *aInput;  int nInput;  int iOff;  int iToken;  char *zToken;  int nAlloc; }; static int unicodeDestroy(sqlite3_tokenizer *pTokenizer){  if( pTokenizer ){  unicode_tokenizer *p = (unicode_tokenizer *)pTokenizer;  sqlite3_free(p->aiException);  sqlite3_free(p);  }  return SQLITE_OK; } static int unicodeAddExceptions(  unicode_tokenizer *p,  int bAlnum,  const char *zIn,  int nIn ){  const unsigned char *z = (const unsigned char *)zIn;  const unsigned char *zTerm = &z[nIn];  unsigned int iCode;  int nEntry = 0;  assert( bAlnum==0 || bAlnum==1 );  while( z<zTerm ){  READ_UTF8(z, zTerm, iCode);  assert( (sqlite3FtsUnicodeIsalnum((int)iCode) & 0xFFFFFFFE)==0 );  if( sqlite3FtsUnicodeIsalnum((int)iCode)!=bAlnum   && sqlite3FtsUnicodeIsdiacritic((int)iCode)==0  ){  nEntry++;  }  }  if( nEntry ){  int *aNew;  int nNew;  aNew = sqlite3_realloc64(p->aiException,(p->nException+nEntry)*sizeof(int));  if( aNew==0 ) return SQLITE_NOMEM;  nNew = p->nException;  z = (const unsigned char *)zIn;  while( z<zTerm ){  READ_UTF8(z, zTerm, iCode);  if( sqlite3FtsUnicodeIsalnum((int)iCode)!=bAlnum   && sqlite3FtsUnicodeIsdiacritic((int)iCode)==0  ){  int i, j;  for(i=0; i<nNew && aNew[i]<(int)iCode; i++);  for(j=nNew; j>i; j--) aNew[j] = aNew[j-1];  aNew[i] = (int)iCode;  nNew++;  }  }  p->aiException = aNew;  p->nException = nNew;  }  return SQLITE_OK; } static int unicodeIsException(unicode_tokenizer *p, int iCode){  if( p->nException>0 ){  int *a = p->aiException;  int iLo = 0;  int iHi = p->nException-1;  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  if( iCode==a[iTest] ){  return 1;  }else if( iCode>a[iTest] ){  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  }  return 0; } static int unicodeIsAlnum(unicode_tokenizer *p, int iCode){  assert( (sqlite3FtsUnicodeIsalnum(iCode) & 0xFFFFFFFE)==0 );  return sqlite3FtsUnicodeIsalnum(iCode) ^ unicodeIsException(p, iCode); } static int unicodeCreate(  int nArg,  const char * const *azArg,  sqlite3_tokenizer **pp ){  unicode_tokenizer *pNew;  int i;  int rc = SQLITE_OK;  pNew = (unicode_tokenizer *) sqlite3_malloc(sizeof(unicode_tokenizer));  if( pNew==NULL ) return SQLITE_NOMEM;  memset(pNew, 0, sizeof(unicode_tokenizer));  pNew->eRemoveDiacritic = 1;  for(i=0; rc==SQLITE_OK && i<nArg; i++){  const char *z = azArg[i];  int n = (int)strlen(z);  if( n==19 && memcmp("remove_diacritics=1", z, 19)==0 ){  pNew->eRemoveDiacritic = 1;  }  else if( n==19 && memcmp("remove_diacritics=0", z, 19)==0 ){  pNew->eRemoveDiacritic = 0;  }  else if( n==19 && memcmp("remove_diacritics=2", z, 19)==0 ){  pNew->eRemoveDiacritic = 2;  }  else if( n>=11 && memcmp("tokenchars=", z, 11)==0 ){  rc = unicodeAddExceptions(pNew, 1, &z[11], n-11);  }  else if( n>=11 && memcmp("separators=", z, 11)==0 ){  rc = unicodeAddExceptions(pNew, 0, &z[11], n-11);  }  else{  rc = SQLITE_ERROR;  }  }  if( rc!=SQLITE_OK ){  unicodeDestroy((sqlite3_tokenizer *)pNew);  pNew = 0;  }  *pp = (sqlite3_tokenizer *)pNew;  return rc; } static int unicodeOpen(  sqlite3_tokenizer *p,  const char *aInput,  int nInput,  sqlite3_tokenizer_cursor **pp ){  unicode_cursor *pCsr;  pCsr = (unicode_cursor *)sqlite3_malloc(sizeof(unicode_cursor));  if( pCsr==0 ){  return SQLITE_NOMEM;  }  memset(pCsr, 0, sizeof(unicode_cursor));  pCsr->aInput = (const unsigned char *)aInput;  if( aInput==0 ){  pCsr->nInput = 0;  pCsr->aInput = (const unsigned char*)"";  }else if( nInput<0 ){  pCsr->nInput = (int)strlen(aInput);  }else{  pCsr->nInput = nInput;  }  *pp = &pCsr->base;  UNUSED_PARAMETER(p);  return SQLITE_OK; } static int unicodeClose(sqlite3_tokenizer_cursor *pCursor){  unicode_cursor *pCsr = (unicode_cursor *) pCursor;  sqlite3_free(pCsr->zToken);  sqlite3_free(pCsr);  return SQLITE_OK; } static int unicodeNext(  sqlite3_tokenizer_cursor *pC,  const char **paToken,  int *pnToken,  int *piStart,  int *piEnd,  int *piPos ){  unicode_cursor *pCsr = (unicode_cursor *)pC;  unicode_tokenizer *p = ((unicode_tokenizer *)pCsr->base.pTokenizer);  unsigned int iCode = 0;  char *zOut;  const unsigned char *z = &pCsr->aInput[pCsr->iOff];  const unsigned char *zStart = z;  const unsigned char *zEnd;  const unsigned char *zTerm = &pCsr->aInput[pCsr->nInput];  while( z<zTerm ){  READ_UTF8(z, zTerm, iCode);  if( unicodeIsAlnum(p, (int)iCode) ) break;  zStart = z;  }  if( zStart>=zTerm ) return SQLITE_DONE;  zOut = pCsr->zToken;  do {  int iOut;  if( (zOut-pCsr->zToken)>=(pCsr->nAlloc-4) ){  char *zNew = sqlite3_realloc64(pCsr->zToken, pCsr->nAlloc+64);  if( !zNew ) return SQLITE_NOMEM;  zOut = &zNew[zOut - pCsr->zToken];  pCsr->zToken = zNew;  pCsr->nAlloc += 64;  }  zEnd = z;  iOut = sqlite3FtsUnicodeFold((int)iCode, p->eRemoveDiacritic);  if( iOut ){  WRITE_UTF8(zOut, iOut);  }  if( z>=zTerm ) break;  READ_UTF8(z, zTerm, iCode);  }while( unicodeIsAlnum(p, (int)iCode)   || sqlite3FtsUnicodeIsdiacritic((int)iCode)  );  pCsr->iOff = (int)(z - pCsr->aInput);  *paToken = pCsr->zToken;  *pnToken = (int)(zOut - pCsr->zToken);  *piStart = (int)(zStart - pCsr->aInput);  *piEnd = (int)(zEnd - pCsr->aInput);  *piPos = pCsr->iToken++;  return SQLITE_OK; } SQLITE_PRIVATE void sqlite3Fts3UnicodeTokenizer(sqlite3_tokenizer_module const **ppModule){  static const sqlite3_tokenizer_module module = {  0,  unicodeCreate,  unicodeDestroy,  unicodeOpen,  unicodeClose,  unicodeNext,  0,  };  *ppModule = &module; }
#endif
#endif
#ifndef SQLITE_DISABLE_FTS3_UNICODE
#if defined(SQLITE_ENABLE_FTS3) || defined(SQLITE_ENABLE_FTS4)
SQLITE_PRIVATE int sqlite3FtsUnicodeIsalnum(int c){  static const unsigned int aEntry[] = {  0x00000030, 0x0000E807, 0x00016C06, 0x0001EC2F, 0x0002AC07,  0x0002D001, 0x0002D803, 0x0002EC01, 0x0002FC01, 0x00035C01,  0x0003DC01, 0x000B0804, 0x000B480E, 0x000B9407, 0x000BB401,  0x000BBC81, 0x000DD401, 0x000DF801, 0x000E1002, 0x000E1C01,  0x000FD801, 0x00120808, 0x00156806, 0x00162402, 0x00163C01,  0x00164437, 0x0017CC02, 0x00180005, 0x00181816, 0x00187802,  0x00192C15, 0x0019A804, 0x0019C001, 0x001B5001, 0x001B580F,  0x001B9C07, 0x001BF402, 0x001C000E, 0x001C3C01, 0x001C4401,  0x001CC01B, 0x001E980B, 0x001FAC09, 0x001FD804, 0x00205804,  0x00206C09, 0x00209403, 0x0020A405, 0x0020C00F, 0x00216403,  0x00217801, 0x0023901B, 0x00240004, 0x0024E803, 0x0024F812,  0x00254407, 0x00258804, 0x0025C001, 0x00260403, 0x0026F001,  0x0026F807, 0x00271C02, 0x00272C03, 0x00275C01, 0x00278802,  0x0027C802, 0x0027E802, 0x00280403, 0x0028F001, 0x0028F805,  0x00291C02, 0x00292C03, 0x00294401, 0x0029C002, 0x0029D401,  0x002A0403, 0x002AF001, 0x002AF808, 0x002B1C03, 0x002B2C03,  0x002B8802, 0x002BC002, 0x002C0403, 0x002CF001, 0x002CF807,  0x002D1C02, 0x002D2C03, 0x002D5802, 0x002D8802, 0x002DC001,  0x002E0801, 0x002EF805, 0x002F1803, 0x002F2804, 0x002F5C01,  0x002FCC08, 0x00300403, 0x0030F807, 0x00311803, 0x00312804,  0x00315402, 0x00318802, 0x0031FC01, 0x00320802, 0x0032F001,  0x0032F807, 0x00331803, 0x00332804, 0x00335402, 0x00338802,  0x00340802, 0x0034F807, 0x00351803, 0x00352804, 0x00355C01,  0x00358802, 0x0035E401, 0x00360802, 0x00372801, 0x00373C06,  0x00375801, 0x00376008, 0x0037C803, 0x0038C401, 0x0038D007,  0x0038FC01, 0x00391C09, 0x00396802, 0x003AC401, 0x003AD006,  0x003AEC02, 0x003B2006, 0x003C041F, 0x003CD00C, 0x003DC417,  0x003E340B, 0x003E6424, 0x003EF80F, 0x003F380D, 0x0040AC14,  0x00412806, 0x00415804, 0x00417803, 0x00418803, 0x00419C07,  0x0041C404, 0x0042080C, 0x00423C01, 0x00426806, 0x0043EC01,  0x004D740C, 0x004E400A, 0x00500001, 0x0059B402, 0x005A0001,  0x005A6C02, 0x005BAC03, 0x005C4803, 0x005CC805, 0x005D4802,  0x005DC802, 0x005ED023, 0x005F6004, 0x005F7401, 0x0060000F,  0x0062A401, 0x0064800C, 0x0064C00C, 0x00650001, 0x00651002,  0x0066C011, 0x00672002, 0x00677822, 0x00685C05, 0x00687802,  0x0069540A, 0x0069801D, 0x0069FC01, 0x006A8007, 0x006AA006,  0x006C0005, 0x006CD011, 0x006D6823, 0x006E0003, 0x006E840D,  0x006F980E, 0x006FF004, 0x00709014, 0x0070EC05, 0x0071F802,  0x00730008, 0x00734019, 0x0073B401, 0x0073C803, 0x00770027,  0x0077F004, 0x007EF401, 0x007EFC03, 0x007F3403, 0x007F7403,  0x007FB403, 0x007FF402, 0x00800065, 0x0081A806, 0x0081E805,  0x00822805, 0x0082801A, 0x00834021, 0x00840002, 0x00840C04,  0x00842002, 0x00845001, 0x00845803, 0x00847806, 0x00849401,  0x00849C01, 0x0084A401, 0x0084B801, 0x0084E802, 0x00850005,  0x00852804, 0x00853C01, 0x00864264, 0x00900027, 0x0091000B,  0x0092704E, 0x00940200, 0x009C0475, 0x009E53B9, 0x00AD400A,  0x00B39406, 0x00B3BC03, 0x00B3E404, 0x00B3F802, 0x00B5C001,  0x00B5FC01, 0x00B7804F, 0x00B8C00C, 0x00BA001A, 0x00BA6C59,  0x00BC00D6, 0x00BFC00C, 0x00C00005, 0x00C02019, 0x00C0A807,  0x00C0D802, 0x00C0F403, 0x00C26404, 0x00C28001, 0x00C3EC01,  0x00C64002, 0x00C6580A, 0x00C70024, 0x00C8001F, 0x00C8A81E,  0x00C94001, 0x00C98020, 0x00CA2827, 0x00CB003F, 0x00CC0100,  0x01370040, 0x02924037, 0x0293F802, 0x02983403, 0x0299BC10,  0x029A7C01, 0x029BC008, 0x029C0017, 0x029C8002, 0x029E2402,  0x02A00801, 0x02A01801, 0x02A02C01, 0x02A08C09, 0x02A0D804,  0x02A1D004, 0x02A20002, 0x02A2D011, 0x02A33802, 0x02A38012,  0x02A3E003, 0x02A4980A, 0x02A51C0D, 0x02A57C01, 0x02A60004,  0x02A6CC1B, 0x02A77802, 0x02A8A40E, 0x02A90C01, 0x02A93002,  0x02A97004, 0x02A9DC03, 0x02A9EC01, 0x02AAC001, 0x02AAC803,  0x02AADC02, 0x02AAF802, 0x02AB0401, 0x02AB7802, 0x02ABAC07,  0x02ABD402, 0x02AF8C0B, 0x03600001, 0x036DFC02, 0x036FFC02,  0x037FFC01, 0x03EC7801, 0x03ECA401, 0x03EEC810, 0x03F4F802,  0x03F7F002, 0x03F8001A, 0x03F88007, 0x03F8C023, 0x03F95013,  0x03F9A004, 0x03FBFC01, 0x03FC040F, 0x03FC6807, 0x03FCEC06,  0x03FD6C0B, 0x03FF8007, 0x03FFA007, 0x03FFE405, 0x04040003,  0x0404DC09, 0x0405E411, 0x0406400C, 0x0407402E, 0x040E7C01,  0x040F4001, 0x04215C01, 0x04247C01, 0x0424FC01, 0x04280403,  0x04281402, 0x04283004, 0x0428E003, 0x0428FC01, 0x04294009,  0x0429FC01, 0x042CE407, 0x04400003, 0x0440E016, 0x04420003,  0x0442C012, 0x04440003, 0x04449C0E, 0x04450004, 0x04460003,  0x0446CC0E, 0x04471404, 0x045AAC0D, 0x0491C004, 0x05BD442E,  0x05BE3C04, 0x074000F6, 0x07440027, 0x0744A4B5, 0x07480046,  0x074C0057, 0x075B0401, 0x075B6C01, 0x075BEC01, 0x075C5401,  0x075CD401, 0x075D3C01, 0x075DBC01, 0x075E2401, 0x075EA401,  0x075F0C01, 0x07BBC002, 0x07C0002C, 0x07C0C064, 0x07C2800F,  0x07C2C40E, 0x07C3040F, 0x07C3440F, 0x07C4401F, 0x07C4C03C,  0x07C5C02B, 0x07C7981D, 0x07C8402B, 0x07C90009, 0x07C94002,  0x07CC0021, 0x07CCC006, 0x07CCDC46, 0x07CE0014, 0x07CE8025,  0x07CF1805, 0x07CF8011, 0x07D0003F, 0x07D10001, 0x07D108B6,  0x07D3E404, 0x07D4003E, 0x07D50004, 0x07D54018, 0x07D7EC46,  0x07D9140B, 0x07DA0046, 0x07DC0074, 0x38000401, 0x38008060,  0x380400F0,  };  static const unsigned int aAscii[4] = {  0xFFFFFFFF, 0xFC00FFFF, 0xF8000001, 0xF8000001,  };  if( (unsigned int)c<128 ){  return ( (aAscii[c >> 5] & ((unsigned int)1 << (c & 0x001F)))==0 );  }else if( (unsigned int)c<(1<<22) ){  unsigned int key = (((unsigned int)c)<<10) | 0x000003FF;  int iRes = 0;  int iHi = sizeof(aEntry)/sizeof(aEntry[0]) - 1;  int iLo = 0;  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  if( key >= aEntry[iTest] ){  iRes = iTest;  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  assert( aEntry[0]<key );  assert( key>=aEntry[iRes] );  return (((unsigned int)c) >= ((aEntry[iRes]>>10) + (aEntry[iRes]&0x3FF)));  }  return 1; } static int remove_diacritic(int c, int bComplex){  unsigned short aDia[] = {  0, 1797, 1848, 1859, 1891, 1928, 1940, 1995,   2024, 2040, 2060, 2110, 2168, 2206, 2264, 2286,   2344, 2383, 2472, 2488, 2516, 2596, 2668, 2732,   2782, 2842, 2894, 2954, 2984, 3000, 3028, 3336,   3456, 3696, 3712, 3728, 3744, 3766, 3832, 3896,   3912, 3928, 3944, 3968, 4008, 4040, 4056, 4106,   4138, 4170, 4202, 4234, 4266, 4296, 4312, 4344,   4408, 4424, 4442, 4472, 4488, 4504, 6148, 6198,   6264, 6280, 6360, 6429, 6505, 6529, 61448, 61468,  61512, 61534, 61592, 61610, 61642, 61672, 61688, 61704,  61726, 61784, 61800, 61816, 61836, 61880, 61896, 61914,  61948, 61998, 62062, 62122, 62154, 62184, 62200, 62218,  62252, 62302, 62364, 62410, 62442, 62478, 62536, 62554,  62584, 62604, 62640, 62648, 62656, 62664, 62730, 62766,  62830, 62890, 62924, 62974, 63032, 63050, 63082, 63118,  63182, 63242, 63274, 63310, 63368, 63390,  };
#define HIBIT ((unsigned char)0x80)
 unsigned char aChar[] = {  '\0', 'a', 'c', 'e', 'i', 'n',  'o', 'u', 'y', 'y', 'a', 'c',  'd', 'e', 'e', 'g', 'h', 'i',  'j', 'k', 'l', 'n', 'o', 'r',  's', 't', 'u', 'u', 'w', 'y',  'z', 'o', 'u', 'a', 'i', 'o',  'u', 'u'|HIBIT, 'a'|HIBIT, 'g', 'k', 'o',  'o'|HIBIT, 'j', 'g', 'n', 'a'|HIBIT, 'a',  'e', 'i', 'o', 'r', 'u', 's',  't', 'h', 'a', 'e', 'o'|HIBIT, 'o',  'o'|HIBIT, 'y', '\0', '\0', '\0', '\0',  '\0', '\0', '\0', '\0', 'a', 'b',  'c'|HIBIT, 'd', 'd', 'e'|HIBIT, 'e', 'e'|HIBIT,  'f', 'g', 'h', 'h', 'i', 'i'|HIBIT,  'k', 'l', 'l'|HIBIT, 'l', 'm', 'n',  'o'|HIBIT, 'p', 'r', 'r'|HIBIT, 'r', 's',  's'|HIBIT, 't', 'u', 'u'|HIBIT, 'v', 'w',  'w', 'x', 'y', 'z', 'h', 't',  'w', 'y', 'a', 'a'|HIBIT, 'a'|HIBIT, 'a'|HIBIT,  'e', 'e'|HIBIT, 'e'|HIBIT, 'i', 'o', 'o'|HIBIT,  'o'|HIBIT, 'o'|HIBIT, 'u', 'u'|HIBIT, 'u'|HIBIT, 'y',  };  unsigned int key = (((unsigned int)c)<<3) | 0x00000007;  int iRes = 0;  int iHi = sizeof(aDia)/sizeof(aDia[0]) - 1;  int iLo = 0;  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  if( key >= aDia[iTest] ){  iRes = iTest;  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  assert( key>=aDia[iRes] );  if( bComplex==0 && (aChar[iRes] & 0x80) ) return c;  return (c > (aDia[iRes]>>3) + (aDia[iRes]&0x07)) ? c : ((int)aChar[iRes] & 0x7F); } SQLITE_PRIVATE int sqlite3FtsUnicodeIsdiacritic(int c){  unsigned int mask0 = 0x08029FDF;  unsigned int mask1 = 0x000361F8;  if( c<768 || c>817 ) return 0;  return (c < 768+32) ?  (mask0 & ((unsigned int)1 << (c-768))) :  (mask1 & ((unsigned int)1 << (c-768-32))); } SQLITE_PRIVATE int sqlite3FtsUnicodeFold(int c, int eRemoveDiacritic){  static const struct TableEntry {  unsigned short iCode;  unsigned char flags;  unsigned char nRange;  } aEntry[] = {  {65, 14, 26}, {181, 64, 1}, {192, 14, 23},  {216, 14, 7}, {256, 1, 48}, {306, 1, 6},  {313, 1, 16}, {330, 1, 46}, {376, 116, 1},  {377, 1, 6}, {383, 104, 1}, {385, 50, 1},  {386, 1, 4}, {390, 44, 1}, {391, 0, 1},  {393, 42, 2}, {395, 0, 1}, {398, 32, 1},  {399, 38, 1}, {400, 40, 1}, {401, 0, 1},  {403, 42, 1}, {404, 46, 1}, {406, 52, 1},  {407, 48, 1}, {408, 0, 1}, {412, 52, 1},  {413, 54, 1}, {415, 56, 1}, {416, 1, 6},  {422, 60, 1}, {423, 0, 1}, {425, 60, 1},  {428, 0, 1}, {430, 60, 1}, {431, 0, 1},  {433, 58, 2}, {435, 1, 4}, {439, 62, 1},  {440, 0, 1}, {444, 0, 1}, {452, 2, 1},  {453, 0, 1}, {455, 2, 1}, {456, 0, 1},  {458, 2, 1}, {459, 1, 18}, {478, 1, 18},  {497, 2, 1}, {498, 1, 4}, {502, 122, 1},  {503, 134, 1}, {504, 1, 40}, {544, 110, 1},  {546, 1, 18}, {570, 70, 1}, {571, 0, 1},  {573, 108, 1}, {574, 68, 1}, {577, 0, 1},  {579, 106, 1}, {580, 28, 1}, {581, 30, 1},  {582, 1, 10}, {837, 36, 1}, {880, 1, 4},  {886, 0, 1}, {902, 18, 1}, {904, 16, 3},  {908, 26, 1}, {910, 24, 2}, {913, 14, 17},  {931, 14, 9}, {962, 0, 1}, {975, 4, 1},  {976, 140, 1}, {977, 142, 1}, {981, 146, 1},  {982, 144, 1}, {984, 1, 24}, {1008, 136, 1},  {1009, 138, 1}, {1012, 130, 1}, {1013, 128, 1},  {1015, 0, 1}, {1017, 152, 1}, {1018, 0, 1},  {1021, 110, 3}, {1024, 34, 16}, {1040, 14, 32},  {1120, 1, 34}, {1162, 1, 54}, {1216, 6, 1},  {1217, 1, 14}, {1232, 1, 88}, {1329, 22, 38},  {4256, 66, 38}, {4295, 66, 1}, {4301, 66, 1},  {7680, 1, 150}, {7835, 132, 1}, {7838, 96, 1},  {7840, 1, 96}, {7944, 150, 8}, {7960, 150, 6},  {7976, 150, 8}, {7992, 150, 8}, {8008, 150, 6},  {8025, 151, 8}, {8040, 150, 8}, {8072, 150, 8},  {8088, 150, 8}, {8104, 150, 8}, {8120, 150, 2},  {8122, 126, 2}, {8124, 148, 1}, {8126, 100, 1},  {8136, 124, 4}, {8140, 148, 1}, {8152, 150, 2},  {8154, 120, 2}, {8168, 150, 2}, {8170, 118, 2},  {8172, 152, 1}, {8184, 112, 2}, {8186, 114, 2},  {8188, 148, 1}, {8486, 98, 1}, {8490, 92, 1},  {8491, 94, 1}, {8498, 12, 1}, {8544, 8, 16},  {8579, 0, 1}, {9398, 10, 26}, {11264, 22, 47},  {11360, 0, 1}, {11362, 88, 1}, {11363, 102, 1},  {11364, 90, 1}, {11367, 1, 6}, {11373, 84, 1},  {11374, 86, 1}, {11375, 80, 1}, {11376, 82, 1},  {11378, 0, 1}, {11381, 0, 1}, {11390, 78, 2},  {11392, 1, 100}, {11499, 1, 4}, {11506, 0, 1},  {42560, 1, 46}, {42624, 1, 24}, {42786, 1, 14},  {42802, 1, 62}, {42873, 1, 4}, {42877, 76, 1},  {42878, 1, 10}, {42891, 0, 1}, {42893, 74, 1},  {42896, 1, 4}, {42912, 1, 10}, {42922, 72, 1},  {65313, 14, 26},  };  static const unsigned short aiOff[] = {   1, 2, 8, 15, 16, 26, 28, 32,   37, 38, 40, 48, 63, 64, 69, 71,   79, 80, 116, 202, 203, 205, 206, 207,   209, 210, 211, 213, 214, 217, 218, 219,   775, 7264, 10792, 10795, 23228, 23256, 30204, 54721,   54753, 54754, 54756, 54787, 54793, 54809, 57153, 57274,   57921, 58019, 58363, 61722, 65268, 65341, 65373, 65406,   65408, 65410, 65415, 65424, 65436, 65439, 65450, 65462,   65472, 65476, 65478, 65480, 65482, 65488, 65506, 65511,   65514, 65521, 65527, 65528, 65529,  };  int ret = c;  assert( sizeof(unsigned short)==2 && sizeof(unsigned char)==1 );  if( c<128 ){  if( c>='A' && c<='Z' ) ret = c + ('a' - 'A');  }else if( c<65536 ){  const struct TableEntry *p;  int iHi = sizeof(aEntry)/sizeof(aEntry[0]) - 1;  int iLo = 0;  int iRes = -1;  assert( c>aEntry[0].iCode );  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  int cmp = (c - aEntry[iTest].iCode);  if( cmp>=0 ){  iRes = iTest;  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  assert( iRes>=0 && c>=aEntry[iRes].iCode );  p = &aEntry[iRes];  if( c<(p->iCode + p->nRange) && 0==(0x01 & p->flags & (p->iCode ^ c)) ){  ret = (c + (aiOff[p->flags>>1])) & 0x0000FFFF;  assert( ret>0 );  }  if( eRemoveDiacritic ){  ret = remove_diacritic(ret, eRemoveDiacritic==2);  }  }  else if( c>=66560 && c<66600 ){  ret = c + 40;  }  return ret; }
#endif
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_JSON1)
#if !defined(SQLITEINT_H)
#endif
SQLITE_EXTENSION_INIT1
#ifndef UNUSED_PARAM
# define UNUSED_PARAM(X) (void)(X)
#endif
#ifndef LARGEST_INT64
# define LARGEST_INT64 (0xffffffff|(((sqlite3_int64)0x7fffffff)<<32))
# define SMALLEST_INT64 (((sqlite3_int64)-1) - LARGEST_INT64)
#endif
#ifndef deliberate_fall_through
# define deliberate_fall_through
#endif
#ifdef sqlite3Isdigit
# define safe_isdigit(x) sqlite3Isdigit(x)
# define safe_isalnum(x) sqlite3Isalnum(x)
# define safe_isxdigit(x) sqlite3Isxdigit(x)
#else
#include <ctype.h>
# define safe_isdigit(x) isdigit((unsigned char)(x))
# define safe_isalnum(x) isalnum((unsigned char)(x))
# define safe_isxdigit(x) isxdigit((unsigned char)(x))
#endif
static const char jsonIsSpace[] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
#define safe_isspace(x) (jsonIsSpace[(unsigned char)x])
#ifndef SQLITE_AMALGAMATION
 typedef sqlite3_uint64 u64;  typedef unsigned int u32;  typedef unsigned short int u16;  typedef unsigned char u8;
# if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
#  define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1
# endif
# if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)
#  define ALWAYS(X) (1)
#  define NEVER(X)  (0)
# elif !defined(NDEBUG)
#  define ALWAYS(X) ((X)?1:(assert(0),0))
#  define NEVER(X)  ((X)?(assert(0),1):0)
# else
#  define ALWAYS(X) (X)
#  define NEVER(X)  (X)
# endif
# define testcase(X)
#endif
#if !defined(SQLITE_DEBUG) && !defined(SQLITE_COVERAGE_TEST)
# define VVA(X)
#else
# define VVA(X) X
#endif
#define json_testcase(X)
typedef struct JsonString JsonString; typedef struct JsonNode JsonNode; typedef struct JsonParse JsonParse; struct JsonString {  sqlite3_context *pCtx;  char *zBuf;  u64 nAlloc;  u64 nUsed;  u8 bStatic;  u8 bErr;  char zSpace[100]; };
#define JSON_NULL  0
#define JSON_TRUE  1
#define JSON_FALSE 2
#define JSON_INT 3
#define JSON_REAL  4
#define JSON_STRING  5
#define JSON_ARRAY 6
#define JSON_OBJECT  7
#define JSON_SUBTYPE 74
static const char * const jsonType[] = {  "null", "true", "false", "integer", "real", "text", "array", "object" };
#define JNODE_RAW  0x01
#define JNODE_ESCAPE 0x02
#define JNODE_REMOVE 0x04
#define JNODE_REPLACE 0x08
#define JNODE_PATCH  0x10
#define JNODE_APPEND 0x20
#define JNODE_LABEL  0x40
struct JsonNode {  u8 eType;  u8 jnFlags;  u8 eU;  u32 n;  union {  const char *zJContent;  u32 iAppend;  u32 iKey;  u32 iReplace;  JsonNode *pPatch;  } u; }; struct JsonParse {  u32 nNode;  u32 nAlloc;  JsonNode *aNode;  const char *zJson;  u32 *aUp;  u8 oom;  u8 nErr;  u16 iDepth;  int nJson;  u32 iHold; };
#define JSON_MAX_DEPTH 2000
static void jsonZero(JsonString *p){  p->zBuf = p->zSpace;  p->nAlloc = sizeof(p->zSpace);  p->nUsed = 0;  p->bStatic = 1; } static void jsonInit(JsonString *p, sqlite3_context *pCtx){  p->pCtx = pCtx;  p->bErr = 0;  jsonZero(p); } static void jsonReset(JsonString *p){  if( !p->bStatic ) sqlite3_free(p->zBuf);  jsonZero(p); } static void jsonOom(JsonString *p){  p->bErr = 1;  sqlite3_result_error_nomem(p->pCtx);  jsonReset(p); } static int jsonGrow(JsonString *p, u32 N){  u64 nTotal = N<p->nAlloc ? p->nAlloc*2 : p->nAlloc+N+10;  char *zNew;  if( p->bStatic ){  if( p->bErr ) return 1;  zNew = sqlite3_malloc64(nTotal);  if( zNew==0 ){  jsonOom(p);  return SQLITE_NOMEM;  }  memcpy(zNew, p->zBuf, (size_t)p->nUsed);  p->zBuf = zNew;  p->bStatic = 0;  }else{  zNew = sqlite3_realloc64(p->zBuf, nTotal);  if( zNew==0 ){  jsonOom(p);  return SQLITE_NOMEM;  }  p->zBuf = zNew;  }  p->nAlloc = nTotal;  return SQLITE_OK; } static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){  if( N==0 ) return;  if( (N+p->nUsed >= p->nAlloc) && jsonGrow(p,N)!=0 ) return;  memcpy(p->zBuf+p->nUsed, zIn, N);  p->nUsed += N; } static void jsonPrintf(int N, JsonString *p, const char *zFormat, ...){  va_list ap;  if( (p->nUsed + N >= p->nAlloc) && jsonGrow(p, N) ) return;  va_start(ap, zFormat);  sqlite3_vsnprintf(N, p->zBuf+p->nUsed, zFormat, ap);  va_end(ap);  p->nUsed += (int)strlen(p->zBuf+p->nUsed); } static void jsonAppendChar(JsonString *p, char c){  if( p->nUsed>=p->nAlloc && jsonGrow(p,1)!=0 ) return;  p->zBuf[p->nUsed++] = c; } static void jsonAppendSeparator(JsonString *p){  char c;  if( p->nUsed==0 ) return;  c = p->zBuf[p->nUsed-1];  if( c!='[' && c!='{' ) jsonAppendChar(p, ','); } static void jsonAppendString(JsonString *p, const char *zIn, u32 N){  u32 i;  if( zIn==0 || ((N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0) ) return;  p->zBuf[p->nUsed++] = '"';  for(i=0; i<N; i++){  unsigned char c = ((unsigned const char*)zIn)[i];  if( c=='"' || c=='\\' ){  json_simple_escape:  if( (p->nUsed+N+3-i > p->nAlloc) && jsonGrow(p,N+3-i)!=0 ) return;  p->zBuf[p->nUsed++] = '\\';  }else if( c<=0x1f ){  static const char aSpecial[] = {   0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  };  assert( sizeof(aSpecial)==32 );  assert( aSpecial['\b']=='b' );  assert( aSpecial['\f']=='f' );  assert( aSpecial['\n']=='n' );  assert( aSpecial['\r']=='r' );  assert( aSpecial['\t']=='t' );  if( aSpecial[c] ){  c = aSpecial[c];  goto json_simple_escape;  }  if( (p->nUsed+N+7+i > p->nAlloc) && jsonGrow(p,N+7-i)!=0 ) return;  p->zBuf[p->nUsed++] = '\\';  p->zBuf[p->nUsed++] = 'u';  p->zBuf[p->nUsed++] = '0';  p->zBuf[p->nUsed++] = '0';  p->zBuf[p->nUsed++] = '0' + (c>>4);  c = "0123456789abcdef"[c&0xf];  }  p->zBuf[p->nUsed++] = c;  }  p->zBuf[p->nUsed++] = '"';  assert( p->nUsed<p->nAlloc ); } static void jsonAppendValue(  JsonString *p,  sqlite3_value *pValue ){  switch( sqlite3_value_type(pValue) ){  case SQLITE_NULL: {  jsonAppendRaw(p, "null", 4);  break;  }  case SQLITE_INTEGER:  case SQLITE_FLOAT: {  const char *z = (const char*)sqlite3_value_text(pValue);  u32 n = (u32)sqlite3_value_bytes(pValue);  jsonAppendRaw(p, z, n);  break;  }  case SQLITE_TEXT: {  const char *z = (const char*)sqlite3_value_text(pValue);  u32 n = (u32)sqlite3_value_bytes(pValue);  if( sqlite3_value_subtype(pValue)==JSON_SUBTYPE ){  jsonAppendRaw(p, z, n);  }else{  jsonAppendString(p, z, n);  }  break;  }  default: {  if( p->bErr==0 ){  sqlite3_result_error(p->pCtx, "JSON cannot hold BLOB values", -1);  p->bErr = 2;  jsonReset(p);  }  break;  }  } } static void jsonResult(JsonString *p){  if( p->bErr==0 ){  sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,  p->bStatic ? SQLITE_TRANSIENT : sqlite3_free,  SQLITE_UTF8);  jsonZero(p);  }  assert( p->bStatic ); } static u32 jsonNodeSize(JsonNode *pNode){  return pNode->eType>=JSON_ARRAY ? pNode->n+1 : 1; } static void jsonParseReset(JsonParse *pParse){  sqlite3_free(pParse->aNode);  pParse->aNode = 0;  pParse->nNode = 0;  pParse->nAlloc = 0;  sqlite3_free(pParse->aUp);  pParse->aUp = 0; } static void jsonParseFree(JsonParse *pParse){  jsonParseReset(pParse);  sqlite3_free(pParse); } static void jsonRenderNode(  JsonNode *pNode,  JsonString *pOut,  sqlite3_value **aReplace ){  assert( pNode!=0 );  if( pNode->jnFlags & (JNODE_REPLACE|JNODE_PATCH) ){  if( (pNode->jnFlags & JNODE_REPLACE)!=0 && ALWAYS(aReplace!=0) ){  assert( pNode->eU==4 );  jsonAppendValue(pOut, aReplace[pNode->u.iReplace]);  return;  }  assert( pNode->eU==5 );  pNode = pNode->u.pPatch;  }  switch( pNode->eType ){  default: {  assert( pNode->eType==JSON_NULL );  jsonAppendRaw(pOut, "null", 4);  break;  }  case JSON_TRUE: {  jsonAppendRaw(pOut, "true", 4);  break;  }  case JSON_FALSE: {  jsonAppendRaw(pOut, "false", 5);  break;  }  case JSON_STRING: {  if( pNode->jnFlags & JNODE_RAW ){  assert( pNode->eU==1 );  jsonAppendString(pOut, pNode->u.zJContent, pNode->n);  break;  }  deliberate_fall_through  }  case JSON_REAL:  case JSON_INT: {  assert( pNode->eU==1 );  jsonAppendRaw(pOut, pNode->u.zJContent, pNode->n);  break;  }  case JSON_ARRAY: {  u32 j = 1;  jsonAppendChar(pOut, '[');  for(;;){  while( j<=pNode->n ){  if( (pNode[j].jnFlags & JNODE_REMOVE)==0 ){  jsonAppendSeparator(pOut);  jsonRenderNode(&pNode[j], pOut, aReplace);  }  j += jsonNodeSize(&pNode[j]);  }  if( (pNode->jnFlags & JNODE_APPEND)==0 ) break;  assert( pNode->eU==2 );  pNode = &pNode[pNode->u.iAppend];  j = 1;  }  jsonAppendChar(pOut, ']');  break;  }  case JSON_OBJECT: {  u32 j = 1;  jsonAppendChar(pOut, '{');  for(;;){  while( j<=pNode->n ){  if( (pNode[j+1].jnFlags & JNODE_REMOVE)==0 ){  jsonAppendSeparator(pOut);  jsonRenderNode(&pNode[j], pOut, aReplace);  jsonAppendChar(pOut, ':');  jsonRenderNode(&pNode[j+1], pOut, aReplace);  }  j += 1 + jsonNodeSize(&pNode[j+1]);  }  if( (pNode->jnFlags & JNODE_APPEND)==0 ) break;  assert( pNode->eU==2 );  pNode = &pNode[pNode->u.iAppend];  j = 1;  }  jsonAppendChar(pOut, '}');  break;  }  } } static void jsonReturnJson(  JsonNode *pNode,  sqlite3_context *pCtx,  sqlite3_value **aReplace ){  JsonString s;  jsonInit(&s, pCtx);  jsonRenderNode(pNode, &s, aReplace);  jsonResult(&s);  sqlite3_result_subtype(pCtx, JSON_SUBTYPE); } static u8 jsonHexToInt(int h){  assert( (h>='0' && h<='9') || (h>='a' && h<='f') || (h>='A' && h<='F') );
#ifdef SQLITE_EBCDIC
 h += 9*(1&~(h>>4));
#else
 h += 9*(1&(h>>6));
#endif
 return (u8)(h & 0xf); } static u32 jsonHexToInt4(const char *z){  u32 v;  assert( safe_isxdigit(z[0]) );  assert( safe_isxdigit(z[1]) );  assert( safe_isxdigit(z[2]) );  assert( safe_isxdigit(z[3]) );  v = (jsonHexToInt(z[0])<<12)  + (jsonHexToInt(z[1])<<8)  + (jsonHexToInt(z[2])<<4)  + jsonHexToInt(z[3]);  return v; } static void jsonReturn(  JsonNode *pNode,  sqlite3_context *pCtx,  sqlite3_value **aReplace ){  switch( pNode->eType ){  default: {  assert( pNode->eType==JSON_NULL );  sqlite3_result_null(pCtx);  break;  }  case JSON_TRUE: {  sqlite3_result_int(pCtx, 1);  break;  }  case JSON_FALSE: {  sqlite3_result_int(pCtx, 0);  break;  }  case JSON_INT: {  sqlite3_int64 i = 0;  const char *z;  assert( pNode->eU==1 );  z = pNode->u.zJContent;  if( z[0]=='-' ){ z++; }  while( z[0]>='0' && z[0]<='9' ){  unsigned v = *(z++) - '0';  if( i>=LARGEST_INT64/10 ){  if( i>LARGEST_INT64/10 ) goto int_as_real;  if( z[0]>='0' && z[0]<='9' ) goto int_as_real;  if( v==9 ) goto int_as_real;  if( v==8 ){  if( pNode->u.zJContent[0]=='-' ){  sqlite3_result_int64(pCtx, SMALLEST_INT64);  goto int_done;  }else{  goto int_as_real;  }  }  }  i = i*10 + v;  }  if( pNode->u.zJContent[0]=='-' ){ i = -i; }  sqlite3_result_int64(pCtx, i);  int_done:  break;  int_as_real: ; deliberate_fall_through  }  case JSON_REAL: {  double r;
#ifdef SQLITE_AMALGAMATION
 const char *z;  assert( pNode->eU==1 );  z = pNode->u.zJContent;  sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);
#else
 assert( pNode->eU==1 );  r = strtod(pNode->u.zJContent, 0);
#endif
 sqlite3_result_double(pCtx, r);  break;  }  case JSON_STRING: {
#if 0
 if( pNode->jnFlags & JNODE_RAW ){  assert( pNode->eU==1 );  sqlite3_result_text(pCtx, pNode->u.zJContent, pNode->n,  SQLITE_TRANSIENT);  }else
#endif
 assert( (pNode->jnFlags & JNODE_RAW)==0 );  if( (pNode->jnFlags & JNODE_ESCAPE)==0 ){  assert( pNode->eU==1 );  sqlite3_result_text(pCtx, pNode->u.zJContent+1, pNode->n-2,  SQLITE_TRANSIENT);  }else{  u32 i;  u32 n = pNode->n;  const char *z;  char *zOut;  u32 j;  assert( pNode->eU==1 );  z = pNode->u.zJContent;  zOut = sqlite3_malloc( n+1 );  if( zOut==0 ){  sqlite3_result_error_nomem(pCtx);  break;  }  for(i=1, j=0; i<n-1; i++){  char c = z[i];  if( c!='\\' ){  zOut[j++] = c;  }else{  c = z[++i];  if( c=='u' ){  u32 v = jsonHexToInt4(z+i+1);  i += 4;  if( v==0 ) break;  if( v<=0x7f ){  zOut[j++] = (char)v;  }else if( v<=0x7ff ){  zOut[j++] = (char)(0xc0 | (v>>6));  zOut[j++] = 0x80 | (v&0x3f);  }else{  u32 vlo;  if( (v&0xfc00)==0xd800  && i<n-6  && z[i+1]=='\\'  && z[i+2]=='u'  && ((vlo = jsonHexToInt4(z+i+3))&0xfc00)==0xdc00  ){  v = ((v&0x3ff)<<10) + (vlo&0x3ff) + 0x10000;  i += 6;  zOut[j++] = 0xf0 | (v>>18);  zOut[j++] = 0x80 | ((v>>12)&0x3f);  zOut[j++] = 0x80 | ((v>>6)&0x3f);  zOut[j++] = 0x80 | (v&0x3f);  }else{  zOut[j++] = 0xe0 | (v>>12);  zOut[j++] = 0x80 | ((v>>6)&0x3f);  zOut[j++] = 0x80 | (v&0x3f);  }  }  }else{  if( c=='b' ){  c = '\b';  }else if( c=='f' ){  c = '\f';  }else if( c=='n' ){  c = '\n';  }else if( c=='r' ){  c = '\r';  }else if( c=='t' ){  c = '\t';  }  zOut[j++] = c;  }  }  }  zOut[j] = 0;  sqlite3_result_text(pCtx, zOut, j, sqlite3_free);  }  break;  }  case JSON_ARRAY:  case JSON_OBJECT: {  jsonReturnJson(pNode, pCtx, aReplace);  break;  }  } } static int jsonParseAddNode(JsonParse*,u32,u32,const char*);
#if defined(__GNUC__)
# define JSON_NOINLINE __attribute__((noinline))
#elif defined(_MSC_VER) && _MSC_VER>=1310
# define JSON_NOINLINE __declspec(noinline)
#else
# define JSON_NOINLINE
#endif
static JSON_NOINLINE int jsonParseAddNodeExpand(  JsonParse *pParse,  u32 eType,  u32 n,  const char *zContent ){  u32 nNew;  JsonNode *pNew;  assert( pParse->nNode>=pParse->nAlloc );  if( pParse->oom ) return -1;  nNew = pParse->nAlloc*2 + 10;  pNew = sqlite3_realloc64(pParse->aNode, sizeof(JsonNode)*nNew);  if( pNew==0 ){  pParse->oom = 1;  return -1;  }  pParse->nAlloc = nNew;  pParse->aNode = pNew;  assert( pParse->nNode<pParse->nAlloc );  return jsonParseAddNode(pParse, eType, n, zContent); } static int jsonParseAddNode(  JsonParse *pParse,  u32 eType,  u32 n,  const char *zContent ){  JsonNode *p;  if( pParse->aNode==0 || pParse->nNode>=pParse->nAlloc ){  return jsonParseAddNodeExpand(pParse, eType, n, zContent);  }  p = &pParse->aNode[pParse->nNode];  p->eType = (u8)eType;  p->jnFlags = 0;  VVA( p->eU = zContent ? 1 : 0 );  p->n = n;  p->u.zJContent = zContent;  return pParse->nNode++; } static int jsonIs4Hex(const char *z){  int i;  for(i=0; i<4; i++) if( !safe_isxdigit(z[i]) ) return 0;  return 1; } static int jsonParseValue(JsonParse *pParse, u32 i){  char c;  u32 j;  int iThis;  int x;  JsonNode *pNode;  const char *z = pParse->zJson;  while( safe_isspace(z[i]) ){ i++; }  if( (c = z[i])=='{' ){  iThis = jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);  if( iThis<0 ) return -1;  for(j=i+1;;j++){  while( safe_isspace(z[j]) ){ j++; }  if( ++pParse->iDepth > JSON_MAX_DEPTH ) return -1;  x = jsonParseValue(pParse, j);  if( x<0 ){  pParse->iDepth--;  if( x==(-2) && pParse->nNode==(u32)iThis+1 ) return j+1;  return -1;  }  if( pParse->oom ) return -1;  pNode = &pParse->aNode[pParse->nNode-1];  if( pNode->eType!=JSON_STRING ) return -1;  pNode->jnFlags |= JNODE_LABEL;  j = x;  while( safe_isspace(z[j]) ){ j++; }  if( z[j]!=':' ) return -1;  j++;  x = jsonParseValue(pParse, j);  pParse->iDepth--;  if( x<0 ) return -1;  j = x;  while( safe_isspace(z[j]) ){ j++; }  c = z[j];  if( c==',' ) continue;  if( c!='}' ) return -1;  break;  }  pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;  return j+1;  }else if( c=='[' ){  iThis = jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);  if( iThis<0 ) return -1;  memset(&pParse->aNode[iThis].u, 0, sizeof(pParse->aNode[iThis].u));  for(j=i+1;;j++){  while( safe_isspace(z[j]) ){ j++; }  if( ++pParse->iDepth > JSON_MAX_DEPTH ) return -1;  x = jsonParseValue(pParse, j);  pParse->iDepth--;  if( x<0 ){  if( x==(-3) && pParse->nNode==(u32)iThis+1 ) return j+1;  return -1;  }  j = x;  while( safe_isspace(z[j]) ){ j++; }  c = z[j];  if( c==',' ) continue;  if( c!=']' ) return -1;  break;  }  pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;  return j+1;  }else if( c=='"' ){  u8 jnFlags = 0;  j = i+1;  for(;;){  c = z[j];  if( (c & ~0x1f)==0 ){  return -1;  }  if( c=='\\' ){  c = z[++j];  if( c=='"' || c=='\\' || c=='/' || c=='b' || c=='f'   || c=='n' || c=='r' || c=='t'   || (c=='u' && jsonIs4Hex(z+j+1)) ){  jnFlags = JNODE_ESCAPE;  }else{  return -1;  }  }else if( c=='"' ){  break;  }  j++;  }  jsonParseAddNode(pParse, JSON_STRING, j+1-i, &z[i]);  if( !pParse->oom ) pParse->aNode[pParse->nNode-1].jnFlags = jnFlags;  return j+1;  }else if( c=='n'   && strncmp(z+i,"null",4)==0   && !safe_isalnum(z[i+4]) ){  jsonParseAddNode(pParse, JSON_NULL, 0, 0);  return i+4;  }else if( c=='t'   && strncmp(z+i,"true",4)==0   && !safe_isalnum(z[i+4]) ){  jsonParseAddNode(pParse, JSON_TRUE, 0, 0);  return i+4;  }else if( c=='f'   && strncmp(z+i,"false",5)==0   && !safe_isalnum(z[i+5]) ){  jsonParseAddNode(pParse, JSON_FALSE, 0, 0);  return i+5;  }else if( c=='-' || (c>='0' && c<='9') ){  u8 seenDP = 0;  u8 seenE = 0;  assert( '-' < '0' );  if( c<='0' ){  j = c=='-' ? i+1 : i;  if( z[j]=='0' && z[j+1]>='0' && z[j+1]<='9' ) return -1;  }  j = i+1;  for(;; j++){  c = z[j];  if( c>='0' && c<='9' ) continue;  if( c=='.' ){  if( z[j-1]=='-' ) return -1;  if( seenDP ) return -1;  seenDP = 1;  continue;  }  if( c=='e' || c=='E' ){  if( z[j-1]<'0' ) return -1;  if( seenE ) return -1;  seenDP = seenE = 1;  c = z[j+1];  if( c=='+' || c=='-' ){  j++;  c = z[j+1];  }  if( c<'0' || c>'9' ) return -1;  continue;  }  break;  }  if( z[j-1]<'0' ) return -1;  jsonParseAddNode(pParse, seenDP ? JSON_REAL : JSON_INT,  j - i, &z[i]);  return j;  }else if( c=='}' ){  return -2;  }else if( c==']' ){  return -3;  }else if( c==0 ){  return 0;  }else{  return -1;  } } static int jsonParse(  JsonParse *pParse,  sqlite3_context *pCtx,  const char *zJson ){  int i;  memset(pParse, 0, sizeof(*pParse));  if( zJson==0 ) return 1;  pParse->zJson = zJson;  i = jsonParseValue(pParse, 0);  if( pParse->oom ) i = -1;  if( i>0 ){  assert( pParse->iDepth==0 );  while( safe_isspace(zJson[i]) ) i++;  if( zJson[i] ) i = -1;  }  if( i<=0 ){  if( pCtx!=0 ){  if( pParse->oom ){  sqlite3_result_error_nomem(pCtx);  }else{  sqlite3_result_error(pCtx, "malformed JSON", -1);  }  }  jsonParseReset(pParse);  return 1;  }  return 0; } static void jsonParseFillInParentage(JsonParse *pParse, u32 i, u32 iParent){  JsonNode *pNode = &pParse->aNode[i];  u32 j;  pParse->aUp[i] = iParent;  switch( pNode->eType ){  case JSON_ARRAY: {  for(j=1; j<=pNode->n; j += jsonNodeSize(pNode+j)){  jsonParseFillInParentage(pParse, i+j, i);  }  break;  }  case JSON_OBJECT: {  for(j=1; j<=pNode->n; j += jsonNodeSize(pNode+j+1)+1){  pParse->aUp[i+j] = i;  jsonParseFillInParentage(pParse, i+j+1, i);  }  break;  }  default: {  break;  }  } } static int jsonParseFindParents(JsonParse *pParse){  u32 *aUp;  assert( pParse->aUp==0 );  aUp = pParse->aUp = sqlite3_malloc64( sizeof(u32)*pParse->nNode );  if( aUp==0 ){  pParse->oom = 1;  return SQLITE_NOMEM;  }  jsonParseFillInParentage(pParse, 0, 0);  return SQLITE_OK; }
#define JSON_CACHE_ID (-429938)
#define JSON_CACHE_SZ 4
static JsonParse *jsonParseCached(  sqlite3_context *pCtx,  sqlite3_value **argv,  sqlite3_context *pErrCtx ){  const char *zJson = (const char*)sqlite3_value_text(argv[0]);  int nJson = sqlite3_value_bytes(argv[0]);  JsonParse *p;  JsonParse *pMatch = 0;  int iKey;  int iMinKey = 0;  u32 iMinHold = 0xffffffff;  u32 iMaxHold = 0;  if( zJson==0 ) return 0;  for(iKey=0; iKey<JSON_CACHE_SZ; iKey++){  p = (JsonParse*)sqlite3_get_auxdata(pCtx, JSON_CACHE_ID+iKey);  if( p==0 ){  iMinKey = iKey;  break;  }  if( pMatch==0   && p->nJson==nJson   && memcmp(p->zJson,zJson,nJson)==0  ){  p->nErr = 0;  pMatch = p;  }else if( p->iHold<iMinHold ){  iMinHold = p->iHold;  iMinKey = iKey;  }  if( p->iHold>iMaxHold ){  iMaxHold = p->iHold;  }  }  if( pMatch ){  pMatch->nErr = 0;  pMatch->iHold = iMaxHold+1;  return pMatch;  }  p = sqlite3_malloc64( sizeof(*p) + nJson + 1 );  if( p==0 ){  sqlite3_result_error_nomem(pCtx);  return 0;  }  memset(p, 0, sizeof(*p));  p->zJson = (char*)&p[1];  memcpy((char*)p->zJson, zJson, nJson+1);  if( jsonParse(p, pErrCtx, p->zJson) ){  sqlite3_free(p);  return 0;  }  p->nJson = nJson;  p->iHold = iMaxHold+1;  sqlite3_set_auxdata(pCtx, JSON_CACHE_ID+iMinKey, p,  (void(*)(void*))jsonParseFree);  return (JsonParse*)sqlite3_get_auxdata(pCtx, JSON_CACHE_ID+iMinKey); } static int jsonLabelCompare(JsonNode *pNode, const char *zKey, u32 nKey){  assert( pNode->eU==1 );  if( pNode->jnFlags & JNODE_RAW ){  if( pNode->n!=nKey ) return 0;  return strncmp(pNode->u.zJContent, zKey, nKey)==0;  }else{  if( pNode->n!=nKey+2 ) return 0;  return strncmp(pNode->u.zJContent+1, zKey, nKey)==0;  } } static JsonNode *jsonLookupAppend(JsonParse*,const char*,int*,const char**); static JsonNode *jsonLookupStep(  JsonParse *pParse,  u32 iRoot,  const char *zPath,  int *pApnd,  const char **pzErr ){  u32 i, j, nKey;  const char *zKey;  JsonNode *pRoot = &pParse->aNode[iRoot];  if( zPath[0]==0 ) return pRoot;  if( pRoot->jnFlags & JNODE_REPLACE ) return 0;  if( zPath[0]=='.' ){  if( pRoot->eType!=JSON_OBJECT ) return 0;  zPath++;  if( zPath[0]=='"' ){  zKey = zPath + 1;  for(i=1; zPath[i] && zPath[i]!='"'; i++){}  nKey = i-1;  if( zPath[i] ){  i++;  }else{  *pzErr = zPath;  return 0;  }  }else{  zKey = zPath;  for(i=0; zPath[i] && zPath[i]!='.' && zPath[i]!='['; i++){}  nKey = i;  }  if( nKey==0 ){  *pzErr = zPath;  return 0;  }  j = 1;  for(;;){  while( j<=pRoot->n ){  if( jsonLabelCompare(pRoot+j, zKey, nKey) ){  return jsonLookupStep(pParse, iRoot+j+1, &zPath[i], pApnd, pzErr);  }  j++;  j += jsonNodeSize(&pRoot[j]);  }  if( (pRoot->jnFlags & JNODE_APPEND)==0 ) break;  assert( pRoot->eU==2 );  iRoot += pRoot->u.iAppend;  pRoot = &pParse->aNode[iRoot];  j = 1;  }  if( pApnd ){  u32 iStart, iLabel;  JsonNode *pNode;  iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);  iLabel = jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);  zPath += i;  pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);  if( pParse->oom ) return 0;  if( pNode ){  pRoot = &pParse->aNode[iRoot];  assert( pRoot->eU==0 );  pRoot->u.iAppend = iStart - iRoot;  pRoot->jnFlags |= JNODE_APPEND;  VVA( pRoot->eU = 2 );  pParse->aNode[iLabel].jnFlags |= JNODE_RAW;  }  return pNode;  }  }else if( zPath[0]=='[' ){  i = 0;  j = 1;  while( safe_isdigit(zPath[j]) ){  i = i*10 + zPath[j] - '0';  j++;  }  if( j<2 || zPath[j]!=']' ){  if( zPath[1]=='#' ){  JsonNode *pBase = pRoot;  int iBase = iRoot;  if( pRoot->eType!=JSON_ARRAY ) return 0;  for(;;){  while( j<=pBase->n ){  if( (pBase[j].jnFlags & JNODE_REMOVE)==0 ) i++;  j += jsonNodeSize(&pBase[j]);  }  if( (pBase->jnFlags & JNODE_APPEND)==0 ) break;  assert( pBase->eU==2 );  iBase += pBase->u.iAppend;  pBase = &pParse->aNode[iBase];  j = 1;  }  j = 2;  if( zPath[2]=='-' && safe_isdigit(zPath[3]) ){  unsigned int x = 0;  j = 3;  do{  x = x*10 + zPath[j] - '0';  j++;  }while( safe_isdigit(zPath[j]) );  if( x>i ) return 0;  i -= x;  }  if( zPath[j]!=']' ){  *pzErr = zPath;  return 0;  }  }else{  *pzErr = zPath;  return 0;  }  }  if( pRoot->eType!=JSON_ARRAY ) return 0;  zPath += j + 1;  j = 1;  for(;;){  while( j<=pRoot->n && (i>0 || (pRoot[j].jnFlags & JNODE_REMOVE)!=0) ){  if( (pRoot[j].jnFlags & JNODE_REMOVE)==0 ) i--;  j += jsonNodeSize(&pRoot[j]);  }  if( (pRoot->jnFlags & JNODE_APPEND)==0 ) break;  assert( pRoot->eU==2 );  iRoot += pRoot->u.iAppend;  pRoot = &pParse->aNode[iRoot];  j = 1;  }  if( j<=pRoot->n ){  return jsonLookupStep(pParse, iRoot+j, zPath, pApnd, pzErr);  }  if( i==0 && pApnd ){  u32 iStart;  JsonNode *pNode;  iStart = jsonParseAddNode(pParse, JSON_ARRAY, 1, 0);  pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);  if( pParse->oom ) return 0;  if( pNode ){  pRoot = &pParse->aNode[iRoot];  assert( pRoot->eU==0 );  pRoot->u.iAppend = iStart - iRoot;  pRoot->jnFlags |= JNODE_APPEND;  VVA( pRoot->eU = 2 );  }  return pNode;  }  }else{  *pzErr = zPath;  }  return 0; } static JsonNode *jsonLookupAppend(  JsonParse *pParse,  const char *zPath,  int *pApnd,  const char **pzErr ){  *pApnd = 1;  if( zPath[0]==0 ){  jsonParseAddNode(pParse, JSON_NULL, 0, 0);  return pParse->oom ? 0 : &pParse->aNode[pParse->nNode-1];  }  if( zPath[0]=='.' ){  jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);  }else if( strncmp(zPath,"[0]",3)==0 ){  jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);  }else{  return 0;  }  if( pParse->oom ) return 0;  return jsonLookupStep(pParse, pParse->nNode-1, zPath, pApnd, pzErr); } static char *jsonPathSyntaxError(const char *zErr){  return sqlite3_mprintf("JSON path error near '%q'", zErr); } static JsonNode *jsonLookup(  JsonParse *pParse,  const char *zPath,  int *pApnd,  sqlite3_context *pCtx ){  const char *zErr = 0;  JsonNode *pNode = 0;  char *zMsg;  if( zPath==0 ) return 0;  if( zPath[0]!='$' ){  zErr = zPath;  goto lookup_err;  }  zPath++;  pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);  if( zErr==0 ) return pNode; lookup_err:  pParse->nErr++;  assert( zErr!=0 && pCtx!=0 );  zMsg = jsonPathSyntaxError(zErr);  if( zMsg ){  sqlite3_result_error(pCtx, zMsg, -1);  sqlite3_free(zMsg);  }else{  sqlite3_result_error_nomem(pCtx);  }  return 0; } static void jsonWrongNumArgs(  sqlite3_context *pCtx,  const char *zFuncName ){  char *zMsg = sqlite3_mprintf("json_%s() needs an odd number of arguments",   zFuncName);  sqlite3_result_error(pCtx, zMsg, -1);  sqlite3_free(zMsg); } static void jsonRemoveAllNulls(JsonNode *pNode){  int i, n;  assert( pNode->eType==JSON_OBJECT );  n = pNode->n;  for(i=2; i<=n; i += jsonNodeSize(&pNode[i])+1){  switch( pNode[i].eType ){  case JSON_NULL:  pNode[i].jnFlags |= JNODE_REMOVE;  break;  case JSON_OBJECT:  jsonRemoveAllNulls(&pNode[i]);  break;  }  } }
#ifdef SQLITE_DEBUG
static void jsonParseFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonString s;  JsonParse x;  u32 i;  assert( argc==1 );  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;  jsonParseFindParents(&x);  jsonInit(&s, ctx);  for(i=0; i<x.nNode; i++){  const char *zType;  if( x.aNode[i].jnFlags & JNODE_LABEL ){  assert( x.aNode[i].eType==JSON_STRING );  zType = "label";  }else{  zType = jsonType[x.aNode[i].eType];  }  jsonPrintf(100, &s,"node %3u: %7s n=%-4d up=%-4d",   i, zType, x.aNode[i].n, x.aUp[i]);  assert( x.aNode[i].eU==0 || x.aNode[i].eU==1 );  if( x.aNode[i].u.zJContent!=0 ){  assert( x.aNode[i].eU==1 );  jsonAppendRaw(&s, " ", 1);  jsonAppendRaw(&s, x.aNode[i].u.zJContent, x.aNode[i].n);  }else{  assert( x.aNode[i].eU==0 );  }  jsonAppendRaw(&s, "\n", 1);  }  jsonParseReset(&x);  jsonResult(&s); } static void jsonTest1Func(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  UNUSED_PARAM(argc);  sqlite3_result_int(ctx, sqlite3_value_subtype(argv[0])==JSON_SUBTYPE); }
#endif
static void jsonQuoteFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonString jx;  UNUSED_PARAM(argc);  jsonInit(&jx, ctx);  jsonAppendValue(&jx, argv[0]);  jsonResult(&jx);  sqlite3_result_subtype(ctx, JSON_SUBTYPE); } static void jsonArrayFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  int i;  JsonString jx;  jsonInit(&jx, ctx);  jsonAppendChar(&jx, '[');  for(i=0; i<argc; i++){  jsonAppendSeparator(&jx);  jsonAppendValue(&jx, argv[i]);  }  jsonAppendChar(&jx, ']');  jsonResult(&jx);  sqlite3_result_subtype(ctx, JSON_SUBTYPE); } static void jsonArrayLengthFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse *p;  sqlite3_int64 n = 0;  u32 i;  JsonNode *pNode;  p = jsonParseCached(ctx, argv, ctx);  if( p==0 ) return;  assert( p->nNode );  if( argc==2 ){  const char *zPath = (const char*)sqlite3_value_text(argv[1]);  pNode = jsonLookup(p, zPath, 0, ctx);  }else{  pNode = p->aNode;  }  if( pNode==0 ){  return;  }  if( pNode->eType==JSON_ARRAY ){  assert( (pNode->jnFlags & JNODE_APPEND)==0 );  for(i=1; i<=pNode->n; n++){  i += jsonNodeSize(&pNode[i]);  }  }  sqlite3_result_int64(ctx, n); } static void jsonExtractFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse *p;  JsonNode *pNode;  const char *zPath;  JsonString jx;  int i;  if( argc<2 ) return;  p = jsonParseCached(ctx, argv, ctx);  if( p==0 ) return;  jsonInit(&jx, ctx);  jsonAppendChar(&jx, '[');  for(i=1; i<argc; i++){  zPath = (const char*)sqlite3_value_text(argv[i]);  pNode = jsonLookup(p, zPath, 0, ctx);  if( p->nErr ) break;  if( argc>2 ){  jsonAppendSeparator(&jx);  if( pNode ){  jsonRenderNode(pNode, &jx, 0);  }else{  jsonAppendRaw(&jx, "null", 4);  }  }else if( pNode ){  jsonReturn(pNode, ctx, 0);  }  }  if( argc>2 && i==argc ){  jsonAppendChar(&jx, ']');  jsonResult(&jx);  sqlite3_result_subtype(ctx, JSON_SUBTYPE);  }  jsonReset(&jx); } static JsonNode *jsonMergePatch(  JsonParse *pParse,  u32 iTarget,  JsonNode *pPatch ){  u32 i, j;  u32 iRoot;  JsonNode *pTarget;  if( pPatch->eType!=JSON_OBJECT ){  return pPatch;  }  assert( iTarget>=0 && iTarget<pParse->nNode );  pTarget = &pParse->aNode[iTarget];  assert( (pPatch->jnFlags & JNODE_APPEND)==0 );  if( pTarget->eType!=JSON_OBJECT ){  jsonRemoveAllNulls(pPatch);  return pPatch;  }  iRoot = iTarget;  for(i=1; i<pPatch->n; i += jsonNodeSize(&pPatch[i+1])+1){  u32 nKey;  const char *zKey;  assert( pPatch[i].eType==JSON_STRING );  assert( pPatch[i].jnFlags & JNODE_LABEL );  assert( pPatch[i].eU==1 );  nKey = pPatch[i].n;  zKey = pPatch[i].u.zJContent;  assert( (pPatch[i].jnFlags & JNODE_RAW)==0 );  for(j=1; j<pTarget->n; j += jsonNodeSize(&pTarget[j+1])+1 ){  assert( pTarget[j].eType==JSON_STRING );  assert( pTarget[j].jnFlags & JNODE_LABEL );  assert( (pPatch[i].jnFlags & JNODE_RAW)==0 );  if( pTarget[j].n==nKey && strncmp(pTarget[j].u.zJContent,zKey,nKey)==0 ){  if( pTarget[j+1].jnFlags & (JNODE_REMOVE|JNODE_PATCH) ) break;  if( pPatch[i+1].eType==JSON_NULL ){  pTarget[j+1].jnFlags |= JNODE_REMOVE;  }else{  JsonNode *pNew = jsonMergePatch(pParse, iTarget+j+1, &pPatch[i+1]);  if( pNew==0 ) return 0;  pTarget = &pParse->aNode[iTarget];  if( pNew!=&pTarget[j+1] ){  assert( pTarget[j+1].eU==0   || pTarget[j+1].eU==1   || pTarget[j+1].eU==2 );  testcase( pTarget[j+1].eU==1 );  testcase( pTarget[j+1].eU==2 );  VVA( pTarget[j+1].eU = 5 );  pTarget[j+1].u.pPatch = pNew;  pTarget[j+1].jnFlags |= JNODE_PATCH;  }  }  break;  }  }  if( j>=pTarget->n && pPatch[i+1].eType!=JSON_NULL ){  int iStart, iPatch;  iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);  jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);  iPatch = jsonParseAddNode(pParse, JSON_TRUE, 0, 0);  if( pParse->oom ) return 0;  jsonRemoveAllNulls(pPatch);  pTarget = &pParse->aNode[iTarget];  assert( pParse->aNode[iRoot].eU==0 || pParse->aNode[iRoot].eU==2 );  testcase( pParse->aNode[iRoot].eU==2 );  pParse->aNode[iRoot].jnFlags |= JNODE_APPEND;  VVA( pParse->aNode[iRoot].eU = 2 );  pParse->aNode[iRoot].u.iAppend = iStart - iRoot;  iRoot = iStart;  assert( pParse->aNode[iPatch].eU==0 );  VVA( pParse->aNode[iPatch].eU = 5 );  pParse->aNode[iPatch].jnFlags |= JNODE_PATCH;  pParse->aNode[iPatch].u.pPatch = &pPatch[i+1];  }  }  return pTarget; } static void jsonPatchFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse x;  JsonParse y;  JsonNode *pResult;  UNUSED_PARAM(argc);  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;  if( jsonParse(&y, ctx, (const char*)sqlite3_value_text(argv[1])) ){  jsonParseReset(&x);  return;  }  pResult = jsonMergePatch(&x, 0, y.aNode);  assert( pResult!=0 || x.oom );  if( pResult ){  jsonReturnJson(pResult, ctx, 0);  }else{  sqlite3_result_error_nomem(ctx);  }  jsonParseReset(&x);  jsonParseReset(&y); } static void jsonObjectFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  int i;  JsonString jx;  const char *z;  u32 n;  if( argc&1 ){  sqlite3_result_error(ctx, "json_object() requires an even number "  "of arguments", -1);  return;  }  jsonInit(&jx, ctx);  jsonAppendChar(&jx, '{');  for(i=0; i<argc; i+=2){  if( sqlite3_value_type(argv[i])!=SQLITE_TEXT ){  sqlite3_result_error(ctx, "json_object() labels must be TEXT", -1);  jsonReset(&jx);  return;  }  jsonAppendSeparator(&jx);  z = (const char*)sqlite3_value_text(argv[i]);  n = (u32)sqlite3_value_bytes(argv[i]);  jsonAppendString(&jx, z, n);  jsonAppendChar(&jx, ':');  jsonAppendValue(&jx, argv[i+1]);  }  jsonAppendChar(&jx, '}');  jsonResult(&jx);  sqlite3_result_subtype(ctx, JSON_SUBTYPE); } static void jsonRemoveFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse x;  JsonNode *pNode;  const char *zPath;  u32 i;  if( argc<1 ) return;  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;  assert( x.nNode );  for(i=1; i<(u32)argc; i++){  zPath = (const char*)sqlite3_value_text(argv[i]);  if( zPath==0 ) goto remove_done;  pNode = jsonLookup(&x, zPath, 0, ctx);  if( x.nErr ) goto remove_done;  if( pNode ) pNode->jnFlags |= JNODE_REMOVE;  }  if( (x.aNode[0].jnFlags & JNODE_REMOVE)==0 ){  jsonReturnJson(x.aNode, ctx, 0);  } remove_done:  jsonParseReset(&x); } static void jsonReplaceFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse x;  JsonNode *pNode;  const char *zPath;  u32 i;  if( argc<1 ) return;  if( (argc&1)==0 ) {  jsonWrongNumArgs(ctx, "replace");  return;  }  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;  assert( x.nNode );  for(i=1; i<(u32)argc; i+=2){  zPath = (const char*)sqlite3_value_text(argv[i]);  pNode = jsonLookup(&x, zPath, 0, ctx);  if( x.nErr ) goto replace_err;  if( pNode ){  assert( pNode->eU==0 || pNode->eU==1 || pNode->eU==4 );  json_testcase( pNode->eU!=0 && pNode->eU!=1 );  pNode->jnFlags |= (u8)JNODE_REPLACE;  VVA( pNode->eU = 4 );  pNode->u.iReplace = i + 1;  }  }  if( x.aNode[0].jnFlags & JNODE_REPLACE ){  assert( x.aNode[0].eU==4 );  sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);  }else{  jsonReturnJson(x.aNode, ctx, argv);  } replace_err:  jsonParseReset(&x); } static void jsonSetFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse x;  JsonNode *pNode;  const char *zPath;  u32 i;  int bApnd;  int bIsSet = *(int*)sqlite3_user_data(ctx);  if( argc<1 ) return;  if( (argc&1)==0 ) {  jsonWrongNumArgs(ctx, bIsSet ? "set" : "insert");  return;  }  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;  assert( x.nNode );  for(i=1; i<(u32)argc; i+=2){  zPath = (const char*)sqlite3_value_text(argv[i]);  bApnd = 0;  pNode = jsonLookup(&x, zPath, &bApnd, ctx);  if( x.oom ){  sqlite3_result_error_nomem(ctx);  goto jsonSetDone;  }else if( x.nErr ){  goto jsonSetDone;  }else if( pNode && (bApnd || bIsSet) ){  json_testcase( pNode->eU!=0 && pNode->eU!=1 && pNode->eU!=4 );  assert( pNode->eU!=3 || pNode->eU!=5 );  VVA( pNode->eU = 4 );  pNode->jnFlags |= (u8)JNODE_REPLACE;  pNode->u.iReplace = i + 1;  }  }  if( x.aNode[0].jnFlags & JNODE_REPLACE ){  assert( x.aNode[0].eU==4 );  sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);  }else{  jsonReturnJson(x.aNode, ctx, argv);  } jsonSetDone:  jsonParseReset(&x); } static void jsonTypeFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse *p;  const char *zPath;  JsonNode *pNode;  p = jsonParseCached(ctx, argv, ctx);  if( p==0 ) return;  if( argc==2 ){  zPath = (const char*)sqlite3_value_text(argv[1]);  pNode = jsonLookup(p, zPath, 0, ctx);  }else{  pNode = p->aNode;  }  if( pNode ){  sqlite3_result_text(ctx, jsonType[pNode->eType], -1, SQLITE_STATIC);  } } static void jsonValidFunc(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonParse *p;  UNUSED_PARAM(argc);  p = jsonParseCached(ctx, argv, 0);  sqlite3_result_int(ctx, p!=0); } static void jsonArrayStep(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonString *pStr;  UNUSED_PARAM(argc);  pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));  if( pStr ){  if( pStr->zBuf==0 ){  jsonInit(pStr, ctx);  jsonAppendChar(pStr, '[');  }else if( pStr->nUsed>1 ){  jsonAppendChar(pStr, ',');  }  pStr->pCtx = ctx;  jsonAppendValue(pStr, argv[0]);  } } static void jsonArrayCompute(sqlite3_context *ctx, int isFinal){  JsonString *pStr;  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);  if( pStr ){  pStr->pCtx = ctx;  jsonAppendChar(pStr, ']');  if( pStr->bErr ){  if( pStr->bErr==1 ) sqlite3_result_error_nomem(ctx);  assert( pStr->bStatic );  }else if( isFinal ){  sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,  pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);  pStr->bStatic = 1;  }else{  sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, SQLITE_TRANSIENT);  pStr->nUsed--;  }  }else{  sqlite3_result_text(ctx, "[]", 2, SQLITE_STATIC);  }  sqlite3_result_subtype(ctx, JSON_SUBTYPE); } static void jsonArrayValue(sqlite3_context *ctx){  jsonArrayCompute(ctx, 0); } static void jsonArrayFinal(sqlite3_context *ctx){  jsonArrayCompute(ctx, 1); }
#ifndef SQLITE_OMIT_WINDOWFUNC
static void jsonGroupInverse(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  unsigned int i;  int inStr = 0;  int nNest = 0;  char *z;  char c;  JsonString *pStr;  UNUSED_PARAM(argc);  UNUSED_PARAM(argv);  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);
#ifdef NEVER
 if( NEVER(!pStr) ) return;
#endif
 z = pStr->zBuf;  for(i=1; i<pStr->nUsed && ((c = z[i])!=',' || inStr || nNest); i++){  if( c=='"' ){  inStr = !inStr;  }else if( c=='\\' ){  i++;  }else if( !inStr ){  if( c=='{' || c=='[' ) nNest++;  if( c=='}' || c==']' ) nNest--;  }  }  if( i<pStr->nUsed ){  pStr->nUsed -= i;  memmove(&z[1], &z[i+1], (size_t)pStr->nUsed-1);  z[pStr->nUsed] = 0;  }else{  pStr->nUsed = 1;  } }
#else
# define jsonGroupInverse 0
#endif
static void jsonObjectStep(  sqlite3_context *ctx,  int argc,  sqlite3_value **argv ){  JsonString *pStr;  const char *z;  u32 n;  UNUSED_PARAM(argc);  pStr = (JsonString*)sqlite3_aggregate_context(ctx, sizeof(*pStr));  if( pStr ){  if( pStr->zBuf==0 ){  jsonInit(pStr, ctx);  jsonAppendChar(pStr, '{');  }else if( pStr->nUsed>1 ){  jsonAppendChar(pStr, ',');  }  pStr->pCtx = ctx;  z = (const char*)sqlite3_value_text(argv[0]);  n = (u32)sqlite3_value_bytes(argv[0]);  jsonAppendString(pStr, z, n);  jsonAppendChar(pStr, ':');  jsonAppendValue(pStr, argv[1]);  } } static void jsonObjectCompute(sqlite3_context *ctx, int isFinal){  JsonString *pStr;  pStr = (JsonString*)sqlite3_aggregate_context(ctx, 0);  if( pStr ){  jsonAppendChar(pStr, '}');  if( pStr->bErr ){  if( pStr->bErr==1 ) sqlite3_result_error_nomem(ctx);  assert( pStr->bStatic );  }else if( isFinal ){  sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed,  pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);  pStr->bStatic = 1;  }else{  sqlite3_result_text(ctx, pStr->zBuf, (int)pStr->nUsed, SQLITE_TRANSIENT);  pStr->nUsed--;  }  }else{  sqlite3_result_text(ctx, "{}", 2, SQLITE_STATIC);  }  sqlite3_result_subtype(ctx, JSON_SUBTYPE); } static void jsonObjectValue(sqlite3_context *ctx){  jsonObjectCompute(ctx, 0); } static void jsonObjectFinal(sqlite3_context *ctx){  jsonObjectCompute(ctx, 1); }
#ifndef SQLITE_OMIT_VIRTUALTABLE
typedef struct JsonEachCursor JsonEachCursor; struct JsonEachCursor {  sqlite3_vtab_cursor base;  u32 iRowid;  u32 iBegin;  u32 i;  u32 iEnd;  u8 eType;  u8 bRecursive;  char *zJson;  char *zRoot;  JsonParse sParse; }; static int jsonEachConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  sqlite3_vtab *pNew;  int rc;
#define JEACH_KEY  0
#define JEACH_VALUE  1
#define JEACH_TYPE 2
#define JEACH_ATOM 3
#define JEACH_ID 4
#define JEACH_PARENT 5
#define JEACH_FULLKEY 6
#define JEACH_PATH 7
#define JEACH_JSON 8
#define JEACH_ROOT 9
 UNUSED_PARAM(pzErr);  UNUSED_PARAM(argv);  UNUSED_PARAM(argc);  UNUSED_PARAM(pAux);  rc = sqlite3_declare_vtab(db,   "CREATE TABLE x(key,value,type,atom,id,parent,fullkey,path,"  "json HIDDEN,root HIDDEN)");  if( rc==SQLITE_OK ){  pNew = *ppVtab = sqlite3_malloc( sizeof(*pNew) );  if( pNew==0 ) return SQLITE_NOMEM;  memset(pNew, 0, sizeof(*pNew));  sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);  }  return rc; } static int jsonEachDisconnect(sqlite3_vtab *pVtab){  sqlite3_free(pVtab);  return SQLITE_OK; } static int jsonEachOpenEach(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){  JsonEachCursor *pCur;  UNUSED_PARAM(p);  pCur = sqlite3_malloc( sizeof(*pCur) );  if( pCur==0 ) return SQLITE_NOMEM;  memset(pCur, 0, sizeof(*pCur));  *ppCursor = &pCur->base;  return SQLITE_OK; } static int jsonEachOpenTree(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){  int rc = jsonEachOpenEach(p, ppCursor);  if( rc==SQLITE_OK ){  JsonEachCursor *pCur = (JsonEachCursor*)*ppCursor;  pCur->bRecursive = 1;  }  return rc; } static void jsonEachCursorReset(JsonEachCursor *p){  sqlite3_free(p->zJson);  sqlite3_free(p->zRoot);  jsonParseReset(&p->sParse);  p->iRowid = 0;  p->i = 0;  p->iEnd = 0;  p->eType = 0;  p->zJson = 0;  p->zRoot = 0; } static int jsonEachClose(sqlite3_vtab_cursor *cur){  JsonEachCursor *p = (JsonEachCursor*)cur;  jsonEachCursorReset(p);  sqlite3_free(cur);  return SQLITE_OK; } static int jsonEachEof(sqlite3_vtab_cursor *cur){  JsonEachCursor *p = (JsonEachCursor*)cur;  return p->i >= p->iEnd; } static int jsonEachNext(sqlite3_vtab_cursor *cur){  JsonEachCursor *p = (JsonEachCursor*)cur;  if( p->bRecursive ){  if( p->sParse.aNode[p->i].jnFlags & JNODE_LABEL ) p->i++;  p->i++;  p->iRowid++;  if( p->i<p->iEnd ){  u32 iUp = p->sParse.aUp[p->i];  JsonNode *pUp = &p->sParse.aNode[iUp];  p->eType = pUp->eType;  if( pUp->eType==JSON_ARRAY ){  assert( pUp->eU==0 || pUp->eU==3 );  json_testcase( pUp->eU==3 );  VVA( pUp->eU = 3 );  if( iUp==p->i-1 ){  pUp->u.iKey = 0;  }else{  pUp->u.iKey++;  }  }  }  }else{  switch( p->eType ){  case JSON_ARRAY: {  p->i += jsonNodeSize(&p->sParse.aNode[p->i]);  p->iRowid++;  break;  }  case JSON_OBJECT: {  p->i += 1 + jsonNodeSize(&p->sParse.aNode[p->i+1]);  p->iRowid++;  break;  }  default: {  p->i = p->iEnd;  break;  }  }  }  return SQLITE_OK; } static void jsonEachComputePath(  JsonEachCursor *p,  JsonString *pStr,  u32 i ){  JsonNode *pNode, *pUp;  u32 iUp;  if( i==0 ){  jsonAppendChar(pStr, '$');  return;  }  iUp = p->sParse.aUp[i];  jsonEachComputePath(p, pStr, iUp);  pNode = &p->sParse.aNode[i];  pUp = &p->sParse.aNode[iUp];  if( pUp->eType==JSON_ARRAY ){  assert( pUp->eU==3 || (pUp->eU==0 && pUp->u.iKey==0) );  testcase( pUp->eU==0 );  jsonPrintf(30, pStr, "[%d]", pUp->u.iKey);  }else{  assert( pUp->eType==JSON_OBJECT );  if( (pNode->jnFlags & JNODE_LABEL)==0 ) pNode--;  assert( pNode->eType==JSON_STRING );  assert( pNode->jnFlags & JNODE_LABEL );  assert( pNode->eU==1 );  jsonPrintf(pNode->n+1, pStr, ".%.*s", pNode->n-2, pNode->u.zJContent+1);  } } static int jsonEachColumn(  sqlite3_vtab_cursor *cur,  sqlite3_context *ctx,  int i ){  JsonEachCursor *p = (JsonEachCursor*)cur;  JsonNode *pThis = &p->sParse.aNode[p->i];  switch( i ){  case JEACH_KEY: {  if( p->i==0 ) break;  if( p->eType==JSON_OBJECT ){  jsonReturn(pThis, ctx, 0);  }else if( p->eType==JSON_ARRAY ){  u32 iKey;  if( p->bRecursive ){  if( p->iRowid==0 ) break;  assert( p->sParse.aNode[p->sParse.aUp[p->i]].eU==3 );  iKey = p->sParse.aNode[p->sParse.aUp[p->i]].u.iKey;  }else{  iKey = p->iRowid;  }  sqlite3_result_int64(ctx, (sqlite3_int64)iKey);  }  break;  }  case JEACH_VALUE: {  if( pThis->jnFlags & JNODE_LABEL ) pThis++;  jsonReturn(pThis, ctx, 0);  break;  }  case JEACH_TYPE: {  if( pThis->jnFlags & JNODE_LABEL ) pThis++;  sqlite3_result_text(ctx, jsonType[pThis->eType], -1, SQLITE_STATIC);  break;  }  case JEACH_ATOM: {  if( pThis->jnFlags & JNODE_LABEL ) pThis++;  if( pThis->eType>=JSON_ARRAY ) break;  jsonReturn(pThis, ctx, 0);  break;  }  case JEACH_ID: {  sqlite3_result_int64(ctx,   (sqlite3_int64)p->i + ((pThis->jnFlags & JNODE_LABEL)!=0));  break;  }  case JEACH_PARENT: {  if( p->i>p->iBegin && p->bRecursive ){  sqlite3_result_int64(ctx, (sqlite3_int64)p->sParse.aUp[p->i]);  }  break;  }  case JEACH_FULLKEY: {  JsonString x;  jsonInit(&x, ctx);  if( p->bRecursive ){  jsonEachComputePath(p, &x, p->i);  }else{  if( p->zRoot ){  jsonAppendRaw(&x, p->zRoot, (int)strlen(p->zRoot));  }else{  jsonAppendChar(&x, '$');  }  if( p->eType==JSON_ARRAY ){  jsonPrintf(30, &x, "[%d]", p->iRowid);  }else if( p->eType==JSON_OBJECT ){  assert( pThis->eU==1 );  jsonPrintf(pThis->n, &x, ".%.*s", pThis->n-2, pThis->u.zJContent+1);  }  }  jsonResult(&x);  break;  }  case JEACH_PATH: {  if( p->bRecursive ){  JsonString x;  jsonInit(&x, ctx);  jsonEachComputePath(p, &x, p->sParse.aUp[p->i]);  jsonResult(&x);  break;  }  deliberate_fall_through  }  default: {  const char *zRoot = p->zRoot;  if( zRoot==0 ) zRoot = "$";  sqlite3_result_text(ctx, zRoot, -1, SQLITE_STATIC);  break;  }  case JEACH_JSON: {  assert( i==JEACH_JSON );  sqlite3_result_text(ctx, p->sParse.zJson, -1, SQLITE_STATIC);  break;  }  }  return SQLITE_OK; } static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){  JsonEachCursor *p = (JsonEachCursor*)cur;  *pRowid = p->iRowid;  return SQLITE_OK; } static int jsonEachBestIndex(  sqlite3_vtab *tab,  sqlite3_index_info *pIdxInfo ){  int i;  int aIdx[2];  int unusableMask = 0;  int idxMask = 0;  const struct sqlite3_index_constraint *pConstraint;  assert( JEACH_ROOT == JEACH_JSON+1 );  UNUSED_PARAM(tab);  aIdx[0] = aIdx[1] = -1;  pConstraint = pIdxInfo->aConstraint;  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){  int iCol;  int iMask;  if( pConstraint->iColumn < JEACH_JSON ) continue;  iCol = pConstraint->iColumn - JEACH_JSON;  assert( iCol==0 || iCol==1 );  testcase( iCol==0 );  iMask = 1 << iCol;  if( pConstraint->usable==0 ){  unusableMask |= iMask;  }else if( pConstraint->op==SQLITE_INDEX_CONSTRAINT_EQ ){  aIdx[iCol] = i;  idxMask |= iMask;  }  }  if( (unusableMask & ~idxMask)!=0 ){  return SQLITE_CONSTRAINT;  }  if( aIdx[0]<0 ){  pIdxInfo->idxNum = 0;  }else{  pIdxInfo->estimatedCost = 1.0;  i = aIdx[0];  pIdxInfo->aConstraintUsage[i].argvIndex = 1;  pIdxInfo->aConstraintUsage[i].omit = 1;  if( aIdx[1]<0 ){  pIdxInfo->idxNum = 1;  }else{  i = aIdx[1];  pIdxInfo->aConstraintUsage[i].argvIndex = 2;  pIdxInfo->aConstraintUsage[i].omit = 1;  pIdxInfo->idxNum = 3;  }  }  return SQLITE_OK; } static int jsonEachFilter(  sqlite3_vtab_cursor *cur,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  JsonEachCursor *p = (JsonEachCursor*)cur;  const char *z;  const char *zRoot = 0;  sqlite3_int64 n;  UNUSED_PARAM(idxStr);  UNUSED_PARAM(argc);  jsonEachCursorReset(p);  if( idxNum==0 ) return SQLITE_OK;  z = (const char*)sqlite3_value_text(argv[0]);  if( z==0 ) return SQLITE_OK;  n = sqlite3_value_bytes(argv[0]);  p->zJson = sqlite3_malloc64( n+1 );  if( p->zJson==0 ) return SQLITE_NOMEM;  memcpy(p->zJson, z, (size_t)n+1);  if( jsonParse(&p->sParse, 0, p->zJson) ){  int rc = SQLITE_NOMEM;  if( p->sParse.oom==0 ){  sqlite3_free(cur->pVtab->zErrMsg);  cur->pVtab->zErrMsg = sqlite3_mprintf("malformed JSON");  if( cur->pVtab->zErrMsg ) rc = SQLITE_ERROR;  }  jsonEachCursorReset(p);  return rc;  }else if( p->bRecursive && jsonParseFindParents(&p->sParse) ){  jsonEachCursorReset(p);  return SQLITE_NOMEM;  }else{  JsonNode *pNode = 0;  if( idxNum==3 ){  const char *zErr = 0;  zRoot = (const char*)sqlite3_value_text(argv[1]);  if( zRoot==0 ) return SQLITE_OK;  n = sqlite3_value_bytes(argv[1]);  p->zRoot = sqlite3_malloc64( n+1 );  if( p->zRoot==0 ) return SQLITE_NOMEM;  memcpy(p->zRoot, zRoot, (size_t)n+1);  if( zRoot[0]!='$' ){  zErr = zRoot;  }else{  pNode = jsonLookupStep(&p->sParse, 0, p->zRoot+1, 0, &zErr);  }  if( zErr ){  sqlite3_free(cur->pVtab->zErrMsg);  cur->pVtab->zErrMsg = jsonPathSyntaxError(zErr);  jsonEachCursorReset(p);  return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;  }else if( pNode==0 ){  return SQLITE_OK;  }  }else{  pNode = p->sParse.aNode;  }  p->iBegin = p->i = (int)(pNode - p->sParse.aNode);  p->eType = pNode->eType;  if( p->eType>=JSON_ARRAY ){  assert( pNode->eU==0 );  VVA( pNode->eU = 3 );  pNode->u.iKey = 0;  p->iEnd = p->i + pNode->n + 1;  if( p->bRecursive ){  p->eType = p->sParse.aNode[p->sParse.aUp[p->i]].eType;  if( p->i>0 && (p->sParse.aNode[p->i-1].jnFlags & JNODE_LABEL)!=0 ){  p->i--;  }  }else{  p->i++;  }  }else{  p->iEnd = p->i+1;  }  }  return SQLITE_OK; } static sqlite3_module jsonEachModule = {  0,  0,  jsonEachConnect,  jsonEachBestIndex,  jsonEachDisconnect,  0,  jsonEachOpenEach,  jsonEachClose,  jsonEachFilter,  jsonEachNext,  jsonEachEof,  jsonEachColumn,  jsonEachRowid,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 }; static sqlite3_module jsonTreeModule = {  0,  0,  jsonEachConnect,  jsonEachBestIndex,  jsonEachDisconnect,  0,  jsonEachOpenTree,  jsonEachClose,  jsonEachFilter,  jsonEachNext,  jsonEachEof,  jsonEachColumn,  jsonEachRowid,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 };
#endif
SQLITE_PRIVATE int sqlite3Json1Init(sqlite3 *db){  int rc = SQLITE_OK;  unsigned int i;  static const struct {   const char *zName;   int nArg;   int flag;   void (*xFunc)(sqlite3_context*,int,sqlite3_value**);  } aFunc[] = {  { "json", 1, 0, jsonRemoveFunc },  { "json_array", -1, 0, jsonArrayFunc  },  { "json_array_length", 1, 0, jsonArrayLengthFunc  },  { "json_array_length", 2, 0, jsonArrayLengthFunc  },  { "json_extract", -1, 0, jsonExtractFunc  },  { "json_insert", -1, 0, jsonSetFunc  },  { "json_object", -1, 0, jsonObjectFunc },  { "json_patch", 2, 0, jsonPatchFunc  },  { "json_quote", 1, 0, jsonQuoteFunc  },  { "json_remove", -1, 0, jsonRemoveFunc },  { "json_replace", -1, 0, jsonReplaceFunc  },  { "json_set", -1, 1, jsonSetFunc  },  { "json_type", 1, 0, jsonTypeFunc },  { "json_type", 2, 0, jsonTypeFunc },  { "json_valid", 1, 0, jsonValidFunc  },
#if SQLITE_DEBUG
 { "json_parse", 1, 0, jsonParseFunc  },  { "json_test1", 1, 0, jsonTest1Func  },
#endif
 };  static const struct {   const char *zName;   int nArg;   void (*xStep)(sqlite3_context*,int,sqlite3_value**);   void (*xFinal)(sqlite3_context*);   void (*xValue)(sqlite3_context*);  } aAgg[] = {  { "json_group_array", 1,  jsonArrayStep, jsonArrayFinal, jsonArrayValue },  { "json_group_object", 2,  jsonObjectStep, jsonObjectFinal, jsonObjectValue },  };
#ifndef SQLITE_OMIT_VIRTUALTABLE
 static const struct {   const char *zName;   sqlite3_module *pModule;  } aMod[] = {  { "json_each", &jsonEachModule  },  { "json_tree", &jsonTreeModule  },  };
#endif
 static const int enc =   SQLITE_UTF8 |   SQLITE_DETERMINISTIC |   SQLITE_INNOCUOUS;  for(i=0; i<sizeof(aFunc)/sizeof(aFunc[0]) && rc==SQLITE_OK; i++){  rc = sqlite3_create_function(db, aFunc[i].zName, aFunc[i].nArg, enc,   (void*)&aFunc[i].flag,   aFunc[i].xFunc, 0, 0);  }
#ifndef SQLITE_OMIT_WINDOWFUNC
 for(i=0; i<sizeof(aAgg)/sizeof(aAgg[0]) && rc==SQLITE_OK; i++){  rc = sqlite3_create_window_function(db, aAgg[i].zName, aAgg[i].nArg,   SQLITE_SUBTYPE | enc, 0,   aAgg[i].xStep, aAgg[i].xFinal,   aAgg[i].xValue, jsonGroupInverse, 0);  }
#endif
#ifndef SQLITE_OMIT_VIRTUALTABLE
 for(i=0; i<sizeof(aMod)/sizeof(aMod[0]) && rc==SQLITE_OK; i++){  rc = sqlite3_create_module(db, aMod[i].zName, aMod[i].pModule, 0);  }
#endif
 return rc; }
#ifndef SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_json_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  SQLITE_EXTENSION_INIT2(pApi);  (void)pzErrMsg;  return sqlite3Json1Init(db); }
#endif
#endif
#if !defined(SQLITE_CORE)  || (defined(SQLITE_ENABLE_RTREE) && !defined(SQLITE_OMIT_VIRTUALTABLE))

#ifndef SQLITE_CORE
 SQLITE_EXTENSION_INIT1
#else
#endif
SQLITE_PRIVATE int sqlite3GetToken(const unsigned char*,int*);
#if !defined(SQLITE_AMALGAMATION)
#include "sqlite3rtree.h"
typedef sqlite3_int64 i64; typedef sqlite3_uint64 u64; typedef unsigned char u8; typedef unsigned short u16; typedef unsigned int u32;
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
# define NDEBUG 1
#endif
#if defined(NDEBUG) && defined(SQLITE_DEBUG)
# undef NDEBUG
#endif
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1
#endif
#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)
# define ALWAYS(X) (1)
# define NEVER(X)  (0)
#elif !defined(NDEBUG)
# define ALWAYS(X) ((X)?1:(assert(0),0))
# define NEVER(X)  ((X)?(assert(0),1):0)
#else
# define ALWAYS(X) (X)
# define NEVER(X)  (X)
#endif
#endif
#ifndef UNUSED_PARAMETER
# define UNUSED_PARAMETER(x) (void)(x)
#endif
typedef struct Rtree Rtree; typedef struct RtreeCursor RtreeCursor; typedef struct RtreeNode RtreeNode; typedef struct RtreeCell RtreeCell; typedef struct RtreeConstraint RtreeConstraint; typedef struct RtreeMatchArg RtreeMatchArg; typedef struct RtreeGeomCallback RtreeGeomCallback; typedef union RtreeCoord RtreeCoord; typedef struct RtreeSearchPoint RtreeSearchPoint;
#define RTREE_MAX_DIMENSIONS 5
#define RTREE_MAX_AUX_COLUMN 100
#define HASHSIZE 97
#define RTREE_DEFAULT_ROWEST 1048576
#define RTREE_MIN_ROWEST  100
struct Rtree {  sqlite3_vtab base;  sqlite3 *db;  int iNodeSize;  u8 nDim;  u8 nDim2;  u8 eCoordType;  u8 nBytesPerCell;  u8 inWrTrans;  u8 nAux;
#ifdef SQLITE_ENABLE_GEOPOLY
 u8 nAuxNotNull;
#endif
#ifdef SQLITE_DEBUG
 u8 bCorrupt;
#endif
 int iDepth;  char *zDb;  char *zName;  u32 nBusy;  i64 nRowEst;  u32 nCursor;  u32 nNodeRef;  char *zReadAuxSql;  RtreeNode *pDeleted;  int iReinsertHeight;  sqlite3_blob *pNodeBlob;  sqlite3_stmt *pWriteNode;  sqlite3_stmt *pDeleteNode;  sqlite3_stmt *pReadRowid;  sqlite3_stmt *pWriteRowid;  sqlite3_stmt *pDeleteRowid;  sqlite3_stmt *pReadParent;  sqlite3_stmt *pWriteParent;  sqlite3_stmt *pDeleteParent;  sqlite3_stmt *pWriteAux;  RtreeNode *aHash[HASHSIZE]; };
#define RTREE_COORD_REAL32 0
#define RTREE_COORD_INT32 1
#ifdef SQLITE_RTREE_INT_ONLY
 typedef sqlite3_int64 RtreeDValue;  typedef int RtreeValue;
# define RTREE_ZERO 0
#else
 typedef double RtreeDValue;  typedef float RtreeValue;
# define RTREE_ZERO 0.0
#endif
#ifdef SQLITE_DEBUG
# define RTREE_IS_CORRUPT(X) ((X)->bCorrupt = 1)
#else
# define RTREE_IS_CORRUPT(X)
#endif
struct RtreeSearchPoint {  RtreeDValue rScore;  sqlite3_int64 id;  u8 iLevel;  u8 eWithin;  u8 iCell; };
#define RTREE_MINCELLS(p) ((((p)->iNodeSize-4)/(p)->nBytesPerCell)/3)
#define RTREE_REINSERT(p) RTREE_MINCELLS(p)
#define RTREE_MAXCELLS 51
#define RTREE_MAX_DEPTH 40
#define RTREE_CACHE_SZ 5
struct RtreeCursor {  sqlite3_vtab_cursor base;  u8 atEOF;  u8 bPoint;  u8 bAuxValid;  int iStrategy;  int nConstraint;  RtreeConstraint *aConstraint;  int nPointAlloc;  int nPoint;  int mxLevel;  RtreeSearchPoint *aPoint;  sqlite3_stmt *pReadAux;  RtreeSearchPoint sPoint;  RtreeNode *aNode[RTREE_CACHE_SZ];  u32 anQueue[RTREE_MAX_DEPTH+1]; };
#define RTREE_OF_CURSOR(X)  ((Rtree*)((X)->base.pVtab))
union RtreeCoord {  RtreeValue f;  int i;  u32 u; };
#ifdef SQLITE_RTREE_INT_ONLY
# define DCOORD(coord) ((RtreeDValue)coord.i)
#else
# define DCOORD(coord) (   (pRtree->eCoordType==RTREE_COORD_REAL32) ?  ((double)coord.f) :   ((double)coord.i)   )

#endif
struct RtreeConstraint {  int iCoord;  int op;  union {  RtreeDValue rValue;  int (*xGeom)(sqlite3_rtree_geometry*,int,RtreeDValue*,int*);  int (*xQueryFunc)(sqlite3_rtree_query_info*);  } u;  sqlite3_rtree_query_info *pInfo; };
#define RTREE_EQ 0x41
#define RTREE_LE 0x42
#define RTREE_LT 0x43
#define RTREE_GE 0x44
#define RTREE_GT 0x45
#define RTREE_MATCH 0x46
#define RTREE_QUERY 0x47
#define RTREE_TRUE 0x3f
#define RTREE_FALSE 0x40
struct RtreeNode {  RtreeNode *pParent;  i64 iNode;  int nRef;  int isDirty;  u8 *zData;  RtreeNode *pNext; };
#define NCELL(pNode) readInt16(&(pNode)->zData[2])
struct RtreeCell {  i64 iRowid;  RtreeCoord aCoord[RTREE_MAX_DIMENSIONS*2]; }; struct RtreeGeomCallback {  int (*xGeom)(sqlite3_rtree_geometry*, int, RtreeDValue*, int*);  int (*xQueryFunc)(sqlite3_rtree_query_info*);  void (*xDestructor)(void*);  void *pContext; }; struct RtreeMatchArg {  u32 iSize;  RtreeGeomCallback cb;  int nParam;  sqlite3_value **apSqlParam;  RtreeDValue aParam[1]; };
#ifndef MAX
# define MAX(x,y) ((x) < (y) ? (y) : (x))
#endif
#ifndef MIN
# define MIN(x,y) ((x) > (y) ? (y) : (x))
#endif
#ifndef GCC_VERSION
#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)
# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)
#else
# define GCC_VERSION 0
#endif
#endif
#ifndef SQLITE_AMALGAMATION
# if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)
 unsigned int sqlite3RtreeTestcase = 0;
#  define testcase(X) if( X ){ sqlite3RtreeTestcase += __LINE__; }
# else
#  define testcase(X)
# endif
#endif
#if !defined(SQLITE_DISABLE_INTRINSIC)
# if defined(_MSC_VER) && _MSC_VER>=1400
# if !defined(_WIN32_WCE)
# pragma intrinsic(_byteswap_ulong)
# pragma intrinsic(_byteswap_uint64)
# else
# endif
# endif
#endif
#ifndef SQLITE_BYTEORDER
#if defined(i386)  || defined(__i386__)  || defined(_M_IX86) ||  defined(__x86_64) || defined(__x86_64__) || defined(_M_X64) ||  defined(_M_AMD64) || defined(_M_ARM)  || defined(__x86)  ||  defined(__arm__)

# define SQLITE_BYTEORDER 1234
#elif defined(sparc) || defined(__ppc__)
# define SQLITE_BYTEORDER 4321
#else
# define SQLITE_BYTEORDER 0
#endif
#endif
#ifndef MSVC_VERSION
#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)
# define MSVC_VERSION _MSC_VER
#else
# define MSVC_VERSION 0
#endif
#endif
static int readInt16(u8 *p){  return (p[0]<<8) + p[1]; } static void readCoord(u8 *p, RtreeCoord *pCoord){  assert( ((((char*)p) - (char*)0)&3)==0 );
#if SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
 pCoord->u = _byteswap_ulong(*(u32*)p);
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
 pCoord->u = __builtin_bswap32(*(u32*)p);
#elif SQLITE_BYTEORDER==4321
 pCoord->u = *(u32*)p;
#else
 pCoord->u = (  (((u32)p[0]) << 24) +  (((u32)p[1]) << 16) +  (((u32)p[2]) << 8) +  (((u32)p[3]) << 0)  );
#endif
} static i64 readInt64(u8 *p){
#if SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
 u64 x;  memcpy(&x, p, 8);  return (i64)_byteswap_uint64(x);
#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
 u64 x;  memcpy(&x, p, 8);  return (i64)__builtin_bswap64(x);
#elif SQLITE_BYTEORDER==4321
 i64 x;  memcpy(&x, p, 8);  return x;
#else
 return (i64)(  (((u64)p[0]) << 56) +  (((u64)p[1]) << 48) +  (((u64)p[2]) << 40) +  (((u64)p[3]) << 32) +  (((u64)p[4]) << 24) +  (((u64)p[5]) << 16) +  (((u64)p[6]) << 8) +  (((u64)p[7]) << 0)  );
#endif
} static void writeInt16(u8 *p, int i){  p[0] = (i>> 8)&0xFF;  p[1] = (i>> 0)&0xFF; } static int writeCoord(u8 *p, RtreeCoord *pCoord){  u32 i;  assert( ((((char*)p) - (char*)0)&3)==0 );  assert( sizeof(RtreeCoord)==4 );  assert( sizeof(u32)==4 );
#if SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
 i = __builtin_bswap32(pCoord->u);  memcpy(p, &i, 4);
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
 i = _byteswap_ulong(pCoord->u);  memcpy(p, &i, 4);
#elif SQLITE_BYTEORDER==4321
 i = pCoord->u;  memcpy(p, &i, 4);
#else
 i = pCoord->u;  p[0] = (i>>24)&0xFF;  p[1] = (i>>16)&0xFF;  p[2] = (i>> 8)&0xFF;  p[3] = (i>> 0)&0xFF;
#endif
 return 4; } static int writeInt64(u8 *p, i64 i){
#if SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
 i = (i64)__builtin_bswap64((u64)i);  memcpy(p, &i, 8);
#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
 i = (i64)_byteswap_uint64((u64)i);  memcpy(p, &i, 8);
#elif SQLITE_BYTEORDER==4321
 memcpy(p, &i, 8);
#else
 p[0] = (i>>56)&0xFF;  p[1] = (i>>48)&0xFF;  p[2] = (i>>40)&0xFF;  p[3] = (i>>32)&0xFF;  p[4] = (i>>24)&0xFF;  p[5] = (i>>16)&0xFF;  p[6] = (i>> 8)&0xFF;  p[7] = (i>> 0)&0xFF;
#endif
 return 8; } static void nodeReference(RtreeNode *p){  if( p ){  assert( p->nRef>0 );  p->nRef++;  } } static void nodeZero(Rtree *pRtree, RtreeNode *p){  memset(&p->zData[2], 0, pRtree->iNodeSize-2);  p->isDirty = 1; } static unsigned int nodeHash(i64 iNode){  return ((unsigned)iNode) % HASHSIZE; } static RtreeNode *nodeHashLookup(Rtree *pRtree, i64 iNode){  RtreeNode *p;  for(p=pRtree->aHash[nodeHash(iNode)]; p && p->iNode!=iNode; p=p->pNext);  return p; } static void nodeHashInsert(Rtree *pRtree, RtreeNode *pNode){  int iHash;  assert( pNode->pNext==0 );  iHash = nodeHash(pNode->iNode);  pNode->pNext = pRtree->aHash[iHash];  pRtree->aHash[iHash] = pNode; } static void nodeHashDelete(Rtree *pRtree, RtreeNode *pNode){  RtreeNode **pp;  if( pNode->iNode!=0 ){  pp = &pRtree->aHash[nodeHash(pNode->iNode)];  for( ; (*pp)!=pNode; pp = &(*pp)->pNext){ assert(*pp); }  *pp = pNode->pNext;  pNode->pNext = 0;  } } static RtreeNode *nodeNew(Rtree *pRtree, RtreeNode *pParent){  RtreeNode *pNode;  pNode = (RtreeNode *)sqlite3_malloc64(sizeof(RtreeNode) + pRtree->iNodeSize);  if( pNode ){  memset(pNode, 0, sizeof(RtreeNode) + pRtree->iNodeSize);  pNode->zData = (u8 *)&pNode[1];  pNode->nRef = 1;  pRtree->nNodeRef++;  pNode->pParent = pParent;  pNode->isDirty = 1;  nodeReference(pParent);  }  return pNode; } static void nodeBlobReset(Rtree *pRtree){  if( pRtree->pNodeBlob && pRtree->inWrTrans==0 && pRtree->nCursor==0 ){  sqlite3_blob *pBlob = pRtree->pNodeBlob;  pRtree->pNodeBlob = 0;  sqlite3_blob_close(pBlob);  } } static int nodeAcquire(  Rtree *pRtree,  i64 iNode,  RtreeNode *pParent,  RtreeNode **ppNode ){  int rc = SQLITE_OK;  RtreeNode *pNode = 0;  if( (pNode = nodeHashLookup(pRtree, iNode))!=0 ){  if( pParent && pParent!=pNode->pParent ){  RTREE_IS_CORRUPT(pRtree);  return SQLITE_CORRUPT_VTAB;  }  pNode->nRef++;  *ppNode = pNode;  return SQLITE_OK;  }  if( pRtree->pNodeBlob ){  sqlite3_blob *pBlob = pRtree->pNodeBlob;  pRtree->pNodeBlob = 0;  rc = sqlite3_blob_reopen(pBlob, iNode);  pRtree->pNodeBlob = pBlob;  if( rc ){  nodeBlobReset(pRtree);  if( rc==SQLITE_NOMEM ) return SQLITE_NOMEM;  }  }  if( pRtree->pNodeBlob==0 ){  char *zTab = sqlite3_mprintf("%s_node", pRtree->zName);  if( zTab==0 ) return SQLITE_NOMEM;  rc = sqlite3_blob_open(pRtree->db, pRtree->zDb, zTab, "data", iNode, 0,   &pRtree->pNodeBlob);  sqlite3_free(zTab);  }  if( rc ){  nodeBlobReset(pRtree);  *ppNode = 0;  if( rc==SQLITE_ERROR ){  rc = SQLITE_CORRUPT_VTAB;  RTREE_IS_CORRUPT(pRtree);  }  }else if( pRtree->iNodeSize==sqlite3_blob_bytes(pRtree->pNodeBlob) ){  pNode = (RtreeNode *)sqlite3_malloc64(sizeof(RtreeNode)+pRtree->iNodeSize);  if( !pNode ){  rc = SQLITE_NOMEM;  }else{  pNode->pParent = pParent;  pNode->zData = (u8 *)&pNode[1];  pNode->nRef = 1;  pRtree->nNodeRef++;  pNode->iNode = iNode;  pNode->isDirty = 0;  pNode->pNext = 0;  rc = sqlite3_blob_read(pRtree->pNodeBlob, pNode->zData,   pRtree->iNodeSize, 0);  }  }  if( rc==SQLITE_OK && pNode && iNode==1 ){  pRtree->iDepth = readInt16(pNode->zData);  if( pRtree->iDepth>RTREE_MAX_DEPTH ){  rc = SQLITE_CORRUPT_VTAB;  RTREE_IS_CORRUPT(pRtree);  }  }  if( pNode && rc==SQLITE_OK ){  if( NCELL(pNode)>((pRtree->iNodeSize-4)/pRtree->nBytesPerCell) ){  rc = SQLITE_CORRUPT_VTAB;  RTREE_IS_CORRUPT(pRtree);  }  }  if( rc==SQLITE_OK ){  if( pNode!=0 ){  nodeReference(pParent);  nodeHashInsert(pRtree, pNode);  }else{  rc = SQLITE_CORRUPT_VTAB;  RTREE_IS_CORRUPT(pRtree);  }  *ppNode = pNode;  }else{  if( pNode ){  pRtree->nNodeRef--;  sqlite3_free(pNode);  }  *ppNode = 0;  }  return rc; } static void nodeOverwriteCell(  Rtree *pRtree,  RtreeNode *pNode,  RtreeCell *pCell,  int iCell ){  int ii;  u8 *p = &pNode->zData[4 + pRtree->nBytesPerCell*iCell];  p += writeInt64(p, pCell->iRowid);  for(ii=0; ii<pRtree->nDim2; ii++){  p += writeCoord(p, &pCell->aCoord[ii]);  }  pNode->isDirty = 1; } static void nodeDeleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell){  u8 *pDst = &pNode->zData[4 + pRtree->nBytesPerCell*iCell];  u8 *pSrc = &pDst[pRtree->nBytesPerCell];  int nByte = (NCELL(pNode) - iCell - 1) * pRtree->nBytesPerCell;  memmove(pDst, pSrc, nByte);  writeInt16(&pNode->zData[2], NCELL(pNode)-1);  pNode->isDirty = 1; } static int nodeInsertCell(  Rtree *pRtree,  RtreeNode *pNode,  RtreeCell *pCell ){  int nCell;  int nMaxCell;  nMaxCell = (pRtree->iNodeSize-4)/pRtree->nBytesPerCell;  nCell = NCELL(pNode);  assert( nCell<=nMaxCell );  if( nCell<nMaxCell ){  nodeOverwriteCell(pRtree, pNode, pCell, nCell);  writeInt16(&pNode->zData[2], nCell+1);  pNode->isDirty = 1;  }  return (nCell==nMaxCell); } static int nodeWrite(Rtree *pRtree, RtreeNode *pNode){  int rc = SQLITE_OK;  if( pNode->isDirty ){  sqlite3_stmt *p = pRtree->pWriteNode;  if( pNode->iNode ){  sqlite3_bind_int64(p, 1, pNode->iNode);  }else{  sqlite3_bind_null(p, 1);  }  sqlite3_bind_blob(p, 2, pNode->zData, pRtree->iNodeSize, SQLITE_STATIC);  sqlite3_step(p);  pNode->isDirty = 0;  rc = sqlite3_reset(p);  sqlite3_bind_null(p, 2);  if( pNode->iNode==0 && rc==SQLITE_OK ){  pNode->iNode = sqlite3_last_insert_rowid(pRtree->db);  nodeHashInsert(pRtree, pNode);  }  }  return rc; } static int nodeRelease(Rtree *pRtree, RtreeNode *pNode){  int rc = SQLITE_OK;  if( pNode ){  assert( pNode->nRef>0 );  assert( pRtree->nNodeRef>0 );  pNode->nRef--;  if( pNode->nRef==0 ){  pRtree->nNodeRef--;  if( pNode->iNode==1 ){  pRtree->iDepth = -1;  }  if( pNode->pParent ){  rc = nodeRelease(pRtree, pNode->pParent);  }  if( rc==SQLITE_OK ){  rc = nodeWrite(pRtree, pNode);  }  nodeHashDelete(pRtree, pNode);  sqlite3_free(pNode);  }  }  return rc; } static i64 nodeGetRowid(  Rtree *pRtree,  RtreeNode *pNode,  int iCell ){  assert( iCell<NCELL(pNode) );  return readInt64(&pNode->zData[4 + pRtree->nBytesPerCell*iCell]); } static void nodeGetCoord(  Rtree *pRtree,  RtreeNode *pNode,  int iCell,  int iCoord,  RtreeCoord *pCoord ){  readCoord(&pNode->zData[12 + pRtree->nBytesPerCell*iCell + 4*iCoord], pCoord); } static void nodeGetCell(  Rtree *pRtree,  RtreeNode *pNode,  int iCell,  RtreeCell *pCell ){  u8 *pData;  RtreeCoord *pCoord;  int ii = 0;  pCell->iRowid = nodeGetRowid(pRtree, pNode, iCell);  pData = pNode->zData + (12 + pRtree->nBytesPerCell*iCell);  pCoord = pCell->aCoord;  do{  readCoord(pData, &pCoord[ii]);  readCoord(pData+4, &pCoord[ii+1]);  pData += 8;  ii += 2;  }while( ii<pRtree->nDim2 ); } static int rtreeInit(  sqlite3 *, void *, int, const char *const*, sqlite3_vtab **, char **, int ); static int rtreeCreate(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 1); } static int rtreeConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 0); } static void rtreeReference(Rtree *pRtree){  pRtree->nBusy++; } static void rtreeRelease(Rtree *pRtree){  pRtree->nBusy--;  if( pRtree->nBusy==0 ){  pRtree->inWrTrans = 0;  assert( pRtree->nCursor==0 );  nodeBlobReset(pRtree);  assert( pRtree->nNodeRef==0 || pRtree->bCorrupt );  sqlite3_finalize(pRtree->pWriteNode);  sqlite3_finalize(pRtree->pDeleteNode);  sqlite3_finalize(pRtree->pReadRowid);  sqlite3_finalize(pRtree->pWriteRowid);  sqlite3_finalize(pRtree->pDeleteRowid);  sqlite3_finalize(pRtree->pReadParent);  sqlite3_finalize(pRtree->pWriteParent);  sqlite3_finalize(pRtree->pDeleteParent);  sqlite3_finalize(pRtree->pWriteAux);  sqlite3_free(pRtree->zReadAuxSql);  sqlite3_free(pRtree);  } } static int rtreeDisconnect(sqlite3_vtab *pVtab){  rtreeRelease((Rtree *)pVtab);  return SQLITE_OK; } static int rtreeDestroy(sqlite3_vtab *pVtab){  Rtree *pRtree = (Rtree *)pVtab;  int rc;  char *zCreate = sqlite3_mprintf(  "DROP TABLE '%q'.'%q_node';"  "DROP TABLE '%q'.'%q_rowid';"  "DROP TABLE '%q'.'%q_parent';",  pRtree->zDb, pRtree->zName,  pRtree->zDb, pRtree->zName,  pRtree->zDb, pRtree->zName  );  if( !zCreate ){  rc = SQLITE_NOMEM;  }else{  nodeBlobReset(pRtree);  rc = sqlite3_exec(pRtree->db, zCreate, 0, 0, 0);  sqlite3_free(zCreate);  }  if( rc==SQLITE_OK ){  rtreeRelease(pRtree);  }  return rc; } static int rtreeOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){  int rc = SQLITE_NOMEM;  Rtree *pRtree = (Rtree *)pVTab;  RtreeCursor *pCsr;  pCsr = (RtreeCursor *)sqlite3_malloc64(sizeof(RtreeCursor));  if( pCsr ){  memset(pCsr, 0, sizeof(RtreeCursor));  pCsr->base.pVtab = pVTab;  rc = SQLITE_OK;  pRtree->nCursor++;  }  *ppCursor = (sqlite3_vtab_cursor *)pCsr;  return rc; } static void resetCursor(RtreeCursor *pCsr){  Rtree *pRtree = (Rtree *)(pCsr->base.pVtab);  int ii;  sqlite3_stmt *pStmt;  if( pCsr->aConstraint ){  int i;  for(i=0; i<pCsr->nConstraint; i++){  sqlite3_rtree_query_info *pInfo = pCsr->aConstraint[i].pInfo;  if( pInfo ){  if( pInfo->xDelUser ) pInfo->xDelUser(pInfo->pUser);  sqlite3_free(pInfo);  }  }  sqlite3_free(pCsr->aConstraint);  pCsr->aConstraint = 0;  }  for(ii=0; ii<RTREE_CACHE_SZ; ii++) nodeRelease(pRtree, pCsr->aNode[ii]);  sqlite3_free(pCsr->aPoint);  pStmt = pCsr->pReadAux;  memset(pCsr, 0, sizeof(RtreeCursor));  pCsr->base.pVtab = (sqlite3_vtab*)pRtree;  pCsr->pReadAux = pStmt; } static int rtreeClose(sqlite3_vtab_cursor *cur){  Rtree *pRtree = (Rtree *)(cur->pVtab);  RtreeCursor *pCsr = (RtreeCursor *)cur;  assert( pRtree->nCursor>0 );  resetCursor(pCsr);  sqlite3_finalize(pCsr->pReadAux);  sqlite3_free(pCsr);  pRtree->nCursor--;  nodeBlobReset(pRtree);  return SQLITE_OK; } static int rtreeEof(sqlite3_vtab_cursor *cur){  RtreeCursor *pCsr = (RtreeCursor *)cur;  return pCsr->atEOF; }
#if SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300
#define RTREE_DECODE_COORD(eInt, a, r) {  RtreeCoord c;   c.u = _byteswap_ulong(*(u32*)a);  r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; }

#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4003000
#define RTREE_DECODE_COORD(eInt, a, r) {  RtreeCoord c;   c.u = __builtin_bswap32(*(u32*)a);  r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; }

#elif SQLITE_BYTEORDER==1234
#define RTREE_DECODE_COORD(eInt, a, r) {  RtreeCoord c;   memcpy(&c.u,a,4);   c.u = ((c.u>>24)&0xff)|((c.u>>8)&0xff00)|   ((c.u&0xff)<<24)|((c.u&0xff00)<<8);   r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; }

#elif SQLITE_BYTEORDER==4321
#define RTREE_DECODE_COORD(eInt, a, r) {  RtreeCoord c;   memcpy(&c.u,a,4);   r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; }

#else
#define RTREE_DECODE_COORD(eInt, a, r) {  RtreeCoord c;   c.u = ((u32)a[0]<<24) + ((u32)a[1]<<16)    +((u32)a[2]<<8) + a[3];  r = eInt ? (sqlite3_rtree_dbl)c.i : (sqlite3_rtree_dbl)c.f; }

#endif
static int rtreeCallbackConstraint(  RtreeConstraint *pConstraint,  int eInt,  u8 *pCellData,  RtreeSearchPoint *pSearch,  sqlite3_rtree_dbl *prScore,  int *peWithin ){  sqlite3_rtree_query_info *pInfo = pConstraint->pInfo;  int nCoord = pInfo->nCoord;  int rc;  RtreeCoord c;  sqlite3_rtree_dbl aCoord[RTREE_MAX_DIMENSIONS*2];  assert( pConstraint->op==RTREE_MATCH || pConstraint->op==RTREE_QUERY );  assert( nCoord==2 || nCoord==4 || nCoord==6 || nCoord==8 || nCoord==10 );  if( pConstraint->op==RTREE_QUERY && pSearch->iLevel==1 ){  pInfo->iRowid = readInt64(pCellData);  }  pCellData += 8;
#ifndef SQLITE_RTREE_INT_ONLY
 if( eInt==0 ){  switch( nCoord ){  case 10: readCoord(pCellData+36, &c); aCoord[9] = c.f;  readCoord(pCellData+32, &c); aCoord[8] = c.f;  case 8:  readCoord(pCellData+28, &c); aCoord[7] = c.f;  readCoord(pCellData+24, &c); aCoord[6] = c.f;  case 6:  readCoord(pCellData+20, &c); aCoord[5] = c.f;  readCoord(pCellData+16, &c); aCoord[4] = c.f;  case 4:  readCoord(pCellData+12, &c); aCoord[3] = c.f;  readCoord(pCellData+8, &c); aCoord[2] = c.f;  default: readCoord(pCellData+4, &c); aCoord[1] = c.f;  readCoord(pCellData, &c); aCoord[0] = c.f;  }  }else
#endif
 {  switch( nCoord ){  case 10: readCoord(pCellData+36, &c); aCoord[9] = c.i;  readCoord(pCellData+32, &c); aCoord[8] = c.i;  case 8:  readCoord(pCellData+28, &c); aCoord[7] = c.i;  readCoord(pCellData+24, &c); aCoord[6] = c.i;  case 6:  readCoord(pCellData+20, &c); aCoord[5] = c.i;  readCoord(pCellData+16, &c); aCoord[4] = c.i;  case 4:  readCoord(pCellData+12, &c); aCoord[3] = c.i;  readCoord(pCellData+8, &c); aCoord[2] = c.i;  default: readCoord(pCellData+4, &c); aCoord[1] = c.i;  readCoord(pCellData, &c); aCoord[0] = c.i;  }  }  if( pConstraint->op==RTREE_MATCH ){  int eWithin = 0;  rc = pConstraint->u.xGeom((sqlite3_rtree_geometry*)pInfo,  nCoord, aCoord, &eWithin);  if( eWithin==0 ) *peWithin = NOT_WITHIN;  *prScore = RTREE_ZERO;  }else{  pInfo->aCoord = aCoord;  pInfo->iLevel = pSearch->iLevel - 1;  pInfo->rScore = pInfo->rParentScore = pSearch->rScore;  pInfo->eWithin = pInfo->eParentWithin = pSearch->eWithin;  rc = pConstraint->u.xQueryFunc(pInfo);  if( pInfo->eWithin<*peWithin ) *peWithin = pInfo->eWithin;  if( pInfo->rScore<*prScore || *prScore<RTREE_ZERO ){  *prScore = pInfo->rScore;  }  }  return rc; } static void rtreeNonleafConstraint(  RtreeConstraint *p,  int eInt,  u8 *pCellData,  int *peWithin ){  sqlite3_rtree_dbl val;  pCellData += 8 + 4*(p->iCoord&0xfe);  assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE  || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_TRUE  || p->op==RTREE_FALSE );  assert( ((((char*)pCellData) - (char*)0)&3)==0 );  switch( p->op ){  case RTREE_TRUE: return;  case RTREE_FALSE: break;  case RTREE_EQ:  RTREE_DECODE_COORD(eInt, pCellData, val);  if( p->u.rValue>=val ){  pCellData += 4;  RTREE_DECODE_COORD(eInt, pCellData, val);  if( p->u.rValue<=val ) return;  }  break;  case RTREE_LE:  case RTREE_LT:  RTREE_DECODE_COORD(eInt, pCellData, val);  if( p->u.rValue>=val ) return;  break;  default:  pCellData += 4;  RTREE_DECODE_COORD(eInt, pCellData, val);  if( p->u.rValue<=val ) return;  break;  }  *peWithin = NOT_WITHIN; } static void rtreeLeafConstraint(  RtreeConstraint *p,  int eInt,  u8 *pCellData,  int *peWithin ){  RtreeDValue xN;  assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE  || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_TRUE  || p->op==RTREE_FALSE );  pCellData += 8 + p->iCoord*4;  assert( ((((char*)pCellData) - (char*)0)&3)==0 );  RTREE_DECODE_COORD(eInt, pCellData, xN);  switch( p->op ){  case RTREE_TRUE: return;  case RTREE_FALSE: break;  case RTREE_LE: if( xN <= p->u.rValue ) return; break;  case RTREE_LT: if( xN < p->u.rValue ) return; break;  case RTREE_GE: if( xN >= p->u.rValue ) return; break;  case RTREE_GT: if( xN > p->u.rValue ) return; break;  default: if( xN == p->u.rValue ) return; break;  }  *peWithin = NOT_WITHIN; } static int nodeRowidIndex(  Rtree *pRtree,  RtreeNode *pNode,  i64 iRowid,  int *piIndex ){  int ii;  int nCell = NCELL(pNode);  assert( nCell<200 );  for(ii=0; ii<nCell; ii++){  if( nodeGetRowid(pRtree, pNode, ii)==iRowid ){  *piIndex = ii;  return SQLITE_OK;  }  }  RTREE_IS_CORRUPT(pRtree);  return SQLITE_CORRUPT_VTAB; } static int nodeParentIndex(Rtree *pRtree, RtreeNode *pNode, int *piIndex){  RtreeNode *pParent = pNode->pParent;  if( ALWAYS(pParent) ){  return nodeRowidIndex(pRtree, pParent, pNode->iNode, piIndex);  }else{  *piIndex = -1;  return SQLITE_OK;  } } static int rtreeSearchPointCompare(  const RtreeSearchPoint *pA,  const RtreeSearchPoint *pB ){  if( pA->rScore<pB->rScore ) return -1;  if( pA->rScore>pB->rScore ) return +1;  if( pA->iLevel<pB->iLevel ) return -1;  if( pA->iLevel>pB->iLevel ) return +1;  return 0; } static void rtreeSearchPointSwap(RtreeCursor *p, int i, int j){  RtreeSearchPoint t = p->aPoint[i];  assert( i<j );  p->aPoint[i] = p->aPoint[j];  p->aPoint[j] = t;  i++; j++;  if( i<RTREE_CACHE_SZ ){  if( j>=RTREE_CACHE_SZ ){  nodeRelease(RTREE_OF_CURSOR(p), p->aNode[i]);  p->aNode[i] = 0;  }else{  RtreeNode *pTemp = p->aNode[i];  p->aNode[i] = p->aNode[j];  p->aNode[j] = pTemp;  }  } } static RtreeSearchPoint *rtreeSearchPointFirst(RtreeCursor *pCur){  return pCur->bPoint ? &pCur->sPoint : pCur->nPoint ? pCur->aPoint : 0; } static RtreeNode *rtreeNodeOfFirstSearchPoint(RtreeCursor *pCur, int *pRC){  sqlite3_int64 id;  int ii = 1 - pCur->bPoint;  assert( ii==0 || ii==1 );  assert( pCur->bPoint || pCur->nPoint );  if( pCur->aNode[ii]==0 ){  assert( pRC!=0 );  id = ii ? pCur->aPoint[0].id : pCur->sPoint.id;  *pRC = nodeAcquire(RTREE_OF_CURSOR(pCur), id, 0, &pCur->aNode[ii]);  }  return pCur->aNode[ii]; } static RtreeSearchPoint *rtreeEnqueue(  RtreeCursor *pCur,  RtreeDValue rScore,  u8 iLevel ){  int i, j;  RtreeSearchPoint *pNew;  if( pCur->nPoint>=pCur->nPointAlloc ){  int nNew = pCur->nPointAlloc*2 + 8;  pNew = sqlite3_realloc64(pCur->aPoint, nNew*sizeof(pCur->aPoint[0]));  if( pNew==0 ) return 0;  pCur->aPoint = pNew;  pCur->nPointAlloc = nNew;  }  i = pCur->nPoint++;  pNew = pCur->aPoint + i;  pNew->rScore = rScore;  pNew->iLevel = iLevel;  assert( iLevel<=RTREE_MAX_DEPTH );  while( i>0 ){  RtreeSearchPoint *pParent;  j = (i-1)/2;  pParent = pCur->aPoint + j;  if( rtreeSearchPointCompare(pNew, pParent)>=0 ) break;  rtreeSearchPointSwap(pCur, j, i);  i = j;  pNew = pParent;  }  return pNew; } static RtreeSearchPoint *rtreeSearchPointNew(  RtreeCursor *pCur,  RtreeDValue rScore,  u8 iLevel ){  RtreeSearchPoint *pNew, *pFirst;  pFirst = rtreeSearchPointFirst(pCur);  pCur->anQueue[iLevel]++;  if( pFirst==0   || pFirst->rScore>rScore   || (pFirst->rScore==rScore && pFirst->iLevel>iLevel)  ){  if( pCur->bPoint ){  int ii;  pNew = rtreeEnqueue(pCur, rScore, iLevel);  if( pNew==0 ) return 0;  ii = (int)(pNew - pCur->aPoint) + 1;  assert( ii==1 );  if( ALWAYS(ii<RTREE_CACHE_SZ) ){  assert( pCur->aNode[ii]==0 );  pCur->aNode[ii] = pCur->aNode[0];  }else{  nodeRelease(RTREE_OF_CURSOR(pCur), pCur->aNode[0]);  }  pCur->aNode[0] = 0;  *pNew = pCur->sPoint;  }  pCur->sPoint.rScore = rScore;  pCur->sPoint.iLevel = iLevel;  pCur->bPoint = 1;  return &pCur->sPoint;  }else{  return rtreeEnqueue(pCur, rScore, iLevel);  } }
#if 0
static void tracePoint(RtreeSearchPoint *p, int idx, RtreeCursor *pCur){  if( idx<0 ){ printf(" s"); }else{ printf("%2d", idx); }  printf(" %d.%05lld.%02d %g %d",  p->iLevel, p->id, p->iCell, p->rScore, p->eWithin  );  idx++;  if( idx<RTREE_CACHE_SZ ){  printf(" %p\n", pCur->aNode[idx]);  }else{  printf("\n");  } } static void traceQueue(RtreeCursor *pCur, const char *zPrefix){  int ii;  printf("=== %9s ", zPrefix);  if( pCur->bPoint ){  tracePoint(&pCur->sPoint, -1, pCur);  }  for(ii=0; ii<pCur->nPoint; ii++){  if( ii>0 || pCur->bPoint ) printf(" ");  tracePoint(&pCur->aPoint[ii], ii, pCur);  } }
# define RTREE_QUEUE_TRACE(A,B) traceQueue(A,B)
#else
# define RTREE_QUEUE_TRACE(A,B)
#endif
static void rtreeSearchPointPop(RtreeCursor *p){  int i, j, k, n;  i = 1 - p->bPoint;  assert( i==0 || i==1 );  if( p->aNode[i] ){  nodeRelease(RTREE_OF_CURSOR(p), p->aNode[i]);  p->aNode[i] = 0;  }  if( p->bPoint ){  p->anQueue[p->sPoint.iLevel]--;  p->bPoint = 0;  }else if( ALWAYS(p->nPoint) ){  p->anQueue[p->aPoint[0].iLevel]--;  n = --p->nPoint;  p->aPoint[0] = p->aPoint[n];  if( n<RTREE_CACHE_SZ-1 ){  p->aNode[1] = p->aNode[n+1];  p->aNode[n+1] = 0;  }  i = 0;  while( (j = i*2+1)<n ){  k = j+1;  if( k<n && rtreeSearchPointCompare(&p->aPoint[k], &p->aPoint[j])<0 ){  if( rtreeSearchPointCompare(&p->aPoint[k], &p->aPoint[i])<0 ){  rtreeSearchPointSwap(p, i, k);  i = k;  }else{  break;  }  }else{  if( rtreeSearchPointCompare(&p->aPoint[j], &p->aPoint[i])<0 ){  rtreeSearchPointSwap(p, i, j);  i = j;  }else{  break;  }  }  }  } } static int rtreeStepToLeaf(RtreeCursor *pCur){  RtreeSearchPoint *p;  Rtree *pRtree = RTREE_OF_CURSOR(pCur);  RtreeNode *pNode;  int eWithin;  int rc = SQLITE_OK;  int nCell;  int nConstraint = pCur->nConstraint;  int ii;  int eInt;  RtreeSearchPoint x;  eInt = pRtree->eCoordType==RTREE_COORD_INT32;  while( (p = rtreeSearchPointFirst(pCur))!=0 && p->iLevel>0 ){  u8 *pCellData;  pNode = rtreeNodeOfFirstSearchPoint(pCur, &rc);  if( rc ) return rc;  nCell = NCELL(pNode);  assert( nCell<200 );  pCellData = pNode->zData + (4+pRtree->nBytesPerCell*p->iCell);  while( p->iCell<nCell ){  sqlite3_rtree_dbl rScore = (sqlite3_rtree_dbl)-1;  eWithin = FULLY_WITHIN;  for(ii=0; ii<nConstraint; ii++){  RtreeConstraint *pConstraint = pCur->aConstraint + ii;  if( pConstraint->op>=RTREE_MATCH ){  rc = rtreeCallbackConstraint(pConstraint, eInt, pCellData, p,   &rScore, &eWithin);  if( rc ) return rc;  }else if( p->iLevel==1 ){  rtreeLeafConstraint(pConstraint, eInt, pCellData, &eWithin);  }else{  rtreeNonleafConstraint(pConstraint, eInt, pCellData, &eWithin);  }  if( eWithin==NOT_WITHIN ){  p->iCell++;  pCellData += pRtree->nBytesPerCell;  break;  }  }  if( eWithin==NOT_WITHIN ) continue;  p->iCell++;  x.iLevel = p->iLevel - 1;  if( x.iLevel ){  x.id = readInt64(pCellData);  for(ii=0; ii<pCur->nPoint; ii++){  if( pCur->aPoint[ii].id==x.id ){  RTREE_IS_CORRUPT(pRtree);  return SQLITE_CORRUPT_VTAB;  }  }  x.iCell = 0;  }else{  x.id = p->id;  x.iCell = p->iCell - 1;  }  if( p->iCell>=nCell ){  RTREE_QUEUE_TRACE(pCur, "POP-S:");  rtreeSearchPointPop(pCur);  }  if( rScore<RTREE_ZERO ) rScore = RTREE_ZERO;  p = rtreeSearchPointNew(pCur, rScore, x.iLevel);  if( p==0 ) return SQLITE_NOMEM;  p->eWithin = (u8)eWithin;  p->id = x.id;  p->iCell = x.iCell;  RTREE_QUEUE_TRACE(pCur, "PUSH-S:");  break;  }  if( p->iCell>=nCell ){  RTREE_QUEUE_TRACE(pCur, "POP-Se:");  rtreeSearchPointPop(pCur);  }  }  pCur->atEOF = p==0;  return SQLITE_OK; } static int rtreeNext(sqlite3_vtab_cursor *pVtabCursor){  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;  int rc = SQLITE_OK;  RTREE_QUEUE_TRACE(pCsr, "POP-Nx:");  if( pCsr->bAuxValid ){  pCsr->bAuxValid = 0;  sqlite3_reset(pCsr->pReadAux);  }  rtreeSearchPointPop(pCsr);  rc = rtreeStepToLeaf(pCsr);  return rc; } static int rtreeRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid){  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;  RtreeSearchPoint *p = rtreeSearchPointFirst(pCsr);  int rc = SQLITE_OK;  RtreeNode *pNode = rtreeNodeOfFirstSearchPoint(pCsr, &rc);  if( rc==SQLITE_OK && ALWAYS(p) ){  *pRowid = nodeGetRowid(RTREE_OF_CURSOR(pCsr), pNode, p->iCell);  }  return rc; } static int rtreeColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){  Rtree *pRtree = (Rtree *)cur->pVtab;  RtreeCursor *pCsr = (RtreeCursor *)cur;  RtreeSearchPoint *p = rtreeSearchPointFirst(pCsr);  RtreeCoord c;  int rc = SQLITE_OK;  RtreeNode *pNode = rtreeNodeOfFirstSearchPoint(pCsr, &rc);  if( rc ) return rc;  if( NEVER(p==0) ) return SQLITE_OK;  if( i==0 ){  sqlite3_result_int64(ctx, nodeGetRowid(pRtree, pNode, p->iCell));  }else if( i<=pRtree->nDim2 ){  nodeGetCoord(pRtree, pNode, p->iCell, i-1, &c);
#ifndef SQLITE_RTREE_INT_ONLY
 if( pRtree->eCoordType==RTREE_COORD_REAL32 ){  sqlite3_result_double(ctx, c.f);  }else
#endif
 {  assert( pRtree->eCoordType==RTREE_COORD_INT32 );  sqlite3_result_int(ctx, c.i);  }  }else{  if( !pCsr->bAuxValid ){  if( pCsr->pReadAux==0 ){  rc = sqlite3_prepare_v3(pRtree->db, pRtree->zReadAuxSql, -1, 0,  &pCsr->pReadAux, 0);  if( rc ) return rc;  }  sqlite3_bind_int64(pCsr->pReadAux, 1,  nodeGetRowid(pRtree, pNode, p->iCell));  rc = sqlite3_step(pCsr->pReadAux);  if( rc==SQLITE_ROW ){  pCsr->bAuxValid = 1;  }else{  sqlite3_reset(pCsr->pReadAux);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  return rc;  }  }  sqlite3_result_value(ctx,   sqlite3_column_value(pCsr->pReadAux, i - pRtree->nDim2 + 1));  }  return SQLITE_OK; } static int findLeafNode(  Rtree *pRtree,  i64 iRowid,  RtreeNode **ppLeaf,  sqlite3_int64 *piNode ){  int rc;  *ppLeaf = 0;  sqlite3_bind_int64(pRtree->pReadRowid, 1, iRowid);  if( sqlite3_step(pRtree->pReadRowid)==SQLITE_ROW ){  i64 iNode = sqlite3_column_int64(pRtree->pReadRowid, 0);  if( piNode ) *piNode = iNode;  rc = nodeAcquire(pRtree, iNode, 0, ppLeaf);  sqlite3_reset(pRtree->pReadRowid);  }else{  rc = sqlite3_reset(pRtree->pReadRowid);  }  return rc; } static int deserializeGeometry(sqlite3_value *pValue, RtreeConstraint *pCons){  RtreeMatchArg *pBlob, *pSrc;  sqlite3_rtree_query_info *pInfo;  pSrc = sqlite3_value_pointer(pValue, "RtreeMatchArg");  if( pSrc==0 ) return SQLITE_ERROR;  pInfo = (sqlite3_rtree_query_info*)  sqlite3_malloc64( sizeof(*pInfo)+pSrc->iSize );  if( !pInfo ) return SQLITE_NOMEM;  memset(pInfo, 0, sizeof(*pInfo));  pBlob = (RtreeMatchArg*)&pInfo[1];  memcpy(pBlob, pSrc, pSrc->iSize);  pInfo->pContext = pBlob->cb.pContext;  pInfo->nParam = pBlob->nParam;  pInfo->aParam = pBlob->aParam;  pInfo->apSqlParam = pBlob->apSqlParam;  if( pBlob->cb.xGeom ){  pCons->u.xGeom = pBlob->cb.xGeom;  }else{  pCons->op = RTREE_QUERY;  pCons->u.xQueryFunc = pBlob->cb.xQueryFunc;  }  pCons->pInfo = pInfo;  return SQLITE_OK; } static int rtreeFilter(  sqlite3_vtab_cursor *pVtabCursor,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  Rtree *pRtree = (Rtree *)pVtabCursor->pVtab;  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;  RtreeNode *pRoot = 0;  int ii;  int rc = SQLITE_OK;  int iCell = 0;  rtreeReference(pRtree);  resetCursor(pCsr);  pCsr->iStrategy = idxNum;  if( idxNum==1 ){  RtreeNode *pLeaf;  RtreeSearchPoint *p;  i64 iRowid = sqlite3_value_int64(argv[0]);  i64 iNode = 0;  int eType = sqlite3_value_numeric_type(argv[0]);  if( eType==SQLITE_INTEGER   || (eType==SQLITE_FLOAT && sqlite3_value_double(argv[0])==iRowid)  ){  rc = findLeafNode(pRtree, iRowid, &pLeaf, &iNode);  }else{  rc = SQLITE_OK;  pLeaf = 0;  }  if( rc==SQLITE_OK && pLeaf!=0 ){  p = rtreeSearchPointNew(pCsr, RTREE_ZERO, 0);  assert( p!=0 );  pCsr->aNode[0] = pLeaf;  p->id = iNode;  p->eWithin = PARTLY_WITHIN;  rc = nodeRowidIndex(pRtree, pLeaf, iRowid, &iCell);  p->iCell = (u8)iCell;  RTREE_QUEUE_TRACE(pCsr, "PUSH-F1:");  }else{  pCsr->atEOF = 1;  }  }else{  rc = nodeAcquire(pRtree, 1, 0, &pRoot);  if( rc==SQLITE_OK && argc>0 ){  pCsr->aConstraint = sqlite3_malloc64(sizeof(RtreeConstraint)*argc);  pCsr->nConstraint = argc;  if( !pCsr->aConstraint ){  rc = SQLITE_NOMEM;  }else{  memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);  memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));  assert( (idxStr==0 && argc==0)  || (idxStr && (int)strlen(idxStr)==argc*2) );  for(ii=0; ii<argc; ii++){  RtreeConstraint *p = &pCsr->aConstraint[ii];  int eType = sqlite3_value_numeric_type(argv[ii]);  p->op = idxStr[ii*2];  p->iCoord = idxStr[ii*2+1]-'0';  if( p->op>=RTREE_MATCH ){  rc = deserializeGeometry(argv[ii], p);  if( rc!=SQLITE_OK ){  break;  }  p->pInfo->nCoord = pRtree->nDim2;  p->pInfo->anQueue = pCsr->anQueue;  p->pInfo->mxLevel = pRtree->iDepth + 1;  }else if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){
#ifdef SQLITE_RTREE_INT_ONLY
 p->u.rValue = sqlite3_value_int64(argv[ii]);
#else
 p->u.rValue = sqlite3_value_double(argv[ii]);
#endif
 }else{  p->u.rValue = RTREE_ZERO;  if( eType==SQLITE_NULL ){  p->op = RTREE_FALSE;  }else if( p->op==RTREE_LT || p->op==RTREE_LE ){  p->op = RTREE_TRUE;  }else{  p->op = RTREE_FALSE;  }  }  }  }  }  if( rc==SQLITE_OK ){  RtreeSearchPoint *pNew;  assert( pCsr->bPoint==0 );  pNew = rtreeSearchPointNew(pCsr, RTREE_ZERO, (u8)(pRtree->iDepth+1));  if( NEVER(pNew==0) ){  return SQLITE_NOMEM;  }  pNew->id = 1;  pNew->iCell = 0;  pNew->eWithin = PARTLY_WITHIN;  assert( pCsr->bPoint==1 );  pCsr->aNode[0] = pRoot;  pRoot = 0;  RTREE_QUEUE_TRACE(pCsr, "PUSH-Fm:");  rc = rtreeStepToLeaf(pCsr);  }  }  nodeRelease(pRtree, pRoot);  rtreeRelease(pRtree);  return rc; } static int rtreeBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){  Rtree *pRtree = (Rtree*)tab;  int rc = SQLITE_OK;  int ii;  int bMatch = 0;  i64 nRow;  int iIdx = 0;  char zIdxStr[RTREE_MAX_DIMENSIONS*8+1];  memset(zIdxStr, 0, sizeof(zIdxStr));  for(ii=0; ii<pIdxInfo->nConstraint; ii++){  if( pIdxInfo->aConstraint[ii].op==SQLITE_INDEX_CONSTRAINT_MATCH ){  bMatch = 1;  }  }  assert( pIdxInfo->idxStr==0 );  for(ii=0; ii<pIdxInfo->nConstraint && iIdx<(int)(sizeof(zIdxStr)-1); ii++){  struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[ii];  if( bMatch==0 && p->usable   && p->iColumn<=0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ  ){  int jj;  for(jj=0; jj<ii; jj++){  pIdxInfo->aConstraintUsage[jj].argvIndex = 0;  pIdxInfo->aConstraintUsage[jj].omit = 0;  }  pIdxInfo->idxNum = 1;  pIdxInfo->aConstraintUsage[ii].argvIndex = 1;  pIdxInfo->aConstraintUsage[jj].omit = 1;  pIdxInfo->estimatedCost = 30.0;  pIdxInfo->estimatedRows = 1;  pIdxInfo->idxFlags = SQLITE_INDEX_SCAN_UNIQUE;  return SQLITE_OK;  }  if( p->usable  && ((p->iColumn>0 && p->iColumn<=pRtree->nDim2)  || p->op==SQLITE_INDEX_CONSTRAINT_MATCH)  ){  u8 op;  switch( p->op ){  case SQLITE_INDEX_CONSTRAINT_EQ: op = RTREE_EQ; break;  case SQLITE_INDEX_CONSTRAINT_GT: op = RTREE_GT; break;  case SQLITE_INDEX_CONSTRAINT_LE: op = RTREE_LE; break;  case SQLITE_INDEX_CONSTRAINT_LT: op = RTREE_LT; break;  case SQLITE_INDEX_CONSTRAINT_GE: op = RTREE_GE; break;  case SQLITE_INDEX_CONSTRAINT_MATCH: op = RTREE_MATCH; break;  default: op = 0;  break;  }  if( op ){  zIdxStr[iIdx++] = op;  zIdxStr[iIdx++] = (char)(p->iColumn - 1 + '0');  pIdxInfo->aConstraintUsage[ii].argvIndex = (iIdx/2);  pIdxInfo->aConstraintUsage[ii].omit = 1;  }  }  }  pIdxInfo->idxNum = 2;  pIdxInfo->needToFreeIdxStr = 1;  if( iIdx>0 && 0==(pIdxInfo->idxStr = sqlite3_mprintf("%s", zIdxStr)) ){  return SQLITE_NOMEM;  }  nRow = pRtree->nRowEst >> (iIdx/2);  pIdxInfo->estimatedCost = (double)6.0 * (double)nRow;  pIdxInfo->estimatedRows = nRow;  return rc; } static RtreeDValue cellArea(Rtree *pRtree, RtreeCell *p){  RtreeDValue area = (RtreeDValue)1;  assert( pRtree->nDim>=1 && pRtree->nDim<=5 );
#ifndef SQLITE_RTREE_INT_ONLY
 if( pRtree->eCoordType==RTREE_COORD_REAL32 ){  switch( pRtree->nDim ){  case 5: area = p->aCoord[9].f - p->aCoord[8].f;  case 4: area *= p->aCoord[7].f - p->aCoord[6].f;  case 3: area *= p->aCoord[5].f - p->aCoord[4].f;  case 2: area *= p->aCoord[3].f - p->aCoord[2].f;  default: area *= p->aCoord[1].f - p->aCoord[0].f;  }  }else
#endif
 {  switch( pRtree->nDim ){  case 5: area = (i64)p->aCoord[9].i - (i64)p->aCoord[8].i;  case 4: area *= (i64)p->aCoord[7].i - (i64)p->aCoord[6].i;  case 3: area *= (i64)p->aCoord[5].i - (i64)p->aCoord[4].i;  case 2: area *= (i64)p->aCoord[3].i - (i64)p->aCoord[2].i;  default: area *= (i64)p->aCoord[1].i - (i64)p->aCoord[0].i;  }  }  return area; } static RtreeDValue cellMargin(Rtree *pRtree, RtreeCell *p){  RtreeDValue margin = 0;  int ii = pRtree->nDim2 - 2;  do{  margin += (DCOORD(p->aCoord[ii+1]) - DCOORD(p->aCoord[ii]));  ii -= 2;  }while( ii>=0 );  return margin; } static void cellUnion(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){  int ii = 0;  if( pRtree->eCoordType==RTREE_COORD_REAL32 ){  do{  p1->aCoord[ii].f = MIN(p1->aCoord[ii].f, p2->aCoord[ii].f);  p1->aCoord[ii+1].f = MAX(p1->aCoord[ii+1].f, p2->aCoord[ii+1].f);  ii += 2;  }while( ii<pRtree->nDim2 );  }else{  do{  p1->aCoord[ii].i = MIN(p1->aCoord[ii].i, p2->aCoord[ii].i);  p1->aCoord[ii+1].i = MAX(p1->aCoord[ii+1].i, p2->aCoord[ii+1].i);  ii += 2;  }while( ii<pRtree->nDim2 );  } } static int cellContains(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){  int ii;  int isInt = (pRtree->eCoordType==RTREE_COORD_INT32);  for(ii=0; ii<pRtree->nDim2; ii+=2){  RtreeCoord *a1 = &p1->aCoord[ii];  RtreeCoord *a2 = &p2->aCoord[ii];  if( (!isInt && (a2[0].f<a1[0].f || a2[1].f>a1[1].f))   || ( isInt && (a2[0].i<a1[0].i || a2[1].i>a1[1].i))  ){  return 0;  }  }  return 1; } static RtreeDValue cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell){  RtreeDValue area;  RtreeCell cell;  memcpy(&cell, p, sizeof(RtreeCell));  area = cellArea(pRtree, &cell);  cellUnion(pRtree, &cell, pCell);  return (cellArea(pRtree, &cell)-area); } static RtreeDValue cellOverlap(  Rtree *pRtree,  RtreeCell *p,  RtreeCell *aCell,  int nCell ){  int ii;  RtreeDValue overlap = RTREE_ZERO;  for(ii=0; ii<nCell; ii++){  int jj;  RtreeDValue o = (RtreeDValue)1;  for(jj=0; jj<pRtree->nDim2; jj+=2){  RtreeDValue x1, x2;  x1 = MAX(DCOORD(p->aCoord[jj]), DCOORD(aCell[ii].aCoord[jj]));  x2 = MIN(DCOORD(p->aCoord[jj+1]), DCOORD(aCell[ii].aCoord[jj+1]));  if( x2<x1 ){  o = (RtreeDValue)0;  break;  }else{  o = o * (x2-x1);  }  }  overlap += o;  }  return overlap; } static int ChooseLeaf(  Rtree *pRtree,  RtreeCell *pCell,  int iHeight,  RtreeNode **ppLeaf ){  int rc;  int ii;  RtreeNode *pNode = 0;  rc = nodeAcquire(pRtree, 1, 0, &pNode);  for(ii=0; rc==SQLITE_OK && ii<(pRtree->iDepth-iHeight); ii++){  int iCell;  sqlite3_int64 iBest = 0;  RtreeDValue fMinGrowth = RTREE_ZERO;  RtreeDValue fMinArea = RTREE_ZERO;  int nCell = NCELL(pNode);  RtreeCell cell;  RtreeNode *pChild = 0;  RtreeCell *aCell = 0;  for(iCell=0; iCell<nCell; iCell++){  int bBest = 0;  RtreeDValue growth;  RtreeDValue area;  nodeGetCell(pRtree, pNode, iCell, &cell);  growth = cellGrowth(pRtree, &cell, pCell);  area = cellArea(pRtree, &cell);  if( iCell==0||growth<fMinGrowth||(growth==fMinGrowth && area<fMinArea) ){  bBest = 1;  }  if( bBest ){  fMinGrowth = growth;  fMinArea = area;  iBest = cell.iRowid;  }  }  sqlite3_free(aCell);  rc = nodeAcquire(pRtree, iBest, pNode, &pChild);  nodeRelease(pRtree, pNode);  pNode = pChild;  }  *ppLeaf = pNode;  return rc; } static int AdjustTree(  Rtree *pRtree,  RtreeNode *pNode,  RtreeCell *pCell ){  RtreeNode *p = pNode;  int cnt = 0;  int rc;  while( p->pParent ){  RtreeNode *pParent = p->pParent;  RtreeCell cell;  int iCell;  cnt++;  if( NEVER(cnt>100) ){  RTREE_IS_CORRUPT(pRtree);  return SQLITE_CORRUPT_VTAB;  }  rc = nodeParentIndex(pRtree, p, &iCell);  if( NEVER(rc!=SQLITE_OK) ){  RTREE_IS_CORRUPT(pRtree);  return SQLITE_CORRUPT_VTAB;  }  nodeGetCell(pRtree, pParent, iCell, &cell);  if( !cellContains(pRtree, &cell, pCell) ){  cellUnion(pRtree, &cell, pCell);  nodeOverwriteCell(pRtree, pParent, &cell, iCell);  }  p = pParent;  }  return SQLITE_OK; } static int rowidWrite(Rtree *pRtree, sqlite3_int64 iRowid, sqlite3_int64 iNode){  sqlite3_bind_int64(pRtree->pWriteRowid, 1, iRowid);  sqlite3_bind_int64(pRtree->pWriteRowid, 2, iNode);  sqlite3_step(pRtree->pWriteRowid);  return sqlite3_reset(pRtree->pWriteRowid); } static int parentWrite(Rtree *pRtree, sqlite3_int64 iNode, sqlite3_int64 iPar){  sqlite3_bind_int64(pRtree->pWriteParent, 1, iNode);  sqlite3_bind_int64(pRtree->pWriteParent, 2, iPar);  sqlite3_step(pRtree->pWriteParent);  return sqlite3_reset(pRtree->pWriteParent); } static int rtreeInsertCell(Rtree *, RtreeNode *, RtreeCell *, int); static void SortByDistance(  int *aIdx,  int nIdx,  RtreeDValue *aDistance,  int *aSpare ){  if( nIdx>1 ){  int iLeft = 0;  int iRight = 0;  int nLeft = nIdx/2;  int nRight = nIdx-nLeft;  int *aLeft = aIdx;  int *aRight = &aIdx[nLeft];  SortByDistance(aLeft, nLeft, aDistance, aSpare);  SortByDistance(aRight, nRight, aDistance, aSpare);  memcpy(aSpare, aLeft, sizeof(int)*nLeft);  aLeft = aSpare;  while( iLeft<nLeft || iRight<nRight ){  if( iLeft==nLeft ){  aIdx[iLeft+iRight] = aRight[iRight];  iRight++;  }else if( iRight==nRight ){  aIdx[iLeft+iRight] = aLeft[iLeft];  iLeft++;  }else{  RtreeDValue fLeft = aDistance[aLeft[iLeft]];  RtreeDValue fRight = aDistance[aRight[iRight]];  if( fLeft<fRight ){  aIdx[iLeft+iRight] = aLeft[iLeft];  iLeft++;  }else{  aIdx[iLeft+iRight] = aRight[iRight];  iRight++;  }  }  }
#if 0
 {  int jj;  for(jj=1; jj<nIdx; jj++){  RtreeDValue left = aDistance[aIdx[jj-1]];  RtreeDValue right = aDistance[aIdx[jj]];  assert( left<=right );  }  }
#endif
 } } static void SortByDimension(  Rtree *pRtree,  int *aIdx,  int nIdx,  int iDim,  RtreeCell *aCell,  int *aSpare ){  if( nIdx>1 ){  int iLeft = 0;  int iRight = 0;  int nLeft = nIdx/2;  int nRight = nIdx-nLeft;  int *aLeft = aIdx;  int *aRight = &aIdx[nLeft];  SortByDimension(pRtree, aLeft, nLeft, iDim, aCell, aSpare);  SortByDimension(pRtree, aRight, nRight, iDim, aCell, aSpare);  memcpy(aSpare, aLeft, sizeof(int)*nLeft);  aLeft = aSpare;  while( iLeft<nLeft || iRight<nRight ){  RtreeDValue xleft1 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2]);  RtreeDValue xleft2 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2+1]);  RtreeDValue xright1 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2]);  RtreeDValue xright2 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2+1]);  if( (iLeft!=nLeft) && ((iRight==nRight)   || (xleft1<xright1)   || (xleft1==xright1 && xleft2<xright2)  )){  aIdx[iLeft+iRight] = aLeft[iLeft];  iLeft++;  }else{  aIdx[iLeft+iRight] = aRight[iRight];  iRight++;  }  }
#if 0
 {  int jj;  for(jj=1; jj<nIdx; jj++){  RtreeDValue xleft1 = aCell[aIdx[jj-1]].aCoord[iDim*2];  RtreeDValue xleft2 = aCell[aIdx[jj-1]].aCoord[iDim*2+1];  RtreeDValue xright1 = aCell[aIdx[jj]].aCoord[iDim*2];  RtreeDValue xright2 = aCell[aIdx[jj]].aCoord[iDim*2+1];  assert( xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) );  }  }
#endif
 } } static int splitNodeStartree(  Rtree *pRtree,  RtreeCell *aCell,  int nCell,  RtreeNode *pLeft,  RtreeNode *pRight,  RtreeCell *pBboxLeft,  RtreeCell *pBboxRight ){  int **aaSorted;  int *aSpare;  int ii;  int iBestDim = 0;  int iBestSplit = 0;  RtreeDValue fBestMargin = RTREE_ZERO;  sqlite3_int64 nByte = (pRtree->nDim+1)*(sizeof(int*)+nCell*sizeof(int));  aaSorted = (int **)sqlite3_malloc64(nByte);  if( !aaSorted ){  return SQLITE_NOMEM;  }  aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell];  memset(aaSorted, 0, nByte);  for(ii=0; ii<pRtree->nDim; ii++){  int jj;  aaSorted[ii] = &((int *)&aaSorted[pRtree->nDim])[ii*nCell];  for(jj=0; jj<nCell; jj++){  aaSorted[ii][jj] = jj;  }  SortByDimension(pRtree, aaSorted[ii], nCell, ii, aCell, aSpare);  }  for(ii=0; ii<pRtree->nDim; ii++){  RtreeDValue margin = RTREE_ZERO;  RtreeDValue fBestOverlap = RTREE_ZERO;  RtreeDValue fBestArea = RTREE_ZERO;  int iBestLeft = 0;  int nLeft;  for(  nLeft=RTREE_MINCELLS(pRtree);  nLeft<=(nCell-RTREE_MINCELLS(pRtree));  nLeft++  ){  RtreeCell left;  RtreeCell right;  int kk;  RtreeDValue overlap;  RtreeDValue area;  memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell));  memcpy(&right, &aCell[aaSorted[ii][nCell-1]], sizeof(RtreeCell));  for(kk=1; kk<(nCell-1); kk++){  if( kk<nLeft ){  cellUnion(pRtree, &left, &aCell[aaSorted[ii][kk]]);  }else{  cellUnion(pRtree, &right, &aCell[aaSorted[ii][kk]]);  }  }  margin += cellMargin(pRtree, &left);  margin += cellMargin(pRtree, &right);  overlap = cellOverlap(pRtree, &left, &right, 1);  area = cellArea(pRtree, &left) + cellArea(pRtree, &right);  if( (nLeft==RTREE_MINCELLS(pRtree))   || (overlap<fBestOverlap)   || (overlap==fBestOverlap && area<fBestArea)  ){  iBestLeft = nLeft;  fBestOverlap = overlap;  fBestArea = area;  }  }  if( ii==0 || margin<fBestMargin ){  iBestDim = ii;  fBestMargin = margin;  iBestSplit = iBestLeft;  }  }  memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell));  memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell));  for(ii=0; ii<nCell; ii++){  RtreeNode *pTarget = (ii<iBestSplit)?pLeft:pRight;  RtreeCell *pBbox = (ii<iBestSplit)?pBboxLeft:pBboxRight;  RtreeCell *pCell = &aCell[aaSorted[iBestDim][ii]];  nodeInsertCell(pRtree, pTarget, pCell);  cellUnion(pRtree, pBbox, pCell);  }  sqlite3_free(aaSorted);  return SQLITE_OK; } static int updateMapping(  Rtree *pRtree,  i64 iRowid,  RtreeNode *pNode,  int iHeight ){  int (*xSetMapping)(Rtree *, sqlite3_int64, sqlite3_int64);  xSetMapping = ((iHeight==0)?rowidWrite:parentWrite);  if( iHeight>0 ){  RtreeNode *pChild = nodeHashLookup(pRtree, iRowid);  RtreeNode *p;  for(p=pNode; p; p=p->pParent){  if( p==pChild ) return SQLITE_CORRUPT_VTAB;  }  if( pChild ){  nodeRelease(pRtree, pChild->pParent);  nodeReference(pNode);  pChild->pParent = pNode;  }  }  if( NEVER(pNode==0) ) return SQLITE_ERROR;  return xSetMapping(pRtree, iRowid, pNode->iNode); } static int SplitNode(  Rtree *pRtree,  RtreeNode *pNode,  RtreeCell *pCell,  int iHeight ){  int i;  int newCellIsRight = 0;  int rc = SQLITE_OK;  int nCell = NCELL(pNode);  RtreeCell *aCell;  int *aiUsed;  RtreeNode *pLeft = 0;  RtreeNode *pRight = 0;  RtreeCell leftbbox;  RtreeCell rightbbox;  aCell = sqlite3_malloc64((sizeof(RtreeCell)+sizeof(int))*(nCell+1));  if( !aCell ){  rc = SQLITE_NOMEM;  goto splitnode_out;  }  aiUsed = (int *)&aCell[nCell+1];  memset(aiUsed, 0, sizeof(int)*(nCell+1));  for(i=0; i<nCell; i++){  nodeGetCell(pRtree, pNode, i, &aCell[i]);  }  nodeZero(pRtree, pNode);  memcpy(&aCell[nCell], pCell, sizeof(RtreeCell));  nCell++;  if( pNode->iNode==1 ){  pRight = nodeNew(pRtree, pNode);  pLeft = nodeNew(pRtree, pNode);  pRtree->iDepth++;  pNode->isDirty = 1;  writeInt16(pNode->zData, pRtree->iDepth);  }else{  pLeft = pNode;  pRight = nodeNew(pRtree, pLeft->pParent);  pLeft->nRef++;  }  if( !pLeft || !pRight ){  rc = SQLITE_NOMEM;  goto splitnode_out;  }  memset(pLeft->zData, 0, pRtree->iNodeSize);  memset(pRight->zData, 0, pRtree->iNodeSize);  rc = splitNodeStartree(pRtree, aCell, nCell, pLeft, pRight,   &leftbbox, &rightbbox);  if( rc!=SQLITE_OK ){  goto splitnode_out;  }  if( SQLITE_OK!=(rc = nodeWrite(pRtree, pRight))   || (0==pLeft->iNode && SQLITE_OK!=(rc = nodeWrite(pRtree, pLeft)))  ){  goto splitnode_out;  }  rightbbox.iRowid = pRight->iNode;  leftbbox.iRowid = pLeft->iNode;  if( pNode->iNode==1 ){  rc = rtreeInsertCell(pRtree, pLeft->pParent, &leftbbox, iHeight+1);  if( rc!=SQLITE_OK ){  goto splitnode_out;  }  }else{  RtreeNode *pParent = pLeft->pParent;  int iCell;  rc = nodeParentIndex(pRtree, pLeft, &iCell);  if( ALWAYS(rc==SQLITE_OK) ){  nodeOverwriteCell(pRtree, pParent, &leftbbox, iCell);  rc = AdjustTree(pRtree, pParent, &leftbbox);  assert( rc==SQLITE_OK );  }  if( NEVER(rc!=SQLITE_OK) ){  goto splitnode_out;  }  }  if( (rc = rtreeInsertCell(pRtree, pRight->pParent, &rightbbox, iHeight+1)) ){  goto splitnode_out;  }  for(i=0; i<NCELL(pRight); i++){  i64 iRowid = nodeGetRowid(pRtree, pRight, i);  rc = updateMapping(pRtree, iRowid, pRight, iHeight);  if( iRowid==pCell->iRowid ){  newCellIsRight = 1;  }  if( rc!=SQLITE_OK ){  goto splitnode_out;  }  }  if( pNode->iNode==1 ){  for(i=0; i<NCELL(pLeft); i++){  i64 iRowid = nodeGetRowid(pRtree, pLeft, i);  rc = updateMapping(pRtree, iRowid, pLeft, iHeight);  if( rc!=SQLITE_OK ){  goto splitnode_out;  }  }  }else if( newCellIsRight==0 ){  rc = updateMapping(pRtree, pCell->iRowid, pLeft, iHeight);  }  if( rc==SQLITE_OK ){  rc = nodeRelease(pRtree, pRight);  pRight = 0;  }  if( rc==SQLITE_OK ){  rc = nodeRelease(pRtree, pLeft);  pLeft = 0;  } splitnode_out:  nodeRelease(pRtree, pRight);  nodeRelease(pRtree, pLeft);  sqlite3_free(aCell);  return rc; } static int fixLeafParent(Rtree *pRtree, RtreeNode *pLeaf){  int rc = SQLITE_OK;  RtreeNode *pChild = pLeaf;  while( rc==SQLITE_OK && pChild->iNode!=1 && pChild->pParent==0 ){  int rc2 = SQLITE_OK;  sqlite3_bind_int64(pRtree->pReadParent, 1, pChild->iNode);  rc = sqlite3_step(pRtree->pReadParent);  if( rc==SQLITE_ROW ){  RtreeNode *pTest;  i64 iNode;  iNode = sqlite3_column_int64(pRtree->pReadParent, 0);  for(pTest=pLeaf; pTest && pTest->iNode!=iNode; pTest=pTest->pParent);  if( pTest==0 ){  rc2 = nodeAcquire(pRtree, iNode, 0, &pChild->pParent);  }  }  rc = sqlite3_reset(pRtree->pReadParent);  if( rc==SQLITE_OK ) rc = rc2;  if( rc==SQLITE_OK && !pChild->pParent ){  RTREE_IS_CORRUPT(pRtree);  rc = SQLITE_CORRUPT_VTAB;  }  pChild = pChild->pParent;  }  return rc; } static int deleteCell(Rtree *, RtreeNode *, int, int); static int removeNode(Rtree *pRtree, RtreeNode *pNode, int iHeight){  int rc;  int rc2;  RtreeNode *pParent = 0;  int iCell;  assert( pNode->nRef==1 );  rc = nodeParentIndex(pRtree, pNode, &iCell);  if( rc==SQLITE_OK ){  pParent = pNode->pParent;  pNode->pParent = 0;  rc = deleteCell(pRtree, pParent, iCell, iHeight+1);  testcase( rc!=SQLITE_OK );  }  rc2 = nodeRelease(pRtree, pParent);  if( rc==SQLITE_OK ){  rc = rc2;  }  if( rc!=SQLITE_OK ){  return rc;  }  sqlite3_bind_int64(pRtree->pDeleteNode, 1, pNode->iNode);  sqlite3_step(pRtree->pDeleteNode);  if( SQLITE_OK!=(rc = sqlite3_reset(pRtree->pDeleteNode)) ){  return rc;  }  sqlite3_bind_int64(pRtree->pDeleteParent, 1, pNode->iNode);  sqlite3_step(pRtree->pDeleteParent);  if( SQLITE_OK!=(rc = sqlite3_reset(pRtree->pDeleteParent)) ){  return rc;  }  nodeHashDelete(pRtree, pNode);  pNode->iNode = iHeight;  pNode->pNext = pRtree->pDeleted;  pNode->nRef++;  pRtree->pDeleted = pNode;  return SQLITE_OK; } static int fixBoundingBox(Rtree *pRtree, RtreeNode *pNode){  RtreeNode *pParent = pNode->pParent;  int rc = SQLITE_OK;  if( pParent ){  int ii;  int nCell = NCELL(pNode);  RtreeCell box;  nodeGetCell(pRtree, pNode, 0, &box);  for(ii=1; ii<nCell; ii++){  RtreeCell cell;  nodeGetCell(pRtree, pNode, ii, &cell);  cellUnion(pRtree, &box, &cell);  }  box.iRowid = pNode->iNode;  rc = nodeParentIndex(pRtree, pNode, &ii);  if( rc==SQLITE_OK ){  nodeOverwriteCell(pRtree, pParent, &box, ii);  rc = fixBoundingBox(pRtree, pParent);  }  }  return rc; } static int deleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell, int iHeight){  RtreeNode *pParent;  int rc;  if( SQLITE_OK!=(rc = fixLeafParent(pRtree, pNode)) ){  return rc;  }  nodeDeleteCell(pRtree, pNode, iCell);  pParent = pNode->pParent;  assert( pParent || pNode->iNode==1 );  if( pParent ){  if( NCELL(pNode)<RTREE_MINCELLS(pRtree) ){  rc = removeNode(pRtree, pNode, iHeight);  }else{  rc = fixBoundingBox(pRtree, pNode);  }  }  return rc; } static int Reinsert(  Rtree *pRtree,  RtreeNode *pNode,  RtreeCell *pCell,  int iHeight ){  int *aOrder;  int *aSpare;  RtreeCell *aCell;  RtreeDValue *aDistance;  int nCell;  RtreeDValue aCenterCoord[RTREE_MAX_DIMENSIONS];  int iDim;  int ii;  int rc = SQLITE_OK;  int n;  memset(aCenterCoord, 0, sizeof(RtreeDValue)*RTREE_MAX_DIMENSIONS);  nCell = NCELL(pNode)+1;  n = (nCell+1)&(~1);  aCell = (RtreeCell *)sqlite3_malloc64(n * (  sizeof(RtreeCell)  +  sizeof(int)  +  sizeof(int)  +  sizeof(RtreeDValue)  ));  if( !aCell ){  return SQLITE_NOMEM;  }  aOrder = (int *)&aCell[n];  aSpare = (int *)&aOrder[n];  aDistance = (RtreeDValue *)&aSpare[n];  for(ii=0; ii<nCell; ii++){  if( ii==(nCell-1) ){  memcpy(&aCell[ii], pCell, sizeof(RtreeCell));  }else{  nodeGetCell(pRtree, pNode, ii, &aCell[ii]);  }  aOrder[ii] = ii;  for(iDim=0; iDim<pRtree->nDim; iDim++){  aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2]);  aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2+1]);  }  }  for(iDim=0; iDim<pRtree->nDim; iDim++){  aCenterCoord[iDim] = (aCenterCoord[iDim]/(nCell*(RtreeDValue)2));  }  for(ii=0; ii<nCell; ii++){  aDistance[ii] = RTREE_ZERO;  for(iDim=0; iDim<pRtree->nDim; iDim++){  RtreeDValue coord = (DCOORD(aCell[ii].aCoord[iDim*2+1]) -   DCOORD(aCell[ii].aCoord[iDim*2]));  aDistance[ii] += (coord-aCenterCoord[iDim])*(coord-aCenterCoord[iDim]);  }  }  SortByDistance(aOrder, nCell, aDistance, aSpare);  nodeZero(pRtree, pNode);  for(ii=0; rc==SQLITE_OK && ii<(nCell-(RTREE_MINCELLS(pRtree)+1)); ii++){  RtreeCell *p = &aCell[aOrder[ii]];  nodeInsertCell(pRtree, pNode, p);  if( p->iRowid==pCell->iRowid ){  if( iHeight==0 ){  rc = rowidWrite(pRtree, p->iRowid, pNode->iNode);  }else{  rc = parentWrite(pRtree, p->iRowid, pNode->iNode);  }  }  }  if( rc==SQLITE_OK ){  rc = fixBoundingBox(pRtree, pNode);  }  for(; rc==SQLITE_OK && ii<nCell; ii++){  RtreeNode *pInsert;  RtreeCell *p = &aCell[aOrder[ii]];  rc = ChooseLeaf(pRtree, p, iHeight, &pInsert);  if( rc==SQLITE_OK ){  int rc2;  rc = rtreeInsertCell(pRtree, pInsert, p, iHeight);  rc2 = nodeRelease(pRtree, pInsert);  if( rc==SQLITE_OK ){  rc = rc2;  }  }  }  sqlite3_free(aCell);  return rc; } static int rtreeInsertCell(  Rtree *pRtree,  RtreeNode *pNode,  RtreeCell *pCell,  int iHeight ){  int rc = SQLITE_OK;  if( iHeight>0 ){  RtreeNode *pChild = nodeHashLookup(pRtree, pCell->iRowid);  if( pChild ){  nodeRelease(pRtree, pChild->pParent);  nodeReference(pNode);  pChild->pParent = pNode;  }  }  if( nodeInsertCell(pRtree, pNode, pCell) ){  if( iHeight<=pRtree->iReinsertHeight || pNode->iNode==1){  rc = SplitNode(pRtree, pNode, pCell, iHeight);  }else{  pRtree->iReinsertHeight = iHeight;  rc = Reinsert(pRtree, pNode, pCell, iHeight);  }  }else{  rc = AdjustTree(pRtree, pNode, pCell);  if( ALWAYS(rc==SQLITE_OK) ){  if( iHeight==0 ){  rc = rowidWrite(pRtree, pCell->iRowid, pNode->iNode);  }else{  rc = parentWrite(pRtree, pCell->iRowid, pNode->iNode);  }  }  }  return rc; } static int reinsertNodeContent(Rtree *pRtree, RtreeNode *pNode){  int ii;  int rc = SQLITE_OK;  int nCell = NCELL(pNode);  for(ii=0; rc==SQLITE_OK && ii<nCell; ii++){  RtreeNode *pInsert;  RtreeCell cell;  nodeGetCell(pRtree, pNode, ii, &cell);  rc = ChooseLeaf(pRtree, &cell, (int)pNode->iNode, &pInsert);  if( rc==SQLITE_OK ){  int rc2;  rc = rtreeInsertCell(pRtree, pInsert, &cell, (int)pNode->iNode);  rc2 = nodeRelease(pRtree, pInsert);  if( rc==SQLITE_OK ){  rc = rc2;  }  }  }  return rc; } static int rtreeNewRowid(Rtree *pRtree, i64 *piRowid){  int rc;  sqlite3_bind_null(pRtree->pWriteRowid, 1);  sqlite3_bind_null(pRtree->pWriteRowid, 2);  sqlite3_step(pRtree->pWriteRowid);  rc = sqlite3_reset(pRtree->pWriteRowid);  *piRowid = sqlite3_last_insert_rowid(pRtree->db);  return rc; } static int rtreeDeleteRowid(Rtree *pRtree, sqlite3_int64 iDelete){  int rc;  RtreeNode *pLeaf = 0;  int iCell;  RtreeNode *pRoot = 0;  rc = nodeAcquire(pRtree, 1, 0, &pRoot);  if( rc==SQLITE_OK ){  rc = findLeafNode(pRtree, iDelete, &pLeaf, 0);  }
#ifdef CORRUPT_DB
 assert( pLeaf!=0 || rc!=SQLITE_OK || CORRUPT_DB );
#endif
 if( rc==SQLITE_OK && pLeaf ){  int rc2;  rc = nodeRowidIndex(pRtree, pLeaf, iDelete, &iCell);  if( rc==SQLITE_OK ){  rc = deleteCell(pRtree, pLeaf, iCell, 0);  }  rc2 = nodeRelease(pRtree, pLeaf);  if( rc==SQLITE_OK ){  rc = rc2;  }  }  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pRtree->pDeleteRowid, 1, iDelete);  sqlite3_step(pRtree->pDeleteRowid);  rc = sqlite3_reset(pRtree->pDeleteRowid);  }  if( rc==SQLITE_OK && pRtree->iDepth>0 && NCELL(pRoot)==1 ){  int rc2;  RtreeNode *pChild = 0;  i64 iChild = nodeGetRowid(pRtree, pRoot, 0);  rc = nodeAcquire(pRtree, iChild, pRoot, &pChild);  if( rc==SQLITE_OK ){  rc = removeNode(pRtree, pChild, pRtree->iDepth-1);  }  rc2 = nodeRelease(pRtree, pChild);  if( rc==SQLITE_OK ) rc = rc2;  if( rc==SQLITE_OK ){  pRtree->iDepth--;  writeInt16(pRoot->zData, pRtree->iDepth);  pRoot->isDirty = 1;  }  }  for(pLeaf=pRtree->pDeleted; pLeaf; pLeaf=pRtree->pDeleted){  if( rc==SQLITE_OK ){  rc = reinsertNodeContent(pRtree, pLeaf);  }  pRtree->pDeleted = pLeaf->pNext;  pRtree->nNodeRef--;  sqlite3_free(pLeaf);  }  if( rc==SQLITE_OK ){  rc = nodeRelease(pRtree, pRoot);  }else{  nodeRelease(pRtree, pRoot);  }  return rc; }
#define RNDTOWARDS (1.0 - 1.0/8388608.0)
#define RNDAWAY  (1.0 + 1.0/8388608.0)
#if !defined(SQLITE_RTREE_INT_ONLY)
static RtreeValue rtreeValueDown(sqlite3_value *v){  double d = sqlite3_value_double(v);  float f = (float)d;  if( f>d ){  f = (float)(d*(d<0 ? RNDAWAY : RNDTOWARDS));  }  return f; } static RtreeValue rtreeValueUp(sqlite3_value *v){  double d = sqlite3_value_double(v);  float f = (float)d;  if( f<d ){  f = (float)(d*(d<0 ? RNDTOWARDS : RNDAWAY));  }  return f; }
#endif
static int rtreeConstraintError(Rtree *pRtree, int iCol){  sqlite3_stmt *pStmt = 0;  char *zSql;  int rc;  assert( iCol==0 || iCol%2 );  zSql = sqlite3_mprintf("SELECT * FROM %Q.%Q", pRtree->zDb, pRtree->zName);  if( zSql ){  rc = sqlite3_prepare_v2(pRtree->db, zSql, -1, &pStmt, 0);  }else{  rc = SQLITE_NOMEM;  }  sqlite3_free(zSql);  if( rc==SQLITE_OK ){  if( iCol==0 ){  const char *zCol = sqlite3_column_name(pStmt, 0);  pRtree->base.zErrMsg = sqlite3_mprintf(  "UNIQUE constraint failed: %s.%s", pRtree->zName, zCol  );  }else{  const char *zCol1 = sqlite3_column_name(pStmt, iCol);  const char *zCol2 = sqlite3_column_name(pStmt, iCol+1);  pRtree->base.zErrMsg = sqlite3_mprintf(  "rtree constraint failed: %s.(%s<=%s)", pRtree->zName, zCol1, zCol2  );  }  }  sqlite3_finalize(pStmt);  return (rc==SQLITE_OK ? SQLITE_CONSTRAINT : rc); } static int rtreeUpdate(  sqlite3_vtab *pVtab,  int nData,  sqlite3_value **aData,  sqlite_int64 *pRowid ){  Rtree *pRtree = (Rtree *)pVtab;  int rc = SQLITE_OK;  RtreeCell cell;  int bHaveRowid = 0;  if( pRtree->nNodeRef ){  return SQLITE_LOCKED_VTAB;  }  rtreeReference(pRtree);  assert(nData>=1);  cell.iRowid = 0;  if( nData>1 ){  int ii;  int nn = nData - 4;  if( nn > pRtree->nDim2 ) nn = pRtree->nDim2;
#ifndef SQLITE_RTREE_INT_ONLY
 if( pRtree->eCoordType==RTREE_COORD_REAL32 ){  for(ii=0; ii<nn; ii+=2){  cell.aCoord[ii].f = rtreeValueDown(aData[ii+3]);  cell.aCoord[ii+1].f = rtreeValueUp(aData[ii+4]);  if( cell.aCoord[ii].f>cell.aCoord[ii+1].f ){  rc = rtreeConstraintError(pRtree, ii+1);  goto constraint;  }  }  }else
#endif
 {  for(ii=0; ii<nn; ii+=2){  cell.aCoord[ii].i = sqlite3_value_int(aData[ii+3]);  cell.aCoord[ii+1].i = sqlite3_value_int(aData[ii+4]);  if( cell.aCoord[ii].i>cell.aCoord[ii+1].i ){  rc = rtreeConstraintError(pRtree, ii+1);  goto constraint;  }  }  }  if( sqlite3_value_type(aData[2])!=SQLITE_NULL ){  cell.iRowid = sqlite3_value_int64(aData[2]);  if( sqlite3_value_type(aData[0])==SQLITE_NULL   || sqlite3_value_int64(aData[0])!=cell.iRowid  ){  int steprc;  sqlite3_bind_int64(pRtree->pReadRowid, 1, cell.iRowid);  steprc = sqlite3_step(pRtree->pReadRowid);  rc = sqlite3_reset(pRtree->pReadRowid);  if( SQLITE_ROW==steprc ){  if( sqlite3_vtab_on_conflict(pRtree->db)==SQLITE_REPLACE ){  rc = rtreeDeleteRowid(pRtree, cell.iRowid);  }else{  rc = rtreeConstraintError(pRtree, 0);  goto constraint;  }  }  }  bHaveRowid = 1;  }  }  if( sqlite3_value_type(aData[0])!=SQLITE_NULL ){  rc = rtreeDeleteRowid(pRtree, sqlite3_value_int64(aData[0]));  }  if( rc==SQLITE_OK && nData>1 ){  RtreeNode *pLeaf = 0;  if( bHaveRowid==0 ){  rc = rtreeNewRowid(pRtree, &cell.iRowid);  }  *pRowid = cell.iRowid;  if( rc==SQLITE_OK ){  rc = ChooseLeaf(pRtree, &cell, 0, &pLeaf);  }  if( rc==SQLITE_OK ){  int rc2;  pRtree->iReinsertHeight = -1;  rc = rtreeInsertCell(pRtree, pLeaf, &cell, 0);  rc2 = nodeRelease(pRtree, pLeaf);  if( rc==SQLITE_OK ){  rc = rc2;  }  }  if( rc==SQLITE_OK && pRtree->nAux ){  sqlite3_stmt *pUp = pRtree->pWriteAux;  int jj;  sqlite3_bind_int64(pUp, 1, *pRowid);  for(jj=0; jj<pRtree->nAux; jj++){  sqlite3_bind_value(pUp, jj+2, aData[pRtree->nDim2+3+jj]);  }  sqlite3_step(pUp);  rc = sqlite3_reset(pUp);  }  } constraint:  rtreeRelease(pRtree);  return rc; } static int rtreeBeginTransaction(sqlite3_vtab *pVtab){  Rtree *pRtree = (Rtree *)pVtab;  assert( pRtree->inWrTrans==0 );  pRtree->inWrTrans++;  return SQLITE_OK; } static int rtreeEndTransaction(sqlite3_vtab *pVtab){  Rtree *pRtree = (Rtree *)pVtab;  pRtree->inWrTrans = 0;  nodeBlobReset(pRtree);  return SQLITE_OK; } static int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName){  Rtree *pRtree = (Rtree *)pVtab;  int rc = SQLITE_NOMEM;  char *zSql = sqlite3_mprintf(  "ALTER TABLE %Q.'%q_node'  RENAME TO \"%w_node\";"  "ALTER TABLE %Q.'%q_parent' RENAME TO \"%w_parent\";"  "ALTER TABLE %Q.'%q_rowid' RENAME TO \"%w_rowid\";"  , pRtree->zDb, pRtree->zName, zNewName  , pRtree->zDb, pRtree->zName, zNewName  , pRtree->zDb, pRtree->zName, zNewName  );  if( zSql ){  nodeBlobReset(pRtree);  rc = sqlite3_exec(pRtree->db, zSql, 0, 0, 0);  sqlite3_free(zSql);  }  return rc; } static int rtreeSavepoint(sqlite3_vtab *pVtab, int iSavepoint){  Rtree *pRtree = (Rtree *)pVtab;  u8 iwt = pRtree->inWrTrans;  UNUSED_PARAMETER(iSavepoint);  pRtree->inWrTrans = 0;  nodeBlobReset(pRtree);  pRtree->inWrTrans = iwt;  return SQLITE_OK; } static int rtreeQueryStat1(sqlite3 *db, Rtree *pRtree){  const char *zFmt = "SELECT stat FROM %Q.sqlite_stat1 WHERE tbl = '%q_rowid'";  char *zSql;  sqlite3_stmt *p;  int rc;  i64 nRow = RTREE_MIN_ROWEST;  rc = sqlite3_table_column_metadata(  db, pRtree->zDb, "sqlite_stat1",0,0,0,0,0,0  );  if( rc!=SQLITE_OK ){  pRtree->nRowEst = RTREE_DEFAULT_ROWEST;  return rc==SQLITE_ERROR ? SQLITE_OK : rc;  }  zSql = sqlite3_mprintf(zFmt, pRtree->zDb, pRtree->zName);  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v2(db, zSql, -1, &p, 0);  if( rc==SQLITE_OK ){  if( sqlite3_step(p)==SQLITE_ROW ) nRow = sqlite3_column_int64(p, 0);  rc = sqlite3_finalize(p);  }  sqlite3_free(zSql);  }  pRtree->nRowEst = MAX(nRow, RTREE_MIN_ROWEST);  return rc; } static int rtreeShadowName(const char *zName){  static const char *azName[] = {  "node", "parent", "rowid"  };  unsigned int i;  for(i=0; i<sizeof(azName)/sizeof(azName[0]); i++){  if( sqlite3_stricmp(zName, azName[i])==0 ) return 1;  }  return 0; } static sqlite3_module rtreeModule = {  3,  rtreeCreate,  rtreeConnect,  rtreeBestIndex,  rtreeDisconnect,  rtreeDestroy,  rtreeOpen,  rtreeClose,  rtreeFilter,  rtreeNext,  rtreeEof,  rtreeColumn,  rtreeRowid,  rtreeUpdate,  rtreeBeginTransaction,  rtreeEndTransaction,  rtreeEndTransaction,  rtreeEndTransaction,  0,  rtreeRename,  rtreeSavepoint,  0,  0,  rtreeShadowName }; static int rtreeSqlInit(  Rtree *pRtree,  sqlite3 *db,  const char *zDb,  const char *zPrefix,  int isCreate ){  int rc = SQLITE_OK;
 #define N_STATEMENT 8
 static const char *azSql[N_STATEMENT] = {  "INSERT OR REPLACE INTO '%q'.'%q_node' VALUES(?1, ?2)",  "DELETE FROM '%q'.'%q_node' WHERE nodeno = ?1",  "SELECT nodeno FROM '%q'.'%q_rowid' WHERE rowid = ?1",  "INSERT OR REPLACE INTO '%q'.'%q_rowid' VALUES(?1, ?2)",  "DELETE FROM '%q'.'%q_rowid' WHERE rowid = ?1",  "SELECT parentnode FROM '%q'.'%q_parent' WHERE nodeno = ?1",  "INSERT OR REPLACE INTO '%q'.'%q_parent' VALUES(?1, ?2)",  "DELETE FROM '%q'.'%q_parent' WHERE nodeno = ?1"  };  sqlite3_stmt **appStmt[N_STATEMENT];  int i;  const int f = SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_NO_VTAB;  pRtree->db = db;  if( isCreate ){  char *zCreate;  sqlite3_str *p = sqlite3_str_new(db);  int ii;  sqlite3_str_appendf(p,   "CREATE TABLE \"%w\".\"%w_rowid\"(rowid INTEGER PRIMARY KEY,nodeno",   zDb, zPrefix);  for(ii=0; ii<pRtree->nAux; ii++){  sqlite3_str_appendf(p,",a%d",ii);  }  sqlite3_str_appendf(p,  ");CREATE TABLE \"%w\".\"%w_node\"(nodeno INTEGER PRIMARY KEY,data);",  zDb, zPrefix);  sqlite3_str_appendf(p,  "CREATE TABLE \"%w\".\"%w_parent\"(nodeno INTEGER PRIMARY KEY,parentnode);",  zDb, zPrefix);  sqlite3_str_appendf(p,   "INSERT INTO \"%w\".\"%w_node\"VALUES(1,zeroblob(%d))",   zDb, zPrefix, pRtree->iNodeSize);  zCreate = sqlite3_str_finish(p);  if( !zCreate ){  return SQLITE_NOMEM;  }  rc = sqlite3_exec(db, zCreate, 0, 0, 0);  sqlite3_free(zCreate);  if( rc!=SQLITE_OK ){  return rc;  }  }  appStmt[0] = &pRtree->pWriteNode;  appStmt[1] = &pRtree->pDeleteNode;  appStmt[2] = &pRtree->pReadRowid;  appStmt[3] = &pRtree->pWriteRowid;  appStmt[4] = &pRtree->pDeleteRowid;  appStmt[5] = &pRtree->pReadParent;  appStmt[6] = &pRtree->pWriteParent;  appStmt[7] = &pRtree->pDeleteParent;  rc = rtreeQueryStat1(db, pRtree);  for(i=0; i<N_STATEMENT && rc==SQLITE_OK; i++){  char *zSql;  const char *zFormat;  if( i!=3 || pRtree->nAux==0 ){   zFormat = azSql[i];  }else {   zFormat = "INSERT INTO\"%w\".\"%w_rowid\"(rowid,nodeno)VALUES(?1,?2)"  "ON CONFLICT(rowid)DO UPDATE SET nodeno=excluded.nodeno";  }  zSql = sqlite3_mprintf(zFormat, zDb, zPrefix);  if( zSql ){  rc = sqlite3_prepare_v3(db, zSql, -1, f, appStmt[i], 0);  }else{  rc = SQLITE_NOMEM;  }  sqlite3_free(zSql);  }  if( pRtree->nAux ){  pRtree->zReadAuxSql = sqlite3_mprintf(   "SELECT * FROM \"%w\".\"%w_rowid\" WHERE rowid=?1",   zDb, zPrefix);  if( pRtree->zReadAuxSql==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_str *p = sqlite3_str_new(db);  int ii;  char *zSql;  sqlite3_str_appendf(p, "UPDATE \"%w\".\"%w_rowid\"SET ", zDb, zPrefix);  for(ii=0; ii<pRtree->nAux; ii++){  if( ii ) sqlite3_str_append(p, ",", 1);
#ifdef SQLITE_ENABLE_GEOPOLY
 if( ii<pRtree->nAuxNotNull ){  sqlite3_str_appendf(p,"a%d=coalesce(?%d,a%d)",ii,ii+2,ii);  }else
#endif
 {  sqlite3_str_appendf(p,"a%d=?%d",ii,ii+2);  }  }  sqlite3_str_appendf(p, " WHERE rowid=?1");  zSql = sqlite3_str_finish(p);  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v3(db, zSql, -1, f, &pRtree->pWriteAux, 0);  sqlite3_free(zSql);  }  }  }  return rc; } static int getIntFromStmt(sqlite3 *db, const char *zSql, int *piVal){  int rc = SQLITE_NOMEM;  if( zSql ){  sqlite3_stmt *pStmt = 0;  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  *piVal = sqlite3_column_int(pStmt, 0);  }  rc = sqlite3_finalize(pStmt);  }  }  return rc; } static int getNodeSize(  sqlite3 *db,  Rtree *pRtree,  int isCreate,  char **pzErr ){  int rc;  char *zSql;  if( isCreate ){  int iPageSize = 0;  zSql = sqlite3_mprintf("PRAGMA %Q.page_size", pRtree->zDb);  rc = getIntFromStmt(db, zSql, &iPageSize);  if( rc==SQLITE_OK ){  pRtree->iNodeSize = iPageSize-64;  if( (4+pRtree->nBytesPerCell*RTREE_MAXCELLS)<pRtree->iNodeSize ){  pRtree->iNodeSize = 4+pRtree->nBytesPerCell*RTREE_MAXCELLS;  }  }else{  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  }  }else{  zSql = sqlite3_mprintf(  "SELECT length(data) FROM '%q'.'%q_node' WHERE nodeno = 1",  pRtree->zDb, pRtree->zName  );  rc = getIntFromStmt(db, zSql, &pRtree->iNodeSize);  if( rc!=SQLITE_OK ){  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  }else if( pRtree->iNodeSize<(512-64) ){  rc = SQLITE_CORRUPT_VTAB;  RTREE_IS_CORRUPT(pRtree);  *pzErr = sqlite3_mprintf("undersize RTree blobs in \"%q_node\"",   pRtree->zName);  }  }  sqlite3_free(zSql);  return rc; } static int rtreeTokenLength(const char *z){  int dummy = 0;  return sqlite3GetToken((const unsigned char*)z,&dummy); } static int rtreeInit(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr,  int isCreate ){  int rc = SQLITE_OK;  Rtree *pRtree;  int nDb;  int nName;  int eCoordType = (pAux ? RTREE_COORD_INT32 : RTREE_COORD_REAL32);  sqlite3_str *pSql;  char *zSql;  int ii = 4;  int iErr;  const char *aErrMsg[] = {  0,  "Wrong number of columns for an rtree table",  "Too few columns for an rtree table",  "Too many columns for an rtree table",  "Auxiliary rtree columns must be last"  };  assert( RTREE_MAX_AUX_COLUMN<256 );  if( argc<6 || argc>RTREE_MAX_AUX_COLUMN+3 ){  *pzErr = sqlite3_mprintf("%s", aErrMsg[2 + (argc>=6)]);  return SQLITE_ERROR;  }  sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);  nDb = (int)strlen(argv[1]);  nName = (int)strlen(argv[2]);  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName+2);  if( !pRtree ){  return SQLITE_NOMEM;  }  memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);  pRtree->nBusy = 1;  pRtree->base.pModule = &rtreeModule;  pRtree->zDb = (char *)&pRtree[1];  pRtree->zName = &pRtree->zDb[nDb+1];  pRtree->eCoordType = (u8)eCoordType;  memcpy(pRtree->zDb, argv[1], nDb);  memcpy(pRtree->zName, argv[2], nName);  pSql = sqlite3_str_new(db);  sqlite3_str_appendf(pSql, "CREATE TABLE x(%.*s INT",  rtreeTokenLength(argv[3]), argv[3]);  for(ii=4; ii<argc; ii++){  const char *zArg = argv[ii];  if( zArg[0]=='+' ){  pRtree->nAux++;  sqlite3_str_appendf(pSql, ",%.*s", rtreeTokenLength(zArg+1), zArg+1);  }else if( pRtree->nAux>0 ){  break;  }else{  static const char *azFormat[] = {",%.*s REAL", ",%.*s INT"};  pRtree->nDim2++;  sqlite3_str_appendf(pSql, azFormat[eCoordType],  rtreeTokenLength(zArg), zArg);  }  }  sqlite3_str_appendf(pSql, ");");  zSql = sqlite3_str_finish(pSql);  if( !zSql ){  rc = SQLITE_NOMEM;  }else if( ii<argc ){  *pzErr = sqlite3_mprintf("%s", aErrMsg[4]);  rc = SQLITE_ERROR;  }else if( SQLITE_OK!=(rc = sqlite3_declare_vtab(db, zSql)) ){  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  }  sqlite3_free(zSql);  if( rc ) goto rtreeInit_fail;  pRtree->nDim = pRtree->nDim2/2;  if( pRtree->nDim<1 ){  iErr = 2;  }else if( pRtree->nDim2>RTREE_MAX_DIMENSIONS*2 ){  iErr = 3;  }else if( pRtree->nDim2 % 2 ){  iErr = 1;  }else{  iErr = 0;  }  if( iErr ){  *pzErr = sqlite3_mprintf("%s", aErrMsg[iErr]);  goto rtreeInit_fail;  }  pRtree->nBytesPerCell = 8 + pRtree->nDim2*4;  rc = getNodeSize(db, pRtree, isCreate, pzErr);  if( rc ) goto rtreeInit_fail;  rc = rtreeSqlInit(pRtree, db, argv[1], argv[2], isCreate);  if( rc ){  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  goto rtreeInit_fail;  }  *ppVtab = (sqlite3_vtab *)pRtree;  return SQLITE_OK; rtreeInit_fail:  if( rc==SQLITE_OK ) rc = SQLITE_ERROR;  assert( *ppVtab==0 );  assert( pRtree->nBusy==1 );  rtreeRelease(pRtree);  return rc; } static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){  RtreeNode node;  Rtree tree;  int ii;  int nData;  int errCode;  sqlite3_str *pOut;  UNUSED_PARAMETER(nArg);  memset(&node, 0, sizeof(RtreeNode));  memset(&tree, 0, sizeof(Rtree));  tree.nDim = (u8)sqlite3_value_int(apArg[0]);  if( tree.nDim<1 || tree.nDim>5 ) return;  tree.nDim2 = tree.nDim*2;  tree.nBytesPerCell = 8 + 8 * tree.nDim;  node.zData = (u8 *)sqlite3_value_blob(apArg[1]);  if( node.zData==0 ) return;  nData = sqlite3_value_bytes(apArg[1]);  if( nData<4 ) return;  if( nData<NCELL(&node)*tree.nBytesPerCell ) return;  pOut = sqlite3_str_new(0);  for(ii=0; ii<NCELL(&node); ii++){  RtreeCell cell;  int jj;  nodeGetCell(&tree, &node, ii, &cell);  if( ii>0 ) sqlite3_str_append(pOut, " ", 1);  sqlite3_str_appendf(pOut, "{%lld", cell.iRowid);  for(jj=0; jj<tree.nDim2; jj++){
#ifndef SQLITE_RTREE_INT_ONLY
 sqlite3_str_appendf(pOut, " %g", (double)cell.aCoord[jj].f);
#else
 sqlite3_str_appendf(pOut, " %d", cell.aCoord[jj].i);
#endif
 }  sqlite3_str_append(pOut, "}", 1);  }  errCode = sqlite3_str_errcode(pOut);  sqlite3_result_text(ctx, sqlite3_str_finish(pOut), -1, sqlite3_free);  sqlite3_result_error_code(ctx, errCode); } static void rtreedepth(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){  UNUSED_PARAMETER(nArg);  if( sqlite3_value_type(apArg[0])!=SQLITE_BLOB   || sqlite3_value_bytes(apArg[0])<2  ){  sqlite3_result_error(ctx, "Invalid argument to rtreedepth()", -1);  }else{  u8 *zBlob = (u8 *)sqlite3_value_blob(apArg[0]);  if( zBlob ){  sqlite3_result_int(ctx, readInt16(zBlob));  }else{  sqlite3_result_error_nomem(ctx);  }  } } typedef struct RtreeCheck RtreeCheck; struct RtreeCheck {  sqlite3 *db;  const char *zDb;  const char *zTab;  int bInt;  int nDim;  sqlite3_stmt *pGetNode;  sqlite3_stmt *aCheckMapping[2];  int nLeaf;  int nNonLeaf;  int rc;  char *zReport;  int nErr; };
#define RTREE_CHECK_MAX_ERROR 100
static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){  int rc = sqlite3_reset(pStmt);  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc; } static sqlite3_stmt *rtreeCheckPrepare(  RtreeCheck *pCheck,  const char *zFmt, ... ){  va_list ap;  char *z;  sqlite3_stmt *pRet = 0;  va_start(ap, zFmt);  z = sqlite3_vmprintf(zFmt, ap);  if( pCheck->rc==SQLITE_OK ){  if( z==0 ){  pCheck->rc = SQLITE_NOMEM;  }else{  pCheck->rc = sqlite3_prepare_v2(pCheck->db, z, -1, &pRet, 0);  }  }  sqlite3_free(z);  va_end(ap);  return pRet; } static void rtreeCheckAppendMsg(RtreeCheck *pCheck, const char *zFmt, ...){  va_list ap;  va_start(ap, zFmt);  if( pCheck->rc==SQLITE_OK && pCheck->nErr<RTREE_CHECK_MAX_ERROR ){  char *z = sqlite3_vmprintf(zFmt, ap);  if( z==0 ){  pCheck->rc = SQLITE_NOMEM;  }else{  pCheck->zReport = sqlite3_mprintf("%z%s%z",  pCheck->zReport, (pCheck->zReport ? "\n" : ""), z  );  if( pCheck->zReport==0 ){  pCheck->rc = SQLITE_NOMEM;  }  }  pCheck->nErr++;  }  va_end(ap); } static u8 *rtreeCheckGetNode(RtreeCheck *pCheck, i64 iNode, int *pnNode){  u8 *pRet = 0;  if( pCheck->rc==SQLITE_OK && pCheck->pGetNode==0 ){  pCheck->pGetNode = rtreeCheckPrepare(pCheck,  "SELECT data FROM %Q.'%q_node' WHERE nodeno=?",  pCheck->zDb, pCheck->zTab  );  }  if( pCheck->rc==SQLITE_OK ){  sqlite3_bind_int64(pCheck->pGetNode, 1, iNode);  if( sqlite3_step(pCheck->pGetNode)==SQLITE_ROW ){  int nNode = sqlite3_column_bytes(pCheck->pGetNode, 0);  const u8 *pNode = (const u8*)sqlite3_column_blob(pCheck->pGetNode, 0);  pRet = sqlite3_malloc64(nNode);  if( pRet==0 ){  pCheck->rc = SQLITE_NOMEM;  }else{  memcpy(pRet, pNode, nNode);  *pnNode = nNode;  }  }  rtreeCheckReset(pCheck, pCheck->pGetNode);  if( pCheck->rc==SQLITE_OK && pRet==0 ){  rtreeCheckAppendMsg(pCheck, "Node %lld missing from database", iNode);  }  }  return pRet; } static void rtreeCheckMapping(  RtreeCheck *pCheck,  int bLeaf,  i64 iKey,  i64 iVal ){  int rc;  sqlite3_stmt *pStmt;  const char *azSql[2] = {  "SELECT parentnode FROM %Q.'%q_parent' WHERE nodeno=?1",  "SELECT nodeno FROM %Q.'%q_rowid' WHERE rowid=?1"  };  assert( bLeaf==0 || bLeaf==1 );  if( pCheck->aCheckMapping[bLeaf]==0 ){  pCheck->aCheckMapping[bLeaf] = rtreeCheckPrepare(pCheck,  azSql[bLeaf], pCheck->zDb, pCheck->zTab  );  }  if( pCheck->rc!=SQLITE_OK ) return;  pStmt = pCheck->aCheckMapping[bLeaf];  sqlite3_bind_int64(pStmt, 1, iKey);  rc = sqlite3_step(pStmt);  if( rc==SQLITE_DONE ){  rtreeCheckAppendMsg(pCheck, "Mapping (%lld -> %lld) missing from %s table",  iKey, iVal, (bLeaf ? "%_rowid" : "%_parent")  );  }else if( rc==SQLITE_ROW ){  i64 ii = sqlite3_column_int64(pStmt, 0);  if( ii!=iVal ){  rtreeCheckAppendMsg(pCheck,  "Found (%lld -> %lld) in %s table, expected (%lld -> %lld)",  iKey, ii, (bLeaf ? "%_rowid" : "%_parent"), iKey, iVal  );  }  }  rtreeCheckReset(pCheck, pStmt); } static void rtreeCheckCellCoord(  RtreeCheck *pCheck,  i64 iNode,  int iCell,  u8 *pCell,  u8 *pParent ){  RtreeCoord c1, c2;  RtreeCoord p1, p2;  int i;  for(i=0; i<pCheck->nDim; i++){  readCoord(&pCell[4*2*i], &c1);  readCoord(&pCell[4*(2*i + 1)], &c2);  if( pCheck->bInt ? c1.i>c2.i : c1.f>c2.f ){  rtreeCheckAppendMsg(pCheck,  "Dimension %d of cell %d on node %lld is corrupt", i, iCell, iNode  );  }  if( pParent ){  readCoord(&pParent[4*2*i], &p1);  readCoord(&pParent[4*(2*i + 1)], &p2);  if( (pCheck->bInt ? c1.i<p1.i : c1.f<p1.f)   || (pCheck->bInt ? c2.i>p2.i : c2.f>p2.f)  ){  rtreeCheckAppendMsg(pCheck,  "Dimension %d of cell %d on node %lld is corrupt relative to parent"  , i, iCell, iNode  );  }  }  } } static void rtreeCheckNode(  RtreeCheck *pCheck,  int iDepth,  u8 *aParent,  i64 iNode ){  u8 *aNode = 0;  int nNode = 0;  assert( iNode==1 || aParent!=0 );  assert( pCheck->nDim>0 );  aNode = rtreeCheckGetNode(pCheck, iNode, &nNode);  if( aNode ){  if( nNode<4 ){  rtreeCheckAppendMsg(pCheck,  "Node %lld is too small (%d bytes)", iNode, nNode  );  }else{  int nCell;  int i;  if( aParent==0 ){  iDepth = readInt16(aNode);  if( iDepth>RTREE_MAX_DEPTH ){  rtreeCheckAppendMsg(pCheck, "Rtree depth out of range (%d)", iDepth);  sqlite3_free(aNode);  return;  }  }  nCell = readInt16(&aNode[2]);  if( (4 + nCell*(8 + pCheck->nDim*2*4))>nNode ){  rtreeCheckAppendMsg(pCheck,  "Node %lld is too small for cell count of %d (%d bytes)",  iNode, nCell, nNode  );  }else{  for(i=0; i<nCell; i++){  u8 *pCell = &aNode[4 + i*(8 + pCheck->nDim*2*4)];  i64 iVal = readInt64(pCell);  rtreeCheckCellCoord(pCheck, iNode, i, &pCell[8], aParent);  if( iDepth>0 ){  rtreeCheckMapping(pCheck, 0, iVal, iNode);  rtreeCheckNode(pCheck, iDepth-1, &pCell[8], iVal);  pCheck->nNonLeaf++;  }else{  rtreeCheckMapping(pCheck, 1, iVal, iNode);  pCheck->nLeaf++;  }  }  }  }  sqlite3_free(aNode);  } } static void rtreeCheckCount(RtreeCheck *pCheck, const char *zTbl, i64 nExpect){  if( pCheck->rc==SQLITE_OK ){  sqlite3_stmt *pCount;  pCount = rtreeCheckPrepare(pCheck, "SELECT count(*) FROM %Q.'%q%s'",  pCheck->zDb, pCheck->zTab, zTbl  );  if( pCount ){  if( sqlite3_step(pCount)==SQLITE_ROW ){  i64 nActual = sqlite3_column_int64(pCount, 0);  if( nActual!=nExpect ){  rtreeCheckAppendMsg(pCheck, "Wrong number of entries in %%%s table"  " - expected %lld, actual %lld" , zTbl, nExpect, nActual  );  }  }  pCheck->rc = sqlite3_finalize(pCount);  }  } } static int rtreeCheckTable(  sqlite3 *db,  const char *zDb,  const char *zTab,  char **pzReport ){  RtreeCheck check;  sqlite3_stmt *pStmt = 0;  int bEnd = 0;  int nAux = 0;  memset(&check, 0, sizeof(check));  check.db = db;  check.zDb = zDb;  check.zTab = zTab;  if( sqlite3_get_autocommit(db) ){  check.rc = sqlite3_exec(db, "BEGIN", 0, 0, 0);  bEnd = 1;  }  if( check.rc==SQLITE_OK ){  pStmt = rtreeCheckPrepare(&check, "SELECT * FROM %Q.'%q_rowid'", zDb, zTab);  if( pStmt ){  nAux = sqlite3_column_count(pStmt) - 2;  sqlite3_finalize(pStmt);  }else  if( check.rc!=SQLITE_NOMEM ){  check.rc = SQLITE_OK;  }  }  pStmt = rtreeCheckPrepare(&check, "SELECT * FROM %Q.%Q", zDb, zTab);  if( pStmt ){  int rc;  check.nDim = (sqlite3_column_count(pStmt) - 1 - nAux) / 2;  if( check.nDim<1 ){  rtreeCheckAppendMsg(&check, "Schema corrupt or not an rtree");  }else if( SQLITE_ROW==sqlite3_step(pStmt) ){  check.bInt = (sqlite3_column_type(pStmt, 1)==SQLITE_INTEGER);  }  rc = sqlite3_finalize(pStmt);  if( rc!=SQLITE_CORRUPT ) check.rc = rc;  }  if( check.nDim>=1 ){  if( check.rc==SQLITE_OK ){  rtreeCheckNode(&check, 0, 0, 1);  }  rtreeCheckCount(&check, "_rowid", check.nLeaf);  rtreeCheckCount(&check, "_parent", check.nNonLeaf);  }  sqlite3_finalize(check.pGetNode);  sqlite3_finalize(check.aCheckMapping[0]);  sqlite3_finalize(check.aCheckMapping[1]);  if( bEnd ){  int rc = sqlite3_exec(db, "END", 0, 0, 0);  if( check.rc==SQLITE_OK ) check.rc = rc;  }  *pzReport = check.zReport;  return check.rc; } static void rtreecheck(  sqlite3_context *ctx,  int nArg,  sqlite3_value **apArg ){  if( nArg!=1 && nArg!=2 ){  sqlite3_result_error(ctx,  "wrong number of arguments to function rtreecheck()", -1  );  }else{  int rc;  char *zReport = 0;  const char *zDb = (const char*)sqlite3_value_text(apArg[0]);  const char *zTab;  if( nArg==1 ){  zTab = zDb;  zDb = "main";  }else{  zTab = (const char*)sqlite3_value_text(apArg[1]);  }  rc = rtreeCheckTable(sqlite3_context_db_handle(ctx), zDb, zTab, &zReport);  if( rc==SQLITE_OK ){  sqlite3_result_text(ctx, zReport ? zReport : "ok", -1, SQLITE_TRANSIENT);  }else{  sqlite3_result_error_code(ctx, rc);  }  sqlite3_free(zReport);  } }
#ifdef SQLITE_ENABLE_GEOPOLY
#ifdef GEOPOLY_ENABLE_DEBUG
 static int geo_debug = 0;
# define GEODEBUG(X) if(geo_debug)printf X
#else
# define GEODEBUG(X)
#endif
#ifndef JSON_NULL
#ifdef sqlite3Isdigit
# define safe_isdigit(x) sqlite3Isdigit(x)
# define safe_isalnum(x) sqlite3Isalnum(x)
# define safe_isxdigit(x) sqlite3Isxdigit(x)
#else
#include <ctype.h>
# define safe_isdigit(x) isdigit((unsigned char)(x))
# define safe_isalnum(x) isalnum((unsigned char)(x))
# define safe_isxdigit(x) isxdigit((unsigned char)(x))
#endif
static const char geopolyIsSpace[] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
#define safe_isspace(x) (geopolyIsSpace[(unsigned char)x])
#endif
#ifndef GCC_VERSION
#if defined(__GNUC__) && !defined(SQLITE_DISABLE_INTRINSIC)
# define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)
#else
# define GCC_VERSION 0
#endif
#endif
#ifndef MSVC_VERSION
#if defined(_MSC_VER) && !defined(SQLITE_DISABLE_INTRINSIC)
# define MSVC_VERSION _MSC_VER
#else
# define MSVC_VERSION 0
#endif
#endif
typedef float GeoCoord; typedef struct GeoPoly GeoPoly; struct GeoPoly {  int nVertex;  unsigned char hdr[4];  GeoCoord a[8]; };
#define GEOPOLY_SZ(N) (sizeof(GeoPoly) + sizeof(GeoCoord)*2*((N)-4))
#define GeoX(P,I) (((GeoCoord*)(P)->a)[(I)*2])
#define GeoY(P,I) (((GeoCoord*)(P)->a)[(I)*2+1])
typedef struct GeoParse GeoParse; struct GeoParse {  const unsigned char *z;  int nVertex;  int nAlloc;  int nErr;  GeoCoord *a; }; static void geopolySwab32(unsigned char *a){  unsigned char t = a[0];  a[0] = a[3];  a[3] = t;  t = a[1];  a[1] = a[2];  a[2] = t; } static char geopolySkipSpace(GeoParse *p){  while( safe_isspace(p->z[0]) ) p->z++;  return p->z[0]; } static int geopolyParseNumber(GeoParse *p, GeoCoord *pVal){  char c = geopolySkipSpace(p);  const unsigned char *z = p->z;  int j = 0;  int seenDP = 0;  int seenE = 0;  if( c=='-' ){  j = 1;  c = z[j];  }  if( c=='0' && z[j+1]>='0' && z[j+1]<='9' ) return 0;  for(;; j++){  c = z[j];  if( safe_isdigit(c) ) continue;  if( c=='.' ){  if( z[j-1]=='-' ) return 0;  if( seenDP ) return 0;  seenDP = 1;  continue;  }  if( c=='e' || c=='E' ){  if( z[j-1]<'0' ) return 0;  if( seenE ) return -1;  seenDP = seenE = 1;  c = z[j+1];  if( c=='+' || c=='-' ){  j++;  c = z[j+1];  }  if( c<'0' || c>'9' ) return 0;  continue;  }  break;  }  if( z[j-1]<'0' ) return 0;  if( pVal ){
#ifdef SQLITE_AMALGAMATION
  double r;   (void)sqlite3AtoF((const char*)p->z, &r, j, SQLITE_UTF8);   *pVal = r;
#else
  *pVal = (GeoCoord)atof((const char*)p->z);
#endif
 }  p->z += j;  return 1; } static GeoPoly *geopolyParseJson(const unsigned char *z, int *pRc){  GeoParse s;  int rc = SQLITE_OK;  memset(&s, 0, sizeof(s));  s.z = z;  if( geopolySkipSpace(&s)=='[' ){  s.z++;  while( geopolySkipSpace(&s)=='[' ){  int ii = 0;  char c;  s.z++;  if( s.nVertex>=s.nAlloc ){  GeoCoord *aNew;  s.nAlloc = s.nAlloc*2 + 16;  aNew = sqlite3_realloc64(s.a, s.nAlloc*sizeof(GeoCoord)*2 );  if( aNew==0 ){  rc = SQLITE_NOMEM;  s.nErr++;  break;  }  s.a = aNew;  }  while( geopolyParseNumber(&s, ii<=1 ? &s.a[s.nVertex*2+ii] : 0) ){  ii++;  if( ii==2 ) s.nVertex++;  c = geopolySkipSpace(&s);  s.z++;  if( c==',' ) continue;  if( c==']' && ii>=2 ) break;  s.nErr++;  rc = SQLITE_ERROR;  goto parse_json_err;  }  if( geopolySkipSpace(&s)==',' ){  s.z++;  continue;  }  break;  }  if( geopolySkipSpace(&s)==']'   && s.nVertex>=4   && s.a[0]==s.a[s.nVertex*2-2]   && s.a[1]==s.a[s.nVertex*2-1]   && (s.z++, geopolySkipSpace(&s)==0)  ){  GeoPoly *pOut;  int x = 1;  s.nVertex--;  pOut = sqlite3_malloc64( GEOPOLY_SZ((sqlite3_int64)s.nVertex) );  x = 1;  if( pOut==0 ) goto parse_json_err;  pOut->nVertex = s.nVertex;  memcpy(pOut->a, s.a, s.nVertex*2*sizeof(GeoCoord));  pOut->hdr[0] = *(unsigned char*)&x;  pOut->hdr[1] = (s.nVertex>>16)&0xff;  pOut->hdr[2] = (s.nVertex>>8)&0xff;  pOut->hdr[3] = s.nVertex&0xff;  sqlite3_free(s.a);  if( pRc ) *pRc = SQLITE_OK;  return pOut;  }else{  s.nErr++;  rc = SQLITE_ERROR;  }  } parse_json_err:  if( pRc ) *pRc = rc;  sqlite3_free(s.a);  return 0; } static GeoPoly *geopolyFuncParam(  sqlite3_context *pCtx,  sqlite3_value *pVal,  int *pRc ){  GeoPoly *p = 0;  int nByte;  testcase( pCtx==0 );  if( sqlite3_value_type(pVal)==SQLITE_BLOB   && (nByte = sqlite3_value_bytes(pVal))>=(4+6*sizeof(GeoCoord))  ){  const unsigned char *a = sqlite3_value_blob(pVal);  int nVertex;  if( a==0 ){  if( pCtx ) sqlite3_result_error_nomem(pCtx);  return 0;  }  nVertex = (a[1]<<16) + (a[2]<<8) + a[3];  if( (a[0]==0 || a[0]==1)   && (nVertex*2*sizeof(GeoCoord) + 4)==(unsigned int)nByte  ){  p = sqlite3_malloc64( sizeof(*p) + (nVertex-1)*2*sizeof(GeoCoord) );  if( p==0 ){  if( pRc ) *pRc = SQLITE_NOMEM;  if( pCtx ) sqlite3_result_error_nomem(pCtx);  }else{  int x = 1;  p->nVertex = nVertex;  memcpy(p->hdr, a, nByte);  if( a[0] != *(unsigned char*)&x ){  int ii;  for(ii=0; ii<nVertex; ii++){  geopolySwab32((unsigned char*)&GeoX(p,ii));  geopolySwab32((unsigned char*)&GeoY(p,ii));  }  p->hdr[0] ^= 1;  }  }  }  if( pRc ) *pRc = SQLITE_OK;  return p;  }else if( sqlite3_value_type(pVal)==SQLITE_TEXT ){  const unsigned char *zJson = sqlite3_value_text(pVal);  if( zJson==0 ){  if( pRc ) *pRc = SQLITE_NOMEM;  return 0;  }  return geopolyParseJson(zJson, pRc);  }else{  if( pRc ) *pRc = SQLITE_ERROR;  return 0;  } } static void geopolyBlobFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p = geopolyFuncParam(context, argv[0], 0);  if( p ){  sqlite3_result_blob(context, p->hdr,   4+8*p->nVertex, SQLITE_TRANSIENT);  sqlite3_free(p);  } } static void geopolyJsonFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p = geopolyFuncParam(context, argv[0], 0);  if( p ){  sqlite3 *db = sqlite3_context_db_handle(context);  sqlite3_str *x = sqlite3_str_new(db);  int i;  sqlite3_str_append(x, "[", 1);  for(i=0; i<p->nVertex; i++){  sqlite3_str_appendf(x, "[%!g,%!g],", GeoX(p,i), GeoY(p,i));  }  sqlite3_str_appendf(x, "[%!g,%!g]]", GeoX(p,0), GeoY(p,0));  sqlite3_result_text(context, sqlite3_str_finish(x), -1, sqlite3_free);  sqlite3_free(p);  } } static void geopolySvgFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p;  if( argc<1 ) return;  p = geopolyFuncParam(context, argv[0], 0);  if( p ){  sqlite3 *db = sqlite3_context_db_handle(context);  sqlite3_str *x = sqlite3_str_new(db);  int i;  char cSep = '\'';  sqlite3_str_appendf(x, "<polyline points=");  for(i=0; i<p->nVertex; i++){  sqlite3_str_appendf(x, "%c%g,%g", cSep, GeoX(p,i), GeoY(p,i));  cSep = ' ';  }  sqlite3_str_appendf(x, " %g,%g'", GeoX(p,0), GeoY(p,0));  for(i=1; i<argc; i++){  const char *z = (const char*)sqlite3_value_text(argv[i]);  if( z && z[0] ){  sqlite3_str_appendf(x, " %s", z);  }  }  sqlite3_str_appendf(x, "></polyline>");  sqlite3_result_text(context, sqlite3_str_finish(x), -1, sqlite3_free);  sqlite3_free(p);  } } static void geopolyXformFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p = geopolyFuncParam(context, argv[0], 0);  double A = sqlite3_value_double(argv[1]);  double B = sqlite3_value_double(argv[2]);  double C = sqlite3_value_double(argv[3]);  double D = sqlite3_value_double(argv[4]);  double E = sqlite3_value_double(argv[5]);  double F = sqlite3_value_double(argv[6]);  GeoCoord x1, y1, x0, y0;  int ii;  if( p ){  for(ii=0; ii<p->nVertex; ii++){  x0 = GeoX(p,ii);  y0 = GeoY(p,ii);  x1 = (GeoCoord)(A*x0 + B*y0 + E);  y1 = (GeoCoord)(C*x0 + D*y0 + F);  GeoX(p,ii) = x1;  GeoY(p,ii) = y1;  }  sqlite3_result_blob(context, p->hdr,   4+8*p->nVertex, SQLITE_TRANSIENT);  sqlite3_free(p);  } } static double geopolyArea(GeoPoly *p){  double rArea = 0.0;  int ii;  for(ii=0; ii<p->nVertex-1; ii++){  rArea += (GeoX(p,ii) - GeoX(p,ii+1))  * 0.5;  }  rArea += (GeoX(p,ii) - GeoX(p,0))   * 0.5;  return rArea; } static void geopolyAreaFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p = geopolyFuncParam(context, argv[0], 0);  if( p ){  sqlite3_result_double(context, geopolyArea(p));  sqlite3_free(p);  } } static void geopolyCcwFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p = geopolyFuncParam(context, argv[0], 0);  if( p ){  if( geopolyArea(p)<0.0 ){  int ii, jj;  for(ii=1, jj=p->nVertex-1; ii<jj; ii++, jj--){  GeoCoord t = GeoX(p,ii);  GeoX(p,ii) = GeoX(p,jj);  GeoX(p,jj) = t;  t = GeoY(p,ii);  GeoY(p,ii) = GeoY(p,jj);  GeoY(p,jj) = t;  }  }  sqlite3_result_blob(context, p->hdr,   4+8*p->nVertex, SQLITE_TRANSIENT);  sqlite3_free(p);  } }
#define GEOPOLY_PI 3.1415926535897932385
static double geopolySine(double r){  assert( r>=-0.5*GEOPOLY_PI && r<=2.0*GEOPOLY_PI );  if( r>=1.5*GEOPOLY_PI ){  r -= 2.0*GEOPOLY_PI;  }  if( r>=0.5*GEOPOLY_PI ){  return -geopolySine(r-GEOPOLY_PI);  }else{  double r2 = r*r;  double r3 = r2*r;  double r5 = r3*r2;  return 0.9996949*r - 0.1656700*r3 + 0.0075134*r5;  } } static void geopolyRegularFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  double x = sqlite3_value_double(argv[0]);  double y = sqlite3_value_double(argv[1]);  double r = sqlite3_value_double(argv[2]);  int n = sqlite3_value_int(argv[3]);  int i;  GeoPoly *p;  if( n<3 || r<=0.0 ) return;  if( n>1000 ) n = 1000;  p = sqlite3_malloc64( sizeof(*p) + (n-1)*2*sizeof(GeoCoord) );  if( p==0 ){  sqlite3_result_error_nomem(context);  return;  }  i = 1;  p->hdr[0] = *(unsigned char*)&i;  p->hdr[1] = 0;  p->hdr[2] = (n>>8)&0xff;  p->hdr[3] = n&0xff;  for(i=0; i<n; i++){  double rAngle = 2.0*GEOPOLY_PI*i/n;  GeoX(p,i) = x - r*geopolySine(rAngle-0.5*GEOPOLY_PI);  GeoY(p,i) = y + r*geopolySine(rAngle);  }  sqlite3_result_blob(context, p->hdr, 4+8*n, SQLITE_TRANSIENT);  sqlite3_free(p); } static GeoPoly *geopolyBBox(  sqlite3_context *context,  sqlite3_value *pPoly,  RtreeCoord *aCoord,  int *pRc ){  GeoPoly *pOut = 0;  GeoPoly *p;  float mnX, mxX, mnY, mxY;  if( pPoly==0 && aCoord!=0 ){  p = 0;  mnX = aCoord[0].f;  mxX = aCoord[1].f;  mnY = aCoord[2].f;  mxY = aCoord[3].f;  goto geopolyBboxFill;  }else{  p = geopolyFuncParam(context, pPoly, pRc);  }  if( p ){  int ii;  mnX = mxX = GeoX(p,0);  mnY = mxY = GeoY(p,0);  for(ii=1; ii<p->nVertex; ii++){  double r = GeoX(p,ii);  if( r<mnX ) mnX = (float)r;  else if( r>mxX ) mxX = (float)r;  r = GeoY(p,ii);  if( r<mnY ) mnY = (float)r;  else if( r>mxY ) mxY = (float)r;  }  if( pRc ) *pRc = SQLITE_OK;  if( aCoord==0 ){  geopolyBboxFill:  pOut = sqlite3_realloc64(p, GEOPOLY_SZ(4));  if( pOut==0 ){  sqlite3_free(p);  if( context ) sqlite3_result_error_nomem(context);  if( pRc ) *pRc = SQLITE_NOMEM;  return 0;  }  pOut->nVertex = 4;  ii = 1;  pOut->hdr[0] = *(unsigned char*)&ii;  pOut->hdr[1] = 0;  pOut->hdr[2] = 0;  pOut->hdr[3] = 4;  GeoX(pOut,0) = mnX;  GeoY(pOut,0) = mnY;  GeoX(pOut,1) = mxX;  GeoY(pOut,1) = mnY;  GeoX(pOut,2) = mxX;  GeoY(pOut,2) = mxY;  GeoX(pOut,3) = mnX;  GeoY(pOut,3) = mxY;  }else{  sqlite3_free(p);  aCoord[0].f = mnX;  aCoord[1].f = mxX;  aCoord[2].f = mnY;  aCoord[3].f = mxY;  }  }else if( aCoord ){  memset(aCoord, 0, sizeof(RtreeCoord)*4);  }  return pOut; } static void geopolyBBoxFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p = geopolyBBox(context, argv[0], 0, 0);  if( p ){  sqlite3_result_blob(context, p->hdr,   4+8*p->nVertex, SQLITE_TRANSIENT);  sqlite3_free(p);  } } typedef struct GeoBBox GeoBBox; struct GeoBBox {  int isInit;  RtreeCoord a[4]; }; static void geopolyBBoxStep(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  RtreeCoord a[4];  int rc = SQLITE_OK;  (void)geopolyBBox(context, argv[0], a, &rc);  if( rc==SQLITE_OK ){  GeoBBox *pBBox;  pBBox = (GeoBBox*)sqlite3_aggregate_context(context, sizeof(*pBBox));  if( pBBox==0 ) return;  if( pBBox->isInit==0 ){  pBBox->isInit = 1;  memcpy(pBBox->a, a, sizeof(RtreeCoord)*4);  }else{  if( a[0].f < pBBox->a[0].f ) pBBox->a[0] = a[0];  if( a[1].f > pBBox->a[1].f ) pBBox->a[1] = a[1];  if( a[2].f < pBBox->a[2].f ) pBBox->a[2] = a[2];  if( a[3].f > pBBox->a[3].f ) pBBox->a[3] = a[3];  }  } } static void geopolyBBoxFinal(  sqlite3_context *context ){  GeoPoly *p;  GeoBBox *pBBox;  pBBox = (GeoBBox*)sqlite3_aggregate_context(context, 0);  if( pBBox==0 ) return;  p = geopolyBBox(context, 0, pBBox->a, 0);  if( p ){  sqlite3_result_blob(context, p->hdr,   4+8*p->nVertex, SQLITE_TRANSIENT);  sqlite3_free(p);  } } static int pointBeneathLine(  double x0, double y0,  double x1, double y1,  double x2, double y2 ){  double y;  if( x0==x1 && y0==y1 ) return 2;  if( x1<x2 ){  if( x0<=x1 || x0>x2 ) return 0;  }else if( x1>x2 ){  if( x0<=x2 || x0>x1 ) return 0;  }else{  if( x0!=x1 ) return 0;  if( y0<y1 && y0<y2 ) return 0;  if( y0>y1 && y0>y2 ) return 0;  return 2;  }  y = y1 + (y2-y1)*(x0-x1)/(x2-x1);  if( y0==y ) return 2;  if( y0<y ) return 1;  return 0; } static void geopolyContainsPointFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p1 = geopolyFuncParam(context, argv[0], 0);  double x0 = sqlite3_value_double(argv[1]);  double y0 = sqlite3_value_double(argv[2]);  int v = 0;  int cnt = 0;  int ii;  if( p1==0 ) return;  for(ii=0; ii<p1->nVertex-1; ii++){  v = pointBeneathLine(x0,y0,GeoX(p1,ii), GeoY(p1,ii),   GeoX(p1,ii+1),GeoY(p1,ii+1));  if( v==2 ) break;  cnt += v;  }  if( v!=2 ){  v = pointBeneathLine(x0,y0,GeoX(p1,ii), GeoY(p1,ii),   GeoX(p1,0), GeoY(p1,0));  }  if( v==2 ){  sqlite3_result_int(context, 1);  }else if( ((v+cnt)&1)==0 ){  sqlite3_result_int(context, 0);  }else{  sqlite3_result_int(context, 2);  }  sqlite3_free(p1); } static int geopolyOverlap(GeoPoly *p1, GeoPoly *p2); static void geopolyWithinFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p1 = geopolyFuncParam(context, argv[0], 0);  GeoPoly *p2 = geopolyFuncParam(context, argv[1], 0);  if( p1 && p2 ){  int x = geopolyOverlap(p1, p2);  if( x<0 ){  sqlite3_result_error_nomem(context);  }else{  sqlite3_result_int(context, x==2 ? 1 : x==4 ? 2 : 0);  }  }  sqlite3_free(p1);  sqlite3_free(p2); } typedef struct GeoEvent GeoEvent; typedef struct GeoSegment GeoSegment; typedef struct GeoOverlap GeoOverlap; struct GeoEvent {  double x;  int eType;  GeoSegment *pSeg;  GeoEvent *pNext; }; struct GeoSegment {  double C, B;  double y;  float y0;  unsigned char side;  unsigned int idx;  GeoSegment *pNext; }; struct GeoOverlap {  GeoEvent *aEvent;  GeoSegment *aSegment;  int nEvent;  int nSegment; }; static void geopolyAddOneSegment(  GeoOverlap *p,  GeoCoord x0,  GeoCoord y0,  GeoCoord x1,  GeoCoord y1,  unsigned char side,  unsigned int idx ){  GeoSegment *pSeg;  GeoEvent *pEvent;  if( x0==x1 ) return;  if( x0>x1 ){  GeoCoord t = x0;  x0 = x1;  x1 = t;  t = y0;  y0 = y1;  y1 = t;  }  pSeg = p->aSegment + p->nSegment;  p->nSegment++;  pSeg->C = (y1-y0)/(x1-x0);  pSeg->B = y1 - x1*pSeg->C;  pSeg->y0 = y0;  pSeg->side = side;  pSeg->idx = idx;  pEvent = p->aEvent + p->nEvent;  p->nEvent++;  pEvent->x = x0;  pEvent->eType = 0;  pEvent->pSeg = pSeg;  pEvent = p->aEvent + p->nEvent;  p->nEvent++;  pEvent->x = x1;  pEvent->eType = 1;  pEvent->pSeg = pSeg; } static void geopolyAddSegments(  GeoOverlap *p,  GeoPoly *pPoly,  unsigned char side ){  unsigned int i;  GeoCoord *x;  for(i=0; i<(unsigned)pPoly->nVertex-1; i++){  x = &GeoX(pPoly,i);  geopolyAddOneSegment(p, x[0], x[1], x[2], x[3], side, i);  }  x = &GeoX(pPoly,i);  geopolyAddOneSegment(p, x[0], x[1], pPoly->a[0], pPoly->a[1], side, i); } static GeoEvent *geopolyEventMerge(GeoEvent *pLeft, GeoEvent *pRight){  GeoEvent head, *pLast;  head.pNext = 0;  pLast = &head;  while( pRight && pLeft ){  if( pRight->x <= pLeft->x ){  pLast->pNext = pRight;  pLast = pRight;  pRight = pRight->pNext;  }else{  pLast->pNext = pLeft;  pLast = pLeft;  pLeft = pLeft->pNext;  }  }  pLast->pNext = pRight ? pRight : pLeft;  return head.pNext; } static GeoEvent *geopolySortEventsByX(GeoEvent *aEvent, int nEvent){  int mx = 0;  int i, j;  GeoEvent *p;  GeoEvent *a[50];  for(i=0; i<nEvent; i++){  p = &aEvent[i];  p->pNext = 0;  for(j=0; j<mx && a[j]; j++){  p = geopolyEventMerge(a[j], p);  a[j] = 0;  }  a[j] = p;  if( j>=mx ) mx = j+1;  }  p = 0;  for(i=0; i<mx; i++){  p = geopolyEventMerge(a[i], p);  }  return p; } static GeoSegment *geopolySegmentMerge(GeoSegment *pLeft, GeoSegment *pRight){  GeoSegment head, *pLast;  head.pNext = 0;  pLast = &head;  while( pRight && pLeft ){  double r = pRight->y - pLeft->y;  if( r==0.0 ) r = pRight->C - pLeft->C;  if( r<0.0 ){  pLast->pNext = pRight;  pLast = pRight;  pRight = pRight->pNext;  }else{  pLast->pNext = pLeft;  pLast = pLeft;  pLeft = pLeft->pNext;  }  }  pLast->pNext = pRight ? pRight : pLeft;  return head.pNext; } static GeoSegment *geopolySortSegmentsByYAndC(GeoSegment *pList){  int mx = 0;  int i;  GeoSegment *p;  GeoSegment *a[50];  while( pList ){  p = pList;  pList = pList->pNext;  p->pNext = 0;  for(i=0; i<mx && a[i]; i++){  p = geopolySegmentMerge(a[i], p);  a[i] = 0;  }  a[i] = p;  if( i>=mx ) mx = i+1;  }  p = 0;  for(i=0; i<mx; i++){  p = geopolySegmentMerge(a[i], p);  }  return p; } static int geopolyOverlap(GeoPoly *p1, GeoPoly *p2){  sqlite3_int64 nVertex = p1->nVertex + p2->nVertex + 2;  GeoOverlap *p;  sqlite3_int64 nByte;  GeoEvent *pThisEvent;  double rX;  int rc = 0;  int needSort = 0;  GeoSegment *pActive = 0;  GeoSegment *pSeg;  unsigned char aOverlap[4];  nByte = sizeof(GeoEvent)*nVertex*2   + sizeof(GeoSegment)*nVertex   + sizeof(GeoOverlap);  p = sqlite3_malloc64( nByte );  if( p==0 ) return -1;  p->aEvent = (GeoEvent*)&p[1];  p->aSegment = (GeoSegment*)&p->aEvent[nVertex*2];  p->nEvent = p->nSegment = 0;  geopolyAddSegments(p, p1, 1);  geopolyAddSegments(p, p2, 2);  pThisEvent = geopolySortEventsByX(p->aEvent, p->nEvent);  rX = pThisEvent && pThisEvent->x==0.0 ? -1.0 : 0.0;  memset(aOverlap, 0, sizeof(aOverlap));  while( pThisEvent ){  if( pThisEvent->x!=rX ){  GeoSegment *pPrev = 0;  int iMask = 0;  GEODEBUG(("Distinct X: %g\n", pThisEvent->x));  rX = pThisEvent->x;  if( needSort ){  GEODEBUG(("SORT\n"));  pActive = geopolySortSegmentsByYAndC(pActive);  needSort = 0;  }  for(pSeg=pActive; pSeg; pSeg=pSeg->pNext){  if( pPrev ){  if( pPrev->y!=pSeg->y ){  GEODEBUG(("MASK: %d\n", iMask));  aOverlap[iMask] = 1;  }  }  iMask ^= pSeg->side;  pPrev = pSeg;  }  pPrev = 0;  for(pSeg=pActive; pSeg; pSeg=pSeg->pNext){  double y = pSeg->C*rX + pSeg->B;  GEODEBUG(("Segment %d.%d %g->%g\n", pSeg->side, pSeg->idx, pSeg->y, y));  pSeg->y = y;  if( pPrev ){  if( pPrev->y>pSeg->y && pPrev->side!=pSeg->side ){  rc = 1;  GEODEBUG(("Crossing: %d.%d and %d.%d\n",  pPrev->side, pPrev->idx,  pSeg->side, pSeg->idx));  goto geopolyOverlapDone;  }else if( pPrev->y!=pSeg->y ){  GEODEBUG(("MASK: %d\n", iMask));  aOverlap[iMask] = 1;  }  }  iMask ^= pSeg->side;  pPrev = pSeg;  }  }  GEODEBUG(("%s %d.%d C=%g B=%g\n",  pThisEvent->eType ? "RM " : "ADD",  pThisEvent->pSeg->side, pThisEvent->pSeg->idx,  pThisEvent->pSeg->C,  pThisEvent->pSeg->B));  if( pThisEvent->eType==0 ){  pSeg = pThisEvent->pSeg;  pSeg->y = pSeg->y0;  pSeg->pNext = pActive;  pActive = pSeg;  needSort = 1;  }else{  if( pActive==pThisEvent->pSeg ){  pActive = ALWAYS(pActive) ? pActive->pNext : 0;  }else{  for(pSeg=pActive; pSeg; pSeg=pSeg->pNext){  if( pSeg->pNext==pThisEvent->pSeg ){  pSeg->pNext = ALWAYS(pSeg->pNext) ? pSeg->pNext->pNext : 0;  break;  }  }  }  }  pThisEvent = pThisEvent->pNext;  }  if( aOverlap[3]==0 ){  rc = 0;  }else if( aOverlap[1]!=0 && aOverlap[2]==0 ){  rc = 3;  }else if( aOverlap[1]==0 && aOverlap[2]!=0 ){  rc = 2;  }else if( aOverlap[1]==0 && aOverlap[2]==0 ){  rc = 4;  }else{  rc = 1;  } geopolyOverlapDone:  sqlite3_free(p);  return rc; } static void geopolyOverlapFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  GeoPoly *p1 = geopolyFuncParam(context, argv[0], 0);  GeoPoly *p2 = geopolyFuncParam(context, argv[1], 0);  if( p1 && p2 ){  int x = geopolyOverlap(p1, p2);  if( x<0 ){  sqlite3_result_error_nomem(context);  }else{  sqlite3_result_int(context, x);  }  }  sqlite3_free(p1);  sqlite3_free(p2); } static void geopolyDebugFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){
#ifdef GEOPOLY_ENABLE_DEBUG
 geo_debug = sqlite3_value_int(argv[0]);
#endif
} static int geopolyInit(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr,  int isCreate ){  int rc = SQLITE_OK;  Rtree *pRtree;  sqlite3_int64 nDb;  sqlite3_int64 nName;  sqlite3_str *pSql;  char *zSql;  int ii;  sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, 1);  nDb = strlen(argv[1]);  nName = strlen(argv[2]);  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName+2);  if( !pRtree ){  return SQLITE_NOMEM;  }  memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);  pRtree->nBusy = 1;  pRtree->base.pModule = &rtreeModule;  pRtree->zDb = (char *)&pRtree[1];  pRtree->zName = &pRtree->zDb[nDb+1];  pRtree->eCoordType = RTREE_COORD_REAL32;  pRtree->nDim = 2;  pRtree->nDim2 = 4;  memcpy(pRtree->zDb, argv[1], nDb);  memcpy(pRtree->zName, argv[2], nName);  pSql = sqlite3_str_new(db);  sqlite3_str_appendf(pSql, "CREATE TABLE x(_shape");  pRtree->nAux = 1;  pRtree->nAuxNotNull = 1;  for(ii=3; ii<argc; ii++){  pRtree->nAux++;  sqlite3_str_appendf(pSql, ",%s", argv[ii]);  }  sqlite3_str_appendf(pSql, ");");  zSql = sqlite3_str_finish(pSql);  if( !zSql ){  rc = SQLITE_NOMEM;  }else if( SQLITE_OK!=(rc = sqlite3_declare_vtab(db, zSql)) ){  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  }  sqlite3_free(zSql);  if( rc ) goto geopolyInit_fail;  pRtree->nBytesPerCell = 8 + pRtree->nDim2*4;  rc = getNodeSize(db, pRtree, isCreate, pzErr);  if( rc ) goto geopolyInit_fail;  rc = rtreeSqlInit(pRtree, db, argv[1], argv[2], isCreate);  if( rc ){  *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));  goto geopolyInit_fail;  }  *ppVtab = (sqlite3_vtab *)pRtree;  return SQLITE_OK; geopolyInit_fail:  if( rc==SQLITE_OK ) rc = SQLITE_ERROR;  assert( *ppVtab==0 );  assert( pRtree->nBusy==1 );  rtreeRelease(pRtree);  return rc; } static int geopolyCreate(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return geopolyInit(db, pAux, argc, argv, ppVtab, pzErr, 1); } static int geopolyConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return geopolyInit(db, pAux, argc, argv, ppVtab, pzErr, 0); } static int geopolyFilter(  sqlite3_vtab_cursor *pVtabCursor,  int idxNum,  const char *idxStr,  int argc, sqlite3_value **argv ){  Rtree *pRtree = (Rtree *)pVtabCursor->pVtab;  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;  RtreeNode *pRoot = 0;  int rc = SQLITE_OK;  int iCell = 0;  rtreeReference(pRtree);  resetCursor(pCsr);  pCsr->iStrategy = idxNum;  if( idxNum==1 ){  RtreeNode *pLeaf;  RtreeSearchPoint *p;  i64 iRowid = sqlite3_value_int64(argv[0]);  i64 iNode = 0;  rc = findLeafNode(pRtree, iRowid, &pLeaf, &iNode);  if( rc==SQLITE_OK && pLeaf!=0 ){  p = rtreeSearchPointNew(pCsr, RTREE_ZERO, 0);  assert( p!=0 );  pCsr->aNode[0] = pLeaf;  p->id = iNode;  p->eWithin = PARTLY_WITHIN;  rc = nodeRowidIndex(pRtree, pLeaf, iRowid, &iCell);  p->iCell = (u8)iCell;  RTREE_QUEUE_TRACE(pCsr, "PUSH-F1:");  }else{  pCsr->atEOF = 1;  }  }else{  rc = nodeAcquire(pRtree, 1, 0, &pRoot);  if( rc==SQLITE_OK && idxNum<=3 ){  RtreeCoord bbox[4];  RtreeConstraint *p;  assert( argc==1 );  assert( argv[0]!=0 );  geopolyBBox(0, argv[0], bbox, &rc);  if( rc ){  goto geopoly_filter_end;  }  pCsr->aConstraint = p = sqlite3_malloc(sizeof(RtreeConstraint)*4);  pCsr->nConstraint = 4;  if( p==0 ){  rc = SQLITE_NOMEM;  }else{  memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*4);  memset(pCsr->anQueue, 0, sizeof(u32)*(pRtree->iDepth + 1));  if( idxNum==2 ){  p->op = 'B';  p->iCoord = 0;  p->u.rValue = bbox[1].f;  p++;  p->op = 'D';  p->iCoord = 1;  p->u.rValue = bbox[0].f;  p++;  p->op = 'B';  p->iCoord = 2;  p->u.rValue = bbox[3].f;  p++;  p->op = 'D';  p->iCoord = 3;  p->u.rValue = bbox[2].f;  }else{  p->op = 'D';  p->iCoord = 0;  p->u.rValue = bbox[0].f;  p++;  p->op = 'B';  p->iCoord = 1;  p->u.rValue = bbox[1].f;  p++;  p->op = 'D';  p->iCoord = 2;  p->u.rValue = bbox[2].f;  p++;  p->op = 'B';  p->iCoord = 3;  p->u.rValue = bbox[3].f;  }  }  }  if( rc==SQLITE_OK ){  RtreeSearchPoint *pNew;  pNew = rtreeSearchPointNew(pCsr, RTREE_ZERO, (u8)(pRtree->iDepth+1));  if( pNew==0 ){  rc = SQLITE_NOMEM;  goto geopoly_filter_end;  }  pNew->id = 1;  pNew->iCell = 0;  pNew->eWithin = PARTLY_WITHIN;  assert( pCsr->bPoint==1 );  pCsr->aNode[0] = pRoot;  pRoot = 0;  RTREE_QUEUE_TRACE(pCsr, "PUSH-Fm:");  rc = rtreeStepToLeaf(pCsr);  }  } geopoly_filter_end:  nodeRelease(pRtree, pRoot);  rtreeRelease(pRtree);  return rc; } static int geopolyBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){  int ii;  int iRowidTerm = -1;  int iFuncTerm = -1;  int idxNum = 0;  for(ii=0; ii<pIdxInfo->nConstraint; ii++){  struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[ii];  if( !p->usable ) continue;  if( p->iColumn<0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ ){  iRowidTerm = ii;  break;  }  if( p->iColumn==0 && p->op>=SQLITE_INDEX_CONSTRAINT_FUNCTION ){  iFuncTerm = ii;  idxNum = p->op - SQLITE_INDEX_CONSTRAINT_FUNCTION + 2;  }  }  if( iRowidTerm>=0 ){  pIdxInfo->idxNum = 1;  pIdxInfo->idxStr = "rowid";  pIdxInfo->aConstraintUsage[iRowidTerm].argvIndex = 1;  pIdxInfo->aConstraintUsage[iRowidTerm].omit = 1;  pIdxInfo->estimatedCost = 30.0;  pIdxInfo->estimatedRows = 1;  pIdxInfo->idxFlags = SQLITE_INDEX_SCAN_UNIQUE;  return SQLITE_OK;  }  if( iFuncTerm>=0 ){  pIdxInfo->idxNum = idxNum;  pIdxInfo->idxStr = "rtree";  pIdxInfo->aConstraintUsage[iFuncTerm].argvIndex = 1;  pIdxInfo->aConstraintUsage[iFuncTerm].omit = 0;  pIdxInfo->estimatedCost = 300.0;  pIdxInfo->estimatedRows = 10;  return SQLITE_OK;  }  pIdxInfo->idxNum = 4;  pIdxInfo->idxStr = "fullscan";  pIdxInfo->estimatedCost = 3000000.0;  pIdxInfo->estimatedRows = 100000;  return SQLITE_OK; } static int geopolyColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){  Rtree *pRtree = (Rtree *)cur->pVtab;  RtreeCursor *pCsr = (RtreeCursor *)cur;  RtreeSearchPoint *p = rtreeSearchPointFirst(pCsr);  int rc = SQLITE_OK;  RtreeNode *pNode = rtreeNodeOfFirstSearchPoint(pCsr, &rc);  if( rc ) return rc;  if( p==0 ) return SQLITE_OK;  if( i==0 && sqlite3_vtab_nochange(ctx) ) return SQLITE_OK;  if( i<=pRtree->nAux ){  if( !pCsr->bAuxValid ){  if( pCsr->pReadAux==0 ){  rc = sqlite3_prepare_v3(pRtree->db, pRtree->zReadAuxSql, -1, 0,  &pCsr->pReadAux, 0);  if( rc ) return rc;  }  sqlite3_bind_int64(pCsr->pReadAux, 1,  nodeGetRowid(pRtree, pNode, p->iCell));  rc = sqlite3_step(pCsr->pReadAux);  if( rc==SQLITE_ROW ){  pCsr->bAuxValid = 1;  }else{  sqlite3_reset(pCsr->pReadAux);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  return rc;  }  }  sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pReadAux, i+2));  }  return SQLITE_OK; } static int geopolyUpdate(  sqlite3_vtab *pVtab,  int nData,  sqlite3_value **aData,  sqlite_int64 *pRowid ){  Rtree *pRtree = (Rtree *)pVtab;  int rc = SQLITE_OK;  RtreeCell cell;  i64 oldRowid;  int oldRowidValid;  i64 newRowid;  int newRowidValid;  int coordChange = 0;  if( pRtree->nNodeRef ){  return SQLITE_LOCKED_VTAB;  }  rtreeReference(pRtree);  assert(nData>=1);  oldRowidValid = sqlite3_value_type(aData[0])!=SQLITE_NULL;;  oldRowid = oldRowidValid ? sqlite3_value_int64(aData[0]) : 0;  newRowidValid = nData>1 && sqlite3_value_type(aData[1])!=SQLITE_NULL;  newRowid = newRowidValid ? sqlite3_value_int64(aData[1]) : 0;  cell.iRowid = newRowid;  if( nData>1   && (!oldRowidValid  || !sqlite3_value_nochange(aData[2])  || oldRowid!=newRowid)  ){  assert( aData[2]!=0 );  geopolyBBox(0, aData[2], cell.aCoord, &rc);  if( rc ){  if( rc==SQLITE_ERROR ){  pVtab->zErrMsg =  sqlite3_mprintf("_shape does not contain a valid polygon");  }  goto geopoly_update_end;  }  coordChange = 1;  if( newRowidValid && (!oldRowidValid || oldRowid!=newRowid) ){  int steprc;  sqlite3_bind_int64(pRtree->pReadRowid, 1, cell.iRowid);  steprc = sqlite3_step(pRtree->pReadRowid);  rc = sqlite3_reset(pRtree->pReadRowid);  if( SQLITE_ROW==steprc ){  if( sqlite3_vtab_on_conflict(pRtree->db)==SQLITE_REPLACE ){  rc = rtreeDeleteRowid(pRtree, cell.iRowid);  }else{  rc = rtreeConstraintError(pRtree, 0);  }  }  }  }  if( rc==SQLITE_OK && (nData==1 || (coordChange && oldRowidValid)) ){  rc = rtreeDeleteRowid(pRtree, oldRowid);  }  if( rc==SQLITE_OK && nData>1 && coordChange ){  RtreeNode *pLeaf = 0;  if( !newRowidValid ){  rc = rtreeNewRowid(pRtree, &cell.iRowid);  }  *pRowid = cell.iRowid;  if( rc==SQLITE_OK ){  rc = ChooseLeaf(pRtree, &cell, 0, &pLeaf);  }  if( rc==SQLITE_OK ){  int rc2;  pRtree->iReinsertHeight = -1;  rc = rtreeInsertCell(pRtree, pLeaf, &cell, 0);  rc2 = nodeRelease(pRtree, pLeaf);  if( rc==SQLITE_OK ){  rc = rc2;  }  }  }  if( rc==SQLITE_OK && nData>1 ){  sqlite3_stmt *pUp = pRtree->pWriteAux;  int jj;  int nChange = 0;  sqlite3_bind_int64(pUp, 1, cell.iRowid);  assert( pRtree->nAux>=1 );  if( sqlite3_value_nochange(aData[2]) ){  sqlite3_bind_null(pUp, 2);  }else{  GeoPoly *p = 0;  if( sqlite3_value_type(aData[2])==SQLITE_TEXT   && (p = geopolyFuncParam(0, aData[2], &rc))!=0   && rc==SQLITE_OK  ){  sqlite3_bind_blob(pUp, 2, p->hdr, 4+8*p->nVertex, SQLITE_TRANSIENT);  }else{  sqlite3_bind_value(pUp, 2, aData[2]);  }  sqlite3_free(p);  nChange = 1;  }  for(jj=1; jj<pRtree->nAux; jj++){  nChange++;  sqlite3_bind_value(pUp, jj+2, aData[jj+2]);  }  if( nChange ){  sqlite3_step(pUp);  rc = sqlite3_reset(pUp);  }  } geopoly_update_end:  rtreeRelease(pRtree);  return rc; } static int geopolyFindFunction(  sqlite3_vtab *pVtab,  int nArg,  const char *zName,  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),  void **ppArg ){  if( sqlite3_stricmp(zName, "geopoly_overlap")==0 ){  *pxFunc = geopolyOverlapFunc;  *ppArg = 0;  return SQLITE_INDEX_CONSTRAINT_FUNCTION;  }  if( sqlite3_stricmp(zName, "geopoly_within")==0 ){  *pxFunc = geopolyWithinFunc;  *ppArg = 0;  return SQLITE_INDEX_CONSTRAINT_FUNCTION+1;  }  return 0; } static sqlite3_module geopolyModule = {  3,  geopolyCreate,  geopolyConnect,  geopolyBestIndex,  rtreeDisconnect,  rtreeDestroy,  rtreeOpen,  rtreeClose,  geopolyFilter,  rtreeNext,  rtreeEof,  geopolyColumn,  rtreeRowid,  geopolyUpdate,  rtreeBeginTransaction,  rtreeEndTransaction,  rtreeEndTransaction,  rtreeEndTransaction,  geopolyFindFunction,  rtreeRename,  rtreeSavepoint,  0,  0,  rtreeShadowName }; static int sqlite3_geopoly_init(sqlite3 *db){  int rc = SQLITE_OK;  static const struct {  void (*xFunc)(sqlite3_context*,int,sqlite3_value**);  signed char nArg;  unsigned char bPure;  const char *zName;  } aFunc[] = {   { geopolyAreaFunc, 1, 1, "geopoly_area"  },   { geopolyBlobFunc, 1, 1, "geopoly_blob"  },   { geopolyJsonFunc, 1, 1, "geopoly_json"  },   { geopolySvgFunc, -1, 1, "geopoly_svg" },   { geopolyWithinFunc, 2, 1, "geopoly_within"  },   { geopolyContainsPointFunc, 3, 1, "geopoly_contains_point"  },   { geopolyOverlapFunc, 2, 1, "geopoly_overlap" },   { geopolyDebugFunc, 1, 0, "geopoly_debug" },   { geopolyBBoxFunc, 1, 1, "geopoly_bbox"  },   { geopolyXformFunc, 7, 1, "geopoly_xform" },   { geopolyRegularFunc, 4, 1, "geopoly_regular" },   { geopolyCcwFunc, 1, 1, "geopoly_ccw" },  };  static const struct {  void (*xStep)(sqlite3_context*,int,sqlite3_value**);  void (*xFinal)(sqlite3_context*);  const char *zName;  } aAgg[] = {   { geopolyBBoxStep, geopolyBBoxFinal, "geopoly_group_bbox" },  };  int i;  for(i=0; i<sizeof(aFunc)/sizeof(aFunc[0]) && rc==SQLITE_OK; i++){  int enc;  if( aFunc[i].bPure ){  enc = SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS;  }else{  enc = SQLITE_UTF8|SQLITE_DIRECTONLY;  }  rc = sqlite3_create_function(db, aFunc[i].zName, aFunc[i].nArg,   enc, 0,   aFunc[i].xFunc, 0, 0);  }  for(i=0; i<sizeof(aAgg)/sizeof(aAgg[0]) && rc==SQLITE_OK; i++){  rc = sqlite3_create_function(db, aAgg[i].zName, 1,  SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS, 0,  0, aAgg[i].xStep, aAgg[i].xFinal);  }  if( rc==SQLITE_OK ){  rc = sqlite3_create_module_v2(db, "geopoly", &geopolyModule, 0, 0);  }  return rc; }
#endif
SQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db){  const int utf8 = SQLITE_UTF8;  int rc;  rc = sqlite3_create_function(db, "rtreenode", 2, utf8, 0, rtreenode, 0, 0);  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(db, "rtreedepth", 1, utf8, 0,rtreedepth, 0, 0);  }  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(db, "rtreecheck", -1, utf8, 0,rtreecheck, 0,0);  }  if( rc==SQLITE_OK ){
#ifdef SQLITE_RTREE_INT_ONLY
 void *c = (void *)RTREE_COORD_INT32;
#else
 void *c = (void *)RTREE_COORD_REAL32;
#endif
 rc = sqlite3_create_module_v2(db, "rtree", &rtreeModule, c, 0);  }  if( rc==SQLITE_OK ){  void *c = (void *)RTREE_COORD_INT32;  rc = sqlite3_create_module_v2(db, "rtree_i32", &rtreeModule, c, 0);  }
#ifdef SQLITE_ENABLE_GEOPOLY
 if( rc==SQLITE_OK ){  rc = sqlite3_geopoly_init(db);  }
#endif
 return rc; } static void rtreeFreeCallback(void *p){  RtreeGeomCallback *pInfo = (RtreeGeomCallback*)p;  if( pInfo->xDestructor ) pInfo->xDestructor(pInfo->pContext);  sqlite3_free(p); } static void rtreeMatchArgFree(void *pArg){  int i;  RtreeMatchArg *p = (RtreeMatchArg*)pArg;  for(i=0; i<p->nParam; i++){  sqlite3_value_free(p->apSqlParam[i]);  }  sqlite3_free(p); } static void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){  RtreeGeomCallback *pGeomCtx = (RtreeGeomCallback *)sqlite3_user_data(ctx);  RtreeMatchArg *pBlob;  sqlite3_int64 nBlob;  int memErr = 0;  nBlob = sizeof(RtreeMatchArg) + (nArg-1)*sizeof(RtreeDValue)   + nArg*sizeof(sqlite3_value*);  pBlob = (RtreeMatchArg *)sqlite3_malloc64(nBlob);  if( !pBlob ){  sqlite3_result_error_nomem(ctx);  }else{  int i;  pBlob->iSize = nBlob;  pBlob->cb = pGeomCtx[0];  pBlob->apSqlParam = (sqlite3_value**)&pBlob->aParam[nArg];  pBlob->nParam = nArg;  for(i=0; i<nArg; i++){  pBlob->apSqlParam[i] = sqlite3_value_dup(aArg[i]);  if( pBlob->apSqlParam[i]==0 ) memErr = 1;
#ifdef SQLITE_RTREE_INT_ONLY
 pBlob->aParam[i] = sqlite3_value_int64(aArg[i]);
#else
 pBlob->aParam[i] = sqlite3_value_double(aArg[i]);
#endif
 }  if( memErr ){  sqlite3_result_error_nomem(ctx);  rtreeMatchArgFree(pBlob);  }else{  sqlite3_result_pointer(ctx, pBlob, "RtreeMatchArg", rtreeMatchArgFree);  }  } } SQLITE_API int sqlite3_rtree_geometry_callback(  sqlite3 *db,  const char *zGeom,  int (*xGeom)(sqlite3_rtree_geometry*,int,RtreeDValue*,int*),  void *pContext ){  RtreeGeomCallback *pGeomCtx;  pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));  if( !pGeomCtx ) return SQLITE_NOMEM;  pGeomCtx->xGeom = xGeom;  pGeomCtx->xQueryFunc = 0;  pGeomCtx->xDestructor = 0;  pGeomCtx->pContext = pContext;  return sqlite3_create_function_v2(db, zGeom, -1, SQLITE_ANY,  (void *)pGeomCtx, geomCallback, 0, 0, rtreeFreeCallback  ); } SQLITE_API int sqlite3_rtree_query_callback(  sqlite3 *db,  const char *zQueryFunc,  int (*xQueryFunc)(sqlite3_rtree_query_info*),  void *pContext,  void (*xDestructor)(void*) ){  RtreeGeomCallback *pGeomCtx;  pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));  if( !pGeomCtx ){  if( xDestructor ) xDestructor(pContext);  return SQLITE_NOMEM;  }  pGeomCtx->xGeom = 0;  pGeomCtx->xQueryFunc = xQueryFunc;  pGeomCtx->xDestructor = xDestructor;  pGeomCtx->pContext = pContext;  return sqlite3_create_function_v2(db, zQueryFunc, -1, SQLITE_ANY,  (void *)pGeomCtx, geomCallback, 0, 0, rtreeFreeCallback  ); }
#if !SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_rtree_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  SQLITE_EXTENSION_INIT2(pApi)  return sqlite3RtreeInit(db); }
#endif
#endif
#if !defined(SQLITE_CORE)  || defined(SQLITE_ENABLE_ICU)   || defined(SQLITE_ENABLE_ICU_COLLATIONS)

#include <unicode/utypes.h>
#include <unicode/uregex.h>
#include <unicode/ustring.h>
#include <unicode/ucol.h>
#ifndef SQLITE_CORE
 SQLITE_EXTENSION_INIT1
#else
#endif
static void icuFunctionError(  sqlite3_context *pCtx,  const char *zName,  UErrorCode e ){  char zBuf[128];  sqlite3_snprintf(128, zBuf, "ICU error: %s(): %s", zName, u_errorName(e));  zBuf[127] = '\0';  sqlite3_result_error(pCtx, zBuf, -1); }
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_ICU)
#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH
# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000
#endif
static void xFree(void *p){  sqlite3_free(p); } static const unsigned char icuUtf8Trans1[] = {  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, };
#define SQLITE_ICU_READ_UTF8(zIn, c)   c = *(zIn++);  if( c>=0xc0 ){   c = icuUtf8Trans1[c-0xc0];   while( (*zIn & 0xc0)==0x80 ){  c = (c<<6) + (0x3f & *(zIn++));  }  }

#define SQLITE_ICU_SKIP_UTF8(zIn)  assert( *zIn );  if( *(zIn++)>=0xc0 ){  while( (*zIn & 0xc0)==0x80 ){zIn++;}   }

static int icuLikeCompare(  const uint8_t *zPattern,  const uint8_t *zString,  const UChar32 uEsc ){  static const uint32_t MATCH_ONE = (uint32_t)'_';  static const uint32_t MATCH_ALL = (uint32_t)'%';  int prevEscape = 0;  while( 1 ){  uint32_t uPattern;  SQLITE_ICU_READ_UTF8(zPattern, uPattern);  if( uPattern==0 ) break;  if( uPattern==MATCH_ALL && !prevEscape && uPattern!=(uint32_t)uEsc ){  uint8_t c;  while( (c=*zPattern) == MATCH_ALL || c == MATCH_ONE ){  if( c==MATCH_ONE ){  if( *zString==0 ) return 0;  SQLITE_ICU_SKIP_UTF8(zString);  }  zPattern++;  }  if( *zPattern==0 ) return 1;  while( *zString ){  if( icuLikeCompare(zPattern, zString, uEsc) ){  return 1;  }  SQLITE_ICU_SKIP_UTF8(zString);  }  return 0;  }else if( uPattern==MATCH_ONE && !prevEscape && uPattern!=(uint32_t)uEsc ){  if( *zString==0 ) return 0;  SQLITE_ICU_SKIP_UTF8(zString);  }else if( uPattern==(uint32_t)uEsc && !prevEscape ){  prevEscape = 1;  }else{  uint32_t uString;  SQLITE_ICU_READ_UTF8(zString, uString);  uString = (uint32_t)u_foldCase((UChar32)uString, U_FOLD_CASE_DEFAULT);  uPattern = (uint32_t)u_foldCase((UChar32)uPattern, U_FOLD_CASE_DEFAULT);  if( uString!=uPattern ){  return 0;  }  prevEscape = 0;  }  }  return *zString==0; } static void icuLikeFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const unsigned char *zA = sqlite3_value_text(argv[0]);  const unsigned char *zB = sqlite3_value_text(argv[1]);  UChar32 uEsc = 0;  if( sqlite3_value_bytes(argv[0])>SQLITE_MAX_LIKE_PATTERN_LENGTH ){  sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);  return;  }  if( argc==3 ){  int nE= sqlite3_value_bytes(argv[2]);  const unsigned char *zE = sqlite3_value_text(argv[2]);  int i = 0;  if( zE==0 ) return;  U8_NEXT(zE, i, nE, uEsc);  if( i!=nE){  sqlite3_result_error(context,  "ESCAPE expression must be a single character", -1);  return;  }  }  if( zA && zB ){  sqlite3_result_int(context, icuLikeCompare(zA, zB, uEsc));  } } static void icuRegexpDelete(void *p){  URegularExpression *pExpr = (URegularExpression *)p;  uregex_close(pExpr); } static void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg){  UErrorCode status = U_ZERO_ERROR;  URegularExpression *pExpr;  UBool res;  const UChar *zString = sqlite3_value_text16(apArg[1]);  (void)nArg;  if( !zString ){  return;  }  pExpr = sqlite3_get_auxdata(p, 0);  if( !pExpr ){  const UChar *zPattern = sqlite3_value_text16(apArg[0]);  if( !zPattern ){  return;  }  pExpr = uregex_open(zPattern, -1, 0, 0, &status);  if( U_SUCCESS(status) ){  sqlite3_set_auxdata(p, 0, pExpr, icuRegexpDelete);  }else{  assert(!pExpr);  icuFunctionError(p, "uregex_open", status);  return;  }  }  uregex_setText(pExpr, zString, -1, &status);  if( !U_SUCCESS(status) ){  icuFunctionError(p, "uregex_setText", status);  return;  }  res = uregex_matches(pExpr, 0, &status);  if( !U_SUCCESS(status) ){  icuFunctionError(p, "uregex_matches", status);  return;  }  uregex_setText(pExpr, 0, 0, &status);  sqlite3_result_int(p, res ? 1 : 0); } static void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg){  const UChar *zInput;  UChar *zOutput = 0;  int nInput;  int nOut;  int cnt;  int bToUpper;  UErrorCode status;  const char *zLocale = 0;  assert(nArg==1 || nArg==2);  bToUpper = (sqlite3_user_data(p)!=0);  if( nArg==2 ){  zLocale = (const char *)sqlite3_value_text(apArg[1]);  }  zInput = sqlite3_value_text16(apArg[0]);  if( !zInput ){  return;  }  nOut = nInput = sqlite3_value_bytes16(apArg[0]);  if( nOut==0 ){  sqlite3_result_text16(p, "", 0, SQLITE_STATIC);  return;  }  for(cnt=0; cnt<2; cnt++){  UChar *zNew = sqlite3_realloc(zOutput, nOut);  if( zNew==0 ){  sqlite3_free(zOutput);  sqlite3_result_error_nomem(p);  return;  }  zOutput = zNew;  status = U_ZERO_ERROR;  if( bToUpper ){  nOut = 2*u_strToUpper(zOutput,nOut/2,zInput,nInput/2,zLocale,&status);  }else{  nOut = 2*u_strToLower(zOutput,nOut/2,zInput,nInput/2,zLocale,&status);  }  if( U_SUCCESS(status) ){  sqlite3_result_text16(p, zOutput, nOut, xFree);  }else if( status==U_BUFFER_OVERFLOW_ERROR ){  assert( cnt==0 );  continue;  }else{  icuFunctionError(p, bToUpper ? "u_strToUpper" : "u_strToLower", status);  }  return;  }  assert( 0 ); }
#endif
static void icuCollationDel(void *pCtx){  UCollator *p = (UCollator *)pCtx;  ucol_close(p); } static int icuCollationColl(  void *pCtx,  int nLeft,  const void *zLeft,  int nRight,  const void *zRight ){  UCollationResult res;  UCollator *p = (UCollator *)pCtx;  res = ucol_strcoll(p, (UChar *)zLeft, nLeft/2, (UChar *)zRight, nRight/2);  switch( res ){  case UCOL_LESS: return -1;  case UCOL_GREATER: return +1;  case UCOL_EQUAL:  return 0;  }  assert(!"Unexpected return value from ucol_strcoll()");  return 0; } static void icuLoadCollation(  sqlite3_context *p,  int nArg,  sqlite3_value **apArg ){  sqlite3 *db = (sqlite3 *)sqlite3_user_data(p);  UErrorCode status = U_ZERO_ERROR;  const char *zLocale;  const char *zName;  UCollator *pUCollator;  int rc;  assert(nArg==2);  (void)nArg;  zLocale = (const char *)sqlite3_value_text(apArg[0]);  zName = (const char *)sqlite3_value_text(apArg[1]);  if( !zLocale || !zName ){  return;  }  pUCollator = ucol_open(zLocale, &status);  if( !U_SUCCESS(status) ){  icuFunctionError(p, "ucol_open", status);  return;  }  assert(p);  rc = sqlite3_create_collation_v2(db, zName, SQLITE_UTF16, (void *)pUCollator,  icuCollationColl, icuCollationDel  );  if( rc!=SQLITE_OK ){  ucol_close(pUCollator);  sqlite3_result_error(p, "Error registering collation function", -1);  } } SQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db){
# define SQLITEICU_EXTRAFLAGS (SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS)
 static const struct IcuScalar {  const char *zName;  unsigned char nArg;  unsigned int enc;  unsigned char iContext;  void (*xFunc)(sqlite3_context*,int,sqlite3_value**);  } scalars[] = {  {"icu_load_collation",2,SQLITE_UTF8|SQLITE_DIRECTONLY,1, icuLoadCollation},
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_ICU)
 {"regexp", 2, SQLITE_ANY|SQLITEICU_EXTRAFLAGS, 0, icuRegexpFunc},  {"lower", 1, SQLITE_UTF16|SQLITEICU_EXTRAFLAGS, 0, icuCaseFunc16},  {"lower", 2, SQLITE_UTF16|SQLITEICU_EXTRAFLAGS, 0, icuCaseFunc16},  {"upper", 1, SQLITE_UTF16|SQLITEICU_EXTRAFLAGS, 1, icuCaseFunc16},  {"upper", 2, SQLITE_UTF16|SQLITEICU_EXTRAFLAGS, 1, icuCaseFunc16},  {"lower", 1, SQLITE_UTF8|SQLITEICU_EXTRAFLAGS, 0, icuCaseFunc16},  {"lower", 2, SQLITE_UTF8|SQLITEICU_EXTRAFLAGS, 0, icuCaseFunc16},  {"upper", 1, SQLITE_UTF8|SQLITEICU_EXTRAFLAGS, 1, icuCaseFunc16},  {"upper", 2, SQLITE_UTF8|SQLITEICU_EXTRAFLAGS, 1, icuCaseFunc16},  {"like", 2, SQLITE_UTF8|SQLITEICU_EXTRAFLAGS, 0, icuLikeFunc},  {"like", 3, SQLITE_UTF8|SQLITEICU_EXTRAFLAGS, 0, icuLikeFunc},
#endif
 };  int rc = SQLITE_OK;  int i;  for(i=0; rc==SQLITE_OK && i<(int)(sizeof(scalars)/sizeof(scalars[0])); i++){  const struct IcuScalar *p = &scalars[i];  rc = sqlite3_create_function(  db, p->zName, p->nArg, p->enc,  p->iContext ? (void*)db : (void*)0,  p->xFunc, 0, 0  );  }  return rc; }
#if !SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_icu_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  SQLITE_EXTENSION_INIT2(pApi)  return sqlite3IcuInit(db); }
#endif
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)
#ifdef SQLITE_ENABLE_ICU
#include <unicode/ubrk.h>
#include <unicode/utf16.h>
typedef struct IcuTokenizer IcuTokenizer; typedef struct IcuCursor IcuCursor; struct IcuTokenizer {  sqlite3_tokenizer base;  char *zLocale; }; struct IcuCursor {  sqlite3_tokenizer_cursor base;  UBreakIterator *pIter;  int nChar;  UChar *aChar;  int *aOffset;  int nBuffer;  char *zBuffer;  int iToken; }; static int icuCreate(  int argc,  const char * const *argv,  sqlite3_tokenizer **ppTokenizer ){  IcuTokenizer *p;  int n = 0;  if( argc>0 ){  n = strlen(argv[0])+1;  }  p = (IcuTokenizer *)sqlite3_malloc64(sizeof(IcuTokenizer)+n);  if( !p ){  return SQLITE_NOMEM;  }  memset(p, 0, sizeof(IcuTokenizer));  if( n ){  p->zLocale = (char *)&p[1];  memcpy(p->zLocale, argv[0], n);  }  *ppTokenizer = (sqlite3_tokenizer *)p;  return SQLITE_OK; } static int icuDestroy(sqlite3_tokenizer *pTokenizer){  IcuTokenizer *p = (IcuTokenizer *)pTokenizer;  sqlite3_free(p);  return SQLITE_OK; } static int icuOpen(  sqlite3_tokenizer *pTokenizer,  const char *zInput,  int nInput,  sqlite3_tokenizer_cursor **ppCursor ){  IcuTokenizer *p = (IcuTokenizer *)pTokenizer;  IcuCursor *pCsr;  const int32_t opt = U_FOLD_CASE_DEFAULT;  UErrorCode status = U_ZERO_ERROR;  int nChar;  UChar32 c;  int iInput = 0;  int iOut = 0;  *ppCursor = 0;  if( zInput==0 ){  nInput = 0;  zInput = "";  }else if( nInput<0 ){  nInput = strlen(zInput);  }  nChar = nInput+1;  pCsr = (IcuCursor *)sqlite3_malloc64(  sizeof(IcuCursor) +  ((nChar+3)&~3) * sizeof(UChar) +  (nChar+1) * sizeof(int)  );  if( !pCsr ){  return SQLITE_NOMEM;  }  memset(pCsr, 0, sizeof(IcuCursor));  pCsr->aChar = (UChar *)&pCsr[1];  pCsr->aOffset = (int *)&pCsr->aChar[(nChar+3)&~3];  pCsr->aOffset[iOut] = iInput;  U8_NEXT(zInput, iInput, nInput, c);  while( c>0 ){  int isError = 0;  c = u_foldCase(c, opt);  U16_APPEND(pCsr->aChar, iOut, nChar, c, isError);  if( isError ){  sqlite3_free(pCsr);  return SQLITE_ERROR;  }  pCsr->aOffset[iOut] = iInput;  if( iInput<nInput ){  U8_NEXT(zInput, iInput, nInput, c);  }else{  c = 0;  }  }  pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status);  if( !U_SUCCESS(status) ){  sqlite3_free(pCsr);  return SQLITE_ERROR;  }  pCsr->nChar = iOut;  ubrk_first(pCsr->pIter);  *ppCursor = (sqlite3_tokenizer_cursor *)pCsr;  return SQLITE_OK; } static int icuClose(sqlite3_tokenizer_cursor *pCursor){  IcuCursor *pCsr = (IcuCursor *)pCursor;  ubrk_close(pCsr->pIter);  sqlite3_free(pCsr->zBuffer);  sqlite3_free(pCsr);  return SQLITE_OK; } static int icuNext(  sqlite3_tokenizer_cursor *pCursor,  const char **ppToken,  int *pnBytes,  int *piStartOffset,  int *piEndOffset,  int *piPosition ){  IcuCursor *pCsr = (IcuCursor *)pCursor;  int iStart = 0;  int iEnd = 0;  int nByte = 0;  while( iStart==iEnd ){  UChar32 c;  iStart = ubrk_current(pCsr->pIter);  iEnd = ubrk_next(pCsr->pIter);  if( iEnd==UBRK_DONE ){  return SQLITE_DONE;  }  while( iStart<iEnd ){  int iWhite = iStart;  U16_NEXT(pCsr->aChar, iWhite, pCsr->nChar, c);  if( u_isspace(c) ){  iStart = iWhite;  }else{  break;  }  }  assert(iStart<=iEnd);  }  do {  UErrorCode status = U_ZERO_ERROR;  if( nByte ){  char *zNew = sqlite3_realloc(pCsr->zBuffer, nByte);  if( !zNew ){  return SQLITE_NOMEM;  }  pCsr->zBuffer = zNew;  pCsr->nBuffer = nByte;  }  u_strToUTF8(  pCsr->zBuffer, pCsr->nBuffer, &nByte,  &pCsr->aChar[iStart], iEnd-iStart,  &status  );  } while( nByte>pCsr->nBuffer );  *ppToken = pCsr->zBuffer;  *pnBytes = nByte;  *piStartOffset = pCsr->aOffset[iStart];  *piEndOffset = pCsr->aOffset[iEnd];  *piPosition = pCsr->iToken++;  return SQLITE_OK; } static const sqlite3_tokenizer_module icuTokenizerModule = {  0,  icuCreate,  icuDestroy,  icuOpen,  icuClose,  icuNext,  0, }; SQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(  sqlite3_tokenizer_module const**ppModule ){  *ppModule = &icuTokenizerModule; }
#endif
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_RBU)
#ifndef _SQLITE3RBU_H
#define _SQLITE3RBU_H
#if 0
extern "C" {
#endif
typedef struct sqlite3rbu sqlite3rbu; SQLITE_API sqlite3rbu *sqlite3rbu_open(  const char *zTarget,  const char *zRbu,  const char *zState ); SQLITE_API sqlite3rbu *sqlite3rbu_vacuum(  const char *zTarget,  const char *zState ); SQLITE_API sqlite3_int64 sqlite3rbu_temp_size_limit(sqlite3rbu*, sqlite3_int64); SQLITE_API sqlite3_int64 sqlite3rbu_temp_size(sqlite3rbu*); SQLITE_API sqlite3 *sqlite3rbu_db(sqlite3rbu*, int bRbu); SQLITE_API int sqlite3rbu_step(sqlite3rbu *pRbu); SQLITE_API int sqlite3rbu_savestate(sqlite3rbu *pRbu); SQLITE_API int sqlite3rbu_close(sqlite3rbu *pRbu, char **pzErrmsg); SQLITE_API sqlite3_int64 sqlite3rbu_progress(sqlite3rbu *pRbu); SQLITE_API void sqlite3rbu_bp_progress(sqlite3rbu *pRbu, int *pnOne, int*pnTwo);
#define SQLITE_RBU_STATE_OAL 1
#define SQLITE_RBU_STATE_MOVE  2
#define SQLITE_RBU_STATE_CHECKPOINT 3
#define SQLITE_RBU_STATE_DONE  4
#define SQLITE_RBU_STATE_ERROR 5
SQLITE_API int sqlite3rbu_state(sqlite3rbu *pRbu); SQLITE_API int sqlite3rbu_create_vfs(const char *zName, const char *zParent); SQLITE_API void sqlite3rbu_destroy_vfs(const char *zName);
#if 0
}
#endif
#endif
#if defined(_WIN32_WCE)
#endif
#define SQLITE_RBU_UPDATE_CACHESIZE 16
#ifndef RBU_ENABLE_DELTA_CKSUM
# define RBU_ENABLE_DELTA_CKSUM 0
#endif
#if !defined(SQLITE_AMALGAMATION)
# define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}
#endif
#define RBU_EXCLUSIVE_CHECKPOINT "rbu_exclusive_checkpoint"
#define RBU_STATE_STAGE 1
#define RBU_STATE_TBL 2
#define RBU_STATE_IDX 3
#define RBU_STATE_ROW 4
#define RBU_STATE_PROGRESS  5
#define RBU_STATE_CKPT  6
#define RBU_STATE_COOKIE  7
#define RBU_STATE_OALSZ 8
#define RBU_STATE_PHASEONESTEP 9
#define RBU_STATE_DATATBL  10
#define RBU_STAGE_OAL  1
#define RBU_STAGE_MOVE 2
#define RBU_STAGE_CAPTURE  3
#define RBU_STAGE_CKPT 4
#define RBU_STAGE_DONE 5
#define RBU_CREATE_STATE  "CREATE TABLE IF NOT EXISTS %s.rbu_state(k INTEGER PRIMARY KEY, v)"

typedef struct RbuFrame RbuFrame; typedef struct RbuObjIter RbuObjIter; typedef struct RbuState RbuState; typedef struct RbuSpan RbuSpan; typedef struct rbu_vfs rbu_vfs; typedef struct rbu_file rbu_file; typedef struct RbuUpdateStmt RbuUpdateStmt;
#if !defined(SQLITE_AMALGAMATION)
typedef unsigned int u32; typedef unsigned short u16; typedef unsigned char u8; typedef sqlite3_int64 i64;
#endif
#define WAL_LOCK_WRITE 0
#define WAL_LOCK_CKPT  1
#define WAL_LOCK_READ0 3
#define SQLITE_FCNTL_RBUCNT 5149216
struct RbuState {  int eStage;  char *zTbl;  char *zDataTbl;  char *zIdx;  i64 iWalCksum;  int nRow;  i64 nProgress;  u32 iCookie;  i64 iOalSz;  i64 nPhaseOneStep; }; struct RbuUpdateStmt {  char *zMask;  sqlite3_stmt *pUpdate;  RbuUpdateStmt *pNext; }; struct RbuSpan {  const char *zSpan;  int nSpan; }; struct RbuObjIter {  sqlite3_stmt *pTblIter;  sqlite3_stmt *pIdxIter;  int nTblCol;  char **azTblCol;  char **azTblType;  int *aiSrcOrder;  u8 *abTblPk;  u8 *abNotNull;  u8 *abIndexed;  int eType;  int bCleanup;  const char *zTbl;  const char *zDataTbl;  const char *zIdx;  int iTnum;  int iPkTnum;  int bUnique;  int nIndex;  int nCol;  sqlite3_stmt *pSelect;  sqlite3_stmt *pInsert;  sqlite3_stmt *pDelete;  sqlite3_stmt *pTmpInsert;  int nIdxCol;  RbuSpan *aIdxCol;  char *zIdxSql;  RbuUpdateStmt *pRbuUpdate; };
#define RBU_PK_NOTABLE 0
#define RBU_PK_NONE  1
#define RBU_PK_IPK 2
#define RBU_PK_EXTERNAL  3
#define RBU_PK_WITHOUT_ROWID 4
#define RBU_PK_VTAB  5
#define RBU_INSERT  1
#define RBU_DELETE  2
#define RBU_REPLACE 3
#define RBU_IDX_DELETE 4
#define RBU_IDX_INSERT 5
#define RBU_UPDATE  6
struct RbuFrame {  u32 iDbPage;  u32 iWalFrame; }; struct sqlite3rbu {  int eStage;  sqlite3 *dbMain;  sqlite3 *dbRbu;  char *zTarget;  char *zRbu;  char *zState;  char zStateDb[5];  int rc;  char *zErrmsg;  int nStep;  int nProgress;  RbuObjIter objiter;  const char *zVfsName;  rbu_file *pTargetFd;  int nPagePerSector;  i64 iOalSz;  i64 nPhaseOneStep;  u32 iMaxFrame;  u32 mLock;  int nFrame;  int nFrameAlloc;  RbuFrame *aFrame;  int pgsz;  u8 *aBuf;  i64 iWalCksum;  i64 szTemp;  i64 szTempLimit;  int nRbu;  rbu_file *pRbuFd; }; struct rbu_vfs {  sqlite3_vfs base;  sqlite3_vfs *pRealVfs;  sqlite3_mutex *mutex;  sqlite3rbu *pRbu;  rbu_file *pMain;  rbu_file *pMainRbu; }; struct rbu_file {  sqlite3_file base;  sqlite3_file *pReal;  rbu_vfs *pRbuVfs;  sqlite3rbu *pRbu;  i64 sz;  int openFlags;  u32 iCookie;  u8 iWriteVer;  u8 bNolock;  int nShm;  char **apShm;  char *zDel;  const char *zWal;  rbu_file *pWalFd;  rbu_file *pMainNext;  rbu_file *pMainRbuNext; };
#define rbuIsVacuum(p) ((p)->zTarget==0)
static unsigned int rbuDeltaGetInt(const char **pz, int *pLen){  static const signed char zValue[] = {  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,  -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,  25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, 36,  -1, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,  52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, -1, -1, -1, 63, -1,  };  unsigned int v = 0;  int c;  unsigned char *z = (unsigned char*)*pz;  unsigned char *zStart = z;  while( (c = zValue[0x7f&*(z++)])>=0 ){   v = (v<<6) + c;  }  z--;  *pLen -= z - zStart;  *pz = (char*)z;  return v; }
#if RBU_ENABLE_DELTA_CKSUM
static unsigned int rbuDeltaChecksum(const char *zIn, size_t N){  const unsigned char *z = (const unsigned char *)zIn;  unsigned sum0 = 0;  unsigned sum1 = 0;  unsigned sum2 = 0;  unsigned sum3 = 0;  while(N >= 16){  sum0 += ((unsigned)z[0] + z[4] + z[8] + z[12]);  sum1 += ((unsigned)z[1] + z[5] + z[9] + z[13]);  sum2 += ((unsigned)z[2] + z[6] + z[10]+ z[14]);  sum3 += ((unsigned)z[3] + z[7] + z[11]+ z[15]);  z += 16;  N -= 16;  }  while(N >= 4){  sum0 += z[0];  sum1 += z[1];  sum2 += z[2];  sum3 += z[3];  z += 4;  N -= 4;  }  sum3 += (sum2 << 8) + (sum1 << 16) + (sum0 << 24);  switch(N){  case 3:  sum3 += (z[2] << 8);  case 2:  sum3 += (z[1] << 16);  case 1:  sum3 += (z[0] << 24);  default: ;  }  return sum3; }
#endif
static int rbuDeltaApply(  const char *zSrc,  int lenSrc,  const char *zDelta,  int lenDelta,  char *zOut ){  unsigned int limit;  unsigned int total = 0;
#if RBU_ENABLE_DELTA_CKSUM
 char *zOrigOut = zOut;
#endif
 limit = rbuDeltaGetInt(&zDelta, &lenDelta);  if( *zDelta!='\n' ){  return -1;  }  zDelta++; lenDelta--;  while( *zDelta && lenDelta>0 ){  unsigned int cnt, ofst;  cnt = rbuDeltaGetInt(&zDelta, &lenDelta);  switch( zDelta[0] ){  case '@': {  zDelta++; lenDelta--;  ofst = rbuDeltaGetInt(&zDelta, &lenDelta);  if( lenDelta>0 && zDelta[0]!=',' ){  return -1;  }  zDelta++; lenDelta--;  total += cnt;  if( total>limit ){  return -1;  }  if( (int)(ofst+cnt) > lenSrc ){  return -1;  }  memcpy(zOut, &zSrc[ofst], cnt);  zOut += cnt;  break;  }  case ':': {  zDelta++; lenDelta--;  total += cnt;  if( total>limit ){  return -1;  }  if( (int)cnt>lenDelta ){  return -1;  }  memcpy(zOut, zDelta, cnt);  zOut += cnt;  zDelta += cnt;  lenDelta -= cnt;  break;  }  case ';': {  zDelta++; lenDelta--;  zOut[0] = 0;
#if RBU_ENABLE_DELTA_CKSUM
 if( cnt!=rbuDeltaChecksum(zOrigOut, total) ){  return -1;  }
#endif
 if( total!=limit ){  return -1;  }  return total;  }  default: {  return -1;  }  }  }  return -1; } static int rbuDeltaOutputSize(const char *zDelta, int lenDelta){  int size;  size = rbuDeltaGetInt(&zDelta, &lenDelta);  if( *zDelta!='\n' ){  return -1;  }  return size; } static void rbuFossilDeltaFunc(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  const char *aDelta;  int nDelta;  const char *aOrig;  int nOrig;  int nOut;  int nOut2;  char *aOut;  assert( argc==2 );  nOrig = sqlite3_value_bytes(argv[0]);  aOrig = (const char*)sqlite3_value_blob(argv[0]);  nDelta = sqlite3_value_bytes(argv[1]);  aDelta = (const char*)sqlite3_value_blob(argv[1]);  nOut = rbuDeltaOutputSize(aDelta, nDelta);  if( nOut<0 ){  sqlite3_result_error(context, "corrupt fossil delta", -1);  return;  }  aOut = sqlite3_malloc(nOut+1);  if( aOut==0 ){  sqlite3_result_error_nomem(context);  }else{  nOut2 = rbuDeltaApply(aOrig, nOrig, aDelta, nDelta, aOut);  if( nOut2!=nOut ){  sqlite3_free(aOut);  sqlite3_result_error(context, "corrupt fossil delta", -1);  }else{  sqlite3_result_blob(context, aOut, nOut, sqlite3_free);  }  } } static int prepareAndCollectError(  sqlite3 *db,  sqlite3_stmt **ppStmt,  char **pzErrmsg,  const char *zSql ){  int rc = sqlite3_prepare_v2(db, zSql, -1, ppStmt, 0);  if( rc!=SQLITE_OK ){  *pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));  *ppStmt = 0;  }  return rc; } static int resetAndCollectError(sqlite3_stmt *pStmt, char **pzErrmsg){  int rc = sqlite3_reset(pStmt);  if( rc!=SQLITE_OK ){  *pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(sqlite3_db_handle(pStmt)));  }  return rc; } static int prepareFreeAndCollectError(  sqlite3 *db,  sqlite3_stmt **ppStmt,  char **pzErrmsg,  char *zSql ){  int rc;  assert( *pzErrmsg==0 );  if( zSql==0 ){  rc = SQLITE_NOMEM;  *ppStmt = 0;  }else{  rc = prepareAndCollectError(db, ppStmt, pzErrmsg, zSql);  sqlite3_free(zSql);  }  return rc; } static void rbuObjIterFreeCols(RbuObjIter *pIter){  int i;  for(i=0; i<pIter->nTblCol; i++){  sqlite3_free(pIter->azTblCol[i]);  sqlite3_free(pIter->azTblType[i]);  }  sqlite3_free(pIter->azTblCol);  pIter->azTblCol = 0;  pIter->azTblType = 0;  pIter->aiSrcOrder = 0;  pIter->abTblPk = 0;  pIter->abNotNull = 0;  pIter->nTblCol = 0;  pIter->eType = 0; } static void rbuObjIterClearStatements(RbuObjIter *pIter){  RbuUpdateStmt *pUp;  sqlite3_finalize(pIter->pSelect);  sqlite3_finalize(pIter->pInsert);  sqlite3_finalize(pIter->pDelete);  sqlite3_finalize(pIter->pTmpInsert);  pUp = pIter->pRbuUpdate;  while( pUp ){  RbuUpdateStmt *pTmp = pUp->pNext;  sqlite3_finalize(pUp->pUpdate);  sqlite3_free(pUp);  pUp = pTmp;  }  sqlite3_free(pIter->aIdxCol);  sqlite3_free(pIter->zIdxSql);  pIter->pSelect = 0;  pIter->pInsert = 0;  pIter->pDelete = 0;  pIter->pRbuUpdate = 0;  pIter->pTmpInsert = 0;  pIter->nCol = 0;  pIter->nIdxCol = 0;  pIter->aIdxCol = 0;  pIter->zIdxSql = 0; } static void rbuObjIterFinalize(RbuObjIter *pIter){  rbuObjIterClearStatements(pIter);  sqlite3_finalize(pIter->pTblIter);  sqlite3_finalize(pIter->pIdxIter);  rbuObjIterFreeCols(pIter);  memset(pIter, 0, sizeof(RbuObjIter)); } static int rbuObjIterNext(sqlite3rbu *p, RbuObjIter *pIter){  int rc = p->rc;  if( rc==SQLITE_OK ){  rbuObjIterClearStatements(pIter);  if( pIter->zIdx==0 ){  rc = sqlite3_exec(p->dbMain,  "DROP TRIGGER IF EXISTS temp.rbu_insert_tr;"  "DROP TRIGGER IF EXISTS temp.rbu_update1_tr;"  "DROP TRIGGER IF EXISTS temp.rbu_update2_tr;"  "DROP TRIGGER IF EXISTS temp.rbu_delete_tr;"  , 0, 0, &p->zErrmsg  );  }  if( rc==SQLITE_OK ){  if( pIter->bCleanup ){  rbuObjIterFreeCols(pIter);  pIter->bCleanup = 0;  rc = sqlite3_step(pIter->pTblIter);  if( rc!=SQLITE_ROW ){  rc = resetAndCollectError(pIter->pTblIter, &p->zErrmsg);  pIter->zTbl = 0;  }else{  pIter->zTbl = (const char*)sqlite3_column_text(pIter->pTblIter, 0);  pIter->zDataTbl = (const char*)sqlite3_column_text(pIter->pTblIter,1);  rc = (pIter->zDataTbl && pIter->zTbl) ? SQLITE_OK : SQLITE_NOMEM;  }  }else{  if( pIter->zIdx==0 ){  sqlite3_stmt *pIdx = pIter->pIdxIter;  rc = sqlite3_bind_text(pIdx, 1, pIter->zTbl, -1, SQLITE_STATIC);  }  if( rc==SQLITE_OK ){  rc = sqlite3_step(pIter->pIdxIter);  if( rc!=SQLITE_ROW ){  rc = resetAndCollectError(pIter->pIdxIter, &p->zErrmsg);  pIter->bCleanup = 1;  pIter->zIdx = 0;  }else{  pIter->zIdx = (const char*)sqlite3_column_text(pIter->pIdxIter, 0);  pIter->iTnum = sqlite3_column_int(pIter->pIdxIter, 1);  pIter->bUnique = sqlite3_column_int(pIter->pIdxIter, 2);  rc = pIter->zIdx ? SQLITE_OK : SQLITE_NOMEM;  }  }  }  }  }  if( rc!=SQLITE_OK ){  rbuObjIterFinalize(pIter);  p->rc = rc;  }  return rc; } static void rbuTargetNameFunc(  sqlite3_context *pCtx,  int argc,  sqlite3_value **argv ){  sqlite3rbu *p = sqlite3_user_data(pCtx);  const char *zIn;  assert( argc==1 || argc==2 );  zIn = (const char*)sqlite3_value_text(argv[0]);  if( zIn ){  if( rbuIsVacuum(p) ){  assert( argc==2 || argc==1 );  if( argc==1 || 0==sqlite3_value_int(argv[1]) ){  sqlite3_result_text(pCtx, zIn, -1, SQLITE_STATIC);  }  }else{  if( strlen(zIn)>4 && memcmp("data", zIn, 4)==0 ){  int i;  for(i=4; zIn[i]>='0' && zIn[i]<='9'; i++);  if( zIn[i]=='_' && zIn[i+1] ){  sqlite3_result_text(pCtx, &zIn[i+1], -1, SQLITE_STATIC);  }  }  }  } } static int rbuObjIterFirst(sqlite3rbu *p, RbuObjIter *pIter){  int rc;  memset(pIter, 0, sizeof(RbuObjIter));  rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pTblIter, &p->zErrmsg,  sqlite3_mprintf(  "SELECT rbu_target_name(name, type='view') AS target, name "  "FROM sqlite_schema "  "WHERE type IN ('table', 'view') AND target IS NOT NULL "  " %s "  "ORDER BY name"  , rbuIsVacuum(p) ? "AND rootpage!=0 AND rootpage IS NOT NULL" : ""));  if( rc==SQLITE_OK ){  rc = prepareAndCollectError(p->dbMain, &pIter->pIdxIter, &p->zErrmsg,  "SELECT name, rootpage, sql IS NULL OR substr(8, 6)=='UNIQUE' "  " FROM main.sqlite_schema "  " WHERE type='index' AND tbl_name = ?"  );  }  pIter->bCleanup = 1;  p->rc = rc;  return rbuObjIterNext(p, pIter); } static char *rbuMPrintf(sqlite3rbu *p, const char *zFmt, ...){  char *zSql = 0;  va_list ap;  va_start(ap, zFmt);  zSql = sqlite3_vmprintf(zFmt, ap);  if( p->rc==SQLITE_OK ){  if( zSql==0 ) p->rc = SQLITE_NOMEM;  }else{  sqlite3_free(zSql);  zSql = 0;  }  va_end(ap);  return zSql; } static int rbuMPrintfExec(sqlite3rbu *p, sqlite3 *db, const char *zFmt, ...){  va_list ap;  char *zSql;  va_start(ap, zFmt);  zSql = sqlite3_vmprintf(zFmt, ap);  if( p->rc==SQLITE_OK ){  if( zSql==0 ){  p->rc = SQLITE_NOMEM;  }else{  p->rc = sqlite3_exec(db, zSql, 0, 0, &p->zErrmsg);  }  }  sqlite3_free(zSql);  va_end(ap);  return p->rc; } static void *rbuMalloc(sqlite3rbu *p, sqlite3_int64 nByte){  void *pRet = 0;  if( p->rc==SQLITE_OK ){  assert( nByte>0 );  pRet = sqlite3_malloc64(nByte);  if( pRet==0 ){  p->rc = SQLITE_NOMEM;  }else{  memset(pRet, 0, nByte);  }  }  return pRet; } static void rbuAllocateIterArrays(sqlite3rbu *p, RbuObjIter *pIter, int nCol){  sqlite3_int64 nByte = (2*sizeof(char*) + sizeof(int) + 3*sizeof(u8)) * nCol;  char **azNew;  azNew = (char**)rbuMalloc(p, nByte);  if( azNew ){  pIter->azTblCol = azNew;  pIter->azTblType = &azNew[nCol];  pIter->aiSrcOrder = (int*)&pIter->azTblType[nCol];  pIter->abTblPk = (u8*)&pIter->aiSrcOrder[nCol];  pIter->abNotNull = (u8*)&pIter->abTblPk[nCol];  pIter->abIndexed = (u8*)&pIter->abNotNull[nCol];  } } static char *rbuStrndup(const char *zStr, int *pRc){  char *zRet = 0;  if( *pRc==SQLITE_OK ){  if( zStr ){  size_t nCopy = strlen(zStr) + 1;  zRet = (char*)sqlite3_malloc64(nCopy);  if( zRet ){  memcpy(zRet, zStr, nCopy);  }else{  *pRc = SQLITE_NOMEM;  }  }  }  return zRet; } static void rbuFinalize(sqlite3rbu *p, sqlite3_stmt *pStmt){  sqlite3 *db = sqlite3_db_handle(pStmt);  int rc = sqlite3_finalize(pStmt);  if( p->rc==SQLITE_OK && rc!=SQLITE_OK ){  p->rc = rc;  p->zErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));  } } static void rbuTableType(  sqlite3rbu *p,  const char *zTab,  int *peType,  int *piTnum,  int *piPk ){  sqlite3_stmt *aStmt[4] = {0, 0, 0, 0};  *peType = RBU_PK_NOTABLE;  *piPk = 0;  assert( p->rc==SQLITE_OK );  p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[0], &p->zErrmsg,  sqlite3_mprintf(  "SELECT "  " (sql COLLATE nocase BETWEEN 'CREATE VIRTUAL' AND 'CREATE VIRTUAM'),"  " rootpage"  " FROM sqlite_schema"  " WHERE name=%Q", zTab  ));  if( p->rc!=SQLITE_OK || sqlite3_step(aStmt[0])!=SQLITE_ROW ){  goto rbuTableType_end;  }  if( sqlite3_column_int(aStmt[0], 0) ){  *peType = RBU_PK_VTAB;  goto rbuTableType_end;  }  *piTnum = sqlite3_column_int(aStmt[0], 1);  p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[1], &p->zErrmsg,  sqlite3_mprintf("PRAGMA index_list=%Q",zTab)  );  if( p->rc ) goto rbuTableType_end;  while( sqlite3_step(aStmt[1])==SQLITE_ROW ){  const u8 *zOrig = sqlite3_column_text(aStmt[1], 3);  const u8 *zIdx = sqlite3_column_text(aStmt[1], 1);  if( zOrig && zIdx && zOrig[0]=='p' ){  p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[2], &p->zErrmsg,  sqlite3_mprintf(  "SELECT rootpage FROM sqlite_schema WHERE name = %Q", zIdx  ));  if( p->rc==SQLITE_OK ){  if( sqlite3_step(aStmt[2])==SQLITE_ROW ){  *piPk = sqlite3_column_int(aStmt[2], 0);  *peType = RBU_PK_EXTERNAL;  }else{  *peType = RBU_PK_WITHOUT_ROWID;  }  }  goto rbuTableType_end;  }  }  p->rc = prepareFreeAndCollectError(p->dbMain, &aStmt[3], &p->zErrmsg,  sqlite3_mprintf("PRAGMA table_info=%Q",zTab)  );  if( p->rc==SQLITE_OK ){  while( sqlite3_step(aStmt[3])==SQLITE_ROW ){  if( sqlite3_column_int(aStmt[3],5)>0 ){  *peType = RBU_PK_IPK;  goto rbuTableType_end;  }  }  *peType = RBU_PK_NONE;  } rbuTableType_end: {  unsigned int i;  for(i=0; i<sizeof(aStmt)/sizeof(aStmt[0]); i++){  rbuFinalize(p, aStmt[i]);  }  } } static void rbuObjIterCacheIndexedCols(sqlite3rbu *p, RbuObjIter *pIter){  sqlite3_stmt *pList = 0;  int bIndex = 0;  if( p->rc==SQLITE_OK ){  memcpy(pIter->abIndexed, pIter->abTblPk, sizeof(u8)*pIter->nTblCol);  p->rc = prepareFreeAndCollectError(p->dbMain, &pList, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_list = %Q", pIter->zTbl)  );  }  pIter->nIndex = 0;  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pList) ){  const char *zIdx = (const char*)sqlite3_column_text(pList, 1);  int bPartial = sqlite3_column_int(pList, 4);  sqlite3_stmt *pXInfo = 0;  if( zIdx==0 ) break;  if( bPartial ){  memset(pIter->abIndexed, 0x01, sizeof(u8)*pIter->nTblCol);  }  p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)  );  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){  int iCid = sqlite3_column_int(pXInfo, 1);  if( iCid>=0 ) pIter->abIndexed[iCid] = 1;  if( iCid==-2 ){  memset(pIter->abIndexed, 0x01, sizeof(u8)*pIter->nTblCol);  }  }  rbuFinalize(p, pXInfo);  bIndex = 1;  pIter->nIndex++;  }  if( pIter->eType==RBU_PK_WITHOUT_ROWID ){  pIter->nIndex--;  }  rbuFinalize(p, pList);  if( bIndex==0 ) pIter->abIndexed = 0; } static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter){  if( pIter->azTblCol==0 ){  sqlite3_stmt *pStmt = 0;  int nCol = 0;  int i;  int bRbuRowid = 0;  int iOrder = 0;  int iTnum = 0;  assert( pIter->eType==0 );  rbuTableType(p, pIter->zTbl, &pIter->eType, &iTnum, &pIter->iPkTnum);  if( p->rc==SQLITE_OK && pIter->eType==RBU_PK_NOTABLE ){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("no such table: %s", pIter->zTbl);  }  if( p->rc ) return p->rc;  if( pIter->zIdx==0 ) pIter->iTnum = iTnum;  assert( pIter->eType==RBU_PK_NONE || pIter->eType==RBU_PK_IPK   || pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_WITHOUT_ROWID   || pIter->eType==RBU_PK_VTAB  );  p->rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,  sqlite3_mprintf("SELECT * FROM '%q'", pIter->zDataTbl)  );  if( p->rc==SQLITE_OK ){  nCol = sqlite3_column_count(pStmt);  rbuAllocateIterArrays(p, pIter, nCol);  }  for(i=0; p->rc==SQLITE_OK && i<nCol; i++){  const char *zName = (const char*)sqlite3_column_name(pStmt, i);  if( sqlite3_strnicmp("rbu_", zName, 4) ){  char *zCopy = rbuStrndup(zName, &p->rc);  pIter->aiSrcOrder[pIter->nTblCol] = pIter->nTblCol;  pIter->azTblCol[pIter->nTblCol++] = zCopy;  }  else if( 0==sqlite3_stricmp("rbu_rowid", zName) ){  bRbuRowid = 1;  }  }  sqlite3_finalize(pStmt);  pStmt = 0;  if( p->rc==SQLITE_OK   && rbuIsVacuum(p)==0   && bRbuRowid!=(pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE)  ){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf(  "table %q %s rbu_rowid column", pIter->zDataTbl,  (bRbuRowid ? "may not have" : "requires")  );  }  if( p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pStmt, &p->zErrmsg,  sqlite3_mprintf("PRAGMA table_info(%Q)", pIter->zTbl)  );  }  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){  const char *zName = (const char*)sqlite3_column_text(pStmt, 1);  if( zName==0 ) break;  for(i=iOrder; i<pIter->nTblCol; i++){  if( 0==strcmp(zName, pIter->azTblCol[i]) ) break;  }  if( i==pIter->nTblCol ){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("column missing from %q: %s",  pIter->zDataTbl, zName  );  }else{  int iPk = sqlite3_column_int(pStmt, 5);  int bNotNull = sqlite3_column_int(pStmt, 3);  const char *zType = (const char*)sqlite3_column_text(pStmt, 2);  if( i!=iOrder ){  SWAP(int, pIter->aiSrcOrder[i], pIter->aiSrcOrder[iOrder]);  SWAP(char*, pIter->azTblCol[i], pIter->azTblCol[iOrder]);  }  pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);  assert( iPk>=0 );  pIter->abTblPk[iOrder] = (u8)iPk;  pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk!=0);  iOrder++;  }  }  rbuFinalize(p, pStmt);  rbuObjIterCacheIndexedCols(p, pIter);  assert( pIter->eType!=RBU_PK_VTAB || pIter->abIndexed==0 );  assert( pIter->eType!=RBU_PK_VTAB || pIter->nIndex==0 );  }  return p->rc; } static char *rbuObjIterGetCollist(  sqlite3rbu *p,  RbuObjIter *pIter ){  char *zList = 0;  const char *zSep = "";  int i;  for(i=0; i<pIter->nTblCol; i++){  const char *z = pIter->azTblCol[i];  zList = rbuMPrintf(p, "%z%s\"%w\"", zList, zSep, z);  zSep = ", ";  }  return zList; } static char *rbuObjIterGetPkList(  sqlite3rbu *p,  RbuObjIter *pIter,  const char *zPre,  const char *zSeparator,  const char *zPost ){  int iPk = 1;  char *zRet = 0;  const char *zSep = "";  while( 1 ){  int i;  for(i=0; i<pIter->nTblCol; i++){  if( (int)pIter->abTblPk[i]==iPk ){  const char *zCol = pIter->azTblCol[i];  zRet = rbuMPrintf(p, "%z%s%s\"%w\"%s", zRet, zSep, zPre, zCol, zPost);  zSep = zSeparator;  break;  }  }  if( i==pIter->nTblCol ) break;  iPk++;  }  return zRet; } static char *rbuVacuumTableStart(  sqlite3rbu *p,  RbuObjIter *pIter,  int bRowid,  const char *zWrite ){  sqlite3_stmt *pMax = 0;  char *zRet = 0;  if( bRowid ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,  sqlite3_mprintf(  "SELECT max(_rowid_) FROM \"%s%w\"", zWrite, pIter->zTbl  )  );  if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){  sqlite3_int64 iMax = sqlite3_column_int64(pMax, 0);  zRet = rbuMPrintf(p, " WHERE _rowid_ > %lld ", iMax);  }  rbuFinalize(p, pMax);  }else{  char *zOrder = rbuObjIterGetPkList(p, pIter, "", ", ", " DESC");  char *zSelect = rbuObjIterGetPkList(p, pIter, "quote(", "||','||", ")");  char *zList = rbuObjIterGetPkList(p, pIter, "", ", ", "");  if( p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,  sqlite3_mprintf(  "SELECT %s FROM \"%s%w\" ORDER BY %s LIMIT 1",  zSelect, zWrite, pIter->zTbl, zOrder  )  );  if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){  const char *zVal = (const char*)sqlite3_column_text(pMax, 0);  zRet = rbuMPrintf(p, " WHERE (%s) > (%s) ", zList, zVal);  }  rbuFinalize(p, pMax);  }  sqlite3_free(zOrder);  sqlite3_free(zSelect);  sqlite3_free(zList);  }  return zRet; } char *rbuVacuumIndexStart(  sqlite3rbu *p,  RbuObjIter *pIter ){  char *zOrder = 0;  char *zLhs = 0;  char *zSelect = 0;  char *zVector = 0;  char *zRet = 0;  int bFailed = 0;  const char *zSep = "";  int iCol = 0;  sqlite3_stmt *pXInfo = 0;  p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", pIter->zIdx)  );  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){  int iCid = sqlite3_column_int(pXInfo, 1);  const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);  const char *zCol;  if( sqlite3_column_int(pXInfo, 3) ){  bFailed = 1;  break;  }  if( iCid<0 ){  if( pIter->eType==RBU_PK_IPK ){  int i;  for(i=0; pIter->abTblPk[i]==0; i++);  assert( i<pIter->nTblCol );  zCol = pIter->azTblCol[i];  }else{  zCol = "_rowid_";  }  }else{  zCol = pIter->azTblCol[iCid];  }  zLhs = rbuMPrintf(p, "%z%s \"%w\" COLLATE %Q",  zLhs, zSep, zCol, zCollate  );  zOrder = rbuMPrintf(p, "%z%s \"rbu_imp_%d%w\" COLLATE %Q DESC",  zOrder, zSep, iCol, zCol, zCollate  );  zSelect = rbuMPrintf(p, "%z%s quote(\"rbu_imp_%d%w\")",  zSelect, zSep, iCol, zCol  );  zSep = ", ";  iCol++;  }  rbuFinalize(p, pXInfo);  if( bFailed ) goto index_start_out;  if( p->rc==SQLITE_OK ){  sqlite3_stmt *pSel = 0;  p->rc = prepareFreeAndCollectError(p->dbMain, &pSel, &p->zErrmsg,  sqlite3_mprintf("SELECT %s FROM \"rbu_imp_%w\" ORDER BY %s LIMIT 1",  zSelect, pIter->zTbl, zOrder  )  );  if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSel) ){  zSep = "";  for(iCol=0; iCol<pIter->nCol; iCol++){  const char *zQuoted = (const char*)sqlite3_column_text(pSel, iCol);  if( zQuoted==0 ){  p->rc = SQLITE_NOMEM;  }else if( zQuoted[0]=='N' ){  bFailed = 1;  break;  }  zVector = rbuMPrintf(p, "%z%s%s", zVector, zSep, zQuoted);  zSep = ", ";  }  if( !bFailed ){  zRet = rbuMPrintf(p, "(%s) > (%s)", zLhs, zVector);  }  }  rbuFinalize(p, pSel);  }  index_start_out:  sqlite3_free(zOrder);  sqlite3_free(zSelect);  sqlite3_free(zVector);  sqlite3_free(zLhs);  return zRet; } static char *rbuObjIterGetIndexCols(  sqlite3rbu *p,  RbuObjIter *pIter,  char **pzImposterCols,  char **pzImposterPk,  char **pzWhere,  int *pnBind ){  int rc = p->rc;  int rc2;  char *zRet = 0;  char *zImpCols = 0;  char *zImpPK = 0;  char *zWhere = 0;  int nBind = 0;  const char *zCom = "";  const char *zAnd = "";  sqlite3_stmt *pXInfo = 0;  if( rc==SQLITE_OK ){  assert( p->zErrmsg==0 );  rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", pIter->zIdx)  );  }  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){  int iCid = sqlite3_column_int(pXInfo, 1);  int bDesc = sqlite3_column_int(pXInfo, 3);  const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);  const char *zCol = 0;  const char *zType;  if( iCid==-2 ){  int iSeq = sqlite3_column_int(pXInfo, 0);  zRet = sqlite3_mprintf("%z%s(%.*s) COLLATE %Q", zRet, zCom,  pIter->aIdxCol[iSeq].nSpan, pIter->aIdxCol[iSeq].zSpan, zCollate  );  zType = "";  }else {  if( iCid<0 ){  if( pIter->eType==RBU_PK_IPK ){  int i;  for(i=0; pIter->abTblPk[i]==0; i++);  assert( i<pIter->nTblCol );  zCol = pIter->azTblCol[i];  }else if( rbuIsVacuum(p) ){  zCol = "_rowid_";  }else{  zCol = "rbu_rowid";  }  zType = "INTEGER";  }else{  zCol = pIter->azTblCol[iCid];  zType = pIter->azTblType[iCid];  }  zRet = sqlite3_mprintf("%z%s\"%w\" COLLATE %Q", zRet, zCom,zCol,zCollate);  }  if( pIter->bUnique==0 || sqlite3_column_int(pXInfo, 5) ){  const char *zOrder = (bDesc ? " DESC" : "");  zImpPK = sqlite3_mprintf("%z%s\"rbu_imp_%d%w\"%s",  zImpPK, zCom, nBind, zCol, zOrder  );  }  zImpCols = sqlite3_mprintf("%z%s\"rbu_imp_%d%w\" %s COLLATE %Q",  zImpCols, zCom, nBind, zCol, zType, zCollate  );  zWhere = sqlite3_mprintf(  "%z%s\"rbu_imp_%d%w\" IS ?", zWhere, zAnd, nBind, zCol  );  if( zRet==0 || zImpPK==0 || zImpCols==0 || zWhere==0 ) rc = SQLITE_NOMEM;  zCom = ", ";  zAnd = " AND ";  nBind++;  }  rc2 = sqlite3_finalize(pXInfo);  if( rc==SQLITE_OK ) rc = rc2;  if( rc!=SQLITE_OK ){  sqlite3_free(zRet);  sqlite3_free(zImpCols);  sqlite3_free(zImpPK);  sqlite3_free(zWhere);  zRet = 0;  zImpCols = 0;  zImpPK = 0;  zWhere = 0;  p->rc = rc;  }  *pzImposterCols = zImpCols;  *pzImposterPk = zImpPK;  *pzWhere = zWhere;  *pnBind = nBind;  return zRet; } static char *rbuObjIterGetOldlist(  sqlite3rbu *p,  RbuObjIter *pIter,  const char *zObj ){  char *zList = 0;  if( p->rc==SQLITE_OK && pIter->abIndexed ){  const char *zS = "";  int i;  for(i=0; i<pIter->nTblCol; i++){  if( pIter->abIndexed[i] ){  const char *zCol = pIter->azTblCol[i];  zList = sqlite3_mprintf("%z%s%s.\"%w\"", zList, zS, zObj, zCol);  }else{  zList = sqlite3_mprintf("%z%sNULL", zList, zS);  }  zS = ", ";  if( zList==0 ){  p->rc = SQLITE_NOMEM;  break;  }  }  if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){  zList = rbuMPrintf(p, "%z, %s._rowid_", zList, zObj);  }  }  return zList; } static char *rbuObjIterGetWhere(  sqlite3rbu *p,  RbuObjIter *pIter ){  char *zList = 0;  if( pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE ){  zList = rbuMPrintf(p, "_rowid_ = ?%d", pIter->nTblCol+1);  }else if( pIter->eType==RBU_PK_EXTERNAL ){  const char *zSep = "";  int i;  for(i=0; i<pIter->nTblCol; i++){  if( pIter->abTblPk[i] ){  zList = rbuMPrintf(p, "%z%sc%d=?%d", zList, zSep, i, i+1);  zSep = " AND ";  }  }  zList = rbuMPrintf(p,  "_rowid_ = (SELECT id FROM rbu_imposter2 WHERE %z)", zList  );  }else{  const char *zSep = "";  int i;  for(i=0; i<pIter->nTblCol; i++){  if( pIter->abTblPk[i] ){  const char *zCol = pIter->azTblCol[i];  zList = rbuMPrintf(p, "%z%s\"%w\"=?%d", zList, zSep, zCol, i+1);  zSep = " AND ";  }  }  }  return zList; } static void rbuBadControlError(sqlite3rbu *p){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("invalid rbu_control value"); } static char *rbuObjIterGetSetlist(  sqlite3rbu *p,  RbuObjIter *pIter,  const char *zMask ){  char *zList = 0;  if( p->rc==SQLITE_OK ){  int i;  if( (int)strlen(zMask)!=pIter->nTblCol ){  rbuBadControlError(p);  }else{  const char *zSep = "";  for(i=0; i<pIter->nTblCol; i++){  char c = zMask[pIter->aiSrcOrder[i]];  if( c=='x' ){  zList = rbuMPrintf(p, "%z%s\"%w\"=?%d",  zList, zSep, pIter->azTblCol[i], i+1  );  zSep = ", ";  }  else if( c=='d' ){  zList = rbuMPrintf(p, "%z%s\"%w\"=rbu_delta(\"%w\", ?%d)",  zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i+1  );  zSep = ", ";  }  else if( c=='f' ){  zList = rbuMPrintf(p, "%z%s\"%w\"=rbu_fossil_delta(\"%w\", ?%d)",  zList, zSep, pIter->azTblCol[i], pIter->azTblCol[i], i+1  );  zSep = ", ";  }  }  }  }  return zList; } static char *rbuObjIterGetBindlist(sqlite3rbu *p, int nBind){  char *zRet = 0;  sqlite3_int64 nByte = 2*(sqlite3_int64)nBind + 1;  zRet = (char*)rbuMalloc(p, nByte);  if( zRet ){  int i;  for(i=0; i<nBind; i++){  zRet[i*2] = '?';  zRet[i*2+1] = (i+1==nBind) ? '\0' : ',';  }  }  return zRet; } static char *rbuWithoutRowidPK(sqlite3rbu *p, RbuObjIter *pIter){  char *z = 0;  assert( pIter->zIdx==0 );  if( p->rc==SQLITE_OK ){  const char *zSep = "PRIMARY KEY(";  sqlite3_stmt *pXList = 0;  sqlite3_stmt *pXInfo = 0;  p->rc = prepareFreeAndCollectError(p->dbMain, &pXList, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_list = %Q", pIter->zTbl)  );  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXList) ){  const char *zOrig = (const char*)sqlite3_column_text(pXList,3);  if( zOrig && strcmp(zOrig, "pk")==0 ){  const char *zIdx = (const char*)sqlite3_column_text(pXList,1);  if( zIdx ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)  );  }  break;  }  }  rbuFinalize(p, pXList);  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){  if( sqlite3_column_int(pXInfo, 5) ){  const char *zCol = (const char*)sqlite3_column_text(pXInfo, 2);  const char *zDesc = sqlite3_column_int(pXInfo, 3) ? " DESC" : "";  z = rbuMPrintf(p, "%z%s\"%w\"%s", z, zSep, zCol, zDesc);  zSep = ", ";  }  }  z = rbuMPrintf(p, "%z)", z);  rbuFinalize(p, pXInfo);  }  return z; } static void rbuCreateImposterTable2(sqlite3rbu *p, RbuObjIter *pIter){  if( p->rc==SQLITE_OK && pIter->eType==RBU_PK_EXTERNAL ){  int tnum = pIter->iPkTnum;  sqlite3_stmt *pQuery = 0;  const char *zIdx = 0;  sqlite3_stmt *pXInfo = 0;  const char *zComma = "";  char *zCols = 0;  char *zPk = 0;  p->rc = prepareAndCollectError(p->dbMain, &pQuery, &p->zErrmsg,  "SELECT name FROM sqlite_schema WHERE rootpage = ?"  );  if( p->rc==SQLITE_OK ){  sqlite3_bind_int(pQuery, 1, tnum);  if( SQLITE_ROW==sqlite3_step(pQuery) ){  zIdx = (const char*)sqlite3_column_text(pQuery, 0);  }  }  if( zIdx ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.index_xinfo = %Q", zIdx)  );  }  rbuFinalize(p, pQuery);  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){  int bKey = sqlite3_column_int(pXInfo, 5);  if( bKey ){  int iCid = sqlite3_column_int(pXInfo, 1);  int bDesc = sqlite3_column_int(pXInfo, 3);  const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);  zCols = rbuMPrintf(p, "%z%sc%d %s COLLATE %Q", zCols, zComma,  iCid, pIter->azTblType[iCid], zCollate  );  zPk = rbuMPrintf(p, "%z%sc%d%s", zPk, zComma, iCid, bDesc?" DESC":"");  zComma = ", ";  }  }  zCols = rbuMPrintf(p, "%z, id INTEGER", zCols);  rbuFinalize(p, pXInfo);  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1, tnum);  rbuMPrintfExec(p, p->dbMain,  "CREATE TABLE rbu_imposter2(%z, PRIMARY KEY(%z)) WITHOUT ROWID",  zCols, zPk  );  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 0);  } } static void rbuCreateImposterTable(sqlite3rbu *p, RbuObjIter *pIter){  if( p->rc==SQLITE_OK && pIter->eType!=RBU_PK_VTAB ){  int tnum = pIter->iTnum;  const char *zComma = "";  char *zSql = 0;  int iCol;  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 1);  for(iCol=0; p->rc==SQLITE_OK && iCol<pIter->nTblCol; iCol++){  const char *zPk = "";  const char *zCol = pIter->azTblCol[iCol];  const char *zColl = 0;  p->rc = sqlite3_table_column_metadata(  p->dbMain, "main", pIter->zTbl, zCol, 0, &zColl, 0, 0, 0  );  if( pIter->eType==RBU_PK_IPK && pIter->abTblPk[iCol] ){  zPk = "PRIMARY KEY ";  }  zSql = rbuMPrintf(p, "%z%s\"%w\" %s %sCOLLATE %Q%s",  zSql, zComma, zCol, pIter->azTblType[iCol], zPk, zColl,  (pIter->abNotNull[iCol] ? " NOT NULL" : "")  );  zComma = ", ";  }  if( pIter->eType==RBU_PK_WITHOUT_ROWID ){  char *zPk = rbuWithoutRowidPK(p, pIter);  if( zPk ){  zSql = rbuMPrintf(p, "%z, %z", zSql, zPk);  }  }  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1, tnum);  rbuMPrintfExec(p, p->dbMain, "CREATE TABLE \"rbu_imp_%w\"(%z)%s",  pIter->zTbl, zSql,  (pIter->eType==RBU_PK_WITHOUT_ROWID ? " WITHOUT ROWID" : "")  );  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 0);  } } static void rbuObjIterPrepareTmpInsert(  sqlite3rbu *p,  RbuObjIter *pIter,  const char *zCollist,  const char *zRbuRowid ){  int bRbuRowid = (pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE);  char *zBind = rbuObjIterGetBindlist(p, pIter->nTblCol + 1 + bRbuRowid);  if( zBind ){  assert( pIter->pTmpInsert==0 );  p->rc = prepareFreeAndCollectError(  p->dbRbu, &pIter->pTmpInsert, &p->zErrmsg, sqlite3_mprintf(  "INSERT INTO %s.'rbu_tmp_%q'(rbu_control,%s%s) VALUES(%z)",  p->zStateDb, pIter->zDataTbl, zCollist, zRbuRowid, zBind  ));  } } static void rbuTmpInsertFunc(  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ){  sqlite3rbu *p = sqlite3_user_data(pCtx);  int rc = SQLITE_OK;  int i;  assert( sqlite3_value_int(apVal[0])!=0  || p->objiter.eType==RBU_PK_EXTERNAL  || p->objiter.eType==RBU_PK_NONE  );  if( sqlite3_value_int(apVal[0])!=0 ){  p->nPhaseOneStep += p->objiter.nIndex;  }  for(i=0; rc==SQLITE_OK && i<nVal; i++){  rc = sqlite3_bind_value(p->objiter.pTmpInsert, i+1, apVal[i]);  }  if( rc==SQLITE_OK ){  sqlite3_step(p->objiter.pTmpInsert);  rc = sqlite3_reset(p->objiter.pTmpInsert);  }  if( rc!=SQLITE_OK ){  sqlite3_result_error_code(pCtx, rc);  } } static char *rbuObjIterGetIndexWhere(sqlite3rbu *p, RbuObjIter *pIter){  sqlite3_stmt *pStmt = 0;  int rc = p->rc;  char *zRet = 0;  assert( pIter->zIdxSql==0 && pIter->nIdxCol==0 && pIter->aIdxCol==0 );  if( rc==SQLITE_OK ){  rc = prepareAndCollectError(p->dbMain, &pStmt, &p->zErrmsg,  "SELECT trim(sql) FROM sqlite_schema WHERE type='index' AND name=?"  );  }  if( rc==SQLITE_OK ){  int rc2;  rc = sqlite3_bind_text(pStmt, 1, pIter->zIdx, -1, SQLITE_STATIC);  if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){  char *zSql = (char*)sqlite3_column_text(pStmt, 0);  if( zSql ){  pIter->zIdxSql = zSql = rbuStrndup(zSql, &rc);  }  if( zSql ){  int nParen = 0;  int i;  int iIdxCol = 0;  int nIdxAlloc = 0;  for(i=0; zSql[i]; i++){  char c = zSql[i];  if( iIdxCol==nIdxAlloc ){  RbuSpan *aIdxCol = (RbuSpan*)sqlite3_realloc(  pIter->aIdxCol, (nIdxAlloc+16)*sizeof(RbuSpan)  );  if( aIdxCol==0 ){  rc = SQLITE_NOMEM;  break;  }  pIter->aIdxCol = aIdxCol;  nIdxAlloc += 16;  }  if( c=='(' ){  if( nParen==0 ){  assert( iIdxCol==0 );  pIter->aIdxCol[0].zSpan = &zSql[i+1];  }  nParen++;  }  else if( c==')' ){  nParen--;  if( nParen==0 ){  int nSpan = &zSql[i] - pIter->aIdxCol[iIdxCol].zSpan;  pIter->aIdxCol[iIdxCol++].nSpan = nSpan;  i++;  break;  }  }else if( c==',' && nParen==1 ){  int nSpan = &zSql[i] - pIter->aIdxCol[iIdxCol].zSpan;  pIter->aIdxCol[iIdxCol++].nSpan = nSpan;  pIter->aIdxCol[iIdxCol].zSpan = &zSql[i+1];  }else if( c=='"' || c=='\'' || c=='`' ){  for(i++; 1; i++){  if( zSql[i]==c ){  if( zSql[i+1]!=c ) break;  i++;  }  }  }else if( c=='[' ){  for(i++; 1; i++){  if( zSql[i]==']' ) break;  }  }else if( c=='-' && zSql[i+1]=='-' ){  for(i=i+2; zSql[i] && zSql[i]!='\n'; i++);  if( zSql[i]=='\0' ) break;  }else if( c=='/' && zSql[i+1]=='*' ){  for(i=i+2; zSql[i] && (zSql[i]!='*' || zSql[i+1]!='/'); i++);  if( zSql[i]=='\0' ) break;  i++;  }  }  if( zSql[i] ){  zRet = rbuStrndup(&zSql[i], &rc);  }  pIter->nIdxCol = iIdxCol;  }  }  rc2 = sqlite3_finalize(pStmt);  if( rc==SQLITE_OK ) rc = rc2;  }  p->rc = rc;  return zRet; } static int rbuObjIterPrepareAll(  sqlite3rbu *p,  RbuObjIter *pIter,  int nOffset ){  assert( pIter->bCleanup==0 );  if( pIter->pSelect==0 && rbuObjIterCacheTableInfo(p, pIter)==SQLITE_OK ){  const int tnum = pIter->iTnum;  char *zCollist = 0;  char **pz = &p->zErrmsg;  const char *zIdx = pIter->zIdx;  char *zLimit = 0;  if( nOffset ){  zLimit = sqlite3_mprintf(" LIMIT -1 OFFSET %d", nOffset);  if( !zLimit ) p->rc = SQLITE_NOMEM;  }  if( zIdx ){  const char *zTbl = pIter->zTbl;  char *zImposterCols = 0;  char *zImposterPK = 0;  char *zWhere = 0;  char *zBind = 0;  char *zPart = 0;  int nBind = 0;  assert( pIter->eType!=RBU_PK_VTAB );  zPart = rbuObjIterGetIndexWhere(p, pIter);  zCollist = rbuObjIterGetIndexCols(  p, pIter, &zImposterCols, &zImposterPK, &zWhere, &nBind  );  zBind = rbuObjIterGetBindlist(p, nBind);  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 1);  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 1,tnum);  rbuMPrintfExec(p, p->dbMain,  "CREATE TABLE \"rbu_imp_%w\"( %s, PRIMARY KEY( %s ) ) WITHOUT ROWID",  zTbl, zImposterCols, zImposterPK  );  sqlite3_test_control(SQLITE_TESTCTRL_IMPOSTER, p->dbMain, "main", 0, 0);  pIter->nCol = nBind;  if( p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(  p->dbMain, &pIter->pInsert, &p->zErrmsg,  sqlite3_mprintf("INSERT INTO \"rbu_imp_%w\" VALUES(%s)", zTbl, zBind)  );  }  if( rbuIsVacuum(p)==0 && p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(  p->dbMain, &pIter->pDelete, &p->zErrmsg,  sqlite3_mprintf("DELETE FROM \"rbu_imp_%w\" WHERE %s", zTbl, zWhere)  );  }  if( p->rc==SQLITE_OK ){  char *zSql;  if( rbuIsVacuum(p) ){  char *zStart = 0;  if( nOffset ){  zStart = rbuVacuumIndexStart(p, pIter);  if( zStart ){  sqlite3_free(zLimit);  zLimit = 0;  }  }  zSql = sqlite3_mprintf(  "SELECT %s, 0 AS rbu_control FROM '%q' %s %s %s ORDER BY %s%s",  zCollist,  pIter->zDataTbl,  zPart,  (zStart ? (zPart ? "AND" : "WHERE") : ""), zStart,  zCollist, zLimit  );  sqlite3_free(zStart);  }else  if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){  zSql = sqlite3_mprintf(  "SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' %s ORDER BY %s%s",  zCollist, p->zStateDb, pIter->zDataTbl,  zPart, zCollist, zLimit  );  }else{  zSql = sqlite3_mprintf(  "SELECT %s, rbu_control FROM %s.'rbu_tmp_%q' %s "  "UNION ALL "  "SELECT %s, rbu_control FROM '%q' "  "%s %s typeof(rbu_control)='integer' AND rbu_control!=1 "  "ORDER BY %s%s",  zCollist, p->zStateDb, pIter->zDataTbl, zPart,  zCollist, pIter->zDataTbl,  zPart,  (zPart ? "AND" : "WHERE"),  zCollist, zLimit  );  }  if( p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(p->dbRbu,&pIter->pSelect,pz,zSql);  }else{  sqlite3_free(zSql);  }  }  sqlite3_free(zImposterCols);  sqlite3_free(zImposterPK);  sqlite3_free(zWhere);  sqlite3_free(zBind);  sqlite3_free(zPart);  }else{  int bRbuRowid = (pIter->eType==RBU_PK_VTAB)  ||(pIter->eType==RBU_PK_NONE)  ||(pIter->eType==RBU_PK_EXTERNAL && rbuIsVacuum(p));  const char *zTbl = pIter->zTbl;  const char *zWrite;  char *zBindings = rbuObjIterGetBindlist(p, pIter->nTblCol + bRbuRowid);  char *zWhere = rbuObjIterGetWhere(p, pIter);  char *zOldlist = rbuObjIterGetOldlist(p, pIter, "old");  char *zNewlist = rbuObjIterGetOldlist(p, pIter, "new");  zCollist = rbuObjIterGetCollist(p, pIter);  pIter->nCol = pIter->nTblCol;  rbuCreateImposterTable(p, pIter);  rbuCreateImposterTable2(p, pIter);  zWrite = (pIter->eType==RBU_PK_VTAB ? "" : "rbu_imp_");  if( p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pIter->pInsert, pz,  sqlite3_mprintf(  "INSERT INTO \"%s%w\"(%s%s) VALUES(%s)",  zWrite, zTbl, zCollist, (bRbuRowid ? ", _rowid_" : ""), zBindings  )  );  }  if( rbuIsVacuum(p)==0 && p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(p->dbMain, &pIter->pDelete, pz,  sqlite3_mprintf(  "DELETE FROM \"%s%w\" WHERE %s", zWrite, zTbl, zWhere  )  );  }  if( rbuIsVacuum(p)==0 && pIter->abIndexed ){  const char *zRbuRowid = "";  if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){  zRbuRowid = ", rbu_rowid";  }  rbuMPrintfExec(p, p->dbRbu,  "CREATE TABLE IF NOT EXISTS %s.'rbu_tmp_%q' AS "  "SELECT *%s FROM '%q' WHERE 0;"  , p->zStateDb, pIter->zDataTbl  , (pIter->eType==RBU_PK_EXTERNAL ? ", 0 AS rbu_rowid" : "")  , pIter->zDataTbl  );  rbuMPrintfExec(p, p->dbMain,  "CREATE TEMP TRIGGER rbu_delete_tr BEFORE DELETE ON \"%s%w\" "  "BEGIN "  " SELECT rbu_tmp_insert(3, %s);"  "END;"  "CREATE TEMP TRIGGER rbu_update1_tr BEFORE UPDATE ON \"%s%w\" "  "BEGIN "  " SELECT rbu_tmp_insert(3, %s);"  "END;"  "CREATE TEMP TRIGGER rbu_update2_tr AFTER UPDATE ON \"%s%w\" "  "BEGIN "  " SELECT rbu_tmp_insert(4, %s);"  "END;",  zWrite, zTbl, zOldlist,  zWrite, zTbl, zOldlist,  zWrite, zTbl, zNewlist  );  if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){  rbuMPrintfExec(p, p->dbMain,  "CREATE TEMP TRIGGER rbu_insert_tr AFTER INSERT ON \"%s%w\" "  "BEGIN "  " SELECT rbu_tmp_insert(0, %s);"  "END;",  zWrite, zTbl, zNewlist  );  }  rbuObjIterPrepareTmpInsert(p, pIter, zCollist, zRbuRowid);  }  if( p->rc==SQLITE_OK ){  const char *zRbuRowid = "";  char *zStart = 0;  char *zOrder = 0;  if( bRbuRowid ){  zRbuRowid = rbuIsVacuum(p) ? ",_rowid_ " : ",rbu_rowid";  }  if( rbuIsVacuum(p) ){  if( nOffset ){  zStart = rbuVacuumTableStart(p, pIter, bRbuRowid, zWrite);  if( zStart ){  sqlite3_free(zLimit);  zLimit = 0;  }  }  if( bRbuRowid ){  zOrder = rbuMPrintf(p, "_rowid_");  }else{  zOrder = rbuObjIterGetPkList(p, pIter, "", ", ", "");  }  }  if( p->rc==SQLITE_OK ){  p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,  sqlite3_mprintf(  "SELECT %s,%s rbu_control%s FROM '%q'%s %s %s %s",  zCollist,  (rbuIsVacuum(p) ? "0 AS " : ""),  zRbuRowid,  pIter->zDataTbl, (zStart ? zStart : ""),  (zOrder ? "ORDER BY" : ""), zOrder,  zLimit  )  );  }  sqlite3_free(zStart);  sqlite3_free(zOrder);  }  sqlite3_free(zWhere);  sqlite3_free(zOldlist);  sqlite3_free(zNewlist);  sqlite3_free(zBindings);  }  sqlite3_free(zCollist);  sqlite3_free(zLimit);  }  return p->rc; } static int rbuGetUpdateStmt(  sqlite3rbu *p,  RbuObjIter *pIter,  const char *zMask,  sqlite3_stmt **ppStmt ){  RbuUpdateStmt **pp;  RbuUpdateStmt *pUp = 0;  int nUp = 0;  *ppStmt = 0;  for(pp=&pIter->pRbuUpdate; *pp; pp=&((*pp)->pNext)){  pUp = *pp;  if( strcmp(pUp->zMask, zMask)==0 ){  *pp = pUp->pNext;  pUp->pNext = pIter->pRbuUpdate;  pIter->pRbuUpdate = pUp;  *ppStmt = pUp->pUpdate;  return SQLITE_OK;  }  nUp++;  }  assert( pUp==0 || pUp->pNext==0 );  if( nUp>=SQLITE_RBU_UPDATE_CACHESIZE ){  for(pp=&pIter->pRbuUpdate; *pp!=pUp; pp=&((*pp)->pNext));  *pp = 0;  sqlite3_finalize(pUp->pUpdate);  pUp->pUpdate = 0;  }else{  pUp = (RbuUpdateStmt*)rbuMalloc(p, sizeof(RbuUpdateStmt)+pIter->nTblCol+1);  }  if( pUp ){  char *zWhere = rbuObjIterGetWhere(p, pIter);  char *zSet = rbuObjIterGetSetlist(p, pIter, zMask);  char *zUpdate = 0;  pUp->zMask = (char*)&pUp[1];  memcpy(pUp->zMask, zMask, pIter->nTblCol);  pUp->pNext = pIter->pRbuUpdate;  pIter->pRbuUpdate = pUp;  if( zSet ){  const char *zPrefix = "";  if( pIter->eType!=RBU_PK_VTAB ) zPrefix = "rbu_imp_";  zUpdate = sqlite3_mprintf("UPDATE \"%s%w\" SET %s WHERE %s",  zPrefix, pIter->zTbl, zSet, zWhere  );  p->rc = prepareFreeAndCollectError(  p->dbMain, &pUp->pUpdate, &p->zErrmsg, zUpdate  );  *ppStmt = pUp->pUpdate;  }  sqlite3_free(zWhere);  sqlite3_free(zSet);  }  return p->rc; } static sqlite3 *rbuOpenDbhandle(  sqlite3rbu *p,  const char *zName,  int bUseVfs ){  sqlite3 *db = 0;  if( p->rc==SQLITE_OK ){  const int flags = SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_URI;  p->rc = sqlite3_open_v2(zName, &db, flags, bUseVfs ? p->zVfsName : 0);  if( p->rc ){  p->zErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(db));  sqlite3_close(db);  db = 0;  }  }  return db; } static void rbuFreeState(RbuState *p){  if( p ){  sqlite3_free(p->zTbl);  sqlite3_free(p->zDataTbl);  sqlite3_free(p->zIdx);  sqlite3_free(p);  } } static RbuState *rbuLoadState(sqlite3rbu *p){  RbuState *pRet = 0;  sqlite3_stmt *pStmt = 0;  int rc;  int rc2;  pRet = (RbuState*)rbuMalloc(p, sizeof(RbuState));  if( pRet==0 ) return 0;  rc = prepareFreeAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,  sqlite3_mprintf("SELECT k, v FROM %s.rbu_state", p->zStateDb)  );  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){  switch( sqlite3_column_int(pStmt, 0) ){  case RBU_STATE_STAGE:  pRet->eStage = sqlite3_column_int(pStmt, 1);  if( pRet->eStage!=RBU_STAGE_OAL   && pRet->eStage!=RBU_STAGE_MOVE   && pRet->eStage!=RBU_STAGE_CKPT  ){  p->rc = SQLITE_CORRUPT;  }  break;  case RBU_STATE_TBL:  pRet->zTbl = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);  break;  case RBU_STATE_IDX:  pRet->zIdx = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);  break;  case RBU_STATE_ROW:  pRet->nRow = sqlite3_column_int(pStmt, 1);  break;  case RBU_STATE_PROGRESS:  pRet->nProgress = sqlite3_column_int64(pStmt, 1);  break;  case RBU_STATE_CKPT:  pRet->iWalCksum = sqlite3_column_int64(pStmt, 1);  break;  case RBU_STATE_COOKIE:  pRet->iCookie = (u32)sqlite3_column_int64(pStmt, 1);  break;  case RBU_STATE_OALSZ:  pRet->iOalSz = sqlite3_column_int64(pStmt, 1);  break;  case RBU_STATE_PHASEONESTEP:  pRet->nPhaseOneStep = sqlite3_column_int64(pStmt, 1);  break;  case RBU_STATE_DATATBL:  pRet->zDataTbl = rbuStrndup((char*)sqlite3_column_text(pStmt, 1), &rc);  break;  default:  rc = SQLITE_CORRUPT;  break;  }  }  rc2 = sqlite3_finalize(pStmt);  if( rc==SQLITE_OK ) rc = rc2;  p->rc = rc;  return pRet; } static void rbuOpenDatabase(sqlite3rbu *p, sqlite3 *dbMain, int *pbRetry){  assert( p->rc || (p->dbMain==0 && p->dbRbu==0) );  assert( p->rc || rbuIsVacuum(p) || p->zTarget!=0 );  assert( dbMain==0 || rbuIsVacuum(p)==0 );  p->dbRbu = rbuOpenDbhandle(p, p->zRbu, 1);  p->dbMain = dbMain;  if( p->rc==SQLITE_OK && rbuIsVacuum(p) ){  sqlite3_file_control(p->dbRbu, "main", SQLITE_FCNTL_RBUCNT, (void*)p);  if( p->zState==0 ){  const char *zFile = sqlite3_db_filename(p->dbRbu, "main");  p->zState = rbuMPrintf(p, "file: }  }  if( p->zState ){  rbuMPrintfExec(p, p->dbRbu, "ATTACH %Q AS stat", p->zState);  memcpy(p->zStateDb, "stat", 4);  }else{  memcpy(p->zStateDb, "main", 4);  }
#if 0
 if( p->rc==SQLITE_OK && rbuIsVacuum(p) ){  p->rc = sqlite3_exec(p->dbRbu, "BEGIN", 0, 0, 0);  }
#endif
 rbuMPrintfExec(p, p->dbRbu, RBU_CREATE_STATE, p->zStateDb);
#if 0
 if( rbuIsVacuum(p) ){  if( p->rc==SQLITE_OK ){  int rc2;  int bOk = 0;  sqlite3_stmt *pCnt = 0;  p->rc = prepareAndCollectError(p->dbRbu, &pCnt, &p->zErrmsg,  "SELECT count(*) FROM stat.sqlite_schema"  );  if( p->rc==SQLITE_OK   && sqlite3_step(pCnt)==SQLITE_ROW   && 1==sqlite3_column_int(pCnt, 0)  ){  bOk = 1;  }  rc2 = sqlite3_finalize(pCnt);  if( p->rc==SQLITE_OK ) p->rc = rc2;  if( p->rc==SQLITE_OK && bOk==0 ){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("invalid state database");  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, 0);  }  }  }
#endif
 if( p->rc==SQLITE_OK && rbuIsVacuum(p) ){  int bOpen = 0;  int rc;  p->nRbu = 0;  p->pRbuFd = 0;  rc = sqlite3_file_control(p->dbRbu, "main", SQLITE_FCNTL_RBUCNT, (void*)p);  if( rc!=SQLITE_NOTFOUND ) p->rc = rc;  if( p->eStage>=RBU_STAGE_MOVE ){  bOpen = 1;  }else{  RbuState *pState = rbuLoadState(p);  if( pState ){  bOpen = (pState->eStage>=RBU_STAGE_MOVE);  rbuFreeState(pState);  }  }  if( bOpen ) p->dbMain = rbuOpenDbhandle(p, p->zRbu, p->nRbu<=1);  }  p->eStage = 0;  if( p->rc==SQLITE_OK && p->dbMain==0 ){  if( !rbuIsVacuum(p) ){  p->dbMain = rbuOpenDbhandle(p, p->zTarget, 1);  }else if( p->pRbuFd->pWalFd ){  if( pbRetry ){  p->pRbuFd->bNolock = 0;  sqlite3_close(p->dbRbu);  sqlite3_close(p->dbMain);  p->dbMain = 0;  p->dbRbu = 0;  *pbRetry = 1;  return;  }  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("cannot vacuum wal mode database");  }else{  char *zTarget;  char *zExtra = 0;  if( strlen(p->zRbu)>=5 && 0==memcmp("file:", p->zRbu, 5) ){  zExtra = &p->zRbu[5];  while( *zExtra ){  if( *zExtra++=='?' ) break;  }  if( *zExtra=='\0' ) zExtra = 0;  }  zTarget = sqlite3_mprintf("file:%s-vactmp?rbu_memory=1%s%s",  sqlite3_db_filename(p->dbRbu, "main"),  (zExtra==0 ? "" : "&"), (zExtra==0 ? "" : zExtra)  );  if( zTarget==0 ){  p->rc = SQLITE_NOMEM;  return;  }  p->dbMain = rbuOpenDbhandle(p, zTarget, p->nRbu<=1);  sqlite3_free(zTarget);  }  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_create_function(p->dbMain,  "rbu_tmp_insert", -1, SQLITE_UTF8, (void*)p, rbuTmpInsertFunc, 0, 0  );  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_create_function(p->dbMain,  "rbu_fossil_delta", 2, SQLITE_UTF8, 0, rbuFossilDeltaFunc, 0, 0  );  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_create_function(p->dbRbu,  "rbu_target_name", -1, SQLITE_UTF8, (void*)p, rbuTargetNameFunc, 0, 0  );  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_file_control(p->dbMain, "main", SQLITE_FCNTL_RBU, (void*)p);  }  rbuMPrintfExec(p, p->dbMain, "SELECT * FROM sqlite_schema");  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_file_control(p->dbMain, "main", SQLITE_FCNTL_RBU, (void*)p);  }  if( p->rc==SQLITE_NOTFOUND ){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("rbu vfs not found");  } } static void rbuFileSuffix3(const char *zBase, char *z){
#ifdef SQLITE_ENABLE_8_3_NAMES
#if SQLITE_ENABLE_8_3_NAMES<2
 if( sqlite3_uri_boolean(zBase, "8_3_names", 0) )
#endif
 {  int i, sz;  sz = (int)strlen(z)&0xffffff;  for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}  if( z[i]=='.' && sz>i+4 ) memmove(&z[i+1], &z[sz-3], 4);  }
#endif
} static i64 rbuShmChecksum(sqlite3rbu *p){  i64 iRet = 0;  if( p->rc==SQLITE_OK ){  sqlite3_file *pDb = p->pTargetFd->pReal;  u32 volatile *ptr;  p->rc = pDb->pMethods->xShmMap(pDb, 0, 32*1024, 0, (void volatile**)&ptr);  if( p->rc==SQLITE_OK ){  iRet = ((i64)ptr[10] << 32) + ptr[11];  }  }  return iRet; } static void rbuSetupCheckpoint(sqlite3rbu *p, RbuState *pState){  if( pState==0 ){  p->eStage = 0;  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_exec(p->dbMain, "SELECT * FROM sqlite_schema", 0, 0, 0);  }  }  if( p->rc==SQLITE_OK ){  int rc2;  p->eStage = RBU_STAGE_CAPTURE;  rc2 = sqlite3_exec(p->dbMain, "PRAGMA main.wal_checkpoint=restart", 0, 0,0);  if( rc2!=SQLITE_INTERNAL ) p->rc = rc2;  }  if( p->rc==SQLITE_OK && p->nFrame>0 ){  p->eStage = RBU_STAGE_CKPT;  p->nStep = (pState ? pState->nRow : 0);  p->aBuf = rbuMalloc(p, p->pgsz);  p->iWalCksum = rbuShmChecksum(p);  }  if( p->rc==SQLITE_OK ){  if( p->nFrame==0 || (pState && pState->iWalCksum!=p->iWalCksum) ){  p->rc = SQLITE_DONE;  p->eStage = RBU_STAGE_DONE;  }else{  int nSectorSize;  sqlite3_file *pDb = p->pTargetFd->pReal;  sqlite3_file *pWal = p->pTargetFd->pWalFd->pReal;  assert( p->nPagePerSector==0 );  nSectorSize = pDb->pMethods->xSectorSize(pDb);  if( nSectorSize>p->pgsz ){  p->nPagePerSector = nSectorSize / p->pgsz;  }else{  p->nPagePerSector = 1;  }  p->rc = pWal->pMethods->xSync(pWal, SQLITE_SYNC_NORMAL);  }  } } static int rbuCaptureWalRead(sqlite3rbu *pRbu, i64 iOff, int iAmt){  const u32 mReq = (1<<WAL_LOCK_WRITE)|(1<<WAL_LOCK_CKPT)|(1<<WAL_LOCK_READ0);  u32 iFrame;  if( pRbu->mLock!=mReq ){  pRbu->rc = SQLITE_BUSY;  return SQLITE_INTERNAL;  }  pRbu->pgsz = iAmt;  if( pRbu->nFrame==pRbu->nFrameAlloc ){  int nNew = (pRbu->nFrameAlloc ? pRbu->nFrameAlloc : 64) * 2;  RbuFrame *aNew;  aNew = (RbuFrame*)sqlite3_realloc64(pRbu->aFrame, nNew * sizeof(RbuFrame));  if( aNew==0 ) return SQLITE_NOMEM;  pRbu->aFrame = aNew;  pRbu->nFrameAlloc = nNew;  }  iFrame = (u32)((iOff-32) / (i64)(iAmt+24)) + 1;  if( pRbu->iMaxFrame<iFrame ) pRbu->iMaxFrame = iFrame;  pRbu->aFrame[pRbu->nFrame].iWalFrame = iFrame;  pRbu->aFrame[pRbu->nFrame].iDbPage = 0;  pRbu->nFrame++;  return SQLITE_OK; } static int rbuCaptureDbWrite(sqlite3rbu *pRbu, i64 iOff){  pRbu->aFrame[pRbu->nFrame-1].iDbPage = (u32)(iOff / pRbu->pgsz) + 1;  return SQLITE_OK; } static void rbuCheckpointFrame(sqlite3rbu *p, RbuFrame *pFrame){  sqlite3_file *pWal = p->pTargetFd->pWalFd->pReal;  sqlite3_file *pDb = p->pTargetFd->pReal;  i64 iOff;  assert( p->rc==SQLITE_OK );  iOff = (i64)(pFrame->iWalFrame-1) * (p->pgsz + 24) + 32 + 24;  p->rc = pWal->pMethods->xRead(pWal, p->aBuf, p->pgsz, iOff);  if( p->rc ) return;  iOff = (i64)(pFrame->iDbPage-1) * p->pgsz;  p->rc = pDb->pMethods->xWrite(pDb, p->aBuf, p->pgsz, iOff); } static int rbuLockDatabase(sqlite3 *db){  int rc = SQLITE_OK;  sqlite3_file *fd = 0;  sqlite3_file_control(db, "main", SQLITE_FCNTL_FILE_POINTER, &fd);  if( fd->pMethods ){  rc = fd->pMethods->xLock(fd, SQLITE_LOCK_SHARED);  if( rc==SQLITE_OK ){  rc = fd->pMethods->xLock(fd, SQLITE_LOCK_EXCLUSIVE);  }  }  return rc; } static int rbuExclusiveCheckpoint(sqlite3 *db){  const char *zUri = sqlite3_db_filename(db, 0);  return sqlite3_uri_boolean(zUri, RBU_EXCLUSIVE_CHECKPOINT, 0); }
#if defined(_WIN32_WCE)
static LPWSTR rbuWinUtf8ToUnicode(const char *zFilename){  int nChar;  LPWSTR zWideFilename;  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);  if( nChar==0 ){  return 0;  }  zWideFilename = sqlite3_malloc64( nChar*sizeof(zWideFilename[0]) );  if( zWideFilename==0 ){  return 0;  }  memset(zWideFilename, 0, nChar*sizeof(zWideFilename[0]));  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename,  nChar);  if( nChar==0 ){  sqlite3_free(zWideFilename);  zWideFilename = 0;  }  return zWideFilename; }
#endif
static void rbuMoveOalFile(sqlite3rbu *p){  const char *zBase = sqlite3_db_filename(p->dbMain, "main");  const char *zMove = zBase;  char *zOal;  char *zWal;  if( rbuIsVacuum(p) ){  zMove = sqlite3_db_filename(p->dbRbu, "main");  }  zOal = sqlite3_mprintf("%s-oal", zMove);  zWal = sqlite3_mprintf("%s-wal", zMove);  assert( p->eStage==RBU_STAGE_MOVE );  assert( p->rc==SQLITE_OK && p->zErrmsg==0 );  if( zWal==0 || zOal==0 ){  p->rc = SQLITE_NOMEM;  }else{  sqlite3 *dbMain = 0;  rbuFileSuffix3(zBase, zWal);  rbuFileSuffix3(zBase, zOal);  rbuObjIterFinalize(&p->objiter);  sqlite3_close(p->dbRbu);  sqlite3_close(p->dbMain);  p->dbMain = 0;  p->dbRbu = 0;  dbMain = rbuOpenDbhandle(p, p->zTarget, 1);  if( dbMain ){  assert( p->rc==SQLITE_OK );  p->rc = rbuLockDatabase(dbMain);  }  if( p->rc==SQLITE_OK ){
#if defined(_WIN32_WCE)
 {  LPWSTR zWideOal;  LPWSTR zWideWal;  zWideOal = rbuWinUtf8ToUnicode(zOal);  if( zWideOal ){  zWideWal = rbuWinUtf8ToUnicode(zWal);  if( zWideWal ){  if( MoveFileW(zWideOal, zWideWal) ){  p->rc = SQLITE_OK;  }else{  p->rc = SQLITE_IOERR;  }  sqlite3_free(zWideWal);  }else{  p->rc = SQLITE_IOERR_NOMEM;  }  sqlite3_free(zWideOal);  }else{  p->rc = SQLITE_IOERR_NOMEM;  }  }
#else
 p->rc = rename(zOal, zWal) ? SQLITE_IOERR : SQLITE_OK;
#endif
 }  if( p->rc!=SQLITE_OK   || rbuIsVacuum(p)   || rbuExclusiveCheckpoint(dbMain)==0  ){  sqlite3_close(dbMain);  dbMain = 0;  }  if( p->rc==SQLITE_OK ){  rbuOpenDatabase(p, dbMain, 0);  rbuSetupCheckpoint(p, 0);  }  }  sqlite3_free(zWal);  sqlite3_free(zOal); } static int rbuStepType(sqlite3rbu *p, const char **pzMask){  int iCol = p->objiter.nCol;  int res = 0;  switch( sqlite3_column_type(p->objiter.pSelect, iCol) ){  case SQLITE_INTEGER: {  int iVal = sqlite3_column_int(p->objiter.pSelect, iCol);  switch( iVal ){  case 0: res = RBU_INSERT;  break;  case 1: res = RBU_DELETE;  break;  case 2: res = RBU_REPLACE; break;  case 3: res = RBU_IDX_DELETE; break;  case 4: res = RBU_IDX_INSERT; break;  }  break;  }  case SQLITE_TEXT: {  const unsigned char *z = sqlite3_column_text(p->objiter.pSelect, iCol);  if( z==0 ){  p->rc = SQLITE_NOMEM;  }else{  *pzMask = (const char*)z;  }  res = RBU_UPDATE;  break;  }  default:  break;  }  if( res==0 ){  rbuBadControlError(p);  }  return res; }
#ifdef SQLITE_DEBUG
static void assertColumnName(sqlite3_stmt *pStmt, int iCol, const char *zName){  const char *zCol = sqlite3_column_name(pStmt, iCol);  assert( 0==sqlite3_stricmp(zName, zCol) ); }
#else
# define assertColumnName(x,y,z)
#endif
static void rbuStepOneOp(sqlite3rbu *p, int eType){  RbuObjIter *pIter = &p->objiter;  sqlite3_value *pVal;  sqlite3_stmt *pWriter;  int i;  assert( p->rc==SQLITE_OK );  assert( eType!=RBU_DELETE || pIter->zIdx==0 );  assert( eType==RBU_DELETE || eType==RBU_IDX_DELETE   || eType==RBU_INSERT || eType==RBU_IDX_INSERT  );  if( eType==RBU_DELETE ){  p->nPhaseOneStep -= p->objiter.nIndex;  }  if( eType==RBU_IDX_DELETE || eType==RBU_DELETE ){  pWriter = pIter->pDelete;  }else{  pWriter = pIter->pInsert;  }  for(i=0; i<pIter->nCol; i++){  if( eType==RBU_INSERT   && pIter->zIdx==0 && pIter->eType==RBU_PK_IPK && pIter->abTblPk[i]   && sqlite3_column_type(pIter->pSelect, i)==SQLITE_NULL  ){  p->rc = SQLITE_MISMATCH;  p->zErrmsg = sqlite3_mprintf("datatype mismatch");  return;  }  if( eType==RBU_DELETE && pIter->abTblPk[i]==0 ){  continue;  }  pVal = sqlite3_column_value(pIter->pSelect, i);  p->rc = sqlite3_bind_value(pWriter, i+1, pVal);  if( p->rc ) return;  }  if( pIter->zIdx==0 ){  if( pIter->eType==RBU_PK_VTAB   || pIter->eType==RBU_PK_NONE   || (pIter->eType==RBU_PK_EXTERNAL && rbuIsVacuum(p))  ){  assertColumnName(pIter->pSelect, pIter->nCol+1,  rbuIsVacuum(p) ? "rowid" : "rbu_rowid"  );  pVal = sqlite3_column_value(pIter->pSelect, pIter->nCol+1);  p->rc = sqlite3_bind_value(pWriter, pIter->nCol+1, pVal);  }  }  if( p->rc==SQLITE_OK ){  sqlite3_step(pWriter);  p->rc = resetAndCollectError(pWriter, &p->zErrmsg);  } } static int rbuStep(sqlite3rbu *p){  RbuObjIter *pIter = &p->objiter;  const char *zMask = 0;  int eType = rbuStepType(p, &zMask);  if( eType ){  assert( eType==RBU_INSERT  || eType==RBU_DELETE   || eType==RBU_REPLACE || eType==RBU_IDX_DELETE   || eType==RBU_IDX_INSERT || eType==RBU_UPDATE  );  assert( eType!=RBU_UPDATE || pIter->zIdx==0 );  if( pIter->zIdx==0 && (eType==RBU_IDX_DELETE || eType==RBU_IDX_INSERT) ){  rbuBadControlError(p);  }  else if( eType==RBU_REPLACE ){  if( pIter->zIdx==0 ){  p->nPhaseOneStep += p->objiter.nIndex;  rbuStepOneOp(p, RBU_DELETE);  }  if( p->rc==SQLITE_OK ) rbuStepOneOp(p, RBU_INSERT);  }  else if( eType!=RBU_UPDATE ){  rbuStepOneOp(p, eType);  }  else{  sqlite3_value *pVal;  sqlite3_stmt *pUpdate = 0;  assert( eType==RBU_UPDATE );  p->nPhaseOneStep -= p->objiter.nIndex;  rbuGetUpdateStmt(p, pIter, zMask, &pUpdate);  if( pUpdate ){  int i;  for(i=0; p->rc==SQLITE_OK && i<pIter->nCol; i++){  char c = zMask[pIter->aiSrcOrder[i]];  pVal = sqlite3_column_value(pIter->pSelect, i);  if( pIter->abTblPk[i] || c!='.' ){  p->rc = sqlite3_bind_value(pUpdate, i+1, pVal);  }  }  if( p->rc==SQLITE_OK   && (pIter->eType==RBU_PK_VTAB || pIter->eType==RBU_PK_NONE)  ){  assertColumnName(pIter->pSelect, pIter->nCol+1, "rbu_rowid");  pVal = sqlite3_column_value(pIter->pSelect, pIter->nCol+1);  p->rc = sqlite3_bind_value(pUpdate, pIter->nCol+1, pVal);  }  if( p->rc==SQLITE_OK ){  sqlite3_step(pUpdate);  p->rc = resetAndCollectError(pUpdate, &p->zErrmsg);  }  }  }  }  return p->rc; } static void rbuIncrSchemaCookie(sqlite3rbu *p){  if( p->rc==SQLITE_OK ){  sqlite3 *dbread = (rbuIsVacuum(p) ? p->dbRbu : p->dbMain);  int iCookie = 1000000;  sqlite3_stmt *pStmt;  p->rc = prepareAndCollectError(dbread, &pStmt, &p->zErrmsg,  "PRAGMA schema_version"  );  if( p->rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  iCookie = sqlite3_column_int(pStmt, 0);  }  rbuFinalize(p, pStmt);  }  if( p->rc==SQLITE_OK ){  rbuMPrintfExec(p, p->dbMain, "PRAGMA schema_version = %d", iCookie+1);  }  } } static void rbuSaveState(sqlite3rbu *p, int eStage){  if( p->rc==SQLITE_OK || p->rc==SQLITE_DONE ){  sqlite3_stmt *pInsert = 0;  rbu_file *pFd = (rbuIsVacuum(p) ? p->pRbuFd : p->pTargetFd);  int rc;  assert( p->zErrmsg==0 );  rc = prepareFreeAndCollectError(p->dbRbu, &pInsert, &p->zErrmsg,  sqlite3_mprintf(  "INSERT OR REPLACE INTO %s.rbu_state(k, v) VALUES "  "(%d, %d), "  "(%d, %Q), "  "(%d, %Q), "  "(%d, %d), "  "(%d, %d), "  "(%d, %lld), "  "(%d, %lld), "  "(%d, %lld), "  "(%d, %lld), "  "(%d, %Q) ",  p->zStateDb,  RBU_STATE_STAGE, eStage,  RBU_STATE_TBL, p->objiter.zTbl,  RBU_STATE_IDX, p->objiter.zIdx,  RBU_STATE_ROW, p->nStep,  RBU_STATE_PROGRESS, p->nProgress,  RBU_STATE_CKPT, p->iWalCksum,  RBU_STATE_COOKIE, (i64)pFd->iCookie,  RBU_STATE_OALSZ, p->iOalSz,  RBU_STATE_PHASEONESTEP, p->nPhaseOneStep,  RBU_STATE_DATATBL, p->objiter.zDataTbl  )  );  assert( pInsert==0 || rc==SQLITE_OK );  if( rc==SQLITE_OK ){  sqlite3_step(pInsert);  rc = sqlite3_finalize(pInsert);  }  if( rc!=SQLITE_OK ) p->rc = rc;  } } static void rbuCopyPragma(sqlite3rbu *p, const char *zPragma){  if( p->rc==SQLITE_OK ){  sqlite3_stmt *pPragma = 0;  p->rc = prepareFreeAndCollectError(p->dbRbu, &pPragma, &p->zErrmsg,  sqlite3_mprintf("PRAGMA main.%s", zPragma)  );  if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pPragma) ){  p->rc = rbuMPrintfExec(p, p->dbMain, "PRAGMA main.%s = %d",  zPragma, sqlite3_column_int(pPragma, 0)  );  }  rbuFinalize(p, pPragma);  } } static void rbuCreateTargetSchema(sqlite3rbu *p){  sqlite3_stmt *pSql = 0;  sqlite3_stmt *pInsert = 0;  assert( rbuIsVacuum(p) );  p->rc = sqlite3_exec(p->dbMain, "PRAGMA writable_schema=1", 0,0, &p->zErrmsg);  if( p->rc==SQLITE_OK ){  p->rc = prepareAndCollectError(p->dbRbu, &pSql, &p->zErrmsg,  "SELECT sql FROM sqlite_schema WHERE sql!='' AND rootpage!=0"  " AND name!='sqlite_sequence' "  " ORDER BY type DESC"  );  }  while( p->rc==SQLITE_OK && sqlite3_step(pSql)==SQLITE_ROW ){  const char *zSql = (const char*)sqlite3_column_text(pSql, 0);  p->rc = sqlite3_exec(p->dbMain, zSql, 0, 0, &p->zErrmsg);  }  rbuFinalize(p, pSql);  if( p->rc!=SQLITE_OK ) return;  if( p->rc==SQLITE_OK ){  p->rc = prepareAndCollectError(p->dbRbu, &pSql, &p->zErrmsg,  "SELECT * FROM sqlite_schema WHERE rootpage=0 OR rootpage IS NULL"  );  }  if( p->rc==SQLITE_OK ){  p->rc = prepareAndCollectError(p->dbMain, &pInsert, &p->zErrmsg,  "INSERT INTO sqlite_schema VALUES(?,?,?,?,?)"  );  }  while( p->rc==SQLITE_OK && sqlite3_step(pSql)==SQLITE_ROW ){  int i;  for(i=0; i<5; i++){  sqlite3_bind_value(pInsert, i+1, sqlite3_column_value(pSql, i));  }  sqlite3_step(pInsert);  p->rc = sqlite3_reset(pInsert);  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_exec(p->dbMain, "PRAGMA writable_schema=0",0,0,&p->zErrmsg);  }  rbuFinalize(p, pSql);  rbuFinalize(p, pInsert); } SQLITE_API int sqlite3rbu_step(sqlite3rbu *p){  if( p ){  switch( p->eStage ){  case RBU_STAGE_OAL: {  RbuObjIter *pIter = &p->objiter;  if( rbuIsVacuum(p) && p->nProgress==0 && p->rc==SQLITE_OK ){  rbuCreateTargetSchema(p);  rbuCopyPragma(p, "user_version");  rbuCopyPragma(p, "application_id");  }  while( p->rc==SQLITE_OK && pIter->zTbl ){  if( pIter->bCleanup ){  if( rbuIsVacuum(p)==0 && pIter->abIndexed ){  rbuMPrintfExec(p, p->dbRbu,  "DELETE FROM %s.'rbu_tmp_%q'", p->zStateDb, pIter->zDataTbl  );  }  }else{  rbuObjIterPrepareAll(p, pIter, 0);  if( p->rc==SQLITE_OK ){  int rc = sqlite3_step(pIter->pSelect);  if( rc==SQLITE_ROW ){  p->nProgress++;  p->nStep++;  return rbuStep(p);  }  p->rc = sqlite3_reset(pIter->pSelect);  p->nStep = 0;  }  }  rbuObjIterNext(p, pIter);  }  if( p->rc==SQLITE_OK ){  assert( pIter->zTbl==0 );  rbuSaveState(p, RBU_STAGE_MOVE);  rbuIncrSchemaCookie(p);  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, &p->zErrmsg);  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, &p->zErrmsg);  }  p->eStage = RBU_STAGE_MOVE;  }  break;  }  case RBU_STAGE_MOVE: {  if( p->rc==SQLITE_OK ){  rbuMoveOalFile(p);  p->nProgress++;  }  break;  }  case RBU_STAGE_CKPT: {  if( p->rc==SQLITE_OK ){  if( p->nStep>=p->nFrame ){  sqlite3_file *pDb = p->pTargetFd->pReal;  p->rc = pDb->pMethods->xSync(pDb, SQLITE_SYNC_NORMAL);  if( p->rc==SQLITE_OK ){  void volatile *ptr;  p->rc = pDb->pMethods->xShmMap(pDb, 0, 32*1024, 0, &ptr);  if( p->rc==SQLITE_OK ){  ((u32 volatile*)ptr)[24] = p->iMaxFrame;  }  }  if( p->rc==SQLITE_OK ){  p->eStage = RBU_STAGE_DONE;  p->rc = SQLITE_DONE;  }  }else{  u32 iSector;  do{  RbuFrame *pFrame = &p->aFrame[p->nStep];  iSector = (pFrame->iDbPage-1) / p->nPagePerSector;  rbuCheckpointFrame(p, pFrame);  p->nStep++;  }while( p->nStep<p->nFrame   && iSector==((p->aFrame[p->nStep].iDbPage-1) / p->nPagePerSector)   && p->rc==SQLITE_OK  );  }  p->nProgress++;  }  break;  }  default:  break;  }  return p->rc;  }else{  return SQLITE_NOMEM;  } } static int rbuStrCompare(const char *z1, const char *z2){  if( z1==0 && z2==0 ) return 0;  if( z1==0 || z2==0 ) return 1;  return (sqlite3_stricmp(z1, z2)!=0); } static void rbuSetupOal(sqlite3rbu *p, RbuState *pState){  assert( p->rc==SQLITE_OK );  if( pState->zTbl ){  RbuObjIter *pIter = &p->objiter;  int rc = SQLITE_OK;  while( rc==SQLITE_OK && pIter->zTbl && (pIter->bCleanup   || rbuStrCompare(pIter->zIdx, pState->zIdx)   || (pState->zDataTbl==0 && rbuStrCompare(pIter->zTbl, pState->zTbl))   || (pState->zDataTbl && rbuStrCompare(pIter->zDataTbl, pState->zDataTbl))  )){  rc = rbuObjIterNext(p, pIter);  }  if( rc==SQLITE_OK && !pIter->zTbl ){  rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("rbu_state mismatch error");  }  if( rc==SQLITE_OK ){  p->nStep = pState->nRow;  rc = rbuObjIterPrepareAll(p, &p->objiter, p->nStep);  }  p->rc = rc;  } } static void rbuDeleteOalFile(sqlite3rbu *p){  char *zOal = rbuMPrintf(p, "%s-oal", p->zTarget);  if( zOal ){  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);  assert( pVfs && p->rc==SQLITE_OK && p->zErrmsg==0 );  pVfs->xDelete(pVfs, zOal, 0);  sqlite3_free(zOal);  } } static void rbuCreateVfs(sqlite3rbu *p){  int rnd;  char zRnd[64];  assert( p->rc==SQLITE_OK );  sqlite3_randomness(sizeof(int), (void*)&rnd);  sqlite3_snprintf(sizeof(zRnd), zRnd, "rbu_vfs_%d", rnd);  p->rc = sqlite3rbu_create_vfs(zRnd, 0);  if( p->rc==SQLITE_OK ){  sqlite3_vfs *pVfs = sqlite3_vfs_find(zRnd);  assert( pVfs );  p->zVfsName = pVfs->zName;  ((rbu_vfs*)pVfs)->pRbu = p;  } } static void rbuDeleteVfs(sqlite3rbu *p){  if( p->zVfsName ){  sqlite3rbu_destroy_vfs(p->zVfsName);  p->zVfsName = 0;  } } static void rbuIndexCntFunc(  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ){  sqlite3rbu *p = (sqlite3rbu*)sqlite3_user_data(pCtx);  sqlite3_stmt *pStmt = 0;  char *zErrmsg = 0;  int rc;  sqlite3 *db = (rbuIsVacuum(p) ? p->dbRbu : p->dbMain);  assert( nVal==1 );  rc = prepareFreeAndCollectError(db, &pStmt, &zErrmsg,  sqlite3_mprintf("SELECT count(*) FROM sqlite_schema "  "WHERE type='index' AND tbl_name = %Q", sqlite3_value_text(apVal[0]))  );  if( rc!=SQLITE_OK ){  sqlite3_result_error(pCtx, zErrmsg, -1);  }else{  int nIndex = 0;  if( SQLITE_ROW==sqlite3_step(pStmt) ){  nIndex = sqlite3_column_int(pStmt, 0);  }  rc = sqlite3_finalize(pStmt);  if( rc==SQLITE_OK ){  sqlite3_result_int(pCtx, nIndex);  }else{  sqlite3_result_error(pCtx, sqlite3_errmsg(db), -1);  }  }  sqlite3_free(zErrmsg); } static void rbuInitPhaseOneSteps(sqlite3rbu *p){  if( p->rc==SQLITE_OK ){  sqlite3_stmt *pStmt = 0;  int bExists = 0;  p->nPhaseOneStep = -1;  p->rc = sqlite3_create_function(p->dbRbu,  "rbu_index_cnt", 1, SQLITE_UTF8, (void*)p, rbuIndexCntFunc, 0, 0  );  if( p->rc==SQLITE_OK ){  p->rc = prepareAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,  "SELECT 1 FROM sqlite_schema WHERE tbl_name = 'rbu_count'"  );  }  if( p->rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  bExists = 1;  }  p->rc = sqlite3_finalize(pStmt);  }  if( p->rc==SQLITE_OK && bExists ){  p->rc = prepareAndCollectError(p->dbRbu, &pStmt, &p->zErrmsg,  "SELECT sum(cnt * (1 + rbu_index_cnt(rbu_target_name(tbl))))"  "FROM rbu_count"  );  if( p->rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  p->nPhaseOneStep = sqlite3_column_int64(pStmt, 0);  }  p->rc = sqlite3_finalize(pStmt);  }  }  } } static sqlite3rbu *openRbuHandle(  const char *zTarget,  const char *zRbu,  const char *zState ){  sqlite3rbu *p;  size_t nTarget = zTarget ? strlen(zTarget) : 0;  size_t nRbu = strlen(zRbu);  size_t nByte = sizeof(sqlite3rbu) + nTarget+1 + nRbu+1;  p = (sqlite3rbu*)sqlite3_malloc64(nByte);  if( p ){  RbuState *pState = 0;  memset(p, 0, sizeof(sqlite3rbu));  rbuCreateVfs(p);  if( p->rc==SQLITE_OK ){  char *pCsr = (char*)&p[1];  int bRetry = 0;  if( zTarget ){  p->zTarget = pCsr;  memcpy(p->zTarget, zTarget, nTarget+1);  pCsr += nTarget+1;  }  p->zRbu = pCsr;  memcpy(p->zRbu, zRbu, nRbu+1);  pCsr += nRbu+1;  if( zState ){  p->zState = rbuMPrintf(p, "%s", zState);  }  rbuOpenDatabase(p, 0, &bRetry);  if( bRetry ){  rbuOpenDatabase(p, 0, 0);  }  }  if( p->rc==SQLITE_OK ){  pState = rbuLoadState(p);  assert( pState || p->rc!=SQLITE_OK );  if( p->rc==SQLITE_OK ){  if( pState->eStage==0 ){  rbuDeleteOalFile(p);  rbuInitPhaseOneSteps(p);  p->eStage = RBU_STAGE_OAL;  }else{  p->eStage = pState->eStage;  p->nPhaseOneStep = pState->nPhaseOneStep;  }  p->nProgress = pState->nProgress;  p->iOalSz = pState->iOalSz;  }  }  assert( p->rc!=SQLITE_OK || p->eStage!=0 );  if( p->rc==SQLITE_OK && p->pTargetFd->pWalFd ){  if( p->eStage==RBU_STAGE_OAL ){  p->rc = SQLITE_ERROR;  p->zErrmsg = sqlite3_mprintf("cannot update wal mode database");  }else if( p->eStage==RBU_STAGE_MOVE ){  p->eStage = RBU_STAGE_CKPT;  p->nStep = 0;  }  }  if( p->rc==SQLITE_OK   && (p->eStage==RBU_STAGE_OAL || p->eStage==RBU_STAGE_MOVE)   && pState->eStage!=0  ){  rbu_file *pFd = (rbuIsVacuum(p) ? p->pRbuFd : p->pTargetFd);  if( pFd->iCookie!=pState->iCookie ){  p->rc = SQLITE_BUSY;  p->zErrmsg = sqlite3_mprintf("database modified during rbu %s",  (rbuIsVacuum(p) ? "vacuum" : "update")  );  }  }  if( p->rc==SQLITE_OK ){  if( p->eStage==RBU_STAGE_OAL ){  sqlite3 *db = p->dbMain;  p->rc = sqlite3_exec(p->dbRbu, "BEGIN", 0, 0, &p->zErrmsg);  if( p->rc==SQLITE_OK ){  p->rc = rbuObjIterFirst(p, &p->objiter);  }  if( p->rc==SQLITE_OK && p->objiter.zTbl==0 ){  p->rc = SQLITE_DONE;  p->eStage = RBU_STAGE_DONE;  }else{  if( p->rc==SQLITE_OK && pState->eStage==0 && rbuIsVacuum(p) ){  rbuCopyPragma(p, "page_size");  rbuCopyPragma(p, "auto_vacuum");  }  if( p->rc==SQLITE_OK ){  p->rc = sqlite3_exec(db, "BEGIN IMMEDIATE", 0, 0, &p->zErrmsg);  }  if( p->rc==SQLITE_OK ){  int frc = sqlite3_file_control(db, "main", SQLITE_FCNTL_ZIPVFS, 0);  if( frc==SQLITE_OK ){  p->rc = sqlite3_exec(  db, "PRAGMA journal_mode=off",0,0,&p->zErrmsg);  }  }  if( p->rc==SQLITE_OK ){  rbuSetupOal(p, pState);  }  }  }else if( p->eStage==RBU_STAGE_MOVE ){  }else if( p->eStage==RBU_STAGE_CKPT ){  if( !rbuIsVacuum(p) && rbuExclusiveCheckpoint(p->dbMain) ){  p->eStage = RBU_STAGE_DONE;  rbuLockDatabase(p->dbMain);  p->eStage = RBU_STAGE_CKPT;  }  rbuSetupCheckpoint(p, pState);  }else if( p->eStage==RBU_STAGE_DONE ){  p->rc = SQLITE_DONE;  }else{  p->rc = SQLITE_CORRUPT;  }  }  rbuFreeState(pState);  }  return p; } static sqlite3rbu *rbuMisuseError(void){  sqlite3rbu *pRet;  pRet = sqlite3_malloc64(sizeof(sqlite3rbu));  if( pRet ){  memset(pRet, 0, sizeof(sqlite3rbu));  pRet->rc = SQLITE_MISUSE;  }  return pRet; } SQLITE_API sqlite3rbu *sqlite3rbu_open(  const char *zTarget,  const char *zRbu,  const char *zState ){  if( zTarget==0 || zRbu==0 ){ return rbuMisuseError(); }  return openRbuHandle(zTarget, zRbu, zState); } SQLITE_API sqlite3rbu *sqlite3rbu_vacuum(  const char *zTarget,  const char *zState ){  if( zTarget==0 ){ return rbuMisuseError(); }  if( zState ){  int n = strlen(zState);  if( n>=7 && 0==memcmp("-vactmp", &zState[n-7], 7) ){  return rbuMisuseError();  }  }  return openRbuHandle(0, zTarget, zState); } SQLITE_API sqlite3 *sqlite3rbu_db(sqlite3rbu *pRbu, int bRbu){  sqlite3 *db = 0;  if( pRbu ){  db = (bRbu ? pRbu->dbRbu : pRbu->dbMain);  }  return db; } static void rbuEditErrmsg(sqlite3rbu *p){  if( p->rc==SQLITE_CONSTRAINT && p->zErrmsg ){  unsigned int i;  size_t nErrmsg = strlen(p->zErrmsg);  for(i=0; i<(nErrmsg-8); i++){  if( memcmp(&p->zErrmsg[i], "rbu_imp_", 8)==0 ){  int nDel = 8;  while( p->zErrmsg[i+nDel]>='0' && p->zErrmsg[i+nDel]<='9' ) nDel++;  memmove(&p->zErrmsg[i], &p->zErrmsg[i+nDel], nErrmsg + 1 - i - nDel);  nErrmsg -= nDel;  }  }  } } SQLITE_API int sqlite3rbu_close(sqlite3rbu *p, char **pzErrmsg){  int rc;  if( p ){  if( p->rc==SQLITE_OK && p->eStage==RBU_STAGE_OAL ){  p->rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, &p->zErrmsg);  }  if( p->rc==SQLITE_OK && p->eStage==RBU_STAGE_CKPT ){  sqlite3_file *pDb = p->pTargetFd->pReal;  p->rc = pDb->pMethods->xSync(pDb, SQLITE_SYNC_NORMAL);  }  rbuSaveState(p, p->eStage);  if( p->rc==SQLITE_OK && p->eStage==RBU_STAGE_OAL ){  p->rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, &p->zErrmsg);  }  rbuObjIterFinalize(&p->objiter);  if( rbuIsVacuum(p) && p->rc!=SQLITE_OK && p->dbRbu ){  int rc2 = sqlite3_exec(p->dbRbu, "DELETE FROM stat.rbu_state", 0, 0, 0);  if( p->rc==SQLITE_DONE && rc2!=SQLITE_OK ) p->rc = rc2;  }  sqlite3_close(p->dbRbu);  sqlite3_close(p->dbMain);  assert( p->szTemp==0 );  rbuDeleteVfs(p);  sqlite3_free(p->aBuf);  sqlite3_free(p->aFrame);  rbuEditErrmsg(p);  rc = p->rc;  if( pzErrmsg ){  *pzErrmsg = p->zErrmsg;  }else{  sqlite3_free(p->zErrmsg);  }  sqlite3_free(p->zState);  sqlite3_free(p);  }else{  rc = SQLITE_NOMEM;  *pzErrmsg = 0;  }  return rc; } SQLITE_API sqlite3_int64 sqlite3rbu_progress(sqlite3rbu *pRbu){  return pRbu->nProgress; } SQLITE_API void sqlite3rbu_bp_progress(sqlite3rbu *p, int *pnOne, int *pnTwo){  const int MAX_PROGRESS = 10000;  switch( p->eStage ){  case RBU_STAGE_OAL:  if( p->nPhaseOneStep>0 ){  *pnOne = (int)(MAX_PROGRESS * (i64)p->nProgress/(i64)p->nPhaseOneStep);  }else{  *pnOne = -1;  }  *pnTwo = 0;  break;  case RBU_STAGE_MOVE:  *pnOne = MAX_PROGRESS;  *pnTwo = 0;  break;  case RBU_STAGE_CKPT:  *pnOne = MAX_PROGRESS;  *pnTwo = (int)(MAX_PROGRESS * (i64)p->nStep / (i64)p->nFrame);  break;  case RBU_STAGE_DONE:  *pnOne = MAX_PROGRESS;  *pnTwo = MAX_PROGRESS;  break;  default:  assert( 0 );  } } SQLITE_API int sqlite3rbu_state(sqlite3rbu *p){  int aRes[] = {  0, SQLITE_RBU_STATE_OAL, SQLITE_RBU_STATE_MOVE,  0, SQLITE_RBU_STATE_CHECKPOINT, SQLITE_RBU_STATE_DONE  };  assert( RBU_STAGE_OAL==1 );  assert( RBU_STAGE_MOVE==2 );  assert( RBU_STAGE_CKPT==4 );  assert( RBU_STAGE_DONE==5 );  assert( aRes[RBU_STAGE_OAL]==SQLITE_RBU_STATE_OAL );  assert( aRes[RBU_STAGE_MOVE]==SQLITE_RBU_STATE_MOVE );  assert( aRes[RBU_STAGE_CKPT]==SQLITE_RBU_STATE_CHECKPOINT );  assert( aRes[RBU_STAGE_DONE]==SQLITE_RBU_STATE_DONE );  if( p->rc!=SQLITE_OK && p->rc!=SQLITE_DONE ){  return SQLITE_RBU_STATE_ERROR;  }else{  assert( p->rc!=SQLITE_DONE || p->eStage==RBU_STAGE_DONE );  assert( p->eStage==RBU_STAGE_OAL   || p->eStage==RBU_STAGE_MOVE   || p->eStage==RBU_STAGE_CKPT   || p->eStage==RBU_STAGE_DONE  );  return aRes[p->eStage];  } } SQLITE_API int sqlite3rbu_savestate(sqlite3rbu *p){  int rc = p->rc;  if( rc==SQLITE_DONE ) return SQLITE_OK;  assert( p->eStage>=RBU_STAGE_OAL && p->eStage<=RBU_STAGE_DONE );  if( p->eStage==RBU_STAGE_OAL ){  assert( rc!=SQLITE_DONE );  if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbMain, "COMMIT", 0, 0, 0);  }  if( rc==SQLITE_OK && p->eStage==RBU_STAGE_CKPT ){  sqlite3_file *pDb = p->pTargetFd->pReal;  rc = pDb->pMethods->xSync(pDb, SQLITE_SYNC_NORMAL);  }  p->rc = rc;  rbuSaveState(p, p->eStage);  rc = p->rc;  if( p->eStage==RBU_STAGE_OAL ){  assert( rc!=SQLITE_DONE );  if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbRbu, "COMMIT", 0, 0, 0);  if( rc==SQLITE_OK ){  const char *zBegin = rbuIsVacuum(p) ? "BEGIN" : "BEGIN IMMEDIATE";  rc = sqlite3_exec(p->dbRbu, zBegin, 0, 0, 0);  }  if( rc==SQLITE_OK ) rc = sqlite3_exec(p->dbMain, "BEGIN IMMEDIATE", 0, 0,0);  }  p->rc = rc;  return rc; } static void rbuUnlockShm(rbu_file *p){  assert( p->openFlags & SQLITE_OPEN_MAIN_DB );  if( p->pRbu ){  int (*xShmLock)(sqlite3_file*,int,int,int) = p->pReal->pMethods->xShmLock;  int i;  for(i=0; i<SQLITE_SHM_NLOCK;i++){  if( (1<<i) & p->pRbu->mLock ){  xShmLock(p->pReal, i, 1, SQLITE_SHM_UNLOCK|SQLITE_SHM_EXCLUSIVE);  }  }  p->pRbu->mLock = 0;  } } static int rbuUpdateTempSize(rbu_file *pFd, sqlite3_int64 nNew){  sqlite3rbu *pRbu = pFd->pRbu;  i64 nDiff = nNew - pFd->sz;  pRbu->szTemp += nDiff;  pFd->sz = nNew;  assert( pRbu->szTemp>=0 );  if( pRbu->szTempLimit && pRbu->szTemp>pRbu->szTempLimit ) return SQLITE_FULL;  return SQLITE_OK; } static void rbuMainlistAdd(rbu_file *p){  rbu_vfs *pRbuVfs = p->pRbuVfs;  rbu_file *pIter;  assert( (p->openFlags & SQLITE_OPEN_MAIN_DB) );  sqlite3_mutex_enter(pRbuVfs->mutex);  if( p->pRbu==0 ){  for(pIter=pRbuVfs->pMain; pIter; pIter=pIter->pMainNext);  p->pMainNext = pRbuVfs->pMain;  pRbuVfs->pMain = p;  }else{  for(pIter=pRbuVfs->pMainRbu; pIter && pIter!=p; pIter=pIter->pMainRbuNext){}  if( pIter==0 ){  p->pMainRbuNext = pRbuVfs->pMainRbu;  pRbuVfs->pMainRbu = p;  }  }  sqlite3_mutex_leave(pRbuVfs->mutex); } static void rbuMainlistRemove(rbu_file *p){  rbu_file **pp;  sqlite3_mutex_enter(p->pRbuVfs->mutex);  for(pp=&p->pRbuVfs->pMain; *pp && *pp!=p; pp=&((*pp)->pMainNext)){}  if( *pp ) *pp = p->pMainNext;  p->pMainNext = 0;  for(pp=&p->pRbuVfs->pMainRbu; *pp && *pp!=p; pp=&((*pp)->pMainRbuNext)){}  if( *pp ) *pp = p->pMainRbuNext;  p->pMainRbuNext = 0;  sqlite3_mutex_leave(p->pRbuVfs->mutex); } static rbu_file *rbuFindMaindb(rbu_vfs *pRbuVfs, const char *zWal, int bRbu){  rbu_file *pDb;  sqlite3_mutex_enter(pRbuVfs->mutex);  if( bRbu ){  for(pDb=pRbuVfs->pMainRbu; pDb && pDb->zWal!=zWal; pDb=pDb->pMainRbuNext){}  }else{  for(pDb=pRbuVfs->pMain; pDb && pDb->zWal!=zWal; pDb=pDb->pMainNext){}  }  sqlite3_mutex_leave(pRbuVfs->mutex);  return pDb; } static int rbuVfsClose(sqlite3_file *pFile){  rbu_file *p = (rbu_file*)pFile;  int rc;  int i;  for(i=0; i<p->nShm; i++){  sqlite3_free(p->apShm[i]);  }  sqlite3_free(p->apShm);  p->apShm = 0;  sqlite3_free(p->zDel);  if( p->openFlags & SQLITE_OPEN_MAIN_DB ){  rbuMainlistRemove(p);  rbuUnlockShm(p);  p->pReal->pMethods->xShmUnmap(p->pReal, 0);  }  else if( (p->openFlags & SQLITE_OPEN_DELETEONCLOSE) && p->pRbu ){  rbuUpdateTempSize(p, 0);  }  assert( p->pMainNext==0 && p->pRbuVfs->pMain!=p );  rc = p->pReal->pMethods->xClose(p->pReal);  return rc; } static u32 rbuGetU32(u8 *aBuf){  return ((u32)aBuf[0] << 24)   + ((u32)aBuf[1] << 16)   + ((u32)aBuf[2] << 8)   + ((u32)aBuf[3]); } static void rbuPutU32(u8 *aBuf, u32 iVal){  aBuf[0] = (iVal >> 24) & 0xFF;  aBuf[1] = (iVal >> 16) & 0xFF;  aBuf[2] = (iVal >> 8) & 0xFF;  aBuf[3] = (iVal >> 0) & 0xFF; } static void rbuPutU16(u8 *aBuf, u16 iVal){  aBuf[0] = (iVal >> 8) & 0xFF;  aBuf[1] = (iVal >> 0) & 0xFF; } static int rbuVfsRead(  sqlite3_file *pFile,  void *zBuf,  int iAmt,  sqlite_int64 iOfst ){  rbu_file *p = (rbu_file*)pFile;  sqlite3rbu *pRbu = p->pRbu;  int rc;  if( pRbu && pRbu->eStage==RBU_STAGE_CAPTURE ){  assert( p->openFlags & SQLITE_OPEN_WAL );  rc = rbuCaptureWalRead(p->pRbu, iOfst, iAmt);  }else{  if( pRbu && pRbu->eStage==RBU_STAGE_OAL   && (p->openFlags & SQLITE_OPEN_WAL)   && iOfst>=pRbu->iOalSz  ){  rc = SQLITE_OK;  memset(zBuf, 0, iAmt);  }else{  rc = p->pReal->pMethods->xRead(p->pReal, zBuf, iAmt, iOfst);
#if 1
 if( pRbu && rbuIsVacuum(pRbu)  && rc==SQLITE_IOERR_SHORT_READ && iOfst==0  && (p->openFlags & SQLITE_OPEN_MAIN_DB)  && pRbu->rc==SQLITE_OK  ){  sqlite3_file *pFd = (sqlite3_file*)pRbu->pRbuFd;  rc = pFd->pMethods->xRead(pFd, zBuf, iAmt, iOfst);  if( rc==SQLITE_OK ){  u8 *aBuf = (u8*)zBuf;  u32 iRoot = rbuGetU32(&aBuf[52]) ? 1 : 0;  rbuPutU32(&aBuf[52], iRoot);  rbuPutU32(&aBuf[36], 0);  rbuPutU32(&aBuf[32], 0);  rbuPutU32(&aBuf[28], 1);  rbuPutU32(&aBuf[24], pRbu->pRbuFd->iCookie+1);  if( iAmt>100 ){  memset(&aBuf[100], 0, iAmt-100);  rbuPutU16(&aBuf[105], iAmt & 0xFFFF);  aBuf[100] = 0x0D;  }  }  }
#endif
 }  if( rc==SQLITE_OK && iOfst==0 && (p->openFlags & SQLITE_OPEN_MAIN_DB) ){  u8 *pBuf = (u8*)zBuf;  p->iCookie = rbuGetU32(&pBuf[24]);  p->iWriteVer = pBuf[19];  }  }  return rc; } static int rbuVfsWrite(  sqlite3_file *pFile,  const void *zBuf,  int iAmt,  sqlite_int64 iOfst ){  rbu_file *p = (rbu_file*)pFile;  sqlite3rbu *pRbu = p->pRbu;  int rc;  if( pRbu && pRbu->eStage==RBU_STAGE_CAPTURE ){  assert( p->openFlags & SQLITE_OPEN_MAIN_DB );  rc = rbuCaptureDbWrite(p->pRbu, iOfst);  }else{  if( pRbu ){  if( pRbu->eStage==RBU_STAGE_OAL   && (p->openFlags & SQLITE_OPEN_WAL)   && iOfst>=pRbu->iOalSz  ){  pRbu->iOalSz = iAmt + iOfst;  }else if( p->openFlags & SQLITE_OPEN_DELETEONCLOSE ){  i64 szNew = iAmt+iOfst;  if( szNew>p->sz ){  rc = rbuUpdateTempSize(p, szNew);  if( rc!=SQLITE_OK ) return rc;  }  }  }  rc = p->pReal->pMethods->xWrite(p->pReal, zBuf, iAmt, iOfst);  if( rc==SQLITE_OK && iOfst==0 && (p->openFlags & SQLITE_OPEN_MAIN_DB) ){  u8 *pBuf = (u8*)zBuf;  p->iCookie = rbuGetU32(&pBuf[24]);  p->iWriteVer = pBuf[19];  }  }  return rc; } static int rbuVfsTruncate(sqlite3_file *pFile, sqlite_int64 size){  rbu_file *p = (rbu_file*)pFile;  if( (p->openFlags & SQLITE_OPEN_DELETEONCLOSE) && p->pRbu ){  int rc = rbuUpdateTempSize(p, size);  if( rc!=SQLITE_OK ) return rc;  }  return p->pReal->pMethods->xTruncate(p->pReal, size); } static int rbuVfsSync(sqlite3_file *pFile, int flags){  rbu_file *p = (rbu_file *)pFile;  if( p->pRbu && p->pRbu->eStage==RBU_STAGE_CAPTURE ){  if( p->openFlags & SQLITE_OPEN_MAIN_DB ){  return SQLITE_INTERNAL;  }  return SQLITE_OK;  }  return p->pReal->pMethods->xSync(p->pReal, flags); } static int rbuVfsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){  rbu_file *p = (rbu_file *)pFile;  int rc;  rc = p->pReal->pMethods->xFileSize(p->pReal, pSize);  if( rc==SQLITE_OK && *pSize==0   && p->pRbu && rbuIsVacuum(p->pRbu)   && (p->openFlags & SQLITE_OPEN_MAIN_DB)  ){  *pSize = 1024;  }  return rc; } static int rbuVfsLock(sqlite3_file *pFile, int eLock){  rbu_file *p = (rbu_file*)pFile;  sqlite3rbu *pRbu = p->pRbu;  int rc = SQLITE_OK;  assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB) );  if( eLock==SQLITE_LOCK_EXCLUSIVE   && (p->bNolock || (pRbu && pRbu->eStage!=RBU_STAGE_DONE))  ){  rc = SQLITE_BUSY;  }else{  rc = p->pReal->pMethods->xLock(p->pReal, eLock);  }  return rc; } static int rbuVfsUnlock(sqlite3_file *pFile, int eLock){  rbu_file *p = (rbu_file *)pFile;  return p->pReal->pMethods->xUnlock(p->pReal, eLock); } static int rbuVfsCheckReservedLock(sqlite3_file *pFile, int *pResOut){  rbu_file *p = (rbu_file *)pFile;  return p->pReal->pMethods->xCheckReservedLock(p->pReal, pResOut); } static int rbuVfsFileControl(sqlite3_file *pFile, int op, void *pArg){  rbu_file *p = (rbu_file *)pFile;  int (*xControl)(sqlite3_file*,int,void*) = p->pReal->pMethods->xFileControl;  int rc;  assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB)   || p->openFlags & (SQLITE_OPEN_TRANSIENT_DB|SQLITE_OPEN_TEMP_JOURNAL)  );  if( op==SQLITE_FCNTL_RBU ){  sqlite3rbu *pRbu = (sqlite3rbu*)pArg;  rc = xControl(p->pReal, op, pArg);  if( rc==SQLITE_NOTFOUND ){  void *dummy = 0;  rc = xControl(p->pReal, SQLITE_FCNTL_ZIPVFS, &dummy);  if( rc==SQLITE_OK ){  rc = SQLITE_ERROR;  pRbu->zErrmsg = sqlite3_mprintf("rbu/zipvfs setup error");  }else if( rc==SQLITE_NOTFOUND ){  pRbu->pTargetFd = p;  p->pRbu = pRbu;  rbuMainlistAdd(p);  if( p->pWalFd ) p->pWalFd->pRbu = pRbu;  rc = SQLITE_OK;  }  }  return rc;  }  else if( op==SQLITE_FCNTL_RBUCNT ){  sqlite3rbu *pRbu = (sqlite3rbu*)pArg;  pRbu->nRbu++;  pRbu->pRbuFd = p;  p->bNolock = 1;  }  rc = xControl(p->pReal, op, pArg);  if( rc==SQLITE_OK && op==SQLITE_FCNTL_VFSNAME ){  rbu_vfs *pRbuVfs = p->pRbuVfs;  char *zIn = *(char**)pArg;  char *zOut = sqlite3_mprintf("rbu(%s)/%z", pRbuVfs->base.zName, zIn);  *(char**)pArg = zOut;  if( zOut==0 ) rc = SQLITE_NOMEM;  }  return rc; } static int rbuVfsSectorSize(sqlite3_file *pFile){  rbu_file *p = (rbu_file *)pFile;  return p->pReal->pMethods->xSectorSize(p->pReal); } static int rbuVfsDeviceCharacteristics(sqlite3_file *pFile){  rbu_file *p = (rbu_file *)pFile;  return p->pReal->pMethods->xDeviceCharacteristics(p->pReal); } static int rbuVfsShmLock(sqlite3_file *pFile, int ofst, int n, int flags){  rbu_file *p = (rbu_file*)pFile;  sqlite3rbu *pRbu = p->pRbu;  int rc = SQLITE_OK;
#ifdef SQLITE_AMALGAMATION
 assert( WAL_CKPT_LOCK==1 );
#endif
 assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB) );  if( pRbu && (   pRbu->eStage==RBU_STAGE_OAL  || pRbu->eStage==RBU_STAGE_MOVE  || pRbu->eStage==RBU_STAGE_DONE  )){  if( ofst==WAL_LOCK_CKPT && n==1 ) rc = SQLITE_BUSY;  }else{  int bCapture = 0;  if( pRbu && pRbu->eStage==RBU_STAGE_CAPTURE ){  bCapture = 1;  }  if( bCapture==0 || 0==(flags & SQLITE_SHM_UNLOCK) ){  rc = p->pReal->pMethods->xShmLock(p->pReal, ofst, n, flags);  if( bCapture && rc==SQLITE_OK ){  pRbu->mLock |= ((1<<n) - 1) << ofst;  }  }  }  return rc; } static int rbuVfsShmMap(  sqlite3_file *pFile,  int iRegion,  int szRegion,  int isWrite,  void volatile **pp ){  rbu_file *p = (rbu_file*)pFile;  int rc = SQLITE_OK;  int eStage = (p->pRbu ? p->pRbu->eStage : 0);  assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB) );  if( eStage==RBU_STAGE_OAL ){  sqlite3_int64 nByte = (iRegion+1) * sizeof(char*);  char **apNew = (char**)sqlite3_realloc64(p->apShm, nByte);  assert( iRegion==p->nShm );  if( apNew==0 ){  rc = SQLITE_NOMEM;  }else{  memset(&apNew[p->nShm], 0, sizeof(char*) * (1 + iRegion - p->nShm));  p->apShm = apNew;  p->nShm = iRegion+1;  }  if( rc==SQLITE_OK ){  char *pNew = (char*)sqlite3_malloc64(szRegion);  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  memset(pNew, 0, szRegion);  p->apShm[iRegion] = pNew;  }  }  if( rc==SQLITE_OK ){  *pp = p->apShm[iRegion];  }else{  *pp = 0;  }  }else{  assert( p->apShm==0 );  rc = p->pReal->pMethods->xShmMap(p->pReal, iRegion, szRegion, isWrite, pp);  }  return rc; } static void rbuVfsShmBarrier(sqlite3_file *pFile){  rbu_file *p = (rbu_file *)pFile;  p->pReal->pMethods->xShmBarrier(p->pReal); } static int rbuVfsShmUnmap(sqlite3_file *pFile, int delFlag){  rbu_file *p = (rbu_file*)pFile;  int rc = SQLITE_OK;  int eStage = (p->pRbu ? p->pRbu->eStage : 0);  assert( p->openFlags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_TEMP_DB) );  if( eStage==RBU_STAGE_OAL || eStage==RBU_STAGE_MOVE ){  }else{  rbuUnlockShm(p);  rc = p->pReal->pMethods->xShmUnmap(p->pReal, delFlag);  }  return rc; } static int rbuVfsOpen(  sqlite3_vfs *pVfs,  const char *zName,  sqlite3_file *pFile,  int flags,  int *pOutFlags ){  static sqlite3_io_methods rbuvfs_io_methods = {  2,  rbuVfsClose,  rbuVfsRead,  rbuVfsWrite,  rbuVfsTruncate,  rbuVfsSync,  rbuVfsFileSize,  rbuVfsLock,  rbuVfsUnlock,  rbuVfsCheckReservedLock,  rbuVfsFileControl,  rbuVfsSectorSize,  rbuVfsDeviceCharacteristics,  rbuVfsShmMap,  rbuVfsShmLock,  rbuVfsShmBarrier,  rbuVfsShmUnmap,  0, 0  };  rbu_vfs *pRbuVfs = (rbu_vfs*)pVfs;  sqlite3_vfs *pRealVfs = pRbuVfs->pRealVfs;  rbu_file *pFd = (rbu_file *)pFile;  int rc = SQLITE_OK;  const char *zOpen = zName;  int oflags = flags;  memset(pFd, 0, sizeof(rbu_file));  pFd->pReal = (sqlite3_file*)&pFd[1];  pFd->pRbuVfs = pRbuVfs;  pFd->openFlags = flags;  if( zName ){  if( flags & SQLITE_OPEN_MAIN_DB ){  pFd->zWal = sqlite3_filename_wal(zName);  }  else if( flags & SQLITE_OPEN_WAL ){  rbu_file *pDb = rbuFindMaindb(pRbuVfs, zName, 0);  if( pDb ){  if( pDb->pRbu && pDb->pRbu->eStage==RBU_STAGE_OAL ){  size_t nOpen;  if( rbuIsVacuum(pDb->pRbu) ){  zOpen = sqlite3_db_filename(pDb->pRbu->dbRbu, "main");  zOpen = sqlite3_filename_wal(zOpen);  }  nOpen = strlen(zOpen);  ((char*)zOpen)[nOpen-3] = 'o';  pFd->pRbu = pDb->pRbu;  }  pDb->pWalFd = pFd;  }  }  }else{  pFd->pRbu = pRbuVfs->pRbu;  }  if( oflags & SQLITE_OPEN_MAIN_DB   && sqlite3_uri_boolean(zName, "rbu_memory", 0)  ){  assert( oflags & SQLITE_OPEN_MAIN_DB );  oflags = SQLITE_OPEN_TEMP_DB | SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |  SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;  zOpen = 0;  }  if( rc==SQLITE_OK ){  rc = pRealVfs->xOpen(pRealVfs, zOpen, pFd->pReal, oflags, pOutFlags);  }  if( pFd->pReal->pMethods ){  pFile->pMethods = &rbuvfs_io_methods;  if( flags & SQLITE_OPEN_MAIN_DB ){  rbuMainlistAdd(pFd);  }  }else{  sqlite3_free(pFd->zDel);  }  return rc; } static int rbuVfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xDelete(pRealVfs, zPath, dirSync); } static int rbuVfsAccess(  sqlite3_vfs *pVfs,  const char *zPath,  int flags,  int *pResOut ){  rbu_vfs *pRbuVfs = (rbu_vfs*)pVfs;  sqlite3_vfs *pRealVfs = pRbuVfs->pRealVfs;  int rc;  rc = pRealVfs->xAccess(pRealVfs, zPath, flags, pResOut);  if( rc==SQLITE_OK && flags==SQLITE_ACCESS_EXISTS ){  rbu_file *pDb = rbuFindMaindb(pRbuVfs, zPath, 1);  if( pDb && pDb->pRbu->eStage==RBU_STAGE_OAL ){  assert( pDb->pRbu );  if( *pResOut ){  rc = SQLITE_CANTOPEN;  }else{  sqlite3_int64 sz = 0;  rc = rbuVfsFileSize(&pDb->base, &sz);  *pResOut = (sz>0);  }  }  }  return rc; } static int rbuVfsFullPathname(  sqlite3_vfs *pVfs,  const char *zPath,  int nOut,  char *zOut ){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xFullPathname(pRealVfs, zPath, nOut, zOut); }
#ifndef SQLITE_OMIT_LOAD_EXTENSION
static void *rbuVfsDlOpen(sqlite3_vfs *pVfs, const char *zPath){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xDlOpen(pRealVfs, zPath); } static void rbuVfsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  pRealVfs->xDlError(pRealVfs, nByte, zErrMsg); } static void (*rbuVfsDlSym(  sqlite3_vfs *pVfs,  void *pArg,  const char *zSym ))(void){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xDlSym(pRealVfs, pArg, zSym); } static void rbuVfsDlClose(sqlite3_vfs *pVfs, void *pHandle){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  pRealVfs->xDlClose(pRealVfs, pHandle); }
#endif
static int rbuVfsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xRandomness(pRealVfs, nByte, zBufOut); } static int rbuVfsSleep(sqlite3_vfs *pVfs, int nMicro){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xSleep(pRealVfs, nMicro); } static int rbuVfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){  sqlite3_vfs *pRealVfs = ((rbu_vfs*)pVfs)->pRealVfs;  return pRealVfs->xCurrentTime(pRealVfs, pTimeOut); } static int rbuVfsGetLastError(sqlite3_vfs *pVfs, int a, char *b){  return 0; } SQLITE_API void sqlite3rbu_destroy_vfs(const char *zName){  sqlite3_vfs *pVfs = sqlite3_vfs_find(zName);  if( pVfs && pVfs->xOpen==rbuVfsOpen ){  sqlite3_mutex_free(((rbu_vfs*)pVfs)->mutex);  sqlite3_vfs_unregister(pVfs);  sqlite3_free(pVfs);  } } SQLITE_API int sqlite3rbu_create_vfs(const char *zName, const char *zParent){  static sqlite3_vfs vfs_template = {  1,  0,  0,  0,  0,  0,  rbuVfsOpen,  rbuVfsDelete,  rbuVfsAccess,  rbuVfsFullPathname,
#ifndef SQLITE_OMIT_LOAD_EXTENSION
 rbuVfsDlOpen,  rbuVfsDlError,  rbuVfsDlSym,  rbuVfsDlClose,
#else
 0, 0, 0, 0,
#endif
 rbuVfsRandomness,  rbuVfsSleep,  rbuVfsCurrentTime,  rbuVfsGetLastError,  0,  0, 0, 0  };  rbu_vfs *pNew = 0;  int rc = SQLITE_OK;  size_t nName;  size_t nByte;  nName = strlen(zName);  nByte = sizeof(rbu_vfs) + nName + 1;  pNew = (rbu_vfs*)sqlite3_malloc64(nByte);  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_vfs *pParent;  memset(pNew, 0, nByte);  pParent = sqlite3_vfs_find(zParent);  if( pParent==0 ){  rc = SQLITE_NOTFOUND;  }else{  char *zSpace;  memcpy(&pNew->base, &vfs_template, sizeof(sqlite3_vfs));  pNew->base.mxPathname = pParent->mxPathname;  pNew->base.szOsFile = sizeof(rbu_file) + pParent->szOsFile;  pNew->pRealVfs = pParent;  pNew->base.zName = (const char*)(zSpace = (char*)&pNew[1]);  memcpy(zSpace, zName, nName);  pNew->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_RECURSIVE);  if( pNew->mutex==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_vfs_register(&pNew->base, 0);  }  }  if( rc!=SQLITE_OK ){  sqlite3_mutex_free(pNew->mutex);  sqlite3_free(pNew);  }  }  return rc; } SQLITE_API sqlite3_int64 sqlite3rbu_temp_size_limit(sqlite3rbu *pRbu, sqlite3_int64 n){  if( n>=0 ){  pRbu->szTempLimit = n;  }  return pRbu->szTempLimit; } SQLITE_API sqlite3_int64 sqlite3rbu_temp_size(sqlite3rbu *pRbu){  return pRbu->szTemp; }
#endif
#if (defined(SQLITE_ENABLE_DBSTAT_VTAB) || defined(SQLITE_TEST))  && !defined(SQLITE_OMIT_VIRTUALTABLE)

#define DBSTAT_PAGE_PADDING_BYTES 256
static const char zDbstatSchema[] =  "CREATE TABLE x("  " name  TEXT,"  " path  TEXT,"  " pageno  INTEGER,"  " pagetype  TEXT,"  " ncell INTEGER,"  " payload INTEGER,"  " unused  INTEGER,"  " mx_payload INTEGER,"  " pgoffset  INTEGER,"  " pgsize  INTEGER,"  " schema  TEXT HIDDEN,"  " aggregate BOOLEAN HIDDEN"  ")" ; typedef struct StatTable StatTable; typedef struct StatCursor StatCursor; typedef struct StatPage StatPage; typedef struct StatCell StatCell; struct StatCell {  int nLocal;  u32 iChildPg;  int nOvfl;  u32 *aOvfl;  int nLastOvfl;  int iOvfl; }; struct StatPage {  u32 iPgno;  u8 *aPg;  int iCell;  char *zPath;  u8 flags;  int nCell;  int nUnused;  StatCell *aCell;  u32 iRightChildPg;  int nMxPayload; }; struct StatCursor {  sqlite3_vtab_cursor base;  sqlite3_stmt *pStmt;  u8 isEof;  u8 isAgg;  int iDb;  StatPage aPage[32];  int iPage;  u32 iPageno;  char *zName;  char *zPath;  char *zPagetype;  int nPage;  int nCell;  int nMxPayload;  i64 nUnused;  i64 nPayload;  i64 iOffset;  i64 szPage; }; struct StatTable {  sqlite3_vtab base;  sqlite3 *db;  int iDb; };
#ifndef get2byte
# define get2byte(x)  ((x)[0]<<8 | (x)[1])
#endif
static int statConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  StatTable *pTab = 0;  int rc = SQLITE_OK;  int iDb;  if( argc>=4 ){  Token nm;  sqlite3TokenInit(&nm, (char*)argv[3]);  iDb = sqlite3FindDb(db, &nm);  if( iDb<0 ){  *pzErr = sqlite3_mprintf("no such database: %s", argv[3]);  return SQLITE_ERROR;  }  }else{  iDb = 0;  }  sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);  rc = sqlite3_declare_vtab(db, zDbstatSchema);  if( rc==SQLITE_OK ){  pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));  if( pTab==0 ) rc = SQLITE_NOMEM_BKPT;  }  assert( rc==SQLITE_OK || pTab==0 );  if( rc==SQLITE_OK ){  memset(pTab, 0, sizeof(StatTable));  pTab->db = db;  pTab->iDb = iDb;  }  *ppVtab = (sqlite3_vtab*)pTab;  return rc; } static int statDisconnect(sqlite3_vtab *pVtab){  sqlite3_free(pVtab);  return SQLITE_OK; } static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){  int i;  int iSchema = -1;  int iName = -1;  int iAgg = -1;  for(i=0; i<pIdxInfo->nConstraint; i++){  if( pIdxInfo->aConstraint[i].op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;  if( pIdxInfo->aConstraint[i].usable==0 ){  return SQLITE_CONSTRAINT;  }  switch( pIdxInfo->aConstraint[i].iColumn ){  case 0: {  iName = i;  break;  }  case 10: {  iSchema = i;  break;  }  case 11: {  iAgg = i;  break;  }  }  }  i = 0;  if( iSchema>=0 ){  pIdxInfo->aConstraintUsage[iSchema].argvIndex = ++i;  pIdxInfo->aConstraintUsage[iSchema].omit = 1;  pIdxInfo->idxNum |= 0x01;  }  if( iName>=0 ){  pIdxInfo->aConstraintUsage[iName].argvIndex = ++i;  pIdxInfo->idxNum |= 0x02;  }  if( iAgg>=0 ){  pIdxInfo->aConstraintUsage[iAgg].argvIndex = ++i;  pIdxInfo->idxNum |= 0x04;  }  pIdxInfo->estimatedCost = 1.0;  if( ( pIdxInfo->nOrderBy==1   && pIdxInfo->aOrderBy[0].iColumn==0   && pIdxInfo->aOrderBy[0].desc==0   ) ||  ( pIdxInfo->nOrderBy==2   && pIdxInfo->aOrderBy[0].iColumn==0   && pIdxInfo->aOrderBy[0].desc==0   && pIdxInfo->aOrderBy[1].iColumn==1   && pIdxInfo->aOrderBy[1].desc==0   )  ){  pIdxInfo->orderByConsumed = 1;  pIdxInfo->idxNum |= 0x08;  }  return SQLITE_OK; } static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){  StatTable *pTab = (StatTable *)pVTab;  StatCursor *pCsr;  pCsr = (StatCursor *)sqlite3_malloc64(sizeof(StatCursor));  if( pCsr==0 ){  return SQLITE_NOMEM_BKPT;  }else{  memset(pCsr, 0, sizeof(StatCursor));  pCsr->base.pVtab = pVTab;  pCsr->iDb = pTab->iDb;  }  *ppCursor = (sqlite3_vtab_cursor *)pCsr;  return SQLITE_OK; } static void statClearCells(StatPage *p){  int i;  if( p->aCell ){  for(i=0; i<p->nCell; i++){  sqlite3_free(p->aCell[i].aOvfl);  }  sqlite3_free(p->aCell);  }  p->nCell = 0;  p->aCell = 0; } static void statClearPage(StatPage *p){  u8 *aPg = p->aPg;  statClearCells(p);  sqlite3_free(p->zPath);  memset(p, 0, sizeof(StatPage));  p->aPg = aPg; } static void statResetCsr(StatCursor *pCsr){  int i;  for(i=0; i<ArraySize(pCsr->aPage); i++){  statClearPage(&pCsr->aPage[i]);  sqlite3_free(pCsr->aPage[i].aPg);  pCsr->aPage[i].aPg = 0;  }  sqlite3_reset(pCsr->pStmt);  pCsr->iPage = 0;  sqlite3_free(pCsr->zPath);  pCsr->zPath = 0;  pCsr->isEof = 0; } static void statResetCounts(StatCursor *pCsr){  pCsr->nCell = 0;  pCsr->nMxPayload = 0;  pCsr->nUnused = 0;  pCsr->nPayload = 0;  pCsr->szPage = 0;  pCsr->nPage = 0; } static int statClose(sqlite3_vtab_cursor *pCursor){  StatCursor *pCsr = (StatCursor *)pCursor;  statResetCsr(pCsr);  sqlite3_finalize(pCsr->pStmt);  sqlite3_free(pCsr);  return SQLITE_OK; } static int getLocalPayload(  int nUsable,  u8 flags,  int nTotal ){  int nLocal;  int nMinLocal;  int nMaxLocal;  if( flags==0x0D ){  nMinLocal = (nUsable - 12) * 32 / 255 - 23;  nMaxLocal = nUsable - 35;  }else{  nMinLocal = (nUsable - 12) * 32 / 255 - 23;  nMaxLocal = (nUsable - 12) * 64 / 255 - 23;  }  nLocal = nMinLocal + (nTotal - nMinLocal) % (nUsable - 4);  if( nLocal>nMaxLocal ) nLocal = nMinLocal;  return nLocal; } static int statDecodePage(Btree *pBt, StatPage *p){  int nUnused;  int iOff;  int nHdr;  int isLeaf;  int szPage;  u8 *aData = p->aPg;  u8 *aHdr = &aData[p->iPgno==1 ? 100 : 0];  p->flags = aHdr[0];  if( p->flags==0x0A || p->flags==0x0D ){  isLeaf = 1;  nHdr = 8;  }else if( p->flags==0x05 || p->flags==0x02 ){  isLeaf = 0;  nHdr = 12;  }else{  goto statPageIsCorrupt;  }  if( p->iPgno==1 ) nHdr += 100;  p->nCell = get2byte(&aHdr[3]);  p->nMxPayload = 0;  szPage = sqlite3BtreeGetPageSize(pBt);  nUnused = get2byte(&aHdr[5]) - nHdr - 2*p->nCell;  nUnused += (int)aHdr[7];  iOff = get2byte(&aHdr[1]);  while( iOff ){  int iNext;  if( iOff>=szPage ) goto statPageIsCorrupt;  nUnused += get2byte(&aData[iOff+2]);  iNext = get2byte(&aData[iOff]);  if( iNext<iOff+4 && iNext>0 ) goto statPageIsCorrupt;  iOff = iNext;  }  p->nUnused = nUnused;  p->iRightChildPg = isLeaf ? 0 : sqlite3Get4byte(&aHdr[8]);  if( p->nCell ){  int i;  int nUsable;  sqlite3BtreeEnter(pBt);  nUsable = szPage - sqlite3BtreeGetReserveNoMutex(pBt);  sqlite3BtreeLeave(pBt);  p->aCell = sqlite3_malloc64((p->nCell+1) * sizeof(StatCell));  if( p->aCell==0 ) return SQLITE_NOMEM_BKPT;  memset(p->aCell, 0, (p->nCell+1) * sizeof(StatCell));  for(i=0; i<p->nCell; i++){  StatCell *pCell = &p->aCell[i];  iOff = get2byte(&aData[nHdr+i*2]);  if( iOff<nHdr || iOff>=szPage ) goto statPageIsCorrupt;  if( !isLeaf ){  pCell->iChildPg = sqlite3Get4byte(&aData[iOff]);  iOff += 4;  }  if( p->flags==0x05 ){  }else{  u32 nPayload;  int nLocal;  iOff += getVarint32(&aData[iOff], nPayload);  if( p->flags==0x0D ){  u64 dummy;  iOff += sqlite3GetVarint(&aData[iOff], &dummy);  }  if( nPayload>(u32)p->nMxPayload ) p->nMxPayload = nPayload;  nLocal = getLocalPayload(nUsable, p->flags, nPayload);  if( nLocal<0 ) goto statPageIsCorrupt;  pCell->nLocal = nLocal;  assert( nPayload>=(u32)nLocal );  assert( nLocal<=(nUsable-35) );  if( nPayload>(u32)nLocal ){  int j;  int nOvfl = ((nPayload - nLocal) + nUsable-4 - 1) / (nUsable - 4);  if( iOff+nLocal+4>nUsable || nPayload>0x7fffffff ){  goto statPageIsCorrupt;  }  pCell->nLastOvfl = (nPayload-nLocal) - (nOvfl-1) * (nUsable-4);  pCell->nOvfl = nOvfl;  pCell->aOvfl = sqlite3_malloc64(sizeof(u32)*nOvfl);  if( pCell->aOvfl==0 ) return SQLITE_NOMEM_BKPT;  pCell->aOvfl[0] = sqlite3Get4byte(&aData[iOff+nLocal]);  for(j=1; j<nOvfl; j++){  int rc;  u32 iPrev = pCell->aOvfl[j-1];  DbPage *pPg = 0;  rc = sqlite3PagerGet(sqlite3BtreePager(pBt), iPrev, &pPg, 0);  if( rc!=SQLITE_OK ){  assert( pPg==0 );  return rc;  }  pCell->aOvfl[j] = sqlite3Get4byte(sqlite3PagerGetData(pPg));  sqlite3PagerUnref(pPg);  }  }  }  }  }  return SQLITE_OK; statPageIsCorrupt:  p->flags = 0;  statClearCells(p);  return SQLITE_OK; } static void statSizeAndOffset(StatCursor *pCsr){  StatTable *pTab = (StatTable *)((sqlite3_vtab_cursor *)pCsr)->pVtab;  Btree *pBt = pTab->db->aDb[pTab->iDb].pBt;  Pager *pPager = sqlite3BtreePager(pBt);  sqlite3_file *fd;  sqlite3_int64 x[2];  fd = sqlite3PagerFile(pPager);  x[0] = pCsr->iPageno;  if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){  pCsr->iOffset = x[0];  pCsr->szPage += x[1];  }else{  pCsr->szPage += sqlite3BtreeGetPageSize(pBt);  pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);  } } static int statGetPage(  Btree *pBt,  u32 iPg,  StatPage *pPg ){  int pgsz = sqlite3BtreeGetPageSize(pBt);  DbPage *pDbPage = 0;  int rc;  if( pPg->aPg==0 ){  pPg->aPg = (u8*)sqlite3_malloc(pgsz + DBSTAT_PAGE_PADDING_BYTES);  if( pPg->aPg==0 ){  return SQLITE_NOMEM_BKPT;  }  memset(&pPg->aPg[pgsz], 0, DBSTAT_PAGE_PADDING_BYTES);  }  rc = sqlite3PagerGet(sqlite3BtreePager(pBt), iPg, &pDbPage, 0);  if( rc==SQLITE_OK ){  const u8 *a = sqlite3PagerGetData(pDbPage);  memcpy(pPg->aPg, a, pgsz);  sqlite3PagerUnref(pDbPage);  }  return rc; } static int statNext(sqlite3_vtab_cursor *pCursor){  int rc;  int nPayload;  char *z;  StatCursor *pCsr = (StatCursor *)pCursor;  StatTable *pTab = (StatTable *)pCursor->pVtab;  Btree *pBt = pTab->db->aDb[pCsr->iDb].pBt;  Pager *pPager = sqlite3BtreePager(pBt);  sqlite3_free(pCsr->zPath);  pCsr->zPath = 0; statNextRestart:  if( pCsr->iPage<0 ){  statResetCounts(pCsr);  rc = sqlite3_step(pCsr->pStmt);  if( rc==SQLITE_ROW ){  int nPage;  u32 iRoot = (u32)sqlite3_column_int64(pCsr->pStmt, 1);  sqlite3PagerPagecount(pPager, &nPage);  if( nPage==0 ){  pCsr->isEof = 1;  return sqlite3_reset(pCsr->pStmt);  }  rc = statGetPage(pBt, iRoot, &pCsr->aPage[0]);  pCsr->aPage[0].iPgno = iRoot;  pCsr->aPage[0].iCell = 0;  if( !pCsr->isAgg ){  pCsr->aPage[0].zPath = z = sqlite3_mprintf("/");  if( z==0 ) rc = SQLITE_NOMEM_BKPT;  }  pCsr->iPage = 0;  pCsr->nPage = 1;  }else{  pCsr->isEof = 1;  return sqlite3_reset(pCsr->pStmt);  }  }else{  StatPage *p = &pCsr->aPage[pCsr->iPage];  if( !pCsr->isAgg ) statResetCounts(pCsr);  while( p->iCell<p->nCell ){  StatCell *pCell = &p->aCell[p->iCell];  while( pCell->iOvfl<pCell->nOvfl ){  int nUsable, iOvfl;  sqlite3BtreeEnter(pBt);  nUsable = sqlite3BtreeGetPageSize(pBt) -  sqlite3BtreeGetReserveNoMutex(pBt);  sqlite3BtreeLeave(pBt);  pCsr->nPage++;  statSizeAndOffset(pCsr);  if( pCell->iOvfl<pCell->nOvfl-1 ){  pCsr->nPayload += nUsable - 4;  }else{  pCsr->nPayload += pCell->nLastOvfl;  pCsr->nUnused += nUsable - 4 - pCell->nLastOvfl;  }  iOvfl = pCell->iOvfl;  pCell->iOvfl++;  if( !pCsr->isAgg ){  pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);  pCsr->iPageno = pCell->aOvfl[iOvfl];  pCsr->zPagetype = "overflow";  pCsr->zPath = z = sqlite3_mprintf(  "%s%.3x+%.6x", p->zPath, p->iCell, iOvfl  );  return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;  }  }  if( p->iRightChildPg ) break;  p->iCell++;  }  if( !p->iRightChildPg || p->iCell>p->nCell ){  statClearPage(p);  pCsr->iPage--;  if( pCsr->isAgg && pCsr->iPage<0 ){  return SQLITE_OK;  }  goto statNextRestart;  }  pCsr->iPage++;  if( pCsr->iPage>=ArraySize(pCsr->aPage) ){  statResetCsr(pCsr);  return SQLITE_CORRUPT_BKPT;  }  assert( p==&pCsr->aPage[pCsr->iPage-1] );  if( p->iCell==p->nCell ){  p[1].iPgno = p->iRightChildPg;  }else{  p[1].iPgno = p->aCell[p->iCell].iChildPg;  }  rc = statGetPage(pBt, p[1].iPgno, &p[1]);  pCsr->nPage++;  p[1].iCell = 0;  if( !pCsr->isAgg ){  p[1].zPath = z = sqlite3_mprintf("%s%.3x/", p->zPath, p->iCell);  if( z==0 ) rc = SQLITE_NOMEM_BKPT;  }  p->iCell++;  }  if( rc==SQLITE_OK ){  int i;  StatPage *p = &pCsr->aPage[pCsr->iPage];  pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);  pCsr->iPageno = p->iPgno;  rc = statDecodePage(pBt, p);  if( rc==SQLITE_OK ){  statSizeAndOffset(pCsr);  switch( p->flags ){  case 0x05:  case 0x02:  pCsr->zPagetype = "internal";  break;  case 0x0D:  case 0x0A:  pCsr->zPagetype = "leaf";  break;  default:  pCsr->zPagetype = "corrupted";  break;  }  pCsr->nCell += p->nCell;  pCsr->nUnused += p->nUnused;  if( p->nMxPayload>pCsr->nMxPayload ) pCsr->nMxPayload = p->nMxPayload;  if( !pCsr->isAgg ){  pCsr->zPath = z = sqlite3_mprintf("%s", p->zPath);  if( z==0 ) rc = SQLITE_NOMEM_BKPT;  }  nPayload = 0;  for(i=0; i<p->nCell; i++){  nPayload += p->aCell[i].nLocal;  }  pCsr->nPayload += nPayload;  if( pCsr->isAgg ) goto statNextRestart;  }  }  return rc; } static int statEof(sqlite3_vtab_cursor *pCursor){  StatCursor *pCsr = (StatCursor *)pCursor;  return pCsr->isEof; } static int statFilter(  sqlite3_vtab_cursor *pCursor,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  StatCursor *pCsr = (StatCursor *)pCursor;  StatTable *pTab = (StatTable*)(pCursor->pVtab);  sqlite3_str *pSql;  char *zSql;  int iArg = 0;  int rc = SQLITE_OK;  const char *zName = 0;  statResetCsr(pCsr);  sqlite3_finalize(pCsr->pStmt);  pCsr->pStmt = 0;  if( idxNum & 0x01 ){  const char *zDbase = (const char*)sqlite3_value_text(argv[iArg++]);  pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);  if( pCsr->iDb<0 ){  pCsr->iDb = 0;  pCsr->isEof = 1;  return SQLITE_OK;  }  }else{  pCsr->iDb = pTab->iDb;  }  if( idxNum & 0x02 ){  zName = (const char*)sqlite3_value_text(argv[iArg++]);  }  if( idxNum & 0x04 ){  pCsr->isAgg = sqlite3_value_double(argv[iArg++])!=0.0;  }else{  pCsr->isAgg = 0;  }  pSql = sqlite3_str_new(pTab->db);  sqlite3_str_appendf(pSql,  "SELECT * FROM ("  "SELECT 'sqlite_schema' AS name,1 AS rootpage,'table' AS type"  " UNION ALL "  "SELECT name,rootpage,type"  " FROM \"%w\".sqlite_schema WHERE rootpage!=0)",  pTab->db->aDb[pCsr->iDb].zDbSName);  if( zName ){  sqlite3_str_appendf(pSql, "WHERE name=%Q", zName);  }  if( idxNum & 0x08 ){  sqlite3_str_appendf(pSql, " ORDER BY name");  }  zSql = sqlite3_str_finish(pSql);  if( zSql==0 ){  return SQLITE_NOMEM_BKPT;  }else{  rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pStmt, 0);  sqlite3_free(zSql);  }  if( rc==SQLITE_OK ){  pCsr->iPage = -1;  rc = statNext(pCursor);  }  return rc; } static int statColumn(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *ctx,  int i ){  StatCursor *pCsr = (StatCursor *)pCursor;  switch( i ){  case 0:  sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);  break;  case 1:  if( !pCsr->isAgg ){  sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);  }  break;  case 2:  if( pCsr->isAgg ){  sqlite3_result_int64(ctx, pCsr->nPage);  }else{  sqlite3_result_int64(ctx, pCsr->iPageno);  }  break;  case 3:  if( !pCsr->isAgg ){  sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);  }  break;  case 4:  sqlite3_result_int(ctx, pCsr->nCell);  break;  case 5:  sqlite3_result_int(ctx, pCsr->nPayload);  break;  case 6:  sqlite3_result_int(ctx, pCsr->nUnused);  break;  case 7:  sqlite3_result_int(ctx, pCsr->nMxPayload);  break;  case 8:  if( !pCsr->isAgg ){  sqlite3_result_int64(ctx, pCsr->iOffset);  }  break;  case 9:  sqlite3_result_int(ctx, pCsr->szPage);  break;  case 10: {  sqlite3 *db = sqlite3_context_db_handle(ctx);  int iDb = pCsr->iDb;  sqlite3_result_text(ctx, db->aDb[iDb].zDbSName, -1, SQLITE_STATIC);  break;  }  default: {  sqlite3_result_int(ctx, pCsr->isAgg);  break;  }  }  return SQLITE_OK; } static int statRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){  StatCursor *pCsr = (StatCursor *)pCursor;  *pRowid = pCsr->iPageno;  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3 *db){  static sqlite3_module dbstat_module = {  0,  statConnect,  statConnect,  statBestIndex,  statDisconnect,  statDisconnect,  statOpen,  statClose,  statFilter,  statNext,  statEof,  statColumn,  statRowid,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  };  return sqlite3_create_module(db, "dbstat", &dbstat_module, 0); }
#elif defined(SQLITE_ENABLE_DBSTAT_VTAB)
SQLITE_PRIVATE int sqlite3DbstatRegister(sqlite3 *db){ return SQLITE_OK; }
#endif
#if (defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST))  && !defined(SQLITE_OMIT_VIRTUALTABLE)

typedef struct DbpageTable DbpageTable; typedef struct DbpageCursor DbpageCursor; struct DbpageCursor {  sqlite3_vtab_cursor base;  int pgno;  int mxPgno;  Pager *pPager;  DbPage *pPage1;  int iDb;  int szPage; }; struct DbpageTable {  sqlite3_vtab base;  sqlite3 *db; };
#define DBPAGE_COLUMN_PGNO 0
#define DBPAGE_COLUMN_DATA 1
#define DBPAGE_COLUMN_SCHEMA 2
static int dbpageConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  DbpageTable *pTab = 0;  int rc = SQLITE_OK;  sqlite3_vtab_config(db, SQLITE_VTAB_DIRECTONLY);  rc = sqlite3_declare_vtab(db,  "CREATE TABLE x(pgno INTEGER PRIMARY KEY, data BLOB, schema HIDDEN)");  if( rc==SQLITE_OK ){  pTab = (DbpageTable *)sqlite3_malloc64(sizeof(DbpageTable));  if( pTab==0 ) rc = SQLITE_NOMEM_BKPT;  }  assert( rc==SQLITE_OK || pTab==0 );  if( rc==SQLITE_OK ){  memset(pTab, 0, sizeof(DbpageTable));  pTab->db = db;  }  *ppVtab = (sqlite3_vtab*)pTab;  return rc; } static int dbpageDisconnect(sqlite3_vtab *pVtab){  sqlite3_free(pVtab);  return SQLITE_OK; } static int dbpageBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){  int i;  int iPlan = 0;  for(i=0; i<pIdxInfo->nConstraint; i++){  struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[i];  if( p->iColumn!=DBPAGE_COLUMN_SCHEMA ) continue;  if( p->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;  if( !p->usable ){  return SQLITE_CONSTRAINT;  }  iPlan = 2;  pIdxInfo->aConstraintUsage[i].argvIndex = 1;  pIdxInfo->aConstraintUsage[i].omit = 1;  break;  }  pIdxInfo->estimatedCost = 1.0e6;  for(i=0; i<pIdxInfo->nConstraint; i++){  struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[i];  if( p->usable && p->iColumn<=0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ ){  pIdxInfo->estimatedRows = 1;  pIdxInfo->idxFlags = SQLITE_INDEX_SCAN_UNIQUE;  pIdxInfo->estimatedCost = 1.0;  pIdxInfo->aConstraintUsage[i].argvIndex = iPlan ? 2 : 1;  pIdxInfo->aConstraintUsage[i].omit = 1;  iPlan |= 1;  break;  }  }  pIdxInfo->idxNum = iPlan;  if( pIdxInfo->nOrderBy>=1   && pIdxInfo->aOrderBy[0].iColumn<=0   && pIdxInfo->aOrderBy[0].desc==0  ){  pIdxInfo->orderByConsumed = 1;  }  return SQLITE_OK; } static int dbpageOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){  DbpageCursor *pCsr;  pCsr = (DbpageCursor *)sqlite3_malloc64(sizeof(DbpageCursor));  if( pCsr==0 ){  return SQLITE_NOMEM_BKPT;  }else{  memset(pCsr, 0, sizeof(DbpageCursor));  pCsr->base.pVtab = pVTab;  pCsr->pgno = -1;  }  *ppCursor = (sqlite3_vtab_cursor *)pCsr;  return SQLITE_OK; } static int dbpageClose(sqlite3_vtab_cursor *pCursor){  DbpageCursor *pCsr = (DbpageCursor *)pCursor;  if( pCsr->pPage1 ) sqlite3PagerUnrefPageOne(pCsr->pPage1);  sqlite3_free(pCsr);  return SQLITE_OK; } static int dbpageNext(sqlite3_vtab_cursor *pCursor){  int rc = SQLITE_OK;  DbpageCursor *pCsr = (DbpageCursor *)pCursor;  pCsr->pgno++;  return rc; } static int dbpageEof(sqlite3_vtab_cursor *pCursor){  DbpageCursor *pCsr = (DbpageCursor *)pCursor;  return pCsr->pgno > pCsr->mxPgno; } static int dbpageFilter(  sqlite3_vtab_cursor *pCursor,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  DbpageCursor *pCsr = (DbpageCursor *)pCursor;  DbpageTable *pTab = (DbpageTable *)pCursor->pVtab;  int rc;  sqlite3 *db = pTab->db;  Btree *pBt;  pCsr->pgno = 1;  pCsr->mxPgno = 0;  if( idxNum & 2 ){  const char *zSchema;  assert( argc>=1 );  zSchema = (const char*)sqlite3_value_text(argv[0]);  pCsr->iDb = sqlite3FindDbName(db, zSchema);  if( pCsr->iDb<0 ) return SQLITE_OK;  }else{  pCsr->iDb = 0;  }  pBt = db->aDb[pCsr->iDb].pBt;  if( pBt==0 ) return SQLITE_OK;  pCsr->pPager = sqlite3BtreePager(pBt);  pCsr->szPage = sqlite3BtreeGetPageSize(pBt);  pCsr->mxPgno = sqlite3BtreeLastPage(pBt);  if( idxNum & 1 ){  assert( argc>(idxNum>>1) );  pCsr->pgno = sqlite3_value_int(argv[idxNum>>1]);  if( pCsr->pgno<1 || pCsr->pgno>pCsr->mxPgno ){  pCsr->pgno = 1;  pCsr->mxPgno = 0;  }else{  pCsr->mxPgno = pCsr->pgno;  }  }else{  assert( pCsr->pgno==1 );  }  if( pCsr->pPage1 ) sqlite3PagerUnrefPageOne(pCsr->pPage1);  rc = sqlite3PagerGet(pCsr->pPager, 1, &pCsr->pPage1, 0);  return rc; } static int dbpageColumn(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *ctx,  int i ){  DbpageCursor *pCsr = (DbpageCursor *)pCursor;  int rc = SQLITE_OK;  switch( i ){  case 0: {  sqlite3_result_int(ctx, pCsr->pgno);  break;  }  case 1: {  DbPage *pDbPage = 0;  rc = sqlite3PagerGet(pCsr->pPager, pCsr->pgno, (DbPage**)&pDbPage, 0);  if( rc==SQLITE_OK ){  sqlite3_result_blob(ctx, sqlite3PagerGetData(pDbPage), pCsr->szPage,  SQLITE_TRANSIENT);  }  sqlite3PagerUnref(pDbPage);  break;  }  default: {  sqlite3 *db = sqlite3_context_db_handle(ctx);  sqlite3_result_text(ctx, db->aDb[pCsr->iDb].zDbSName, -1, SQLITE_STATIC);  break;  }  }  return SQLITE_OK; } static int dbpageRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){  DbpageCursor *pCsr = (DbpageCursor *)pCursor;  *pRowid = pCsr->pgno;  return SQLITE_OK; } static int dbpageUpdate(  sqlite3_vtab *pVtab,  int argc,  sqlite3_value **argv,  sqlite_int64 *pRowid ){  DbpageTable *pTab = (DbpageTable *)pVtab;  Pgno pgno;  DbPage *pDbPage = 0;  int rc = SQLITE_OK;  char *zErr = 0;  const char *zSchema;  int iDb;  Btree *pBt;  Pager *pPager;  int szPage;  if( pTab->db->flags & SQLITE_Defensive ){  zErr = "read-only";  goto update_fail;  }  if( argc==1 ){  zErr = "cannot delete";  goto update_fail;  }  pgno = sqlite3_value_int(argv[0]);  if( (Pgno)sqlite3_value_int(argv[1])!=pgno ){  zErr = "cannot insert";  goto update_fail;  }  zSchema = (const char*)sqlite3_value_text(argv[4]);  iDb = zSchema ? sqlite3FindDbName(pTab->db, zSchema) : -1;  if( iDb<0 ){  zErr = "no such schema";  goto update_fail;  }  pBt = pTab->db->aDb[iDb].pBt;  if( pgno<1 || pBt==0 || pgno>(int)sqlite3BtreeLastPage(pBt) ){  zErr = "bad page number";  goto update_fail;  }  szPage = sqlite3BtreeGetPageSize(pBt);  if( sqlite3_value_type(argv[3])!=SQLITE_BLOB   || sqlite3_value_bytes(argv[3])!=szPage  ){  zErr = "bad page value";  goto update_fail;  }  pPager = sqlite3BtreePager(pBt);  rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pDbPage, 0);  if( rc==SQLITE_OK ){  rc = sqlite3PagerWrite(pDbPage);  if( rc==SQLITE_OK ){  memcpy(sqlite3PagerGetData(pDbPage),   sqlite3_value_blob(argv[3]),   szPage);  }  }  sqlite3PagerUnref(pDbPage);  return rc; update_fail:  sqlite3_free(pVtab->zErrMsg);  pVtab->zErrMsg = sqlite3_mprintf("%s", zErr);  return SQLITE_ERROR; } static int dbpageBegin(sqlite3_vtab *pVtab){  DbpageTable *pTab = (DbpageTable *)pVtab;  sqlite3 *db = pTab->db;  int i;  for(i=0; i<db->nDb; i++){  Btree *pBt = db->aDb[i].pBt;  if( pBt ) sqlite3BtreeBeginTrans(pBt, 1, 0);  }  return SQLITE_OK; } SQLITE_PRIVATE int sqlite3DbpageRegister(sqlite3 *db){  static sqlite3_module dbpage_module = {  0,  dbpageConnect,  dbpageConnect,  dbpageBestIndex,  dbpageDisconnect,  dbpageDisconnect,  dbpageOpen,  dbpageClose,  dbpageFilter,  dbpageNext,  dbpageEof,  dbpageColumn,  dbpageRowid,  dbpageUpdate,  dbpageBegin,  0,  0,  0,  0,  0,  0,  0,  0,  0  };  return sqlite3_create_module(db, "sqlite_dbpage", &dbpage_module, 0); }
#elif defined(SQLITE_ENABLE_DBPAGE_VTAB)
SQLITE_PRIVATE int sqlite3DbpageRegister(sqlite3 *db){ return SQLITE_OK; }
#endif
#if defined(SQLITE_ENABLE_SESSION) && defined(SQLITE_ENABLE_PREUPDATE_HOOK)
#ifndef SQLITE_AMALGAMATION
#endif
typedef struct SessionTable SessionTable; typedef struct SessionChange SessionChange; typedef struct SessionBuffer SessionBuffer; typedef struct SessionInput SessionInput;
#ifndef SESSIONS_STRM_CHUNK_SIZE
# ifdef SQLITE_TEST
#  define SESSIONS_STRM_CHUNK_SIZE 64
# else
#  define SESSIONS_STRM_CHUNK_SIZE 1024
# endif
#endif
static int sessions_strm_chunk_size = SESSIONS_STRM_CHUNK_SIZE; typedef struct SessionHook SessionHook; struct SessionHook {  void *pCtx;  int (*xOld)(void*,int,sqlite3_value**);  int (*xNew)(void*,int,sqlite3_value**);  int (*xCount)(void*);  int (*xDepth)(void*); }; struct sqlite3_session {  sqlite3 *db;  char *zDb;  int bEnableSize;  int bEnable;  int bIndirect;  int bAutoAttach;  int rc;  void *pFilterCtx;  int (*xTableFilter)(void *pCtx, const char *zTab);  i64 nMalloc;  i64 nMaxChangesetSize;  sqlite3_value *pZeroBlob;  sqlite3_session *pNext;  SessionTable *pTable;  SessionHook hook; }; struct SessionBuffer {  u8 *aBuf;  int nBuf;  int nAlloc; }; struct SessionInput {  int bNoDiscard;  int iCurrent;  int iNext;  u8 *aData;  int nData;  SessionBuffer buf;  int (*xInput)(void*, void*, int*);  void *pIn;  int bEof; }; struct sqlite3_changeset_iter {  SessionInput in;  SessionBuffer tblhdr;  int bPatchset;  int bInvert;  int bSkipEmpty;  int rc;  sqlite3_stmt *pConflict;  char *zTab;  int nCol;  int op;  int bIndirect;  u8 *abPK;  sqlite3_value **apValue; }; struct SessionTable {  SessionTable *pNext;  char *zName;  int nCol;  int bStat1;  const char **azCol;  u8 *abPK;  int nEntry;  int nChange;  SessionChange **apChange; }; struct SessionChange {  u8 op;  u8 bIndirect;  int nMaxSize;  int nRecord;  u8 *aRecord;  SessionChange *pNext; }; static int sessionVarintPut(u8 *aBuf, int iVal){  return putVarint32(aBuf, iVal); } static int sessionVarintLen(int iVal){  return sqlite3VarintLen(iVal); } static int sessionVarintGet(u8 *aBuf, int *piVal){  return getVarint32(aBuf, *piVal); }
#define SESSION_UINT32(x) (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
static sqlite3_int64 sessionGetI64(u8 *aRec){  u64 x = SESSION_UINT32(aRec);  u32 y = SESSION_UINT32(aRec+4);  x = (x<<32) + y;  return (sqlite3_int64)x; } static void sessionPutI64(u8 *aBuf, sqlite3_int64 i){  aBuf[0] = (i>>56) & 0xFF;  aBuf[1] = (i>>48) & 0xFF;  aBuf[2] = (i>>40) & 0xFF;  aBuf[3] = (i>>32) & 0xFF;  aBuf[4] = (i>>24) & 0xFF;  aBuf[5] = (i>>16) & 0xFF;  aBuf[6] = (i>> 8) & 0xFF;  aBuf[7] = (i>> 0) & 0xFF; } static int sessionSerializeValue(  u8 *aBuf,  sqlite3_value *pValue,  sqlite3_int64 *pnWrite ){  int nByte;  if( pValue ){  int eType;  eType = sqlite3_value_type(pValue);  if( aBuf ) aBuf[0] = eType;  switch( eType ){  case SQLITE_NULL:  nByte = 1;  break;  case SQLITE_INTEGER:  case SQLITE_FLOAT:  if( aBuf ){  u64 i;  if( eType==SQLITE_INTEGER ){  i = (u64)sqlite3_value_int64(pValue);  }else{  double r;  assert( sizeof(double)==8 && sizeof(u64)==8 );  r = sqlite3_value_double(pValue);  memcpy(&i, &r, 8);  }  sessionPutI64(&aBuf[1], i);  }  nByte = 9;  break;  default: {  u8 *z;  int n;  int nVarint;  assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );  if( eType==SQLITE_TEXT ){  z = (u8 *)sqlite3_value_text(pValue);  }else{  z = (u8 *)sqlite3_value_blob(pValue);  }  n = sqlite3_value_bytes(pValue);  if( z==0 && (eType!=SQLITE_BLOB || n>0) ) return SQLITE_NOMEM;  nVarint = sessionVarintLen(n);  if( aBuf ){  sessionVarintPut(&aBuf[1], n);  if( n>0 ) memcpy(&aBuf[nVarint + 1], z, n);  }  nByte = 1 + nVarint + n;  break;  }  }  }else{  nByte = 1;  if( aBuf ) aBuf[0] = '\0';  }  if( pnWrite ) *pnWrite += nByte;  return SQLITE_OK; } static void *sessionMalloc64(sqlite3_session *pSession, i64 nByte){  void *pRet = sqlite3_malloc64(nByte);  if( pSession ) pSession->nMalloc += sqlite3_msize(pRet);  return pRet; } static void sessionFree(sqlite3_session *pSession, void *pFree){  if( pSession ) pSession->nMalloc -= sqlite3_msize(pFree);  sqlite3_free(pFree); }
#define HASH_APPEND(hash, add) ((hash) << 3) ^ (hash) ^ (unsigned int)(add)
static unsigned int sessionHashAppendI64(unsigned int h, i64 i){  h = HASH_APPEND(h, i & 0xFFFFFFFF);  return HASH_APPEND(h, (i>>32)&0xFFFFFFFF); } static unsigned int sessionHashAppendBlob(unsigned int h, int n, const u8 *z){  int i;  for(i=0; i<n; i++) h = HASH_APPEND(h, z[i]);  return h; } static unsigned int sessionHashAppendType(unsigned int h, int eType){  return HASH_APPEND(h, eType); } static int sessionPreupdateHash(  sqlite3_session *pSession,  SessionTable *pTab,  int bNew,  int *piHash,  int *pbNullPK ){  unsigned int h = 0;  int i;  assert( *pbNullPK==0 );  assert( pTab->nCol==pSession->hook.xCount(pSession->hook.pCtx) );  for(i=0; i<pTab->nCol; i++){  if( pTab->abPK[i] ){  int rc;  int eType;  sqlite3_value *pVal;  if( bNew ){  rc = pSession->hook.xNew(pSession->hook.pCtx, i, &pVal);  }else{  rc = pSession->hook.xOld(pSession->hook.pCtx, i, &pVal);  }  if( rc!=SQLITE_OK ) return rc;  eType = sqlite3_value_type(pVal);  h = sessionHashAppendType(h, eType);  if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  i64 iVal;  if( eType==SQLITE_INTEGER ){  iVal = sqlite3_value_int64(pVal);  }else{  double rVal = sqlite3_value_double(pVal);  assert( sizeof(iVal)==8 && sizeof(rVal)==8 );  memcpy(&iVal, &rVal, 8);  }  h = sessionHashAppendI64(h, iVal);  }else if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){  const u8 *z;  int n;  if( eType==SQLITE_TEXT ){  z = (const u8 *)sqlite3_value_text(pVal);  }else{  z = (const u8 *)sqlite3_value_blob(pVal);  }  n = sqlite3_value_bytes(pVal);  if( !z && (eType!=SQLITE_BLOB || n>0) ) return SQLITE_NOMEM;  h = sessionHashAppendBlob(h, n, z);  }else{  assert( eType==SQLITE_NULL );  assert( pTab->bStat1==0 || i!=1 );  *pbNullPK = 1;  }  }  }  *piHash = (h % pTab->nChange);  return SQLITE_OK; } static int sessionSerialLen(u8 *a){  int e = *a;  int n;  if( e==0 || e==0xFF ) return 1;  if( e==SQLITE_NULL ) return 1;  if( e==SQLITE_INTEGER || e==SQLITE_FLOAT ) return 9;  return sessionVarintGet(&a[1], &n) + 1 + n; } static unsigned int sessionChangeHash(  SessionTable *pTab,  int bPkOnly,  u8 *aRecord,  int nBucket ){  unsigned int h = 0;  int i;  u8 *a = aRecord;  for(i=0; i<pTab->nCol; i++){  int eType = *a;  int isPK = pTab->abPK[i];  if( bPkOnly && isPK==0 ) continue;  assert( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT   || eType==SQLITE_TEXT || eType==SQLITE_BLOB   || eType==SQLITE_NULL || eType==0  );  assert( !isPK || (eType!=0 && eType!=SQLITE_NULL) );  if( isPK ){  a++;  h = sessionHashAppendType(h, eType);  if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  h = sessionHashAppendI64(h, sessionGetI64(a));  a += 8;  }else{  int n;  a += sessionVarintGet(a, &n);  h = sessionHashAppendBlob(h, n, a);  a += n;  }  }else{  a += sessionSerialLen(a);  }  }  return (h % nBucket); } static int sessionChangeEqual(  SessionTable *pTab,  int bLeftPkOnly,  u8 *aLeft,  int bRightPkOnly,  u8 *aRight ){  u8 *a1 = aLeft;  u8 *a2 = aRight;  int iCol;  for(iCol=0; iCol<pTab->nCol; iCol++){  if( pTab->abPK[iCol] ){  int n1 = sessionSerialLen(a1);  int n2 = sessionSerialLen(a2);  if( n1!=n2 || memcmp(a1, a2, n1) ){  return 0;  }  a1 += n1;  a2 += n2;  }else{  if( bLeftPkOnly==0 ) a1 += sessionSerialLen(a1);  if( bRightPkOnly==0 ) a2 += sessionSerialLen(a2);  }  }  return 1; } static void sessionMergeRecord(  u8 **paOut,  int nCol,  u8 *aLeft,  u8 *aRight ){  u8 *a1 = aLeft;  u8 *a2 = aRight;  u8 *aOut = *paOut;  int iCol;  for(iCol=0; iCol<nCol; iCol++){  int n1 = sessionSerialLen(a1);  int n2 = sessionSerialLen(a2);  if( *a2 ){  memcpy(aOut, a2, n2);  aOut += n2;  }else{  memcpy(aOut, a1, n1);  aOut += n1;  }  a1 += n1;  a2 += n2;  }  *paOut = aOut; } static u8 *sessionMergeValue(  u8 **paOne,  u8 **paTwo,  int *pnVal ){  u8 *a1 = *paOne;  u8 *a2 = *paTwo;  u8 *pRet = 0;  int n1;  assert( a1 );  if( a2 ){  int n2 = sessionSerialLen(a2);  if( *a2 ){  *pnVal = n2;  pRet = a2;  }  *paTwo = &a2[n2];  }  n1 = sessionSerialLen(a1);  if( pRet==0 ){  *pnVal = n1;  pRet = a1;  }  *paOne = &a1[n1];  return pRet; } static int sessionMergeUpdate(  u8 **paOut,  SessionTable *pTab,  int bPatchset,  u8 *aOldRecord1,  u8 *aOldRecord2,  u8 *aNewRecord1,  u8 *aNewRecord2 ){  u8 *aOld1 = aOldRecord1;  u8 *aOld2 = aOldRecord2;  u8 *aNew1 = aNewRecord1;  u8 *aNew2 = aNewRecord2;  u8 *aOut = *paOut;  int i;  if( bPatchset==0 ){  int bRequired = 0;  assert( aOldRecord1 && aNewRecord1 );  for(i=0; i<pTab->nCol; i++){  int nOld;  u8 *aOld;  int nNew;  u8 *aNew;  aOld = sessionMergeValue(&aOld1, &aOld2, &nOld);  aNew = sessionMergeValue(&aNew1, &aNew2, &nNew);  if( pTab->abPK[i] || nOld!=nNew || memcmp(aOld, aNew, nNew) ){  if( pTab->abPK[i]==0 ) bRequired = 1;  memcpy(aOut, aOld, nOld);  aOut += nOld;  }else{  *(aOut++) = '\0';  }  }  if( !bRequired ) return 0;  }  aOld1 = aOldRecord1;  aOld2 = aOldRecord2;  aNew1 = aNewRecord1;  aNew2 = aNewRecord2;  for(i=0; i<pTab->nCol; i++){  int nOld;  u8 *aOld;  int nNew;  u8 *aNew;  aOld = sessionMergeValue(&aOld1, &aOld2, &nOld);  aNew = sessionMergeValue(&aNew1, &aNew2, &nNew);  if( bPatchset==0   && (pTab->abPK[i] || (nOld==nNew && 0==memcmp(aOld, aNew, nNew)))  ){  *(aOut++) = '\0';  }else{  memcpy(aOut, aNew, nNew);  aOut += nNew;  }  }  *paOut = aOut;  return 1; } static int sessionPreupdateEqual(  sqlite3_session *pSession,  SessionTable *pTab,  SessionChange *pChange,  int op ){  int iCol;  u8 *a = pChange->aRecord;  assert( op==SQLITE_INSERT || op==SQLITE_UPDATE || op==SQLITE_DELETE );  for(iCol=0; iCol<pTab->nCol; iCol++){  if( !pTab->abPK[iCol] ){  a += sessionSerialLen(a);  }else{  sqlite3_value *pVal;  int rc;  int eType = *a++;  if( op==SQLITE_INSERT ){  rc = pSession->hook.xNew(pSession->hook.pCtx, iCol, &pVal);  }else{  rc = pSession->hook.xOld(pSession->hook.pCtx, iCol, &pVal);  }  assert( rc==SQLITE_OK );  if( sqlite3_value_type(pVal)!=eType ) return 0;  assert( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT   || eType==SQLITE_BLOB || eType==SQLITE_TEXT  );  if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  i64 iVal = sessionGetI64(a);  a += 8;  if( eType==SQLITE_INTEGER ){  if( sqlite3_value_int64(pVal)!=iVal ) return 0;  }else{  double rVal;  assert( sizeof(iVal)==8 && sizeof(rVal)==8 );  memcpy(&rVal, &iVal, 8);  if( sqlite3_value_double(pVal)!=rVal ) return 0;  }  }else{  int n;  const u8 *z;  a += sessionVarintGet(a, &n);  if( sqlite3_value_bytes(pVal)!=n ) return 0;  if( eType==SQLITE_TEXT ){  z = sqlite3_value_text(pVal);  }else{  z = sqlite3_value_blob(pVal);  }  if( n>0 && memcmp(a, z, n) ) return 0;  a += n;  }  }  }  return 1; } static int sessionGrowHash(  sqlite3_session *pSession,  int bPatchset,  SessionTable *pTab ){  if( pTab->nChange==0 || pTab->nEntry>=(pTab->nChange/2) ){  int i;  SessionChange **apNew;  sqlite3_int64 nNew = 2*(sqlite3_int64)(pTab->nChange ? pTab->nChange : 128);  apNew = (SessionChange**)sessionMalloc64(  pSession, sizeof(SessionChange*) * nNew  );  if( apNew==0 ){  if( pTab->nChange==0 ){  return SQLITE_ERROR;  }  return SQLITE_OK;  }  memset(apNew, 0, sizeof(SessionChange *) * nNew);  for(i=0; i<pTab->nChange; i++){  SessionChange *p;  SessionChange *pNext;  for(p=pTab->apChange[i]; p; p=pNext){  int bPkOnly = (p->op==SQLITE_DELETE && bPatchset);  int iHash = sessionChangeHash(pTab, bPkOnly, p->aRecord, nNew);  pNext = p->pNext;  p->pNext = apNew[iHash];  apNew[iHash] = p;  }  }  sessionFree(pSession, pTab->apChange);  pTab->nChange = nNew;  pTab->apChange = apNew;  }  return SQLITE_OK; } static int sessionTableInfo(  sqlite3_session *pSession,  sqlite3 *db,  const char *zDb,  const char *zThis,  int *pnCol,  const char **pzTab,  const char ***pazCol,  u8 **pabPK ){  char *zPragma;  sqlite3_stmt *pStmt;  int rc;  sqlite3_int64 nByte;  int nDbCol = 0;  int nThis;  int i;  u8 *pAlloc = 0;  char **azCol = 0;  u8 *abPK = 0;  assert( pazCol && pabPK );  nThis = sqlite3Strlen30(zThis);  if( nThis==12 && 0==sqlite3_stricmp("sqlite_stat1", zThis) ){  rc = sqlite3_table_column_metadata(db, zDb, zThis, 0, 0, 0, 0, 0, 0);  if( rc==SQLITE_OK ){  zPragma = sqlite3_mprintf(  "SELECT 0, 'tbl', '', 0, '', 1  UNION ALL "  "SELECT 1, 'idx', '', 0, '', 2  UNION ALL "  "SELECT 2, 'stat', '', 0, '', 0"  );  }else if( rc==SQLITE_ERROR ){  zPragma = sqlite3_mprintf("");  }else{  *pazCol = 0;  *pabPK = 0;  *pnCol = 0;  if( pzTab ) *pzTab = 0;  return rc;  }  }else{  zPragma = sqlite3_mprintf("PRAGMA '%q'.table_info('%q')", zDb, zThis);  }  if( !zPragma ){  *pazCol = 0;  *pabPK = 0;  *pnCol = 0;  if( pzTab ) *pzTab = 0;  return SQLITE_NOMEM;  }  rc = sqlite3_prepare_v2(db, zPragma, -1, &pStmt, 0);  sqlite3_free(zPragma);  if( rc!=SQLITE_OK ){  *pazCol = 0;  *pabPK = 0;  *pnCol = 0;  if( pzTab ) *pzTab = 0;  return rc;  }  nByte = nThis + 1;  while( SQLITE_ROW==sqlite3_step(pStmt) ){  nByte += sqlite3_column_bytes(pStmt, 1);  nDbCol++;  }  rc = sqlite3_reset(pStmt);  if( rc==SQLITE_OK ){  nByte += nDbCol * (sizeof(const char *) + sizeof(u8) + 1);  pAlloc = sessionMalloc64(pSession, nByte);  if( pAlloc==0 ){  rc = SQLITE_NOMEM;  }  }  if( rc==SQLITE_OK ){  azCol = (char **)pAlloc;  pAlloc = (u8 *)&azCol[nDbCol];  abPK = (u8 *)pAlloc;  pAlloc = &abPK[nDbCol];  if( pzTab ){  memcpy(pAlloc, zThis, nThis+1);  *pzTab = (char *)pAlloc;  pAlloc += nThis+1;  }  i = 0;  while( SQLITE_ROW==sqlite3_step(pStmt) ){  int nName = sqlite3_column_bytes(pStmt, 1);  const unsigned char *zName = sqlite3_column_text(pStmt, 1);  if( zName==0 ) break;  memcpy(pAlloc, zName, nName+1);  azCol[i] = (char *)pAlloc;  pAlloc += nName+1;  abPK[i] = sqlite3_column_int(pStmt, 5);  i++;  }  rc = sqlite3_reset(pStmt);  }  if( rc==SQLITE_OK ){  *pazCol = (const char **)azCol;  *pabPK = abPK;  *pnCol = nDbCol;  }else{  *pazCol = 0;  *pabPK = 0;  *pnCol = 0;  if( pzTab ) *pzTab = 0;  sessionFree(pSession, azCol);  }  sqlite3_finalize(pStmt);  return rc; } static int sessionInitTable(sqlite3_session *pSession, SessionTable *pTab){  if( pTab->nCol==0 ){  u8 *abPK;  assert( pTab->azCol==0 || pTab->abPK==0 );  pSession->rc = sessionTableInfo(pSession, pSession->db, pSession->zDb,  pTab->zName, &pTab->nCol, 0, &pTab->azCol, &abPK  );  if( pSession->rc==SQLITE_OK ){  int i;  for(i=0; i<pTab->nCol; i++){  if( abPK[i] ){  pTab->abPK = abPK;  break;  }  }  if( 0==sqlite3_stricmp("sqlite_stat1", pTab->zName) ){  pTab->bStat1 = 1;  }  if( pSession->bEnableSize ){  pSession->nMaxChangesetSize += (  1 + sessionVarintLen(pTab->nCol) + pTab->nCol + strlen(pTab->zName)+1  );  }  }  }  return (pSession->rc || pTab->abPK==0); } typedef struct SessionStat1Ctx SessionStat1Ctx; struct SessionStat1Ctx {  SessionHook hook;  sqlite3_session *pSession; }; static int sessionStat1Old(void *pCtx, int iCol, sqlite3_value **ppVal){  SessionStat1Ctx *p = (SessionStat1Ctx*)pCtx;  sqlite3_value *pVal = 0;  int rc = p->hook.xOld(p->hook.pCtx, iCol, &pVal);  if( rc==SQLITE_OK && iCol==1 && sqlite3_value_type(pVal)==SQLITE_NULL ){  pVal = p->pSession->pZeroBlob;  }  *ppVal = pVal;  return rc; } static int sessionStat1New(void *pCtx, int iCol, sqlite3_value **ppVal){  SessionStat1Ctx *p = (SessionStat1Ctx*)pCtx;  sqlite3_value *pVal = 0;  int rc = p->hook.xNew(p->hook.pCtx, iCol, &pVal);  if( rc==SQLITE_OK && iCol==1 && sqlite3_value_type(pVal)==SQLITE_NULL ){  pVal = p->pSession->pZeroBlob;  }  *ppVal = pVal;  return rc; } static int sessionStat1Count(void *pCtx){  SessionStat1Ctx *p = (SessionStat1Ctx*)pCtx;  return p->hook.xCount(p->hook.pCtx); } static int sessionStat1Depth(void *pCtx){  SessionStat1Ctx *p = (SessionStat1Ctx*)pCtx;  return p->hook.xDepth(p->hook.pCtx); } static int sessionUpdateMaxSize(  int op,  sqlite3_session *pSession,  SessionTable *pTab,  SessionChange *pC ){  i64 nNew = 2;  if( pC->op==SQLITE_INSERT ){  if( op!=SQLITE_DELETE ){  int ii;  for(ii=0; ii<pTab->nCol; ii++){  sqlite3_value *p = 0;  pSession->hook.xNew(pSession->hook.pCtx, ii, &p);  sessionSerializeValue(0, p, &nNew);  }  }  }else if( op==SQLITE_DELETE ){  nNew += pC->nRecord;  if( sqlite3_preupdate_blobwrite(pSession->db)>=0 ){  nNew += pC->nRecord;  }  }else{  int ii;  u8 *pCsr = pC->aRecord;  for(ii=0; ii<pTab->nCol; ii++){  int bChanged = 1;  int nOld = 0;  int eType;  sqlite3_value *p = 0;  pSession->hook.xNew(pSession->hook.pCtx, ii, &p);  if( p==0 ){  return SQLITE_NOMEM;  }  eType = *pCsr++;  switch( eType ){  case SQLITE_NULL:  bChanged = sqlite3_value_type(p)!=SQLITE_NULL;  break;  case SQLITE_FLOAT:  case SQLITE_INTEGER: {  if( eType==sqlite3_value_type(p) ){  sqlite3_int64 iVal = sessionGetI64(pCsr);  if( eType==SQLITE_INTEGER ){  bChanged = (iVal!=sqlite3_value_int64(p));  }else{  double dVal;  memcpy(&dVal, &iVal, 8);  bChanged = (dVal!=sqlite3_value_double(p));  }  }  nOld = 8;  pCsr += 8;  break;  }  default: {  int nByte;  nOld = sessionVarintGet(pCsr, &nByte);  pCsr += nOld;  nOld += nByte;  assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );  if( eType==sqlite3_value_type(p)   && nByte==sqlite3_value_bytes(p)   && (nByte==0 || 0==memcmp(pCsr, sqlite3_value_blob(p), nByte))  ){  bChanged = 0;  }  pCsr += nByte;  break;  }  }  if( bChanged && pTab->abPK[ii] ){  nNew = pC->nRecord + 2;  break;  }  if( bChanged ){  nNew += 1 + nOld;  sessionSerializeValue(0, p, &nNew);  }else if( pTab->abPK[ii] ){  nNew += 2 + nOld;  }else{  nNew += 2;  }  }  }  if( nNew>pC->nMaxSize ){  int nIncr = nNew - pC->nMaxSize;  pC->nMaxSize = nNew;  pSession->nMaxChangesetSize += nIncr;  }  return SQLITE_OK; } static void sessionPreupdateOneChange(  int op,  sqlite3_session *pSession,  SessionTable *pTab ){  int iHash;  int bNull = 0;  int rc = SQLITE_OK;  SessionStat1Ctx stat1 = {{0,0,0,0,0},0};  if( pSession->rc ) return;  if( sessionInitTable(pSession, pTab) ) return;  if( pTab->nCol!=pSession->hook.xCount(pSession->hook.pCtx) ){  pSession->rc = SQLITE_SCHEMA;  return;  }  if( sessionGrowHash(pSession, 0, pTab) ){  pSession->rc = SQLITE_NOMEM;  return;  }  if( pTab->bStat1 ){  stat1.hook = pSession->hook;  stat1.pSession = pSession;  pSession->hook.pCtx = (void*)&stat1;  pSession->hook.xNew = sessionStat1New;  pSession->hook.xOld = sessionStat1Old;  pSession->hook.xCount = sessionStat1Count;  pSession->hook.xDepth = sessionStat1Depth;  if( pSession->pZeroBlob==0 ){  sqlite3_value *p = sqlite3ValueNew(0);  if( p==0 ){  rc = SQLITE_NOMEM;  goto error_out;  }  sqlite3ValueSetStr(p, 0, "", 0, SQLITE_STATIC);  pSession->pZeroBlob = p;  }  }  rc = sessionPreupdateHash(pSession, pTab, op==SQLITE_INSERT, &iHash, &bNull);  if( rc!=SQLITE_OK ) goto error_out;  if( bNull==0 ){  SessionChange *pC;  for(pC=pTab->apChange[iHash]; pC; pC=pC->pNext){  if( sessionPreupdateEqual(pSession, pTab, pC, op) ) break;  }  if( pC==0 ){  sqlite3_int64 nByte;  int i;  assert( rc==SQLITE_OK );  pTab->nEntry++;  nByte = sizeof(SessionChange);  for(i=0; i<pTab->nCol; i++){  sqlite3_value *p = 0;  if( op!=SQLITE_INSERT ){  TESTONLY(int trc = ) pSession->hook.xOld(pSession->hook.pCtx, i, &p);  assert( trc==SQLITE_OK );  }else if( pTab->abPK[i] ){  TESTONLY(int trc = ) pSession->hook.xNew(pSession->hook.pCtx, i, &p);  assert( trc==SQLITE_OK );  }  rc = sessionSerializeValue(0, p, &nByte);  if( rc!=SQLITE_OK ) goto error_out;  }  pC = (SessionChange *)sessionMalloc64(pSession, nByte);  if( !pC ){  rc = SQLITE_NOMEM;  goto error_out;  }else{  memset(pC, 0, sizeof(SessionChange));  pC->aRecord = (u8 *)&pC[1];  }  nByte = 0;  for(i=0; i<pTab->nCol; i++){  sqlite3_value *p = 0;  if( op!=SQLITE_INSERT ){  pSession->hook.xOld(pSession->hook.pCtx, i, &p);  }else if( pTab->abPK[i] ){  pSession->hook.xNew(pSession->hook.pCtx, i, &p);  }  sessionSerializeValue(&pC->aRecord[nByte], p, &nByte);  }  if( pSession->bIndirect || pSession->hook.xDepth(pSession->hook.pCtx) ){  pC->bIndirect = 1;  }  pC->nRecord = nByte;  pC->op = op;  pC->pNext = pTab->apChange[iHash];  pTab->apChange[iHash] = pC;  }else if( pC->bIndirect ){  if( pSession->hook.xDepth(pSession->hook.pCtx)==0   && pSession->bIndirect==0  ){  pC->bIndirect = 0;  }  }  assert( rc==SQLITE_OK );  if( pSession->bEnableSize ){  rc = sessionUpdateMaxSize(op, pSession, pTab, pC);  }  }  error_out:  if( pTab->bStat1 ){  pSession->hook = stat1.hook;  }  if( rc!=SQLITE_OK ){  pSession->rc = rc;  } } static int sessionFindTable(  sqlite3_session *pSession,  const char *zName,  SessionTable **ppTab ){  int rc = SQLITE_OK;  int nName = sqlite3Strlen30(zName);  SessionTable *pRet;  for(pRet=pSession->pTable; pRet; pRet=pRet->pNext){  if( 0==sqlite3_strnicmp(pRet->zName, zName, nName+1) ) break;  }  if( pRet==0 && pSession->bAutoAttach ){  if( pSession->xTableFilter==0   || pSession->xTableFilter(pSession->pFilterCtx, zName)  ){  rc = sqlite3session_attach(pSession, zName);  if( rc==SQLITE_OK ){  pRet = pSession->pTable;  while( ALWAYS(pRet) && pRet->pNext ){  pRet = pRet->pNext;  }  assert( pRet!=0 );  assert( 0==sqlite3_strnicmp(pRet->zName, zName, nName+1) );  }  }  }  assert( rc==SQLITE_OK || pRet==0 );  *ppTab = pRet;  return rc; } static void xPreUpdate(  void *pCtx,  sqlite3 *db,  int op,  char const *zDb,  char const *zName,  sqlite3_int64 iKey1,  sqlite3_int64 iKey2 ){  sqlite3_session *pSession;  int nDb = sqlite3Strlen30(zDb);  assert( sqlite3_mutex_held(db->mutex) );  for(pSession=(sqlite3_session *)pCtx; pSession; pSession=pSession->pNext){  SessionTable *pTab;  if( pSession->bEnable==0 ) continue;  if( pSession->rc ) continue;  if( sqlite3_strnicmp(zDb, pSession->zDb, nDb+1) ) continue;  pSession->rc = sessionFindTable(pSession, zName, &pTab);  if( pTab ){  assert( pSession->rc==SQLITE_OK );  sessionPreupdateOneChange(op, pSession, pTab);  if( op==SQLITE_UPDATE ){  sessionPreupdateOneChange(SQLITE_INSERT, pSession, pTab);  }  }  } } static int sessionPreupdateOld(void *pCtx, int iVal, sqlite3_value **ppVal){  return sqlite3_preupdate_old((sqlite3*)pCtx, iVal, ppVal); } static int sessionPreupdateNew(void *pCtx, int iVal, sqlite3_value **ppVal){  return sqlite3_preupdate_new((sqlite3*)pCtx, iVal, ppVal); } static int sessionPreupdateCount(void *pCtx){  return sqlite3_preupdate_count((sqlite3*)pCtx); } static int sessionPreupdateDepth(void *pCtx){  return sqlite3_preupdate_depth((sqlite3*)pCtx); } static void sessionPreupdateHooks(  sqlite3_session *pSession ){  pSession->hook.pCtx = (void*)pSession->db;  pSession->hook.xOld = sessionPreupdateOld;  pSession->hook.xNew = sessionPreupdateNew;  pSession->hook.xCount = sessionPreupdateCount;  pSession->hook.xDepth = sessionPreupdateDepth; } typedef struct SessionDiffCtx SessionDiffCtx; struct SessionDiffCtx {  sqlite3_stmt *pStmt;  int nOldOff; }; static int sessionDiffOld(void *pCtx, int iVal, sqlite3_value **ppVal){  SessionDiffCtx *p = (SessionDiffCtx*)pCtx;  *ppVal = sqlite3_column_value(p->pStmt, iVal+p->nOldOff);  return SQLITE_OK; } static int sessionDiffNew(void *pCtx, int iVal, sqlite3_value **ppVal){  SessionDiffCtx *p = (SessionDiffCtx*)pCtx;  *ppVal = sqlite3_column_value(p->pStmt, iVal);   return SQLITE_OK; } static int sessionDiffCount(void *pCtx){  SessionDiffCtx *p = (SessionDiffCtx*)pCtx;  return p->nOldOff ? p->nOldOff : sqlite3_column_count(p->pStmt); } static int sessionDiffDepth(void *pCtx){  return 0; } static void sessionDiffHooks(  sqlite3_session *pSession,  SessionDiffCtx *pDiffCtx ){  pSession->hook.pCtx = (void*)pDiffCtx;  pSession->hook.xOld = sessionDiffOld;  pSession->hook.xNew = sessionDiffNew;  pSession->hook.xCount = sessionDiffCount;  pSession->hook.xDepth = sessionDiffDepth; } static char *sessionExprComparePK(  int nCol,  const char *zDb1, const char *zDb2,  const char *zTab,  const char **azCol, u8 *abPK ){  int i;  const char *zSep = "";  char *zRet = 0;  for(i=0; i<nCol; i++){  if( abPK[i] ){  zRet = sqlite3_mprintf("%z%s\"%w\".\"%w\".\"%w\"=\"%w\".\"%w\".\"%w\"",  zRet, zSep, zDb1, zTab, azCol[i], zDb2, zTab, azCol[i]  );  zSep = " AND ";  if( zRet==0 ) break;  }  }  return zRet; } static char *sessionExprCompareOther(  int nCol,  const char *zDb1, const char *zDb2,  const char *zTab,  const char **azCol, u8 *abPK ){  int i;  const char *zSep = "";  char *zRet = 0;  int bHave = 0;  for(i=0; i<nCol; i++){  if( abPK[i]==0 ){  bHave = 1;  zRet = sqlite3_mprintf(  "%z%s\"%w\".\"%w\".\"%w\" IS NOT \"%w\".\"%w\".\"%w\"",  zRet, zSep, zDb1, zTab, azCol[i], zDb2, zTab, azCol[i]  );  zSep = " OR ";  if( zRet==0 ) break;  }  }  if( bHave==0 ){  assert( zRet==0 );  zRet = sqlite3_mprintf("0");  }  return zRet; } static char *sessionSelectFindNew(  int nCol,  const char *zDb1,  const char *zDb2,  const char *zTbl,  const char *zExpr ){  char *zRet = sqlite3_mprintf(  "SELECT * FROM \"%w\".\"%w\" WHERE NOT EXISTS ("  " SELECT 1 FROM \"%w\".\"%w\" WHERE %s"  ")",  zDb1, zTbl, zDb2, zTbl, zExpr  );  return zRet; } static int sessionDiffFindNew(  int op,  sqlite3_session *pSession,  SessionTable *pTab,  const char *zDb1,  const char *zDb2,  char *zExpr ){  int rc = SQLITE_OK;  char *zStmt = sessionSelectFindNew(pTab->nCol, zDb1, zDb2, pTab->zName,zExpr);  if( zStmt==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_stmt *pStmt;  rc = sqlite3_prepare(pSession->db, zStmt, -1, &pStmt, 0);  if( rc==SQLITE_OK ){  SessionDiffCtx *pDiffCtx = (SessionDiffCtx*)pSession->hook.pCtx;  pDiffCtx->pStmt = pStmt;  pDiffCtx->nOldOff = 0;  while( SQLITE_ROW==sqlite3_step(pStmt) ){  sessionPreupdateOneChange(op, pSession, pTab);  }  rc = sqlite3_finalize(pStmt);  }  sqlite3_free(zStmt);  }  return rc; } static int sessionDiffFindModified(  sqlite3_session *pSession,  SessionTable *pTab,  const char *zFrom,  const char *zExpr ){  int rc = SQLITE_OK;  char *zExpr2 = sessionExprCompareOther(pTab->nCol,  pSession->zDb, zFrom, pTab->zName, pTab->azCol, pTab->abPK  );  if( zExpr2==0 ){  rc = SQLITE_NOMEM;  }else{  char *zStmt = sqlite3_mprintf(  "SELECT * FROM \"%w\".\"%w\", \"%w\".\"%w\" WHERE %s AND (%z)",  pSession->zDb, pTab->zName, zFrom, pTab->zName, zExpr, zExpr2  );  if( zStmt==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_stmt *pStmt;  rc = sqlite3_prepare(pSession->db, zStmt, -1, &pStmt, 0);  if( rc==SQLITE_OK ){  SessionDiffCtx *pDiffCtx = (SessionDiffCtx*)pSession->hook.pCtx;  pDiffCtx->pStmt = pStmt;  pDiffCtx->nOldOff = pTab->nCol;  while( SQLITE_ROW==sqlite3_step(pStmt) ){  sessionPreupdateOneChange(SQLITE_UPDATE, pSession, pTab);  }  rc = sqlite3_finalize(pStmt);  }  sqlite3_free(zStmt);  }  }  return rc; } SQLITE_API int sqlite3session_diff(  sqlite3_session *pSession,  const char *zFrom,  const char *zTbl,  char **pzErrMsg ){  const char *zDb = pSession->zDb;  int rc = pSession->rc;  SessionDiffCtx d;  memset(&d, 0, sizeof(d));  sessionDiffHooks(pSession, &d);  sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));  if( pzErrMsg ) *pzErrMsg = 0;  if( rc==SQLITE_OK ){  char *zExpr = 0;  sqlite3 *db = pSession->db;  SessionTable *pTo;  rc = sessionFindTable(pSession, zTbl, &pTo);  if( pTo==0 ) goto diff_out;  if( sessionInitTable(pSession, pTo) ){  rc = pSession->rc;  goto diff_out;  }  if( rc==SQLITE_OK ){  int bHasPk = 0;  int bMismatch = 0;  int nCol;  u8 *abPK;  const char **azCol = 0;  rc = sessionTableInfo(0, db, zFrom, zTbl, &nCol, 0, &azCol, &abPK);  if( rc==SQLITE_OK ){  if( pTo->nCol!=nCol ){  bMismatch = 1;  }else{  int i;  for(i=0; i<nCol; i++){  if( pTo->abPK[i]!=abPK[i] ) bMismatch = 1;  if( sqlite3_stricmp(azCol[i], pTo->azCol[i]) ) bMismatch = 1;  if( abPK[i] ) bHasPk = 1;  }  }  }  sqlite3_free((char*)azCol);  if( bMismatch ){  if( pzErrMsg ){  *pzErrMsg = sqlite3_mprintf("table schemas do not match");  }  rc = SQLITE_SCHEMA;  }  if( bHasPk==0 ){  goto diff_out;  }  }  if( rc==SQLITE_OK ){  zExpr = sessionExprComparePK(pTo->nCol,  zDb, zFrom, pTo->zName, pTo->azCol, pTo->abPK  );  }  if( rc==SQLITE_OK ){  rc = sessionDiffFindNew(SQLITE_INSERT, pSession, pTo, zDb, zFrom, zExpr);  }  if( rc==SQLITE_OK ){  rc = sessionDiffFindNew(SQLITE_DELETE, pSession, pTo, zFrom, zDb, zExpr);  }  if( rc==SQLITE_OK ){  rc = sessionDiffFindModified(pSession, pTo, zFrom, zExpr);  }  sqlite3_free(zExpr);  }  diff_out:  sessionPreupdateHooks(pSession);  sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));  return rc; } SQLITE_API int sqlite3session_create(  sqlite3 *db,  const char *zDb,  sqlite3_session **ppSession ){  sqlite3_session *pNew;  sqlite3_session *pOld;  int nDb = sqlite3Strlen30(zDb);  *ppSession = 0;  pNew = (sqlite3_session *)sqlite3_malloc64(sizeof(sqlite3_session) + nDb + 1);  if( !pNew ) return SQLITE_NOMEM;  memset(pNew, 0, sizeof(sqlite3_session));  pNew->db = db;  pNew->zDb = (char *)&pNew[1];  pNew->bEnable = 1;  memcpy(pNew->zDb, zDb, nDb+1);  sessionPreupdateHooks(pNew);  sqlite3_mutex_enter(sqlite3_db_mutex(db));  pOld = (sqlite3_session*)sqlite3_preupdate_hook(db, xPreUpdate, (void*)pNew);  pNew->pNext = pOld;  sqlite3_mutex_leave(sqlite3_db_mutex(db));  *ppSession = pNew;  return SQLITE_OK; } static void sessionDeleteTable(sqlite3_session *pSession, SessionTable *pList){  SessionTable *pNext;  SessionTable *pTab;  for(pTab=pList; pTab; pTab=pNext){  int i;  pNext = pTab->pNext;  for(i=0; i<pTab->nChange; i++){  SessionChange *p;  SessionChange *pNextChange;  for(p=pTab->apChange[i]; p; p=pNextChange){  pNextChange = p->pNext;  sessionFree(pSession, p);  }  }  sessionFree(pSession, (char*)pTab->azCol);  sessionFree(pSession, pTab->apChange);  sessionFree(pSession, pTab);  } } SQLITE_API void sqlite3session_delete(sqlite3_session *pSession){  sqlite3 *db = pSession->db;  sqlite3_session *pHead;  sqlite3_session **pp;  sqlite3_mutex_enter(sqlite3_db_mutex(db));  pHead = (sqlite3_session*)sqlite3_preupdate_hook(db, 0, 0);  for(pp=&pHead; ALWAYS((*pp)!=0); pp=&((*pp)->pNext)){  if( (*pp)==pSession ){  *pp = (*pp)->pNext;  if( pHead ) sqlite3_preupdate_hook(db, xPreUpdate, (void*)pHead);  break;  }  }  sqlite3_mutex_leave(sqlite3_db_mutex(db));  sqlite3ValueFree(pSession->pZeroBlob);  sessionDeleteTable(pSession, pSession->pTable);  assert( pSession->nMalloc==0 );  sqlite3_free(pSession); } SQLITE_API void sqlite3session_table_filter(  sqlite3_session *pSession,  int(*xFilter)(void*, const char*),  void *pCtx ){  pSession->bAutoAttach = 1;  pSession->pFilterCtx = pCtx;  pSession->xTableFilter = xFilter; } SQLITE_API int sqlite3session_attach(  sqlite3_session *pSession,  const char *zName ){  int rc = SQLITE_OK;  sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));  if( !zName ){  pSession->bAutoAttach = 1;  }else{  SessionTable *pTab;  int nName;  nName = sqlite3Strlen30(zName);  for(pTab=pSession->pTable; pTab; pTab=pTab->pNext){  if( 0==sqlite3_strnicmp(pTab->zName, zName, nName+1) ) break;  }  if( !pTab ){  int nByte = sizeof(SessionTable) + nName + 1;  pTab = (SessionTable*)sessionMalloc64(pSession, nByte);  if( !pTab ){  rc = SQLITE_NOMEM;  }else{  SessionTable **ppTab;  memset(pTab, 0, sizeof(SessionTable));  pTab->zName = (char *)&pTab[1];  memcpy(pTab->zName, zName, nName+1);  for(ppTab=&pSession->pTable; *ppTab; ppTab=&(*ppTab)->pNext);  *ppTab = pTab;  }  }  }  sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));  return rc; } static int sessionBufferGrow(SessionBuffer *p, i64 nByte, int *pRc){
#define SESSION_MAX_BUFFER_SZ (0x7FFFFF00 - 1)
 i64 nReq = p->nBuf + nByte;  if( *pRc==SQLITE_OK && nReq>p->nAlloc ){  u8 *aNew;  i64 nNew = p->nAlloc ? p->nAlloc : 128;  do {  nNew = nNew*2;  }while( nNew<nReq );  if( nNew>SESSION_MAX_BUFFER_SZ ){  nNew = SESSION_MAX_BUFFER_SZ;  if( nNew<nReq ){  *pRc = SQLITE_NOMEM;  return 1;  }  }  aNew = (u8 *)sqlite3_realloc64(p->aBuf, nNew);  if( 0==aNew ){  *pRc = SQLITE_NOMEM;  }else{  p->aBuf = aNew;  p->nAlloc = nNew;  }  }  return (*pRc!=SQLITE_OK); } static void sessionAppendValue(SessionBuffer *p, sqlite3_value *pVal, int *pRc){  int rc = *pRc;  if( rc==SQLITE_OK ){  sqlite3_int64 nByte = 0;  rc = sessionSerializeValue(0, pVal, &nByte);  sessionBufferGrow(p, nByte, &rc);  if( rc==SQLITE_OK ){  rc = sessionSerializeValue(&p->aBuf[p->nBuf], pVal, 0);  p->nBuf += nByte;  }else{  *pRc = rc;  }  } } static void sessionAppendByte(SessionBuffer *p, u8 v, int *pRc){  if( 0==sessionBufferGrow(p, 1, pRc) ){  p->aBuf[p->nBuf++] = v;  } } static void sessionAppendVarint(SessionBuffer *p, int v, int *pRc){  if( 0==sessionBufferGrow(p, 9, pRc) ){  p->nBuf += sessionVarintPut(&p->aBuf[p->nBuf], v);  } } static void sessionAppendBlob(  SessionBuffer *p,  const u8 *aBlob,  int nBlob,  int *pRc ){  if( nBlob>0 && 0==sessionBufferGrow(p, nBlob, pRc) ){  memcpy(&p->aBuf[p->nBuf], aBlob, nBlob);  p->nBuf += nBlob;  } } static void sessionAppendStr(  SessionBuffer *p,  const char *zStr,  int *pRc ){  int nStr = sqlite3Strlen30(zStr);  if( 0==sessionBufferGrow(p, nStr, pRc) ){  memcpy(&p->aBuf[p->nBuf], zStr, nStr);  p->nBuf += nStr;  } } static void sessionAppendInteger(  SessionBuffer *p,  int iVal,  int *pRc ){  char aBuf[24];  sqlite3_snprintf(sizeof(aBuf)-1, aBuf, "%d", iVal);  sessionAppendStr(p, aBuf, pRc); } static void sessionAppendIdent(  SessionBuffer *p,  const char *zStr,  int *pRc ){  int nStr = sqlite3Strlen30(zStr)*2 + 2 + 1;  if( 0==sessionBufferGrow(p, nStr, pRc) ){  char *zOut = (char *)&p->aBuf[p->nBuf];  const char *zIn = zStr;  *zOut++ = '"';  while( *zIn ){  if( *zIn=='"' ) *zOut++ = '"';  *zOut++ = *(zIn++);  }  *zOut++ = '"';  p->nBuf = (int)((u8 *)zOut - p->aBuf);  } } static void sessionAppendCol(  SessionBuffer *p,  sqlite3_stmt *pStmt,  int iCol,  int *pRc ){  if( *pRc==SQLITE_OK ){  int eType = sqlite3_column_type(pStmt, iCol);  sessionAppendByte(p, (u8)eType, pRc);  if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  sqlite3_int64 i;  u8 aBuf[8];  if( eType==SQLITE_INTEGER ){  i = sqlite3_column_int64(pStmt, iCol);  }else{  double r = sqlite3_column_double(pStmt, iCol);  memcpy(&i, &r, 8);  }  sessionPutI64(aBuf, i);  sessionAppendBlob(p, aBuf, 8, pRc);  }  if( eType==SQLITE_BLOB || eType==SQLITE_TEXT ){  u8 *z;  int nByte;  if( eType==SQLITE_BLOB ){  z = (u8 *)sqlite3_column_blob(pStmt, iCol);  }else{  z = (u8 *)sqlite3_column_text(pStmt, iCol);  }  nByte = sqlite3_column_bytes(pStmt, iCol);  if( z || (eType==SQLITE_BLOB && nByte==0) ){  sessionAppendVarint(p, nByte, pRc);  sessionAppendBlob(p, z, nByte, pRc);  }else{  *pRc = SQLITE_NOMEM;  }  }  } } static int sessionAppendUpdate(  SessionBuffer *pBuf,  int bPatchset,  sqlite3_stmt *pStmt,  SessionChange *p,  u8 *abPK ){  int rc = SQLITE_OK;  SessionBuffer buf2 = {0,0,0};  int bNoop = 1;  int nRewind = pBuf->nBuf;  int i;  u8 *pCsr = p->aRecord;  assert( abPK!=0 );  sessionAppendByte(pBuf, SQLITE_UPDATE, &rc);  sessionAppendByte(pBuf, p->bIndirect, &rc);  for(i=0; i<sqlite3_column_count(pStmt); i++){  int bChanged = 0;  int nAdvance;  int eType = *pCsr;  switch( eType ){  case SQLITE_NULL:  nAdvance = 1;  if( sqlite3_column_type(pStmt, i)!=SQLITE_NULL ){  bChanged = 1;  }  break;  case SQLITE_FLOAT:  case SQLITE_INTEGER: {  nAdvance = 9;  if( eType==sqlite3_column_type(pStmt, i) ){  sqlite3_int64 iVal = sessionGetI64(&pCsr[1]);  if( eType==SQLITE_INTEGER ){  if( iVal==sqlite3_column_int64(pStmt, i) ) break;  }else{  double dVal;  memcpy(&dVal, &iVal, 8);  if( dVal==sqlite3_column_double(pStmt, i) ) break;  }  }  bChanged = 1;  break;  }  default: {  int n;  int nHdr = 1 + sessionVarintGet(&pCsr[1], &n);  assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );  nAdvance = nHdr + n;  if( eType==sqlite3_column_type(pStmt, i)   && n==sqlite3_column_bytes(pStmt, i)   && (n==0 || 0==memcmp(&pCsr[nHdr], sqlite3_column_blob(pStmt, i), n))  ){  break;  }  bChanged = 1;  }  }  if( bChanged ) bNoop = 0;  if( bPatchset==0 ){  if( bChanged || abPK[i] ){  sessionAppendBlob(pBuf, pCsr, nAdvance, &rc);  }else{  sessionAppendByte(pBuf, 0, &rc);  }  }  if( bChanged || (bPatchset && abPK[i]) ){  sessionAppendCol(&buf2, pStmt, i, &rc);  }else{  sessionAppendByte(&buf2, 0, &rc);  }  pCsr += nAdvance;  }  if( bNoop ){  pBuf->nBuf = nRewind;  }else{  sessionAppendBlob(pBuf, buf2.aBuf, buf2.nBuf, &rc);  }  sqlite3_free(buf2.aBuf);  return rc; } static int sessionAppendDelete(  SessionBuffer *pBuf,  int bPatchset,  SessionChange *p,  int nCol,  u8 *abPK ){  int rc = SQLITE_OK;  sessionAppendByte(pBuf, SQLITE_DELETE, &rc);  sessionAppendByte(pBuf, p->bIndirect, &rc);  if( bPatchset==0 ){  sessionAppendBlob(pBuf, p->aRecord, p->nRecord, &rc);  }else{  int i;  u8 *a = p->aRecord;  for(i=0; i<nCol; i++){  u8 *pStart = a;  int eType = *a++;  switch( eType ){  case 0:  case SQLITE_NULL:  assert( abPK[i]==0 );  break;  case SQLITE_FLOAT:  case SQLITE_INTEGER:  a += 8;  break;  default: {  int n;  a += sessionVarintGet(a, &n);  a += n;  break;  }  }  if( abPK[i] ){  sessionAppendBlob(pBuf, pStart, (int)(a-pStart), &rc);  }  }  assert( (a - p->aRecord)==p->nRecord );  }  return rc; } static int sessionSelectStmt(  sqlite3 *db,  const char *zDb,  const char *zTab,  int nCol,  const char **azCol,  u8 *abPK,  sqlite3_stmt **ppStmt ){  int rc = SQLITE_OK;  char *zSql = 0;  int nSql = -1;  if( 0==sqlite3_stricmp("sqlite_stat1", zTab) ){  zSql = sqlite3_mprintf(  "SELECT tbl, ?2, stat FROM %Q.sqlite_stat1 WHERE tbl IS ?1 AND "  "idx IS (CASE WHEN ?2=X'' THEN NULL ELSE ?2 END)", zDb  );  if( zSql==0 ) rc = SQLITE_NOMEM;  }else{  int i;  const char *zSep = "";  SessionBuffer buf = {0, 0, 0};  sessionAppendStr(&buf, "SELECT * FROM ", &rc);  sessionAppendIdent(&buf, zDb, &rc);  sessionAppendStr(&buf, ".", &rc);  sessionAppendIdent(&buf, zTab, &rc);  sessionAppendStr(&buf, " WHERE ", &rc);  for(i=0; i<nCol; i++){  if( abPK[i] ){  sessionAppendStr(&buf, zSep, &rc);  sessionAppendIdent(&buf, azCol[i], &rc);  sessionAppendStr(&buf, " IS ?", &rc);  sessionAppendInteger(&buf, i+1, &rc);  zSep = " AND ";  }  }  zSql = (char*)buf.aBuf;  nSql = buf.nBuf;  }  if( rc==SQLITE_OK ){  rc = sqlite3_prepare_v2(db, zSql, nSql, ppStmt, 0);  }  sqlite3_free(zSql);  return rc; } static int sessionSelectBind(  sqlite3_stmt *pSelect,  int nCol,  u8 *abPK,  SessionChange *pChange ){  int i;  int rc = SQLITE_OK;  u8 *a = pChange->aRecord;  for(i=0; i<nCol && rc==SQLITE_OK; i++){  int eType = *a++;  switch( eType ){  case 0:  case SQLITE_NULL:  assert( abPK[i]==0 );  break;  case SQLITE_INTEGER: {  if( abPK[i] ){  i64 iVal = sessionGetI64(a);  rc = sqlite3_bind_int64(pSelect, i+1, iVal);  }  a += 8;  break;  }  case SQLITE_FLOAT: {  if( abPK[i] ){  double rVal;  i64 iVal = sessionGetI64(a);  memcpy(&rVal, &iVal, 8);  rc = sqlite3_bind_double(pSelect, i+1, rVal);  }  a += 8;  break;  }  case SQLITE_TEXT: {  int n;  a += sessionVarintGet(a, &n);  if( abPK[i] ){  rc = sqlite3_bind_text(pSelect, i+1, (char *)a, n, SQLITE_TRANSIENT);  }  a += n;  break;  }  default: {  int n;  assert( eType==SQLITE_BLOB );  a += sessionVarintGet(a, &n);  if( abPK[i] ){  rc = sqlite3_bind_blob(pSelect, i+1, a, n, SQLITE_TRANSIENT);  }  a += n;  break;  }  }  }  return rc; } static void sessionAppendTableHdr(  SessionBuffer *pBuf,  int bPatchset,  SessionTable *pTab,  int *pRc ){  sessionAppendByte(pBuf, (bPatchset ? 'P' : 'T'), pRc);  sessionAppendVarint(pBuf, pTab->nCol, pRc);  sessionAppendBlob(pBuf, pTab->abPK, pTab->nCol, pRc);  sessionAppendBlob(pBuf, (u8 *)pTab->zName, (int)strlen(pTab->zName)+1, pRc); } static int sessionGenerateChangeset(  sqlite3_session *pSession,  int bPatchset,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut,  int *pnChangeset,  void **ppChangeset ){  sqlite3 *db = pSession->db;  SessionTable *pTab;  SessionBuffer buf = {0,0,0};  int rc;  assert( xOutput==0 || (pnChangeset==0 && ppChangeset==0) );  assert( xOutput!=0 || (pnChangeset!=0 && ppChangeset!=0) );  if( xOutput==0 ){  assert( pnChangeset!=0 && ppChangeset!=0 );  *pnChangeset = 0;  *ppChangeset = 0;  }  if( pSession->rc ) return pSession->rc;  rc = sqlite3_exec(pSession->db, "SAVEPOINT changeset", 0, 0, 0);  if( rc!=SQLITE_OK ) return rc;  sqlite3_mutex_enter(sqlite3_db_mutex(db));  for(pTab=pSession->pTable; rc==SQLITE_OK && pTab; pTab=pTab->pNext){  if( pTab->nEntry ){  const char *zName = pTab->zName;  int nCol = 0;  u8 *abPK = 0;  const char **azCol = 0;  int i;  sqlite3_stmt *pSel = 0;  int nRewind = buf.nBuf;  int nNoop;  rc = sessionTableInfo(0, db, pSession->zDb, zName, &nCol, 0,&azCol,&abPK);  if( !rc && (pTab->nCol!=nCol || memcmp(abPK, pTab->abPK, nCol)) ){  rc = SQLITE_SCHEMA;  }  sessionAppendTableHdr(&buf, bPatchset, pTab, &rc);  if( rc==SQLITE_OK ){  rc = sessionSelectStmt(  db, pSession->zDb, zName, nCol, azCol, abPK, &pSel);  }  nNoop = buf.nBuf;  for(i=0; i<pTab->nChange && rc==SQLITE_OK; i++){  SessionChange *p;  for(p=pTab->apChange[i]; rc==SQLITE_OK && p; p=p->pNext){  rc = sessionSelectBind(pSel, nCol, abPK, p);  if( rc!=SQLITE_OK ) continue;  if( sqlite3_step(pSel)==SQLITE_ROW ){  if( p->op==SQLITE_INSERT ){  int iCol;  sessionAppendByte(&buf, SQLITE_INSERT, &rc);  sessionAppendByte(&buf, p->bIndirect, &rc);  for(iCol=0; iCol<nCol; iCol++){  sessionAppendCol(&buf, pSel, iCol, &rc);  }  }else{  assert( abPK!=0 );  rc = sessionAppendUpdate(&buf, bPatchset, pSel, p, abPK);  }  }else if( p->op!=SQLITE_INSERT ){  rc = sessionAppendDelete(&buf, bPatchset, p, nCol, abPK);  }  if( rc==SQLITE_OK ){  rc = sqlite3_reset(pSel);  }  if( xOutput   && rc==SQLITE_OK   && buf.nBuf>nNoop   && buf.nBuf>sessions_strm_chunk_size  ){  rc = xOutput(pOut, (void*)buf.aBuf, buf.nBuf);  nNoop = -1;  buf.nBuf = 0;  }  }  }  sqlite3_finalize(pSel);  if( buf.nBuf==nNoop ){  buf.nBuf = nRewind;  }  sqlite3_free((char*)azCol);  }  }  if( rc==SQLITE_OK ){  if( xOutput==0 ){  *pnChangeset = buf.nBuf;  *ppChangeset = buf.aBuf;  buf.aBuf = 0;  }else if( buf.nBuf>0 ){  rc = xOutput(pOut, (void*)buf.aBuf, buf.nBuf);  }  }  sqlite3_free(buf.aBuf);  sqlite3_exec(db, "RELEASE changeset", 0, 0, 0);  sqlite3_mutex_leave(sqlite3_db_mutex(db));  return rc; } SQLITE_API int sqlite3session_changeset(  sqlite3_session *pSession,  int *pnChangeset,  void **ppChangeset ){  int rc;  if( pnChangeset==0 || ppChangeset==0 ) return SQLITE_MISUSE;  rc = sessionGenerateChangeset(pSession, 0, 0, 0, pnChangeset,ppChangeset);  assert( rc || pnChangeset==0   || pSession->bEnableSize==0 || *pnChangeset<=pSession->nMaxChangesetSize  );  return rc; } SQLITE_API int sqlite3session_changeset_strm(  sqlite3_session *pSession,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ){  if( xOutput==0 ) return SQLITE_MISUSE;  return sessionGenerateChangeset(pSession, 0, xOutput, pOut, 0, 0); } SQLITE_API int sqlite3session_patchset_strm(  sqlite3_session *pSession,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ){  if( xOutput==0 ) return SQLITE_MISUSE;  return sessionGenerateChangeset(pSession, 1, xOutput, pOut, 0, 0); } SQLITE_API int sqlite3session_patchset(  sqlite3_session *pSession,  int *pnPatchset,  void **ppPatchset ){  if( pnPatchset==0 || ppPatchset==0 ) return SQLITE_MISUSE;  return sessionGenerateChangeset(pSession, 1, 0, 0, pnPatchset, ppPatchset); } SQLITE_API int sqlite3session_enable(sqlite3_session *pSession, int bEnable){  int ret;  sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));  if( bEnable>=0 ){  pSession->bEnable = bEnable;  }  ret = pSession->bEnable;  sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));  return ret; } SQLITE_API int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect){  int ret;  sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));  if( bIndirect>=0 ){  pSession->bIndirect = bIndirect;  }  ret = pSession->bIndirect;  sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));  return ret; } SQLITE_API int sqlite3session_isempty(sqlite3_session *pSession){  int ret = 0;  SessionTable *pTab;  sqlite3_mutex_enter(sqlite3_db_mutex(pSession->db));  for(pTab=pSession->pTable; pTab && ret==0; pTab=pTab->pNext){  ret = (pTab->nEntry>0);  }  sqlite3_mutex_leave(sqlite3_db_mutex(pSession->db));  return (ret==0); } SQLITE_API sqlite3_int64 sqlite3session_memory_used(sqlite3_session *pSession){  return pSession->nMalloc; } SQLITE_API int sqlite3session_object_config(sqlite3_session *pSession, int op, void *pArg){  int rc = SQLITE_OK;  switch( op ){  case SQLITE_SESSION_OBJCONFIG_SIZE: {  int iArg = *(int*)pArg;  if( iArg>=0 ){  if( pSession->pTable ){  rc = SQLITE_MISUSE;  }else{  pSession->bEnableSize = (iArg!=0);  }  }  *(int*)pArg = pSession->bEnableSize;  break;  }  default:  rc = SQLITE_MISUSE;  }  return rc; } SQLITE_API sqlite3_int64 sqlite3session_changeset_size(sqlite3_session *pSession){  return pSession->nMaxChangesetSize; } static int sessionChangesetStart(  sqlite3_changeset_iter **pp,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int nChangeset,  void *pChangeset,  int bInvert,  int bSkipEmpty ){  sqlite3_changeset_iter *pRet;  int nByte;  assert( xInput==0 || (pChangeset==0 && nChangeset==0) );  *pp = 0;  nByte = sizeof(sqlite3_changeset_iter);  pRet = (sqlite3_changeset_iter *)sqlite3_malloc(nByte);  if( !pRet ) return SQLITE_NOMEM;  memset(pRet, 0, sizeof(sqlite3_changeset_iter));  pRet->in.aData = (u8 *)pChangeset;  pRet->in.nData = nChangeset;  pRet->in.xInput = xInput;  pRet->in.pIn = pIn;  pRet->in.bEof = (xInput ? 0 : 1);  pRet->bInvert = bInvert;  pRet->bSkipEmpty = bSkipEmpty;  *pp = pRet;  return SQLITE_OK; } SQLITE_API int sqlite3changeset_start(  sqlite3_changeset_iter **pp,  int nChangeset,  void *pChangeset ){  return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset, 0, 0); } SQLITE_API int sqlite3changeset_start_v2(  sqlite3_changeset_iter **pp,  int nChangeset,  void *pChangeset,  int flags ){  int bInvert = !!(flags & SQLITE_CHANGESETSTART_INVERT);  return sessionChangesetStart(pp, 0, 0, nChangeset, pChangeset, bInvert, 0); } SQLITE_API int sqlite3changeset_start_strm(  sqlite3_changeset_iter **pp,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn ){  return sessionChangesetStart(pp, xInput, pIn, 0, 0, 0, 0); } SQLITE_API int sqlite3changeset_start_v2_strm(  sqlite3_changeset_iter **pp,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int flags ){  int bInvert = !!(flags & SQLITE_CHANGESETSTART_INVERT);  return sessionChangesetStart(pp, xInput, pIn, 0, 0, bInvert, 0); } static void sessionDiscardData(SessionInput *pIn){  if( pIn->xInput && pIn->iNext>=sessions_strm_chunk_size ){  int nMove = pIn->buf.nBuf - pIn->iNext;  assert( nMove>=0 );  if( nMove>0 ){  memmove(pIn->buf.aBuf, &pIn->buf.aBuf[pIn->iNext], nMove);  }  pIn->buf.nBuf -= pIn->iNext;  pIn->iNext = 0;  pIn->nData = pIn->buf.nBuf;  } } static int sessionInputBuffer(SessionInput *pIn, int nByte){  int rc = SQLITE_OK;  if( pIn->xInput ){  while( !pIn->bEof && (pIn->iNext+nByte)>=pIn->nData && rc==SQLITE_OK ){  int nNew = sessions_strm_chunk_size;  if( pIn->bNoDiscard==0 ) sessionDiscardData(pIn);  if( SQLITE_OK==sessionBufferGrow(&pIn->buf, nNew, &rc) ){  rc = pIn->xInput(pIn->pIn, &pIn->buf.aBuf[pIn->buf.nBuf], &nNew);  if( nNew==0 ){  pIn->bEof = 1;  }else{  pIn->buf.nBuf += nNew;  }  }  pIn->aData = pIn->buf.aBuf;  pIn->nData = pIn->buf.nBuf;  }  }  return rc; } static void sessionSkipRecord(  u8 **ppRec,  int nCol ){  u8 *aRec = *ppRec;  int i;  for(i=0; i<nCol; i++){  int eType = *aRec++;  if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){  int nByte;  aRec += sessionVarintGet((u8*)aRec, &nByte);  aRec += nByte;  }else if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  aRec += 8;  }  }  *ppRec = aRec; } static int sessionValueSetStr(  sqlite3_value *pVal,  u8 *aData,  int nData,  u8 enc ){  u8 *aCopy = sqlite3_malloc64((sqlite3_int64)nData+1);  if( aCopy==0 ) return SQLITE_NOMEM;  memcpy(aCopy, aData, nData);  sqlite3ValueSetStr(pVal, nData, (char*)aCopy, enc, sqlite3_free);  return SQLITE_OK; } static int sessionReadRecord(  SessionInput *pIn,  int nCol,  u8 *abPK,  sqlite3_value **apOut,  int *pbEmpty ){  int i;  int rc = SQLITE_OK;  assert( pbEmpty==0 || *pbEmpty==0 );  if( pbEmpty ) *pbEmpty = 1;  for(i=0; i<nCol && rc==SQLITE_OK; i++){  int eType = 0;  if( abPK && abPK[i]==0 ) continue;  rc = sessionInputBuffer(pIn, 9);  if( rc==SQLITE_OK ){  if( pIn->iNext>=pIn->nData ){  rc = SQLITE_CORRUPT_BKPT;  }else{  eType = pIn->aData[pIn->iNext++];  assert( apOut[i]==0 );  if( eType ){  if( pbEmpty ) *pbEmpty = 0;  apOut[i] = sqlite3ValueNew(0);  if( !apOut[i] ) rc = SQLITE_NOMEM;  }  }  }  if( rc==SQLITE_OK ){  u8 *aVal = &pIn->aData[pIn->iNext];  if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){  int nByte;  pIn->iNext += sessionVarintGet(aVal, &nByte);  rc = sessionInputBuffer(pIn, nByte);  if( rc==SQLITE_OK ){  if( nByte<0 || nByte>pIn->nData-pIn->iNext ){  rc = SQLITE_CORRUPT_BKPT;  }else{  u8 enc = (eType==SQLITE_TEXT ? SQLITE_UTF8 : 0);  rc = sessionValueSetStr(apOut[i],&pIn->aData[pIn->iNext],nByte,enc);  pIn->iNext += nByte;  }  }  }  if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  sqlite3_int64 v = sessionGetI64(aVal);  if( eType==SQLITE_INTEGER ){  sqlite3VdbeMemSetInt64(apOut[i], v);  }else{  double d;  memcpy(&d, &v, 8);  sqlite3VdbeMemSetDouble(apOut[i], d);  }  pIn->iNext += 8;  }  }  }  return rc; } static int sessionChangesetBufferTblhdr(SessionInput *pIn, int *pnByte){  int rc = SQLITE_OK;  int nCol = 0;  int nRead = 0;  rc = sessionInputBuffer(pIn, 9);  if( rc==SQLITE_OK ){  nRead += sessionVarintGet(&pIn->aData[pIn->iNext + nRead], &nCol);  if( nCol<0 || nCol>65536 ){  rc = SQLITE_CORRUPT_BKPT;  }else{  rc = sessionInputBuffer(pIn, nRead+nCol+100);  nRead += nCol;  }  }  while( rc==SQLITE_OK ){  while( (pIn->iNext + nRead)<pIn->nData && pIn->aData[pIn->iNext + nRead] ){  nRead++;  }  if( (pIn->iNext + nRead)<pIn->nData ) break;  rc = sessionInputBuffer(pIn, nRead + 100);  }  *pnByte = nRead+1;  return rc; } static int sessionChangesetBufferRecord(  SessionInput *pIn,  int nCol,  int *pnByte ){  int rc = SQLITE_OK;  int nByte = 0;  int i;  for(i=0; rc==SQLITE_OK && i<nCol; i++){  int eType;  rc = sessionInputBuffer(pIn, nByte + 10);  if( rc==SQLITE_OK ){  eType = pIn->aData[pIn->iNext + nByte++];  if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){  int n;  nByte += sessionVarintGet(&pIn->aData[pIn->iNext+nByte], &n);  nByte += n;  rc = sessionInputBuffer(pIn, nByte);  }else if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){  nByte += 8;  }  }  }  *pnByte = nByte;  return rc; } static int sessionChangesetReadTblhdr(sqlite3_changeset_iter *p){  int rc;  int nCopy;  assert( p->rc==SQLITE_OK );  rc = sessionChangesetBufferTblhdr(&p->in, &nCopy);  if( rc==SQLITE_OK ){  int nByte;  int nVarint;  nVarint = sessionVarintGet(&p->in.aData[p->in.iNext], &p->nCol);  if( p->nCol>0 ){  nCopy -= nVarint;  p->in.iNext += nVarint;  nByte = p->nCol * sizeof(sqlite3_value*) * 2 + nCopy;  p->tblhdr.nBuf = 0;  sessionBufferGrow(&p->tblhdr, nByte, &rc);  }else{  rc = SQLITE_CORRUPT_BKPT;  }  }  if( rc==SQLITE_OK ){  size_t iPK = sizeof(sqlite3_value*)*p->nCol*2;  memset(p->tblhdr.aBuf, 0, iPK);  memcpy(&p->tblhdr.aBuf[iPK], &p->in.aData[p->in.iNext], nCopy);  p->in.iNext += nCopy;  }  p->apValue = (sqlite3_value**)p->tblhdr.aBuf;  if( p->apValue==0 ){  p->abPK = 0;  p->zTab = 0;  }else{  p->abPK = (u8*)&p->apValue[p->nCol*2];  p->zTab = p->abPK ? (char*)&p->abPK[p->nCol] : 0;  }  return (p->rc = rc); } static int sessionChangesetNextOne(  sqlite3_changeset_iter *p,  u8 **paRec,  int *pnRec,  int *pbNew,  int *pbEmpty ){  int i;  u8 op;  assert( (paRec==0 && pnRec==0) || (paRec && pnRec) );  assert( pbEmpty==0 || *pbEmpty==0 );  if( p->rc!=SQLITE_OK ) return p->rc;  if( p->apValue ){  for(i=0; i<p->nCol*2; i++){  sqlite3ValueFree(p->apValue[i]);  }  memset(p->apValue, 0, sizeof(sqlite3_value*)*p->nCol*2);  }  p->rc = sessionInputBuffer(&p->in, 2);  if( p->rc!=SQLITE_OK ) return p->rc;  if( p->in.iNext>=p->in.nData ){  return SQLITE_DONE;  }  sessionDiscardData(&p->in);  p->in.iCurrent = p->in.iNext;  op = p->in.aData[p->in.iNext++];  while( op=='T' || op=='P' ){  if( pbNew ) *pbNew = 1;  p->bPatchset = (op=='P');  if( sessionChangesetReadTblhdr(p) ) return p->rc;  if( (p->rc = sessionInputBuffer(&p->in, 2)) ) return p->rc;  p->in.iCurrent = p->in.iNext;  if( p->in.iNext>=p->in.nData ) return SQLITE_DONE;  op = p->in.aData[p->in.iNext++];  }  if( p->zTab==0 || (p->bPatchset && p->bInvert) ){  assert( p->in.iNext==1 || p->zTab );  return (p->rc = SQLITE_CORRUPT_BKPT);  }  p->op = op;  p->bIndirect = p->in.aData[p->in.iNext++];  if( p->op!=SQLITE_UPDATE && p->op!=SQLITE_DELETE && p->op!=SQLITE_INSERT ){  return (p->rc = SQLITE_CORRUPT_BKPT);  }  if( paRec ){  int nVal;  if( p->bPatchset==0 && op==SQLITE_UPDATE ){  nVal = p->nCol * 2;  }else if( p->bPatchset && op==SQLITE_DELETE ){  nVal = 0;  for(i=0; i<p->nCol; i++) if( p->abPK[i] ) nVal++;  }else{  nVal = p->nCol;  }  p->rc = sessionChangesetBufferRecord(&p->in, nVal, pnRec);  if( p->rc!=SQLITE_OK ) return p->rc;  *paRec = &p->in.aData[p->in.iNext];  p->in.iNext += *pnRec;  }else{  sqlite3_value **apOld = (p->bInvert ? &p->apValue[p->nCol] : p->apValue);  sqlite3_value **apNew = (p->bInvert ? p->apValue : &p->apValue[p->nCol]);  if( p->op!=SQLITE_INSERT && (p->bPatchset==0 || p->op==SQLITE_DELETE) ){  u8 *abPK = p->bPatchset ? p->abPK : 0;  p->rc = sessionReadRecord(&p->in, p->nCol, abPK, apOld, 0);  if( p->rc!=SQLITE_OK ) return p->rc;  }  if( p->op!=SQLITE_DELETE ){  p->rc = sessionReadRecord(&p->in, p->nCol, 0, apNew, pbEmpty);  if( p->rc!=SQLITE_OK ) return p->rc;  }  if( (p->bPatchset || p->bInvert) && p->op==SQLITE_UPDATE ){  for(i=0; i<p->nCol; i++){  assert( p->bPatchset==0 || p->apValue[i]==0 );  if( p->abPK[i] ){  assert( p->apValue[i]==0 );  p->apValue[i] = p->apValue[i+p->nCol];  if( p->apValue[i]==0 ) return (p->rc = SQLITE_CORRUPT_BKPT);  p->apValue[i+p->nCol] = 0;  }  }  }else if( p->bInvert ){  if( p->op==SQLITE_INSERT ) p->op = SQLITE_DELETE;  else if( p->op==SQLITE_DELETE ) p->op = SQLITE_INSERT;  }  }  return SQLITE_ROW; } static int sessionChangesetNext(  sqlite3_changeset_iter *p,  u8 **paRec,  int *pnRec,  int *pbNew ){  int bEmpty;  int rc;  do {  bEmpty = 0;  rc = sessionChangesetNextOne(p, paRec, pnRec, pbNew, &bEmpty);  }while( rc==SQLITE_ROW && p->bSkipEmpty && bEmpty);  return rc; } SQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *p){  return sessionChangesetNext(p, 0, 0, 0); } SQLITE_API int sqlite3changeset_op(  sqlite3_changeset_iter *pIter,  const char **pzTab,  int *pnCol,  int *pOp,  int *pbIndirect ){  *pOp = pIter->op;  *pnCol = pIter->nCol;  *pzTab = pIter->zTab;  if( pbIndirect ) *pbIndirect = pIter->bIndirect;  return SQLITE_OK; } SQLITE_API int sqlite3changeset_pk(  sqlite3_changeset_iter *pIter,  unsigned char **pabPK,  int *pnCol ){  *pabPK = pIter->abPK;  if( pnCol ) *pnCol = pIter->nCol;  return SQLITE_OK; } SQLITE_API int sqlite3changeset_old(  sqlite3_changeset_iter *pIter,  int iVal,  sqlite3_value **ppValue ){  if( pIter->op!=SQLITE_UPDATE && pIter->op!=SQLITE_DELETE ){  return SQLITE_MISUSE;  }  if( iVal<0 || iVal>=pIter->nCol ){  return SQLITE_RANGE;  }  *ppValue = pIter->apValue[iVal];  return SQLITE_OK; } SQLITE_API int sqlite3changeset_new(  sqlite3_changeset_iter *pIter,  int iVal,  sqlite3_value **ppValue ){  if( pIter->op!=SQLITE_UPDATE && pIter->op!=SQLITE_INSERT ){  return SQLITE_MISUSE;  }  if( iVal<0 || iVal>=pIter->nCol ){  return SQLITE_RANGE;  }  *ppValue = pIter->apValue[pIter->nCol+iVal];  return SQLITE_OK; }
#define sessionChangesetNew(pIter, iVal) (pIter)->apValue[(pIter)->nCol+(iVal)]
#define sessionChangesetOld(pIter, iVal) (pIter)->apValue[(iVal)]
SQLITE_API int sqlite3changeset_conflict(  sqlite3_changeset_iter *pIter,  int iVal,  sqlite3_value **ppValue ){  if( !pIter->pConflict ){  return SQLITE_MISUSE;  }  if( iVal<0 || iVal>=pIter->nCol ){  return SQLITE_RANGE;  }  *ppValue = sqlite3_column_value(pIter->pConflict, iVal);  return SQLITE_OK; } SQLITE_API int sqlite3changeset_fk_conflicts(  sqlite3_changeset_iter *pIter,  int *pnOut ){  if( pIter->pConflict || pIter->apValue ){  return SQLITE_MISUSE;  }  *pnOut = pIter->nCol;  return SQLITE_OK; } SQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *p){  int rc = SQLITE_OK;  if( p ){  int i;  rc = p->rc;  if( p->apValue ){  for(i=0; i<p->nCol*2; i++) sqlite3ValueFree(p->apValue[i]);  }  sqlite3_free(p->tblhdr.aBuf);  sqlite3_free(p->in.buf.aBuf);  sqlite3_free(p);  }  return rc; } static int sessionChangesetInvert(  SessionInput *pInput,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut,  int *pnInverted,  void **ppInverted ){  int rc = SQLITE_OK;  SessionBuffer sOut;  int nCol = 0;  u8 *abPK = 0;  sqlite3_value **apVal = 0;  SessionBuffer sPK = {0, 0, 0};  memset(&sOut, 0, sizeof(SessionBuffer));  if( ppInverted ){  *ppInverted = 0;  *pnInverted = 0;  }  while( 1 ){  u8 eType;  if( (rc = sessionInputBuffer(pInput, 2)) ) goto finished_invert;  if( pInput->iNext>=pInput->nData ) break;  eType = pInput->aData[pInput->iNext];  switch( eType ){  case 'T': {  int nByte;  int nVar;  pInput->iNext++;  if( (rc = sessionChangesetBufferTblhdr(pInput, &nByte)) ){  goto finished_invert;  }  nVar = sessionVarintGet(&pInput->aData[pInput->iNext], &nCol);  sPK.nBuf = 0;  sessionAppendBlob(&sPK, &pInput->aData[pInput->iNext+nVar], nCol, &rc);  sessionAppendByte(&sOut, eType, &rc);  sessionAppendBlob(&sOut, &pInput->aData[pInput->iNext], nByte, &rc);  if( rc ) goto finished_invert;  pInput->iNext += nByte;  sqlite3_free(apVal);  apVal = 0;  abPK = sPK.aBuf;  break;  }  case SQLITE_INSERT:  case SQLITE_DELETE: {  int nByte;  int bIndirect = pInput->aData[pInput->iNext+1];  int eType2 = (eType==SQLITE_DELETE ? SQLITE_INSERT : SQLITE_DELETE);  pInput->iNext += 2;  assert( rc==SQLITE_OK );  rc = sessionChangesetBufferRecord(pInput, nCol, &nByte);  sessionAppendByte(&sOut, eType2, &rc);  sessionAppendByte(&sOut, bIndirect, &rc);  sessionAppendBlob(&sOut, &pInput->aData[pInput->iNext], nByte, &rc);  pInput->iNext += nByte;  if( rc ) goto finished_invert;  break;  }  case SQLITE_UPDATE: {  int iCol;  if( 0==apVal ){  apVal = (sqlite3_value **)sqlite3_malloc64(sizeof(apVal[0])*nCol*2);  if( 0==apVal ){  rc = SQLITE_NOMEM;  goto finished_invert;  }  memset(apVal, 0, sizeof(apVal[0])*nCol*2);  }  sessionAppendByte(&sOut, eType, &rc);  sessionAppendByte(&sOut, pInput->aData[pInput->iNext+1], &rc);  pInput->iNext += 2;  rc = sessionReadRecord(pInput, nCol, 0, &apVal[0], 0);  if( rc==SQLITE_OK ){  rc = sessionReadRecord(pInput, nCol, 0, &apVal[nCol], 0);  }  for(iCol=0; iCol<nCol; iCol++){  sqlite3_value *pVal = apVal[iCol + (abPK[iCol] ? 0 : nCol)];  sessionAppendValue(&sOut, pVal, &rc);  }  for(iCol=0; iCol<nCol; iCol++){  sqlite3_value *pVal = (abPK[iCol] ? 0 : apVal[iCol]);  sessionAppendValue(&sOut, pVal, &rc);  }  for(iCol=0; iCol<nCol*2; iCol++){  sqlite3ValueFree(apVal[iCol]);  }  memset(apVal, 0, sizeof(apVal[0])*nCol*2);  if( rc!=SQLITE_OK ){  goto finished_invert;  }  break;  }  default:  rc = SQLITE_CORRUPT_BKPT;  goto finished_invert;  }  assert( rc==SQLITE_OK );  if( xOutput && sOut.nBuf>=sessions_strm_chunk_size ){  rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);  sOut.nBuf = 0;  if( rc!=SQLITE_OK ) goto finished_invert;  }  }  assert( rc==SQLITE_OK );  if( pnInverted && ALWAYS(ppInverted) ){  *pnInverted = sOut.nBuf;  *ppInverted = sOut.aBuf;  sOut.aBuf = 0;  }else if( sOut.nBuf>0 && ALWAYS(xOutput!=0) ){  rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);  }  finished_invert:  sqlite3_free(sOut.aBuf);  sqlite3_free(apVal);  sqlite3_free(sPK.aBuf);  return rc; } SQLITE_API int sqlite3changeset_invert(  int nChangeset,  const void *pChangeset,  int *pnInverted,  void **ppInverted ){  SessionInput sInput;  memset(&sInput, 0, sizeof(SessionInput));  sInput.nData = nChangeset;  sInput.aData = (u8*)pChangeset;  return sessionChangesetInvert(&sInput, 0, 0, pnInverted, ppInverted); } SQLITE_API int sqlite3changeset_invert_strm(  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ){  SessionInput sInput;  int rc;  memset(&sInput, 0, sizeof(SessionInput));  sInput.xInput = xInput;  sInput.pIn = pIn;  rc = sessionChangesetInvert(&sInput, xOutput, pOut, 0, 0);  sqlite3_free(sInput.buf.aBuf);  return rc; } typedef struct SessionUpdate SessionUpdate; struct SessionUpdate {  sqlite3_stmt *pStmt;  u32 *aMask;  SessionUpdate *pNext; }; typedef struct SessionApplyCtx SessionApplyCtx; struct SessionApplyCtx {  sqlite3 *db;  sqlite3_stmt *pDelete;  sqlite3_stmt *pInsert;  sqlite3_stmt *pSelect;  int nCol;  const char **azCol;  u8 *abPK;  u32 *aUpdateMask;  SessionUpdate *pUp;  int bStat1;  int bDeferConstraints;  int bInvertConstraints;  SessionBuffer constraints;  SessionBuffer rebase;  u8 bRebaseStarted;  u8 bRebase; };
#define SESSION_UPDATE_CACHE_SZ 12
static int sessionUpdateFind(  sqlite3_changeset_iter *pIter,  SessionApplyCtx *p,  int bPatchset,  sqlite3_stmt **ppStmt ){  int rc = SQLITE_OK;  SessionUpdate *pUp = 0;  int nCol = pIter->nCol;  int nU32 = (pIter->nCol+33)/32;  int ii;  if( p->aUpdateMask==0 ){  p->aUpdateMask = sqlite3_malloc(nU32*sizeof(u32));  if( p->aUpdateMask==0 ){  rc = SQLITE_NOMEM;  }  }  if( rc==SQLITE_OK ){  memset(p->aUpdateMask, 0, nU32*sizeof(u32));  rc = SQLITE_CORRUPT;  for(ii=0; ii<pIter->nCol; ii++){  if( sessionChangesetNew(pIter, ii) ){  p->aUpdateMask[ii/32] |= (1<<(ii%32));  rc = SQLITE_OK;  }  }  }  if( rc==SQLITE_OK ){  if( bPatchset ) p->aUpdateMask[nCol/32] |= (1<<(nCol%32));  if( p->pUp ){  int nUp = 0;  SessionUpdate **pp = &p->pUp;  while( 1 ){  nUp++;  if( 0==memcmp(p->aUpdateMask, (*pp)->aMask, nU32*sizeof(u32)) ){  pUp = *pp;  *pp = pUp->pNext;  pUp->pNext = p->pUp;  p->pUp = pUp;  break;  }  if( (*pp)->pNext ){  pp = &(*pp)->pNext;  }else{  if( nUp>=SESSION_UPDATE_CACHE_SZ ){  sqlite3_finalize((*pp)->pStmt);  sqlite3_free(*pp);  *pp = 0;  }  break;  }  }  }  if( pUp==0 ){  int nByte = sizeof(SessionUpdate) * nU32*sizeof(u32);  int bStat1 = (sqlite3_stricmp(pIter->zTab, "sqlite_stat1")==0);  pUp = (SessionUpdate*)sqlite3_malloc(nByte);  if( pUp==0 ){  rc = SQLITE_NOMEM;  }else{  const char *zSep = "";  SessionBuffer buf;  memset(&buf, 0, sizeof(buf));  pUp->aMask = (u32*)&pUp[1];  memcpy(pUp->aMask, p->aUpdateMask, nU32*sizeof(u32));  sessionAppendStr(&buf, "UPDATE main.", &rc);  sessionAppendIdent(&buf, pIter->zTab, &rc);  sessionAppendStr(&buf, " SET ", &rc);  for(ii=0; ii<pIter->nCol; ii++){  if( p->abPK[ii]==0 && sessionChangesetNew(pIter, ii) ){  sessionAppendStr(&buf, zSep, &rc);  sessionAppendIdent(&buf, p->azCol[ii], &rc);  sessionAppendStr(&buf, " = ?", &rc);  sessionAppendInteger(&buf, ii*2+1, &rc);  zSep = ", ";  }  }  zSep = "";  sessionAppendStr(&buf, " WHERE ", &rc);  for(ii=0; ii<pIter->nCol; ii++){  if( p->abPK[ii] || (bPatchset==0 && sessionChangesetOld(pIter, ii)) ){  sessionAppendStr(&buf, zSep, &rc);  if( bStat1 && ii==1 ){  assert( sqlite3_stricmp(p->azCol[ii], "idx")==0 );  sessionAppendStr(&buf,  "idx IS CASE "  "WHEN length(?4)=0 AND typeof(?4)='blob' THEN NULL "  "ELSE ?4 END ", &rc  );  }else{  sessionAppendIdent(&buf, p->azCol[ii], &rc);  sessionAppendStr(&buf, " IS ?", &rc);  sessionAppendInteger(&buf, ii*2+2, &rc);  }  zSep = " AND ";  }  }  if( rc==SQLITE_OK ){  char *zSql = (char*)buf.aBuf;  rc = sqlite3_prepare_v2(p->db, zSql, buf.nBuf, &pUp->pStmt, 0);  }  if( rc!=SQLITE_OK ){  sqlite3_free(pUp);  pUp = 0;  }else{  pUp->pNext = p->pUp;  p->pUp = pUp;  }  sqlite3_free(buf.aBuf);  }  }  }  assert( (rc==SQLITE_OK)==(pUp!=0) );  if( pUp ){  *ppStmt = pUp->pStmt;  }else{  *ppStmt = 0;  }  return rc; } static void sessionUpdateFree(SessionApplyCtx *p){  SessionUpdate *pUp;  SessionUpdate *pNext;  for(pUp=p->pUp; pUp; pUp=pNext){  pNext = pUp->pNext;  sqlite3_finalize(pUp->pStmt);  sqlite3_free(pUp);  }  p->pUp = 0;  sqlite3_free(p->aUpdateMask);  p->aUpdateMask = 0; } static int sessionDeleteRow(  sqlite3 *db,  const char *zTab,  SessionApplyCtx *p ){  int i;  const char *zSep = "";  int rc = SQLITE_OK;  SessionBuffer buf = {0, 0, 0};  int nPk = 0;  sessionAppendStr(&buf, "DELETE FROM main.", &rc);  sessionAppendIdent(&buf, zTab, &rc);  sessionAppendStr(&buf, " WHERE ", &rc);  for(i=0; i<p->nCol; i++){  if( p->abPK[i] ){  nPk++;  sessionAppendStr(&buf, zSep, &rc);  sessionAppendIdent(&buf, p->azCol[i], &rc);  sessionAppendStr(&buf, " = ?", &rc);  sessionAppendInteger(&buf, i+1, &rc);  zSep = " AND ";  }  }  if( nPk<p->nCol ){  sessionAppendStr(&buf, " AND (?", &rc);  sessionAppendInteger(&buf, p->nCol+1, &rc);  sessionAppendStr(&buf, " OR ", &rc);  zSep = "";  for(i=0; i<p->nCol; i++){  if( !p->abPK[i] ){  sessionAppendStr(&buf, zSep, &rc);  sessionAppendIdent(&buf, p->azCol[i], &rc);  sessionAppendStr(&buf, " IS ?", &rc);  sessionAppendInteger(&buf, i+1, &rc);  zSep = "AND ";  }  }  sessionAppendStr(&buf, ")", &rc);  }  if( rc==SQLITE_OK ){  rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, &p->pDelete, 0);  }  sqlite3_free(buf.aBuf);  return rc; } static int sessionSelectRow(  sqlite3 *db,  const char *zTab,  SessionApplyCtx *p ){  return sessionSelectStmt(  db, "main", zTab, p->nCol, p->azCol, p->abPK, &p->pSelect); } static int sessionInsertRow(  sqlite3 *db,  const char *zTab,  SessionApplyCtx *p ){  int rc = SQLITE_OK;  int i;  SessionBuffer buf = {0, 0, 0};  sessionAppendStr(&buf, "INSERT INTO main.", &rc);  sessionAppendIdent(&buf, zTab, &rc);  sessionAppendStr(&buf, "(", &rc);  for(i=0; i<p->nCol; i++){  if( i!=0 ) sessionAppendStr(&buf, ", ", &rc);  sessionAppendIdent(&buf, p->azCol[i], &rc);  }  sessionAppendStr(&buf, ") VALUES(?", &rc);  for(i=1; i<p->nCol; i++){  sessionAppendStr(&buf, ", ?", &rc);  }  sessionAppendStr(&buf, ")", &rc);  if( rc==SQLITE_OK ){  rc = sqlite3_prepare_v2(db, (char *)buf.aBuf, buf.nBuf, &p->pInsert, 0);  }  sqlite3_free(buf.aBuf);  return rc; } static int sessionPrepare(sqlite3 *db, sqlite3_stmt **pp, const char *zSql){  return sqlite3_prepare_v2(db, zSql, -1, pp, 0); } static int sessionStat1Sql(sqlite3 *db, SessionApplyCtx *p){  int rc = sessionSelectRow(db, "sqlite_stat1", p);  if( rc==SQLITE_OK ){  rc = sessionPrepare(db, &p->pInsert,  "INSERT INTO main.sqlite_stat1 VALUES(?1, "  "CASE WHEN length(?2)=0 AND typeof(?2)='blob' THEN NULL ELSE ?2 END, "  "?3)"  );  }  if( rc==SQLITE_OK ){  rc = sessionPrepare(db, &p->pDelete,  "DELETE FROM main.sqlite_stat1 WHERE tbl=?1 AND idx IS "  "CASE WHEN length(?2)=0 AND typeof(?2)='blob' THEN NULL ELSE ?2 END "  "AND (?4 OR stat IS ?3)"  );  }  return rc; } static int sessionBindValue(  sqlite3_stmt *pStmt,  int i,  sqlite3_value *pVal ){  int eType = sqlite3_value_type(pVal);  if( (eType==SQLITE_TEXT || eType==SQLITE_BLOB) && pVal->z==0 ){  return SQLITE_NOMEM;  }  return sqlite3_bind_value(pStmt, i, pVal); } static int sessionBindRow(  sqlite3_changeset_iter *pIter,  int(*xValue)(sqlite3_changeset_iter *, int, sqlite3_value **),  int nCol,  u8 *abPK,  sqlite3_stmt *pStmt ){  int i;  int rc = SQLITE_OK;  assert( xValue==sqlite3changeset_old || xValue==sqlite3changeset_new );  for(i=0; rc==SQLITE_OK && i<nCol; i++){  if( !abPK || abPK[i] ){  sqlite3_value *pVal = 0;  (void)xValue(pIter, i, &pVal);  if( pVal==0 ){  rc = SQLITE_CORRUPT_BKPT;  }else{  rc = sessionBindValue(pStmt, i+1, pVal);  }  }  }  return rc; } static int sessionSeekToRow(  sqlite3 *db,  sqlite3_changeset_iter *pIter,  u8 *abPK,  sqlite3_stmt *pSelect ){  int rc;  int nCol;  int op;  const char *zDummy;  sqlite3changeset_op(pIter, &zDummy, &nCol, &op, 0);  rc = sessionBindRow(pIter,  op==SQLITE_INSERT ? sqlite3changeset_new : sqlite3changeset_old,  nCol, abPK, pSelect  );  if( rc==SQLITE_OK ){  rc = sqlite3_step(pSelect);  if( rc!=SQLITE_ROW ) rc = sqlite3_reset(pSelect);  }  return rc; } static int sessionRebaseAdd(  SessionApplyCtx *p,  int eType,  sqlite3_changeset_iter *pIter ){  int rc = SQLITE_OK;  if( p->bRebase ){  int i;  int eOp = pIter->op;  if( p->bRebaseStarted==0 ){  const char *zTab = pIter->zTab;  sessionAppendByte(&p->rebase, 'T', &rc);  sessionAppendVarint(&p->rebase, p->nCol, &rc);  sessionAppendBlob(&p->rebase, p->abPK, p->nCol, &rc);  sessionAppendBlob(&p->rebase, (u8*)zTab, (int)strlen(zTab)+1, &rc);  p->bRebaseStarted = 1;  }  assert( eType==SQLITE_CHANGESET_REPLACE||eType==SQLITE_CHANGESET_OMIT );  assert( eOp==SQLITE_DELETE || eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE );  sessionAppendByte(&p->rebase,  (eOp==SQLITE_DELETE ? SQLITE_DELETE : SQLITE_INSERT), &rc  );  sessionAppendByte(&p->rebase, (eType==SQLITE_CHANGESET_REPLACE), &rc);  for(i=0; i<p->nCol; i++){  sqlite3_value *pVal = 0;  if( eOp==SQLITE_DELETE || (eOp==SQLITE_UPDATE && p->abPK[i]) ){  sqlite3changeset_old(pIter, i, &pVal);  }else{  sqlite3changeset_new(pIter, i, &pVal);  }  sessionAppendValue(&p->rebase, pVal, &rc);  }  }  return rc; } static int sessionConflictHandler(  int eType,  SessionApplyCtx *p,  sqlite3_changeset_iter *pIter,  int(*xConflict)(void *, int, sqlite3_changeset_iter*),  void *pCtx,  int *pbReplace ){  int res = 0;  int rc;  int nCol;  int op;  const char *zDummy;  sqlite3changeset_op(pIter, &zDummy, &nCol, &op, 0);  assert( eType==SQLITE_CHANGESET_CONFLICT || eType==SQLITE_CHANGESET_DATA );  assert( SQLITE_CHANGESET_CONFLICT+1==SQLITE_CHANGESET_CONSTRAINT );  assert( SQLITE_CHANGESET_DATA+1==SQLITE_CHANGESET_NOTFOUND );  if( pbReplace ){  rc = sessionSeekToRow(p->db, pIter, p->abPK, p->pSelect);  }else{  rc = SQLITE_OK;  }  if( rc==SQLITE_ROW ){  pIter->pConflict = p->pSelect;  res = xConflict(pCtx, eType, pIter);  pIter->pConflict = 0;  rc = sqlite3_reset(p->pSelect);  }else if( rc==SQLITE_OK ){  if( p->bDeferConstraints && eType==SQLITE_CHANGESET_CONFLICT ){  u8 *aBlob = &pIter->in.aData[pIter->in.iCurrent];  int nBlob = pIter->in.iNext - pIter->in.iCurrent;  sessionAppendBlob(&p->constraints, aBlob, nBlob, &rc);  return SQLITE_OK;  }else{  res = xConflict(pCtx, eType+1, pIter);  if( res==SQLITE_CHANGESET_REPLACE ) rc = SQLITE_MISUSE;  }  }  if( rc==SQLITE_OK ){  switch( res ){  case SQLITE_CHANGESET_REPLACE:  assert( pbReplace );  *pbReplace = 1;  break;  case SQLITE_CHANGESET_OMIT:  break;  case SQLITE_CHANGESET_ABORT:  rc = SQLITE_ABORT;  break;  default:  rc = SQLITE_MISUSE;  break;  }  if( rc==SQLITE_OK ){  rc = sessionRebaseAdd(p, res, pIter);  }  }  return rc; } static int sessionApplyOneOp(  sqlite3_changeset_iter *pIter,  SessionApplyCtx *p,  int(*xConflict)(void *, int, sqlite3_changeset_iter *),  void *pCtx,  int *pbReplace,  int *pbRetry ){  const char *zDummy;  int op;  int nCol;  int rc = SQLITE_OK;  assert( p->pDelete && p->pInsert && p->pSelect );  assert( p->azCol && p->abPK );  assert( !pbReplace || *pbReplace==0 );  sqlite3changeset_op(pIter, &zDummy, &nCol, &op, 0);  if( op==SQLITE_DELETE ){  u8 *abPK = (pIter->bPatchset ? p->abPK : 0);  rc = sessionBindRow(pIter, sqlite3changeset_old, nCol, abPK, p->pDelete);  if( rc==SQLITE_OK && sqlite3_bind_parameter_count(p->pDelete)>nCol ){  rc = sqlite3_bind_int(p->pDelete, nCol+1, (pbRetry==0 || abPK));  }  if( rc!=SQLITE_OK ) return rc;  sqlite3_step(p->pDelete);  rc = sqlite3_reset(p->pDelete);  if( rc==SQLITE_OK && sqlite3_changes(p->db)==0 ){  rc = sessionConflictHandler(  SQLITE_CHANGESET_DATA, p, pIter, xConflict, pCtx, pbRetry  );  }else if( (rc&0xff)==SQLITE_CONSTRAINT ){  rc = sessionConflictHandler(  SQLITE_CHANGESET_CONFLICT, p, pIter, xConflict, pCtx, 0  );  }  }else if( op==SQLITE_UPDATE ){  int i;  sqlite3_stmt *pUp = 0;  int bPatchset = (pbRetry==0 || pIter->bPatchset);  rc = sessionUpdateFind(pIter, p, bPatchset, &pUp);  for(i=0; rc==SQLITE_OK && i<nCol; i++){  sqlite3_value *pOld = sessionChangesetOld(pIter, i);  sqlite3_value *pNew = sessionChangesetNew(pIter, i);  if( p->abPK[i] || (bPatchset==0 && pOld) ){  rc = sessionBindValue(pUp, i*2+2, pOld);  }  if( rc==SQLITE_OK && pNew ){  rc = sessionBindValue(pUp, i*2+1, pNew);  }  }  if( rc!=SQLITE_OK ) return rc;  sqlite3_step(pUp);  rc = sqlite3_reset(pUp);  if( rc==SQLITE_OK && sqlite3_changes(p->db)==0 ){  rc = sessionConflictHandler(  SQLITE_CHANGESET_DATA, p, pIter, xConflict, pCtx, pbRetry  );  }else if( (rc&0xff)==SQLITE_CONSTRAINT ){  rc = sessionConflictHandler(  SQLITE_CHANGESET_CONFLICT, p, pIter, xConflict, pCtx, 0  );  }  }else{  assert( op==SQLITE_INSERT );  if( p->bStat1 ){  rc = sessionSeekToRow(p->db, pIter, p->abPK, p->pSelect);  if( rc==SQLITE_ROW ){  rc = SQLITE_CONSTRAINT;  sqlite3_reset(p->pSelect);  }  }  if( rc==SQLITE_OK ){  rc = sessionBindRow(pIter, sqlite3changeset_new, nCol, 0, p->pInsert);  if( rc!=SQLITE_OK ) return rc;  sqlite3_step(p->pInsert);  rc = sqlite3_reset(p->pInsert);  }  if( (rc&0xff)==SQLITE_CONSTRAINT ){  rc = sessionConflictHandler(  SQLITE_CHANGESET_CONFLICT, p, pIter, xConflict, pCtx, pbReplace  );  }  }  return rc; } static int sessionApplyOneWithRetry(  sqlite3 *db,  sqlite3_changeset_iter *pIter,  SessionApplyCtx *pApply,  int(*xConflict)(void*, int, sqlite3_changeset_iter*),  void *pCtx ){  int bReplace = 0;  int bRetry = 0;  int rc;  rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, &bReplace, &bRetry);  if( rc==SQLITE_OK ){  if( bRetry ){  assert( pIter->op==SQLITE_UPDATE || pIter->op==SQLITE_DELETE );  rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);  }  else if( bReplace ){  assert( pIter->op==SQLITE_INSERT );  rc = sqlite3_exec(db, "SAVEPOINT replace_op", 0, 0, 0);  if( rc==SQLITE_OK ){  rc = sessionBindRow(pIter,  sqlite3changeset_new, pApply->nCol, pApply->abPK, pApply->pDelete);  sqlite3_bind_int(pApply->pDelete, pApply->nCol+1, 1);  }  if( rc==SQLITE_OK ){  sqlite3_step(pApply->pDelete);  rc = sqlite3_reset(pApply->pDelete);  }  if( rc==SQLITE_OK ){  rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);  }  if( rc==SQLITE_OK ){  rc = sqlite3_exec(db, "RELEASE replace_op", 0, 0, 0);  }  }  }  return rc; } static int sessionRetryConstraints(  sqlite3 *db,  int bPatchset,  const char *zTab,  SessionApplyCtx *pApply,  int(*xConflict)(void*, int, sqlite3_changeset_iter*),  void *pCtx ){  int rc = SQLITE_OK;  while( pApply->constraints.nBuf ){  sqlite3_changeset_iter *pIter2 = 0;  SessionBuffer cons = pApply->constraints;  memset(&pApply->constraints, 0, sizeof(SessionBuffer));  rc = sessionChangesetStart(  &pIter2, 0, 0, cons.nBuf, cons.aBuf, pApply->bInvertConstraints, 1  );  if( rc==SQLITE_OK ){  size_t nByte = 2*pApply->nCol*sizeof(sqlite3_value*);  int rc2;  pIter2->bPatchset = bPatchset;  pIter2->zTab = (char*)zTab;  pIter2->nCol = pApply->nCol;  pIter2->abPK = pApply->abPK;  sessionBufferGrow(&pIter2->tblhdr, nByte, &rc);  pIter2->apValue = (sqlite3_value**)pIter2->tblhdr.aBuf;  if( rc==SQLITE_OK ) memset(pIter2->apValue, 0, nByte);  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3changeset_next(pIter2) ){  rc = sessionApplyOneWithRetry(db, pIter2, pApply, xConflict, pCtx);  }  rc2 = sqlite3changeset_finalize(pIter2);  if( rc==SQLITE_OK ) rc = rc2;  }  assert( pApply->bDeferConstraints || pApply->constraints.nBuf==0 );  sqlite3_free(cons.aBuf);  if( rc!=SQLITE_OK ) break;  if( pApply->constraints.nBuf>=cons.nBuf ){  pApply->bDeferConstraints = 0;  }  }  return rc; } static int sessionChangesetApply(  sqlite3 *db,  sqlite3_changeset_iter *pIter,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx,  void **ppRebase, int *pnRebase,  int flags ){  int schemaMismatch = 0;  int rc = SQLITE_OK;  const char *zTab = 0;  int nTab = 0;  SessionApplyCtx sApply;  int bPatchset;  assert( xConflict!=0 );  pIter->in.bNoDiscard = 1;  memset(&sApply, 0, sizeof(sApply));  sApply.bRebase = (ppRebase && pnRebase);  sApply.bInvertConstraints = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);  sqlite3_mutex_enter(sqlite3_db_mutex(db));  if( (flags & SQLITE_CHANGESETAPPLY_NOSAVEPOINT)==0 ){  rc = sqlite3_exec(db, "SAVEPOINT changeset_apply", 0, 0, 0);  }  if( rc==SQLITE_OK ){  rc = sqlite3_exec(db, "PRAGMA defer_foreign_keys = 1", 0, 0, 0);  }  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3changeset_next(pIter) ){  int nCol;  int op;  const char *zNew;  sqlite3changeset_op(pIter, &zNew, &nCol, &op, 0);  if( zTab==0 || sqlite3_strnicmp(zNew, zTab, nTab+1) ){  u8 *abPK;  rc = sessionRetryConstraints(  db, pIter->bPatchset, zTab, &sApply, xConflict, pCtx  );  if( rc!=SQLITE_OK ) break;  sessionUpdateFree(&sApply);  sqlite3_free((char*)sApply.azCol);  sqlite3_finalize(sApply.pDelete);  sqlite3_finalize(sApply.pInsert);  sqlite3_finalize(sApply.pSelect);  sApply.db = db;  sApply.pDelete = 0;  sApply.pInsert = 0;  sApply.pSelect = 0;  sApply.nCol = 0;  sApply.azCol = 0;  sApply.abPK = 0;  sApply.bStat1 = 0;  sApply.bDeferConstraints = 1;  sApply.bRebaseStarted = 0;  memset(&sApply.constraints, 0, sizeof(SessionBuffer));  schemaMismatch = (xFilter && (0==xFilter(pCtx, zNew)));  if( schemaMismatch ){  zTab = sqlite3_mprintf("%s", zNew);  if( zTab==0 ){  rc = SQLITE_NOMEM;  break;  }  nTab = (int)strlen(zTab);  sApply.azCol = (const char **)zTab;  }else{  int nMinCol = 0;  int i;  sqlite3changeset_pk(pIter, &abPK, 0);  rc = sessionTableInfo(0,  db, "main", zNew, &sApply.nCol, &zTab, &sApply.azCol, &sApply.abPK  );  if( rc!=SQLITE_OK ) break;  for(i=0; i<sApply.nCol; i++){  if( sApply.abPK[i] ) nMinCol = i+1;  }  if( sApply.nCol==0 ){  schemaMismatch = 1;  sqlite3_log(SQLITE_SCHEMA,  "sqlite3changeset_apply(): no such table: %s", zTab  );  }  else if( sApply.nCol<nCol ){  schemaMismatch = 1;  sqlite3_log(SQLITE_SCHEMA,  "sqlite3changeset_apply(): table %s has %d columns, "  "expected %d or more",  zTab, sApply.nCol, nCol  );  }  else if( nCol<nMinCol || memcmp(sApply.abPK, abPK, nCol)!=0 ){  schemaMismatch = 1;  sqlite3_log(SQLITE_SCHEMA, "sqlite3changeset_apply(): "  "primary key mismatch for table %s", zTab  );  }  else{  sApply.nCol = nCol;  if( 0==sqlite3_stricmp(zTab, "sqlite_stat1") ){  if( (rc = sessionStat1Sql(db, &sApply) ) ){  break;  }  sApply.bStat1 = 1;  }else{  if( (rc = sessionSelectRow(db, zTab, &sApply))   || (rc = sessionDeleteRow(db, zTab, &sApply))   || (rc = sessionInsertRow(db, zTab, &sApply))  ){  break;  }  sApply.bStat1 = 0;  }  }  nTab = sqlite3Strlen30(zTab);  }  }  if( schemaMismatch ) continue;  rc = sessionApplyOneWithRetry(db, pIter, &sApply, xConflict, pCtx);  }  bPatchset = pIter->bPatchset;  if( rc==SQLITE_OK ){  rc = sqlite3changeset_finalize(pIter);  }else{  sqlite3changeset_finalize(pIter);  }  if( rc==SQLITE_OK ){  rc = sessionRetryConstraints(db, bPatchset, zTab, &sApply, xConflict, pCtx);  }  if( rc==SQLITE_OK ){  int nFk, notUsed;  sqlite3_db_status(db, SQLITE_DBSTATUS_DEFERRED_FKS, &nFk, &notUsed, 0);  if( nFk!=0 ){  int res = SQLITE_CHANGESET_ABORT;  sqlite3_changeset_iter sIter;  memset(&sIter, 0, sizeof(sIter));  sIter.nCol = nFk;  res = xConflict(pCtx, SQLITE_CHANGESET_FOREIGN_KEY, &sIter);  if( res!=SQLITE_CHANGESET_OMIT ){  rc = SQLITE_CONSTRAINT;  }  }  }  sqlite3_exec(db, "PRAGMA defer_foreign_keys = 0", 0, 0, 0);  if( (flags & SQLITE_CHANGESETAPPLY_NOSAVEPOINT)==0 ){  if( rc==SQLITE_OK ){  rc = sqlite3_exec(db, "RELEASE changeset_apply", 0, 0, 0);  }else{  sqlite3_exec(db, "ROLLBACK TO changeset_apply", 0, 0, 0);  sqlite3_exec(db, "RELEASE changeset_apply", 0, 0, 0);  }  }  assert( sApply.bRebase || sApply.rebase.nBuf==0 );  if( rc==SQLITE_OK && bPatchset==0 && sApply.bRebase ){  *ppRebase = (void*)sApply.rebase.aBuf;  *pnRebase = sApply.rebase.nBuf;  sApply.rebase.aBuf = 0;  }  sessionUpdateFree(&sApply);  sqlite3_finalize(sApply.pInsert);  sqlite3_finalize(sApply.pDelete);  sqlite3_finalize(sApply.pSelect);  sqlite3_free((char*)sApply.azCol);  sqlite3_free((char*)sApply.constraints.aBuf);  sqlite3_free((char*)sApply.rebase.aBuf);  sqlite3_mutex_leave(sqlite3_db_mutex(db));  return rc; } SQLITE_API int sqlite3changeset_apply_v2(  sqlite3 *db,  int nChangeset,  void *pChangeset,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx,  void **ppRebase, int *pnRebase,  int flags ){  sqlite3_changeset_iter *pIter;  int bInv = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);  int rc = sessionChangesetStart(&pIter, 0, 0, nChangeset, pChangeset, bInv, 1);  if( rc==SQLITE_OK ){  rc = sessionChangesetApply(  db, pIter, xFilter, xConflict, pCtx, ppRebase, pnRebase, flags  );  }  return rc; } SQLITE_API int sqlite3changeset_apply(  sqlite3 *db,  int nChangeset,  void *pChangeset,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx ){  return sqlite3changeset_apply_v2(  db, nChangeset, pChangeset, xFilter, xConflict, pCtx, 0, 0, 0  ); } SQLITE_API int sqlite3changeset_apply_v2_strm(  sqlite3 *db,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx,  void **ppRebase, int *pnRebase,  int flags ){  sqlite3_changeset_iter *pIter;  int bInverse = !!(flags & SQLITE_CHANGESETAPPLY_INVERT);  int rc = sessionChangesetStart(&pIter, xInput, pIn, 0, 0, bInverse, 1);  if( rc==SQLITE_OK ){  rc = sessionChangesetApply(  db, pIter, xFilter, xConflict, pCtx, ppRebase, pnRebase, flags  );  }  return rc; } SQLITE_API int sqlite3changeset_apply_strm(  sqlite3 *db,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int(*xFilter)(  void *pCtx,  const char *zTab  ),  int(*xConflict)(  void *pCtx,  int eConflict,  sqlite3_changeset_iter *p  ),  void *pCtx ){  return sqlite3changeset_apply_v2_strm(  db, xInput, pIn, xFilter, xConflict, pCtx, 0, 0, 0  ); } struct sqlite3_changegroup {  int rc;  int bPatch;  SessionTable *pList; }; static int sessionChangeMerge(  SessionTable *pTab,  int bRebase,  int bPatchset,  SessionChange *pExist,  int op2,  int bIndirect,  u8 *aRec,  int nRec,  SessionChange **ppNew ){  SessionChange *pNew = 0;  int rc = SQLITE_OK;  if( !pExist ){  pNew = (SessionChange *)sqlite3_malloc64(sizeof(SessionChange) + nRec);  if( !pNew ){  return SQLITE_NOMEM;  }  memset(pNew, 0, sizeof(SessionChange));  pNew->op = op2;  pNew->bIndirect = bIndirect;  pNew->aRecord = (u8*)&pNew[1];  if( bIndirect==0 || bRebase==0 ){  pNew->nRecord = nRec;  memcpy(pNew->aRecord, aRec, nRec);  }else{  int i;  u8 *pIn = aRec;  u8 *pOut = pNew->aRecord;  for(i=0; i<pTab->nCol; i++){  int nIn = sessionSerialLen(pIn);  if( *pIn==0 ){  *pOut++ = 0;  }else if( pTab->abPK[i]==0 ){  *pOut++ = 0xFF;  }else{  memcpy(pOut, pIn, nIn);  pOut += nIn;  }  pIn += nIn;  }  pNew->nRecord = pOut - pNew->aRecord;  }  }else if( bRebase ){  if( pExist->op==SQLITE_DELETE && pExist->bIndirect ){  *ppNew = pExist;  }else{  sqlite3_int64 nByte = nRec + pExist->nRecord + sizeof(SessionChange);  pNew = (SessionChange*)sqlite3_malloc64(nByte);  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  int i;  u8 *a1 = pExist->aRecord;  u8 *a2 = aRec;  u8 *pOut;  memset(pNew, 0, nByte);  pNew->bIndirect = bIndirect || pExist->bIndirect;  pNew->op = op2;  pOut = pNew->aRecord = (u8*)&pNew[1];  for(i=0; i<pTab->nCol; i++){  int n1 = sessionSerialLen(a1);  int n2 = sessionSerialLen(a2);  if( *a1==0xFF || (pTab->abPK[i]==0 && bIndirect) ){  *pOut++ = 0xFF;  }else if( *a2==0 ){  memcpy(pOut, a1, n1);  pOut += n1;  }else{  memcpy(pOut, a2, n2);  pOut += n2;  }  a1 += n1;  a2 += n2;  }  pNew->nRecord = pOut - pNew->aRecord;  }  sqlite3_free(pExist);  }  }else{  int op1 = pExist->op;  if( (op1==SQLITE_INSERT && op2==SQLITE_INSERT)   || (op1==SQLITE_UPDATE && op2==SQLITE_INSERT)   || (op1==SQLITE_DELETE && op2==SQLITE_UPDATE)   || (op1==SQLITE_DELETE && op2==SQLITE_DELETE)  ){  pNew = pExist;  }else if( op1==SQLITE_INSERT && op2==SQLITE_DELETE ){  sqlite3_free(pExist);  assert( pNew==0 );  }else{  u8 *aExist = pExist->aRecord;  sqlite3_int64 nByte;  u8 *aCsr;  nByte = sizeof(SessionChange) + pExist->nRecord + nRec;  pNew = (SessionChange *)sqlite3_malloc64(nByte);  if( !pNew ){  sqlite3_free(pExist);  return SQLITE_NOMEM;  }  memset(pNew, 0, sizeof(SessionChange));  pNew->bIndirect = (bIndirect && pExist->bIndirect);  aCsr = pNew->aRecord = (u8 *)&pNew[1];  if( op1==SQLITE_INSERT ){  u8 *a1 = aRec;  assert( op2==SQLITE_UPDATE );  pNew->op = SQLITE_INSERT;  if( bPatchset==0 ) sessionSkipRecord(&a1, pTab->nCol);  sessionMergeRecord(&aCsr, pTab->nCol, aExist, a1);  }else if( op1==SQLITE_DELETE ){  assert( op2==SQLITE_INSERT );  pNew->op = SQLITE_UPDATE;  if( bPatchset ){  memcpy(aCsr, aRec, nRec);  aCsr += nRec;  }else{  if( 0==sessionMergeUpdate(&aCsr, pTab, bPatchset, aExist, 0,aRec,0) ){  sqlite3_free(pNew);  pNew = 0;  }  }  }else if( op2==SQLITE_UPDATE ){  u8 *a1 = aExist;  u8 *a2 = aRec;  assert( op1==SQLITE_UPDATE );  if( bPatchset==0 ){  sessionSkipRecord(&a1, pTab->nCol);  sessionSkipRecord(&a2, pTab->nCol);  }  pNew->op = SQLITE_UPDATE;  if( 0==sessionMergeUpdate(&aCsr, pTab, bPatchset, aRec, aExist,a1,a2) ){  sqlite3_free(pNew);  pNew = 0;  }  }else{  assert( op1==SQLITE_UPDATE && op2==SQLITE_DELETE );  pNew->op = SQLITE_DELETE;  if( bPatchset ){  memcpy(aCsr, aRec, nRec);  aCsr += nRec;  }else{  sessionMergeRecord(&aCsr, pTab->nCol, aRec, aExist);  }  }  if( pNew ){  pNew->nRecord = (int)(aCsr - pNew->aRecord);  }  sqlite3_free(pExist);  }  }  *ppNew = pNew;  return rc; } static int sessionChangesetToHash(  sqlite3_changeset_iter *pIter,  sqlite3_changegroup *pGrp,  int bRebase ){  u8 *aRec;  int nRec;  int rc = SQLITE_OK;  SessionTable *pTab = 0;  while( SQLITE_ROW==sessionChangesetNext(pIter, &aRec, &nRec, 0) ){  const char *zNew;  int nCol;  int op;  int iHash;  int bIndirect;  SessionChange *pChange;  SessionChange *pExist = 0;  SessionChange **pp;  if( pGrp->pList==0 ){  pGrp->bPatch = pIter->bPatchset;  }else if( pIter->bPatchset!=pGrp->bPatch ){  rc = SQLITE_ERROR;  break;  }  sqlite3changeset_op(pIter, &zNew, &nCol, &op, &bIndirect);  if( !pTab || sqlite3_stricmp(zNew, pTab->zName) ){  int nNew = (int)strlen(zNew);  u8 *abPK;  sqlite3changeset_pk(pIter, &abPK, 0);  for(pTab = pGrp->pList; pTab; pTab=pTab->pNext){  if( 0==sqlite3_strnicmp(pTab->zName, zNew, nNew+1) ) break;  }  if( !pTab ){  SessionTable **ppTab;  pTab = sqlite3_malloc64(sizeof(SessionTable) + nCol + nNew+1);  if( !pTab ){  rc = SQLITE_NOMEM;  break;  }  memset(pTab, 0, sizeof(SessionTable));  pTab->nCol = nCol;  pTab->abPK = (u8*)&pTab[1];  memcpy(pTab->abPK, abPK, nCol);  pTab->zName = (char*)&pTab->abPK[nCol];  memcpy(pTab->zName, zNew, nNew+1);  for(ppTab=&pGrp->pList; *ppTab; ppTab=&(*ppTab)->pNext);  *ppTab = pTab;  }else if( pTab->nCol!=nCol || memcmp(pTab->abPK, abPK, nCol) ){  rc = SQLITE_SCHEMA;  break;  }  }  if( sessionGrowHash(0, pIter->bPatchset, pTab) ){  rc = SQLITE_NOMEM;  break;  }  iHash = sessionChangeHash(  pTab, (pIter->bPatchset && op==SQLITE_DELETE), aRec, pTab->nChange  );  for(pp=&pTab->apChange[iHash]; *pp; pp=&(*pp)->pNext){  int bPkOnly1 = 0;  int bPkOnly2 = 0;  if( pIter->bPatchset ){  bPkOnly1 = (*pp)->op==SQLITE_DELETE;  bPkOnly2 = op==SQLITE_DELETE;  }  if( sessionChangeEqual(pTab, bPkOnly1, (*pp)->aRecord, bPkOnly2, aRec) ){  pExist = *pp;  *pp = (*pp)->pNext;  pTab->nEntry--;  break;  }  }  rc = sessionChangeMerge(pTab, bRebase,  pIter->bPatchset, pExist, op, bIndirect, aRec, nRec, &pChange  );  if( rc ) break;  if( pChange ){  pChange->pNext = pTab->apChange[iHash];  pTab->apChange[iHash] = pChange;  pTab->nEntry++;  }  }  if( rc==SQLITE_OK ) rc = pIter->rc;  return rc; } static int sessionChangegroupOutput(  sqlite3_changegroup *pGrp,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut,  int *pnOut,  void **ppOut ){  int rc = SQLITE_OK;  SessionBuffer buf = {0, 0, 0};  SessionTable *pTab;  assert( xOutput==0 || (ppOut==0 && pnOut==0) );  for(pTab=pGrp->pList; rc==SQLITE_OK && pTab; pTab=pTab->pNext){  int i;  if( pTab->nEntry==0 ) continue;  sessionAppendTableHdr(&buf, pGrp->bPatch, pTab, &rc);  for(i=0; i<pTab->nChange; i++){  SessionChange *p;  for(p=pTab->apChange[i]; p; p=p->pNext){  sessionAppendByte(&buf, p->op, &rc);  sessionAppendByte(&buf, p->bIndirect, &rc);  sessionAppendBlob(&buf, p->aRecord, p->nRecord, &rc);  if( rc==SQLITE_OK && xOutput && buf.nBuf>=sessions_strm_chunk_size ){  rc = xOutput(pOut, buf.aBuf, buf.nBuf);  buf.nBuf = 0;  }  }  }  }  if( rc==SQLITE_OK ){  if( xOutput ){  if( buf.nBuf>0 ) rc = xOutput(pOut, buf.aBuf, buf.nBuf);  }else if( ppOut ){  *ppOut = buf.aBuf;  if( pnOut ) *pnOut = buf.nBuf;  buf.aBuf = 0;  }  }  sqlite3_free(buf.aBuf);  return rc; } SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp){  int rc = SQLITE_OK;  sqlite3_changegroup *p;  p = (sqlite3_changegroup*)sqlite3_malloc(sizeof(sqlite3_changegroup));  if( p==0 ){  rc = SQLITE_NOMEM;  }else{  memset(p, 0, sizeof(sqlite3_changegroup));  }  *pp = p;  return rc; } SQLITE_API int sqlite3changegroup_add(sqlite3_changegroup *pGrp, int nData, void *pData){  sqlite3_changeset_iter *pIter;  int rc;  rc = sqlite3changeset_start(&pIter, nData, pData);  if( rc==SQLITE_OK ){  rc = sessionChangesetToHash(pIter, pGrp, 0);  }  sqlite3changeset_finalize(pIter);  return rc; } SQLITE_API int sqlite3changegroup_output(  sqlite3_changegroup *pGrp,  int *pnData,  void **ppData ){  return sessionChangegroupOutput(pGrp, 0, 0, pnData, ppData); } SQLITE_API int sqlite3changegroup_add_strm(  sqlite3_changegroup *pGrp,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn ){  sqlite3_changeset_iter *pIter;  int rc;  rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);  if( rc==SQLITE_OK ){  rc = sessionChangesetToHash(pIter, pGrp, 0);  }  sqlite3changeset_finalize(pIter);  return rc; } SQLITE_API int sqlite3changegroup_output_strm(  sqlite3_changegroup *pGrp,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ){  return sessionChangegroupOutput(pGrp, xOutput, pOut, 0, 0); } SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup *pGrp){  if( pGrp ){  sessionDeleteTable(0, pGrp->pList);  sqlite3_free(pGrp);  } } SQLITE_API int sqlite3changeset_concat(  int nLeft,  void *pLeft,  int nRight ,  void *pRight,  int *pnOut,  void **ppOut ){  sqlite3_changegroup *pGrp;  int rc;  rc = sqlite3changegroup_new(&pGrp);  if( rc==SQLITE_OK ){  rc = sqlite3changegroup_add(pGrp, nLeft, pLeft);  }  if( rc==SQLITE_OK ){  rc = sqlite3changegroup_add(pGrp, nRight, pRight);  }  if( rc==SQLITE_OK ){  rc = sqlite3changegroup_output(pGrp, pnOut, ppOut);  }  sqlite3changegroup_delete(pGrp);  return rc; } SQLITE_API int sqlite3changeset_concat_strm(  int (*xInputA)(void *pIn, void *pData, int *pnData),  void *pInA,  int (*xInputB)(void *pIn, void *pData, int *pnData),  void *pInB,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ){  sqlite3_changegroup *pGrp;  int rc;  rc = sqlite3changegroup_new(&pGrp);  if( rc==SQLITE_OK ){  rc = sqlite3changegroup_add_strm(pGrp, xInputA, pInA);  }  if( rc==SQLITE_OK ){  rc = sqlite3changegroup_add_strm(pGrp, xInputB, pInB);  }  if( rc==SQLITE_OK ){  rc = sqlite3changegroup_output_strm(pGrp, xOutput, pOut);  }  sqlite3changegroup_delete(pGrp);  return rc; } struct sqlite3_rebaser {  sqlite3_changegroup grp; }; static void sessionAppendRecordMerge(  SessionBuffer *pBuf,  int nCol,  u8 *a1, int n1,  u8 *a2, int n2,  int *pRc ){  sessionBufferGrow(pBuf, n1+n2, pRc);  if( *pRc==SQLITE_OK ){  int i;  u8 *pOut = &pBuf->aBuf[pBuf->nBuf];  for(i=0; i<nCol; i++){  int nn1 = sessionSerialLen(a1);  int nn2 = sessionSerialLen(a2);  if( *a1==0 || *a1==0xFF ){  memcpy(pOut, a2, nn2);  pOut += nn2;  }else{  memcpy(pOut, a1, nn1);  pOut += nn1;  }  a1 += nn1;  a2 += nn2;  }  pBuf->nBuf = pOut-pBuf->aBuf;  assert( pBuf->nBuf<=pBuf->nAlloc );  } } static void sessionAppendPartialUpdate(  SessionBuffer *pBuf,  sqlite3_changeset_iter *pIter,  u8 *aRec, int nRec,  u8 *aChange, int nChange,  int *pRc ){  sessionBufferGrow(pBuf, 2+nRec+nChange, pRc);  if( *pRc==SQLITE_OK ){  int bData = 0;  u8 *pOut = &pBuf->aBuf[pBuf->nBuf];  int i;  u8 *a1 = aRec;  u8 *a2 = aChange;  *pOut++ = SQLITE_UPDATE;  *pOut++ = pIter->bIndirect;  for(i=0; i<pIter->nCol; i++){  int n1 = sessionSerialLen(a1);  int n2 = sessionSerialLen(a2);  if( pIter->abPK[i] || a2[0]==0 ){  if( !pIter->abPK[i] && a1[0] ) bData = 1;  memcpy(pOut, a1, n1);  pOut += n1;  }else if( a2[0]!=0xFF ){  bData = 1;  memcpy(pOut, a2, n2);  pOut += n2;  }else{  *pOut++ = '\0';  }  a1 += n1;  a2 += n2;  }  if( bData ){  a2 = aChange;  for(i=0; i<pIter->nCol; i++){  int n1 = sessionSerialLen(a1);  int n2 = sessionSerialLen(a2);  if( pIter->abPK[i] || a2[0]!=0xFF ){  memcpy(pOut, a1, n1);  pOut += n1;  }else{  *pOut++ = '\0';  }  a1 += n1;  a2 += n2;  }  pBuf->nBuf = (pOut - pBuf->aBuf);  }  } } static int sessionRebase(  sqlite3_rebaser *p,  sqlite3_changeset_iter *pIter,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut,  int *pnOut,  void **ppOut ){  int rc = SQLITE_OK;  u8 *aRec = 0;  int nRec = 0;  int bNew = 0;  SessionTable *pTab = 0;  SessionBuffer sOut = {0,0,0};  while( SQLITE_ROW==sessionChangesetNext(pIter, &aRec, &nRec, &bNew) ){  SessionChange *pChange = 0;  int bDone = 0;  if( bNew ){  const char *zTab = pIter->zTab;  for(pTab=p->grp.pList; pTab; pTab=pTab->pNext){  if( 0==sqlite3_stricmp(pTab->zName, zTab) ) break;  }  bNew = 0;  if( pIter->bPatchset ){  rc = SQLITE_ERROR;  }  sessionAppendByte(&sOut, pIter->bPatchset ? 'P' : 'T', &rc);  sessionAppendVarint(&sOut, pIter->nCol, &rc);  sessionAppendBlob(&sOut, pIter->abPK, pIter->nCol, &rc);  sessionAppendBlob(&sOut,(u8*)pIter->zTab,(int)strlen(pIter->zTab)+1,&rc);  }  if( pTab && rc==SQLITE_OK ){  int iHash = sessionChangeHash(pTab, 0, aRec, pTab->nChange);  for(pChange=pTab->apChange[iHash]; pChange; pChange=pChange->pNext){  if( sessionChangeEqual(pTab, 0, aRec, 0, pChange->aRecord) ){  break;  }  }  }  if( pChange ){  assert( pChange->op==SQLITE_DELETE || pChange->op==SQLITE_INSERT );  switch( pIter->op ){  case SQLITE_INSERT:  if( pChange->op==SQLITE_INSERT ){  bDone = 1;  if( pChange->bIndirect==0 ){  sessionAppendByte(&sOut, SQLITE_UPDATE, &rc);  sessionAppendByte(&sOut, pIter->bIndirect, &rc);  sessionAppendBlob(&sOut, pChange->aRecord, pChange->nRecord, &rc);  sessionAppendBlob(&sOut, aRec, nRec, &rc);  }  }  break;  case SQLITE_UPDATE:  bDone = 1;  if( pChange->op==SQLITE_DELETE ){  if( pChange->bIndirect==0 ){  u8 *pCsr = aRec;  sessionSkipRecord(&pCsr, pIter->nCol);  sessionAppendByte(&sOut, SQLITE_INSERT, &rc);  sessionAppendByte(&sOut, pIter->bIndirect, &rc);  sessionAppendRecordMerge(&sOut, pIter->nCol,  pCsr, nRec-(pCsr-aRec),  pChange->aRecord, pChange->nRecord, &rc  );  }  }else{  sessionAppendPartialUpdate(&sOut, pIter,  aRec, nRec, pChange->aRecord, pChange->nRecord, &rc  );  }  break;  default:  assert( pIter->op==SQLITE_DELETE );  bDone = 1;  if( pChange->op==SQLITE_INSERT ){  sessionAppendByte(&sOut, SQLITE_DELETE, &rc);  sessionAppendByte(&sOut, pIter->bIndirect, &rc);  sessionAppendRecordMerge(&sOut, pIter->nCol,  pChange->aRecord, pChange->nRecord, aRec, nRec, &rc  );  }  break;  }  }  if( bDone==0 ){  sessionAppendByte(&sOut, pIter->op, &rc);  sessionAppendByte(&sOut, pIter->bIndirect, &rc);  sessionAppendBlob(&sOut, aRec, nRec, &rc);  }  if( rc==SQLITE_OK && xOutput && sOut.nBuf>sessions_strm_chunk_size ){  rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);  sOut.nBuf = 0;  }  if( rc ) break;  }  if( rc!=SQLITE_OK ){  sqlite3_free(sOut.aBuf);  memset(&sOut, 0, sizeof(sOut));  }  if( rc==SQLITE_OK ){  if( xOutput ){  if( sOut.nBuf>0 ){  rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);  }  }else if( ppOut ){  *ppOut = (void*)sOut.aBuf;  *pnOut = sOut.nBuf;  sOut.aBuf = 0;  }  }  sqlite3_free(sOut.aBuf);  return rc; } SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew){  int rc = SQLITE_OK;  sqlite3_rebaser *pNew;  pNew = sqlite3_malloc(sizeof(sqlite3_rebaser));  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  memset(pNew, 0, sizeof(sqlite3_rebaser));  }  *ppNew = pNew;  return rc; } SQLITE_API int sqlite3rebaser_configure(  sqlite3_rebaser *p,  int nRebase, const void *pRebase ){  sqlite3_changeset_iter *pIter = 0;  int rc;  rc = sqlite3changeset_start(&pIter, nRebase, (void*)pRebase);  if( rc==SQLITE_OK ){  rc = sessionChangesetToHash(pIter, &p->grp, 1);  }  sqlite3changeset_finalize(pIter);  return rc; } SQLITE_API int sqlite3rebaser_rebase(  sqlite3_rebaser *p,  int nIn, const void *pIn,  int *pnOut, void **ppOut ){  sqlite3_changeset_iter *pIter = 0;  int rc = sqlite3changeset_start(&pIter, nIn, (void*)pIn);  if( rc==SQLITE_OK ){  rc = sessionRebase(p, pIter, 0, 0, pnOut, ppOut);  sqlite3changeset_finalize(pIter);  }  return rc; } SQLITE_API int sqlite3rebaser_rebase_strm(  sqlite3_rebaser *p,  int (*xInput)(void *pIn, void *pData, int *pnData),  void *pIn,  int (*xOutput)(void *pOut, const void *pData, int nData),  void *pOut ){  sqlite3_changeset_iter *pIter = 0;  int rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);  if( rc==SQLITE_OK ){  rc = sessionRebase(p, pIter, xOutput, pOut, 0, 0);  sqlite3changeset_finalize(pIter);  }  return rc; } SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p){  if( p ){  sessionDeleteTable(0, p->grp.pList);  sqlite3_free(p);  } } SQLITE_API int sqlite3session_config(int op, void *pArg){  int rc = SQLITE_OK;  switch( op ){  case SQLITE_SESSION_CONFIG_STRMSIZE: {  int *pInt = (int*)pArg;  if( *pInt>0 ){  sessions_strm_chunk_size = *pInt;  }  *pInt = sessions_strm_chunk_size;  break;  }  default:  rc = SQLITE_MISUSE;  break;  }  return rc; }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS5)
#if !defined(NDEBUG) && !defined(SQLITE_DEBUG)
# define NDEBUG 1
#endif
#if defined(NDEBUG) && defined(SQLITE_DEBUG)
# undef NDEBUG
#endif
#ifndef _FTS5_H
#define _FTS5_H
#if 0
extern "C" {
#endif
typedef struct Fts5ExtensionApi Fts5ExtensionApi; typedef struct Fts5Context Fts5Context; typedef struct Fts5PhraseIter Fts5PhraseIter; typedef void (*fts5_extension_function)(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ); struct Fts5PhraseIter {  const unsigned char *a;  const unsigned char *b; }; struct Fts5ExtensionApi {  int iVersion;  void *(*xUserData)(Fts5Context*);  int (*xColumnCount)(Fts5Context*);  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);  int (*xTokenize)(Fts5Context*,  const char *pText, int nText,  void *pCtx,  int (*xToken)(void*, int, const char*, int, int, int)  );  int (*xPhraseCount)(Fts5Context*);  int (*xPhraseSize)(Fts5Context*, int iPhrase);  int (*xInstCount)(Fts5Context*, int *pnInst);  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);  sqlite3_int64 (*xRowid)(Fts5Context*);  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,  int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)  );  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));  void *(*xGetAuxdata)(Fts5Context*, int bClear);  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol); }; typedef struct Fts5Tokenizer Fts5Tokenizer; typedef struct fts5_tokenizer fts5_tokenizer; struct fts5_tokenizer {  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);  void (*xDelete)(Fts5Tokenizer*);  int (*xTokenize)(Fts5Tokenizer*,  void *pCtx,  int flags,  const char *pText, int nText,  int (*xToken)(  void *pCtx,  int tflags,  const char *pToken,  int nToken,  int iStart,  int iEnd  )  ); };
#define FTS5_TOKENIZE_QUERY  0x0001
#define FTS5_TOKENIZE_PREFIX 0x0002
#define FTS5_TOKENIZE_DOCUMENT 0x0004
#define FTS5_TOKENIZE_AUX  0x0008
#define FTS5_TOKEN_COLOCATED 0x0001
typedef struct fts5_api fts5_api; struct fts5_api {  int iVersion;  int (*xCreateTokenizer)(  fts5_api *pApi,  const char *zName,  void *pContext,  fts5_tokenizer *pTokenizer,  void (*xDestroy)(void*)  );  int (*xFindTokenizer)(  fts5_api *pApi,  const char *zName,  void **ppContext,  fts5_tokenizer *pTokenizer  );  int (*xCreateFunction)(  fts5_api *pApi,  const char *zName,  void *pContext,  fts5_extension_function xFunction,  void (*xDestroy)(void*)  ); };
#if 0
}
#endif
#endif
#ifndef _FTS5INT_H
#define _FTS5INT_H
SQLITE_EXTENSION_INIT1
#ifndef SQLITE_AMALGAMATION
typedef unsigned char u8; typedef unsigned int  u32; typedef unsigned short u16; typedef short i16; typedef sqlite3_int64 i64; typedef sqlite3_uint64 u64;
#ifndef ArraySize
# define ArraySize(x) ((int)(sizeof(x) / sizeof(x[0])))
#endif
#define testcase(x)
#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
# define SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS 1
#endif
#if defined(SQLITE_OMIT_AUXILIARY_SAFETY_CHECKS)
# define ALWAYS(X) (1)
# define NEVER(X)  (0)
#elif !defined(NDEBUG)
# define ALWAYS(X) ((X)?1:(assert(0),0))
# define NEVER(X)  ((X)?(assert(0),1):0)
#else
# define ALWAYS(X) (X)
# define NEVER(X)  (X)
#endif
#define MIN(x,y) (((x) < (y)) ? (x) : (y))
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
# define LARGEST_INT64 (0xffffffff|(((i64)0x7fffffff)<<32))
# define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
#endif
#define FTS5_MAX_TOKEN_SIZE 32768
#define FTS5_MAX_PREFIX_INDEXES 31
#define FTS5_MAX_SEGMENT 2000
#define FTS5_DEFAULT_NEARDIST 10
#define FTS5_DEFAULT_RANK  "bm25"
#define FTS5_RANK_NAME "rank"
#define FTS5_ROWID_NAME "rowid"
#ifdef SQLITE_DEBUG
# define FTS5_CORRUPT sqlite3Fts5Corrupt()
static int sqlite3Fts5Corrupt(void);
#else
# define FTS5_CORRUPT SQLITE_CORRUPT_VTAB
#endif
#ifdef SQLITE_DEBUG
SQLITE_API extern int sqlite3_fts5_may_be_corrupt;
# define assert_nc(x) assert(sqlite3_fts5_may_be_corrupt || (x))
#else
# define assert_nc(x) assert(x)
#endif
#define fts5Memcmp(s1, s2, n) ((n)<=0 ? 0 : memcmp((s1), (s2), (n)))
#ifndef UNUSED_PARAM
# define UNUSED_PARAM(X) (void)(X)
#endif
#ifndef UNUSED_PARAM2
# define UNUSED_PARAM2(X, Y) (void)(X), (void)(Y)
#endif
typedef struct Fts5Global Fts5Global; typedef struct Fts5Colset Fts5Colset; struct Fts5Colset {  int nCol;  int aiCol[1]; }; typedef struct Fts5Config Fts5Config; struct Fts5Config {  sqlite3 *db;  char *zDb;  char *zName;  int nCol;  char **azCol;  u8 *abUnindexed;  int nPrefix;  int *aPrefix;  int eContent;  char *zContent;  char *zContentRowid;  int bColumnsize;  int eDetail;  char *zContentExprlist;  Fts5Tokenizer *pTok;  fts5_tokenizer *pTokApi;  int bLock;  int ePattern;  int iCookie;  int pgsz;  int nAutomerge;  int nCrisisMerge;  int nUsermerge;  int nHashSize;  char *zRank;  char *zRankArgs;  char **pzErrmsg;
#ifdef SQLITE_DEBUG
 int bPrefixIndex;
#endif
};
#define FTS5_CURRENT_VERSION 4
#define FTS5_CONTENT_NORMAL  0
#define FTS5_CONTENT_NONE  1
#define FTS5_CONTENT_EXTERNAL 2
#define FTS5_DETAIL_FULL 0
#define FTS5_DETAIL_NONE 1
#define FTS5_DETAIL_COLUMNS  2
#define FTS5_PATTERN_NONE  0
#define FTS5_PATTERN_LIKE  65
#define FTS5_PATTERN_GLOB  66
static int sqlite3Fts5ConfigParse(  Fts5Global*, sqlite3*, int, const char **, Fts5Config**, char** ); static void sqlite3Fts5ConfigFree(Fts5Config*); static int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig); static int sqlite3Fts5Tokenize(  Fts5Config *pConfig,  int flags,  const char *pText, int nText,  void *pCtx,  int (*xToken)(void*, int, const char*, int, int, int) ); static void sqlite3Fts5Dequote(char *z); static int sqlite3Fts5ConfigLoad(Fts5Config*, int); static int sqlite3Fts5ConfigSetValue(Fts5Config*, const char*, sqlite3_value*, int*); static int sqlite3Fts5ConfigParseRank(const char*, char**, char**); typedef struct Fts5Buffer Fts5Buffer; struct Fts5Buffer {  u8 *p;  int n;  int nSpace; }; static int sqlite3Fts5BufferSize(int*, Fts5Buffer*, u32); static void sqlite3Fts5BufferAppendVarint(int*, Fts5Buffer*, i64); static void sqlite3Fts5BufferAppendBlob(int*, Fts5Buffer*, u32, const u8*); static void sqlite3Fts5BufferAppendString(int *, Fts5Buffer*, const char*); static void sqlite3Fts5BufferFree(Fts5Buffer*); static void sqlite3Fts5BufferZero(Fts5Buffer*); static void sqlite3Fts5BufferSet(int*, Fts5Buffer*, int, const u8*); static void sqlite3Fts5BufferAppendPrintf(int *, Fts5Buffer*, char *zFmt, ...); static char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...);
#define fts5BufferZero(x)  sqlite3Fts5BufferZero(x)
#define fts5BufferAppendVarint(a,b,c) sqlite3Fts5BufferAppendVarint(a,b,c)
#define fts5BufferFree(a)  sqlite3Fts5BufferFree(a)
#define fts5BufferAppendBlob(a,b,c,d) sqlite3Fts5BufferAppendBlob(a,b,c,d)
#define fts5BufferSet(a,b,c,d) sqlite3Fts5BufferSet(a,b,c,d)
#define fts5BufferGrow(pRc,pBuf,nn) (  (u32)((pBuf)->n) + (u32)(nn) <= (u32)((pBuf)->nSpace) ? 0 :  sqlite3Fts5BufferSize((pRc),(pBuf),(nn)+(pBuf)->n) )

static void sqlite3Fts5Put32(u8*, int); static int sqlite3Fts5Get32(const u8*);
#define FTS5_POS2COLUMN(iPos) (int)(iPos >> 32)
#define FTS5_POS2OFFSET(iPos) (int)(iPos & 0x7FFFFFFF)
typedef struct Fts5PoslistReader Fts5PoslistReader; struct Fts5PoslistReader {  const u8 *a;  int n;  int i;  u8 bFlag;  u8 bEof;  i64 iPos; }; static int sqlite3Fts5PoslistReaderInit(  const u8 *a, int n,  Fts5PoslistReader *pIter ); static int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader*); typedef struct Fts5PoslistWriter Fts5PoslistWriter; struct Fts5PoslistWriter {  i64 iPrev; }; static int sqlite3Fts5PoslistWriterAppend(Fts5Buffer*, Fts5PoslistWriter*, i64); static void sqlite3Fts5PoslistSafeAppend(Fts5Buffer*, i64*, i64); static int sqlite3Fts5PoslistNext64(  const u8 *a, int n,  int *pi,  i64 *piOff ); static void *sqlite3Fts5MallocZero(int *pRc, sqlite3_int64 nByte); static char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn); static int sqlite3Fts5IsBareword(char t); typedef struct Fts5Termset Fts5Termset; static int sqlite3Fts5TermsetNew(Fts5Termset**); static int sqlite3Fts5TermsetAdd(Fts5Termset*, int, const char*, int, int *pbPresent); static void sqlite3Fts5TermsetFree(Fts5Termset*); typedef struct Fts5Index Fts5Index; typedef struct Fts5IndexIter Fts5IndexIter; struct Fts5IndexIter {  i64 iRowid;  const u8 *pData;  int nData;  u8 bEof; };
#define sqlite3Fts5IterEof(x) ((x)->bEof)
#define FTS5INDEX_QUERY_PREFIX  0x0001
#define FTS5INDEX_QUERY_DESC  0x0002
#define FTS5INDEX_QUERY_TEST_NOIDX 0x0004
#define FTS5INDEX_QUERY_SCAN  0x0008
#define FTS5INDEX_QUERY_SKIPEMPTY 0x0010
#define FTS5INDEX_QUERY_NOOUTPUT  0x0020
static int sqlite3Fts5IndexOpen(Fts5Config *pConfig, int bCreate, Fts5Index**, char**); static int sqlite3Fts5IndexClose(Fts5Index *p); static u64 sqlite3Fts5IndexEntryCksum(  i64 iRowid,  int iCol,  int iPos,  int iIdx,  const char *pTerm,  int nTerm ); static int sqlite3Fts5IndexCharlenToBytelen(  const char *p,  int nByte,  int nChar ); static int sqlite3Fts5IndexQuery(  Fts5Index *p,  const char *pToken, int nToken,  int flags,  Fts5Colset *pColset,  Fts5IndexIter **ppIter ); static int sqlite3Fts5IterNext(Fts5IndexIter*); static int sqlite3Fts5IterNextFrom(Fts5IndexIter*, i64 iMatch); static void sqlite3Fts5IterClose(Fts5IndexIter*); static void sqlite3Fts5IndexCloseReader(Fts5Index*); static const char *sqlite3Fts5IterTerm(Fts5IndexIter*, int*); static int sqlite3Fts5IterNextScan(Fts5IndexIter*); static void *sqlite3Fts5StructureRef(Fts5Index*); static void sqlite3Fts5StructureRelease(void*); static int sqlite3Fts5StructureTest(Fts5Index*, void*); static int sqlite3Fts5IndexWrite(  Fts5Index *p,  int iCol,  int iPos,  const char *pToken, int nToken ); static int sqlite3Fts5IndexBeginWrite(  Fts5Index *p,  int bDelete,  i64 iDocid ); static int sqlite3Fts5IndexSync(Fts5Index *p); static int sqlite3Fts5IndexRollback(Fts5Index *p); static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize); static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8*, int); static int sqlite3Fts5IndexIntegrityCheck(Fts5Index*, u64 cksum, int bUseCksum); static int sqlite3Fts5IndexInit(sqlite3*); static int sqlite3Fts5IndexSetCookie(Fts5Index*, int); static int sqlite3Fts5IndexReads(Fts5Index *p); static int sqlite3Fts5IndexReinit(Fts5Index *p); static int sqlite3Fts5IndexOptimize(Fts5Index *p); static int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge); static int sqlite3Fts5IndexReset(Fts5Index *p); static int sqlite3Fts5IndexLoadConfig(Fts5Index *p); static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v); static int sqlite3Fts5GetVarintLen(u32 iVal); static u8 sqlite3Fts5GetVarint(const unsigned char*, u64*); static int sqlite3Fts5PutVarint(unsigned char *p, u64 v);
#define fts5GetVarint32(a,b) sqlite3Fts5GetVarint32(a,(u32*)&b)
#define fts5GetVarint sqlite3Fts5GetVarint
#define fts5FastGetVarint32(a, iOff, nVal) {  nVal = (a)[iOff++];   if( nVal & 0x80 ){  iOff--;   iOff += fts5GetVarint32(&(a)[iOff], nVal);  }  }

typedef struct Fts5Table Fts5Table; struct Fts5Table {  sqlite3_vtab base;  Fts5Config *pConfig;  Fts5Index *pIndex; }; static int sqlite3Fts5GetTokenizer(  Fts5Global*,  const char **azArg,  int nArg,  Fts5Config*,  char **pzErr ); static Fts5Table *sqlite3Fts5TableFromCsrid(Fts5Global*, i64); static int sqlite3Fts5FlushToDisk(Fts5Table*); typedef struct Fts5Hash Fts5Hash; static int sqlite3Fts5HashNew(Fts5Config*, Fts5Hash**, int *pnSize); static void sqlite3Fts5HashFree(Fts5Hash*); static int sqlite3Fts5HashWrite(  Fts5Hash*,  i64 iRowid,  int iCol,  int iPos,  char bByte,  const char *pToken, int nToken ); static void sqlite3Fts5HashClear(Fts5Hash*); static int sqlite3Fts5HashQuery(  Fts5Hash*,  int nPre,  const char *pTerm, int nTerm,  void **ppObj,  int *pnDoclist ); static int sqlite3Fts5HashScanInit(  Fts5Hash*,  const char *pTerm, int nTerm ); static void sqlite3Fts5HashScanNext(Fts5Hash*); static int sqlite3Fts5HashScanEof(Fts5Hash*); static void sqlite3Fts5HashScanEntry(Fts5Hash *,  const char **pzTerm,  const u8 **ppDoclist,  int *pnDoclist );
#define FTS5_STMT_SCAN_ASC 0
#define FTS5_STMT_SCAN_DESC 1
#define FTS5_STMT_LOOKUP 2
typedef struct Fts5Storage Fts5Storage; static int sqlite3Fts5StorageOpen(Fts5Config*, Fts5Index*, int, Fts5Storage**, char**); static int sqlite3Fts5StorageClose(Fts5Storage *p); static int sqlite3Fts5StorageRename(Fts5Storage*, const char *zName); static int sqlite3Fts5DropAll(Fts5Config*); static int sqlite3Fts5CreateTable(Fts5Config*, const char*, const char*, int, char **); static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64, sqlite3_value**); static int sqlite3Fts5StorageContentInsert(Fts5Storage *p, sqlite3_value**, i64*); static int sqlite3Fts5StorageIndexInsert(Fts5Storage *p, sqlite3_value**, i64); static int sqlite3Fts5StorageIntegrity(Fts5Storage *p, int iArg); static int sqlite3Fts5StorageStmt(Fts5Storage *p, int eStmt, sqlite3_stmt**, char**); static void sqlite3Fts5StorageStmtRelease(Fts5Storage *p, int eStmt, sqlite3_stmt*); static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol); static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnAvg); static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow); static int sqlite3Fts5StorageSync(Fts5Storage *p); static int sqlite3Fts5StorageRollback(Fts5Storage *p); static int sqlite3Fts5StorageConfigValue(  Fts5Storage *p, const char*, sqlite3_value*, int ); static int sqlite3Fts5StorageDeleteAll(Fts5Storage *p); static int sqlite3Fts5StorageRebuild(Fts5Storage *p); static int sqlite3Fts5StorageOptimize(Fts5Storage *p); static int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge); static int sqlite3Fts5StorageReset(Fts5Storage *p); typedef struct Fts5Expr Fts5Expr; typedef struct Fts5ExprNode Fts5ExprNode; typedef struct Fts5Parse Fts5Parse; typedef struct Fts5Token Fts5Token; typedef struct Fts5ExprPhrase Fts5ExprPhrase; typedef struct Fts5ExprNearset Fts5ExprNearset; struct Fts5Token {  const char *p;  int n; }; static int sqlite3Fts5ExprNew(  Fts5Config *pConfig,  int bPhraseToAnd,  int iCol,  const char *zExpr,  Fts5Expr **ppNew,  char **pzErr ); static int sqlite3Fts5ExprPattern(  Fts5Config *pConfig,  int bGlob,  int iCol,  const char *zText,  Fts5Expr **pp ); static int sqlite3Fts5ExprFirst(Fts5Expr*, Fts5Index *pIdx, i64 iMin, int bDesc); static int sqlite3Fts5ExprNext(Fts5Expr*, i64 iMax); static int sqlite3Fts5ExprEof(Fts5Expr*); static i64 sqlite3Fts5ExprRowid(Fts5Expr*); static void sqlite3Fts5ExprFree(Fts5Expr*); static int sqlite3Fts5ExprAnd(Fts5Expr **pp1, Fts5Expr *p2); static int sqlite3Fts5ExprInit(Fts5Global*, sqlite3*); static int sqlite3Fts5ExprPhraseCount(Fts5Expr*); static int sqlite3Fts5ExprPhraseSize(Fts5Expr*, int iPhrase); static int sqlite3Fts5ExprPoslist(Fts5Expr*, int, const u8 **); typedef struct Fts5PoslistPopulator Fts5PoslistPopulator; static Fts5PoslistPopulator *sqlite3Fts5ExprClearPoslists(Fts5Expr*, int); static int sqlite3Fts5ExprPopulatePoslists(  Fts5Config*, Fts5Expr*, Fts5PoslistPopulator*, int, const char*, int ); static void sqlite3Fts5ExprCheckPoslists(Fts5Expr*, i64); static int sqlite3Fts5ExprClonePhrase(Fts5Expr*, int, Fts5Expr**); static int sqlite3Fts5ExprPhraseCollist(Fts5Expr *, int, const u8 **, int *); static void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...); static Fts5ExprNode *sqlite3Fts5ParseNode(  Fts5Parse *pParse,  int eType,  Fts5ExprNode *pLeft,  Fts5ExprNode *pRight,  Fts5ExprNearset *pNear ); static Fts5ExprNode *sqlite3Fts5ParseImplicitAnd(  Fts5Parse *pParse,  Fts5ExprNode *pLeft,  Fts5ExprNode *pRight ); static Fts5ExprPhrase *sqlite3Fts5ParseTerm(  Fts5Parse *pParse,  Fts5ExprPhrase *pPhrase,  Fts5Token *pToken,  int bPrefix ); static void sqlite3Fts5ParseSetCaret(Fts5ExprPhrase*); static Fts5ExprNearset *sqlite3Fts5ParseNearset(  Fts5Parse*,  Fts5ExprNearset*,  Fts5ExprPhrase* ); static Fts5Colset *sqlite3Fts5ParseColset(  Fts5Parse*,  Fts5Colset*,  Fts5Token * ); static void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase*); static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset*); static void sqlite3Fts5ParseNodeFree(Fts5ExprNode*); static void sqlite3Fts5ParseSetDistance(Fts5Parse*, Fts5ExprNearset*, Fts5Token*); static void sqlite3Fts5ParseSetColset(Fts5Parse*, Fts5ExprNode*, Fts5Colset*); static Fts5Colset *sqlite3Fts5ParseColsetInvert(Fts5Parse*, Fts5Colset*); static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p); static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token*); static int sqlite3Fts5AuxInit(fts5_api*); static int sqlite3Fts5TokenizerInit(fts5_api*); static int sqlite3Fts5TokenizerPattern(  int (*xCreate)(void*, const char**, int, Fts5Tokenizer**),  Fts5Tokenizer *pTok ); static int sqlite3Fts5VocabInit(Fts5Global*, sqlite3*); static int sqlite3Fts5UnicodeIsdiacritic(int c); static int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic); static int sqlite3Fts5UnicodeCatParse(const char*, u8*); static int sqlite3Fts5UnicodeCategory(u32 iCode); static void sqlite3Fts5UnicodeAscii(u8*, u8*);
#endif
#define FTS5_OR  1
#define FTS5_AND 2
#define FTS5_NOT 3
#define FTS5_TERM  4
#define FTS5_COLON 5
#define FTS5_MINUS 6
#define FTS5_LCP 7
#define FTS5_RCP 8
#define FTS5_STRING  9
#define FTS5_LP 10
#define FTS5_RP 11
#define FTS5_CARET  12
#define FTS5_COMMA  13
#define FTS5_PLUS 14
#define FTS5_STAR 15
#define fts5YYNOERRORRECOVERY 1
#define fts5yytestcase(X) testcase(X)
#define fts5YYPARSEFREENOTNULL 1
#define fts5YYMALLOCARGTYPE u64
#ifndef FTS5_OR
#define FTS5_OR 1
#define FTS5_AND  2
#define FTS5_NOT  3
#define FTS5_TERM 4
#define FTS5_COLON  5
#define FTS5_MINUS  6
#define FTS5_LCP  7
#define FTS5_RCP  8
#define FTS5_STRING 9
#define FTS5_LP  10
#define FTS5_RP  11
#define FTS5_CARET 12
#define FTS5_COMMA 13
#define FTS5_PLUS  14
#define FTS5_STAR  15
#endif
#ifndef INTERFACE
# define INTERFACE 1
#endif
#define fts5YYCODETYPE unsigned char
#define fts5YYNOCODE 27
#define fts5YYACTIONTYPE unsigned char
#define sqlite3Fts5ParserFTS5TOKENTYPE Fts5Token
typedef union {  int fts5yyinit;  sqlite3Fts5ParserFTS5TOKENTYPE fts5yy0;  int fts5yy4;  Fts5Colset* fts5yy11;  Fts5ExprNode* fts5yy24;  Fts5ExprNearset* fts5yy46;  Fts5ExprPhrase* fts5yy53; } fts5YYMINORTYPE;
#ifndef fts5YYSTACKDEPTH
#define fts5YYSTACKDEPTH 100
#endif
#define sqlite3Fts5ParserARG_SDECL Fts5Parse *pParse;
#define sqlite3Fts5ParserARG_PDECL ,Fts5Parse *pParse
#define sqlite3Fts5ParserARG_PARAM ,pParse
#define sqlite3Fts5ParserARG_FETCH Fts5Parse *pParse=fts5yypParser->pParse;
#define sqlite3Fts5ParserARG_STORE fts5yypParser->pParse=pParse;
#define sqlite3Fts5ParserCTX_SDECL
#define sqlite3Fts5ParserCTX_PDECL
#define sqlite3Fts5ParserCTX_PARAM
#define sqlite3Fts5ParserCTX_FETCH
#define sqlite3Fts5ParserCTX_STORE
#define fts5YYNSTATE  35
#define fts5YYNRULE 28
#define fts5YYNRULE_WITH_ACTION 28
#define fts5YYNFTS5TOKEN  16
#define fts5YY_MAX_SHIFT  34
#define fts5YY_MIN_SHIFTREDUCE  52
#define fts5YY_MAX_SHIFTREDUCE  79
#define fts5YY_ERROR_ACTION 80
#define fts5YY_ACCEPT_ACTION  81
#define fts5YY_NO_ACTION  82
#define fts5YY_MIN_REDUCE 83
#define fts5YY_MAX_REDUCE 110
#define fts5YY_NLOOKAHEAD ((int)(sizeof(fts5yy_lookahead)/sizeof(fts5yy_lookahead[0])))
#ifndef fts5yytestcase
# define fts5yytestcase(X)
#endif
#define fts5YY_ACTTAB_COUNT (105)
static const fts5YYACTIONTYPE fts5yy_action[] = {  81, 20, 96, 6, 28, 99, 98, 26, 26, 18,  96, 6, 28, 17, 98, 56, 26, 19, 96, 6,  28, 14, 98, 14, 26, 31, 92, 96, 6, 28,   108, 98, 25, 26, 21, 96, 6, 28, 78, 98,  58, 26, 29, 96, 6, 28, 107, 98, 22, 26,  24, 16, 12, 11, 1, 13, 13, 24, 16, 23,  11, 33, 34, 13, 97, 8, 27, 32, 98, 7,  26, 3, 4, 5, 3, 4, 5, 3, 83, 4,   5, 3, 63, 5, 3, 62, 12, 2, 86, 13,   9, 30, 10, 10, 54, 57, 75, 78, 78, 53,  57, 15, 82, 82, 71, }; static const fts5YYCODETYPE fts5yy_lookahead[] = {  16, 17, 18, 19, 20, 22, 22, 24, 24, 17,  18, 19, 20, 7, 22, 9, 24, 17, 18, 19,  20, 9, 22, 9, 24, 13, 17, 18, 19, 20,  26, 22, 24, 24, 17, 18, 19, 20, 15, 22,   9, 24, 17, 18, 19, 20, 26, 22, 21, 24,   6, 7, 9, 9, 10, 12, 12, 6, 7, 21,   9, 24, 25, 12, 18, 5, 20, 14, 22, 5,  24, 3, 1, 2, 3, 1, 2, 3, 0, 1,   2, 3, 11, 2, 3, 11, 9, 10, 5, 12,  23, 24, 10, 10, 8, 9, 9, 15, 15, 8,   9, 9, 27, 27, 11, 27, 27, 27, 27, 27,  27, 27, 27, 27, 27, 27, 27, 27, 27, 27,  27, };
#define fts5YY_SHIFT_COUNT (34)
#define fts5YY_SHIFT_MIN (0)
#define fts5YY_SHIFT_MAX (93)
static const unsigned char fts5yy_shift_ofst[] = {  44, 44, 44, 44, 44, 44, 51, 77, 43, 12,  14, 83, 82, 14, 23, 23, 31, 31, 71, 74,  78, 81, 86, 91, 6, 53, 53, 60, 64, 68,  53, 87, 92, 53, 93, };
#define fts5YY_REDUCE_COUNT (17)
#define fts5YY_REDUCE_MIN  (-17)
#define fts5YY_REDUCE_MAX  (67)
static const signed char fts5yy_reduce_ofst[] = {   -16, -8, 0, 9, 17, 25, 46, -17, -17, 37,  67, 4, 4, 8, 4, 20, 27, 38, }; static const fts5YYACTIONTYPE fts5yy_default[] = {  80, 80, 80, 80, 80, 80, 95, 80, 80, 105,  80, 110, 110, 80, 110, 110, 80, 80, 80, 80,  80, 91, 80, 80, 80, 101, 100, 80, 80, 90,   103, 80, 80, 104, 80, };
#ifdef fts5YYFALLBACK
static const fts5YYCODETYPE fts5yyFallback[] = { };
#endif
struct fts5yyStackEntry {  fts5YYACTIONTYPE stateno;  fts5YYCODETYPE major;  fts5YYMINORTYPE minor; }; typedef struct fts5yyStackEntry fts5yyStackEntry; struct fts5yyParser {  fts5yyStackEntry *fts5yytos;
#ifdef fts5YYTRACKMAXSTACKDEPTH
 int fts5yyhwm;
#endif
#ifndef fts5YYNOERRORRECOVERY
 int fts5yyerrcnt;
#endif
 sqlite3Fts5ParserARG_SDECL  sqlite3Fts5ParserCTX_SDECL
#if fts5YYSTACKDEPTH<=0
 int fts5yystksz;  fts5yyStackEntry *fts5yystack;  fts5yyStackEntry fts5yystk0;
#else
 fts5yyStackEntry fts5yystack[fts5YYSTACKDEPTH];  fts5yyStackEntry *fts5yystackEnd;
#endif
}; typedef struct fts5yyParser fts5yyParser;
#ifndef NDEBUG
static FILE *fts5yyTraceFILE = 0; static char *fts5yyTracePrompt = 0;
#endif
#ifndef NDEBUG
static void sqlite3Fts5ParserTrace(FILE *TraceFILE, char *zTracePrompt){  fts5yyTraceFILE = TraceFILE;  fts5yyTracePrompt = zTracePrompt;  if( fts5yyTraceFILE==0 ) fts5yyTracePrompt = 0;  else if( fts5yyTracePrompt==0 ) fts5yyTraceFILE = 0; }
#endif
#if defined(fts5YYCOVERAGE) || !defined(NDEBUG)
static const char *const fts5yyTokenName[] = {  "$",  "OR",  "AND",  "NOT",  "TERM",  "COLON",  "MINUS",  "LCP",  "RCP",  "STRING",  "LP",  "RP",  "CARET",  "COMMA",  "PLUS",  "STAR",  "input",  "expr",  "cnearset",  "exprlist",  "colset",  "colsetlist",  "nearset",  "nearphrases",  "phrase",  "neardist_opt",  "star_opt", };
#endif
#ifndef NDEBUG
static const char *const fts5yyRuleName[] = {  "input ::= expr",  "colset ::= MINUS LCP colsetlist RCP",  "colset ::= LCP colsetlist RCP",  "colset ::= STRING",  "colset ::= MINUS STRING",  "colsetlist ::= colsetlist STRING",  "colsetlist ::= STRING",  "expr ::= expr AND expr",  "expr ::= expr OR expr",  "expr ::= expr NOT expr",  "expr ::= colset COLON LP expr RP",  "expr ::= LP expr RP",  "expr ::= exprlist",  "exprlist ::= cnearset",  "exprlist ::= exprlist cnearset",  "cnearset ::= nearset",  "cnearset ::= colset COLON nearset",  "nearset ::= phrase",  "nearset ::= CARET phrase",  "nearset ::= STRING LP nearphrases neardist_opt RP",  "nearphrases ::= phrase",  "nearphrases ::= nearphrases phrase",  "neardist_opt ::=",  "neardist_opt ::= COMMA STRING",  "phrase ::= phrase PLUS STRING star_opt",  "phrase ::= STRING star_opt",  "star_opt ::= STAR",  "star_opt ::=", };
#endif
#if fts5YYSTACKDEPTH<=0
static int fts5yyGrowStack(fts5yyParser *p){  int newSize;  int idx;  fts5yyStackEntry *pNew;  newSize = p->fts5yystksz*2 + 100;  idx = p->fts5yytos ? (int)(p->fts5yytos - p->fts5yystack) : 0;  if( p->fts5yystack==&p->fts5yystk0 ){  pNew = malloc(newSize*sizeof(pNew[0]));  if( pNew ) pNew[0] = p->fts5yystk0;  }else{  pNew = realloc(p->fts5yystack, newSize*sizeof(pNew[0]));  }  if( pNew ){  p->fts5yystack = pNew;  p->fts5yytos = &p->fts5yystack[idx];
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE,"%sStack grows from %d to %d entries.\n",  fts5yyTracePrompt, p->fts5yystksz, newSize);  }
#endif
 p->fts5yystksz = newSize;  }  return pNew==0; }
#endif
#ifndef fts5YYMALLOCARGTYPE
# define fts5YYMALLOCARGTYPE size_t
#endif
static void sqlite3Fts5ParserInit(void *fts5yypRawParser sqlite3Fts5ParserCTX_PDECL){  fts5yyParser *fts5yypParser = (fts5yyParser*)fts5yypRawParser;  sqlite3Fts5ParserCTX_STORE
#ifdef fts5YYTRACKMAXSTACKDEPTH
 fts5yypParser->fts5yyhwm = 0;
#endif
#if fts5YYSTACKDEPTH<=0
 fts5yypParser->fts5yytos = NULL;  fts5yypParser->fts5yystack = NULL;  fts5yypParser->fts5yystksz = 0;  if( fts5yyGrowStack(fts5yypParser) ){  fts5yypParser->fts5yystack = &fts5yypParser->fts5yystk0;  fts5yypParser->fts5yystksz = 1;  }
#endif
#ifndef fts5YYNOERRORRECOVERY
 fts5yypParser->fts5yyerrcnt = -1;
#endif
 fts5yypParser->fts5yytos = fts5yypParser->fts5yystack;  fts5yypParser->fts5yystack[0].stateno = 0;  fts5yypParser->fts5yystack[0].major = 0;
#if fts5YYSTACKDEPTH>0
 fts5yypParser->fts5yystackEnd = &fts5yypParser->fts5yystack[fts5YYSTACKDEPTH-1];
#endif
}
#ifndef sqlite3Fts5Parser_ENGINEALWAYSONSTACK
static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(fts5YYMALLOCARGTYPE) sqlite3Fts5ParserCTX_PDECL){  fts5yyParser *fts5yypParser;  fts5yypParser = (fts5yyParser*)(*mallocProc)( (fts5YYMALLOCARGTYPE)sizeof(fts5yyParser) );  if( fts5yypParser ){  sqlite3Fts5ParserCTX_STORE  sqlite3Fts5ParserInit(fts5yypParser sqlite3Fts5ParserCTX_PARAM);  }  return (void*)fts5yypParser; }
#endif
static void fts5yy_destructor(  fts5yyParser *fts5yypParser,  fts5YYCODETYPE fts5yymajor,  fts5YYMINORTYPE *fts5yypminor ){  sqlite3Fts5ParserARG_FETCH  sqlite3Fts5ParserCTX_FETCH  switch( fts5yymajor ){  case 16: {  (void)pParse; }  break;  case 17:  case 18:  case 19: {  sqlite3Fts5ParseNodeFree((fts5yypminor->fts5yy24)); }  break;  case 20:  case 21: {  sqlite3_free((fts5yypminor->fts5yy11)); }  break;  case 22:  case 23: {  sqlite3Fts5ParseNearsetFree((fts5yypminor->fts5yy46)); }  break;  case 24: {  sqlite3Fts5ParsePhraseFree((fts5yypminor->fts5yy53)); }  break;  default: break;  } } static void fts5yy_pop_parser_stack(fts5yyParser *pParser){  fts5yyStackEntry *fts5yytos;  assert( pParser->fts5yytos!=0 );  assert( pParser->fts5yytos > pParser->fts5yystack );  fts5yytos = pParser->fts5yytos--;
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE,"%sPopping %s\n",  fts5yyTracePrompt,  fts5yyTokenName[fts5yytos->major]);  }
#endif
 fts5yy_destructor(pParser, fts5yytos->major, &fts5yytos->minor); } static void sqlite3Fts5ParserFinalize(void *p){  fts5yyParser *pParser = (fts5yyParser*)p;  while( pParser->fts5yytos>pParser->fts5yystack ) fts5yy_pop_parser_stack(pParser);
#if fts5YYSTACKDEPTH<=0
 if( pParser->fts5yystack!=&pParser->fts5yystk0 ) free(pParser->fts5yystack);
#endif
}
#ifndef sqlite3Fts5Parser_ENGINEALWAYSONSTACK
static void sqlite3Fts5ParserFree(  void *p,  void (*freeProc)(void*) ){
#ifndef fts5YYPARSEFREENEVERNULL
 if( p==0 ) return;
#endif
 sqlite3Fts5ParserFinalize(p);  (*freeProc)(p); }
#endif
#ifdef fts5YYTRACKMAXSTACKDEPTH
static int sqlite3Fts5ParserStackPeak(void *p){  fts5yyParser *pParser = (fts5yyParser*)p;  return pParser->fts5yyhwm; }
#endif
#if defined(fts5YYCOVERAGE)
static unsigned char fts5yycoverage[fts5YYNSTATE][fts5YYNFTS5TOKEN];
#endif
#if defined(fts5YYCOVERAGE)
static int sqlite3Fts5ParserCoverage(FILE *out){  int stateno, iLookAhead, i;  int nMissed = 0;  for(stateno=0; stateno<fts5YYNSTATE; stateno++){  i = fts5yy_shift_ofst[stateno];  for(iLookAhead=0; iLookAhead<fts5YYNFTS5TOKEN; iLookAhead++){  if( fts5yy_lookahead[i+iLookAhead]!=iLookAhead ) continue;  if( fts5yycoverage[stateno][iLookAhead]==0 ) nMissed++;  if( out ){  fprintf(out,"State %d lookahead %s %s\n", stateno,  fts5yyTokenName[iLookAhead],  fts5yycoverage[stateno][iLookAhead] ? "ok" : "missed");  }  }  }  return nMissed; }
#endif
static fts5YYACTIONTYPE fts5yy_find_shift_action(  fts5YYCODETYPE iLookAhead,  fts5YYACTIONTYPE stateno ){  int i;  if( stateno>fts5YY_MAX_SHIFT ) return stateno;  assert( stateno <= fts5YY_SHIFT_COUNT );
#if defined(fts5YYCOVERAGE)
 fts5yycoverage[stateno][iLookAhead] = 1;
#endif
 do{  i = fts5yy_shift_ofst[stateno];  assert( i>=0 );  assert( i<=fts5YY_ACTTAB_COUNT );  assert( i+fts5YYNFTS5TOKEN<=(int)fts5YY_NLOOKAHEAD );  assert( iLookAhead!=fts5YYNOCODE );  assert( iLookAhead < fts5YYNFTS5TOKEN );  i += iLookAhead;  assert( i<(int)fts5YY_NLOOKAHEAD );  if( fts5yy_lookahead[i]!=iLookAhead ){
#ifdef fts5YYFALLBACK
 fts5YYCODETYPE iFallback;  assert( iLookAhead<sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0]) );  iFallback = fts5yyFallback[iLookAhead];  if( iFallback!=0 ){
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE, "%sFALLBACK %s => %s\n",   fts5yyTracePrompt, fts5yyTokenName[iLookAhead], fts5yyTokenName[iFallback]);  }
#endif
 assert( fts5yyFallback[iFallback]==0 );  iLookAhead = iFallback;  continue;  }
#endif
#ifdef fts5YYWILDCARD
 {  int j = i - iLookAhead + fts5YYWILDCARD;  assert( j<(int)(sizeof(fts5yy_lookahead)/sizeof(fts5yy_lookahead[0])) );  if( fts5yy_lookahead[j]==fts5YYWILDCARD && iLookAhead>0 ){
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE, "%sWILDCARD %s => %s\n",   fts5yyTracePrompt, fts5yyTokenName[iLookAhead],   fts5yyTokenName[fts5YYWILDCARD]);  }
#endif
 return fts5yy_action[j];  }  }
#endif
 return fts5yy_default[stateno];  }else{  assert( i>=0 && i<(int)(sizeof(fts5yy_action)/sizeof(fts5yy_action[0])) );  return fts5yy_action[i];  }  }while(1); } static fts5YYACTIONTYPE fts5yy_find_reduce_action(  fts5YYACTIONTYPE stateno,  fts5YYCODETYPE iLookAhead ){  int i;
#ifdef fts5YYERRORSYMBOL
 if( stateno>fts5YY_REDUCE_COUNT ){  return fts5yy_default[stateno];  }
#else
 assert( stateno<=fts5YY_REDUCE_COUNT );
#endif
 i = fts5yy_reduce_ofst[stateno];  assert( iLookAhead!=fts5YYNOCODE );  i += iLookAhead;
#ifdef fts5YYERRORSYMBOL
 if( i<0 || i>=fts5YY_ACTTAB_COUNT || fts5yy_lookahead[i]!=iLookAhead ){  return fts5yy_default[stateno];  }
#else
 assert( i>=0 && i<fts5YY_ACTTAB_COUNT );  assert( fts5yy_lookahead[i]==iLookAhead );
#endif
 return fts5yy_action[i]; } static void fts5yyStackOverflow(fts5yyParser *fts5yypParser){   sqlite3Fts5ParserARG_FETCH   sqlite3Fts5ParserCTX_FETCH
#ifndef NDEBUG
  if( fts5yyTraceFILE ){   fprintf(fts5yyTraceFILE,"%sStack Overflow!\n",fts5yyTracePrompt);   }
#endif
  while( fts5yypParser->fts5yytos>fts5yypParser->fts5yystack ) fts5yy_pop_parser_stack(fts5yypParser);  sqlite3Fts5ParseError(pParse, "fts5: parser stack overflow");   sqlite3Fts5ParserARG_STORE   sqlite3Fts5ParserCTX_STORE }
#ifndef NDEBUG
static void fts5yyTraceShift(fts5yyParser *fts5yypParser, int fts5yyNewState, const char *zTag){  if( fts5yyTraceFILE ){  if( fts5yyNewState<fts5YYNSTATE ){  fprintf(fts5yyTraceFILE,"%s%s '%s', go to state %d\n",   fts5yyTracePrompt, zTag, fts5yyTokenName[fts5yypParser->fts5yytos->major],   fts5yyNewState);  }else{  fprintf(fts5yyTraceFILE,"%s%s '%s', pending reduce %d\n",   fts5yyTracePrompt, zTag, fts5yyTokenName[fts5yypParser->fts5yytos->major],   fts5yyNewState - fts5YY_MIN_REDUCE);  }  } }
#else
# define fts5yyTraceShift(X,Y,Z)
#endif
static void fts5yy_shift(  fts5yyParser *fts5yypParser,  fts5YYACTIONTYPE fts5yyNewState,  fts5YYCODETYPE fts5yyMajor,  sqlite3Fts5ParserFTS5TOKENTYPE fts5yyMinor ){  fts5yyStackEntry *fts5yytos;  fts5yypParser->fts5yytos++;
#ifdef fts5YYTRACKMAXSTACKDEPTH
 if( (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm ){  fts5yypParser->fts5yyhwm++;  assert( fts5yypParser->fts5yyhwm == (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack) );  }
#endif
#if fts5YYSTACKDEPTH>0
 if( fts5yypParser->fts5yytos>fts5yypParser->fts5yystackEnd ){  fts5yypParser->fts5yytos--;  fts5yyStackOverflow(fts5yypParser);  return;  }
#else
 if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz] ){  if( fts5yyGrowStack(fts5yypParser) ){  fts5yypParser->fts5yytos--;  fts5yyStackOverflow(fts5yypParser);  return;  }  }
#endif
 if( fts5yyNewState > fts5YY_MAX_SHIFT ){  fts5yyNewState += fts5YY_MIN_REDUCE - fts5YY_MIN_SHIFTREDUCE;  }  fts5yytos = fts5yypParser->fts5yytos;  fts5yytos->stateno = fts5yyNewState;  fts5yytos->major = fts5yyMajor;  fts5yytos->minor.fts5yy0 = fts5yyMinor;  fts5yyTraceShift(fts5yypParser, fts5yyNewState, "Shift"); } static const fts5YYCODETYPE fts5yyRuleInfoLhs[] = {  16,  20,  20,  20,  20,  21,  21,  17,  17,  17,  17,  17,  17,  19,  19,  18,  18,  22,  22,  22,  23,  23,  25,  25,  24,  24,  26,  26, }; static const signed char fts5yyRuleInfoNRhs[] = {   -1,   -4,   -3,   -1,   -2,   -2,   -1,   -3,   -3,   -3,   -5,   -3,   -1,   -1,   -2,   -1,   -3,   -1,   -2,   -5,   -1,   -2,  0,   -2,   -4,   -2,   -1,  0, }; static void fts5yy_accept(fts5yyParser*); static fts5YYACTIONTYPE fts5yy_reduce(  fts5yyParser *fts5yypParser,  unsigned int fts5yyruleno,  int fts5yyLookahead,  sqlite3Fts5ParserFTS5TOKENTYPE fts5yyLookaheadToken  sqlite3Fts5ParserCTX_PDECL ){  int fts5yygoto;  fts5YYACTIONTYPE fts5yyact;  fts5yyStackEntry *fts5yymsp;  int fts5yysize;  sqlite3Fts5ParserARG_FETCH  (void)fts5yyLookahead;  (void)fts5yyLookaheadToken;  fts5yymsp = fts5yypParser->fts5yytos;  switch( fts5yyruleno ){  fts5YYMINORTYPE fts5yylhsminor;  case 0: { sqlite3Fts5ParseFinished(pParse, fts5yymsp[0].minor.fts5yy24); }  break;  case 1: {  fts5yymsp[-3].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11); }  break;  case 2: { fts5yymsp[-2].minor.fts5yy11 = fts5yymsp[-1].minor.fts5yy11; }  break;  case 3: {  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0); }  fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;  break;  case 4: {  fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0);  fts5yymsp[-1].minor.fts5yy11 = sqlite3Fts5ParseColsetInvert(pParse, fts5yymsp[-1].minor.fts5yy11); }  break;  case 5: {  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, fts5yymsp[-1].minor.fts5yy11, &fts5yymsp[0].minor.fts5yy0); }  fts5yymsp[-1].minor.fts5yy11 = fts5yylhsminor.fts5yy11;  break;  case 6: {  fts5yylhsminor.fts5yy11 = sqlite3Fts5ParseColset(pParse, 0, &fts5yymsp[0].minor.fts5yy0); }  fts5yymsp[0].minor.fts5yy11 = fts5yylhsminor.fts5yy11;  break;  case 7: {  fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_AND, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0); }  fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 8: {  fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_OR, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0); }  fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 9: {  fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_NOT, fts5yymsp[-2].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24, 0); }  fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 10: {  sqlite3Fts5ParseSetColset(pParse, fts5yymsp[-1].minor.fts5yy24, fts5yymsp[-4].minor.fts5yy11);  fts5yylhsminor.fts5yy24 = fts5yymsp[-1].minor.fts5yy24; }  fts5yymsp[-4].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 11: {fts5yymsp[-2].minor.fts5yy24 = fts5yymsp[-1].minor.fts5yy24;}  break;  case 12:  case 13: fts5yytestcase(fts5yyruleno==13); {fts5yylhsminor.fts5yy24 = fts5yymsp[0].minor.fts5yy24;}  fts5yymsp[0].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 14: {  fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseImplicitAnd(pParse, fts5yymsp[-1].minor.fts5yy24, fts5yymsp[0].minor.fts5yy24); }  fts5yymsp[-1].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 15: {  fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy46); }  fts5yymsp[0].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 16: {  fts5yylhsminor.fts5yy24 = sqlite3Fts5ParseNode(pParse, FTS5_STRING, 0, 0, fts5yymsp[0].minor.fts5yy46);  sqlite3Fts5ParseSetColset(pParse, fts5yylhsminor.fts5yy24, fts5yymsp[-2].minor.fts5yy11); }  fts5yymsp[-2].minor.fts5yy24 = fts5yylhsminor.fts5yy24;  break;  case 17: { fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53); }  fts5yymsp[0].minor.fts5yy46 = fts5yylhsminor.fts5yy46;  break;  case 18: {  sqlite3Fts5ParseSetCaret(fts5yymsp[0].minor.fts5yy53);  fts5yymsp[-1].minor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53); }  break;  case 19: {  sqlite3Fts5ParseNear(pParse, &fts5yymsp[-4].minor.fts5yy0);  sqlite3Fts5ParseSetDistance(pParse, fts5yymsp[-2].minor.fts5yy46, &fts5yymsp[-1].minor.fts5yy0);  fts5yylhsminor.fts5yy46 = fts5yymsp[-2].minor.fts5yy46; }  fts5yymsp[-4].minor.fts5yy46 = fts5yylhsminor.fts5yy46;  break;  case 20: {  fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, 0, fts5yymsp[0].minor.fts5yy53); }  fts5yymsp[0].minor.fts5yy46 = fts5yylhsminor.fts5yy46;  break;  case 21: {  fts5yylhsminor.fts5yy46 = sqlite3Fts5ParseNearset(pParse, fts5yymsp[-1].minor.fts5yy46, fts5yymsp[0].minor.fts5yy53); }  fts5yymsp[-1].minor.fts5yy46 = fts5yylhsminor.fts5yy46;  break;  case 22: { fts5yymsp[1].minor.fts5yy0.p = 0; fts5yymsp[1].minor.fts5yy0.n = 0; }  break;  case 23: { fts5yymsp[-1].minor.fts5yy0 = fts5yymsp[0].minor.fts5yy0; }  break;  case 24: {  fts5yylhsminor.fts5yy53 = sqlite3Fts5ParseTerm(pParse, fts5yymsp[-3].minor.fts5yy53, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy4); }  fts5yymsp[-3].minor.fts5yy53 = fts5yylhsminor.fts5yy53;  break;  case 25: {  fts5yylhsminor.fts5yy53 = sqlite3Fts5ParseTerm(pParse, 0, &fts5yymsp[-1].minor.fts5yy0, fts5yymsp[0].minor.fts5yy4); }  fts5yymsp[-1].minor.fts5yy53 = fts5yylhsminor.fts5yy53;  break;  case 26: { fts5yymsp[0].minor.fts5yy4 = 1; }  break;  case 27: { fts5yymsp[1].minor.fts5yy4 = 0; }  break;  default:  break;  };  assert( fts5yyruleno<sizeof(fts5yyRuleInfoLhs)/sizeof(fts5yyRuleInfoLhs[0]) );  fts5yygoto = fts5yyRuleInfoLhs[fts5yyruleno];  fts5yysize = fts5yyRuleInfoNRhs[fts5yyruleno];  fts5yyact = fts5yy_find_reduce_action(fts5yymsp[fts5yysize].stateno,(fts5YYCODETYPE)fts5yygoto);  assert( !(fts5yyact>fts5YY_MAX_SHIFT && fts5yyact<=fts5YY_MAX_SHIFTREDUCE) );  assert( fts5yyact!=fts5YY_ERROR_ACTION );  fts5yymsp += fts5yysize+1;  fts5yypParser->fts5yytos = fts5yymsp;  fts5yymsp->stateno = (fts5YYACTIONTYPE)fts5yyact;  fts5yymsp->major = (fts5YYCODETYPE)fts5yygoto;  fts5yyTraceShift(fts5yypParser, fts5yyact, "... then shift");  return fts5yyact; }
#ifndef fts5YYNOERRORRECOVERY
static void fts5yy_parse_failed(  fts5yyParser *fts5yypParser ){  sqlite3Fts5ParserARG_FETCH  sqlite3Fts5ParserCTX_FETCH
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE,"%sFail!\n",fts5yyTracePrompt);  }
#endif
 while( fts5yypParser->fts5yytos>fts5yypParser->fts5yystack ) fts5yy_pop_parser_stack(fts5yypParser);  sqlite3Fts5ParserARG_STORE  sqlite3Fts5ParserCTX_STORE }
#endif
static void fts5yy_syntax_error(  fts5yyParser *fts5yypParser,  int fts5yymajor,  sqlite3Fts5ParserFTS5TOKENTYPE fts5yyminor ){  sqlite3Fts5ParserARG_FETCH  sqlite3Fts5ParserCTX_FETCH
#define FTS5TOKEN fts5yyminor
 UNUSED_PARAM(fts5yymajor);  sqlite3Fts5ParseError(  pParse, "fts5: syntax error near \"%.*s\"",FTS5TOKEN.n,FTS5TOKEN.p  );  sqlite3Fts5ParserARG_STORE  sqlite3Fts5ParserCTX_STORE } static void fts5yy_accept(  fts5yyParser *fts5yypParser ){  sqlite3Fts5ParserARG_FETCH  sqlite3Fts5ParserCTX_FETCH
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE,"%sAccept!\n",fts5yyTracePrompt);  }
#endif
#ifndef fts5YYNOERRORRECOVERY
 fts5yypParser->fts5yyerrcnt = -1;
#endif
 assert( fts5yypParser->fts5yytos==fts5yypParser->fts5yystack );  sqlite3Fts5ParserARG_STORE  sqlite3Fts5ParserCTX_STORE } static void sqlite3Fts5Parser(  void *fts5yyp,  int fts5yymajor,  sqlite3Fts5ParserFTS5TOKENTYPE fts5yyminor  sqlite3Fts5ParserARG_PDECL ){  fts5YYMINORTYPE fts5yyminorunion;  fts5YYACTIONTYPE fts5yyact;
#if !defined(fts5YYERRORSYMBOL) && !defined(fts5YYNOERRORRECOVERY)
 int fts5yyendofinput;
#endif
#ifdef fts5YYERRORSYMBOL
 int fts5yyerrorhit = 0;
#endif
 fts5yyParser *fts5yypParser = (fts5yyParser*)fts5yyp;  sqlite3Fts5ParserCTX_FETCH  sqlite3Fts5ParserARG_STORE  assert( fts5yypParser->fts5yytos!=0 );
#if !defined(fts5YYERRORSYMBOL) && !defined(fts5YYNOERRORRECOVERY)
 fts5yyendofinput = (fts5yymajor==0);
#endif
 fts5yyact = fts5yypParser->fts5yytos->stateno;
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  if( fts5yyact < fts5YY_MIN_REDUCE ){  fprintf(fts5yyTraceFILE,"%sInput '%s' in state %d\n",  fts5yyTracePrompt,fts5yyTokenName[fts5yymajor],fts5yyact);  }else{  fprintf(fts5yyTraceFILE,"%sInput '%s' with pending reduce %d\n",  fts5yyTracePrompt,fts5yyTokenName[fts5yymajor],fts5yyact-fts5YY_MIN_REDUCE);  }  }
#endif
 while(1){  assert( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystack );  assert( fts5yyact==fts5yypParser->fts5yytos->stateno );  fts5yyact = fts5yy_find_shift_action((fts5YYCODETYPE)fts5yymajor,fts5yyact);  if( fts5yyact >= fts5YY_MIN_REDUCE ){  unsigned int fts5yyruleno = fts5yyact - fts5YY_MIN_REDUCE;
#ifndef NDEBUG
 assert( fts5yyruleno<(int)(sizeof(fts5yyRuleName)/sizeof(fts5yyRuleName[0])) );  if( fts5yyTraceFILE ){  int fts5yysize = fts5yyRuleInfoNRhs[fts5yyruleno];  if( fts5yysize ){  fprintf(fts5yyTraceFILE, "%sReduce %d [%s]%s, pop back to state %d.\n",  fts5yyTracePrompt,  fts5yyruleno, fts5yyRuleName[fts5yyruleno],  fts5yyruleno<fts5YYNRULE_WITH_ACTION ? "" : " without external action",  fts5yypParser->fts5yytos[fts5yysize].stateno);  }else{  fprintf(fts5yyTraceFILE, "%sReduce %d [%s]%s.\n",  fts5yyTracePrompt, fts5yyruleno, fts5yyRuleName[fts5yyruleno],  fts5yyruleno<fts5YYNRULE_WITH_ACTION ? "" : " without external action");  }  }
#endif
 if( fts5yyRuleInfoNRhs[fts5yyruleno]==0 ){
#ifdef fts5YYTRACKMAXSTACKDEPTH
 if( (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack)>fts5yypParser->fts5yyhwm ){  fts5yypParser->fts5yyhwm++;  assert( fts5yypParser->fts5yyhwm ==  (int)(fts5yypParser->fts5yytos - fts5yypParser->fts5yystack));  }
#endif
#if fts5YYSTACKDEPTH>0
 if( fts5yypParser->fts5yytos>=fts5yypParser->fts5yystackEnd ){  fts5yyStackOverflow(fts5yypParser);  break;  }
#else
 if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz-1] ){  if( fts5yyGrowStack(fts5yypParser) ){  fts5yyStackOverflow(fts5yypParser);  break;  }  }
#endif
 }  fts5yyact = fts5yy_reduce(fts5yypParser,fts5yyruleno,fts5yymajor,fts5yyminor sqlite3Fts5ParserCTX_PARAM);  }else if( fts5yyact <= fts5YY_MAX_SHIFTREDUCE ){  fts5yy_shift(fts5yypParser,fts5yyact,(fts5YYCODETYPE)fts5yymajor,fts5yyminor);
#ifndef fts5YYNOERRORRECOVERY
 fts5yypParser->fts5yyerrcnt--;
#endif
 break;  }else if( fts5yyact==fts5YY_ACCEPT_ACTION ){  fts5yypParser->fts5yytos--;  fts5yy_accept(fts5yypParser);  return;  }else{  assert( fts5yyact == fts5YY_ERROR_ACTION );  fts5yyminorunion.fts5yy0 = fts5yyminor;
#ifdef fts5YYERRORSYMBOL
 int fts5yymx;
#endif
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE,"%sSyntax Error!\n",fts5yyTracePrompt);  }
#endif
#ifdef fts5YYERRORSYMBOL
 if( fts5yypParser->fts5yyerrcnt<0 ){  fts5yy_syntax_error(fts5yypParser,fts5yymajor,fts5yyminor);  }  fts5yymx = fts5yypParser->fts5yytos->major;  if( fts5yymx==fts5YYERRORSYMBOL || fts5yyerrorhit ){
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fprintf(fts5yyTraceFILE,"%sDiscard input token %s\n",   fts5yyTracePrompt,fts5yyTokenName[fts5yymajor]);  }
#endif
 fts5yy_destructor(fts5yypParser, (fts5YYCODETYPE)fts5yymajor, &fts5yyminorunion);  fts5yymajor = fts5YYNOCODE;  }else{  while( fts5yypParser->fts5yytos > fts5yypParser->fts5yystack ){  fts5yyact = fts5yy_find_reduce_action(fts5yypParser->fts5yytos->stateno,  fts5YYERRORSYMBOL);  if( fts5yyact<=fts5YY_MAX_SHIFTREDUCE ) break;  fts5yy_pop_parser_stack(fts5yypParser);  }  if( fts5yypParser->fts5yytos <= fts5yypParser->fts5yystack || fts5yymajor==0 ){  fts5yy_destructor(fts5yypParser,(fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);  fts5yy_parse_failed(fts5yypParser);
#ifndef fts5YYNOERRORRECOVERY
 fts5yypParser->fts5yyerrcnt = -1;
#endif
 fts5yymajor = fts5YYNOCODE;  }else if( fts5yymx!=fts5YYERRORSYMBOL ){  fts5yy_shift(fts5yypParser,fts5yyact,fts5YYERRORSYMBOL,fts5yyminor);  }  }  fts5yypParser->fts5yyerrcnt = 3;  fts5yyerrorhit = 1;  if( fts5yymajor==fts5YYNOCODE ) break;  fts5yyact = fts5yypParser->fts5yytos->stateno;
#elif defined(fts5YYNOERRORRECOVERY)
 fts5yy_syntax_error(fts5yypParser,fts5yymajor, fts5yyminor);  fts5yy_destructor(fts5yypParser,(fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);  break;
#else
 if( fts5yypParser->fts5yyerrcnt<=0 ){  fts5yy_syntax_error(fts5yypParser,fts5yymajor, fts5yyminor);  }  fts5yypParser->fts5yyerrcnt = 3;  fts5yy_destructor(fts5yypParser,(fts5YYCODETYPE)fts5yymajor,&fts5yyminorunion);  if( fts5yyendofinput ){  fts5yy_parse_failed(fts5yypParser);
#ifndef fts5YYNOERRORRECOVERY
 fts5yypParser->fts5yyerrcnt = -1;
#endif
 }  break;
#endif
 }  }
#ifndef NDEBUG
 if( fts5yyTraceFILE ){  fts5yyStackEntry *i;  char cDiv = '[';  fprintf(fts5yyTraceFILE,"%sReturn. Stack=",fts5yyTracePrompt);  for(i=&fts5yypParser->fts5yystack[1]; i<=fts5yypParser->fts5yytos; i++){  fprintf(fts5yyTraceFILE,"%c%s", cDiv, fts5yyTokenName[i->major]);  cDiv = ' ';  }  fprintf(fts5yyTraceFILE,"]\n");  }
#endif
 return; } static int sqlite3Fts5ParserFallback(int iToken){
#ifdef fts5YYFALLBACK
 assert( iToken<(int)(sizeof(fts5yyFallback)/sizeof(fts5yyFallback[0])) );  return fts5yyFallback[iToken];
#else
 (void)iToken;  return 0;
#endif
}
#include <math.h>
typedef struct CInstIter CInstIter; struct CInstIter {  const Fts5ExtensionApi *pApi;  Fts5Context *pFts;  int iCol;  int iInst;  int nInst;  int iStart;  int iEnd; }; static int fts5CInstIterNext(CInstIter *pIter){  int rc = SQLITE_OK;  pIter->iStart = -1;  pIter->iEnd = -1;  while( rc==SQLITE_OK && pIter->iInst<pIter->nInst ){  int ip; int ic; int io;  rc = pIter->pApi->xInst(pIter->pFts, pIter->iInst, &ip, &ic, &io);  if( rc==SQLITE_OK ){  if( ic==pIter->iCol ){  int iEnd = io - 1 + pIter->pApi->xPhraseSize(pIter->pFts, ip);  if( pIter->iStart<0 ){  pIter->iStart = io;  pIter->iEnd = iEnd;  }else if( io<=pIter->iEnd ){  if( iEnd>pIter->iEnd ) pIter->iEnd = iEnd;  }else{  break;  }  }  pIter->iInst++;  }  }  return rc; } static int fts5CInstIterInit(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  int iCol,  CInstIter *pIter ){  int rc;  memset(pIter, 0, sizeof(CInstIter));  pIter->pApi = pApi;  pIter->pFts = pFts;  pIter->iCol = iCol;  rc = pApi->xInstCount(pFts, &pIter->nInst);  if( rc==SQLITE_OK ){  rc = fts5CInstIterNext(pIter);  }  return rc; } typedef struct HighlightContext HighlightContext; struct HighlightContext {  CInstIter iter;  int iPos;  int iRangeStart;  int iRangeEnd;  const char *zOpen;  const char *zClose;  const char *zIn;  int nIn;  int iOff;  char *zOut; }; static void fts5HighlightAppend(  int *pRc,  HighlightContext *p,  const char *z, int n ){  if( *pRc==SQLITE_OK && z ){  if( n<0 ) n = (int)strlen(z);  p->zOut = sqlite3_mprintf("%z%.*s", p->zOut, n, z);  if( p->zOut==0 ) *pRc = SQLITE_NOMEM;  } } static int fts5HighlightCb(  void *pContext,  int tflags,  const char *pToken,  int nToken,  int iStartOff,  int iEndOff ){  HighlightContext *p = (HighlightContext*)pContext;  int rc = SQLITE_OK;  int iPos;  UNUSED_PARAM2(pToken, nToken);  if( tflags & FTS5_TOKEN_COLOCATED ) return SQLITE_OK;  iPos = p->iPos++;  if( p->iRangeEnd>0 ){  if( iPos<p->iRangeStart || iPos>p->iRangeEnd ) return SQLITE_OK;  if( p->iRangeStart && iPos==p->iRangeStart ) p->iOff = iStartOff;  }  if( iPos==p->iter.iStart ){  fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iStartOff - p->iOff);  fts5HighlightAppend(&rc, p, p->zOpen, -1);  p->iOff = iStartOff;  }  if( iPos==p->iter.iEnd ){  if( p->iRangeEnd && p->iter.iStart<p->iRangeStart ){  fts5HighlightAppend(&rc, p, p->zOpen, -1);  }  fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);  fts5HighlightAppend(&rc, p, p->zClose, -1);  p->iOff = iEndOff;  if( rc==SQLITE_OK ){  rc = fts5CInstIterNext(&p->iter);  }  }  if( p->iRangeEnd>0 && iPos==p->iRangeEnd ){  fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);  p->iOff = iEndOff;  if( iPos>=p->iter.iStart && iPos<p->iter.iEnd ){  fts5HighlightAppend(&rc, p, p->zClose, -1);  }  }  return rc; } static void fts5HighlightFunction(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ){  HighlightContext ctx;  int rc;  int iCol;  if( nVal!=3 ){  const char *zErr = "wrong number of arguments to function highlight()";  sqlite3_result_error(pCtx, zErr, -1);  return;  }  iCol = sqlite3_value_int(apVal[0]);  memset(&ctx, 0, sizeof(HighlightContext));  ctx.zOpen = (const char*)sqlite3_value_text(apVal[1]);  ctx.zClose = (const char*)sqlite3_value_text(apVal[2]);  rc = pApi->xColumnText(pFts, iCol, &ctx.zIn, &ctx.nIn);  if( ctx.zIn ){  if( rc==SQLITE_OK ){  rc = fts5CInstIterInit(pApi, pFts, iCol, &ctx.iter);  }  if( rc==SQLITE_OK ){  rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx,fts5HighlightCb);  }  fts5HighlightAppend(&rc, &ctx, &ctx.zIn[ctx.iOff], ctx.nIn - ctx.iOff);  if( rc==SQLITE_OK ){  sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);  }  sqlite3_free(ctx.zOut);  }  if( rc!=SQLITE_OK ){  sqlite3_result_error_code(pCtx, rc);  } } typedef struct Fts5SFinder Fts5SFinder; struct Fts5SFinder {  int iPos;  int nFirstAlloc;  int nFirst;  int *aFirst;  const char *zDoc; }; static int fts5SentenceFinderAdd(Fts5SFinder *p, int iAdd){  if( p->nFirstAlloc==p->nFirst ){  int nNew = p->nFirstAlloc ? p->nFirstAlloc*2 : 64;  int *aNew;  aNew = (int*)sqlite3_realloc64(p->aFirst, nNew*sizeof(int));  if( aNew==0 ) return SQLITE_NOMEM;  p->aFirst = aNew;  p->nFirstAlloc = nNew;  }  p->aFirst[p->nFirst++] = iAdd;  return SQLITE_OK; } static int fts5SentenceFinderCb(  void *pContext,  int tflags,  const char *pToken,  int nToken,  int iStartOff,  int iEndOff ){  int rc = SQLITE_OK;  UNUSED_PARAM2(pToken, nToken);  UNUSED_PARAM(iEndOff);  if( (tflags & FTS5_TOKEN_COLOCATED)==0 ){  Fts5SFinder *p = (Fts5SFinder*)pContext;  if( p->iPos>0 ){  int i;  char c = 0;  for(i=iStartOff-1; i>=0; i--){  c = p->zDoc[i];  if( c!=' ' && c!='\t' && c!='\n' && c!='\r' ) break;  }  if( i!=iStartOff-1 && (c=='.' || c==':') ){  rc = fts5SentenceFinderAdd(p, p->iPos);  }  }else{  rc = fts5SentenceFinderAdd(p, 0);  }  p->iPos++;  }  return rc; } static int fts5SnippetScore(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  int nDocsize,  unsigned char *aSeen,  int iCol,  int iPos,  int nToken,  int *pnScore,  int *piPos ){  int rc;  int i;  int ip = 0;  int ic = 0;  int iOff = 0;  int iFirst = -1;  int nInst;  int nScore = 0;  int iLast = 0;  sqlite3_int64 iEnd = (sqlite3_int64)iPos + nToken;  rc = pApi->xInstCount(pFts, &nInst);  for(i=0; i<nInst && rc==SQLITE_OK; i++){  rc = pApi->xInst(pFts, i, &ip, &ic, &iOff);  if( rc==SQLITE_OK && ic==iCol && iOff>=iPos && iOff<iEnd ){  nScore += (aSeen[ip] ? 1 : 1000);  aSeen[ip] = 1;  if( iFirst<0 ) iFirst = iOff;  iLast = iOff + pApi->xPhraseSize(pFts, ip);  }  }  *pnScore = nScore;  if( piPos ){  sqlite3_int64 iAdj = iFirst - (nToken - (iLast-iFirst)) / 2;  if( (iAdj+nToken)>nDocsize ) iAdj = nDocsize - nToken;  if( iAdj<0 ) iAdj = 0;  *piPos = (int)iAdj;  }  return rc; } static const char *fts5ValueToText(sqlite3_value *pVal){  const char *zRet = (const char*)sqlite3_value_text(pVal);  return zRet ? zRet : ""; } static void fts5SnippetFunction(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ){  HighlightContext ctx;  int rc = SQLITE_OK;  int iCol;  const char *zEllips;  int nToken;  int nInst = 0;  int i;  int nPhrase;  unsigned char *aSeen;  int iBestCol;  int iBestStart = 0;  int nBestScore = 0;  int nColSize = 0;  Fts5SFinder sFinder;  int nCol;  if( nVal!=5 ){  const char *zErr = "wrong number of arguments to function snippet()";  sqlite3_result_error(pCtx, zErr, -1);  return;  }  nCol = pApi->xColumnCount(pFts);  memset(&ctx, 0, sizeof(HighlightContext));  iCol = sqlite3_value_int(apVal[0]);  ctx.zOpen = fts5ValueToText(apVal[1]);  ctx.zClose = fts5ValueToText(apVal[2]);  zEllips = fts5ValueToText(apVal[3]);  nToken = sqlite3_value_int(apVal[4]);  iBestCol = (iCol>=0 ? iCol : 0);  nPhrase = pApi->xPhraseCount(pFts);  aSeen = sqlite3_malloc(nPhrase);  if( aSeen==0 ){  rc = SQLITE_NOMEM;  }  if( rc==SQLITE_OK ){  rc = pApi->xInstCount(pFts, &nInst);  }  memset(&sFinder, 0, sizeof(Fts5SFinder));  for(i=0; i<nCol; i++){  if( iCol<0 || iCol==i ){  int nDoc;  int nDocsize;  int ii;  sFinder.iPos = 0;  sFinder.nFirst = 0;  rc = pApi->xColumnText(pFts, i, &sFinder.zDoc, &nDoc);  if( rc!=SQLITE_OK ) break;  rc = pApi->xTokenize(pFts,  sFinder.zDoc, nDoc, (void*)&sFinder,fts5SentenceFinderCb  );  if( rc!=SQLITE_OK ) break;  rc = pApi->xColumnSize(pFts, i, &nDocsize);  if( rc!=SQLITE_OK ) break;  for(ii=0; rc==SQLITE_OK && ii<nInst; ii++){  int ip, ic, io;  int iAdj;  int nScore;  int jj;  rc = pApi->xInst(pFts, ii, &ip, &ic, &io);  if( ic!=i ) continue;  if( io>nDocsize ) rc = FTS5_CORRUPT;  if( rc!=SQLITE_OK ) continue;  memset(aSeen, 0, nPhrase);  rc = fts5SnippetScore(pApi, pFts, nDocsize, aSeen, i,  io, nToken, &nScore, &iAdj  );  if( rc==SQLITE_OK && nScore>nBestScore ){  nBestScore = nScore;  iBestCol = i;  iBestStart = iAdj;  nColSize = nDocsize;  }  if( rc==SQLITE_OK && sFinder.nFirst && nDocsize>nToken ){  for(jj=0; jj<(sFinder.nFirst-1); jj++){  if( sFinder.aFirst[jj+1]>io ) break;  }  if( sFinder.aFirst[jj]<io ){  memset(aSeen, 0, nPhrase);  rc = fts5SnippetScore(pApi, pFts, nDocsize, aSeen, i,  sFinder.aFirst[jj], nToken, &nScore, 0  );  nScore += (sFinder.aFirst[jj]==0 ? 120 : 100);  if( rc==SQLITE_OK && nScore>nBestScore ){  nBestScore = nScore;  iBestCol = i;  iBestStart = sFinder.aFirst[jj];  nColSize = nDocsize;  }  }  }  }  }  }  if( rc==SQLITE_OK ){  rc = pApi->xColumnText(pFts, iBestCol, &ctx.zIn, &ctx.nIn);  }  if( rc==SQLITE_OK && nColSize==0 ){  rc = pApi->xColumnSize(pFts, iBestCol, &nColSize);  }  if( ctx.zIn ){  if( rc==SQLITE_OK ){  rc = fts5CInstIterInit(pApi, pFts, iBestCol, &ctx.iter);  }  ctx.iRangeStart = iBestStart;  ctx.iRangeEnd = iBestStart + nToken - 1;  if( iBestStart>0 ){  fts5HighlightAppend(&rc, &ctx, zEllips, -1);  }  while( ctx.iter.iStart>=0 && ctx.iter.iStart<iBestStart && rc==SQLITE_OK ){  rc = fts5CInstIterNext(&ctx.iter);  }  if( rc==SQLITE_OK ){  rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx,fts5HighlightCb);  }  if( ctx.iRangeEnd>=(nColSize-1) ){  fts5HighlightAppend(&rc, &ctx, &ctx.zIn[ctx.iOff], ctx.nIn - ctx.iOff);  }else{  fts5HighlightAppend(&rc, &ctx, zEllips, -1);  }  }  if( rc==SQLITE_OK ){  sqlite3_result_text(pCtx, (const char*)ctx.zOut, -1, SQLITE_TRANSIENT);  }else{  sqlite3_result_error_code(pCtx, rc);  }  sqlite3_free(ctx.zOut);  sqlite3_free(aSeen);  sqlite3_free(sFinder.aFirst); } typedef struct Fts5Bm25Data Fts5Bm25Data; struct Fts5Bm25Data {  int nPhrase;  double avgdl;  double *aIDF;  double *aFreq; }; static int fts5CountCb(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  void *pUserData ){  sqlite3_int64 *pn = (sqlite3_int64*)pUserData;  UNUSED_PARAM2(pApi, pFts);  (*pn)++;  return SQLITE_OK; } static int fts5Bm25GetData(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  Fts5Bm25Data **ppData ){  int rc = SQLITE_OK;  Fts5Bm25Data *p;  p = (Fts5Bm25Data*)pApi->xGetAuxdata(pFts, 0);  if( p==0 ){  int nPhrase;  sqlite3_int64 nRow = 0;  sqlite3_int64 nToken = 0;  sqlite3_int64 nByte;  int i;  nPhrase = pApi->xPhraseCount(pFts);  nByte = sizeof(Fts5Bm25Data) + nPhrase*2*sizeof(double);  p = (Fts5Bm25Data*)sqlite3_malloc64(nByte);  if( p==0 ){  rc = SQLITE_NOMEM;  }else{  memset(p, 0, (size_t)nByte);  p->nPhrase = nPhrase;  p->aIDF = (double*)&p[1];  p->aFreq = &p->aIDF[nPhrase];  }  if( rc==SQLITE_OK ) rc = pApi->xRowCount(pFts, &nRow);  assert( rc!=SQLITE_OK || nRow>0 );  if( rc==SQLITE_OK ) rc = pApi->xColumnTotalSize(pFts, -1, &nToken);  if( rc==SQLITE_OK ) p->avgdl = (double)nToken / (double)nRow;  for(i=0; rc==SQLITE_OK && i<nPhrase; i++){  sqlite3_int64 nHit = 0;  rc = pApi->xQueryPhrase(pFts, i, (void*)&nHit, fts5CountCb);  if( rc==SQLITE_OK ){  double idf = log( (nRow - nHit + 0.5) / (nHit + 0.5) );  if( idf<=0.0 ) idf = 1e-6;  p->aIDF[i] = idf;  }  }  if( rc!=SQLITE_OK ){  sqlite3_free(p);  }else{  rc = pApi->xSetAuxdata(pFts, p, sqlite3_free);  }  if( rc!=SQLITE_OK ) p = 0;  }  *ppData = p;  return rc; } static void fts5Bm25Function(  const Fts5ExtensionApi *pApi,  Fts5Context *pFts,  sqlite3_context *pCtx,  int nVal,  sqlite3_value **apVal ){  const double k1 = 1.2;  const double b = 0.75;  int rc;  double score = 0.0;  Fts5Bm25Data *pData;  int i;  int nInst = 0;  double D = 0.0;  double *aFreq = 0;  rc = fts5Bm25GetData(pApi, pFts, &pData);  if( rc==SQLITE_OK ){  aFreq = pData->aFreq;  memset(aFreq, 0, sizeof(double) * pData->nPhrase);  rc = pApi->xInstCount(pFts, &nInst);  }  for(i=0; rc==SQLITE_OK && i<nInst; i++){  int ip; int ic; int io;  rc = pApi->xInst(pFts, i, &ip, &ic, &io);  if( rc==SQLITE_OK ){  double w = (nVal > ic) ? sqlite3_value_double(apVal[ic]) : 1.0;  aFreq[ip] += w;  }  }  if( rc==SQLITE_OK ){  int nTok;  rc = pApi->xColumnSize(pFts, -1, &nTok);  D = (double)nTok;  }  if( rc==SQLITE_OK ){  for(i=0; i<pData->nPhrase; i++){  score += pData->aIDF[i] * (  ( aFreq[i] * (k1 + 1.0) ) /  ( aFreq[i] + k1 * (1 - b + b * D / pData->avgdl) )  );  }  sqlite3_result_double(pCtx, -1.0 * score);  }else{  sqlite3_result_error_code(pCtx, rc);  } } static int sqlite3Fts5AuxInit(fts5_api *pApi){  struct Builtin {  const char *zFunc;  void *pUserData;  fts5_extension_function xFunc;  void (*xDestroy)(void*);  } aBuiltin [] = {  { "snippet", 0, fts5SnippetFunction, 0 },  { "highlight", 0, fts5HighlightFunction, 0 },  { "bm25", 0, fts5Bm25Function, 0 },  };  int rc = SQLITE_OK;  int i;  for(i=0; rc==SQLITE_OK && i<ArraySize(aBuiltin); i++){  rc = pApi->xCreateFunction(pApi,  aBuiltin[i].zFunc,  aBuiltin[i].pUserData,  aBuiltin[i].xFunc,  aBuiltin[i].xDestroy  );  }  return rc; } static int sqlite3Fts5BufferSize(int *pRc, Fts5Buffer *pBuf, u32 nByte){  if( (u32)pBuf->nSpace<nByte ){  u64 nNew = pBuf->nSpace ? pBuf->nSpace : 64;  u8 *pNew;  while( nNew<nByte ){  nNew = nNew * 2;  }  pNew = sqlite3_realloc64(pBuf->p, nNew);  if( pNew==0 ){  *pRc = SQLITE_NOMEM;  return 1;  }else{  pBuf->nSpace = (int)nNew;  pBuf->p = pNew;  }  }  return 0; } static void sqlite3Fts5BufferAppendVarint(int *pRc, Fts5Buffer *pBuf, i64 iVal){  if( fts5BufferGrow(pRc, pBuf, 9) ) return;  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iVal); } static void sqlite3Fts5Put32(u8 *aBuf, int iVal){  aBuf[0] = (iVal>>24) & 0x00FF;  aBuf[1] = (iVal>>16) & 0x00FF;  aBuf[2] = (iVal>> 8) & 0x00FF;  aBuf[3] = (iVal>> 0) & 0x00FF; } static int sqlite3Fts5Get32(const u8 *aBuf){  return (int)((((u32)aBuf[0])<<24) + (aBuf[1]<<16) + (aBuf[2]<<8) + aBuf[3]); } static void sqlite3Fts5BufferAppendBlob(  int *pRc,  Fts5Buffer *pBuf,  u32 nData,  const u8 *pData ){  if( nData ){  if( fts5BufferGrow(pRc, pBuf, nData) ) return;  memcpy(&pBuf->p[pBuf->n], pData, nData);  pBuf->n += nData;  } } static void sqlite3Fts5BufferAppendString(  int *pRc,  Fts5Buffer *pBuf,  const char *zStr ){  int nStr = (int)strlen(zStr);  sqlite3Fts5BufferAppendBlob(pRc, pBuf, nStr+1, (const u8*)zStr);  pBuf->n--; } static void sqlite3Fts5BufferAppendPrintf(  int *pRc,  Fts5Buffer *pBuf,  char *zFmt, ... ){  if( *pRc==SQLITE_OK ){  char *zTmp;  va_list ap;  va_start(ap, zFmt);  zTmp = sqlite3_vmprintf(zFmt, ap);  va_end(ap);  if( zTmp==0 ){  *pRc = SQLITE_NOMEM;  }else{  sqlite3Fts5BufferAppendString(pRc, pBuf, zTmp);  sqlite3_free(zTmp);  }  } } static char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...){  char *zRet = 0;  if( *pRc==SQLITE_OK ){  va_list ap;  va_start(ap, zFmt);  zRet = sqlite3_vmprintf(zFmt, ap);  va_end(ap);  if( zRet==0 ){  *pRc = SQLITE_NOMEM;  }  }  return zRet; } static void sqlite3Fts5BufferFree(Fts5Buffer *pBuf){  sqlite3_free(pBuf->p);  memset(pBuf, 0, sizeof(Fts5Buffer)); } static void sqlite3Fts5BufferZero(Fts5Buffer *pBuf){  pBuf->n = 0; } static void sqlite3Fts5BufferSet(  int *pRc,  Fts5Buffer *pBuf,  int nData,  const u8 *pData ){  pBuf->n = 0;  sqlite3Fts5BufferAppendBlob(pRc, pBuf, nData, pData); } static int sqlite3Fts5PoslistNext64(  const u8 *a, int n,  int *pi,  i64 *piOff ){  int i = *pi;  if( i>=n ){  *piOff = -1;  return 1;  }else{  i64 iOff = *piOff;  u32 iVal;  fts5FastGetVarint32(a, i, iVal);  if( iVal<=1 ){  if( iVal==0 ){  *pi = i;  return 0;  }  fts5FastGetVarint32(a, i, iVal);  iOff = ((i64)iVal) << 32;  assert( iOff>=0 );  fts5FastGetVarint32(a, i, iVal);  if( iVal<2 ){  *piOff = -1;  return 1;  }  *piOff = iOff + ((iVal-2) & 0x7FFFFFFF);  }else{  *piOff = (iOff & (i64)0x7FFFFFFF<<32)+((iOff + (iVal-2)) & 0x7FFFFFFF);  }  *pi = i;  assert_nc( *piOff>=iOff );  return 0;  } } static int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader *pIter){  if( sqlite3Fts5PoslistNext64(pIter->a, pIter->n, &pIter->i, &pIter->iPos) ){  pIter->bEof = 1;  }  return pIter->bEof; } static int sqlite3Fts5PoslistReaderInit(  const u8 *a, int n,  Fts5PoslistReader *pIter ){  memset(pIter, 0, sizeof(*pIter));  pIter->a = a;  pIter->n = n;  sqlite3Fts5PoslistReaderNext(pIter);  return pIter->bEof; } static void sqlite3Fts5PoslistSafeAppend(  Fts5Buffer *pBuf,  i64 *piPrev,  i64 iPos ){  if( iPos>=*piPrev ){  static const i64 colmask = ((i64)(0x7FFFFFFF)) << 32;  if( (iPos & colmask) != (*piPrev & colmask) ){  pBuf->p[pBuf->n++] = 1;  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos>>32));  *piPrev = (iPos & colmask);  }  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], (iPos-*piPrev)+2);  *piPrev = iPos;  } } static int sqlite3Fts5PoslistWriterAppend(  Fts5Buffer *pBuf,  Fts5PoslistWriter *pWriter,  i64 iPos ){  int rc = 0;  if( fts5BufferGrow(&rc, pBuf, 5+5+5) ) return rc;  sqlite3Fts5PoslistSafeAppend(pBuf, &pWriter->iPrev, iPos);  return SQLITE_OK; } static void *sqlite3Fts5MallocZero(int *pRc, sqlite3_int64 nByte){  void *pRet = 0;  if( *pRc==SQLITE_OK ){  pRet = sqlite3_malloc64(nByte);  if( pRet==0 ){  if( nByte>0 ) *pRc = SQLITE_NOMEM;  }else{  memset(pRet, 0, (size_t)nByte);  }  }  return pRet; } static char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn){  char *zRet = 0;  if( *pRc==SQLITE_OK ){  if( nIn<0 ){  nIn = (int)strlen(pIn);  }  zRet = (char*)sqlite3_malloc(nIn+1);  if( zRet ){  memcpy(zRet, pIn, nIn);  zRet[nIn] = '\0';  }else{  *pRc = SQLITE_NOMEM;  }  }  return zRet; } static int sqlite3Fts5IsBareword(char t){  u8 aBareword[128] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0  };  return (t & 0x80) || aBareword[(int)t]; } typedef struct Fts5TermsetEntry Fts5TermsetEntry; struct Fts5TermsetEntry {  char *pTerm;  int nTerm;  int iIdx;  Fts5TermsetEntry *pNext; }; struct Fts5Termset {  Fts5TermsetEntry *apHash[512]; }; static int sqlite3Fts5TermsetNew(Fts5Termset **pp){  int rc = SQLITE_OK;  *pp = sqlite3Fts5MallocZero(&rc, sizeof(Fts5Termset));  return rc; } static int sqlite3Fts5TermsetAdd(  Fts5Termset *p,  int iIdx,  const char *pTerm, int nTerm,  int *pbPresent ){  int rc = SQLITE_OK;  *pbPresent = 0;  if( p ){  int i;  u32 hash = 13;  Fts5TermsetEntry *pEntry;  for(i=nTerm-1; i>=0; i--){  hash = (hash << 3) ^ hash ^ pTerm[i];  }  hash = (hash << 3) ^ hash ^ iIdx;  hash = hash % ArraySize(p->apHash);  for(pEntry=p->apHash[hash]; pEntry; pEntry=pEntry->pNext){  if( pEntry->iIdx==iIdx  && pEntry->nTerm==nTerm  && memcmp(pEntry->pTerm, pTerm, nTerm)==0  ){  *pbPresent = 1;  break;  }  }  if( pEntry==0 ){  pEntry = sqlite3Fts5MallocZero(&rc, sizeof(Fts5TermsetEntry) + nTerm);  if( pEntry ){  pEntry->pTerm = (char*)&pEntry[1];  pEntry->nTerm = nTerm;  pEntry->iIdx = iIdx;  memcpy(pEntry->pTerm, pTerm, nTerm);  pEntry->pNext = p->apHash[hash];  p->apHash[hash] = pEntry;  }  }  }  return rc; } static void sqlite3Fts5TermsetFree(Fts5Termset *p){  if( p ){  u32 i;  for(i=0; i<ArraySize(p->apHash); i++){  Fts5TermsetEntry *pEntry = p->apHash[i];  while( pEntry ){  Fts5TermsetEntry *pDel = pEntry;  pEntry = pEntry->pNext;  sqlite3_free(pDel);  }  }  sqlite3_free(p);  } }
#define FTS5_DEFAULT_PAGE_SIZE  4050
#define FTS5_DEFAULT_AUTOMERGE 4
#define FTS5_DEFAULT_USERMERGE 4
#define FTS5_DEFAULT_CRISISMERGE  16
#define FTS5_DEFAULT_HASHSIZE (1024*1024)
#define FTS5_MAX_PAGE_SIZE (64*1024)
static int fts5_iswhitespace(char x){  return (x==' '); } static int fts5_isopenquote(char x){  return (x=='"' || x=='\'' || x=='[' || x=='`'); } static const char *fts5ConfigSkipWhitespace(const char *pIn){  const char *p = pIn;  if( p ){  while( fts5_iswhitespace(*p) ){ p++; }  }  return p; } static const char *fts5ConfigSkipBareword(const char *pIn){  const char *p = pIn;  while ( sqlite3Fts5IsBareword(*p) ) p++;  if( p==pIn ) p = 0;  return p; } static int fts5_isdigit(char a){  return (a>='0' && a<='9'); } static const char *fts5ConfigSkipLiteral(const char *pIn){  const char *p = pIn;  switch( *p ){  case 'n': case 'N':  if( sqlite3_strnicmp("null", p, 4)==0 ){  p = &p[4];  }else{  p = 0;  }  break;  case 'x': case 'X':  p++;  if( *p=='\'' ){  p++;  while( (*p>='a' && *p<='f')  || (*p>='A' && *p<='F')  || (*p>='0' && *p<='9')  ){  p++;  }  if( *p=='\'' && 0==((p-pIn)%2) ){  p++;  }else{  p = 0;  }  }else{  p = 0;  }  break;  case '\'':  p++;  while( p ){  if( *p=='\'' ){  p++;  if( *p!='\'' ) break;  }  p++;  if( *p==0 ) p = 0;  }  break;  default:  if( *p=='+' || *p=='-' ) p++;  while( fts5_isdigit(*p) ) p++;  if( *p=='.' && fts5_isdigit(p[1]) ){  p += 2;  while( fts5_isdigit(*p) ) p++;  }  if( p==pIn ) p = 0;  break;  }  return p; } static int fts5Dequote(char *z){  char q;  int iIn = 1;  int iOut = 0;  q = z[0];  assert( q=='[' || q=='\'' || q=='"' || q=='`' );  if( q=='[' ) q = ']';  while( z[iIn] ){  if( z[iIn]==q ){  if( z[iIn+1]!=q ){  iIn++;  break;  }else{  iIn += 2;  z[iOut++] = q;  }  }else{  z[iOut++] = z[iIn++];  }  }  z[iOut] = '\0';  return iIn; } static void sqlite3Fts5Dequote(char *z){  char quote;  assert( 0==fts5_iswhitespace(z[0]) );  quote = z[0];  if( quote=='[' || quote=='\'' || quote=='"' || quote=='`' ){  fts5Dequote(z);  } } struct Fts5Enum {  const char *zName;  int eVal; }; typedef struct Fts5Enum Fts5Enum; static int fts5ConfigSetEnum(  const Fts5Enum *aEnum,  const char *zEnum,  int *peVal ){  int nEnum = (int)strlen(zEnum);  int i;  int iVal = -1;  for(i=0; aEnum[i].zName; i++){  if( sqlite3_strnicmp(aEnum[i].zName, zEnum, nEnum)==0 ){  if( iVal>=0 ) return SQLITE_ERROR;  iVal = aEnum[i].eVal;  }  }  *peVal = iVal;  return iVal<0 ? SQLITE_ERROR : SQLITE_OK; } static int fts5ConfigParseSpecial(  Fts5Global *pGlobal,  Fts5Config *pConfig,  const char *zCmd,  const char *zArg,  char **pzErr ){  int rc = SQLITE_OK;  int nCmd = (int)strlen(zCmd);  if( sqlite3_strnicmp("prefix", zCmd, nCmd)==0 ){  const int nByte = sizeof(int) * FTS5_MAX_PREFIX_INDEXES;  const char *p;  int bFirst = 1;  if( pConfig->aPrefix==0 ){  pConfig->aPrefix = sqlite3Fts5MallocZero(&rc, nByte);  if( rc ) return rc;  }  p = zArg;  while( 1 ){  int nPre = 0;  while( p[0]==' ' ) p++;  if( bFirst==0 && p[0]==',' ){  p++;  while( p[0]==' ' ) p++;  }else if( p[0]=='\0' ){  break;  }  if( p[0]<'0' || p[0]>'9' ){  *pzErr = sqlite3_mprintf("malformed prefix=... directive");  rc = SQLITE_ERROR;  break;  }  if( pConfig->nPrefix==FTS5_MAX_PREFIX_INDEXES ){  *pzErr = sqlite3_mprintf(  "too many prefix indexes (max %d)", FTS5_MAX_PREFIX_INDEXES  );  rc = SQLITE_ERROR;  break;  }  while( p[0]>='0' && p[0]<='9' && nPre<1000 ){  nPre = nPre*10 + (p[0] - '0');  p++;  }  if( nPre<=0 || nPre>=1000 ){  *pzErr = sqlite3_mprintf("prefix length out of range (max 999)");  rc = SQLITE_ERROR;  break;  }  pConfig->aPrefix[pConfig->nPrefix] = nPre;  pConfig->nPrefix++;  bFirst = 0;  }  assert( pConfig->nPrefix<=FTS5_MAX_PREFIX_INDEXES );  return rc;  }  if( sqlite3_strnicmp("tokenize", zCmd, nCmd)==0 ){  const char *p = (const char*)zArg;  sqlite3_int64 nArg = strlen(zArg) + 1;  char **azArg = sqlite3Fts5MallocZero(&rc, sizeof(char*) * nArg);  char *pDel = sqlite3Fts5MallocZero(&rc, nArg * 2);  char *pSpace = pDel;  if( azArg && pSpace ){  if( pConfig->pTok ){  *pzErr = sqlite3_mprintf("multiple tokenize=... directives");  rc = SQLITE_ERROR;  }else{  for(nArg=0; p && *p; nArg++){  const char *p2 = fts5ConfigSkipWhitespace(p);  if( *p2=='\'' ){  p = fts5ConfigSkipLiteral(p2);  }else{  p = fts5ConfigSkipBareword(p2);  }  if( p ){  memcpy(pSpace, p2, p-p2);  azArg[nArg] = pSpace;  sqlite3Fts5Dequote(pSpace);  pSpace += (p - p2) + 1;  p = fts5ConfigSkipWhitespace(p);  }  }  if( p==0 ){  *pzErr = sqlite3_mprintf("parse error in tokenize directive");  rc = SQLITE_ERROR;  }else{  rc = sqlite3Fts5GetTokenizer(pGlobal,  (const char**)azArg, (int)nArg, pConfig,  pzErr  );  }  }  }  sqlite3_free(azArg);  sqlite3_free(pDel);  return rc;  }  if( sqlite3_strnicmp("content", zCmd, nCmd)==0 ){  if( pConfig->eContent!=FTS5_CONTENT_NORMAL ){  *pzErr = sqlite3_mprintf("multiple content=... directives");  rc = SQLITE_ERROR;  }else{  if( zArg[0] ){  pConfig->eContent = FTS5_CONTENT_EXTERNAL;  pConfig->zContent = sqlite3Fts5Mprintf(&rc, "%Q.%Q", pConfig->zDb,zArg);  }else{  pConfig->eContent = FTS5_CONTENT_NONE;  }  }  return rc;  }  if( sqlite3_strnicmp("content_rowid", zCmd, nCmd)==0 ){  if( pConfig->zContentRowid ){  *pzErr = sqlite3_mprintf("multiple content_rowid=... directives");  rc = SQLITE_ERROR;  }else{  pConfig->zContentRowid = sqlite3Fts5Strndup(&rc, zArg, -1);  }  return rc;  }  if( sqlite3_strnicmp("columnsize", zCmd, nCmd)==0 ){  if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1]!='\0' ){  *pzErr = sqlite3_mprintf("malformed columnsize=... directive");  rc = SQLITE_ERROR;  }else{  pConfig->bColumnsize = (zArg[0]=='1');  }  return rc;  }  if( sqlite3_strnicmp("detail", zCmd, nCmd)==0 ){  const Fts5Enum aDetail[] = {  { "none", FTS5_DETAIL_NONE },  { "full", FTS5_DETAIL_FULL },  { "columns", FTS5_DETAIL_COLUMNS },  { 0, 0 }  };  if( (rc = fts5ConfigSetEnum(aDetail, zArg, &pConfig->eDetail)) ){  *pzErr = sqlite3_mprintf("malformed detail=... directive");  }  return rc;  }  *pzErr = sqlite3_mprintf("unrecognized option: \"%.*s\"", nCmd, zCmd);  return SQLITE_ERROR; } static int fts5ConfigDefaultTokenizer(Fts5Global *pGlobal, Fts5Config *pConfig){  assert( pConfig->pTok==0 && pConfig->pTokApi==0 );  return sqlite3Fts5GetTokenizer(pGlobal, 0, 0, pConfig, 0); } static const char *fts5ConfigGobbleWord(  int *pRc,  const char *zIn,  char **pzOut,  int *pbQuoted ){  const char *zRet = 0;  sqlite3_int64 nIn = strlen(zIn);  char *zOut = sqlite3_malloc64(nIn+1);  assert( *pRc==SQLITE_OK );  *pbQuoted = 0;  *pzOut = 0;  if( zOut==0 ){  *pRc = SQLITE_NOMEM;  }else{  memcpy(zOut, zIn, (size_t)(nIn+1));  if( fts5_isopenquote(zOut[0]) ){  int ii = fts5Dequote(zOut);  zRet = &zIn[ii];  *pbQuoted = 1;  }else{  zRet = fts5ConfigSkipBareword(zIn);  if( zRet ){  zOut[zRet-zIn] = '\0';  }  }  }  if( zRet==0 ){  sqlite3_free(zOut);  }else{  *pzOut = zOut;  }  return zRet; } static int fts5ConfigParseColumn(  Fts5Config *p,  char *zCol,  char *zArg,  char **pzErr ){  int rc = SQLITE_OK;  if( 0==sqlite3_stricmp(zCol, FTS5_RANK_NAME)   || 0==sqlite3_stricmp(zCol, FTS5_ROWID_NAME)  ){  *pzErr = sqlite3_mprintf("reserved fts5 column name: %s", zCol);  rc = SQLITE_ERROR;  }else if( zArg ){  if( 0==sqlite3_stricmp(zArg, "unindexed") ){  p->abUnindexed[p->nCol] = 1;  }else{  *pzErr = sqlite3_mprintf("unrecognized column option: %s", zArg);  rc = SQLITE_ERROR;  }  }  p->azCol[p->nCol++] = zCol;  return rc; } static int fts5ConfigMakeExprlist(Fts5Config *p){  int i;  int rc = SQLITE_OK;  Fts5Buffer buf = {0, 0, 0};  sqlite3Fts5BufferAppendPrintf(&rc, &buf, "T.%Q", p->zContentRowid);  if( p->eContent!=FTS5_CONTENT_NONE ){  for(i=0; i<p->nCol; i++){  if( p->eContent==FTS5_CONTENT_EXTERNAL ){  sqlite3Fts5BufferAppendPrintf(&rc, &buf, ", T.%Q", p->azCol[i]);  }else{  sqlite3Fts5BufferAppendPrintf(&rc, &buf, ", T.c%d", i);  }  }  }  assert( p->zContentExprlist==0 );  p->zContentExprlist = (char*)buf.p;  return rc; } static int sqlite3Fts5ConfigParse(  Fts5Global *pGlobal,  sqlite3 *db,  int nArg,  const char **azArg,  Fts5Config **ppOut,  char **pzErr ){  int rc = SQLITE_OK;  Fts5Config *pRet;  int i;  sqlite3_int64 nByte;  *ppOut = pRet = (Fts5Config*)sqlite3_malloc(sizeof(Fts5Config));  if( pRet==0 ) return SQLITE_NOMEM;  memset(pRet, 0, sizeof(Fts5Config));  pRet->db = db;  pRet->iCookie = -1;  nByte = nArg * (sizeof(char*) + sizeof(u8));  pRet->azCol = (char**)sqlite3Fts5MallocZero(&rc, nByte);  pRet->abUnindexed = pRet->azCol ? (u8*)&pRet->azCol[nArg] : 0;  pRet->zDb = sqlite3Fts5Strndup(&rc, azArg[1], -1);  pRet->zName = sqlite3Fts5Strndup(&rc, azArg[2], -1);  pRet->bColumnsize = 1;  pRet->eDetail = FTS5_DETAIL_FULL;
#ifdef SQLITE_DEBUG
 pRet->bPrefixIndex = 1;
#endif
 if( rc==SQLITE_OK && sqlite3_stricmp(pRet->zName, FTS5_RANK_NAME)==0 ){  *pzErr = sqlite3_mprintf("reserved fts5 table name: %s", pRet->zName);  rc = SQLITE_ERROR;  }  for(i=3; rc==SQLITE_OK && i<nArg; i++){  const char *zOrig = azArg[i];  const char *z;  char *zOne = 0;  char *zTwo = 0;  int bOption = 0;  int bMustBeCol = 0;  z = fts5ConfigGobbleWord(&rc, zOrig, &zOne, &bMustBeCol);  z = fts5ConfigSkipWhitespace(z);  if( z && *z=='=' ){  bOption = 1;  assert( zOne!=0 );  z++;  if( bMustBeCol ) z = 0;  }  z = fts5ConfigSkipWhitespace(z);  if( z && z[0] ){  int bDummy;  z = fts5ConfigGobbleWord(&rc, z, &zTwo, &bDummy);  if( z && z[0] ) z = 0;  }  if( rc==SQLITE_OK ){  if( z==0 ){  *pzErr = sqlite3_mprintf("parse error in \"%s\"", zOrig);  rc = SQLITE_ERROR;  }else{  if( bOption ){  rc = fts5ConfigParseSpecial(pGlobal, pRet,  ALWAYS(zOne)?zOne:"",  zTwo?zTwo:"",  pzErr  );  }else{  rc = fts5ConfigParseColumn(pRet, zOne, zTwo, pzErr);  zOne = 0;  }  }  }  sqlite3_free(zOne);  sqlite3_free(zTwo);  }  if( rc==SQLITE_OK && pRet->pTok==0 ){  rc = fts5ConfigDefaultTokenizer(pGlobal, pRet);  }  if( rc==SQLITE_OK && pRet->zContent==0 ){  const char *zTail = 0;  assert( pRet->eContent==FTS5_CONTENT_NORMAL   || pRet->eContent==FTS5_CONTENT_NONE  );  if( pRet->eContent==FTS5_CONTENT_NORMAL ){  zTail = "content";  }else if( pRet->bColumnsize ){  zTail = "docsize";  }  if( zTail ){  pRet->zContent = sqlite3Fts5Mprintf(  &rc, "%Q.'%q_%s'", pRet->zDb, pRet->zName, zTail  );  }  }  if( rc==SQLITE_OK && pRet->zContentRowid==0 ){  pRet->zContentRowid = sqlite3Fts5Strndup(&rc, "rowid", -1);  }  if( rc==SQLITE_OK ){  rc = fts5ConfigMakeExprlist(pRet);  }  if( rc!=SQLITE_OK ){  sqlite3Fts5ConfigFree(pRet);  *ppOut = 0;  }  return rc; } static void sqlite3Fts5ConfigFree(Fts5Config *pConfig){  if( pConfig ){  int i;  if( pConfig->pTok ){  pConfig->pTokApi->xDelete(pConfig->pTok);  }  sqlite3_free(pConfig->zDb);  sqlite3_free(pConfig->zName);  for(i=0; i<pConfig->nCol; i++){  sqlite3_free(pConfig->azCol[i]);  }  sqlite3_free(pConfig->azCol);  sqlite3_free(pConfig->aPrefix);  sqlite3_free(pConfig->zRank);  sqlite3_free(pConfig->zRankArgs);  sqlite3_free(pConfig->zContent);  sqlite3_free(pConfig->zContentRowid);  sqlite3_free(pConfig->zContentExprlist);  sqlite3_free(pConfig);  } } static int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig){  int i;  int rc = SQLITE_OK;  char *zSql;  zSql = sqlite3Fts5Mprintf(&rc, "CREATE TABLE x(");  for(i=0; zSql && i<pConfig->nCol; i++){  const char *zSep = (i==0?"":", ");  zSql = sqlite3Fts5Mprintf(&rc, "%z%s%Q", zSql, zSep, pConfig->azCol[i]);  }  zSql = sqlite3Fts5Mprintf(&rc, "%z, %Q HIDDEN, %s HIDDEN)",  zSql, pConfig->zName, FTS5_RANK_NAME  );  assert( zSql || rc==SQLITE_NOMEM );  if( zSql ){  rc = sqlite3_declare_vtab(pConfig->db, zSql);  sqlite3_free(zSql);  }  return rc; } static int sqlite3Fts5Tokenize(  Fts5Config *pConfig,  int flags,  const char *pText, int nText,  void *pCtx,  int (*xToken)(void*, int, const char*, int, int, int) ){  if( pText==0 ) return SQLITE_OK;  return pConfig->pTokApi->xTokenize(  pConfig->pTok, pCtx, flags, pText, nText, xToken  ); } static const char *fts5ConfigSkipArgs(const char *pIn){  const char *p = pIn;  while( 1 ){  p = fts5ConfigSkipWhitespace(p);  p = fts5ConfigSkipLiteral(p);  p = fts5ConfigSkipWhitespace(p);  if( p==0 || *p==')' ) break;  if( *p!=',' ){  p = 0;  break;  }  p++;  }  return p; } static int sqlite3Fts5ConfigParseRank(  const char *zIn,  char **pzRank,  char **pzRankArgs ){  const char *p = zIn;  const char *pRank;  char *zRank = 0;  char *zRankArgs = 0;  int rc = SQLITE_OK;  *pzRank = 0;  *pzRankArgs = 0;  if( p==0 ){  rc = SQLITE_ERROR;  }else{  p = fts5ConfigSkipWhitespace(p);  pRank = p;  p = fts5ConfigSkipBareword(p);  if( p ){  zRank = sqlite3Fts5MallocZero(&rc, 1 + p - pRank);  if( zRank ) memcpy(zRank, pRank, p-pRank);  }else{  rc = SQLITE_ERROR;  }  if( rc==SQLITE_OK ){  p = fts5ConfigSkipWhitespace(p);  if( *p!='(' ) rc = SQLITE_ERROR;  p++;  }  if( rc==SQLITE_OK ){  const char *pArgs;  p = fts5ConfigSkipWhitespace(p);  pArgs = p;  if( *p!=')' ){  p = fts5ConfigSkipArgs(p);  if( p==0 ){  rc = SQLITE_ERROR;  }else{  zRankArgs = sqlite3Fts5MallocZero(&rc, 1 + p - pArgs);  if( zRankArgs ) memcpy(zRankArgs, pArgs, p-pArgs);  }  }  }  }  if( rc!=SQLITE_OK ){  sqlite3_free(zRank);  assert( zRankArgs==0 );  }else{  *pzRank = zRank;  *pzRankArgs = zRankArgs;  }  return rc; } static int sqlite3Fts5ConfigSetValue(  Fts5Config *pConfig,  const char *zKey,  sqlite3_value *pVal,  int *pbBadkey ){  int rc = SQLITE_OK;  if( 0==sqlite3_stricmp(zKey, "pgsz") ){  int pgsz = 0;  if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){  pgsz = sqlite3_value_int(pVal);  }  if( pgsz<32 || pgsz>FTS5_MAX_PAGE_SIZE ){  *pbBadkey = 1;  }else{  pConfig->pgsz = pgsz;  }  }  else if( 0==sqlite3_stricmp(zKey, "hashsize") ){  int nHashSize = -1;  if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){  nHashSize = sqlite3_value_int(pVal);  }  if( nHashSize<=0 ){  *pbBadkey = 1;  }else{  pConfig->nHashSize = nHashSize;  }  }  else if( 0==sqlite3_stricmp(zKey, "automerge") ){  int nAutomerge = -1;  if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){  nAutomerge = sqlite3_value_int(pVal);  }  if( nAutomerge<0 || nAutomerge>64 ){  *pbBadkey = 1;  }else{  if( nAutomerge==1 ) nAutomerge = FTS5_DEFAULT_AUTOMERGE;  pConfig->nAutomerge = nAutomerge;  }  }  else if( 0==sqlite3_stricmp(zKey, "usermerge") ){  int nUsermerge = -1;  if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){  nUsermerge = sqlite3_value_int(pVal);  }  if( nUsermerge<2 || nUsermerge>16 ){  *pbBadkey = 1;  }else{  pConfig->nUsermerge = nUsermerge;  }  }  else if( 0==sqlite3_stricmp(zKey, "crisismerge") ){  int nCrisisMerge = -1;  if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){  nCrisisMerge = sqlite3_value_int(pVal);  }  if( nCrisisMerge<0 ){  *pbBadkey = 1;  }else{  if( nCrisisMerge<=1 ) nCrisisMerge = FTS5_DEFAULT_CRISISMERGE;  if( nCrisisMerge>=FTS5_MAX_SEGMENT ) nCrisisMerge = FTS5_MAX_SEGMENT-1;  pConfig->nCrisisMerge = nCrisisMerge;  }  }  else if( 0==sqlite3_stricmp(zKey, "rank") ){  const char *zIn = (const char*)sqlite3_value_text(pVal);  char *zRank;  char *zRankArgs;  rc = sqlite3Fts5ConfigParseRank(zIn, &zRank, &zRankArgs);  if( rc==SQLITE_OK ){  sqlite3_free(pConfig->zRank);  sqlite3_free(pConfig->zRankArgs);  pConfig->zRank = zRank;  pConfig->zRankArgs = zRankArgs;  }else if( rc==SQLITE_ERROR ){  rc = SQLITE_OK;  *pbBadkey = 1;  }  }else{  *pbBadkey = 1;  }  return rc; } static int sqlite3Fts5ConfigLoad(Fts5Config *pConfig, int iCookie){  const char *zSelect = "SELECT k, v FROM %Q.'%q_config'";  char *zSql;  sqlite3_stmt *p = 0;  int rc = SQLITE_OK;  int iVersion = 0;  pConfig->pgsz = FTS5_DEFAULT_PAGE_SIZE;  pConfig->nAutomerge = FTS5_DEFAULT_AUTOMERGE;  pConfig->nUsermerge = FTS5_DEFAULT_USERMERGE;  pConfig->nCrisisMerge = FTS5_DEFAULT_CRISISMERGE;  pConfig->nHashSize = FTS5_DEFAULT_HASHSIZE;  zSql = sqlite3Fts5Mprintf(&rc, zSelect, pConfig->zDb, pConfig->zName);  if( zSql ){  rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &p, 0);  sqlite3_free(zSql);  }  assert( rc==SQLITE_OK || p==0 );  if( rc==SQLITE_OK ){  while( SQLITE_ROW==sqlite3_step(p) ){  const char *zK = (const char*)sqlite3_column_text(p, 0);  sqlite3_value *pVal = sqlite3_column_value(p, 1);  if( 0==sqlite3_stricmp(zK, "version") ){  iVersion = sqlite3_value_int(pVal);  }else{  int bDummy = 0;  sqlite3Fts5ConfigSetValue(pConfig, zK, pVal, &bDummy);  }  }  rc = sqlite3_finalize(p);  }  if( rc==SQLITE_OK && iVersion!=FTS5_CURRENT_VERSION ){  rc = SQLITE_ERROR;  if( pConfig->pzErrmsg ){  assert( 0==*pConfig->pzErrmsg );  *pConfig->pzErrmsg = sqlite3_mprintf(  "invalid fts5 file format (found %d, expected %d) - run 'rebuild'",  iVersion, FTS5_CURRENT_VERSION  );  }  }  if( rc==SQLITE_OK ){  pConfig->iCookie = iCookie;  }  return rc; }
#define FTS5_EOF 0
#define FTS5_LARGEST_INT64 (0xffffffff|(((i64)0x7fffffff)<<32))
typedef struct Fts5ExprTerm Fts5ExprTerm; static void *sqlite3Fts5ParserAlloc(void *(*mallocProc)(u64)); static void sqlite3Fts5ParserFree(void*, void (*freeProc)(void*)); static void sqlite3Fts5Parser(void*, int, Fts5Token, Fts5Parse*);
#ifndef NDEBUG
static void sqlite3Fts5ParserTrace(FILE*, char*);
#endif
static int sqlite3Fts5ParserFallback(int); struct Fts5Expr {  Fts5Index *pIndex;  Fts5Config *pConfig;  Fts5ExprNode *pRoot;  int bDesc;  int nPhrase;  Fts5ExprPhrase **apExprPhrase; }; struct Fts5ExprNode {  int eType;  int bEof;  int bNomatch;  int (*xNext)(Fts5Expr*, Fts5ExprNode*, int, i64);  i64 iRowid;  Fts5ExprNearset *pNear;  int nChild;  Fts5ExprNode *apChild[1]; };
#define Fts5NodeIsString(p) ((p)->eType==FTS5_TERM || (p)->eType==FTS5_STRING)
#define fts5ExprNodeNext(a,b,c,d) (b)->xNext((a), (b), (c), (d))
struct Fts5ExprTerm {  u8 bPrefix;  u8 bFirst;  char *zTerm;  Fts5IndexIter *pIter;  Fts5ExprTerm *pSynonym; }; struct Fts5ExprPhrase {  Fts5ExprNode *pNode;  Fts5Buffer poslist;  int nTerm;  Fts5ExprTerm aTerm[1]; }; struct Fts5ExprNearset {  int nNear;  Fts5Colset *pColset;  int nPhrase;  Fts5ExprPhrase *apPhrase[1]; }; struct Fts5Parse {  Fts5Config *pConfig;  char *zErr;  int rc;  int nPhrase;  Fts5ExprPhrase **apPhrase;  Fts5ExprNode *pExpr;  int bPhraseToAnd; }; static void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...){  va_list ap;  va_start(ap, zFmt);  if( pParse->rc==SQLITE_OK ){  assert( pParse->zErr==0 );  pParse->zErr = sqlite3_vmprintf(zFmt, ap);  pParse->rc = SQLITE_ERROR;  }  va_end(ap); } static int fts5ExprIsspace(char t){  return t==' ' || t=='\t' || t=='\n' || t=='\r'; } static int fts5ExprGetToken(  Fts5Parse *pParse,  const char **pz,  Fts5Token *pToken ){  const char *z = *pz;  int tok;  while( fts5ExprIsspace(*z) ) z++;  pToken->p = z;  pToken->n = 1;  switch( *z ){  case '(': tok = FTS5_LP; break;  case ')': tok = FTS5_RP; break;  case '{': tok = FTS5_LCP;  break;  case '}': tok = FTS5_RCP;  break;  case ':': tok = FTS5_COLON; break;  case ',': tok = FTS5_COMMA; break;  case '+': tok = FTS5_PLUS; break;  case '*': tok = FTS5_STAR; break;  case '-': tok = FTS5_MINUS; break;  case '^': tok = FTS5_CARET; break;  case '\0': tok = FTS5_EOF;  break;  case '"': {  const char *z2;  tok = FTS5_STRING;  for(z2=&z[1]; 1; z2++){  if( z2[0]=='"' ){  z2++;  if( z2[0]!='"' ) break;  }  if( z2[0]=='\0' ){  sqlite3Fts5ParseError(pParse, "unterminated string");  return FTS5_EOF;  }  }  pToken->n = (z2 - z);  break;  }  default: {  const char *z2;  if( sqlite3Fts5IsBareword(z[0])==0 ){  sqlite3Fts5ParseError(pParse, "fts5: syntax error near \"%.1s\"", z);  return FTS5_EOF;  }  tok = FTS5_STRING;  for(z2=&z[1]; sqlite3Fts5IsBareword(*z2); z2++);  pToken->n = (z2 - z);  if( pToken->n==2 && memcmp(pToken->p, "OR", 2)==0 ) tok = FTS5_OR;  if( pToken->n==3 && memcmp(pToken->p, "NOT", 3)==0 ) tok = FTS5_NOT;  if( pToken->n==3 && memcmp(pToken->p, "AND", 3)==0 ) tok = FTS5_AND;  break;  }  }  *pz = &pToken->p[pToken->n];  return tok; } static void *fts5ParseAlloc(u64 t){ return sqlite3_malloc64((sqlite3_int64)t);} static void fts5ParseFree(void *p){ sqlite3_free(p); } static int sqlite3Fts5ExprNew(  Fts5Config *pConfig,  int bPhraseToAnd,  int iCol,  const char *zExpr,  Fts5Expr **ppNew,  char **pzErr ){  Fts5Parse sParse;  Fts5Token token;  const char *z = zExpr;  int t;  void *pEngine;  Fts5Expr *pNew;  *ppNew = 0;  *pzErr = 0;  memset(&sParse, 0, sizeof(sParse));  sParse.bPhraseToAnd = bPhraseToAnd;  pEngine = sqlite3Fts5ParserAlloc(fts5ParseAlloc);  if( pEngine==0 ){ return SQLITE_NOMEM; }  sParse.pConfig = pConfig;  do {  t = fts5ExprGetToken(&sParse, &z, &token);  sqlite3Fts5Parser(pEngine, t, token, &sParse);  }while( sParse.rc==SQLITE_OK && t!=FTS5_EOF );  sqlite3Fts5ParserFree(pEngine, fts5ParseFree);  if( iCol<pConfig->nCol && sParse.pExpr && sParse.rc==SQLITE_OK ){  int n = sizeof(Fts5Colset);  Fts5Colset *pColset = (Fts5Colset*)sqlite3Fts5MallocZero(&sParse.rc, n);  if( pColset ){  pColset->nCol = 1;  pColset->aiCol[0] = iCol;  sqlite3Fts5ParseSetColset(&sParse, sParse.pExpr, pColset);  }  }  assert( sParse.rc!=SQLITE_OK || sParse.zErr==0 );  if( sParse.rc==SQLITE_OK ){  *ppNew = pNew = sqlite3_malloc(sizeof(Fts5Expr));  if( pNew==0 ){  sParse.rc = SQLITE_NOMEM;  sqlite3Fts5ParseNodeFree(sParse.pExpr);  }else{  if( !sParse.pExpr ){  const int nByte = sizeof(Fts5ExprNode);  pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&sParse.rc, nByte);  if( pNew->pRoot ){  pNew->pRoot->bEof = 1;  }  }else{  pNew->pRoot = sParse.pExpr;  }  pNew->pIndex = 0;  pNew->pConfig = pConfig;  pNew->apExprPhrase = sParse.apPhrase;  pNew->nPhrase = sParse.nPhrase;  pNew->bDesc = 0;  sParse.apPhrase = 0;  }  }else{  sqlite3Fts5ParseNodeFree(sParse.pExpr);  }  sqlite3_free(sParse.apPhrase);  *pzErr = sParse.zErr;  return sParse.rc; } static int sqlite3Fts5ExprPattern(  Fts5Config *pConfig, int bGlob, int iCol, const char *zText, Fts5Expr **pp ){  i64 nText = strlen(zText);  char *zExpr = (char*)sqlite3_malloc64(nText*4 + 1);  int rc = SQLITE_OK;  if( zExpr==0 ){  rc = SQLITE_NOMEM;  }else{  char aSpec[3];  int iOut = 0;  int i = 0;  int iFirst = 0;  if( bGlob==0 ){  aSpec[0] = '_';  aSpec[1] = '%';  aSpec[2] = 0;  }else{  aSpec[0] = '*';  aSpec[1] = '?';  aSpec[2] = '[';  }  while( i<=nText ){  if( i==nText   || zText[i]==aSpec[0] || zText[i]==aSpec[1] || zText[i]==aSpec[2]  ){  if( i-iFirst>=3 ){  int jj;  zExpr[iOut++] = '"';  for(jj=iFirst; jj<i; jj++){  zExpr[iOut++] = zText[jj];  if( zText[jj]=='"' ) zExpr[iOut++] = '"';  }  zExpr[iOut++] = '"';  zExpr[iOut++] = ' ';  }  if( zText[i]==aSpec[2] ){  i += 2;  if( zText[i-1]=='^' ) i++;  while( i<nText && zText[i]!=']' ) i++;  }  iFirst = i+1;  }  i++;  }  if( iOut>0 ){  int bAnd = 0;  if( pConfig->eDetail!=FTS5_DETAIL_FULL ){  bAnd = 1;  if( pConfig->eDetail==FTS5_DETAIL_NONE ){  iCol = pConfig->nCol;  }  }  zExpr[iOut] = '\0';  rc = sqlite3Fts5ExprNew(pConfig, bAnd, iCol, zExpr, pp,pConfig->pzErrmsg);  }else{  *pp = 0;  }  sqlite3_free(zExpr);  }  return rc; } static void sqlite3Fts5ParseNodeFree(Fts5ExprNode *p){  if( p ){  int i;  for(i=0; i<p->nChild; i++){  sqlite3Fts5ParseNodeFree(p->apChild[i]);  }  sqlite3Fts5ParseNearsetFree(p->pNear);  sqlite3_free(p);  } } static void sqlite3Fts5ExprFree(Fts5Expr *p){  if( p ){  sqlite3Fts5ParseNodeFree(p->pRoot);  sqlite3_free(p->apExprPhrase);  sqlite3_free(p);  } } static int sqlite3Fts5ExprAnd(Fts5Expr **pp1, Fts5Expr *p2){  Fts5Parse sParse;  memset(&sParse, 0, sizeof(sParse));  if( *pp1 ){  Fts5Expr *p1 = *pp1;  int nPhrase = p1->nPhrase + p2->nPhrase;  p1->pRoot = sqlite3Fts5ParseNode(&sParse, FTS5_AND, p1->pRoot, p2->pRoot,0);  p2->pRoot = 0;  if( sParse.rc==SQLITE_OK ){  Fts5ExprPhrase **ap = (Fts5ExprPhrase**)sqlite3_realloc(  p1->apExprPhrase, nPhrase * sizeof(Fts5ExprPhrase*)  );  if( ap==0 ){  sParse.rc = SQLITE_NOMEM;  }else{  int i;  memmove(&ap[p2->nPhrase], ap, p1->nPhrase*sizeof(Fts5ExprPhrase*));  for(i=0; i<p2->nPhrase; i++){  ap[i] = p2->apExprPhrase[i];  }  p1->nPhrase = nPhrase;  p1->apExprPhrase = ap;  }  }  sqlite3_free(p2->apExprPhrase);  sqlite3_free(p2);  }else{  *pp1 = p2;  }  return sParse.rc; } static i64 fts5ExprSynonymRowid(Fts5ExprTerm *pTerm, int bDesc, int *pbEof){  i64 iRet = 0;  int bRetValid = 0;  Fts5ExprTerm *p;  assert( pTerm );  assert( pTerm->pSynonym );  assert( bDesc==0 || bDesc==1 );  for(p=pTerm; p; p=p->pSynonym){  if( 0==sqlite3Fts5IterEof(p->pIter) ){  i64 iRowid = p->pIter->iRowid;  if( bRetValid==0 || (bDesc!=(iRowid<iRet)) ){  iRet = iRowid;  bRetValid = 1;  }  }  }  if( pbEof && bRetValid==0 ) *pbEof = 1;  return iRet; } static int fts5ExprSynonymList(  Fts5ExprTerm *pTerm,  i64 iRowid,  Fts5Buffer *pBuf,  u8 **pa, int *pn ){  Fts5PoslistReader aStatic[4];  Fts5PoslistReader *aIter = aStatic;  int nIter = 0;  int nAlloc = 4;  int rc = SQLITE_OK;  Fts5ExprTerm *p;  assert( pTerm->pSynonym );  for(p=pTerm; p; p=p->pSynonym){  Fts5IndexIter *pIter = p->pIter;  if( sqlite3Fts5IterEof(pIter)==0 && pIter->iRowid==iRowid ){  if( pIter->nData==0 ) continue;  if( nIter==nAlloc ){  sqlite3_int64 nByte = sizeof(Fts5PoslistReader) * nAlloc * 2;  Fts5PoslistReader *aNew = (Fts5PoslistReader*)sqlite3_malloc64(nByte);  if( aNew==0 ){  rc = SQLITE_NOMEM;  goto synonym_poslist_out;  }  memcpy(aNew, aIter, sizeof(Fts5PoslistReader) * nIter);  nAlloc = nAlloc*2;  if( aIter!=aStatic ) sqlite3_free(aIter);  aIter = aNew;  }  sqlite3Fts5PoslistReaderInit(pIter->pData, pIter->nData, &aIter[nIter]);  assert( aIter[nIter].bEof==0 );  nIter++;  }  }  if( nIter==1 ){  *pa = (u8*)aIter[0].a;  *pn = aIter[0].n;  }else{  Fts5PoslistWriter writer = {0};  i64 iPrev = -1;  fts5BufferZero(pBuf);  while( 1 ){  int i;  i64 iMin = FTS5_LARGEST_INT64;  for(i=0; i<nIter; i++){  if( aIter[i].bEof==0 ){  if( aIter[i].iPos==iPrev ){  if( sqlite3Fts5PoslistReaderNext(&aIter[i]) ) continue;  }  if( aIter[i].iPos<iMin ){  iMin = aIter[i].iPos;  }  }  }  if( iMin==FTS5_LARGEST_INT64 || rc!=SQLITE_OK ) break;  rc = sqlite3Fts5PoslistWriterAppend(pBuf, &writer, iMin);  iPrev = iMin;  }  if( rc==SQLITE_OK ){  *pa = pBuf->p;  *pn = pBuf->n;  }  }  synonym_poslist_out:  if( aIter!=aStatic ) sqlite3_free(aIter);  return rc; } static int fts5ExprPhraseIsMatch(  Fts5ExprNode *pNode,  Fts5ExprPhrase *pPhrase,  int *pbMatch ){  Fts5PoslistWriter writer = {0};  Fts5PoslistReader aStatic[4];  Fts5PoslistReader *aIter = aStatic;  int i;  int rc = SQLITE_OK;  int bFirst = pPhrase->aTerm[0].bFirst;  fts5BufferZero(&pPhrase->poslist);  if( pPhrase->nTerm>ArraySize(aStatic) ){  sqlite3_int64 nByte = sizeof(Fts5PoslistReader) * pPhrase->nTerm;  aIter = (Fts5PoslistReader*)sqlite3_malloc64(nByte);  if( !aIter ) return SQLITE_NOMEM;  }  memset(aIter, 0, sizeof(Fts5PoslistReader) * pPhrase->nTerm);  for(i=0; i<pPhrase->nTerm; i++){  Fts5ExprTerm *pTerm = &pPhrase->aTerm[i];  int n = 0;  int bFlag = 0;  u8 *a = 0;  if( pTerm->pSynonym ){  Fts5Buffer buf = {0, 0, 0};  rc = fts5ExprSynonymList(pTerm, pNode->iRowid, &buf, &a, &n);  if( rc ){  sqlite3_free(a);  goto ismatch_out;  }  if( a==buf.p ) bFlag = 1;  }else{  a = (u8*)pTerm->pIter->pData;  n = pTerm->pIter->nData;  }  sqlite3Fts5PoslistReaderInit(a, n, &aIter[i]);  aIter[i].bFlag = (u8)bFlag;  if( aIter[i].bEof ) goto ismatch_out;  }  while( 1 ){  int bMatch;  i64 iPos = aIter[0].iPos;  do {  bMatch = 1;  for(i=0; i<pPhrase->nTerm; i++){  Fts5PoslistReader *pPos = &aIter[i];  i64 iAdj = iPos + i;  if( pPos->iPos!=iAdj ){  bMatch = 0;  while( pPos->iPos<iAdj ){  if( sqlite3Fts5PoslistReaderNext(pPos) ) goto ismatch_out;  }  if( pPos->iPos>iAdj ) iPos = pPos->iPos-i;  }  }  }while( bMatch==0 );  if( bFirst==0 || FTS5_POS2OFFSET(iPos)==0 ){  rc = sqlite3Fts5PoslistWriterAppend(&pPhrase->poslist, &writer, iPos);  if( rc!=SQLITE_OK ) goto ismatch_out;  }  for(i=0; i<pPhrase->nTerm; i++){  if( sqlite3Fts5PoslistReaderNext(&aIter[i]) ) goto ismatch_out;  }  }  ismatch_out:  *pbMatch = (pPhrase->poslist.n>0);  for(i=0; i<pPhrase->nTerm; i++){  if( aIter[i].bFlag ) sqlite3_free((u8*)aIter[i].a);  }  if( aIter!=aStatic ) sqlite3_free(aIter);  return rc; } typedef struct Fts5LookaheadReader Fts5LookaheadReader; struct Fts5LookaheadReader {  const u8 *a;  int n;  int i;  i64 iPos;  i64 iLookahead; };
#define FTS5_LOOKAHEAD_EOF (((i64)1) << 62)
static int fts5LookaheadReaderNext(Fts5LookaheadReader *p){  p->iPos = p->iLookahead;  if( sqlite3Fts5PoslistNext64(p->a, p->n, &p->i, &p->iLookahead) ){  p->iLookahead = FTS5_LOOKAHEAD_EOF;  }  return (p->iPos==FTS5_LOOKAHEAD_EOF); } static int fts5LookaheadReaderInit(  const u8 *a, int n,  Fts5LookaheadReader *p ){  memset(p, 0, sizeof(Fts5LookaheadReader));  p->a = a;  p->n = n;  fts5LookaheadReaderNext(p);  return fts5LookaheadReaderNext(p); } typedef struct Fts5NearTrimmer Fts5NearTrimmer; struct Fts5NearTrimmer {  Fts5LookaheadReader reader;  Fts5PoslistWriter writer;  Fts5Buffer *pOut; }; static int fts5ExprNearIsMatch(int *pRc, Fts5ExprNearset *pNear){  Fts5NearTrimmer aStatic[4];  Fts5NearTrimmer *a = aStatic;  Fts5ExprPhrase **apPhrase = pNear->apPhrase;  int i;  int rc = *pRc;  int bMatch;  assert( pNear->nPhrase>1 );  if( pNear->nPhrase>ArraySize(aStatic) ){  sqlite3_int64 nByte = sizeof(Fts5NearTrimmer) * pNear->nPhrase;  a = (Fts5NearTrimmer*)sqlite3Fts5MallocZero(&rc, nByte);  }else{  memset(aStatic, 0, sizeof(aStatic));  }  if( rc!=SQLITE_OK ){  *pRc = rc;  return 0;  }  for(i=0; i<pNear->nPhrase; i++){  Fts5Buffer *pPoslist = &apPhrase[i]->poslist;  fts5LookaheadReaderInit(pPoslist->p, pPoslist->n, &a[i].reader);  pPoslist->n = 0;  a[i].pOut = pPoslist;  }  while( 1 ){  int iAdv;  i64 iMin;  i64 iMax;  iMax = a[0].reader.iPos;  do {  bMatch = 1;  for(i=0; i<pNear->nPhrase; i++){  Fts5LookaheadReader *pPos = &a[i].reader;  iMin = iMax - pNear->apPhrase[i]->nTerm - pNear->nNear;  if( pPos->iPos<iMin || pPos->iPos>iMax ){  bMatch = 0;  while( pPos->iPos<iMin ){  if( fts5LookaheadReaderNext(pPos) ) goto ismatch_out;  }  if( pPos->iPos>iMax ) iMax = pPos->iPos;  }  }  }while( bMatch==0 );  for(i=0; i<pNear->nPhrase; i++){  i64 iPos = a[i].reader.iPos;  Fts5PoslistWriter *pWriter = &a[i].writer;  if( a[i].pOut->n==0 || iPos!=pWriter->iPrev ){  sqlite3Fts5PoslistWriterAppend(a[i].pOut, pWriter, iPos);  }  }  iAdv = 0;  iMin = a[0].reader.iLookahead;  for(i=0; i<pNear->nPhrase; i++){  if( a[i].reader.iLookahead < iMin ){  iMin = a[i].reader.iLookahead;  iAdv = i;  }  }  if( fts5LookaheadReaderNext(&a[iAdv].reader) ) goto ismatch_out;  }  ismatch_out: {  int bRet = a[0].pOut->n>0;  *pRc = rc;  if( a!=aStatic ) sqlite3_free(a);  return bRet;  } } static int fts5ExprAdvanceto(  Fts5IndexIter *pIter,  int bDesc,  i64 *piLast,  int *pRc,  int *pbEof ){  i64 iLast = *piLast;  i64 iRowid;  iRowid = pIter->iRowid;  if( (bDesc==0 && iLast>iRowid) || (bDesc && iLast<iRowid) ){  int rc = sqlite3Fts5IterNextFrom(pIter, iLast);  if( rc || sqlite3Fts5IterEof(pIter) ){  *pRc = rc;  *pbEof = 1;  return 1;  }  iRowid = pIter->iRowid;  assert( (bDesc==0 && iRowid>=iLast) || (bDesc==1 && iRowid<=iLast) );  }  *piLast = iRowid;  return 0; } static int fts5ExprSynonymAdvanceto(  Fts5ExprTerm *pTerm,  int bDesc,  i64 *piLast,  int *pRc ){  int rc = SQLITE_OK;  i64 iLast = *piLast;  Fts5ExprTerm *p;  int bEof = 0;  for(p=pTerm; rc==SQLITE_OK && p; p=p->pSynonym){  if( sqlite3Fts5IterEof(p->pIter)==0 ){  i64 iRowid = p->pIter->iRowid;  if( (bDesc==0 && iLast>iRowid) || (bDesc && iLast<iRowid) ){  rc = sqlite3Fts5IterNextFrom(p->pIter, iLast);  }  }  }  if( rc!=SQLITE_OK ){  *pRc = rc;  bEof = 1;  }else{  *piLast = fts5ExprSynonymRowid(pTerm, bDesc, &bEof);  }  return bEof; } static int fts5ExprNearTest(  int *pRc,  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  Fts5ExprNearset *pNear = pNode->pNear;  int rc = *pRc;  if( pExpr->pConfig->eDetail!=FTS5_DETAIL_FULL ){  Fts5ExprTerm *pTerm;  Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];  pPhrase->poslist.n = 0;  for(pTerm=&pPhrase->aTerm[0]; pTerm; pTerm=pTerm->pSynonym){  Fts5IndexIter *pIter = pTerm->pIter;  if( sqlite3Fts5IterEof(pIter)==0 ){  if( pIter->iRowid==pNode->iRowid && pIter->nData>0 ){  pPhrase->poslist.n = 1;  }  }  }  return pPhrase->poslist.n;  }else{  int i;  for(i=0; rc==SQLITE_OK && i<pNear->nPhrase; i++){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];  if( pPhrase->nTerm>1 || pPhrase->aTerm[0].pSynonym   || pNear->pColset || pPhrase->aTerm[0].bFirst  ){  int bMatch = 0;  rc = fts5ExprPhraseIsMatch(pNode, pPhrase, &bMatch);  if( bMatch==0 ) break;  }else{  Fts5IndexIter *pIter = pPhrase->aTerm[0].pIter;  fts5BufferSet(&rc, &pPhrase->poslist, pIter->nData, pIter->pData);  }  }  *pRc = rc;  if( i==pNear->nPhrase && (i==1 || fts5ExprNearIsMatch(pRc, pNear)) ){  return 1;  }  return 0;  } } static int fts5ExprNearInitAll(  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  Fts5ExprNearset *pNear = pNode->pNear;  int i;  assert( pNode->bNomatch==0 );  for(i=0; i<pNear->nPhrase; i++){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];  if( pPhrase->nTerm==0 ){  pNode->bEof = 1;  return SQLITE_OK;  }else{  int j;  for(j=0; j<pPhrase->nTerm; j++){  Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];  Fts5ExprTerm *p;  int bHit = 0;  for(p=pTerm; p; p=p->pSynonym){  int rc;  if( p->pIter ){  sqlite3Fts5IterClose(p->pIter);  p->pIter = 0;  }  rc = sqlite3Fts5IndexQuery(  pExpr->pIndex, p->zTerm, (int)strlen(p->zTerm),  (pTerm->bPrefix ? FTS5INDEX_QUERY_PREFIX : 0) |  (pExpr->bDesc ? FTS5INDEX_QUERY_DESC : 0),  pNear->pColset,  &p->pIter  );  assert( (rc==SQLITE_OK)==(p->pIter!=0) );  if( rc!=SQLITE_OK ) return rc;  if( 0==sqlite3Fts5IterEof(p->pIter) ){  bHit = 1;  }  }  if( bHit==0 ){  pNode->bEof = 1;  return SQLITE_OK;  }  }  }  }  pNode->bEof = 0;  return SQLITE_OK; } static int fts5RowidCmp(  Fts5Expr *pExpr,  i64 iLhs,  i64 iRhs ){  assert( pExpr->bDesc==0 || pExpr->bDesc==1 );  if( pExpr->bDesc==0 ){  if( iLhs<iRhs ) return -1;  return (iLhs > iRhs);  }else{  if( iLhs>iRhs ) return -1;  return (iLhs < iRhs);  } } static void fts5ExprSetEof(Fts5ExprNode *pNode){  int i;  pNode->bEof = 1;  pNode->bNomatch = 0;  for(i=0; i<pNode->nChild; i++){  fts5ExprSetEof(pNode->apChild[i]);  } } static void fts5ExprNodeZeroPoslist(Fts5ExprNode *pNode){  if( pNode->eType==FTS5_STRING || pNode->eType==FTS5_TERM ){  Fts5ExprNearset *pNear = pNode->pNear;  int i;  for(i=0; i<pNear->nPhrase; i++){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];  pPhrase->poslist.n = 0;  }  }else{  int i;  for(i=0; i<pNode->nChild; i++){  fts5ExprNodeZeroPoslist(pNode->apChild[i]);  }  } } static int fts5NodeCompare(  Fts5Expr *pExpr,  Fts5ExprNode *p1,  Fts5ExprNode *p2 ){  if( p2->bEof ) return -1;  if( p1->bEof ) return +1;  return fts5RowidCmp(pExpr, p1->iRowid, p2->iRowid); } static int fts5ExprNodeTest_STRING(  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  Fts5ExprNearset *pNear = pNode->pNear;  Fts5ExprPhrase *pLeft = pNear->apPhrase[0];  int rc = SQLITE_OK;  i64 iLast;  int i, j;  int bMatch;  const int bDesc = pExpr->bDesc;  assert( pNear->nPhrase>1   || pNear->apPhrase[0]->nTerm>1   || pNear->apPhrase[0]->aTerm[0].pSynonym   || pNear->apPhrase[0]->aTerm[0].bFirst  );  if( pLeft->aTerm[0].pSynonym ){  iLast = fts5ExprSynonymRowid(&pLeft->aTerm[0], bDesc, 0);  }else{  iLast = pLeft->aTerm[0].pIter->iRowid;  }  do {  bMatch = 1;  for(i=0; i<pNear->nPhrase; i++){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];  for(j=0; j<pPhrase->nTerm; j++){  Fts5ExprTerm *pTerm = &pPhrase->aTerm[j];  if( pTerm->pSynonym ){  i64 iRowid = fts5ExprSynonymRowid(pTerm, bDesc, 0);  if( iRowid==iLast ) continue;  bMatch = 0;  if( fts5ExprSynonymAdvanceto(pTerm, bDesc, &iLast, &rc) ){  pNode->bNomatch = 0;  pNode->bEof = 1;  return rc;  }  }else{  Fts5IndexIter *pIter = pPhrase->aTerm[j].pIter;  if( pIter->iRowid==iLast || pIter->bEof ) continue;  bMatch = 0;  if( fts5ExprAdvanceto(pIter, bDesc, &iLast, &rc, &pNode->bEof) ){  return rc;  }  }  }  }  }while( bMatch==0 );  pNode->iRowid = iLast;  pNode->bNomatch = ((0==fts5ExprNearTest(&rc, pExpr, pNode)) && rc==SQLITE_OK);  assert( pNode->bEof==0 || pNode->bNomatch==0 );  return rc; } static int fts5ExprNodeNext_STRING(  Fts5Expr *pExpr,  Fts5ExprNode *pNode,  int bFromValid,  i64 iFrom ){  Fts5ExprTerm *pTerm = &pNode->pNear->apPhrase[0]->aTerm[0];  int rc = SQLITE_OK;  pNode->bNomatch = 0;  if( pTerm->pSynonym ){  int bEof = 1;  Fts5ExprTerm *p;  i64 iRowid = fts5ExprSynonymRowid(pTerm, pExpr->bDesc, 0);  for(p=pTerm; p; p=p->pSynonym){  if( sqlite3Fts5IterEof(p->pIter)==0 ){  i64 ii = p->pIter->iRowid;  if( ii==iRowid   || (bFromValid && ii!=iFrom && (ii>iFrom)==pExpr->bDesc)  ){  if( bFromValid ){  rc = sqlite3Fts5IterNextFrom(p->pIter, iFrom);  }else{  rc = sqlite3Fts5IterNext(p->pIter);  }  if( rc!=SQLITE_OK ) break;  if( sqlite3Fts5IterEof(p->pIter)==0 ){  bEof = 0;  }  }else{  bEof = 0;  }  }  }  pNode->bEof = (rc || bEof);  }else{  Fts5IndexIter *pIter = pTerm->pIter;  assert( Fts5NodeIsString(pNode) );  if( bFromValid ){  rc = sqlite3Fts5IterNextFrom(pIter, iFrom);  }else{  rc = sqlite3Fts5IterNext(pIter);  }  pNode->bEof = (rc || sqlite3Fts5IterEof(pIter));  }  if( pNode->bEof==0 ){  assert( rc==SQLITE_OK );  rc = fts5ExprNodeTest_STRING(pExpr, pNode);  }  return rc; } static int fts5ExprNodeTest_TERM(  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  Fts5ExprPhrase *pPhrase = pNode->pNear->apPhrase[0];  Fts5IndexIter *pIter = pPhrase->aTerm[0].pIter;  assert( pNode->eType==FTS5_TERM );  assert( pNode->pNear->nPhrase==1 && pPhrase->nTerm==1 );  assert( pPhrase->aTerm[0].pSynonym==0 );  pPhrase->poslist.n = pIter->nData;  if( pExpr->pConfig->eDetail==FTS5_DETAIL_FULL ){  pPhrase->poslist.p = (u8*)pIter->pData;  }  pNode->iRowid = pIter->iRowid;  pNode->bNomatch = (pPhrase->poslist.n==0);  return SQLITE_OK; } static int fts5ExprNodeNext_TERM(  Fts5Expr *pExpr,  Fts5ExprNode *pNode,  int bFromValid,  i64 iFrom ){  int rc;  Fts5IndexIter *pIter = pNode->pNear->apPhrase[0]->aTerm[0].pIter;  assert( pNode->bEof==0 );  if( bFromValid ){  rc = sqlite3Fts5IterNextFrom(pIter, iFrom);  }else{  rc = sqlite3Fts5IterNext(pIter);  }  if( rc==SQLITE_OK && sqlite3Fts5IterEof(pIter)==0 ){  rc = fts5ExprNodeTest_TERM(pExpr, pNode);  }else{  pNode->bEof = 1;  pNode->bNomatch = 0;  }  return rc; } static void fts5ExprNodeTest_OR(  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  Fts5ExprNode *pNext = pNode->apChild[0];  int i;  for(i=1; i<pNode->nChild; i++){  Fts5ExprNode *pChild = pNode->apChild[i];  int cmp = fts5NodeCompare(pExpr, pNext, pChild);  if( cmp>0 || (cmp==0 && pChild->bNomatch==0) ){  pNext = pChild;  }  }  pNode->iRowid = pNext->iRowid;  pNode->bEof = pNext->bEof;  pNode->bNomatch = pNext->bNomatch; } static int fts5ExprNodeNext_OR(  Fts5Expr *pExpr,  Fts5ExprNode *pNode,  int bFromValid,  i64 iFrom ){  int i;  i64 iLast = pNode->iRowid;  for(i=0; i<pNode->nChild; i++){  Fts5ExprNode *p1 = pNode->apChild[i];  assert( p1->bEof || fts5RowidCmp(pExpr, p1->iRowid, iLast)>=0 );  if( p1->bEof==0 ){  if( (p1->iRowid==iLast)   || (bFromValid && fts5RowidCmp(pExpr, p1->iRowid, iFrom)<0)  ){  int rc = fts5ExprNodeNext(pExpr, p1, bFromValid, iFrom);  if( rc!=SQLITE_OK ){  pNode->bNomatch = 0;  return rc;  }  }  }  }  fts5ExprNodeTest_OR(pExpr, pNode);  return SQLITE_OK; } static int fts5ExprNodeTest_AND(  Fts5Expr *pExpr,  Fts5ExprNode *pAnd ){  int iChild;  i64 iLast = pAnd->iRowid;  int rc = SQLITE_OK;  int bMatch;  assert( pAnd->bEof==0 );  do {  pAnd->bNomatch = 0;  bMatch = 1;  for(iChild=0; iChild<pAnd->nChild; iChild++){  Fts5ExprNode *pChild = pAnd->apChild[iChild];  int cmp = fts5RowidCmp(pExpr, iLast, pChild->iRowid);  if( cmp>0 ){  rc = fts5ExprNodeNext(pExpr, pChild, 1, iLast);  if( rc!=SQLITE_OK ){  pAnd->bNomatch = 0;  return rc;  }  }  assert( pChild->bEof || fts5RowidCmp(pExpr, iLast, pChild->iRowid)<=0 );  if( pChild->bEof ){  fts5ExprSetEof(pAnd);  bMatch = 1;  break;  }else if( iLast!=pChild->iRowid ){  bMatch = 0;  iLast = pChild->iRowid;  }  if( pChild->bNomatch ){  pAnd->bNomatch = 1;  }  }  }while( bMatch==0 );  if( pAnd->bNomatch && pAnd!=pExpr->pRoot ){  fts5ExprNodeZeroPoslist(pAnd);  }  pAnd->iRowid = iLast;  return SQLITE_OK; } static int fts5ExprNodeNext_AND(  Fts5Expr *pExpr,  Fts5ExprNode *pNode,  int bFromValid,  i64 iFrom ){  int rc = fts5ExprNodeNext(pExpr, pNode->apChild[0], bFromValid, iFrom);  if( rc==SQLITE_OK ){  rc = fts5ExprNodeTest_AND(pExpr, pNode);  }else{  pNode->bNomatch = 0;  }  return rc; } static int fts5ExprNodeTest_NOT(  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  int rc = SQLITE_OK;  Fts5ExprNode *p1 = pNode->apChild[0];  Fts5ExprNode *p2 = pNode->apChild[1];  assert( pNode->nChild==2 );  while( rc==SQLITE_OK && p1->bEof==0 ){  int cmp = fts5NodeCompare(pExpr, p1, p2);  if( cmp>0 ){  rc = fts5ExprNodeNext(pExpr, p2, 1, p1->iRowid);  cmp = fts5NodeCompare(pExpr, p1, p2);  }  assert( rc!=SQLITE_OK || cmp<=0 );  if( cmp || p2->bNomatch ) break;  rc = fts5ExprNodeNext(pExpr, p1, 0, 0);  }  pNode->bEof = p1->bEof;  pNode->bNomatch = p1->bNomatch;  pNode->iRowid = p1->iRowid;  if( p1->bEof ){  fts5ExprNodeZeroPoslist(p2);  }  return rc; } static int fts5ExprNodeNext_NOT(  Fts5Expr *pExpr,  Fts5ExprNode *pNode,  int bFromValid,  i64 iFrom ){  int rc = fts5ExprNodeNext(pExpr, pNode->apChild[0], bFromValid, iFrom);  if( rc==SQLITE_OK ){  rc = fts5ExprNodeTest_NOT(pExpr, pNode);  }  if( rc!=SQLITE_OK ){  pNode->bNomatch = 0;  }  return rc; } static int fts5ExprNodeTest(  Fts5Expr *pExpr,  Fts5ExprNode *pNode ){  int rc = SQLITE_OK;  if( pNode->bEof==0 ){  switch( pNode->eType ){  case FTS5_STRING: {  rc = fts5ExprNodeTest_STRING(pExpr, pNode);  break;  }  case FTS5_TERM: {  rc = fts5ExprNodeTest_TERM(pExpr, pNode);  break;  }  case FTS5_AND: {  rc = fts5ExprNodeTest_AND(pExpr, pNode);  break;  }  case FTS5_OR: {  fts5ExprNodeTest_OR(pExpr, pNode);  break;  }  default: assert( pNode->eType==FTS5_NOT ); {  rc = fts5ExprNodeTest_NOT(pExpr, pNode);  break;  }  }  }  return rc; } static int fts5ExprNodeFirst(Fts5Expr *pExpr, Fts5ExprNode *pNode){  int rc = SQLITE_OK;  pNode->bEof = 0;  pNode->bNomatch = 0;  if( Fts5NodeIsString(pNode) ){  rc = fts5ExprNearInitAll(pExpr, pNode);  }else if( pNode->xNext==0 ){  pNode->bEof = 1;  }else{  int i;  int nEof = 0;  for(i=0; i<pNode->nChild && rc==SQLITE_OK; i++){  Fts5ExprNode *pChild = pNode->apChild[i];  rc = fts5ExprNodeFirst(pExpr, pNode->apChild[i]);  assert( pChild->bEof==0 || pChild->bEof==1 );  nEof += pChild->bEof;  }  pNode->iRowid = pNode->apChild[0]->iRowid;  switch( pNode->eType ){  case FTS5_AND:  if( nEof>0 ) fts5ExprSetEof(pNode);  break;  case FTS5_OR:  if( pNode->nChild==nEof ) fts5ExprSetEof(pNode);  break;  default:  assert( pNode->eType==FTS5_NOT );  pNode->bEof = pNode->apChild[0]->bEof;  break;  }  }  if( rc==SQLITE_OK ){  rc = fts5ExprNodeTest(pExpr, pNode);  }  return rc; } static int sqlite3Fts5ExprFirst(Fts5Expr *p, Fts5Index *pIdx, i64 iFirst, int bDesc){  Fts5ExprNode *pRoot = p->pRoot;  int rc;  p->pIndex = pIdx;  p->bDesc = bDesc;  rc = fts5ExprNodeFirst(p, pRoot);  if( rc==SQLITE_OK   && 0==pRoot->bEof   && fts5RowidCmp(p, pRoot->iRowid, iFirst)<0  ){  rc = fts5ExprNodeNext(p, pRoot, 1, iFirst);  }  while( pRoot->bNomatch && rc==SQLITE_OK ){  assert( pRoot->bEof==0 );  rc = fts5ExprNodeNext(p, pRoot, 0, 0);  }  return rc; } static int sqlite3Fts5ExprNext(Fts5Expr *p, i64 iLast){  int rc;  Fts5ExprNode *pRoot = p->pRoot;  assert( pRoot->bEof==0 && pRoot->bNomatch==0 );  do {  rc = fts5ExprNodeNext(p, pRoot, 0, 0);  assert( pRoot->bNomatch==0 || (rc==SQLITE_OK && pRoot->bEof==0) );  }while( pRoot->bNomatch );  if( fts5RowidCmp(p, pRoot->iRowid, iLast)>0 ){  pRoot->bEof = 1;  }  return rc; } static int sqlite3Fts5ExprEof(Fts5Expr *p){  return p->pRoot->bEof; } static i64 sqlite3Fts5ExprRowid(Fts5Expr *p){  return p->pRoot->iRowid; } static int fts5ParseStringFromToken(Fts5Token *pToken, char **pz){  int rc = SQLITE_OK;  *pz = sqlite3Fts5Strndup(&rc, pToken->p, pToken->n);  return rc; } static void fts5ExprPhraseFree(Fts5ExprPhrase *pPhrase){  if( pPhrase ){  int i;  for(i=0; i<pPhrase->nTerm; i++){  Fts5ExprTerm *pSyn;  Fts5ExprTerm *pNext;  Fts5ExprTerm *pTerm = &pPhrase->aTerm[i];  sqlite3_free(pTerm->zTerm);  sqlite3Fts5IterClose(pTerm->pIter);  for(pSyn=pTerm->pSynonym; pSyn; pSyn=pNext){  pNext = pSyn->pSynonym;  sqlite3Fts5IterClose(pSyn->pIter);  fts5BufferFree((Fts5Buffer*)&pSyn[1]);  sqlite3_free(pSyn);  }  }  if( pPhrase->poslist.nSpace>0 ) fts5BufferFree(&pPhrase->poslist);  sqlite3_free(pPhrase);  } } static void sqlite3Fts5ParseSetCaret(Fts5ExprPhrase *pPhrase){  if( pPhrase && pPhrase->nTerm ){  pPhrase->aTerm[0].bFirst = 1;  } } static Fts5ExprNearset *sqlite3Fts5ParseNearset(  Fts5Parse *pParse,  Fts5ExprNearset *pNear,  Fts5ExprPhrase *pPhrase ){  const int SZALLOC = 8;  Fts5ExprNearset *pRet = 0;  if( pParse->rc==SQLITE_OK ){  if( pPhrase==0 ){  return pNear;  }  if( pNear==0 ){  sqlite3_int64 nByte;  nByte = sizeof(Fts5ExprNearset) + SZALLOC * sizeof(Fts5ExprPhrase*);  pRet = sqlite3_malloc64(nByte);  if( pRet==0 ){  pParse->rc = SQLITE_NOMEM;  }else{  memset(pRet, 0, (size_t)nByte);  }  }else if( (pNear->nPhrase % SZALLOC)==0 ){  int nNew = pNear->nPhrase + SZALLOC;  sqlite3_int64 nByte;  nByte = sizeof(Fts5ExprNearset) + nNew * sizeof(Fts5ExprPhrase*);  pRet = (Fts5ExprNearset*)sqlite3_realloc64(pNear, nByte);  if( pRet==0 ){  pParse->rc = SQLITE_NOMEM;  }  }else{  pRet = pNear;  }  }  if( pRet==0 ){  assert( pParse->rc!=SQLITE_OK );  sqlite3Fts5ParseNearsetFree(pNear);  sqlite3Fts5ParsePhraseFree(pPhrase);  }else{  if( pRet->nPhrase>0 ){  Fts5ExprPhrase *pLast = pRet->apPhrase[pRet->nPhrase-1];  assert( pLast==pParse->apPhrase[pParse->nPhrase-2] );  if( pPhrase->nTerm==0 ){  fts5ExprPhraseFree(pPhrase);  pRet->nPhrase--;  pParse->nPhrase--;  pPhrase = pLast;  }else if( pLast->nTerm==0 ){  fts5ExprPhraseFree(pLast);  pParse->apPhrase[pParse->nPhrase-2] = pPhrase;  pParse->nPhrase--;  pRet->nPhrase--;  }  }  pRet->apPhrase[pRet->nPhrase++] = pPhrase;  }  return pRet; } typedef struct TokenCtx TokenCtx; struct TokenCtx {  Fts5ExprPhrase *pPhrase;  int rc; }; static int fts5ParseTokenize(  void *pContext,  int tflags,  const char *pToken,  int nToken,  int iUnused1,  int iUnused2 ){  int rc = SQLITE_OK;  const int SZALLOC = 8;  TokenCtx *pCtx = (TokenCtx*)pContext;  Fts5ExprPhrase *pPhrase = pCtx->pPhrase;  UNUSED_PARAM2(iUnused1, iUnused2);  if( pCtx->rc!=SQLITE_OK ) return pCtx->rc;  if( nToken>FTS5_MAX_TOKEN_SIZE ) nToken = FTS5_MAX_TOKEN_SIZE;  if( pPhrase && pPhrase->nTerm>0 && (tflags & FTS5_TOKEN_COLOCATED) ){  Fts5ExprTerm *pSyn;  sqlite3_int64 nByte = sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer) + nToken+1;  pSyn = (Fts5ExprTerm*)sqlite3_malloc64(nByte);  if( pSyn==0 ){  rc = SQLITE_NOMEM;  }else{  memset(pSyn, 0, (size_t)nByte);  pSyn->zTerm = ((char*)pSyn) + sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer);  memcpy(pSyn->zTerm, pToken, nToken);  pSyn->pSynonym = pPhrase->aTerm[pPhrase->nTerm-1].pSynonym;  pPhrase->aTerm[pPhrase->nTerm-1].pSynonym = pSyn;  }  }else{  Fts5ExprTerm *pTerm;  if( pPhrase==0 || (pPhrase->nTerm % SZALLOC)==0 ){  Fts5ExprPhrase *pNew;  int nNew = SZALLOC + (pPhrase ? pPhrase->nTerm : 0);  pNew = (Fts5ExprPhrase*)sqlite3_realloc64(pPhrase,  sizeof(Fts5ExprPhrase) + sizeof(Fts5ExprTerm) * nNew  );  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  if( pPhrase==0 ) memset(pNew, 0, sizeof(Fts5ExprPhrase));  pCtx->pPhrase = pPhrase = pNew;  pNew->nTerm = nNew - SZALLOC;  }  }  if( rc==SQLITE_OK ){  pTerm = &pPhrase->aTerm[pPhrase->nTerm++];  memset(pTerm, 0, sizeof(Fts5ExprTerm));  pTerm->zTerm = sqlite3Fts5Strndup(&rc, pToken, nToken);  }  }  pCtx->rc = rc;  return rc; } static void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase *pPhrase){  fts5ExprPhraseFree(pPhrase); } static void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset *pNear){  if( pNear ){  int i;  for(i=0; i<pNear->nPhrase; i++){  fts5ExprPhraseFree(pNear->apPhrase[i]);  }  sqlite3_free(pNear->pColset);  sqlite3_free(pNear);  } } static void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p){  assert( pParse->pExpr==0 );  pParse->pExpr = p; } static int parseGrowPhraseArray(Fts5Parse *pParse){  if( (pParse->nPhrase % 8)==0 ){  sqlite3_int64 nByte = sizeof(Fts5ExprPhrase*) * (pParse->nPhrase + 8);  Fts5ExprPhrase **apNew;  apNew = (Fts5ExprPhrase**)sqlite3_realloc64(pParse->apPhrase, nByte);  if( apNew==0 ){  pParse->rc = SQLITE_NOMEM;  return SQLITE_NOMEM;  }  pParse->apPhrase = apNew;  }  return SQLITE_OK; } static Fts5ExprPhrase *sqlite3Fts5ParseTerm(  Fts5Parse *pParse,  Fts5ExprPhrase *pAppend,  Fts5Token *pToken,  int bPrefix ){  Fts5Config *pConfig = pParse->pConfig;  TokenCtx sCtx;  int rc;  char *z = 0;  memset(&sCtx, 0, sizeof(TokenCtx));  sCtx.pPhrase = pAppend;  rc = fts5ParseStringFromToken(pToken, &z);  if( rc==SQLITE_OK ){  int flags = FTS5_TOKENIZE_QUERY | (bPrefix ? FTS5_TOKENIZE_PREFIX : 0);  int n;  sqlite3Fts5Dequote(z);  n = (int)strlen(z);  rc = sqlite3Fts5Tokenize(pConfig, flags, z, n, &sCtx, fts5ParseTokenize);  }  sqlite3_free(z);  if( rc || (rc = sCtx.rc) ){  pParse->rc = rc;  fts5ExprPhraseFree(sCtx.pPhrase);  sCtx.pPhrase = 0;  }else{  if( pAppend==0 ){  if( parseGrowPhraseArray(pParse) ){  fts5ExprPhraseFree(sCtx.pPhrase);  return 0;  }  pParse->nPhrase++;  }  if( sCtx.pPhrase==0 ){  sCtx.pPhrase = sqlite3Fts5MallocZero(&pParse->rc, sizeof(Fts5ExprPhrase));  }else if( sCtx.pPhrase->nTerm ){  sCtx.pPhrase->aTerm[sCtx.pPhrase->nTerm-1].bPrefix = (u8)bPrefix;  }  pParse->apPhrase[pParse->nPhrase-1] = sCtx.pPhrase;  }  return sCtx.pPhrase; } static int sqlite3Fts5ExprClonePhrase(  Fts5Expr *pExpr,  int iPhrase,  Fts5Expr **ppNew ){  int rc = SQLITE_OK;  Fts5ExprPhrase *pOrig;  Fts5Expr *pNew = 0;  TokenCtx sCtx = {0,0};  pOrig = pExpr->apExprPhrase[iPhrase];  pNew = (Fts5Expr*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Expr));  if( rc==SQLITE_OK ){  pNew->apExprPhrase = (Fts5ExprPhrase**)sqlite3Fts5MallocZero(&rc,  sizeof(Fts5ExprPhrase*));  }  if( rc==SQLITE_OK ){  pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&rc,  sizeof(Fts5ExprNode));  }  if( rc==SQLITE_OK ){  pNew->pRoot->pNear = (Fts5ExprNearset*)sqlite3Fts5MallocZero(&rc,  sizeof(Fts5ExprNearset) + sizeof(Fts5ExprPhrase*));  }  if( rc==SQLITE_OK ){  Fts5Colset *pColsetOrig = pOrig->pNode->pNear->pColset;  if( pColsetOrig ){  sqlite3_int64 nByte;  Fts5Colset *pColset;  nByte = sizeof(Fts5Colset) + (pColsetOrig->nCol-1) * sizeof(int);  pColset = (Fts5Colset*)sqlite3Fts5MallocZero(&rc, nByte);  if( pColset ){  memcpy(pColset, pColsetOrig, (size_t)nByte);  }  pNew->pRoot->pNear->pColset = pColset;  }  }  if( pOrig->nTerm ){  int i;  for(i=0; rc==SQLITE_OK && i<pOrig->nTerm; i++){  int tflags = 0;  Fts5ExprTerm *p;  for(p=&pOrig->aTerm[i]; p && rc==SQLITE_OK; p=p->pSynonym){  const char *zTerm = p->zTerm;  rc = fts5ParseTokenize((void*)&sCtx, tflags, zTerm, (int)strlen(zTerm),  0, 0);  tflags = FTS5_TOKEN_COLOCATED;  }  if( rc==SQLITE_OK ){  sCtx.pPhrase->aTerm[i].bPrefix = pOrig->aTerm[i].bPrefix;  sCtx.pPhrase->aTerm[i].bFirst = pOrig->aTerm[i].bFirst;  }  }  }else{  sCtx.pPhrase = sqlite3Fts5MallocZero(&rc, sizeof(Fts5ExprPhrase));  }  if( rc==SQLITE_OK && ALWAYS(sCtx.pPhrase) ){  pNew->pIndex = pExpr->pIndex;  pNew->pConfig = pExpr->pConfig;  pNew->nPhrase = 1;  pNew->apExprPhrase[0] = sCtx.pPhrase;  pNew->pRoot->pNear->apPhrase[0] = sCtx.pPhrase;  pNew->pRoot->pNear->nPhrase = 1;  sCtx.pPhrase->pNode = pNew->pRoot;  if( pOrig->nTerm==1   && pOrig->aTerm[0].pSynonym==0   && pOrig->aTerm[0].bFirst==0  ){  pNew->pRoot->eType = FTS5_TERM;  pNew->pRoot->xNext = fts5ExprNodeNext_TERM;  }else{  pNew->pRoot->eType = FTS5_STRING;  pNew->pRoot->xNext = fts5ExprNodeNext_STRING;  }  }else{  sqlite3Fts5ExprFree(pNew);  fts5ExprPhraseFree(sCtx.pPhrase);  pNew = 0;  }  *ppNew = pNew;  return rc; } static void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token *pTok){  if( pTok->n!=4 || memcmp("NEAR", pTok->p, 4) ){  sqlite3Fts5ParseError(  pParse, "fts5: syntax error near \"%.*s\"", pTok->n, pTok->p  );  } } static void sqlite3Fts5ParseSetDistance(  Fts5Parse *pParse,  Fts5ExprNearset *pNear,  Fts5Token *p ){  if( pNear ){  int nNear = 0;  int i;  if( p->n ){  for(i=0; i<p->n; i++){  char c = (char)p->p[i];  if( c<'0' || c>'9' ){  sqlite3Fts5ParseError(  pParse, "expected integer, got \"%.*s\"", p->n, p->p  );  return;  }  nNear = nNear * 10 + (p->p[i] - '0');  }  }else{  nNear = FTS5_DEFAULT_NEARDIST;  }  pNear->nNear = nNear;  } } static Fts5Colset *fts5ParseColset(  Fts5Parse *pParse,  Fts5Colset *p,  int iCol ){  int nCol = p ? p->nCol : 0;  Fts5Colset *pNew;  assert( pParse->rc==SQLITE_OK );  assert( iCol>=0 && iCol<pParse->pConfig->nCol );  pNew = sqlite3_realloc64(p, sizeof(Fts5Colset) + sizeof(int)*nCol);  if( pNew==0 ){  pParse->rc = SQLITE_NOMEM;  }else{  int *aiCol = pNew->aiCol;  int i, j;  for(i=0; i<nCol; i++){  if( aiCol[i]==iCol ) return pNew;  if( aiCol[i]>iCol ) break;  }  for(j=nCol; j>i; j--){  aiCol[j] = aiCol[j-1];  }  aiCol[i] = iCol;  pNew->nCol = nCol+1;
#ifndef NDEBUG
 for(i=1; i<pNew->nCol; i++) assert( pNew->aiCol[i]>pNew->aiCol[i-1] );
#endif
 }  return pNew; } static Fts5Colset *sqlite3Fts5ParseColsetInvert(Fts5Parse *pParse, Fts5Colset *p){  Fts5Colset *pRet;  int nCol = pParse->pConfig->nCol;  pRet = (Fts5Colset*)sqlite3Fts5MallocZero(&pParse->rc,  sizeof(Fts5Colset) + sizeof(int)*nCol  );  if( pRet ){  int i;  int iOld = 0;  for(i=0; i<nCol; i++){  if( iOld>=p->nCol || p->aiCol[iOld]!=i ){  pRet->aiCol[pRet->nCol++] = i;  }else{  iOld++;  }  }  }  sqlite3_free(p);  return pRet; } static Fts5Colset *sqlite3Fts5ParseColset(  Fts5Parse *pParse,  Fts5Colset *pColset,  Fts5Token *p ){  Fts5Colset *pRet = 0;  int iCol;  char *z;  z = sqlite3Fts5Strndup(&pParse->rc, p->p, p->n);  if( pParse->rc==SQLITE_OK ){  Fts5Config *pConfig = pParse->pConfig;  sqlite3Fts5Dequote(z);  for(iCol=0; iCol<pConfig->nCol; iCol++){  if( 0==sqlite3_stricmp(pConfig->azCol[iCol], z) ) break;  }  if( iCol==pConfig->nCol ){  sqlite3Fts5ParseError(pParse, "no such column: %s", z);  }else{  pRet = fts5ParseColset(pParse, pColset, iCol);  }  sqlite3_free(z);  }  if( pRet==0 ){  assert( pParse->rc!=SQLITE_OK );  sqlite3_free(pColset);  }  return pRet; } static Fts5Colset *fts5CloneColset(int *pRc, Fts5Colset *pOrig){  Fts5Colset *pRet;  if( pOrig ){  sqlite3_int64 nByte = sizeof(Fts5Colset) + (pOrig->nCol-1) * sizeof(int);  pRet = (Fts5Colset*)sqlite3Fts5MallocZero(pRc, nByte);  if( pRet ){  memcpy(pRet, pOrig, (size_t)nByte);  }  }else{  pRet = 0;  }  return pRet; } static void fts5MergeColset(Fts5Colset *pColset, Fts5Colset *pMerge){  int iIn = 0;  int iMerge = 0;  int iOut = 0;  while( iIn<pColset->nCol && iMerge<pMerge->nCol ){  int iDiff = pColset->aiCol[iIn] - pMerge->aiCol[iMerge];  if( iDiff==0 ){  pColset->aiCol[iOut++] = pMerge->aiCol[iMerge];  iMerge++;  iIn++;  }else if( iDiff>0 ){  iMerge++;  }else{  iIn++;  }  }  pColset->nCol = iOut; } static void fts5ParseSetColset(  Fts5Parse *pParse,  Fts5ExprNode *pNode,  Fts5Colset *pColset,  Fts5Colset **ppFree ){  if( pParse->rc==SQLITE_OK ){  assert( pNode->eType==FTS5_TERM || pNode->eType==FTS5_STRING   || pNode->eType==FTS5_AND || pNode->eType==FTS5_OR   || pNode->eType==FTS5_NOT || pNode->eType==FTS5_EOF  );  if( pNode->eType==FTS5_STRING || pNode->eType==FTS5_TERM ){  Fts5ExprNearset *pNear = pNode->pNear;  if( pNear->pColset ){  fts5MergeColset(pNear->pColset, pColset);  if( pNear->pColset->nCol==0 ){  pNode->eType = FTS5_EOF;  pNode->xNext = 0;  }  }else if( *ppFree ){  pNear->pColset = pColset;  *ppFree = 0;  }else{  pNear->pColset = fts5CloneColset(&pParse->rc, pColset);  }  }else{  int i;  assert( pNode->eType!=FTS5_EOF || pNode->nChild==0 );  for(i=0; i<pNode->nChild; i++){  fts5ParseSetColset(pParse, pNode->apChild[i], pColset, ppFree);  }  }  } } static void sqlite3Fts5ParseSetColset(  Fts5Parse *pParse,  Fts5ExprNode *pExpr,  Fts5Colset *pColset ){  Fts5Colset *pFree = pColset;  if( pParse->pConfig->eDetail==FTS5_DETAIL_NONE ){  sqlite3Fts5ParseError(pParse,  "fts5: column queries are not supported (detail=none)"  );  }else{  fts5ParseSetColset(pParse, pExpr, pColset, &pFree);  }  sqlite3_free(pFree); } static void fts5ExprAssignXNext(Fts5ExprNode *pNode){  switch( pNode->eType ){  case FTS5_STRING: {  Fts5ExprNearset *pNear = pNode->pNear;  if( pNear->nPhrase==1 && pNear->apPhrase[0]->nTerm==1   && pNear->apPhrase[0]->aTerm[0].pSynonym==0   && pNear->apPhrase[0]->aTerm[0].bFirst==0  ){  pNode->eType = FTS5_TERM;  pNode->xNext = fts5ExprNodeNext_TERM;  }else{  pNode->xNext = fts5ExprNodeNext_STRING;  }  break;  };  case FTS5_OR: {  pNode->xNext = fts5ExprNodeNext_OR;  break;  };  case FTS5_AND: {  pNode->xNext = fts5ExprNodeNext_AND;  break;  };  default: assert( pNode->eType==FTS5_NOT ); {  pNode->xNext = fts5ExprNodeNext_NOT;  break;  };  } } static void fts5ExprAddChildren(Fts5ExprNode *p, Fts5ExprNode *pSub){  if( p->eType!=FTS5_NOT && pSub->eType==p->eType ){  int nByte = sizeof(Fts5ExprNode*) * pSub->nChild;  memcpy(&p->apChild[p->nChild], pSub->apChild, nByte);  p->nChild += pSub->nChild;  sqlite3_free(pSub);  }else{  p->apChild[p->nChild++] = pSub;  } } static Fts5ExprNode *fts5ParsePhraseToAnd(  Fts5Parse *pParse,  Fts5ExprNearset *pNear ){  int nTerm = pNear->apPhrase[0]->nTerm;  int ii;  int nByte;  Fts5ExprNode *pRet;  assert( pNear->nPhrase==1 );  assert( pParse->bPhraseToAnd );  nByte = sizeof(Fts5ExprNode) + nTerm*sizeof(Fts5ExprNode*);  pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);  if( pRet ){  pRet->eType = FTS5_AND;  pRet->nChild = nTerm;  fts5ExprAssignXNext(pRet);  pParse->nPhrase--;  for(ii=0; ii<nTerm; ii++){  Fts5ExprPhrase *pPhrase = (Fts5ExprPhrase*)sqlite3Fts5MallocZero(  &pParse->rc, sizeof(Fts5ExprPhrase)  );  if( pPhrase ){  if( parseGrowPhraseArray(pParse) ){  fts5ExprPhraseFree(pPhrase);  }else{  pParse->apPhrase[pParse->nPhrase++] = pPhrase;  pPhrase->nTerm = 1;  pPhrase->aTerm[0].zTerm = sqlite3Fts5Strndup(  &pParse->rc, pNear->apPhrase[0]->aTerm[ii].zTerm, -1  );  pRet->apChild[ii] = sqlite3Fts5ParseNode(pParse, FTS5_STRING,  0, 0, sqlite3Fts5ParseNearset(pParse, 0, pPhrase)  );  }  }  }  if( pParse->rc ){  sqlite3Fts5ParseNodeFree(pRet);  pRet = 0;  }else{  sqlite3Fts5ParseNearsetFree(pNear);  }  }  return pRet; } static Fts5ExprNode *sqlite3Fts5ParseNode(  Fts5Parse *pParse,  int eType,  Fts5ExprNode *pLeft,  Fts5ExprNode *pRight,  Fts5ExprNearset *pNear ){  Fts5ExprNode *pRet = 0;  if( pParse->rc==SQLITE_OK ){  int nChild = 0;  sqlite3_int64 nByte;  assert( (eType!=FTS5_STRING && !pNear)   || (eType==FTS5_STRING && !pLeft && !pRight)  );  if( eType==FTS5_STRING && pNear==0 ) return 0;  if( eType!=FTS5_STRING && pLeft==0 ) return pRight;  if( eType!=FTS5_STRING && pRight==0 ) return pLeft;  if( eType==FTS5_STRING   && pParse->bPhraseToAnd   && pNear->apPhrase[0]->nTerm>1  ){  pRet = fts5ParsePhraseToAnd(pParse, pNear);  }else{  if( eType==FTS5_NOT ){  nChild = 2;  }else if( eType==FTS5_AND || eType==FTS5_OR ){  nChild = 2;  if( pLeft->eType==eType ) nChild += pLeft->nChild-1;  if( pRight->eType==eType ) nChild += pRight->nChild-1;  }  nByte = sizeof(Fts5ExprNode) + sizeof(Fts5ExprNode*)*(nChild-1);  pRet = (Fts5ExprNode*)sqlite3Fts5MallocZero(&pParse->rc, nByte);  if( pRet ){  pRet->eType = eType;  pRet->pNear = pNear;  fts5ExprAssignXNext(pRet);  if( eType==FTS5_STRING ){  int iPhrase;  for(iPhrase=0; iPhrase<pNear->nPhrase; iPhrase++){  pNear->apPhrase[iPhrase]->pNode = pRet;  if( pNear->apPhrase[iPhrase]->nTerm==0 ){  pRet->xNext = 0;  pRet->eType = FTS5_EOF;  }  }  if( pParse->pConfig->eDetail!=FTS5_DETAIL_FULL ){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[0];  if( pNear->nPhrase!=1  || pPhrase->nTerm>1  || (pPhrase->nTerm>0 && pPhrase->aTerm[0].bFirst)  ){  sqlite3Fts5ParseError(pParse,  "fts5: %s queries are not supported (detail!=full)",  pNear->nPhrase==1 ? "phrase": "NEAR"  );  sqlite3_free(pRet);  pRet = 0;  }  }  }else{  fts5ExprAddChildren(pRet, pLeft);  fts5ExprAddChildren(pRet, pRight);  }  }  }  }  if( pRet==0 ){  assert( pParse->rc!=SQLITE_OK );  sqlite3Fts5ParseNodeFree(pLeft);  sqlite3Fts5ParseNodeFree(pRight);  sqlite3Fts5ParseNearsetFree(pNear);  }  return pRet; } static Fts5ExprNode *sqlite3Fts5ParseImplicitAnd(  Fts5Parse *pParse,  Fts5ExprNode *pLeft,  Fts5ExprNode *pRight ){  Fts5ExprNode *pRet = 0;  Fts5ExprNode *pPrev;  if( pParse->rc ){  sqlite3Fts5ParseNodeFree(pLeft);  sqlite3Fts5ParseNodeFree(pRight);  }else{  assert( pLeft->eType==FTS5_STRING  || pLeft->eType==FTS5_TERM  || pLeft->eType==FTS5_EOF  || pLeft->eType==FTS5_AND  );  assert( pRight->eType==FTS5_STRING  || pRight->eType==FTS5_TERM  || pRight->eType==FTS5_EOF  );  if( pLeft->eType==FTS5_AND ){  pPrev = pLeft->apChild[pLeft->nChild-1];  }else{  pPrev = pLeft;  }  assert( pPrev->eType==FTS5_STRING  || pPrev->eType==FTS5_TERM  || pPrev->eType==FTS5_EOF  );  if( pRight->eType==FTS5_EOF ){  assert( pParse->apPhrase[pParse->nPhrase-1]==pRight->pNear->apPhrase[0] );  sqlite3Fts5ParseNodeFree(pRight);  pRet = pLeft;  pParse->nPhrase--;  }  else if( pPrev->eType==FTS5_EOF ){  Fts5ExprPhrase **ap;  if( pPrev==pLeft ){  pRet = pRight;  }else{  pLeft->apChild[pLeft->nChild-1] = pRight;  pRet = pLeft;  }  ap = &pParse->apPhrase[pParse->nPhrase-1-pRight->pNear->nPhrase];  assert( ap[0]==pPrev->pNear->apPhrase[0] );  memmove(ap, &ap[1], sizeof(Fts5ExprPhrase*)*pRight->pNear->nPhrase);  pParse->nPhrase--;  sqlite3Fts5ParseNodeFree(pPrev);  }  else{  pRet = sqlite3Fts5ParseNode(pParse, FTS5_AND, pLeft, pRight, 0);  }  }  return pRet; }
#ifdef SQLITE_TEST
static char *fts5ExprTermPrint(Fts5ExprTerm *pTerm){  sqlite3_int64 nByte = 0;  Fts5ExprTerm *p;  char *zQuoted;  for(p=pTerm; p; p=p->pSynonym){  nByte += (int)strlen(pTerm->zTerm) * 2 + 3 + 2;  }  zQuoted = sqlite3_malloc64(nByte);  if( zQuoted ){  int i = 0;  for(p=pTerm; p; p=p->pSynonym){  char *zIn = p->zTerm;  zQuoted[i++] = '"';  while( *zIn ){  if( *zIn=='"' ) zQuoted[i++] = '"';  zQuoted[i++] = *zIn++;  }  zQuoted[i++] = '"';  if( p->pSynonym ) zQuoted[i++] = '|';  }  if( pTerm->bPrefix ){  zQuoted[i++] = ' ';  zQuoted[i++] = '*';  }  zQuoted[i++] = '\0';  }  return zQuoted; } static char *fts5PrintfAppend(char *zApp, const char *zFmt, ...){  char *zNew;  va_list ap;  va_start(ap, zFmt);  zNew = sqlite3_vmprintf(zFmt, ap);  va_end(ap);  if( zApp && zNew ){  char *zNew2 = sqlite3_mprintf("%s%s", zApp, zNew);  sqlite3_free(zNew);  zNew = zNew2;  }  sqlite3_free(zApp);  return zNew; } static char *fts5ExprPrintTcl(  Fts5Config *pConfig,  const char *zNearsetCmd,  Fts5ExprNode *pExpr ){  char *zRet = 0;  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){  Fts5ExprNearset *pNear = pExpr->pNear;  int i;  int iTerm;  zRet = fts5PrintfAppend(zRet, "%s ", zNearsetCmd);  if( zRet==0 ) return 0;  if( pNear->pColset ){  int *aiCol = pNear->pColset->aiCol;  int nCol = pNear->pColset->nCol;  if( nCol==1 ){  zRet = fts5PrintfAppend(zRet, "-col %d ", aiCol[0]);  }else{  zRet = fts5PrintfAppend(zRet, "-col {%d", aiCol[0]);  for(i=1; i<pNear->pColset->nCol; i++){  zRet = fts5PrintfAppend(zRet, " %d", aiCol[i]);  }  zRet = fts5PrintfAppend(zRet, "} ");  }  if( zRet==0 ) return 0;  }  if( pNear->nPhrase>1 ){  zRet = fts5PrintfAppend(zRet, "-near %d ", pNear->nNear);  if( zRet==0 ) return 0;  }  zRet = fts5PrintfAppend(zRet, "--");  if( zRet==0 ) return 0;  for(i=0; i<pNear->nPhrase; i++){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];  zRet = fts5PrintfAppend(zRet, " {");  for(iTerm=0; zRet && iTerm<pPhrase->nTerm; iTerm++){  char *zTerm = pPhrase->aTerm[iTerm].zTerm;  zRet = fts5PrintfAppend(zRet, "%s%s", iTerm==0?"":" ", zTerm);  if( pPhrase->aTerm[iTerm].bPrefix ){  zRet = fts5PrintfAppend(zRet, "*");  }  }  if( zRet ) zRet = fts5PrintfAppend(zRet, "}");  if( zRet==0 ) return 0;  }  }else{  char const *zOp = 0;  int i;  switch( pExpr->eType ){  case FTS5_AND: zOp = "AND"; break;  case FTS5_NOT: zOp = "NOT"; break;  default:  assert( pExpr->eType==FTS5_OR );  zOp = "OR";  break;  }  zRet = sqlite3_mprintf("%s", zOp);  for(i=0; zRet && i<pExpr->nChild; i++){  char *z = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->apChild[i]);  if( !z ){  sqlite3_free(zRet);  zRet = 0;  }else{  zRet = fts5PrintfAppend(zRet, " [%z]", z);  }  }  }  return zRet; } static char *fts5ExprPrint(Fts5Config *pConfig, Fts5ExprNode *pExpr){  char *zRet = 0;  if( pExpr->eType==0 ){  return sqlite3_mprintf("\"\"");  }else  if( pExpr->eType==FTS5_STRING || pExpr->eType==FTS5_TERM ){  Fts5ExprNearset *pNear = pExpr->pNear;  int i;  int iTerm;  if( pNear->pColset ){  int ii;  Fts5Colset *pColset = pNear->pColset;  if( pColset->nCol>1 ) zRet = fts5PrintfAppend(zRet, "{");  for(ii=0; ii<pColset->nCol; ii++){  zRet = fts5PrintfAppend(zRet, "%s%s",  pConfig->azCol[pColset->aiCol[ii]], ii==pColset->nCol-1 ? "" : " "  );  }  if( zRet ){  zRet = fts5PrintfAppend(zRet, "%s : ", pColset->nCol>1 ? "}" : "");  }  if( zRet==0 ) return 0;  }  if( pNear->nPhrase>1 ){  zRet = fts5PrintfAppend(zRet, "NEAR(");  if( zRet==0 ) return 0;  }  for(i=0; i<pNear->nPhrase; i++){  Fts5ExprPhrase *pPhrase = pNear->apPhrase[i];  if( i!=0 ){  zRet = fts5PrintfAppend(zRet, " ");  if( zRet==0 ) return 0;  }  for(iTerm=0; iTerm<pPhrase->nTerm; iTerm++){  char *zTerm = fts5ExprTermPrint(&pPhrase->aTerm[iTerm]);  if( zTerm ){  zRet = fts5PrintfAppend(zRet, "%s%s", iTerm==0?"":" + ", zTerm);  sqlite3_free(zTerm);  }  if( zTerm==0 || zRet==0 ){  sqlite3_free(zRet);  return 0;  }  }  }  if( pNear->nPhrase>1 ){  zRet = fts5PrintfAppend(zRet, ", %d)", pNear->nNear);  if( zRet==0 ) return 0;  }  }else{  char const *zOp = 0;  int i;  switch( pExpr->eType ){  case FTS5_AND: zOp = " AND "; break;  case FTS5_NOT: zOp = " NOT "; break;  default:  assert( pExpr->eType==FTS5_OR );  zOp = " OR ";  break;  }  for(i=0; i<pExpr->nChild; i++){  char *z = fts5ExprPrint(pConfig, pExpr->apChild[i]);  if( z==0 ){  sqlite3_free(zRet);  zRet = 0;  }else{  int e = pExpr->apChild[i]->eType;  int b = (e!=FTS5_STRING && e!=FTS5_TERM && e!=FTS5_EOF);  zRet = fts5PrintfAppend(zRet, "%s%s%z%s",  (i==0 ? "" : zOp),  (b?"(":""), z, (b?")":"")  );  }  if( zRet==0 ) break;  }  }  return zRet; } static void fts5ExprFunction(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal,  int bTcl ){  Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);  sqlite3 *db = sqlite3_context_db_handle(pCtx);  const char *zExpr = 0;  char *zErr = 0;  Fts5Expr *pExpr = 0;  int rc;  int i;  const char **azConfig;  const char *zNearsetCmd = "nearset";  int nConfig;  Fts5Config *pConfig = 0;  int iArg = 1;  if( nArg<1 ){  zErr = sqlite3_mprintf("wrong number of arguments to function %s",  bTcl ? "fts5_expr_tcl" : "fts5_expr"  );  sqlite3_result_error(pCtx, zErr, -1);  sqlite3_free(zErr);  return;  }  if( bTcl && nArg>1 ){  zNearsetCmd = (const char*)sqlite3_value_text(apVal[1]);  iArg = 2;  }  nConfig = 3 + (nArg-iArg);  azConfig = (const char**)sqlite3_malloc64(sizeof(char*) * nConfig);  if( azConfig==0 ){  sqlite3_result_error_nomem(pCtx);  return;  }  azConfig[0] = 0;  azConfig[1] = "main";  azConfig[2] = "tbl";  for(i=3; iArg<nArg; iArg++){  const char *z = (const char*)sqlite3_value_text(apVal[iArg]);  azConfig[i++] = (z ? z : "");  }  zExpr = (const char*)sqlite3_value_text(apVal[0]);  if( zExpr==0 ) zExpr = "";  rc = sqlite3Fts5ConfigParse(pGlobal, db, nConfig, azConfig, &pConfig, &zErr);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ExprNew(pConfig, 0, pConfig->nCol, zExpr, &pExpr, &zErr);  }  if( rc==SQLITE_OK ){  char *zText;  if( pExpr->pRoot->xNext==0 ){  zText = sqlite3_mprintf("");  }else if( bTcl ){  zText = fts5ExprPrintTcl(pConfig, zNearsetCmd, pExpr->pRoot);  }else{  zText = fts5ExprPrint(pConfig, pExpr->pRoot);  }  if( zText==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_result_text(pCtx, zText, -1, SQLITE_TRANSIENT);  sqlite3_free(zText);  }  }  if( rc!=SQLITE_OK ){  if( zErr ){  sqlite3_result_error(pCtx, zErr, -1);  sqlite3_free(zErr);  }else{  sqlite3_result_error_code(pCtx, rc);  }  }  sqlite3_free((void *)azConfig);  sqlite3Fts5ConfigFree(pConfig);  sqlite3Fts5ExprFree(pExpr); } static void fts5ExprFunctionHr(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal ){  fts5ExprFunction(pCtx, nArg, apVal, 0); } static void fts5ExprFunctionTcl(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal ){  fts5ExprFunction(pCtx, nArg, apVal, 1); } static void fts5ExprIsAlnum(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal ){  int iCode;  u8 aArr[32];  if( nArg!=1 ){  sqlite3_result_error(pCtx,  "wrong number of arguments to function fts5_isalnum", -1  );  return;  }  memset(aArr, 0, sizeof(aArr));  sqlite3Fts5UnicodeCatParse("L*", aArr);  sqlite3Fts5UnicodeCatParse("N*", aArr);  sqlite3Fts5UnicodeCatParse("Co", aArr);  iCode = sqlite3_value_int(apVal[0]);  sqlite3_result_int(pCtx, aArr[sqlite3Fts5UnicodeCategory((u32)iCode)]); } static void fts5ExprFold(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal ){  if( nArg!=1 && nArg!=2 ){  sqlite3_result_error(pCtx,  "wrong number of arguments to function fts5_fold", -1  );  }else{  int iCode;  int bRemoveDiacritics = 0;  iCode = sqlite3_value_int(apVal[0]);  if( nArg==2 ) bRemoveDiacritics = sqlite3_value_int(apVal[1]);  sqlite3_result_int(pCtx, sqlite3Fts5UnicodeFold(iCode, bRemoveDiacritics));  } }
#endif
static int sqlite3Fts5ExprInit(Fts5Global *pGlobal, sqlite3 *db){
#ifdef SQLITE_TEST
 struct Fts5ExprFunc {  const char *z;  void (*x)(sqlite3_context*,int,sqlite3_value**);  } aFunc[] = {  { "fts5_expr", fts5ExprFunctionHr },  { "fts5_expr_tcl", fts5ExprFunctionTcl },  { "fts5_isalnum", fts5ExprIsAlnum },  { "fts5_fold", fts5ExprFold },  };  int i;  int rc = SQLITE_OK;  void *pCtx = (void*)pGlobal;  for(i=0; rc==SQLITE_OK && i<ArraySize(aFunc); i++){  struct Fts5ExprFunc *p = &aFunc[i];  rc = sqlite3_create_function(db, p->z, -1, SQLITE_UTF8, pCtx, p->x, 0, 0);  }
#else
 int rc = SQLITE_OK;  UNUSED_PARAM2(pGlobal,db);
#endif
#ifndef NDEBUG
 (void)sqlite3Fts5ParserTrace;
#endif
 (void)sqlite3Fts5ParserFallback;  return rc; } static int sqlite3Fts5ExprPhraseCount(Fts5Expr *pExpr){  return (pExpr ? pExpr->nPhrase : 0); } static int sqlite3Fts5ExprPhraseSize(Fts5Expr *pExpr, int iPhrase){  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ) return 0;  return pExpr->apExprPhrase[iPhrase]->nTerm; } static int sqlite3Fts5ExprPoslist(Fts5Expr *pExpr, int iPhrase, const u8 **pa){  int nRet;  Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];  Fts5ExprNode *pNode = pPhrase->pNode;  if( pNode->bEof==0 && pNode->iRowid==pExpr->pRoot->iRowid ){  *pa = pPhrase->poslist.p;  nRet = pPhrase->poslist.n;  }else{  *pa = 0;  nRet = 0;  }  return nRet; } struct Fts5PoslistPopulator {  Fts5PoslistWriter writer;  int bOk;  int bMiss; }; static Fts5PoslistPopulator *sqlite3Fts5ExprClearPoslists(Fts5Expr *pExpr, int bLive){  Fts5PoslistPopulator *pRet;  pRet = sqlite3_malloc64(sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);  if( pRet ){  int i;  memset(pRet, 0, sizeof(Fts5PoslistPopulator)*pExpr->nPhrase);  for(i=0; i<pExpr->nPhrase; i++){  Fts5Buffer *pBuf = &pExpr->apExprPhrase[i]->poslist;  Fts5ExprNode *pNode = pExpr->apExprPhrase[i]->pNode;  assert( pExpr->apExprPhrase[i]->nTerm<=1 );  if( bLive &&  (pBuf->n==0 || pNode->iRowid!=pExpr->pRoot->iRowid || pNode->bEof)  ){  pRet[i].bMiss = 1;  }else{  pBuf->n = 0;  }  }  }  return pRet; } struct Fts5ExprCtx {  Fts5Expr *pExpr;  Fts5PoslistPopulator *aPopulator;  i64 iOff; }; typedef struct Fts5ExprCtx Fts5ExprCtx; static int fts5ExprColsetTest(Fts5Colset *pColset, int iCol){  int i;  for(i=0; i<pColset->nCol; i++){  if( pColset->aiCol[i]==iCol ) return 1;  }  return 0; } static int fts5ExprPopulatePoslistsCb(  void *pCtx,  int tflags,  const char *pToken,  int nToken,  int iUnused1,  int iUnused2 ){  Fts5ExprCtx *p = (Fts5ExprCtx*)pCtx;  Fts5Expr *pExpr = p->pExpr;  int i;  UNUSED_PARAM2(iUnused1, iUnused2);  if( nToken>FTS5_MAX_TOKEN_SIZE ) nToken = FTS5_MAX_TOKEN_SIZE;  if( (tflags & FTS5_TOKEN_COLOCATED)==0 ) p->iOff++;  for(i=0; i<pExpr->nPhrase; i++){  Fts5ExprTerm *pTerm;  if( p->aPopulator[i].bOk==0 ) continue;  for(pTerm=&pExpr->apExprPhrase[i]->aTerm[0]; pTerm; pTerm=pTerm->pSynonym){  int nTerm = (int)strlen(pTerm->zTerm);  if( (nTerm==nToken || (nTerm<nToken && pTerm->bPrefix))   && memcmp(pTerm->zTerm, pToken, nTerm)==0  ){  int rc = sqlite3Fts5PoslistWriterAppend(  &pExpr->apExprPhrase[i]->poslist, &p->aPopulator[i].writer, p->iOff  );  if( rc ) return rc;  break;  }  }  }  return SQLITE_OK; } static int sqlite3Fts5ExprPopulatePoslists(  Fts5Config *pConfig,  Fts5Expr *pExpr,  Fts5PoslistPopulator *aPopulator,  int iCol,  const char *z, int n ){  int i;  Fts5ExprCtx sCtx;  sCtx.pExpr = pExpr;  sCtx.aPopulator = aPopulator;  sCtx.iOff = (((i64)iCol) << 32) - 1;  for(i=0; i<pExpr->nPhrase; i++){  Fts5ExprNode *pNode = pExpr->apExprPhrase[i]->pNode;  Fts5Colset *pColset = pNode->pNear->pColset;  if( (pColset && 0==fts5ExprColsetTest(pColset, iCol))   || aPopulator[i].bMiss  ){  aPopulator[i].bOk = 0;  }else{  aPopulator[i].bOk = 1;  }  }  return sqlite3Fts5Tokenize(pConfig,  FTS5_TOKENIZE_DOCUMENT, z, n, (void*)&sCtx, fts5ExprPopulatePoslistsCb  ); } static void fts5ExprClearPoslists(Fts5ExprNode *pNode){  if( pNode->eType==FTS5_TERM || pNode->eType==FTS5_STRING ){  pNode->pNear->apPhrase[0]->poslist.n = 0;  }else{  int i;  for(i=0; i<pNode->nChild; i++){  fts5ExprClearPoslists(pNode->apChild[i]);  }  } } static int fts5ExprCheckPoslists(Fts5ExprNode *pNode, i64 iRowid){  pNode->iRowid = iRowid;  pNode->bEof = 0;  switch( pNode->eType ){  case FTS5_TERM:  case FTS5_STRING:  return (pNode->pNear->apPhrase[0]->poslist.n>0);  case FTS5_AND: {  int i;  for(i=0; i<pNode->nChild; i++){  if( fts5ExprCheckPoslists(pNode->apChild[i], iRowid)==0 ){  fts5ExprClearPoslists(pNode);  return 0;  }  }  break;  }  case FTS5_OR: {  int i;  int bRet = 0;  for(i=0; i<pNode->nChild; i++){  if( fts5ExprCheckPoslists(pNode->apChild[i], iRowid) ){  bRet = 1;  }  }  return bRet;  }  default: {  assert( pNode->eType==FTS5_NOT );  if( 0==fts5ExprCheckPoslists(pNode->apChild[0], iRowid)  || 0!=fts5ExprCheckPoslists(pNode->apChild[1], iRowid)  ){  fts5ExprClearPoslists(pNode);  return 0;  }  break;  }  }  return 1; } static void sqlite3Fts5ExprCheckPoslists(Fts5Expr *pExpr, i64 iRowid){  fts5ExprCheckPoslists(pExpr->pRoot, iRowid); } static int sqlite3Fts5ExprPhraseCollist(  Fts5Expr *pExpr,  int iPhrase,  const u8 **ppCollist,  int *pnCollist ){  Fts5ExprPhrase *pPhrase = pExpr->apExprPhrase[iPhrase];  Fts5ExprNode *pNode = pPhrase->pNode;  int rc = SQLITE_OK;  assert( iPhrase>=0 && iPhrase<pExpr->nPhrase );  assert( pExpr->pConfig->eDetail==FTS5_DETAIL_COLUMNS );  if( pNode->bEof==0   && pNode->iRowid==pExpr->pRoot->iRowid   && pPhrase->poslist.n>0  ){  Fts5ExprTerm *pTerm = &pPhrase->aTerm[0];  if( pTerm->pSynonym ){  Fts5Buffer *pBuf = (Fts5Buffer*)&pTerm->pSynonym[1];  rc = fts5ExprSynonymList(  pTerm, pNode->iRowid, pBuf, (u8**)ppCollist, pnCollist  );  }else{  *ppCollist = pPhrase->aTerm[0].pIter->pData;  *pnCollist = pPhrase->aTerm[0].pIter->nData;  }  }else{  *ppCollist = 0;  *pnCollist = 0;  }  return rc; } typedef struct Fts5HashEntry Fts5HashEntry; struct Fts5Hash {  int eDetail;  int *pnByte;  int nEntry;  int nSlot;  Fts5HashEntry *pScan;  Fts5HashEntry **aSlot; }; struct Fts5HashEntry {  Fts5HashEntry *pHashNext;  Fts5HashEntry *pScanNext;  int nAlloc;  int iSzPoslist;  int nData;  int nKey;  u8 bDel;  u8 bContent;  i16 iCol;  int iPos;  i64 iRowid; };
#define fts5EntryKey(p) ( ((char *)(&(p)[1])) )
static int sqlite3Fts5HashNew(Fts5Config *pConfig, Fts5Hash **ppNew, int *pnByte){  int rc = SQLITE_OK;  Fts5Hash *pNew;  *ppNew = pNew = (Fts5Hash*)sqlite3_malloc(sizeof(Fts5Hash));  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_int64 nByte;  memset(pNew, 0, sizeof(Fts5Hash));  pNew->pnByte = pnByte;  pNew->eDetail = pConfig->eDetail;  pNew->nSlot = 1024;  nByte = sizeof(Fts5HashEntry*) * pNew->nSlot;  pNew->aSlot = (Fts5HashEntry**)sqlite3_malloc64(nByte);  if( pNew->aSlot==0 ){  sqlite3_free(pNew);  *ppNew = 0;  rc = SQLITE_NOMEM;  }else{  memset(pNew->aSlot, 0, (size_t)nByte);  }  }  return rc; } static void sqlite3Fts5HashFree(Fts5Hash *pHash){  if( pHash ){  sqlite3Fts5HashClear(pHash);  sqlite3_free(pHash->aSlot);  sqlite3_free(pHash);  } } static void sqlite3Fts5HashClear(Fts5Hash *pHash){  int i;  for(i=0; i<pHash->nSlot; i++){  Fts5HashEntry *pNext;  Fts5HashEntry *pSlot;  for(pSlot=pHash->aSlot[i]; pSlot; pSlot=pNext){  pNext = pSlot->pHashNext;  sqlite3_free(pSlot);  }  }  memset(pHash->aSlot, 0, pHash->nSlot * sizeof(Fts5HashEntry*));  pHash->nEntry = 0; } static unsigned int fts5HashKey(int nSlot, const u8 *p, int n){  int i;  unsigned int h = 13;  for(i=n-1; i>=0; i--){  h = (h << 3) ^ h ^ p[i];  }  return (h % nSlot); } static unsigned int fts5HashKey2(int nSlot, u8 b, const u8 *p, int n){  int i;  unsigned int h = 13;  for(i=n-1; i>=0; i--){  h = (h << 3) ^ h ^ p[i];  }  h = (h << 3) ^ h ^ b;  return (h % nSlot); } static int fts5HashResize(Fts5Hash *pHash){  int nNew = pHash->nSlot*2;  int i;  Fts5HashEntry **apNew;  Fts5HashEntry **apOld = pHash->aSlot;  apNew = (Fts5HashEntry**)sqlite3_malloc64(nNew*sizeof(Fts5HashEntry*));  if( !apNew ) return SQLITE_NOMEM;  memset(apNew, 0, nNew*sizeof(Fts5HashEntry*));  for(i=0; i<pHash->nSlot; i++){  while( apOld[i] ){  unsigned int iHash;  Fts5HashEntry *p = apOld[i];  apOld[i] = p->pHashNext;  iHash = fts5HashKey(nNew, (u8*)fts5EntryKey(p),  (int)strlen(fts5EntryKey(p)));  p->pHashNext = apNew[iHash];  apNew[iHash] = p;  }  }  sqlite3_free(apOld);  pHash->nSlot = nNew;  pHash->aSlot = apNew;  return SQLITE_OK; } static int fts5HashAddPoslistSize(  Fts5Hash *pHash,  Fts5HashEntry *p,  Fts5HashEntry *p2 ){  int nRet = 0;  if( p->iSzPoslist ){  u8 *pPtr = p2 ? (u8*)p2 : (u8*)p;  int nData = p->nData;  if( pHash->eDetail==FTS5_DETAIL_NONE ){  assert( nData==p->iSzPoslist );  if( p->bDel ){  pPtr[nData++] = 0x00;  if( p->bContent ){  pPtr[nData++] = 0x00;  }  }  }else{  int nSz = (nData - p->iSzPoslist - 1);  int nPos = nSz*2 + p->bDel;  assert( p->bDel==0 || p->bDel==1 );  if( nPos<=127 ){  pPtr[p->iSzPoslist] = (u8)nPos;  }else{  int nByte = sqlite3Fts5GetVarintLen((u32)nPos);  memmove(&pPtr[p->iSzPoslist + nByte], &pPtr[p->iSzPoslist + 1], nSz);  sqlite3Fts5PutVarint(&pPtr[p->iSzPoslist], nPos);  nData += (nByte-1);  }  }  nRet = nData - p->nData;  if( p2==0 ){  p->iSzPoslist = 0;  p->bDel = 0;  p->bContent = 0;  p->nData = nData;  }  }  return nRet; } static int sqlite3Fts5HashWrite(  Fts5Hash *pHash,  i64 iRowid,  int iCol,  int iPos,  char bByte,  const char *pToken, int nToken ){  unsigned int iHash;  Fts5HashEntry *p;  u8 *pPtr;  int nIncr = 0;  int bNew;  bNew = (pHash->eDetail==FTS5_DETAIL_FULL);  iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);  for(p=pHash->aSlot[iHash]; p; p=p->pHashNext){  char *zKey = fts5EntryKey(p);  if( zKey[0]==bByte   && p->nKey==nToken   && memcmp(&zKey[1], pToken, nToken)==0  ){  break;  }  }  if( p==0 ){  char *zKey;  sqlite3_int64 nByte = sizeof(Fts5HashEntry) + (nToken+1) + 1 + 64;  if( nByte<128 ) nByte = 128;  if( (pHash->nEntry*2)>=pHash->nSlot ){  int rc = fts5HashResize(pHash);  if( rc!=SQLITE_OK ) return rc;  iHash = fts5HashKey2(pHash->nSlot, (u8)bByte, (const u8*)pToken, nToken);  }  p = (Fts5HashEntry*)sqlite3_malloc64(nByte);  if( !p ) return SQLITE_NOMEM;  memset(p, 0, sizeof(Fts5HashEntry));  p->nAlloc = (int)nByte;  zKey = fts5EntryKey(p);  zKey[0] = bByte;  memcpy(&zKey[1], pToken, nToken);  assert( iHash==fts5HashKey(pHash->nSlot, (u8*)zKey, nToken+1) );  p->nKey = nToken;  zKey[nToken+1] = '\0';  p->nData = nToken+1 + 1 + sizeof(Fts5HashEntry);  p->pHashNext = pHash->aSlot[iHash];  pHash->aSlot[iHash] = p;  pHash->nEntry++;  p->nData += sqlite3Fts5PutVarint(&((u8*)p)[p->nData], iRowid);  p->iRowid = iRowid;  p->iSzPoslist = p->nData;  if( pHash->eDetail!=FTS5_DETAIL_NONE ){  p->nData += 1;  p->iCol = (pHash->eDetail==FTS5_DETAIL_FULL ? 0 : -1);  }  }else{  if( (p->nAlloc - p->nData) < (9 + 4 + 1 + 3 + 5) ){  sqlite3_int64 nNew = p->nAlloc * 2;  Fts5HashEntry *pNew;  Fts5HashEntry **pp;  pNew = (Fts5HashEntry*)sqlite3_realloc64(p, nNew);  if( pNew==0 ) return SQLITE_NOMEM;  pNew->nAlloc = (int)nNew;  for(pp=&pHash->aSlot[iHash]; *pp!=p; pp=&(*pp)->pHashNext);  *pp = pNew;  p = pNew;  }  nIncr -= p->nData;  }  assert( (p->nAlloc - p->nData) >= (9 + 4 + 1 + 3 + 5) );  pPtr = (u8*)p;  if( iRowid!=p->iRowid ){  u64 iDiff = (u64)iRowid - (u64)p->iRowid;  fts5HashAddPoslistSize(pHash, p, 0);  p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iDiff);  p->iRowid = iRowid;  bNew = 1;  p->iSzPoslist = p->nData;  if( pHash->eDetail!=FTS5_DETAIL_NONE ){  p->nData += 1;  p->iCol = (pHash->eDetail==FTS5_DETAIL_FULL ? 0 : -1);  p->iPos = 0;  }  }  if( iCol>=0 ){  if( pHash->eDetail==FTS5_DETAIL_NONE ){  p->bContent = 1;  }else{  assert_nc( iCol>=p->iCol );  if( iCol!=p->iCol ){  if( pHash->eDetail==FTS5_DETAIL_FULL ){  pPtr[p->nData++] = 0x01;  p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iCol);  p->iCol = (i16)iCol;  p->iPos = 0;  }else{  bNew = 1;  p->iCol = (i16)(iPos = iCol);  }  }  if( bNew ){  p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iPos - p->iPos + 2);  p->iPos = iPos;  }  }  }else{  p->bDel = 1;  }  nIncr += p->nData;  *pHash->pnByte += nIncr;  return SQLITE_OK; } static Fts5HashEntry *fts5HashEntryMerge(  Fts5HashEntry *pLeft,  Fts5HashEntry *pRight ){  Fts5HashEntry *p1 = pLeft;  Fts5HashEntry *p2 = pRight;  Fts5HashEntry *pRet = 0;  Fts5HashEntry **ppOut = &pRet;  while( p1 || p2 ){  if( p1==0 ){  *ppOut = p2;  p2 = 0;  }else if( p2==0 ){  *ppOut = p1;  p1 = 0;  }else{  int i = 0;  char *zKey1 = fts5EntryKey(p1);  char *zKey2 = fts5EntryKey(p2);  while( zKey1[i]==zKey2[i] ) i++;  if( ((u8)zKey1[i])>((u8)zKey2[i]) ){  *ppOut = p2;  ppOut = &p2->pScanNext;  p2 = p2->pScanNext;  }else{  *ppOut = p1;  ppOut = &p1->pScanNext;  p1 = p1->pScanNext;  }  *ppOut = 0;  }  }  return pRet; } static int fts5HashEntrySort(  Fts5Hash *pHash,  const char *pTerm, int nTerm,  Fts5HashEntry **ppSorted ){  const int nMergeSlot = 32;  Fts5HashEntry **ap;  Fts5HashEntry *pList;  int iSlot;  int i;  *ppSorted = 0;  ap = sqlite3_malloc64(sizeof(Fts5HashEntry*) * nMergeSlot);  if( !ap ) return SQLITE_NOMEM;  memset(ap, 0, sizeof(Fts5HashEntry*) * nMergeSlot);  for(iSlot=0; iSlot<pHash->nSlot; iSlot++){  Fts5HashEntry *pIter;  for(pIter=pHash->aSlot[iSlot]; pIter; pIter=pIter->pHashNext){  if( pTerm==0   || (pIter->nKey+1>=nTerm && 0==memcmp(fts5EntryKey(pIter), pTerm, nTerm))  ){  Fts5HashEntry *pEntry = pIter;  pEntry->pScanNext = 0;  for(i=0; ap[i]; i++){  pEntry = fts5HashEntryMerge(pEntry, ap[i]);  ap[i] = 0;  }  ap[i] = pEntry;  }  }  }  pList = 0;  for(i=0; i<nMergeSlot; i++){  pList = fts5HashEntryMerge(pList, ap[i]);  }  pHash->nEntry = 0;  sqlite3_free(ap);  *ppSorted = pList;  return SQLITE_OK; } static int sqlite3Fts5HashQuery(  Fts5Hash *pHash,  int nPre,  const char *pTerm, int nTerm,  void **ppOut,  int *pnDoclist ){  unsigned int iHash = fts5HashKey(pHash->nSlot, (const u8*)pTerm, nTerm);  char *zKey = 0;  Fts5HashEntry *p;  for(p=pHash->aSlot[iHash]; p; p=p->pHashNext){  zKey = fts5EntryKey(p);  assert( p->nKey+1==(int)strlen(zKey) );  if( nTerm==p->nKey+1 && memcmp(zKey, pTerm, nTerm)==0 ) break;  }  if( p ){  int nHashPre = sizeof(Fts5HashEntry) + nTerm + 1;  int nList = p->nData - nHashPre;  u8 *pRet = (u8*)(*ppOut = sqlite3_malloc64(nPre + nList + 10));  if( pRet ){  Fts5HashEntry *pFaux = (Fts5HashEntry*)&pRet[nPre-nHashPre];  memcpy(&pRet[nPre], &((u8*)p)[nHashPre], nList);  nList += fts5HashAddPoslistSize(pHash, p, pFaux);  *pnDoclist = nList;  }else{  *pnDoclist = 0;  return SQLITE_NOMEM;  }  }else{  *ppOut = 0;  *pnDoclist = 0;  }  return SQLITE_OK; } static int sqlite3Fts5HashScanInit(  Fts5Hash *p,  const char *pTerm, int nTerm ){  return fts5HashEntrySort(p, pTerm, nTerm, &p->pScan); } static void sqlite3Fts5HashScanNext(Fts5Hash *p){  assert( !sqlite3Fts5HashScanEof(p) );  p->pScan = p->pScan->pScanNext; } static int sqlite3Fts5HashScanEof(Fts5Hash *p){  return (p->pScan==0); } static void sqlite3Fts5HashScanEntry(  Fts5Hash *pHash,  const char **pzTerm,  const u8 **ppDoclist,  int *pnDoclist ){  Fts5HashEntry *p;  if( (p = pHash->pScan) ){  char *zKey = fts5EntryKey(p);  int nTerm = (int)strlen(zKey);  fts5HashAddPoslistSize(pHash, p, 0);  *pzTerm = zKey;  *ppDoclist = (const u8*)&zKey[nTerm+1];  *pnDoclist = p->nData - (sizeof(Fts5HashEntry) + nTerm + 1);  }else{  *pzTerm = 0;  *ppDoclist = 0;  *pnDoclist = 0;  } }
#define FTS5_OPT_WORK_UNIT 1000
#define FTS5_WORK_UNIT 64
#define FTS5_MIN_DLIDX_SIZE 4
#define FTS5_MAIN_PREFIX '0'
#if FTS5_MAX_PREFIX_INDEXES > 31
# error "FTS5_MAX_PREFIX_INDEXES is too large"
#endif
#define FTS5_AVERAGES_ROWID  1
#define FTS5_STRUCTURE_ROWID  10
#define FTS5_DATA_ID_B  16
#define FTS5_DATA_DLI_B  1
#define FTS5_DATA_HEIGHT_B 5
#define FTS5_DATA_PAGE_B  31
#define fts5_dri(segid, dlidx, height, pgno) (   ((i64)(segid) << (FTS5_DATA_PAGE_B+FTS5_DATA_HEIGHT_B+FTS5_DATA_DLI_B)) +  ((i64)(dlidx) << (FTS5_DATA_PAGE_B + FTS5_DATA_HEIGHT_B)) +  ((i64)(height) << (FTS5_DATA_PAGE_B)) +   ((i64)(pgno))  )

#define FTS5_SEGMENT_ROWID(segid, pgno)  fts5_dri(segid, 0, 0, pgno)
#define FTS5_DLIDX_ROWID(segid, height, pgno) fts5_dri(segid, 1, height, pgno)
#ifdef SQLITE_DEBUG
static int sqlite3Fts5Corrupt() { return SQLITE_CORRUPT_VTAB; }
#endif
#define FTS5_DATA_ZERO_PADDING 8
#define FTS5_DATA_PADDING 20
typedef struct Fts5Data Fts5Data; typedef struct Fts5DlidxIter Fts5DlidxIter; typedef struct Fts5DlidxLvl Fts5DlidxLvl; typedef struct Fts5DlidxWriter Fts5DlidxWriter; typedef struct Fts5Iter Fts5Iter; typedef struct Fts5PageWriter Fts5PageWriter; typedef struct Fts5SegIter Fts5SegIter; typedef struct Fts5DoclistIter Fts5DoclistIter; typedef struct Fts5SegWriter Fts5SegWriter; typedef struct Fts5Structure Fts5Structure; typedef struct Fts5StructureLevel Fts5StructureLevel; typedef struct Fts5StructureSegment Fts5StructureSegment; struct Fts5Data {  u8 *p;  int nn;  int szLeaf; }; struct Fts5Index {  Fts5Config *pConfig;  char *zDataTbl;  int nWorkUnit;  Fts5Hash *pHash;  int nPendingData;  i64 iWriteRowid;  int bDelete;  int rc;  sqlite3_blob *pReader;  sqlite3_stmt *pWriter;  sqlite3_stmt *pDeleter;  sqlite3_stmt *pIdxWriter;  sqlite3_stmt *pIdxDeleter;  sqlite3_stmt *pIdxSelect;  int nRead;  sqlite3_stmt *pDataVersion;  i64 iStructVersion;  Fts5Structure *pStruct; }; struct Fts5DoclistIter {  u8 *aEof;  i64 iRowid;  u8 *aPoslist;  int nPoslist;  int nSize; }; struct Fts5StructureSegment {  int iSegid;  int pgnoFirst;  int pgnoLast; }; struct Fts5StructureLevel {  int nMerge;  int nSeg;  Fts5StructureSegment *aSeg; }; struct Fts5Structure {  int nRef;  u64 nWriteCounter;  int nSegment;  int nLevel;  Fts5StructureLevel aLevel[1]; }; struct Fts5PageWriter {  int pgno;  int iPrevPgidx;  Fts5Buffer buf;  Fts5Buffer pgidx;  Fts5Buffer term; }; struct Fts5DlidxWriter {  int pgno;  int bPrevValid;  i64 iPrev;  Fts5Buffer buf; }; struct Fts5SegWriter {  int iSegid;  Fts5PageWriter writer;  i64 iPrevRowid;  u8 bFirstRowidInDoclist;  u8 bFirstRowidInPage;  u8 bFirstTermInPage;  int nLeafWritten;  int nEmpty;  int nDlidx;  Fts5DlidxWriter *aDlidx;  Fts5Buffer btterm;  int iBtPage; }; typedef struct Fts5CResult Fts5CResult; struct Fts5CResult {  u16 iFirst;  u8 bTermEq; }; struct Fts5SegIter {  Fts5StructureSegment *pSeg;  int flags;  int iLeafPgno;  Fts5Data *pLeaf;  Fts5Data *pNextLeaf;  i64 iLeafOffset;  void (*xNext)(Fts5Index*, Fts5SegIter*, int*);  int iTermLeafPgno;  int iTermLeafOffset;  int iPgidxOff;  int iEndofDoclist;  int iRowidOffset;  int nRowidOffset;  int *aRowidOffset;  Fts5DlidxIter *pDlidx;  Fts5Buffer term;  i64 iRowid;  int nPos;  u8 bDel; };
#define ASSERT_SZLEAF_OK(x) assert(  (x)->szLeaf==(x)->nn || (x)->szLeaf==fts5GetU16(&(x)->p[2]) )

#define FTS5_SEGITER_ONETERM 0x01
#define FTS5_SEGITER_REVERSE 0x02
#define fts5LeafIsTermless(x) ((x)->szLeaf >= (x)->nn)
#define fts5LeafTermOff(x, i) (fts5GetU16(&(x)->p[(x)->szLeaf + (i)*2]))
#define fts5LeafFirstRowidOff(x) (fts5GetU16((x)->p))
struct Fts5Iter {  Fts5IndexIter base;  Fts5Index *pIndex;  Fts5Buffer poslist;  Fts5Colset *pColset;  void (*xSetOutputs)(Fts5Iter*, Fts5SegIter*);  int nSeg;  int bRev;  u8 bSkipEmpty;  i64 iSwitchRowid;  Fts5CResult *aFirst;  Fts5SegIter aSeg[1]; }; struct Fts5DlidxLvl {  Fts5Data *pData;  int iOff;  int bEof;  int iFirstOff;  int iLeafPgno;  i64 iRowid; }; struct Fts5DlidxIter {  int nLvl;  int iSegid;  Fts5DlidxLvl aLvl[1]; }; static void fts5PutU16(u8 *aOut, u16 iVal){  aOut[0] = (iVal>>8);  aOut[1] = (iVal&0xFF); } static u16 fts5GetU16(const u8 *aIn){  return ((u16)aIn[0] << 8) + aIn[1]; } static void *fts5IdxMalloc(Fts5Index *p, sqlite3_int64 nByte){  return sqlite3Fts5MallocZero(&p->rc, nByte); }
#ifdef SQLITE_DEBUG
static int fts5BufferCompareBlob(  Fts5Buffer *pLeft,  const u8 *pRight, int nRight ){  int nCmp = MIN(pLeft->n, nRight);  int res = memcmp(pLeft->p, pRight, nCmp);  return (res==0 ? (pLeft->n - nRight) : res); }
#endif
static int fts5BufferCompare(Fts5Buffer *pLeft, Fts5Buffer *pRight){  int nCmp, res;  nCmp = MIN(pLeft->n, pRight->n);  assert( nCmp<=0 || pLeft->p!=0 );  assert( nCmp<=0 || pRight->p!=0 );  res = fts5Memcmp(pLeft->p, pRight->p, nCmp);  return (res==0 ? (pLeft->n - pRight->n) : res); } static int fts5LeafFirstTermOff(Fts5Data *pLeaf){  int ret;  fts5GetVarint32(&pLeaf->p[pLeaf->szLeaf], ret);  return ret; } static void sqlite3Fts5IndexCloseReader(Fts5Index *p){  if( p->pReader ){  sqlite3_blob *pReader = p->pReader;  p->pReader = 0;  sqlite3_blob_close(pReader);  } } static Fts5Data *fts5DataRead(Fts5Index *p, i64 iRowid){  Fts5Data *pRet = 0;  if( p->rc==SQLITE_OK ){  int rc = SQLITE_OK;  if( p->pReader ){  sqlite3_blob *pBlob = p->pReader;  p->pReader = 0;  rc = sqlite3_blob_reopen(pBlob, iRowid);  assert( p->pReader==0 );  p->pReader = pBlob;  if( rc!=SQLITE_OK ){  sqlite3Fts5IndexCloseReader(p);  }  if( rc==SQLITE_ABORT ) rc = SQLITE_OK;  }  if( p->pReader==0 && rc==SQLITE_OK ){  Fts5Config *pConfig = p->pConfig;  rc = sqlite3_blob_open(pConfig->db,  pConfig->zDb, p->zDataTbl, "block", iRowid, 0, &p->pReader  );  }  if( rc==SQLITE_ERROR ) rc = FTS5_CORRUPT;  if( rc==SQLITE_OK ){  u8 *aOut = 0;  int nByte = sqlite3_blob_bytes(p->pReader);  sqlite3_int64 nAlloc = sizeof(Fts5Data) + nByte + FTS5_DATA_PADDING;  pRet = (Fts5Data*)sqlite3_malloc64(nAlloc);  if( pRet ){  pRet->nn = nByte;  aOut = pRet->p = (u8*)&pRet[1];  }else{  rc = SQLITE_NOMEM;  }  if( rc==SQLITE_OK ){  rc = sqlite3_blob_read(p->pReader, aOut, nByte, 0);  }  if( rc!=SQLITE_OK ){  sqlite3_free(pRet);  pRet = 0;  }else{  pRet->p[nByte] = 0x00;  pRet->p[nByte+1] = 0x00;  pRet->szLeaf = fts5GetU16(&pRet->p[2]);  }  }  p->rc = rc;  p->nRead++;  }  assert( (pRet==0)==(p->rc!=SQLITE_OK) );  return pRet; } static void fts5DataRelease(Fts5Data *pData){  sqlite3_free(pData); } static Fts5Data *fts5LeafRead(Fts5Index *p, i64 iRowid){  Fts5Data *pRet = fts5DataRead(p, iRowid);  if( pRet ){  if( pRet->nn<4 || pRet->szLeaf>pRet->nn ){  p->rc = FTS5_CORRUPT;  fts5DataRelease(pRet);  pRet = 0;  }  }  return pRet; } static int fts5IndexPrepareStmt(  Fts5Index *p,  sqlite3_stmt **ppStmt,  char *zSql ){  if( p->rc==SQLITE_OK ){  if( zSql ){  p->rc = sqlite3_prepare_v3(p->pConfig->db, zSql, -1,  SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_NO_VTAB,  ppStmt, 0);  }else{  p->rc = SQLITE_NOMEM;  }  }  sqlite3_free(zSql);  return p->rc; } static void fts5DataWrite(Fts5Index *p, i64 iRowid, const u8 *pData, int nData){  if( p->rc!=SQLITE_OK ) return;  if( p->pWriter==0 ){  Fts5Config *pConfig = p->pConfig;  fts5IndexPrepareStmt(p, &p->pWriter, sqlite3_mprintf(  "REPLACE INTO '%q'.'%q_data'(id, block) VALUES(?,?)",  pConfig->zDb, pConfig->zName  ));  if( p->rc ) return;  }  sqlite3_bind_int64(p->pWriter, 1, iRowid);  sqlite3_bind_blob(p->pWriter, 2, pData, nData, SQLITE_STATIC);  sqlite3_step(p->pWriter);  p->rc = sqlite3_reset(p->pWriter);  sqlite3_bind_null(p->pWriter, 2); } static void fts5DataDelete(Fts5Index *p, i64 iFirst, i64 iLast){  if( p->rc!=SQLITE_OK ) return;  if( p->pDeleter==0 ){  Fts5Config *pConfig = p->pConfig;  char *zSql = sqlite3_mprintf(  "DELETE FROM '%q'.'%q_data' WHERE id>=? AND id<=?",  pConfig->zDb, pConfig->zName  );  if( fts5IndexPrepareStmt(p, &p->pDeleter, zSql) ) return;  }  sqlite3_bind_int64(p->pDeleter, 1, iFirst);  sqlite3_bind_int64(p->pDeleter, 2, iLast);  sqlite3_step(p->pDeleter);  p->rc = sqlite3_reset(p->pDeleter); } static void fts5DataRemoveSegment(Fts5Index *p, int iSegid){  i64 iFirst = FTS5_SEGMENT_ROWID(iSegid, 0);  i64 iLast = FTS5_SEGMENT_ROWID(iSegid+1, 0)-1;  fts5DataDelete(p, iFirst, iLast);  if( p->pIdxDeleter==0 ){  Fts5Config *pConfig = p->pConfig;  fts5IndexPrepareStmt(p, &p->pIdxDeleter, sqlite3_mprintf(  "DELETE FROM '%q'.'%q_idx' WHERE segid=?",  pConfig->zDb, pConfig->zName  ));  }  if( p->rc==SQLITE_OK ){  sqlite3_bind_int(p->pIdxDeleter, 1, iSegid);  sqlite3_step(p->pIdxDeleter);  p->rc = sqlite3_reset(p->pIdxDeleter);  } } static void fts5StructureRelease(Fts5Structure *pStruct){  if( pStruct && 0>=(--pStruct->nRef) ){  int i;  assert( pStruct->nRef==0 );  for(i=0; i<pStruct->nLevel; i++){  sqlite3_free(pStruct->aLevel[i].aSeg);  }  sqlite3_free(pStruct);  } } static void fts5StructureRef(Fts5Structure *pStruct){  pStruct->nRef++; } static void *sqlite3Fts5StructureRef(Fts5Index *p){  fts5StructureRef(p->pStruct);  return (void*)p->pStruct; } static void sqlite3Fts5StructureRelease(void *p){  if( p ){  fts5StructureRelease((Fts5Structure*)p);  } } static int sqlite3Fts5StructureTest(Fts5Index *p, void *pStruct){  if( p->pStruct!=(Fts5Structure*)pStruct ){  return SQLITE_ABORT;  }  return SQLITE_OK; } static void fts5StructureMakeWritable(int *pRc, Fts5Structure **pp){  Fts5Structure *p = *pp;  if( *pRc==SQLITE_OK && p->nRef>1 ){  i64 nByte = sizeof(Fts5Structure)+(p->nLevel-1)*sizeof(Fts5StructureLevel);  Fts5Structure *pNew;  pNew = (Fts5Structure*)sqlite3Fts5MallocZero(pRc, nByte);  if( pNew ){  int i;  memcpy(pNew, p, nByte);  for(i=0; i<p->nLevel; i++) pNew->aLevel[i].aSeg = 0;  for(i=0; i<p->nLevel; i++){  Fts5StructureLevel *pLvl = &pNew->aLevel[i];  nByte = sizeof(Fts5StructureSegment) * pNew->aLevel[i].nSeg;  pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(pRc, nByte);  if( pLvl->aSeg==0 ){  for(i=0; i<p->nLevel; i++){  sqlite3_free(pNew->aLevel[i].aSeg);  }  sqlite3_free(pNew);  return;  }  memcpy(pLvl->aSeg, p->aLevel[i].aSeg, nByte);  }  p->nRef--;  pNew->nRef = 1;  }  *pp = pNew;  } } static int fts5StructureDecode(  const u8 *pData,  int nData,  int *piCookie,  Fts5Structure **ppOut ){  int rc = SQLITE_OK;  int i = 0;  int iLvl;  int nLevel = 0;  int nSegment = 0;  sqlite3_int64 nByte;  Fts5Structure *pRet = 0;  if( piCookie ) *piCookie = sqlite3Fts5Get32(pData);  i = 4;  i += fts5GetVarint32(&pData[i], nLevel);  i += fts5GetVarint32(&pData[i], nSegment);  if( nLevel>FTS5_MAX_SEGMENT  || nLevel<0   || nSegment>FTS5_MAX_SEGMENT || nSegment<0  ){  return FTS5_CORRUPT;  }  nByte = (  sizeof(Fts5Structure) +  sizeof(Fts5StructureLevel) * (nLevel-1)  );  pRet = (Fts5Structure*)sqlite3Fts5MallocZero(&rc, nByte);  if( pRet ){  pRet->nRef = 1;  pRet->nLevel = nLevel;  pRet->nSegment = nSegment;  i += sqlite3Fts5GetVarint(&pData[i], &pRet->nWriteCounter);  for(iLvl=0; rc==SQLITE_OK && iLvl<nLevel; iLvl++){  Fts5StructureLevel *pLvl = &pRet->aLevel[iLvl];  int nTotal = 0;  int iSeg;  if( i>=nData ){  rc = FTS5_CORRUPT;  }else{  i += fts5GetVarint32(&pData[i], pLvl->nMerge);  i += fts5GetVarint32(&pData[i], nTotal);  if( nTotal<pLvl->nMerge ) rc = FTS5_CORRUPT;  pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(&rc,  nTotal * sizeof(Fts5StructureSegment)  );  nSegment -= nTotal;  }  if( rc==SQLITE_OK ){  pLvl->nSeg = nTotal;  for(iSeg=0; iSeg<nTotal; iSeg++){  Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];  if( i>=nData ){  rc = FTS5_CORRUPT;  break;  }  i += fts5GetVarint32(&pData[i], pSeg->iSegid);  i += fts5GetVarint32(&pData[i], pSeg->pgnoFirst);  i += fts5GetVarint32(&pData[i], pSeg->pgnoLast);  if( pSeg->pgnoLast<pSeg->pgnoFirst ){  rc = FTS5_CORRUPT;  break;  }  }  if( iLvl>0 && pLvl[-1].nMerge && nTotal==0 ) rc = FTS5_CORRUPT;  if( iLvl==nLevel-1 && pLvl->nMerge ) rc = FTS5_CORRUPT;  }  }  if( nSegment!=0 && rc==SQLITE_OK ) rc = FTS5_CORRUPT;  if( rc!=SQLITE_OK ){  fts5StructureRelease(pRet);  pRet = 0;  }  }  *ppOut = pRet;  return rc; } static void fts5StructureAddLevel(int *pRc, Fts5Structure **ppStruct){  fts5StructureMakeWritable(pRc, ppStruct);  if( *pRc==SQLITE_OK ){  Fts5Structure *pStruct = *ppStruct;  int nLevel = pStruct->nLevel;  sqlite3_int64 nByte = (  sizeof(Fts5Structure) +  sizeof(Fts5StructureLevel) * (nLevel+1)  );  pStruct = sqlite3_realloc64(pStruct, nByte);  if( pStruct ){  memset(&pStruct->aLevel[nLevel], 0, sizeof(Fts5StructureLevel));  pStruct->nLevel++;  *ppStruct = pStruct;  }else{  *pRc = SQLITE_NOMEM;  }  } } static void fts5StructureExtendLevel(  int *pRc,  Fts5Structure *pStruct,  int iLvl,  int nExtra,  int bInsert ){  if( *pRc==SQLITE_OK ){  Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];  Fts5StructureSegment *aNew;  sqlite3_int64 nByte;  nByte = (pLvl->nSeg + nExtra) * sizeof(Fts5StructureSegment);  aNew = sqlite3_realloc64(pLvl->aSeg, nByte);  if( aNew ){  if( bInsert==0 ){  memset(&aNew[pLvl->nSeg], 0, sizeof(Fts5StructureSegment) * nExtra);  }else{  int nMove = pLvl->nSeg * sizeof(Fts5StructureSegment);  memmove(&aNew[nExtra], aNew, nMove);  memset(aNew, 0, sizeof(Fts5StructureSegment) * nExtra);  }  pLvl->aSeg = aNew;  }else{  *pRc = SQLITE_NOMEM;  }  } } static Fts5Structure *fts5StructureReadUncached(Fts5Index *p){  Fts5Structure *pRet = 0;  Fts5Config *pConfig = p->pConfig;  int iCookie;  Fts5Data *pData;  pData = fts5DataRead(p, FTS5_STRUCTURE_ROWID);  if( p->rc==SQLITE_OK ){  memset(&pData->p[pData->nn], 0, FTS5_DATA_PADDING);  p->rc = fts5StructureDecode(pData->p, pData->nn, &iCookie, &pRet);  if( p->rc==SQLITE_OK && (pConfig->pgsz==0 || pConfig->iCookie!=iCookie) ){  p->rc = sqlite3Fts5ConfigLoad(pConfig, iCookie);  }  fts5DataRelease(pData);  if( p->rc!=SQLITE_OK ){  fts5StructureRelease(pRet);  pRet = 0;  }  }  return pRet; } static i64 fts5IndexDataVersion(Fts5Index *p){  i64 iVersion = 0;  if( p->rc==SQLITE_OK ){  if( p->pDataVersion==0 ){  p->rc = fts5IndexPrepareStmt(p, &p->pDataVersion,  sqlite3_mprintf("PRAGMA %Q.data_version", p->pConfig->zDb)  );  if( p->rc ) return 0;  }  if( SQLITE_ROW==sqlite3_step(p->pDataVersion) ){  iVersion = sqlite3_column_int64(p->pDataVersion, 0);  }  p->rc = sqlite3_reset(p->pDataVersion);  }  return iVersion; } static Fts5Structure *fts5StructureRead(Fts5Index *p){  if( p->pStruct==0 ){  p->iStructVersion = fts5IndexDataVersion(p);  if( p->rc==SQLITE_OK ){  p->pStruct = fts5StructureReadUncached(p);  }  }
#if 0
 else{  Fts5Structure *pTest = fts5StructureReadUncached(p);  if( pTest ){  int i, j;  assert_nc( p->pStruct->nSegment==pTest->nSegment );  assert_nc( p->pStruct->nLevel==pTest->nLevel );  for(i=0; i<pTest->nLevel; i++){  assert_nc( p->pStruct->aLevel[i].nMerge==pTest->aLevel[i].nMerge );  assert_nc( p->pStruct->aLevel[i].nSeg==pTest->aLevel[i].nSeg );  for(j=0; j<pTest->aLevel[i].nSeg; j++){  Fts5StructureSegment *p1 = &pTest->aLevel[i].aSeg[j];  Fts5StructureSegment *p2 = &p->pStruct->aLevel[i].aSeg[j];  assert_nc( p1->iSegid==p2->iSegid );  assert_nc( p1->pgnoFirst==p2->pgnoFirst );  assert_nc( p1->pgnoLast==p2->pgnoLast );  }  }  fts5StructureRelease(pTest);  }  }
#endif
 if( p->rc!=SQLITE_OK ) return 0;  assert( p->iStructVersion!=0 );  assert( p->pStruct!=0 );  fts5StructureRef(p->pStruct);  return p->pStruct; } static void fts5StructureInvalidate(Fts5Index *p){  if( p->pStruct ){  fts5StructureRelease(p->pStruct);  p->pStruct = 0;  } }
#ifdef SQLITE_DEBUG
static int fts5StructureCountSegments(Fts5Structure *pStruct){  int nSegment = 0;  if( pStruct ){  int iLvl;  for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){  nSegment += pStruct->aLevel[iLvl].nSeg;  }  }  return nSegment; }
#endif
#define fts5BufferSafeAppendBlob(pBuf, pBlob, nBlob) {   assert( (pBuf)->nSpace>=((pBuf)->n+nBlob) );   memcpy(&(pBuf)->p[(pBuf)->n], pBlob, nBlob);   (pBuf)->n += nBlob; }

#define fts5BufferSafeAppendVarint(pBuf, iVal) {  (pBuf)->n += sqlite3Fts5PutVarint(&(pBuf)->p[(pBuf)->n], (iVal));  assert( (pBuf)->nSpace>=(pBuf)->n ); }

static void fts5StructureWrite(Fts5Index *p, Fts5Structure *pStruct){  if( p->rc==SQLITE_OK ){  Fts5Buffer buf;  int iLvl;  int iCookie;  assert( pStruct->nSegment==fts5StructureCountSegments(pStruct) );  memset(&buf, 0, sizeof(Fts5Buffer));  iCookie = p->pConfig->iCookie;  if( iCookie<0 ) iCookie = 0;  if( 0==sqlite3Fts5BufferSize(&p->rc, &buf, 4+9+9+9) ){  sqlite3Fts5Put32(buf.p, iCookie);  buf.n = 4;  fts5BufferSafeAppendVarint(&buf, pStruct->nLevel);  fts5BufferSafeAppendVarint(&buf, pStruct->nSegment);  fts5BufferSafeAppendVarint(&buf, (i64)pStruct->nWriteCounter);  }  for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){  int iSeg;  Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];  fts5BufferAppendVarint(&p->rc, &buf, pLvl->nMerge);  fts5BufferAppendVarint(&p->rc, &buf, pLvl->nSeg);  assert( pLvl->nMerge<=pLvl->nSeg );  for(iSeg=0; iSeg<pLvl->nSeg; iSeg++){  fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].iSegid);  fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoFirst);  fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoLast);  }  }  fts5DataWrite(p, FTS5_STRUCTURE_ROWID, buf.p, buf.n);  fts5BufferFree(&buf);  } }
#if 0
static void fts5DebugStructure(int*,Fts5Buffer*,Fts5Structure*); static void fts5PrintStructure(const char *zCaption, Fts5Structure *pStruct){  int rc = SQLITE_OK;  Fts5Buffer buf;  memset(&buf, 0, sizeof(buf));  fts5DebugStructure(&rc, &buf, pStruct);  fprintf(stdout, "%s: %s\n", zCaption, buf.p);  fflush(stdout);  fts5BufferFree(&buf); }
#else
# define fts5PrintStructure(x,y)
#endif
static int fts5SegmentSize(Fts5StructureSegment *pSeg){  return 1 + pSeg->pgnoLast - pSeg->pgnoFirst; } static void fts5StructurePromoteTo(  Fts5Index *p,  int iPromote,  int szPromote,  Fts5Structure *pStruct ){  int il, is;  Fts5StructureLevel *pOut = &pStruct->aLevel[iPromote];  if( pOut->nMerge==0 ){  for(il=iPromote+1; il<pStruct->nLevel; il++){  Fts5StructureLevel *pLvl = &pStruct->aLevel[il];  if( pLvl->nMerge ) return;  for(is=pLvl->nSeg-1; is>=0; is--){  int sz = fts5SegmentSize(&pLvl->aSeg[is]);  if( sz>szPromote ) return;  fts5StructureExtendLevel(&p->rc, pStruct, iPromote, 1, 1);  if( p->rc ) return;  memcpy(pOut->aSeg, &pLvl->aSeg[is], sizeof(Fts5StructureSegment));  pOut->nSeg++;  pLvl->nSeg--;  }  }  } } static void fts5StructurePromote(  Fts5Index *p,  int iLvl,  Fts5Structure *pStruct ){  if( p->rc==SQLITE_OK ){  int iTst;  int iPromote = -1;  int szPromote = 0;  Fts5StructureSegment *pSeg;  int szSeg;  int nSeg = pStruct->aLevel[iLvl].nSeg;  if( nSeg==0 ) return;  pSeg = &pStruct->aLevel[iLvl].aSeg[pStruct->aLevel[iLvl].nSeg-1];  szSeg = (1 + pSeg->pgnoLast - pSeg->pgnoFirst);  for(iTst=iLvl-1; iTst>=0 && pStruct->aLevel[iTst].nSeg==0; iTst--);  if( iTst>=0 ){  int i;  int szMax = 0;  Fts5StructureLevel *pTst = &pStruct->aLevel[iTst];  assert( pTst->nMerge==0 );  for(i=0; i<pTst->nSeg; i++){  int sz = pTst->aSeg[i].pgnoLast - pTst->aSeg[i].pgnoFirst + 1;  if( sz>szMax ) szMax = sz;  }  if( szMax>=szSeg ){  iPromote = iTst;  szPromote = szMax;  }  }  if( iPromote<0 ){  iPromote = iLvl;  szPromote = szSeg;  }  fts5StructurePromoteTo(p, iPromote, szPromote, pStruct);  } } static int fts5DlidxLvlNext(Fts5DlidxLvl *pLvl){  Fts5Data *pData = pLvl->pData;  if( pLvl->iOff==0 ){  assert( pLvl->bEof==0 );  pLvl->iOff = 1;  pLvl->iOff += fts5GetVarint32(&pData->p[1], pLvl->iLeafPgno);  pLvl->iOff += fts5GetVarint(&pData->p[pLvl->iOff], (u64*)&pLvl->iRowid);  pLvl->iFirstOff = pLvl->iOff;  }else{  int iOff;  for(iOff=pLvl->iOff; iOff<pData->nn; iOff++){  if( pData->p[iOff] ) break;  }  if( iOff<pData->nn ){  i64 iVal;  pLvl->iLeafPgno += (iOff - pLvl->iOff) + 1;  iOff += fts5GetVarint(&pData->p[iOff], (u64*)&iVal);  pLvl->iRowid += iVal;  pLvl->iOff = iOff;  }else{  pLvl->bEof = 1;  }  }  return pLvl->bEof; } static int fts5DlidxIterNextR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl){  Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];  assert( iLvl<pIter->nLvl );  if( fts5DlidxLvlNext(pLvl) ){  if( (iLvl+1) < pIter->nLvl ){  fts5DlidxIterNextR(p, pIter, iLvl+1);  if( pLvl[1].bEof==0 ){  fts5DataRelease(pLvl->pData);  memset(pLvl, 0, sizeof(Fts5DlidxLvl));  pLvl->pData = fts5DataRead(p,  FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)  );  if( pLvl->pData ) fts5DlidxLvlNext(pLvl);  }  }  }  return pIter->aLvl[0].bEof; } static int fts5DlidxIterNext(Fts5Index *p, Fts5DlidxIter *pIter){  return fts5DlidxIterNextR(p, pIter, 0); } static int fts5DlidxIterFirst(Fts5DlidxIter *pIter){  int i;  for(i=0; i<pIter->nLvl; i++){  fts5DlidxLvlNext(&pIter->aLvl[i]);  }  return pIter->aLvl[0].bEof; } static int fts5DlidxIterEof(Fts5Index *p, Fts5DlidxIter *pIter){  return p->rc!=SQLITE_OK || pIter->aLvl[0].bEof; } static void fts5DlidxIterLast(Fts5Index *p, Fts5DlidxIter *pIter){  int i;  for(i=pIter->nLvl-1; p->rc==SQLITE_OK && i>=0; i--){  Fts5DlidxLvl *pLvl = &pIter->aLvl[i];  while( fts5DlidxLvlNext(pLvl)==0 );  pLvl->bEof = 0;  if( i>0 ){  Fts5DlidxLvl *pChild = &pLvl[-1];  fts5DataRelease(pChild->pData);  memset(pChild, 0, sizeof(Fts5DlidxLvl));  pChild->pData = fts5DataRead(p,  FTS5_DLIDX_ROWID(pIter->iSegid, i-1, pLvl->iLeafPgno)  );  }  } } static int fts5DlidxLvlPrev(Fts5DlidxLvl *pLvl){  int iOff = pLvl->iOff;  assert( pLvl->bEof==0 );  if( iOff<=pLvl->iFirstOff ){  pLvl->bEof = 1;  }else{  u8 *a = pLvl->pData->p;  i64 iVal;  int iLimit;  int ii;  int nZero = 0;  iLimit = (iOff>9 ? iOff-9 : 0);  for(iOff--; iOff>iLimit; iOff--){  if( (a[iOff-1] & 0x80)==0 ) break;  }  fts5GetVarint(&a[iOff], (u64*)&iVal);  pLvl->iRowid -= iVal;  pLvl->iLeafPgno--;  for(ii=iOff-1; ii>=pLvl->iFirstOff && a[ii]==0x00; ii--){  nZero++;  }  if( ii>=pLvl->iFirstOff && (a[ii] & 0x80) ){  int bZero = 0;  if( (ii-8)>=pLvl->iFirstOff ){  int j;  for(j=1; j<=8 && (a[ii-j] & 0x80); j++);  bZero = (j>8);  }  if( bZero==0 ) nZero--;  }  pLvl->iLeafPgno -= nZero;  pLvl->iOff = iOff - nZero;  }  return pLvl->bEof; } static int fts5DlidxIterPrevR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl){  Fts5DlidxLvl *pLvl = &pIter->aLvl[iLvl];  assert( iLvl<pIter->nLvl );  if( fts5DlidxLvlPrev(pLvl) ){  if( (iLvl+1) < pIter->nLvl ){  fts5DlidxIterPrevR(p, pIter, iLvl+1);  if( pLvl[1].bEof==0 ){  fts5DataRelease(pLvl->pData);  memset(pLvl, 0, sizeof(Fts5DlidxLvl));  pLvl->pData = fts5DataRead(p,  FTS5_DLIDX_ROWID(pIter->iSegid, iLvl, pLvl[1].iLeafPgno)  );  if( pLvl->pData ){  while( fts5DlidxLvlNext(pLvl)==0 );  pLvl->bEof = 0;  }  }  }  }  return pIter->aLvl[0].bEof; } static int fts5DlidxIterPrev(Fts5Index *p, Fts5DlidxIter *pIter){  return fts5DlidxIterPrevR(p, pIter, 0); } static void fts5DlidxIterFree(Fts5DlidxIter *pIter){  if( pIter ){  int i;  for(i=0; i<pIter->nLvl; i++){  fts5DataRelease(pIter->aLvl[i].pData);  }  sqlite3_free(pIter);  } } static Fts5DlidxIter *fts5DlidxIterInit(  Fts5Index *p,  int bRev,  int iSegid,  int iLeafPg ){  Fts5DlidxIter *pIter = 0;  int i;  int bDone = 0;  for(i=0; p->rc==SQLITE_OK && bDone==0; i++){  sqlite3_int64 nByte = sizeof(Fts5DlidxIter) + i * sizeof(Fts5DlidxLvl);  Fts5DlidxIter *pNew;  pNew = (Fts5DlidxIter*)sqlite3_realloc64(pIter, nByte);  if( pNew==0 ){  p->rc = SQLITE_NOMEM;  }else{  i64 iRowid = FTS5_DLIDX_ROWID(iSegid, i, iLeafPg);  Fts5DlidxLvl *pLvl = &pNew->aLvl[i];  pIter = pNew;  memset(pLvl, 0, sizeof(Fts5DlidxLvl));  pLvl->pData = fts5DataRead(p, iRowid);  if( pLvl->pData && (pLvl->pData->p[0] & 0x0001)==0 ){  bDone = 1;  }  pIter->nLvl = i+1;  }  }  if( p->rc==SQLITE_OK ){  pIter->iSegid = iSegid;  if( bRev==0 ){  fts5DlidxIterFirst(pIter);  }else{  fts5DlidxIterLast(p, pIter);  }  }  if( p->rc!=SQLITE_OK ){  fts5DlidxIterFree(pIter);  pIter = 0;  }  return pIter; } static i64 fts5DlidxIterRowid(Fts5DlidxIter *pIter){  return pIter->aLvl[0].iRowid; } static int fts5DlidxIterPgno(Fts5DlidxIter *pIter){  return pIter->aLvl[0].iLeafPgno; } static void fts5SegIterNextPage(  Fts5Index *p,  Fts5SegIter *pIter ){  Fts5Data *pLeaf;  Fts5StructureSegment *pSeg = pIter->pSeg;  fts5DataRelease(pIter->pLeaf);  pIter->iLeafPgno++;  if( pIter->pNextLeaf ){  pIter->pLeaf = pIter->pNextLeaf;  pIter->pNextLeaf = 0;  }else if( pIter->iLeafPgno<=pSeg->pgnoLast ){  pIter->pLeaf = fts5LeafRead(p,  FTS5_SEGMENT_ROWID(pSeg->iSegid, pIter->iLeafPgno)  );  }else{  pIter->pLeaf = 0;  }  pLeaf = pIter->pLeaf;  if( pLeaf ){  pIter->iPgidxOff = pLeaf->szLeaf;  if( fts5LeafIsTermless(pLeaf) ){  pIter->iEndofDoclist = pLeaf->nn+1;  }else{  pIter->iPgidxOff += fts5GetVarint32(&pLeaf->p[pIter->iPgidxOff],  pIter->iEndofDoclist  );  }  } } static int fts5GetPoslistSize(const u8 *p, int *pnSz, int *pbDel){  int nSz;  int n = 0;  fts5FastGetVarint32(p, n, nSz);  assert_nc( nSz>=0 );  *pnSz = nSz/2;  *pbDel = nSz & 0x0001;  return n; } static void fts5SegIterLoadNPos(Fts5Index *p, Fts5SegIter *pIter){  if( p->rc==SQLITE_OK ){  int iOff = pIter->iLeafOffset;  ASSERT_SZLEAF_OK(pIter->pLeaf);  if( p->pConfig->eDetail==FTS5_DETAIL_NONE ){  int iEod = MIN(pIter->iEndofDoclist, pIter->pLeaf->szLeaf);  pIter->bDel = 0;  pIter->nPos = 1;  if( iOff<iEod && pIter->pLeaf->p[iOff]==0 ){  pIter->bDel = 1;  iOff++;  if( iOff<iEod && pIter->pLeaf->p[iOff]==0 ){  pIter->nPos = 1;  iOff++;  }else{  pIter->nPos = 0;  }  }  }else{  int nSz;  fts5FastGetVarint32(pIter->pLeaf->p, iOff, nSz);  pIter->bDel = (nSz & 0x0001);  pIter->nPos = nSz>>1;  assert_nc( pIter->nPos>=0 );  }  pIter->iLeafOffset = iOff;  } } static void fts5SegIterLoadRowid(Fts5Index *p, Fts5SegIter *pIter){  u8 *a = pIter->pLeaf->p;  i64 iOff = pIter->iLeafOffset;  ASSERT_SZLEAF_OK(pIter->pLeaf);  if( iOff>=pIter->pLeaf->szLeaf ){  fts5SegIterNextPage(p, pIter);  if( pIter->pLeaf==0 ){  if( p->rc==SQLITE_OK ) p->rc = FTS5_CORRUPT;  return;  }  iOff = 4;  a = pIter->pLeaf->p;  }  iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);  pIter->iLeafOffset = iOff; } static void fts5SegIterLoadTerm(Fts5Index *p, Fts5SegIter *pIter, int nKeep){  u8 *a = pIter->pLeaf->p;  i64 iOff = pIter->iLeafOffset;  int nNew;  iOff += fts5GetVarint32(&a[iOff], nNew);  if( iOff+nNew>pIter->pLeaf->szLeaf || nKeep>pIter->term.n || nNew==0 ){  p->rc = FTS5_CORRUPT;  return;  }  pIter->term.n = nKeep;  fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);  assert( pIter->term.n<=pIter->term.nSpace );  iOff += nNew;  pIter->iTermLeafOffset = iOff;  pIter->iTermLeafPgno = pIter->iLeafPgno;  pIter->iLeafOffset = iOff;  if( pIter->iPgidxOff>=pIter->pLeaf->nn ){  pIter->iEndofDoclist = pIter->pLeaf->nn+1;  }else{  int nExtra;  pIter->iPgidxOff += fts5GetVarint32(&a[pIter->iPgidxOff], nExtra);  pIter->iEndofDoclist += nExtra;  }  fts5SegIterLoadRowid(p, pIter); } static void fts5SegIterNext(Fts5Index*, Fts5SegIter*, int*); static void fts5SegIterNext_Reverse(Fts5Index*, Fts5SegIter*, int*); static void fts5SegIterNext_None(Fts5Index*, Fts5SegIter*, int*); static void fts5SegIterSetNext(Fts5Index *p, Fts5SegIter *pIter){  if( pIter->flags & FTS5_SEGITER_REVERSE ){  pIter->xNext = fts5SegIterNext_Reverse;  }else if( p->pConfig->eDetail==FTS5_DETAIL_NONE ){  pIter->xNext = fts5SegIterNext_None;  }else{  pIter->xNext = fts5SegIterNext;  } } static void fts5SegIterInit(  Fts5Index *p,  Fts5StructureSegment *pSeg,  Fts5SegIter *pIter ){  if( pSeg->pgnoFirst==0 ){  assert( pIter->pLeaf==0 );  return;  }  if( p->rc==SQLITE_OK ){  memset(pIter, 0, sizeof(*pIter));  fts5SegIterSetNext(p, pIter);  pIter->pSeg = pSeg;  pIter->iLeafPgno = pSeg->pgnoFirst-1;  fts5SegIterNextPage(p, pIter);  }  if( p->rc==SQLITE_OK ){  pIter->iLeafOffset = 4;  assert( pIter->pLeaf!=0 );  assert_nc( pIter->pLeaf->nn>4 );  assert_nc( fts5LeafFirstTermOff(pIter->pLeaf)==4 );  pIter->iPgidxOff = pIter->pLeaf->szLeaf+1;  fts5SegIterLoadTerm(p, pIter, 0);  fts5SegIterLoadNPos(p, pIter);  } } static void fts5SegIterReverseInitPage(Fts5Index *p, Fts5SegIter *pIter){  int eDetail = p->pConfig->eDetail;  int n = pIter->pLeaf->szLeaf;  int i = pIter->iLeafOffset;  u8 *a = pIter->pLeaf->p;  int iRowidOffset = 0;  if( n>pIter->iEndofDoclist ){  n = pIter->iEndofDoclist;  }  ASSERT_SZLEAF_OK(pIter->pLeaf);  while( 1 ){  u64 iDelta = 0;  if( eDetail==FTS5_DETAIL_NONE ){  if( i<n && a[i]==0 ){  i++;  if( i<n && a[i]==0 ) i++;  }  }else{  int nPos;  int bDummy;  i += fts5GetPoslistSize(&a[i], &nPos, &bDummy);  i += nPos;  }  if( i>=n ) break;  i += fts5GetVarint(&a[i], &iDelta);  pIter->iRowid += iDelta;  if( iRowidOffset>=pIter->nRowidOffset ){  int nNew = pIter->nRowidOffset + 8;  int *aNew = (int*)sqlite3_realloc64(pIter->aRowidOffset,nNew*sizeof(int));  if( aNew==0 ){  p->rc = SQLITE_NOMEM;  break;  }  pIter->aRowidOffset = aNew;  pIter->nRowidOffset = nNew;  }  pIter->aRowidOffset[iRowidOffset++] = pIter->iLeafOffset;  pIter->iLeafOffset = i;  }  pIter->iRowidOffset = iRowidOffset;  fts5SegIterLoadNPos(p, pIter); } static void fts5SegIterReverseNewPage(Fts5Index *p, Fts5SegIter *pIter){  assert( pIter->flags & FTS5_SEGITER_REVERSE );  assert( pIter->flags & FTS5_SEGITER_ONETERM );  fts5DataRelease(pIter->pLeaf);  pIter->pLeaf = 0;  while( p->rc==SQLITE_OK && pIter->iLeafPgno>pIter->iTermLeafPgno ){  Fts5Data *pNew;  pIter->iLeafPgno--;  pNew = fts5DataRead(p, FTS5_SEGMENT_ROWID(  pIter->pSeg->iSegid, pIter->iLeafPgno  ));  if( pNew ){  if( pIter->iLeafPgno==pIter->iTermLeafPgno ){  assert( pIter->pLeaf==0 );  if( pIter->iTermLeafOffset<pNew->szLeaf ){  pIter->pLeaf = pNew;  pIter->iLeafOffset = pIter->iTermLeafOffset;  }  }else{  int iRowidOff;  iRowidOff = fts5LeafFirstRowidOff(pNew);  if( iRowidOff ){  if( iRowidOff>=pNew->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  pIter->pLeaf = pNew;  pIter->iLeafOffset = iRowidOff;  }  }  }  if( pIter->pLeaf ){  u8 *a = &pIter->pLeaf->p[pIter->iLeafOffset];  pIter->iLeafOffset += fts5GetVarint(a, (u64*)&pIter->iRowid);  break;  }else{  fts5DataRelease(pNew);  }  }  }  if( pIter->pLeaf ){  pIter->iEndofDoclist = pIter->pLeaf->nn+1;  fts5SegIterReverseInitPage(p, pIter);  } } static int fts5MultiIterIsEmpty(Fts5Index *p, Fts5Iter *pIter){  Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];  return (p->rc==SQLITE_OK && pSeg->pLeaf && pSeg->nPos==0); } static void fts5SegIterNext_Reverse(  Fts5Index *p,  Fts5SegIter *pIter,  int *pbUnused ){  assert( pIter->flags & FTS5_SEGITER_REVERSE );  assert( pIter->pNextLeaf==0 );  UNUSED_PARAM(pbUnused);  if( pIter->iRowidOffset>0 ){  u8 *a = pIter->pLeaf->p;  int iOff;  u64 iDelta;  pIter->iRowidOffset--;  pIter->iLeafOffset = pIter->aRowidOffset[pIter->iRowidOffset];  fts5SegIterLoadNPos(p, pIter);  iOff = pIter->iLeafOffset;  if( p->pConfig->eDetail!=FTS5_DETAIL_NONE ){  iOff += pIter->nPos;  }  fts5GetVarint(&a[iOff], &iDelta);  pIter->iRowid -= iDelta;  }else{  fts5SegIterReverseNewPage(p, pIter);  } } static void fts5SegIterNext_None(  Fts5Index *p,  Fts5SegIter *pIter,  int *pbNewTerm ){  int iOff;  assert( p->rc==SQLITE_OK );  assert( (pIter->flags & FTS5_SEGITER_REVERSE)==0 );  assert( p->pConfig->eDetail==FTS5_DETAIL_NONE );  ASSERT_SZLEAF_OK(pIter->pLeaf);  iOff = pIter->iLeafOffset;  if( pIter->pSeg && iOff>=pIter->pLeaf->szLeaf ){  fts5SegIterNextPage(p, pIter);  if( p->rc || pIter->pLeaf==0 ) return;  pIter->iRowid = 0;  iOff = 4;  }  if( iOff<pIter->iEndofDoclist ){  i64 iDelta;  iOff += sqlite3Fts5GetVarint(&pIter->pLeaf->p[iOff], (u64*)&iDelta);  pIter->iLeafOffset = iOff;  pIter->iRowid += iDelta;  }else if( (pIter->flags & FTS5_SEGITER_ONETERM)==0 ){  if( pIter->pSeg ){  int nKeep = 0;  if( iOff!=fts5LeafFirstTermOff(pIter->pLeaf) ){  iOff += fts5GetVarint32(&pIter->pLeaf->p[iOff], nKeep);  }  pIter->iLeafOffset = iOff;  fts5SegIterLoadTerm(p, pIter, nKeep);  }else{  const u8 *pList = 0;  const char *zTerm = 0;  int nList;  sqlite3Fts5HashScanNext(p->pHash);  sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);  if( pList==0 ) goto next_none_eof;  pIter->pLeaf->p = (u8*)pList;  pIter->pLeaf->nn = nList;  pIter->pLeaf->szLeaf = nList;  pIter->iEndofDoclist = nList;  sqlite3Fts5BufferSet(&p->rc,&pIter->term, (int)strlen(zTerm), (u8*)zTerm);  pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);  }  if( pbNewTerm ) *pbNewTerm = 1;  }else{  goto next_none_eof;  }  fts5SegIterLoadNPos(p, pIter);  return;  next_none_eof:  fts5DataRelease(pIter->pLeaf);  pIter->pLeaf = 0; } static void fts5SegIterNext(  Fts5Index *p,  Fts5SegIter *pIter,  int *pbNewTerm ){  Fts5Data *pLeaf = pIter->pLeaf;  int iOff;  int bNewTerm = 0;  int nKeep = 0;  u8 *a;  int n;  assert( pbNewTerm==0 || *pbNewTerm==0 );  assert( p->pConfig->eDetail!=FTS5_DETAIL_NONE );  a = pLeaf->p;  n = pLeaf->szLeaf;  ASSERT_SZLEAF_OK(pLeaf);  iOff = pIter->iLeafOffset + pIter->nPos;  if( iOff<n ){  assert_nc( iOff<=pIter->iEndofDoclist );  if( iOff>=pIter->iEndofDoclist ){  bNewTerm = 1;  if( iOff!=fts5LeafFirstTermOff(pLeaf) ){  iOff += fts5GetVarint32(&a[iOff], nKeep);  }  }else{  u64 iDelta;  iOff += sqlite3Fts5GetVarint(&a[iOff], &iDelta);  pIter->iRowid += iDelta;  assert_nc( iDelta>0 );  }  pIter->iLeafOffset = iOff;  }else if( pIter->pSeg==0 ){  const u8 *pList = 0;  const char *zTerm = 0;  int nList = 0;  assert( (pIter->flags & FTS5_SEGITER_ONETERM) || pbNewTerm );  if( 0==(pIter->flags & FTS5_SEGITER_ONETERM) ){  sqlite3Fts5HashScanNext(p->pHash);  sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);  }  if( pList==0 ){  fts5DataRelease(pIter->pLeaf);  pIter->pLeaf = 0;  }else{  pIter->pLeaf->p = (u8*)pList;  pIter->pLeaf->nn = nList;  pIter->pLeaf->szLeaf = nList;  pIter->iEndofDoclist = nList+1;  sqlite3Fts5BufferSet(&p->rc, &pIter->term, (int)strlen(zTerm),  (u8*)zTerm);  pIter->iLeafOffset = fts5GetVarint(pList, (u64*)&pIter->iRowid);  *pbNewTerm = 1;  }  }else{  iOff = 0;  while( iOff==0 ){  fts5SegIterNextPage(p, pIter);  pLeaf = pIter->pLeaf;  if( pLeaf==0 ) break;  ASSERT_SZLEAF_OK(pLeaf);  if( (iOff = fts5LeafFirstRowidOff(pLeaf)) && iOff<pLeaf->szLeaf ){  iOff += sqlite3Fts5GetVarint(&pLeaf->p[iOff], (u64*)&pIter->iRowid);  pIter->iLeafOffset = iOff;  if( pLeaf->nn>pLeaf->szLeaf ){  pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(  &pLeaf->p[pLeaf->szLeaf], pIter->iEndofDoclist  );  }  }  else if( pLeaf->nn>pLeaf->szLeaf ){  pIter->iPgidxOff = pLeaf->szLeaf + fts5GetVarint32(  &pLeaf->p[pLeaf->szLeaf], iOff  );  pIter->iLeafOffset = iOff;  pIter->iEndofDoclist = iOff;  bNewTerm = 1;  }  assert_nc( iOff<pLeaf->szLeaf );  if( iOff>pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  return;  }  }  }  if( pIter->pLeaf ){  if( bNewTerm ){  if( pIter->flags & FTS5_SEGITER_ONETERM ){  fts5DataRelease(pIter->pLeaf);  pIter->pLeaf = 0;  }else{  fts5SegIterLoadTerm(p, pIter, nKeep);  fts5SegIterLoadNPos(p, pIter);  if( pbNewTerm ) *pbNewTerm = 1;  }  }else{  int nSz;  assert_nc( pIter->iLeafOffset<=pIter->pLeaf->nn );  fts5FastGetVarint32(pIter->pLeaf->p, pIter->iLeafOffset, nSz);  pIter->bDel = (nSz & 0x0001);  pIter->nPos = nSz>>1;  assert_nc( pIter->nPos>=0 );  }  } }
#define SWAPVAL(T, a, b) { T tmp; tmp=a; a=b; b=tmp; }
#define fts5IndexSkipVarint(a, iOff) {  int iEnd = iOff+9;  while( (a[iOff++] & 0x80) && iOff<iEnd );  }

static void fts5SegIterReverse(Fts5Index *p, Fts5SegIter *pIter){  Fts5DlidxIter *pDlidx = pIter->pDlidx;  Fts5Data *pLast = 0;  int pgnoLast = 0;  if( pDlidx ){  int iSegid = pIter->pSeg->iSegid;  pgnoLast = fts5DlidxIterPgno(pDlidx);  pLast = fts5LeafRead(p, FTS5_SEGMENT_ROWID(iSegid, pgnoLast));  }else{  Fts5Data *pLeaf = pIter->pLeaf;  int iPoslist;  if( pIter->iTermLeafPgno==pIter->iLeafPgno ){  iPoslist = pIter->iTermLeafOffset;  }else{  iPoslist = 4;  }  fts5IndexSkipVarint(pLeaf->p, iPoslist);  pIter->iLeafOffset = iPoslist;  if( pIter->iEndofDoclist>=pLeaf->szLeaf ){  int pgno;  Fts5StructureSegment *pSeg = pIter->pSeg;  for(pgno=pIter->iLeafPgno+1; !p->rc && pgno<=pSeg->pgnoLast; pgno++){  i64 iAbs = FTS5_SEGMENT_ROWID(pSeg->iSegid, pgno);  Fts5Data *pNew = fts5LeafRead(p, iAbs);  if( pNew ){  int iRowid, bTermless;  iRowid = fts5LeafFirstRowidOff(pNew);  bTermless = fts5LeafIsTermless(pNew);  if( iRowid ){  SWAPVAL(Fts5Data*, pNew, pLast);  pgnoLast = pgno;  }  fts5DataRelease(pNew);  if( bTermless==0 ) break;  }  }  }  }  if( pLast ){  int iOff;  fts5DataRelease(pIter->pLeaf);  pIter->pLeaf = pLast;  pIter->iLeafPgno = pgnoLast;  iOff = fts5LeafFirstRowidOff(pLast);  if( iOff>pLast->szLeaf ){  p->rc = FTS5_CORRUPT;  return;  }  iOff += fts5GetVarint(&pLast->p[iOff], (u64*)&pIter->iRowid);  pIter->iLeafOffset = iOff;  if( fts5LeafIsTermless(pLast) ){  pIter->iEndofDoclist = pLast->nn+1;  }else{  pIter->iEndofDoclist = fts5LeafFirstTermOff(pLast);  }  }  fts5SegIterReverseInitPage(p, pIter); } static void fts5SegIterLoadDlidx(Fts5Index *p, Fts5SegIter *pIter){  int iSeg = pIter->pSeg->iSegid;  int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);  Fts5Data *pLeaf = pIter->pLeaf;  assert( pIter->flags & FTS5_SEGITER_ONETERM );  assert( pIter->pDlidx==0 );  if( pIter->iTermLeafPgno==pIter->iLeafPgno   && pIter->iEndofDoclist<pLeaf->szLeaf  ){  return;  }  pIter->pDlidx = fts5DlidxIterInit(p, bRev, iSeg, pIter->iTermLeafPgno); } static void fts5LeafSeek(  Fts5Index *p,  int bGe,  Fts5SegIter *pIter,  const u8 *pTerm, int nTerm ){  u32 iOff;  const u8 *a = pIter->pLeaf->p;  u32 n = (u32)pIter->pLeaf->nn;  u32 nMatch = 0;  u32 nKeep = 0;  u32 nNew = 0;  u32 iTermOff;  u32 iPgidx;  int bEndOfPage = 0;  assert( p->rc==SQLITE_OK );  iPgidx = (u32)pIter->pLeaf->szLeaf;  iPgidx += fts5GetVarint32(&a[iPgidx], iTermOff);  iOff = iTermOff;  if( iOff>n ){  p->rc = FTS5_CORRUPT;  return;  }  while( 1 ){  fts5FastGetVarint32(a, iOff, nNew);  if( nKeep<nMatch ){  goto search_failed;  }  assert( nKeep>=nMatch );  if( nKeep==nMatch ){  u32 nCmp;  u32 i;  nCmp = (u32)MIN(nNew, nTerm-nMatch);  for(i=0; i<nCmp; i++){  if( a[iOff+i]!=pTerm[nMatch+i] ) break;  }  nMatch += i;  if( (u32)nTerm==nMatch ){  if( i==nNew ){  goto search_success;  }else{  goto search_failed;  }  }else if( i<nNew && a[iOff+i]>pTerm[nMatch] ){  goto search_failed;  }  }  if( iPgidx>=n ){  bEndOfPage = 1;  break;  }  iPgidx += fts5GetVarint32(&a[iPgidx], nKeep);  iTermOff += nKeep;  iOff = iTermOff;  if( iOff>=n ){  p->rc = FTS5_CORRUPT;  return;  }  fts5FastGetVarint32(a, iOff, nKeep);  }  search_failed:  if( bGe==0 ){  fts5DataRelease(pIter->pLeaf);  pIter->pLeaf = 0;  return;  }else if( bEndOfPage ){  do {  fts5SegIterNextPage(p, pIter);  if( pIter->pLeaf==0 ) return;  a = pIter->pLeaf->p;  if( fts5LeafIsTermless(pIter->pLeaf)==0 ){  iPgidx = (u32)pIter->pLeaf->szLeaf;  iPgidx += fts5GetVarint32(&pIter->pLeaf->p[iPgidx], iOff);  if( iOff<4 || (i64)iOff>=pIter->pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  return;  }else{  nKeep = 0;  iTermOff = iOff;  n = (u32)pIter->pLeaf->nn;  iOff += fts5GetVarint32(&a[iOff], nNew);  break;  }  }  }while( 1 );  }  search_success:  if( (i64)iOff+nNew>n || nNew<1 ){  p->rc = FTS5_CORRUPT;  return;  }  pIter->iLeafOffset = iOff + nNew;  pIter->iTermLeafOffset = pIter->iLeafOffset;  pIter->iTermLeafPgno = pIter->iLeafPgno;  fts5BufferSet(&p->rc, &pIter->term, nKeep, pTerm);  fts5BufferAppendBlob(&p->rc, &pIter->term, nNew, &a[iOff]);  if( iPgidx>=n ){  pIter->iEndofDoclist = pIter->pLeaf->nn+1;  }else{  int nExtra;  iPgidx += fts5GetVarint32(&a[iPgidx], nExtra);  pIter->iEndofDoclist = iTermOff + nExtra;  }  pIter->iPgidxOff = iPgidx;  fts5SegIterLoadRowid(p, pIter);  fts5SegIterLoadNPos(p, pIter); } static sqlite3_stmt *fts5IdxSelectStmt(Fts5Index *p){  if( p->pIdxSelect==0 ){  Fts5Config *pConfig = p->pConfig;  fts5IndexPrepareStmt(p, &p->pIdxSelect, sqlite3_mprintf(  "SELECT pgno FROM '%q'.'%q_idx' WHERE "  "segid=? AND term<=? ORDER BY term DESC LIMIT 1",  pConfig->zDb, pConfig->zName  ));  }  return p->pIdxSelect; } static void fts5SegIterSeekInit(  Fts5Index *p,  const u8 *pTerm, int nTerm,  int flags,  Fts5StructureSegment *pSeg,  Fts5SegIter *pIter ){  int iPg = 1;  int bGe = (flags & FTS5INDEX_QUERY_SCAN);  int bDlidx = 0;  sqlite3_stmt *pIdxSelect = 0;  assert( bGe==0 || (flags & FTS5INDEX_QUERY_DESC)==0 );  assert( pTerm && nTerm );  memset(pIter, 0, sizeof(*pIter));  pIter->pSeg = pSeg;  pIdxSelect = fts5IdxSelectStmt(p);  if( p->rc ) return;  sqlite3_bind_int(pIdxSelect, 1, pSeg->iSegid);  sqlite3_bind_blob(pIdxSelect, 2, pTerm, nTerm, SQLITE_STATIC);  if( SQLITE_ROW==sqlite3_step(pIdxSelect) ){  i64 val = sqlite3_column_int(pIdxSelect, 0);  iPg = (int)(val>>1);  bDlidx = (val & 0x0001);  }  p->rc = sqlite3_reset(pIdxSelect);  sqlite3_bind_null(pIdxSelect, 2);  if( iPg<pSeg->pgnoFirst ){  iPg = pSeg->pgnoFirst;  bDlidx = 0;  }  pIter->iLeafPgno = iPg - 1;  fts5SegIterNextPage(p, pIter);  if( pIter->pLeaf ){  fts5LeafSeek(p, bGe, pIter, pTerm, nTerm);  }  if( p->rc==SQLITE_OK && bGe==0 ){  pIter->flags |= FTS5_SEGITER_ONETERM;  if( pIter->pLeaf ){  if( flags & FTS5INDEX_QUERY_DESC ){  pIter->flags |= FTS5_SEGITER_REVERSE;  }  if( bDlidx ){  fts5SegIterLoadDlidx(p, pIter);  }  if( flags & FTS5INDEX_QUERY_DESC ){  fts5SegIterReverse(p, pIter);  }  }  }  fts5SegIterSetNext(p, pIter);  assert_nc( p->rc!=SQLITE_OK   || pIter->pLeaf==0   || fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)==0   || (bGe && fts5BufferCompareBlob(&pIter->term, pTerm, nTerm)>0)  ); } static void fts5SegIterHashInit(  Fts5Index *p,  const u8 *pTerm, int nTerm,  int flags,  Fts5SegIter *pIter ){  int nList = 0;  const u8 *z = 0;  int n = 0;  Fts5Data *pLeaf = 0;  assert( p->pHash );  assert( p->rc==SQLITE_OK );  if( pTerm==0 || (flags & FTS5INDEX_QUERY_SCAN) ){  const u8 *pList = 0;  p->rc = sqlite3Fts5HashScanInit(p->pHash, (const char*)pTerm, nTerm);  sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &pList, &nList);  n = (z ? (int)strlen((const char*)z) : 0);  if( pList ){  pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));  if( pLeaf ){  pLeaf->p = (u8*)pList;  }  }  }else{  p->rc = sqlite3Fts5HashQuery(p->pHash, sizeof(Fts5Data),  (const char*)pTerm, nTerm, (void**)&pLeaf, &nList  );  if( pLeaf ){  pLeaf->p = (u8*)&pLeaf[1];  }  z = pTerm;  n = nTerm;  pIter->flags |= FTS5_SEGITER_ONETERM;  }  if( pLeaf ){  sqlite3Fts5BufferSet(&p->rc, &pIter->term, n, z);  pLeaf->nn = pLeaf->szLeaf = nList;  pIter->pLeaf = pLeaf;  pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);  pIter->iEndofDoclist = pLeaf->nn;  if( flags & FTS5INDEX_QUERY_DESC ){  pIter->flags |= FTS5_SEGITER_REVERSE;  fts5SegIterReverseInitPage(p, pIter);  }else{  fts5SegIterLoadNPos(p, pIter);  }  }  fts5SegIterSetNext(p, pIter); } static void fts5SegIterClear(Fts5SegIter *pIter){  fts5BufferFree(&pIter->term);  fts5DataRelease(pIter->pLeaf);  fts5DataRelease(pIter->pNextLeaf);  fts5DlidxIterFree(pIter->pDlidx);  sqlite3_free(pIter->aRowidOffset);  memset(pIter, 0, sizeof(Fts5SegIter)); }
#ifdef SQLITE_DEBUG
static void fts5AssertComparisonResult(  Fts5Iter *pIter,  Fts5SegIter *p1,  Fts5SegIter *p2,  Fts5CResult *pRes ){  int i1 = p1 - pIter->aSeg;  int i2 = p2 - pIter->aSeg;  if( p1->pLeaf || p2->pLeaf ){  if( p1->pLeaf==0 ){  assert( pRes->iFirst==i2 );  }else if( p2->pLeaf==0 ){  assert( pRes->iFirst==i1 );  }else{  int nMin = MIN(p1->term.n, p2->term.n);  int res = fts5Memcmp(p1->term.p, p2->term.p, nMin);  if( res==0 ) res = p1->term.n - p2->term.n;  if( res==0 ){  assert( pRes->bTermEq==1 );  assert( p1->iRowid!=p2->iRowid );  res = ((p1->iRowid > p2->iRowid)==pIter->bRev) ? -1 : 1;  }else{  assert( pRes->bTermEq==0 );  }  if( res<0 ){  assert( pRes->iFirst==i1 );  }else{  assert( pRes->iFirst==i2 );  }  }  } } static void fts5AssertMultiIterSetup(Fts5Index *p, Fts5Iter *pIter){  if( p->rc==SQLITE_OK ){  Fts5SegIter *pFirst = &pIter->aSeg[ pIter->aFirst[1].iFirst ];  int i;  assert( (pFirst->pLeaf==0)==pIter->base.bEof );  for(i=0; i<pIter->nSeg; i++){  Fts5SegIter *p1 = &pIter->aSeg[i];  assert( p1==pFirst   || p1->pLeaf==0   || fts5BufferCompare(&pFirst->term, &p1->term)   || p1->iRowid==pIter->iSwitchRowid   || (p1->iRowid<pIter->iSwitchRowid)==pIter->bRev  );  }  for(i=0; i<pIter->nSeg; i+=2){  Fts5SegIter *p1 = &pIter->aSeg[i];  Fts5SegIter *p2 = &pIter->aSeg[i+1];  Fts5CResult *pRes = &pIter->aFirst[(pIter->nSeg + i) / 2];  fts5AssertComparisonResult(pIter, p1, p2, pRes);  }  for(i=1; i<(pIter->nSeg / 2); i+=2){  Fts5SegIter *p1 = &pIter->aSeg[ pIter->aFirst[i*2].iFirst ];  Fts5SegIter *p2 = &pIter->aSeg[ pIter->aFirst[i*2+1].iFirst ];  Fts5CResult *pRes = &pIter->aFirst[i];  fts5AssertComparisonResult(pIter, p1, p2, pRes);  }  } }
#else
# define fts5AssertMultiIterSetup(x,y)
#endif
static int fts5MultiIterDoCompare(Fts5Iter *pIter, int iOut){  int i1;  int i2;  int iRes;  Fts5SegIter *p1;  Fts5SegIter *p2;  Fts5CResult *pRes = &pIter->aFirst[iOut];  assert( iOut<pIter->nSeg && iOut>0 );  assert( pIter->bRev==0 || pIter->bRev==1 );  if( iOut>=(pIter->nSeg/2) ){  i1 = (iOut - pIter->nSeg/2) * 2;  i2 = i1 + 1;  }else{  i1 = pIter->aFirst[iOut*2].iFirst;  i2 = pIter->aFirst[iOut*2+1].iFirst;  }  p1 = &pIter->aSeg[i1];  p2 = &pIter->aSeg[i2];  pRes->bTermEq = 0;  if( p1->pLeaf==0 ){  iRes = i2;  }else if( p2->pLeaf==0 ){  iRes = i1;  }else{  int res = fts5BufferCompare(&p1->term, &p2->term);  if( res==0 ){  assert_nc( i2>i1 );  assert_nc( i2!=0 );  pRes->bTermEq = 1;  if( p1->iRowid==p2->iRowid ){  p1->bDel = p2->bDel;  return i2;  }  res = ((p1->iRowid > p2->iRowid)==pIter->bRev) ? -1 : +1;  }  assert( res!=0 );  if( res<0 ){  iRes = i1;  }else{  iRes = i2;  }  }  pRes->iFirst = (u16)iRes;  return 0; } static void fts5SegIterGotoPage(  Fts5Index *p,  Fts5SegIter *pIter,  int iLeafPgno ){  assert( iLeafPgno>pIter->iLeafPgno );  if( iLeafPgno>pIter->pSeg->pgnoLast ){  p->rc = FTS5_CORRUPT;  }else{  fts5DataRelease(pIter->pNextLeaf);  pIter->pNextLeaf = 0;  pIter->iLeafPgno = iLeafPgno-1;  fts5SegIterNextPage(p, pIter);  assert( p->rc!=SQLITE_OK || pIter->iLeafPgno==iLeafPgno );  if( p->rc==SQLITE_OK && ALWAYS(pIter->pLeaf!=0) ){  int iOff;  u8 *a = pIter->pLeaf->p;  int n = pIter->pLeaf->szLeaf;  iOff = fts5LeafFirstRowidOff(pIter->pLeaf);  if( iOff<4 || iOff>=n ){  p->rc = FTS5_CORRUPT;  }else{  iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);  pIter->iLeafOffset = iOff;  fts5SegIterLoadNPos(p, pIter);  }  }  } } static void fts5SegIterNextFrom(  Fts5Index *p,  Fts5SegIter *pIter,  i64 iMatch ){  int bRev = (pIter->flags & FTS5_SEGITER_REVERSE);  Fts5DlidxIter *pDlidx = pIter->pDlidx;  int iLeafPgno = pIter->iLeafPgno;  int bMove = 1;  assert( pIter->flags & FTS5_SEGITER_ONETERM );  assert( pIter->pDlidx );  assert( pIter->pLeaf );  if( bRev==0 ){  while( !fts5DlidxIterEof(p, pDlidx) && iMatch>fts5DlidxIterRowid(pDlidx) ){  iLeafPgno = fts5DlidxIterPgno(pDlidx);  fts5DlidxIterNext(p, pDlidx);  }  assert_nc( iLeafPgno>=pIter->iLeafPgno || p->rc );  if( iLeafPgno>pIter->iLeafPgno ){  fts5SegIterGotoPage(p, pIter, iLeafPgno);  bMove = 0;  }  }else{  assert( pIter->pNextLeaf==0 );  assert( iMatch<pIter->iRowid );  while( !fts5DlidxIterEof(p, pDlidx) && iMatch<fts5DlidxIterRowid(pDlidx) ){  fts5DlidxIterPrev(p, pDlidx);  }  iLeafPgno = fts5DlidxIterPgno(pDlidx);  assert( fts5DlidxIterEof(p, pDlidx) || iLeafPgno<=pIter->iLeafPgno );  if( iLeafPgno<pIter->iLeafPgno ){  pIter->iLeafPgno = iLeafPgno+1;  fts5SegIterReverseNewPage(p, pIter);  bMove = 0;  }  }  do{  if( bMove && p->rc==SQLITE_OK ) pIter->xNext(p, pIter, 0);  if( pIter->pLeaf==0 ) break;  if( bRev==0 && pIter->iRowid>=iMatch ) break;  if( bRev!=0 && pIter->iRowid<=iMatch ) break;  bMove = 1;  }while( p->rc==SQLITE_OK ); } static void fts5MultiIterFree(Fts5Iter *pIter){  if( pIter ){  int i;  for(i=0; i<pIter->nSeg; i++){  fts5SegIterClear(&pIter->aSeg[i]);  }  fts5BufferFree(&pIter->poslist);  sqlite3_free(pIter);  } } static void fts5MultiIterAdvanced(  Fts5Index *p,  Fts5Iter *pIter,  int iChanged,  int iMinset ){  int i;  for(i=(pIter->nSeg+iChanged)/2; i>=iMinset && p->rc==SQLITE_OK; i=i/2){  int iEq;  if( (iEq = fts5MultiIterDoCompare(pIter, i)) ){  Fts5SegIter *pSeg = &pIter->aSeg[iEq];  assert( p->rc==SQLITE_OK );  pSeg->xNext(p, pSeg, 0);  i = pIter->nSeg + iEq;  }  } } static int fts5MultiIterAdvanceRowid(  Fts5Iter *pIter,  int iChanged,  Fts5SegIter **ppFirst ){  Fts5SegIter *pNew = &pIter->aSeg[iChanged];  if( pNew->iRowid==pIter->iSwitchRowid   || (pNew->iRowid<pIter->iSwitchRowid)==pIter->bRev  ){  int i;  Fts5SegIter *pOther = &pIter->aSeg[iChanged ^ 0x0001];  pIter->iSwitchRowid = pIter->bRev ? SMALLEST_INT64 : LARGEST_INT64;  for(i=(pIter->nSeg+iChanged)/2; 1; i=i/2){  Fts5CResult *pRes = &pIter->aFirst[i];  assert( pNew->pLeaf );  assert( pRes->bTermEq==0 || pOther->pLeaf );  if( pRes->bTermEq ){  if( pNew->iRowid==pOther->iRowid ){  return 1;  }else if( (pOther->iRowid>pNew->iRowid)==pIter->bRev ){  pIter->iSwitchRowid = pOther->iRowid;  pNew = pOther;  }else if( (pOther->iRowid>pIter->iSwitchRowid)==pIter->bRev ){  pIter->iSwitchRowid = pOther->iRowid;  }  }  pRes->iFirst = (u16)(pNew - pIter->aSeg);  if( i==1 ) break;  pOther = &pIter->aSeg[ pIter->aFirst[i ^ 0x0001].iFirst ];  }  }  *ppFirst = pNew;  return 0; } static void fts5MultiIterSetEof(Fts5Iter *pIter){  Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];  pIter->base.bEof = pSeg->pLeaf==0;  pIter->iSwitchRowid = pSeg->iRowid; } static void fts5MultiIterNext(  Fts5Index *p,  Fts5Iter *pIter,  int bFrom,  i64 iFrom ){  int bUseFrom = bFrom;  assert( pIter->base.bEof==0 );  while( p->rc==SQLITE_OK ){  int iFirst = pIter->aFirst[1].iFirst;  int bNewTerm = 0;  Fts5SegIter *pSeg = &pIter->aSeg[iFirst];  assert( p->rc==SQLITE_OK );  if( bUseFrom && pSeg->pDlidx ){  fts5SegIterNextFrom(p, pSeg, iFrom);  }else{  pSeg->xNext(p, pSeg, &bNewTerm);  }  if( pSeg->pLeaf==0 || bNewTerm   || fts5MultiIterAdvanceRowid(pIter, iFirst, &pSeg)  ){  fts5MultiIterAdvanced(p, pIter, iFirst, 1);  fts5MultiIterSetEof(pIter);  pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];  if( pSeg->pLeaf==0 ) return;  }  fts5AssertMultiIterSetup(p, pIter);  assert( pSeg==&pIter->aSeg[pIter->aFirst[1].iFirst] && pSeg->pLeaf );  if( pIter->bSkipEmpty==0 || pSeg->nPos ){  pIter->xSetOutputs(pIter, pSeg);  return;  }  bUseFrom = 0;  } } static void fts5MultiIterNext2(  Fts5Index *p,  Fts5Iter *pIter,  int *pbNewTerm ){  assert( pIter->bSkipEmpty );  if( p->rc==SQLITE_OK ){  *pbNewTerm = 0;  do{  int iFirst = pIter->aFirst[1].iFirst;  Fts5SegIter *pSeg = &pIter->aSeg[iFirst];  int bNewTerm = 0;  assert( p->rc==SQLITE_OK );  pSeg->xNext(p, pSeg, &bNewTerm);  if( pSeg->pLeaf==0 || bNewTerm   || fts5MultiIterAdvanceRowid(pIter, iFirst, &pSeg)  ){  fts5MultiIterAdvanced(p, pIter, iFirst, 1);  fts5MultiIterSetEof(pIter);  *pbNewTerm = 1;  }  fts5AssertMultiIterSetup(p, pIter);  }while( fts5MultiIterIsEmpty(p, pIter) );  } } static void fts5IterSetOutputs_Noop(Fts5Iter *pUnused1, Fts5SegIter *pUnused2){  UNUSED_PARAM2(pUnused1, pUnused2); } static Fts5Iter *fts5MultiIterAlloc(  Fts5Index *p,  int nSeg ){  Fts5Iter *pNew;  int nSlot;  for(nSlot=2; nSlot<nSeg; nSlot=nSlot*2);  pNew = fts5IdxMalloc(p,  sizeof(Fts5Iter) +  sizeof(Fts5SegIter) * (nSlot-1) +  sizeof(Fts5CResult) * nSlot  );  if( pNew ){  pNew->nSeg = nSlot;  pNew->aFirst = (Fts5CResult*)&pNew->aSeg[nSlot];  pNew->pIndex = p;  pNew->xSetOutputs = fts5IterSetOutputs_Noop;  }  return pNew; } static void fts5PoslistCallback(  Fts5Index *pUnused,  void *pContext,  const u8 *pChunk, int nChunk ){  UNUSED_PARAM(pUnused);  assert_nc( nChunk>=0 );  if( nChunk>0 ){  fts5BufferSafeAppendBlob((Fts5Buffer*)pContext, pChunk, nChunk);  } } typedef struct PoslistCallbackCtx PoslistCallbackCtx; struct PoslistCallbackCtx {  Fts5Buffer *pBuf;  Fts5Colset *pColset;  int eState; }; typedef struct PoslistOffsetsCtx PoslistOffsetsCtx; struct PoslistOffsetsCtx {  Fts5Buffer *pBuf;  Fts5Colset *pColset;  int iRead;  int iWrite; }; static int fts5IndexColsetTest(Fts5Colset *pColset, int iCol){  int i;  for(i=0; i<pColset->nCol; i++){  if( pColset->aiCol[i]==iCol ) return 1;  }  return 0; } static void fts5PoslistOffsetsCallback(  Fts5Index *pUnused,  void *pContext,  const u8 *pChunk, int nChunk ){  PoslistOffsetsCtx *pCtx = (PoslistOffsetsCtx*)pContext;  UNUSED_PARAM(pUnused);  assert_nc( nChunk>=0 );  if( nChunk>0 ){  int i = 0;  while( i<nChunk ){  int iVal;  i += fts5GetVarint32(&pChunk[i], iVal);  iVal += pCtx->iRead - 2;  pCtx->iRead = iVal;  if( fts5IndexColsetTest(pCtx->pColset, iVal) ){  fts5BufferSafeAppendVarint(pCtx->pBuf, iVal + 2 - pCtx->iWrite);  pCtx->iWrite = iVal;  }  }  } } static void fts5PoslistFilterCallback(  Fts5Index *pUnused,  void *pContext,  const u8 *pChunk, int nChunk ){  PoslistCallbackCtx *pCtx = (PoslistCallbackCtx*)pContext;  UNUSED_PARAM(pUnused);  assert_nc( nChunk>=0 );  if( nChunk>0 ){  int i = 0;  int iStart = 0;  if( pCtx->eState==2 ){  int iCol;  fts5FastGetVarint32(pChunk, i, iCol);  if( fts5IndexColsetTest(pCtx->pColset, iCol) ){  pCtx->eState = 1;  fts5BufferSafeAppendVarint(pCtx->pBuf, 1);  }else{  pCtx->eState = 0;  }  }  do {  while( i<nChunk && pChunk[i]!=0x01 ){  while( pChunk[i] & 0x80 ) i++;  i++;  }  if( pCtx->eState ){  fts5BufferSafeAppendBlob(pCtx->pBuf, &pChunk[iStart], i-iStart);  }  if( i<nChunk ){  int iCol;  iStart = i;  i++;  if( i>=nChunk ){  pCtx->eState = 2;  }else{  fts5FastGetVarint32(pChunk, i, iCol);  pCtx->eState = fts5IndexColsetTest(pCtx->pColset, iCol);  if( pCtx->eState ){  fts5BufferSafeAppendBlob(pCtx->pBuf, &pChunk[iStart], i-iStart);  iStart = i;  }  }  }  }while( i<nChunk );  } } static void fts5ChunkIterate(  Fts5Index *p,  Fts5SegIter *pSeg,  void *pCtx,  void (*xChunk)(Fts5Index*, void*, const u8*, int) ){  int nRem = pSeg->nPos;  Fts5Data *pData = 0;  u8 *pChunk = &pSeg->pLeaf->p[pSeg->iLeafOffset];  int nChunk = MIN(nRem, pSeg->pLeaf->szLeaf - pSeg->iLeafOffset);  int pgno = pSeg->iLeafPgno;  int pgnoSave = 0;  assert( p->pConfig->eDetail!=FTS5_DETAIL_NONE );  if( (pSeg->flags & FTS5_SEGITER_REVERSE)==0 ){  pgnoSave = pgno+1;  }  while( 1 ){  xChunk(p, pCtx, pChunk, nChunk);  nRem -= nChunk;  fts5DataRelease(pData);  if( nRem<=0 ){  break;  }else if( pSeg->pSeg==0 ){  p->rc = FTS5_CORRUPT;  return;  }else{  pgno++;  pData = fts5LeafRead(p, FTS5_SEGMENT_ROWID(pSeg->pSeg->iSegid, pgno));  if( pData==0 ) break;  pChunk = &pData->p[4];  nChunk = MIN(nRem, pData->szLeaf - 4);  if( pgno==pgnoSave ){  assert( pSeg->pNextLeaf==0 );  pSeg->pNextLeaf = pData;  pData = 0;  }  }  } } static void fts5SegiterPoslist(  Fts5Index *p,  Fts5SegIter *pSeg,  Fts5Colset *pColset,  Fts5Buffer *pBuf ){  assert( pBuf!=0 );  assert( pSeg!=0 );  if( 0==fts5BufferGrow(&p->rc, pBuf, pSeg->nPos+FTS5_DATA_ZERO_PADDING) ){  assert( pBuf->p!=0 );  assert( pBuf->nSpace >= pBuf->n+pSeg->nPos+FTS5_DATA_ZERO_PADDING );  memset(&pBuf->p[pBuf->n+pSeg->nPos], 0, FTS5_DATA_ZERO_PADDING);  if( pColset==0 ){  fts5ChunkIterate(p, pSeg, (void*)pBuf, fts5PoslistCallback);  }else{  if( p->pConfig->eDetail==FTS5_DETAIL_FULL ){  PoslistCallbackCtx sCtx;  sCtx.pBuf = pBuf;  sCtx.pColset = pColset;  sCtx.eState = fts5IndexColsetTest(pColset, 0);  assert( sCtx.eState==0 || sCtx.eState==1 );  fts5ChunkIterate(p, pSeg, (void*)&sCtx, fts5PoslistFilterCallback);  }else{  PoslistOffsetsCtx sCtx;  memset(&sCtx, 0, sizeof(sCtx));  sCtx.pBuf = pBuf;  sCtx.pColset = pColset;  fts5ChunkIterate(p, pSeg, (void*)&sCtx, fts5PoslistOffsetsCallback);  }  }  } } static void fts5IndexExtractColset(  int *pRc,  Fts5Colset *pColset,  const u8 *pPos, int nPos,  Fts5Iter *pIter ){  if( *pRc==SQLITE_OK ){  const u8 *p = pPos;  const u8 *aCopy = p;  const u8 *pEnd = &p[nPos];  int i = 0;  int iCurrent = 0;  if( pColset->nCol>1 && sqlite3Fts5BufferSize(pRc, &pIter->poslist, nPos) ){  return;  }  while( 1 ){  while( pColset->aiCol[i]<iCurrent ){  i++;  if( i==pColset->nCol ){  pIter->base.pData = pIter->poslist.p;  pIter->base.nData = pIter->poslist.n;  return;  }  }  while( p<pEnd && *p!=0x01 ){  while( *p++ & 0x80 );  }  if( pColset->aiCol[i]==iCurrent ){  if( pColset->nCol==1 ){  pIter->base.pData = aCopy;  pIter->base.nData = p-aCopy;  return;  }  fts5BufferSafeAppendBlob(&pIter->poslist, aCopy, p-aCopy);  }  if( p>=pEnd ){  pIter->base.pData = pIter->poslist.p;  pIter->base.nData = pIter->poslist.n;  return;  }  aCopy = p++;  iCurrent = *p++;  if( iCurrent & 0x80 ){  p--;  p += fts5GetVarint32(p, iCurrent);  }  }  } } static void fts5IterSetOutputs_None(Fts5Iter *pIter, Fts5SegIter *pSeg){  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_NONE );  pIter->base.iRowid = pSeg->iRowid;  pIter->base.nData = pSeg->nPos; } static void fts5IterSetOutputs_Nocolset(Fts5Iter *pIter, Fts5SegIter *pSeg){  pIter->base.iRowid = pSeg->iRowid;  pIter->base.nData = pSeg->nPos;  assert( pIter->pIndex->pConfig->eDetail!=FTS5_DETAIL_NONE );  assert( pIter->pColset==0 );  if( pSeg->iLeafOffset+pSeg->nPos<=pSeg->pLeaf->szLeaf ){  pIter->base.pData = &pSeg->pLeaf->p[pSeg->iLeafOffset];  }else{  fts5BufferZero(&pIter->poslist);  fts5SegiterPoslist(pIter->pIndex, pSeg, 0, &pIter->poslist);  pIter->base.pData = pIter->poslist.p;  } } static void fts5IterSetOutputs_ZeroColset(Fts5Iter *pIter, Fts5SegIter *pSeg){  UNUSED_PARAM(pSeg);  pIter->base.nData = 0; } static void fts5IterSetOutputs_Col(Fts5Iter *pIter, Fts5SegIter *pSeg){  fts5BufferZero(&pIter->poslist);  fts5SegiterPoslist(pIter->pIndex, pSeg, pIter->pColset, &pIter->poslist);  pIter->base.iRowid = pSeg->iRowid;  pIter->base.pData = pIter->poslist.p;  pIter->base.nData = pIter->poslist.n; } static void fts5IterSetOutputs_Col100(Fts5Iter *pIter, Fts5SegIter *pSeg){  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_COLUMNS );  assert( pIter->pColset );  if( pSeg->iLeafOffset+pSeg->nPos>pSeg->pLeaf->szLeaf ){  fts5IterSetOutputs_Col(pIter, pSeg);  }else{  u8 *a = (u8*)&pSeg->pLeaf->p[pSeg->iLeafOffset];  u8 *pEnd = (u8*)&a[pSeg->nPos];  int iPrev = 0;  int *aiCol = pIter->pColset->aiCol;  int *aiColEnd = &aiCol[pIter->pColset->nCol];  u8 *aOut = pIter->poslist.p;  int iPrevOut = 0;  pIter->base.iRowid = pSeg->iRowid;  while( a<pEnd ){  iPrev += (int)a++[0] - 2;  while( *aiCol<iPrev ){  aiCol++;  if( aiCol==aiColEnd ) goto setoutputs_col_out;  }  if( *aiCol==iPrev ){  *aOut++ = (u8)((iPrev - iPrevOut) + 2);  iPrevOut = iPrev;  }  } setoutputs_col_out:  pIter->base.pData = pIter->poslist.p;  pIter->base.nData = aOut - pIter->poslist.p;  } } static void fts5IterSetOutputs_Full(Fts5Iter *pIter, Fts5SegIter *pSeg){  Fts5Colset *pColset = pIter->pColset;  pIter->base.iRowid = pSeg->iRowid;  assert( pIter->pIndex->pConfig->eDetail==FTS5_DETAIL_FULL );  assert( pColset );  if( pSeg->iLeafOffset+pSeg->nPos<=pSeg->pLeaf->szLeaf ){  const u8 *a = &pSeg->pLeaf->p[pSeg->iLeafOffset];  int *pRc = &pIter->pIndex->rc;  fts5BufferZero(&pIter->poslist);  fts5IndexExtractColset(pRc, pColset, a, pSeg->nPos, pIter);  }else{  fts5BufferZero(&pIter->poslist);  fts5SegiterPoslist(pIter->pIndex, pSeg, pColset, &pIter->poslist);  pIter->base.pData = pIter->poslist.p;  pIter->base.nData = pIter->poslist.n;  } } static void fts5IterSetOutputCb(int *pRc, Fts5Iter *pIter){  assert( pIter!=0 || (*pRc)!=SQLITE_OK );  if( *pRc==SQLITE_OK ){  Fts5Config *pConfig = pIter->pIndex->pConfig;  if( pConfig->eDetail==FTS5_DETAIL_NONE ){  pIter->xSetOutputs = fts5IterSetOutputs_None;  }  else if( pIter->pColset==0 ){  pIter->xSetOutputs = fts5IterSetOutputs_Nocolset;  }  else if( pIter->pColset->nCol==0 ){  pIter->xSetOutputs = fts5IterSetOutputs_ZeroColset;  }  else if( pConfig->eDetail==FTS5_DETAIL_FULL ){  pIter->xSetOutputs = fts5IterSetOutputs_Full;  }  else{  assert( pConfig->eDetail==FTS5_DETAIL_COLUMNS );  if( pConfig->nCol<=100 ){  pIter->xSetOutputs = fts5IterSetOutputs_Col100;  sqlite3Fts5BufferSize(pRc, &pIter->poslist, pConfig->nCol);  }else{  pIter->xSetOutputs = fts5IterSetOutputs_Col;  }  }  } } static void fts5MultiIterNew(  Fts5Index *p,  Fts5Structure *pStruct,  int flags,  Fts5Colset *pColset,  const u8 *pTerm, int nTerm,  int iLevel,  int nSegment,  Fts5Iter **ppOut ){  int nSeg = 0;  int iIter = 0;  int iSeg;  Fts5StructureLevel *pLvl;  Fts5Iter *pNew;  assert( (pTerm==0 && nTerm==0) || iLevel<0 );  if( p->rc==SQLITE_OK ){  if( iLevel<0 ){  assert( pStruct->nSegment==fts5StructureCountSegments(pStruct) );  nSeg = pStruct->nSegment;  nSeg += (p->pHash ? 1 : 0);  }else{  nSeg = MIN(pStruct->aLevel[iLevel].nSeg, nSegment);  }  }  *ppOut = pNew = fts5MultiIterAlloc(p, nSeg);  if( pNew==0 ){  assert( p->rc!=SQLITE_OK );  goto fts5MultiIterNew_post_check;  }  pNew->bRev = (0!=(flags & FTS5INDEX_QUERY_DESC));  pNew->bSkipEmpty = (0!=(flags & FTS5INDEX_QUERY_SKIPEMPTY));  pNew->pColset = pColset;  if( (flags & FTS5INDEX_QUERY_NOOUTPUT)==0 ){  fts5IterSetOutputCb(&p->rc, pNew);  }  if( p->rc==SQLITE_OK ){  if( iLevel<0 ){  Fts5StructureLevel *pEnd = &pStruct->aLevel[pStruct->nLevel];  if( p->pHash ){  Fts5SegIter *pIter = &pNew->aSeg[iIter++];  fts5SegIterHashInit(p, pTerm, nTerm, flags, pIter);  }  for(pLvl=&pStruct->aLevel[0]; pLvl<pEnd; pLvl++){  for(iSeg=pLvl->nSeg-1; iSeg>=0; iSeg--){  Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];  Fts5SegIter *pIter = &pNew->aSeg[iIter++];  if( pTerm==0 ){  fts5SegIterInit(p, pSeg, pIter);  }else{  fts5SegIterSeekInit(p, pTerm, nTerm, flags, pSeg, pIter);  }  }  }  }else{  pLvl = &pStruct->aLevel[iLevel];  for(iSeg=nSeg-1; iSeg>=0; iSeg--){  fts5SegIterInit(p, &pLvl->aSeg[iSeg], &pNew->aSeg[iIter++]);  }  }  assert( iIter==nSeg );  }  if( p->rc==SQLITE_OK ){  for(iIter=pNew->nSeg-1; iIter>0; iIter--){  int iEq;  if( (iEq = fts5MultiIterDoCompare(pNew, iIter)) ){  Fts5SegIter *pSeg = &pNew->aSeg[iEq];  if( p->rc==SQLITE_OK ) pSeg->xNext(p, pSeg, 0);  fts5MultiIterAdvanced(p, pNew, iEq, iIter);  }  }  fts5MultiIterSetEof(pNew);  fts5AssertMultiIterSetup(p, pNew);  if( pNew->bSkipEmpty && fts5MultiIterIsEmpty(p, pNew) ){  fts5MultiIterNext(p, pNew, 0, 0);  }else if( pNew->base.bEof==0 ){  Fts5SegIter *pSeg = &pNew->aSeg[pNew->aFirst[1].iFirst];  pNew->xSetOutputs(pNew, pSeg);  }  }else{  fts5MultiIterFree(pNew);  *ppOut = 0;  } fts5MultiIterNew_post_check:  assert( (*ppOut)!=0 || p->rc!=SQLITE_OK );  return; } static void fts5MultiIterNew2(  Fts5Index *p,  Fts5Data *pData,  int bDesc,  Fts5Iter **ppOut ){  Fts5Iter *pNew;  pNew = fts5MultiIterAlloc(p, 2);  if( pNew ){  Fts5SegIter *pIter = &pNew->aSeg[1];  pIter->flags = FTS5_SEGITER_ONETERM;  if( pData->szLeaf>0 ){  pIter->pLeaf = pData;  pIter->iLeafOffset = fts5GetVarint(pData->p, (u64*)&pIter->iRowid);  pIter->iEndofDoclist = pData->nn;  pNew->aFirst[1].iFirst = 1;  if( bDesc ){  pNew->bRev = 1;  pIter->flags |= FTS5_SEGITER_REVERSE;  fts5SegIterReverseInitPage(p, pIter);  }else{  fts5SegIterLoadNPos(p, pIter);  }  pData = 0;  }else{  pNew->base.bEof = 1;  }  fts5SegIterSetNext(p, pIter);  *ppOut = pNew;  }  fts5DataRelease(pData); } static int fts5MultiIterEof(Fts5Index *p, Fts5Iter *pIter){  assert( pIter!=0 || p->rc!=SQLITE_OK );  assert( p->rc!=SQLITE_OK  || (pIter->aSeg[ pIter->aFirst[1].iFirst ].pLeaf==0)==pIter->base.bEof  );  return (p->rc || pIter->base.bEof); } static i64 fts5MultiIterRowid(Fts5Iter *pIter){  assert( pIter->aSeg[ pIter->aFirst[1].iFirst ].pLeaf );  return pIter->aSeg[ pIter->aFirst[1].iFirst ].iRowid; } static void fts5MultiIterNextFrom(  Fts5Index *p,  Fts5Iter *pIter,  i64 iMatch ){  while( 1 ){  i64 iRowid;  fts5MultiIterNext(p, pIter, 1, iMatch);  if( fts5MultiIterEof(p, pIter) ) break;  iRowid = fts5MultiIterRowid(pIter);  if( pIter->bRev==0 && iRowid>=iMatch ) break;  if( pIter->bRev!=0 && iRowid<=iMatch ) break;  } } static const u8 *fts5MultiIterTerm(Fts5Iter *pIter, int *pn){  Fts5SegIter *p = &pIter->aSeg[ pIter->aFirst[1].iFirst ];  *pn = p->term.n;  return p->term.p; } static int fts5AllocateSegid(Fts5Index *p, Fts5Structure *pStruct){  int iSegid = 0;  if( p->rc==SQLITE_OK ){  if( pStruct->nSegment>=FTS5_MAX_SEGMENT ){  p->rc = SQLITE_FULL;  }else{  u32 aUsed[(FTS5_MAX_SEGMENT+31) / 32];  int iLvl, iSeg;  int i;  u32 mask;  memset(aUsed, 0, sizeof(aUsed));  for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){  for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){  int iId = pStruct->aLevel[iLvl].aSeg[iSeg].iSegid;  if( iId<=FTS5_MAX_SEGMENT && iId>0 ){  aUsed[(iId-1) / 32] |= (u32)1 << ((iId-1) % 32);  }  }  }  for(i=0; aUsed[i]==0xFFFFFFFF; i++);  mask = aUsed[i];  for(iSegid=0; mask & ((u32)1 << iSegid); iSegid++);  iSegid += 1 + i*32;
#ifdef SQLITE_DEBUG
 for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){  for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){  assert_nc( iSegid!=pStruct->aLevel[iLvl].aSeg[iSeg].iSegid );  }  }  assert_nc( iSegid>0 && iSegid<=FTS5_MAX_SEGMENT );  {  sqlite3_stmt *pIdxSelect = fts5IdxSelectStmt(p);  if( p->rc==SQLITE_OK ){  u8 aBlob[2] = {0xff, 0xff};  sqlite3_bind_int(pIdxSelect, 1, iSegid);  sqlite3_bind_blob(pIdxSelect, 2, aBlob, 2, SQLITE_STATIC);  assert_nc( sqlite3_step(pIdxSelect)!=SQLITE_ROW );  p->rc = sqlite3_reset(pIdxSelect);  sqlite3_bind_null(pIdxSelect, 2);  }  }
#endif
 }  }  return iSegid; } static void fts5IndexDiscardData(Fts5Index *p){  assert( p->pHash || p->nPendingData==0 );  if( p->pHash ){  sqlite3Fts5HashClear(p->pHash);  p->nPendingData = 0;  } } static int fts5PrefixCompress(int nOld, const u8 *pOld, const u8 *pNew){  int i;  for(i=0; i<nOld; i++){  if( pOld[i]!=pNew[i] ) break;  }  return i; } static void fts5WriteDlidxClear(  Fts5Index *p,  Fts5SegWriter *pWriter,  int bFlush ){  int i;  assert( bFlush==0 || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n>0) );  for(i=0; i<pWriter->nDlidx; i++){  Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];  if( pDlidx->buf.n==0 ) break;  if( bFlush ){  assert( pDlidx->pgno!=0 );  fts5DataWrite(p,  FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),  pDlidx->buf.p, pDlidx->buf.n  );  }  sqlite3Fts5BufferZero(&pDlidx->buf);  pDlidx->bPrevValid = 0;  } } static int fts5WriteDlidxGrow(  Fts5Index *p,  Fts5SegWriter *pWriter,  int nLvl ){  if( p->rc==SQLITE_OK && nLvl>=pWriter->nDlidx ){  Fts5DlidxWriter *aDlidx = (Fts5DlidxWriter*)sqlite3_realloc64(  pWriter->aDlidx, sizeof(Fts5DlidxWriter) * nLvl  );  if( aDlidx==0 ){  p->rc = SQLITE_NOMEM;  }else{  size_t nByte = sizeof(Fts5DlidxWriter) * (nLvl - pWriter->nDlidx);  memset(&aDlidx[pWriter->nDlidx], 0, nByte);  pWriter->aDlidx = aDlidx;  pWriter->nDlidx = nLvl;  }  }  return p->rc; } static int fts5WriteFlushDlidx(Fts5Index *p, Fts5SegWriter *pWriter){  int bFlag = 0;  if( pWriter->aDlidx[0].buf.n>0 && pWriter->nEmpty>=FTS5_MIN_DLIDX_SIZE ){  bFlag = 1;  }  fts5WriteDlidxClear(p, pWriter, bFlag);  pWriter->nEmpty = 0;  return bFlag; } static void fts5WriteFlushBtree(Fts5Index *p, Fts5SegWriter *pWriter){  int bFlag;  assert( pWriter->iBtPage || pWriter->nEmpty==0 );  if( pWriter->iBtPage==0 ) return;  bFlag = fts5WriteFlushDlidx(p, pWriter);  if( p->rc==SQLITE_OK ){  const char *z = (pWriter->btterm.n>0?(const char*)pWriter->btterm.p:"");  sqlite3_bind_blob(p->pIdxWriter, 2, z, pWriter->btterm.n, SQLITE_STATIC);  sqlite3_bind_int64(p->pIdxWriter, 3, bFlag + ((i64)pWriter->iBtPage<<1));  sqlite3_step(p->pIdxWriter);  p->rc = sqlite3_reset(p->pIdxWriter);  sqlite3_bind_null(p->pIdxWriter, 2);  }  pWriter->iBtPage = 0; } static void fts5WriteBtreeTerm(  Fts5Index *p,  Fts5SegWriter *pWriter,  int nTerm, const u8 *pTerm ){  fts5WriteFlushBtree(p, pWriter);  if( p->rc==SQLITE_OK ){  fts5BufferSet(&p->rc, &pWriter->btterm, nTerm, pTerm);  pWriter->iBtPage = pWriter->writer.pgno;  } } static void fts5WriteBtreeNoTerm(  Fts5Index *p,  Fts5SegWriter *pWriter ){  if( pWriter->bFirstRowidInPage && pWriter->aDlidx[0].buf.n>0 ){  Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[0];  assert( pDlidx->bPrevValid );  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, 0);  }  pWriter->nEmpty++; } static i64 fts5DlidxExtractFirstRowid(Fts5Buffer *pBuf){  i64 iRowid;  int iOff;  iOff = 1 + fts5GetVarint(&pBuf->p[1], (u64*)&iRowid);  fts5GetVarint(&pBuf->p[iOff], (u64*)&iRowid);  return iRowid; } static void fts5WriteDlidxAppend(  Fts5Index *p,  Fts5SegWriter *pWriter,  i64 iRowid ){  int i;  int bDone = 0;  for(i=0; p->rc==SQLITE_OK && bDone==0; i++){  i64 iVal;  Fts5DlidxWriter *pDlidx = &pWriter->aDlidx[i];  if( pDlidx->buf.n>=p->pConfig->pgsz ){  pDlidx->buf.p[0] = 0x01;  fts5DataWrite(p,  FTS5_DLIDX_ROWID(pWriter->iSegid, i, pDlidx->pgno),  pDlidx->buf.p, pDlidx->buf.n  );  fts5WriteDlidxGrow(p, pWriter, i+2);  pDlidx = &pWriter->aDlidx[i];  if( p->rc==SQLITE_OK && pDlidx[1].buf.n==0 ){  i64 iFirst = fts5DlidxExtractFirstRowid(&pDlidx->buf);  pDlidx[1].pgno = pDlidx->pgno;  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, 0);  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, pDlidx->pgno);  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx[1].buf, iFirst);  pDlidx[1].bPrevValid = 1;  pDlidx[1].iPrev = iFirst;  }  sqlite3Fts5BufferZero(&pDlidx->buf);  pDlidx->bPrevValid = 0;  pDlidx->pgno++;  }else{  bDone = 1;  }  if( pDlidx->bPrevValid ){  iVal = iRowid - pDlidx->iPrev;  }else{  i64 iPgno = (i==0 ? pWriter->writer.pgno : pDlidx[-1].pgno);  assert( pDlidx->buf.n==0 );  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, !bDone);  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, iPgno);  iVal = iRowid;  }  sqlite3Fts5BufferAppendVarint(&p->rc, &pDlidx->buf, iVal);  pDlidx->bPrevValid = 1;  pDlidx->iPrev = iRowid;  } } static void fts5WriteFlushLeaf(Fts5Index *p, Fts5SegWriter *pWriter){  static const u8 zero[] = { 0x00, 0x00, 0x00, 0x00 };  Fts5PageWriter *pPage = &pWriter->writer;  i64 iRowid;  assert( (pPage->pgidx.n==0)==(pWriter->bFirstTermInPage) );  assert( 0==fts5GetU16(&pPage->buf.p[2]) );  fts5PutU16(&pPage->buf.p[2], (u16)pPage->buf.n);  if( pWriter->bFirstTermInPage ){  assert( pPage->pgidx.n==0 );  fts5WriteBtreeNoTerm(p, pWriter);  }else{  fts5BufferAppendBlob(&p->rc, &pPage->buf, pPage->pgidx.n, pPage->pgidx.p);  }  iRowid = FTS5_SEGMENT_ROWID(pWriter->iSegid, pPage->pgno);  fts5DataWrite(p, iRowid, pPage->buf.p, pPage->buf.n);  fts5BufferZero(&pPage->buf);  fts5BufferZero(&pPage->pgidx);  fts5BufferAppendBlob(&p->rc, &pPage->buf, 4, zero);  pPage->iPrevPgidx = 0;  pPage->pgno++;  pWriter->nLeafWritten++;  pWriter->bFirstTermInPage = 1;  pWriter->bFirstRowidInPage = 1; } static void fts5WriteAppendTerm(  Fts5Index *p,  Fts5SegWriter *pWriter,  int nTerm, const u8 *pTerm ){  int nPrefix;  Fts5PageWriter *pPage = &pWriter->writer;  Fts5Buffer *pPgidx = &pWriter->writer.pgidx;  int nMin = MIN(pPage->term.n, nTerm);  assert( p->rc==SQLITE_OK );  assert( pPage->buf.n>=4 );  assert( pPage->buf.n>4 || pWriter->bFirstTermInPage );  if( (pPage->buf.n + pPgidx->n + nTerm + 2)>=p->pConfig->pgsz ){  if( pPage->buf.n>4 ){  fts5WriteFlushLeaf(p, pWriter);  if( p->rc!=SQLITE_OK ) return;  }  fts5BufferGrow(&p->rc, &pPage->buf, nTerm+FTS5_DATA_PADDING);  }  pPgidx->n += sqlite3Fts5PutVarint(  &pPgidx->p[pPgidx->n], pPage->buf.n - pPage->iPrevPgidx  );  pPage->iPrevPgidx = pPage->buf.n;
#if 0
 fts5PutU16(&pPgidx->p[pPgidx->n], pPage->buf.n);  pPgidx->n += 2;
#endif
 if( pWriter->bFirstTermInPage ){  nPrefix = 0;  if( pPage->pgno!=1 ){  int n = nTerm;  if( pPage->term.n ){  n = 1 + fts5PrefixCompress(nMin, pPage->term.p, pTerm);  }  fts5WriteBtreeTerm(p, pWriter, n, pTerm);  if( p->rc!=SQLITE_OK ) return;  pPage = &pWriter->writer;  }  }else{  nPrefix = fts5PrefixCompress(nMin, pPage->term.p, pTerm);  fts5BufferAppendVarint(&p->rc, &pPage->buf, nPrefix);  }  fts5BufferAppendVarint(&p->rc, &pPage->buf, nTerm - nPrefix);  fts5BufferAppendBlob(&p->rc, &pPage->buf, nTerm - nPrefix, &pTerm[nPrefix]);  fts5BufferSet(&p->rc, &pPage->term, nTerm, pTerm);  pWriter->bFirstTermInPage = 0;  pWriter->bFirstRowidInPage = 0;  pWriter->bFirstRowidInDoclist = 1;  assert( p->rc || (pWriter->nDlidx>0 && pWriter->aDlidx[0].buf.n==0) );  pWriter->aDlidx[0].pgno = pPage->pgno; } static void fts5WriteAppendRowid(  Fts5Index *p,  Fts5SegWriter *pWriter,  i64 iRowid ){  if( p->rc==SQLITE_OK ){  Fts5PageWriter *pPage = &pWriter->writer;  if( (pPage->buf.n + pPage->pgidx.n)>=p->pConfig->pgsz ){  fts5WriteFlushLeaf(p, pWriter);  }  if( pWriter->bFirstRowidInPage ){  fts5PutU16(pPage->buf.p, (u16)pPage->buf.n);  fts5WriteDlidxAppend(p, pWriter, iRowid);  }  if( pWriter->bFirstRowidInDoclist || pWriter->bFirstRowidInPage ){  fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid);  }else{  assert_nc( p->rc || iRowid>pWriter->iPrevRowid );  fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid - pWriter->iPrevRowid);  }  pWriter->iPrevRowid = iRowid;  pWriter->bFirstRowidInDoclist = 0;  pWriter->bFirstRowidInPage = 0;  } } static void fts5WriteAppendPoslistData(  Fts5Index *p,  Fts5SegWriter *pWriter,  const u8 *aData,  int nData ){  Fts5PageWriter *pPage = &pWriter->writer;  const u8 *a = aData;  int n = nData;  assert( p->pConfig->pgsz>0 );  while( p->rc==SQLITE_OK   && (pPage->buf.n + pPage->pgidx.n + n)>=p->pConfig->pgsz  ){  int nReq = p->pConfig->pgsz - pPage->buf.n - pPage->pgidx.n;  int nCopy = 0;  while( nCopy<nReq ){  i64 dummy;  nCopy += fts5GetVarint(&a[nCopy], (u64*)&dummy);  }  fts5BufferAppendBlob(&p->rc, &pPage->buf, nCopy, a);  a += nCopy;  n -= nCopy;  fts5WriteFlushLeaf(p, pWriter);  }  if( n>0 ){  fts5BufferAppendBlob(&p->rc, &pPage->buf, n, a);  } } static void fts5WriteFinish(  Fts5Index *p,  Fts5SegWriter *pWriter,  int *pnLeaf ){  int i;  Fts5PageWriter *pLeaf = &pWriter->writer;  if( p->rc==SQLITE_OK ){  assert( pLeaf->pgno>=1 );  if( pLeaf->buf.n>4 ){  fts5WriteFlushLeaf(p, pWriter);  }  *pnLeaf = pLeaf->pgno-1;  if( pLeaf->pgno>1 ){  fts5WriteFlushBtree(p, pWriter);  }  }  fts5BufferFree(&pLeaf->term);  fts5BufferFree(&pLeaf->buf);  fts5BufferFree(&pLeaf->pgidx);  fts5BufferFree(&pWriter->btterm);  for(i=0; i<pWriter->nDlidx; i++){  sqlite3Fts5BufferFree(&pWriter->aDlidx[i].buf);  }  sqlite3_free(pWriter->aDlidx); } static void fts5WriteInit(  Fts5Index *p,  Fts5SegWriter *pWriter,  int iSegid ){  const int nBuffer = p->pConfig->pgsz + FTS5_DATA_PADDING;  memset(pWriter, 0, sizeof(Fts5SegWriter));  pWriter->iSegid = iSegid;  fts5WriteDlidxGrow(p, pWriter, 1);  pWriter->writer.pgno = 1;  pWriter->bFirstTermInPage = 1;  pWriter->iBtPage = 1;  assert( pWriter->writer.buf.n==0 );  assert( pWriter->writer.pgidx.n==0 );  sqlite3Fts5BufferSize(&p->rc, &pWriter->writer.pgidx, nBuffer);  sqlite3Fts5BufferSize(&p->rc, &pWriter->writer.buf, nBuffer);  if( p->pIdxWriter==0 ){  Fts5Config *pConfig = p->pConfig;  fts5IndexPrepareStmt(p, &p->pIdxWriter, sqlite3_mprintf(  "INSERT INTO '%q'.'%q_idx'(segid,term,pgno) VALUES(?,?,?)",  pConfig->zDb, pConfig->zName  ));  }  if( p->rc==SQLITE_OK ){  memset(pWriter->writer.buf.p, 0, 4);  pWriter->writer.buf.n = 4;  sqlite3_bind_int(p->pIdxWriter, 1, pWriter->iSegid);  } } static void fts5TrimSegments(Fts5Index *p, Fts5Iter *pIter){  int i;  Fts5Buffer buf;  memset(&buf, 0, sizeof(Fts5Buffer));  for(i=0; i<pIter->nSeg && p->rc==SQLITE_OK; i++){  Fts5SegIter *pSeg = &pIter->aSeg[i];  if( pSeg->pSeg==0 ){  }else if( pSeg->pLeaf==0 ){  pSeg->pSeg->pgnoLast = 0;  pSeg->pSeg->pgnoFirst = 0;  }else{  int iOff = pSeg->iTermLeafOffset;  i64 iLeafRowid;  Fts5Data *pData;  int iId = pSeg->pSeg->iSegid;  u8 aHdr[4] = {0x00, 0x00, 0x00, 0x00};  iLeafRowid = FTS5_SEGMENT_ROWID(iId, pSeg->iTermLeafPgno);  pData = fts5LeafRead(p, iLeafRowid);  if( pData ){  if( iOff>pData->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  fts5BufferZero(&buf);  fts5BufferGrow(&p->rc, &buf, pData->nn);  fts5BufferAppendBlob(&p->rc, &buf, sizeof(aHdr), aHdr);  fts5BufferAppendVarint(&p->rc, &buf, pSeg->term.n);  fts5BufferAppendBlob(&p->rc, &buf, pSeg->term.n, pSeg->term.p);  fts5BufferAppendBlob(&p->rc, &buf, pData->szLeaf-iOff,&pData->p[iOff]);  if( p->rc==SQLITE_OK ){  fts5PutU16(&buf.p[2], (u16)buf.n);  }  fts5BufferAppendVarint(&p->rc, &buf, 4);  if( pSeg->iLeafPgno==pSeg->iTermLeafPgno   && pSeg->iEndofDoclist<pData->szLeaf   && pSeg->iPgidxOff<=pData->nn  ){  int nDiff = pData->szLeaf - pSeg->iEndofDoclist;  fts5BufferAppendVarint(&p->rc, &buf, buf.n - 1 - nDiff - 4);  fts5BufferAppendBlob(&p->rc, &buf,  pData->nn - pSeg->iPgidxOff, &pData->p[pSeg->iPgidxOff]  );  }  pSeg->pSeg->pgnoFirst = pSeg->iTermLeafPgno;  fts5DataDelete(p, FTS5_SEGMENT_ROWID(iId, 1), iLeafRowid);  fts5DataWrite(p, iLeafRowid, buf.p, buf.n);  }  fts5DataRelease(pData);  }  }  }  fts5BufferFree(&buf); } static void fts5MergeChunkCallback(  Fts5Index *p,  void *pCtx,  const u8 *pChunk, int nChunk ){  Fts5SegWriter *pWriter = (Fts5SegWriter*)pCtx;  fts5WriteAppendPoslistData(p, pWriter, pChunk, nChunk); } static void fts5IndexMergeLevel(  Fts5Index *p,  Fts5Structure **ppStruct,  int iLvl,  int *pnRem ){  Fts5Structure *pStruct = *ppStruct;  Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];  Fts5StructureLevel *pLvlOut;  Fts5Iter *pIter = 0;  int nRem = pnRem ? *pnRem : 0;  int nInput;  Fts5SegWriter writer;  Fts5StructureSegment *pSeg;  Fts5Buffer term;  int bOldest;  int eDetail = p->pConfig->eDetail;  const int flags = FTS5INDEX_QUERY_NOOUTPUT;  int bTermWritten = 0;  assert( iLvl<pStruct->nLevel );  assert( pLvl->nMerge<=pLvl->nSeg );  memset(&writer, 0, sizeof(Fts5SegWriter));  memset(&term, 0, sizeof(Fts5Buffer));  if( pLvl->nMerge ){  pLvlOut = &pStruct->aLevel[iLvl+1];  assert( pLvlOut->nSeg>0 );  nInput = pLvl->nMerge;  pSeg = &pLvlOut->aSeg[pLvlOut->nSeg-1];  fts5WriteInit(p, &writer, pSeg->iSegid);  writer.writer.pgno = pSeg->pgnoLast+1;  writer.iBtPage = 0;  }else{  int iSegid = fts5AllocateSegid(p, pStruct);  if( iLvl==pStruct->nLevel-1 ){  fts5StructureAddLevel(&p->rc, ppStruct);  pStruct = *ppStruct;  }  fts5StructureExtendLevel(&p->rc, pStruct, iLvl+1, 1, 0);  if( p->rc ) return;  pLvl = &pStruct->aLevel[iLvl];  pLvlOut = &pStruct->aLevel[iLvl+1];  fts5WriteInit(p, &writer, iSegid);  pSeg = &pLvlOut->aSeg[pLvlOut->nSeg];  pLvlOut->nSeg++;  pSeg->pgnoFirst = 1;  pSeg->iSegid = iSegid;  pStruct->nSegment++;  nInput = pLvl->nSeg;  }  bOldest = (pLvlOut->nSeg==1 && pStruct->nLevel==iLvl+2);  assert( iLvl>=0 );  for(fts5MultiIterNew(p, pStruct, flags, 0, 0, 0, iLvl, nInput, &pIter);  fts5MultiIterEof(p, pIter)==0;  fts5MultiIterNext(p, pIter, 0, 0)  ){  Fts5SegIter *pSegIter = &pIter->aSeg[ pIter->aFirst[1].iFirst ];  int nPos;  int nTerm;  const u8 *pTerm;  pTerm = fts5MultiIterTerm(pIter, &nTerm);  if( nTerm!=term.n || fts5Memcmp(pTerm, term.p, nTerm) ){  if( pnRem && writer.nLeafWritten>nRem ){  break;  }  fts5BufferSet(&p->rc, &term, nTerm, pTerm);  bTermWritten =0;  }  if( pSegIter->nPos==0 && (bOldest || pSegIter->bDel==0) ) continue;  if( p->rc==SQLITE_OK && bTermWritten==0 ){  fts5WriteAppendTerm(p, &writer, nTerm, pTerm);  bTermWritten = 1;  }  fts5WriteAppendRowid(p, &writer, fts5MultiIterRowid(pIter));  if( eDetail==FTS5_DETAIL_NONE ){  if( pSegIter->bDel ){  fts5BufferAppendVarint(&p->rc, &writer.writer.buf, 0);  if( pSegIter->nPos>0 ){  fts5BufferAppendVarint(&p->rc, &writer.writer.buf, 0);  }  }  }else{  nPos = pSegIter->nPos*2 + pSegIter->bDel;  fts5BufferAppendVarint(&p->rc, &writer.writer.buf, nPos);  fts5ChunkIterate(p, pSegIter, (void*)&writer, fts5MergeChunkCallback);  }  }  fts5WriteFinish(p, &writer, &pSeg->pgnoLast);  assert( pIter!=0 || p->rc!=SQLITE_OK );  if( fts5MultiIterEof(p, pIter) ){  int i;  for(i=0; i<nInput; i++){  fts5DataRemoveSegment(p, pLvl->aSeg[i].iSegid);  }  if( pLvl->nSeg!=nInput ){  int nMove = (pLvl->nSeg - nInput) * sizeof(Fts5StructureSegment);  memmove(pLvl->aSeg, &pLvl->aSeg[nInput], nMove);  }  pStruct->nSegment -= nInput;  pLvl->nSeg -= nInput;  pLvl->nMerge = 0;  if( pSeg->pgnoLast==0 ){  pLvlOut->nSeg--;  pStruct->nSegment--;  }  }else{  assert( pSeg->pgnoLast>0 );  fts5TrimSegments(p, pIter);  pLvl->nMerge = nInput;  }  fts5MultiIterFree(pIter);  fts5BufferFree(&term);  if( pnRem ) *pnRem -= writer.nLeafWritten; } static int fts5IndexMerge(  Fts5Index *p,  Fts5Structure **ppStruct,  int nPg,  int nMin ){  int nRem = nPg;  int bRet = 0;  Fts5Structure *pStruct = *ppStruct;  while( nRem>0 && p->rc==SQLITE_OK ){  int iLvl;  int iBestLvl = 0;  int nBest = 0;  assert( pStruct->nLevel>0 );  for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){  Fts5StructureLevel *pLvl = &pStruct->aLevel[iLvl];  if( pLvl->nMerge ){  if( pLvl->nMerge>nBest ){  iBestLvl = iLvl;  nBest = pLvl->nMerge;  }  break;  }  if( pLvl->nSeg>nBest ){  nBest = pLvl->nSeg;  iBestLvl = iLvl;  }  }
#ifdef SQLITE_DEBUG
 for(iLvl=0; nBest==0 && iLvl<pStruct->nLevel; iLvl++){  assert( pStruct->aLevel[iLvl].nSeg==0 );  }
#endif
 if( nBest<nMin && pStruct->aLevel[iBestLvl].nMerge==0 ){  break;  }  bRet = 1;  fts5IndexMergeLevel(p, &pStruct, iBestLvl, &nRem);  if( p->rc==SQLITE_OK && pStruct->aLevel[iBestLvl].nMerge==0 ){  fts5StructurePromote(p, iBestLvl+1, pStruct);  }  }  *ppStruct = pStruct;  return bRet; } static void fts5IndexAutomerge(  Fts5Index *p,  Fts5Structure **ppStruct,  int nLeaf ){  if( p->rc==SQLITE_OK && p->pConfig->nAutomerge>0 && ALWAYS((*ppStruct)!=0) ){  Fts5Structure *pStruct = *ppStruct;  u64 nWrite;  int nWork;  int nRem;  nWrite = pStruct->nWriteCounter;  nWork = (int)(((nWrite + nLeaf) / p->nWorkUnit) - (nWrite / p->nWorkUnit));  pStruct->nWriteCounter += nLeaf;  nRem = (int)(p->nWorkUnit * nWork * pStruct->nLevel);  fts5IndexMerge(p, ppStruct, nRem, p->pConfig->nAutomerge);  } } static void fts5IndexCrisismerge(  Fts5Index *p,  Fts5Structure **ppStruct ){  const int nCrisis = p->pConfig->nCrisisMerge;  Fts5Structure *pStruct = *ppStruct;  int iLvl = 0;  assert( p->rc!=SQLITE_OK || pStruct->nLevel>0 );  while( p->rc==SQLITE_OK && pStruct->aLevel[iLvl].nSeg>=nCrisis ){  fts5IndexMergeLevel(p, &pStruct, iLvl, 0);  assert( p->rc!=SQLITE_OK || pStruct->nLevel>(iLvl+1) );  fts5StructurePromote(p, iLvl+1, pStruct);  iLvl++;  }  *ppStruct = pStruct; } static int fts5IndexReturn(Fts5Index *p){  int rc = p->rc;  p->rc = SQLITE_OK;  return rc; } typedef struct Fts5FlushCtx Fts5FlushCtx; struct Fts5FlushCtx {  Fts5Index *pIdx;  Fts5SegWriter writer; }; static int fts5PoslistPrefix(const u8 *aBuf, int nMax){  int ret;  u32 dummy;  ret = fts5GetVarint32(aBuf, dummy);  if( ret<nMax ){  while( 1 ){  int i = fts5GetVarint32(&aBuf[ret], dummy);  if( (ret + i) > nMax ) break;  ret += i;  }  }  return ret; } static void fts5FlushOneHash(Fts5Index *p){  Fts5Hash *pHash = p->pHash;  Fts5Structure *pStruct;  int iSegid;  int pgnoLast = 0;  pStruct = fts5StructureRead(p);  iSegid = fts5AllocateSegid(p, pStruct);  fts5StructureInvalidate(p);  if( iSegid ){  const int pgsz = p->pConfig->pgsz;  int eDetail = p->pConfig->eDetail;  Fts5StructureSegment *pSeg;  Fts5Buffer *pBuf;  Fts5Buffer *pPgidx;  Fts5SegWriter writer;  fts5WriteInit(p, &writer, iSegid);  pBuf = &writer.writer.buf;  pPgidx = &writer.writer.pgidx;  assert( p->rc || pBuf->nSpace>=(pgsz + FTS5_DATA_PADDING) );  assert( p->rc || pPgidx->nSpace>=(pgsz + FTS5_DATA_PADDING) );  if( p->rc==SQLITE_OK ){  p->rc = sqlite3Fts5HashScanInit(pHash, 0, 0);  }  while( p->rc==SQLITE_OK && 0==sqlite3Fts5HashScanEof(pHash) ){  const char *zTerm;  const u8 *pDoclist;  int nDoclist;  sqlite3Fts5HashScanEntry(pHash, &zTerm, &pDoclist, &nDoclist);  fts5WriteAppendTerm(p, &writer, (int)strlen(zTerm), (const u8*)zTerm);  if( p->rc!=SQLITE_OK ) break;  assert( writer.bFirstRowidInPage==0 );  if( pgsz>=(pBuf->n + pPgidx->n + nDoclist + 1) ){  fts5BufferSafeAppendBlob(pBuf, pDoclist, nDoclist);  }else{  i64 iRowid = 0;  u64 iDelta = 0;  int iOff = 0;  while( p->rc==SQLITE_OK && iOff<nDoclist ){  iOff += fts5GetVarint(&pDoclist[iOff], &iDelta);  iRowid += iDelta;  if( writer.bFirstRowidInPage ){  fts5PutU16(&pBuf->p[0], (u16)pBuf->n);  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iRowid);  writer.bFirstRowidInPage = 0;  fts5WriteDlidxAppend(p, &writer, iRowid);  if( p->rc!=SQLITE_OK ) break;  }else{  pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iDelta);  }  assert( pBuf->n<=pBuf->nSpace );  if( eDetail==FTS5_DETAIL_NONE ){  if( iOff<nDoclist && pDoclist[iOff]==0 ){  pBuf->p[pBuf->n++] = 0;  iOff++;  if( iOff<nDoclist && pDoclist[iOff]==0 ){  pBuf->p[pBuf->n++] = 0;  iOff++;  }  }  if( (pBuf->n + pPgidx->n)>=pgsz ){  fts5WriteFlushLeaf(p, &writer);  }  }else{  int bDummy;  int nPos;  int nCopy = fts5GetPoslistSize(&pDoclist[iOff], &nPos, &bDummy);  nCopy += nPos;  if( (pBuf->n + pPgidx->n + nCopy) <= pgsz ){  fts5BufferSafeAppendBlob(pBuf, &pDoclist[iOff], nCopy);  }else{  const u8 *pPoslist = &pDoclist[iOff];  int iPos = 0;  while( p->rc==SQLITE_OK ){  int nSpace = pgsz - pBuf->n - pPgidx->n;  int n = 0;  if( (nCopy - iPos)<=nSpace ){  n = nCopy - iPos;  }else{  n = fts5PoslistPrefix(&pPoslist[iPos], nSpace);  }  assert( n>0 );  fts5BufferSafeAppendBlob(pBuf, &pPoslist[iPos], n);  iPos += n;  if( (pBuf->n + pPgidx->n)>=pgsz ){  fts5WriteFlushLeaf(p, &writer);  }  if( iPos>=nCopy ) break;  }  }  iOff += nCopy;  }  }  }  assert( pBuf->n<=pBuf->nSpace );  if( p->rc==SQLITE_OK ) sqlite3Fts5HashScanNext(pHash);  }  sqlite3Fts5HashClear(pHash);  fts5WriteFinish(p, &writer, &pgnoLast);  if( pStruct->nLevel==0 ){  fts5StructureAddLevel(&p->rc, &pStruct);  }  fts5StructureExtendLevel(&p->rc, pStruct, 0, 1, 0);  if( p->rc==SQLITE_OK ){  pSeg = &pStruct->aLevel[0].aSeg[ pStruct->aLevel[0].nSeg++ ];  pSeg->iSegid = iSegid;  pSeg->pgnoFirst = 1;  pSeg->pgnoLast = pgnoLast;  pStruct->nSegment++;  }  fts5StructurePromote(p, 0, pStruct);  }  fts5IndexAutomerge(p, &pStruct, pgnoLast);  fts5IndexCrisismerge(p, &pStruct);  fts5StructureWrite(p, pStruct);  fts5StructureRelease(pStruct); } static void fts5IndexFlush(Fts5Index *p){  if( p->nPendingData ){  assert( p->pHash );  p->nPendingData = 0;  fts5FlushOneHash(p);  } } static Fts5Structure *fts5IndexOptimizeStruct(  Fts5Index *p,  Fts5Structure *pStruct ){  Fts5Structure *pNew = 0;  sqlite3_int64 nByte = sizeof(Fts5Structure);  int nSeg = pStruct->nSegment;  int i;  if( nSeg<2 ) return 0;  for(i=0; i<pStruct->nLevel; i++){  int nThis = pStruct->aLevel[i].nSeg;  if( nThis==nSeg || (nThis==nSeg-1 && pStruct->aLevel[i].nMerge==nThis) ){  fts5StructureRef(pStruct);  return pStruct;  }  assert( pStruct->aLevel[i].nMerge<=nThis );  }  nByte += (pStruct->nLevel+1) * sizeof(Fts5StructureLevel);  pNew = (Fts5Structure*)sqlite3Fts5MallocZero(&p->rc, nByte);  if( pNew ){  Fts5StructureLevel *pLvl;  nByte = nSeg * sizeof(Fts5StructureSegment);  pNew->nLevel = pStruct->nLevel+1;  pNew->nRef = 1;  pNew->nWriteCounter = pStruct->nWriteCounter;  pLvl = &pNew->aLevel[pStruct->nLevel];  pLvl->aSeg = (Fts5StructureSegment*)sqlite3Fts5MallocZero(&p->rc, nByte);  if( pLvl->aSeg ){  int iLvl, iSeg;  int iSegOut = 0;  for(iLvl=pStruct->nLevel-1; iLvl>=0; iLvl--){  for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){  pLvl->aSeg[iSegOut] = pStruct->aLevel[iLvl].aSeg[iSeg];  iSegOut++;  }  }  pNew->nSegment = pLvl->nSeg = nSeg;  }else{  sqlite3_free(pNew);  pNew = 0;  }  }  return pNew; } static int sqlite3Fts5IndexOptimize(Fts5Index *p){  Fts5Structure *pStruct;  Fts5Structure *pNew = 0;  assert( p->rc==SQLITE_OK );  fts5IndexFlush(p);  pStruct = fts5StructureRead(p);  fts5StructureInvalidate(p);  if( pStruct ){  pNew = fts5IndexOptimizeStruct(p, pStruct);  }  fts5StructureRelease(pStruct);  assert( pNew==0 || pNew->nSegment>0 );  if( pNew ){  int iLvl;  for(iLvl=0; pNew->aLevel[iLvl].nSeg==0; iLvl++){}  while( p->rc==SQLITE_OK && pNew->aLevel[iLvl].nSeg>0 ){  int nRem = FTS5_OPT_WORK_UNIT;  fts5IndexMergeLevel(p, &pNew, iLvl, &nRem);  }  fts5StructureWrite(p, pNew);  fts5StructureRelease(pNew);  }  return fts5IndexReturn(p); } static int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge){  Fts5Structure *pStruct = fts5StructureRead(p);  if( pStruct ){  int nMin = p->pConfig->nUsermerge;  fts5StructureInvalidate(p);  if( nMerge<0 ){  Fts5Structure *pNew = fts5IndexOptimizeStruct(p, pStruct);  fts5StructureRelease(pStruct);  pStruct = pNew;  nMin = 2;  nMerge = nMerge*-1;  }  if( pStruct && pStruct->nLevel ){  if( fts5IndexMerge(p, &pStruct, nMerge, nMin) ){  fts5StructureWrite(p, pStruct);  }  }  fts5StructureRelease(pStruct);  }  return fts5IndexReturn(p); } static void fts5AppendRowid(  Fts5Index *p,  i64 iDelta,  Fts5Iter *pUnused,  Fts5Buffer *pBuf ){  UNUSED_PARAM(pUnused);  fts5BufferAppendVarint(&p->rc, pBuf, iDelta); } static void fts5AppendPoslist(  Fts5Index *p,  i64 iDelta,  Fts5Iter *pMulti,  Fts5Buffer *pBuf ){  int nData = pMulti->base.nData;  int nByte = nData + 9 + 9 + FTS5_DATA_ZERO_PADDING;  assert( nData>0 );  if( p->rc==SQLITE_OK && 0==fts5BufferGrow(&p->rc, pBuf, nByte) ){  fts5BufferSafeAppendVarint(pBuf, iDelta);  fts5BufferSafeAppendVarint(pBuf, nData*2);  fts5BufferSafeAppendBlob(pBuf, pMulti->base.pData, nData);  memset(&pBuf->p[pBuf->n], 0, FTS5_DATA_ZERO_PADDING);  } } static void fts5DoclistIterNext(Fts5DoclistIter *pIter){  u8 *p = pIter->aPoslist + pIter->nSize + pIter->nPoslist;  assert( pIter->aPoslist || (p==0 && pIter->aPoslist==0) );  if( p>=pIter->aEof ){  pIter->aPoslist = 0;  }else{  i64 iDelta;  p += fts5GetVarint(p, (u64*)&iDelta);  pIter->iRowid += iDelta;  if( p[0] & 0x80 ){  int nPos;  pIter->nSize = fts5GetVarint32(p, nPos);  pIter->nPoslist = (nPos>>1);  }else{  pIter->nPoslist = ((int)(p[0])) >> 1;  pIter->nSize = 1;  }  pIter->aPoslist = p;  if( &pIter->aPoslist[pIter->nPoslist]>pIter->aEof ){  pIter->aPoslist = 0;  }  } } static void fts5DoclistIterInit(  Fts5Buffer *pBuf,  Fts5DoclistIter *pIter ){  memset(pIter, 0, sizeof(*pIter));  if( pBuf->n>0 ){  pIter->aPoslist = pBuf->p;  pIter->aEof = &pBuf->p[pBuf->n];  fts5DoclistIterNext(pIter);  } }
#if 0
static void fts5MergeAppendDocid(  Fts5Buffer *pBuf,  i64 *piLastRowid,  i64 iRowid ){  assert( pBuf->n!=0 || (*piLastRowid)==0 );  fts5BufferSafeAppendVarint(pBuf, iRowid - *piLastRowid);  *piLastRowid = iRowid; }
#endif
#define fts5MergeAppendDocid(pBuf, iLastRowid, iRowid) {   assert( (pBuf)->n!=0 || (iLastRowid)==0 );   fts5BufferSafeAppendVarint((pBuf), (iRowid) - (iLastRowid));  (iLastRowid) = (iRowid);  }

static void fts5BufferSwap(Fts5Buffer *p1, Fts5Buffer *p2){  Fts5Buffer tmp = *p1;  *p1 = *p2;  *p2 = tmp; } static void fts5NextRowid(Fts5Buffer *pBuf, int *piOff, i64 *piRowid){  int i = *piOff;  if( i>=pBuf->n ){  *piOff = -1;  }else{  u64 iVal;  *piOff = i + sqlite3Fts5GetVarint(&pBuf->p[i], &iVal);  *piRowid += iVal;  } } static void fts5MergeRowidLists(  Fts5Index *p,  Fts5Buffer *p1,  int nBuf,  Fts5Buffer *aBuf ){  int i1 = 0;  int i2 = 0;  i64 iRowid1 = 0;  i64 iRowid2 = 0;  i64 iOut = 0;  Fts5Buffer *p2 = &aBuf[0];  Fts5Buffer out;  (void)nBuf;  memset(&out, 0, sizeof(out));  assert( nBuf==1 );  sqlite3Fts5BufferSize(&p->rc, &out, p1->n + p2->n);  if( p->rc ) return;  fts5NextRowid(p1, &i1, &iRowid1);  fts5NextRowid(p2, &i2, &iRowid2);  while( i1>=0 || i2>=0 ){  if( i1>=0 && (i2<0 || iRowid1<iRowid2) ){  assert( iOut==0 || iRowid1>iOut );  fts5BufferSafeAppendVarint(&out, iRowid1 - iOut);  iOut = iRowid1;  fts5NextRowid(p1, &i1, &iRowid1);  }else{  assert( iOut==0 || iRowid2>iOut );  fts5BufferSafeAppendVarint(&out, iRowid2 - iOut);  iOut = iRowid2;  if( i1>=0 && iRowid1==iRowid2 ){  fts5NextRowid(p1, &i1, &iRowid1);  }  fts5NextRowid(p2, &i2, &iRowid2);  }  }  fts5BufferSwap(&out, p1);  fts5BufferFree(&out); } typedef struct PrefixMerger PrefixMerger; struct PrefixMerger {  Fts5DoclistIter iter;  i64 iPos;  int iOff;  u8 *aPos;  PrefixMerger *pNext; }; static void fts5PrefixMergerInsertByRowid(  PrefixMerger **ppHead,  PrefixMerger *p ){  if( p->iter.aPoslist ){  PrefixMerger **pp = ppHead;  while( *pp && p->iter.iRowid>(*pp)->iter.iRowid ){  pp = &(*pp)->pNext;  }  p->pNext = *pp;  *pp = p;  } } static void fts5PrefixMergerInsertByPosition(  PrefixMerger **ppHead,  PrefixMerger *p ){  if( p->iPos>=0 ){  PrefixMerger **pp = ppHead;  while( *pp && p->iPos>(*pp)->iPos ){  pp = &(*pp)->pNext;  }  p->pNext = *pp;  *pp = p;  } } static void fts5MergePrefixLists(  Fts5Index *p,  Fts5Buffer *p1,  int nBuf,  Fts5Buffer *aBuf ){
#define fts5PrefixMergerNextPosition(p)  sqlite3Fts5PoslistNext64((p)->aPos,(p)->iter.nPoslist,&(p)->iOff,&(p)->iPos)

#define FTS5_MERGE_NLIST 16
 PrefixMerger aMerger[FTS5_MERGE_NLIST];  PrefixMerger *pHead = 0;  int i;  int nOut = 0;  Fts5Buffer out = {0, 0, 0};  Fts5Buffer tmp = {0, 0, 0};  i64 iLastRowid = 0;  assert( nBuf+1<=sizeof(aMerger)/sizeof(aMerger[0]) );  memset(aMerger, 0, sizeof(PrefixMerger)*(nBuf+1));  pHead = &aMerger[nBuf];  fts5DoclistIterInit(p1, &pHead->iter);  for(i=0; i<nBuf; i++){  fts5DoclistIterInit(&aBuf[i], &aMerger[i].iter);  fts5PrefixMergerInsertByRowid(&pHead, &aMerger[i]);  nOut += aBuf[i].n;  }  if( nOut==0 ) return;  nOut += p1->n + 9 + 10*nBuf;  if( sqlite3Fts5BufferSize(&p->rc, &out, nOut) ) return;  while( pHead ){  fts5MergeAppendDocid(&out, iLastRowid, pHead->iter.iRowid);  if( pHead->pNext && iLastRowid==pHead->pNext->iter.iRowid ){  i64 iPrev = 0;  int nTmp = FTS5_DATA_ZERO_PADDING;  int nMerge = 0;  PrefixMerger *pSave = pHead;  PrefixMerger *pThis = 0;  int nTail = 0;  pHead = 0;  while( pSave && pSave->iter.iRowid==iLastRowid ){  PrefixMerger *pNext = pSave->pNext;  pSave->iOff = 0;  pSave->iPos = 0;  pSave->aPos = &pSave->iter.aPoslist[pSave->iter.nSize];  fts5PrefixMergerNextPosition(pSave);  nTmp += pSave->iter.nPoslist + 10;  nMerge++;  fts5PrefixMergerInsertByPosition(&pHead, pSave);  pSave = pNext;  }  if( pHead==0 || pHead->pNext==0 ){  p->rc = FTS5_CORRUPT;  break;  }  if( sqlite3Fts5BufferSize(&p->rc, &tmp, nTmp+nMerge*10) ){  break;  }  fts5BufferZero(&tmp);  pThis = pHead;  pHead = pThis->pNext;  sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, pThis->iPos);  fts5PrefixMergerNextPosition(pThis);  fts5PrefixMergerInsertByPosition(&pHead, pThis);  while( pHead->pNext ){  pThis = pHead;  if( pThis->iPos!=iPrev ){  sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, pThis->iPos);  }  fts5PrefixMergerNextPosition(pThis);  pHead = pThis->pNext;  fts5PrefixMergerInsertByPosition(&pHead, pThis);  }  if( pHead->iPos!=iPrev ){  sqlite3Fts5PoslistSafeAppend(&tmp, &iPrev, pHead->iPos);  }  nTail = pHead->iter.nPoslist - pHead->iOff;  assert_nc( tmp.n+nTail<=nTmp );  assert( tmp.n+nTail<=nTmp+nMerge*10 );  if( tmp.n+nTail>nTmp-FTS5_DATA_ZERO_PADDING ){  if( p->rc==SQLITE_OK ) p->rc = FTS5_CORRUPT;  break;  }  fts5BufferSafeAppendVarint(&out, (tmp.n+nTail) * 2);  fts5BufferSafeAppendBlob(&out, tmp.p, tmp.n);  if( nTail>0 ){  fts5BufferSafeAppendBlob(&out, &pHead->aPos[pHead->iOff], nTail);  }  pHead = pSave;  for(i=0; i<nBuf+1; i++){  PrefixMerger *pX = &aMerger[i];  if( pX->iter.aPoslist && pX->iter.iRowid==iLastRowid ){  fts5DoclistIterNext(&pX->iter);  fts5PrefixMergerInsertByRowid(&pHead, pX);  }  }  }else{  PrefixMerger *pThis = pHead;  Fts5DoclistIter *pI = &pThis->iter;  fts5BufferSafeAppendBlob(&out, pI->aPoslist, pI->nPoslist+pI->nSize);  fts5DoclistIterNext(pI);  pHead = pThis->pNext;  fts5PrefixMergerInsertByRowid(&pHead, pThis);  }  }  fts5BufferFree(p1);  fts5BufferFree(&tmp);  memset(&out.p[out.n], 0, FTS5_DATA_ZERO_PADDING);  *p1 = out; } static void fts5SetupPrefixIter(  Fts5Index *p,  int bDesc,  int iIdx,  u8 *pToken,  int nToken,  Fts5Colset *pColset,  Fts5Iter **ppIter ){  Fts5Structure *pStruct;  Fts5Buffer *aBuf;  int nBuf = 32;  int nMerge = 1;  void (*xMerge)(Fts5Index*, Fts5Buffer*, int, Fts5Buffer*);  void (*xAppend)(Fts5Index*, i64, Fts5Iter*, Fts5Buffer*);  if( p->pConfig->eDetail==FTS5_DETAIL_NONE ){  xMerge = fts5MergeRowidLists;  xAppend = fts5AppendRowid;  }else{  nMerge = FTS5_MERGE_NLIST-1;  nBuf = nMerge*8;  xMerge = fts5MergePrefixLists;  xAppend = fts5AppendPoslist;  }  aBuf = (Fts5Buffer*)fts5IdxMalloc(p, sizeof(Fts5Buffer)*nBuf);  pStruct = fts5StructureRead(p);  if( aBuf && pStruct ){  const int flags = FTS5INDEX_QUERY_SCAN  | FTS5INDEX_QUERY_SKIPEMPTY  | FTS5INDEX_QUERY_NOOUTPUT;  int i;  i64 iLastRowid = 0;  Fts5Iter *p1 = 0;  Fts5Data *pData;  Fts5Buffer doclist;  int bNewTerm = 1;  memset(&doclist, 0, sizeof(doclist));  if( iIdx!=0 ){  int dummy = 0;  const int f2 = FTS5INDEX_QUERY_SKIPEMPTY|FTS5INDEX_QUERY_NOOUTPUT;  pToken[0] = FTS5_MAIN_PREFIX;  fts5MultiIterNew(p, pStruct, f2, pColset, pToken, nToken, -1, 0, &p1);  fts5IterSetOutputCb(&p->rc, p1);  for(;  fts5MultiIterEof(p, p1)==0;  fts5MultiIterNext2(p, p1, &dummy)  ){  Fts5SegIter *pSeg = &p1->aSeg[ p1->aFirst[1].iFirst ];  p1->xSetOutputs(p1, pSeg);  if( p1->base.nData ){  xAppend(p, p1->base.iRowid-iLastRowid, p1, &doclist);  iLastRowid = p1->base.iRowid;  }  }  fts5MultiIterFree(p1);  }  pToken[0] = FTS5_MAIN_PREFIX + iIdx;  fts5MultiIterNew(p, pStruct, flags, pColset, pToken, nToken, -1, 0, &p1);  fts5IterSetOutputCb(&p->rc, p1);  for( ;  fts5MultiIterEof(p, p1)==0;  fts5MultiIterNext2(p, p1, &bNewTerm)  ){  Fts5SegIter *pSeg = &p1->aSeg[ p1->aFirst[1].iFirst ];  int nTerm = pSeg->term.n;  const u8 *pTerm = pSeg->term.p;  p1->xSetOutputs(p1, pSeg);  assert_nc( memcmp(pToken, pTerm, MIN(nToken, nTerm))<=0 );  if( bNewTerm ){  if( nTerm<nToken || memcmp(pToken, pTerm, nToken) ) break;  }  if( p1->base.nData==0 ) continue;  if( p1->base.iRowid<=iLastRowid && doclist.n>0 ){  for(i=0; p->rc==SQLITE_OK && doclist.n; i++){  int i1 = i*nMerge;  int iStore;  assert( i1+nMerge<=nBuf );  for(iStore=i1; iStore<i1+nMerge; iStore++){  if( aBuf[iStore].n==0 ){  fts5BufferSwap(&doclist, &aBuf[iStore]);  fts5BufferZero(&doclist);  break;  }  }  if( iStore==i1+nMerge ){  xMerge(p, &doclist, nMerge, &aBuf[i1]);  for(iStore=i1; iStore<i1+nMerge; iStore++){  fts5BufferZero(&aBuf[iStore]);  }  }  }  iLastRowid = 0;  }  xAppend(p, p1->base.iRowid-iLastRowid, p1, &doclist);  iLastRowid = p1->base.iRowid;  }  assert( (nBuf%nMerge)==0 );  for(i=0; i<nBuf; i+=nMerge){  int iFree;  if( p->rc==SQLITE_OK ){  xMerge(p, &doclist, nMerge, &aBuf[i]);  }  for(iFree=i; iFree<i+nMerge; iFree++){  fts5BufferFree(&aBuf[iFree]);  }  }  fts5MultiIterFree(p1);  pData = fts5IdxMalloc(p, sizeof(Fts5Data)+doclist.n+FTS5_DATA_ZERO_PADDING);  if( pData ){  pData->p = (u8*)&pData[1];  pData->nn = pData->szLeaf = doclist.n;  if( doclist.n ) memcpy(pData->p, doclist.p, doclist.n);  fts5MultiIterNew2(p, pData, bDesc, ppIter);  }  fts5BufferFree(&doclist);  }  fts5StructureRelease(pStruct);  sqlite3_free(aBuf); } static int sqlite3Fts5IndexBeginWrite(Fts5Index *p, int bDelete, i64 iRowid){  assert( p->rc==SQLITE_OK );  if( p->pHash==0 ){  p->rc = sqlite3Fts5HashNew(p->pConfig, &p->pHash, &p->nPendingData);  }  if( iRowid<p->iWriteRowid   || (iRowid==p->iWriteRowid && p->bDelete==0)   || (p->nPendingData > p->pConfig->nHashSize)  ){  fts5IndexFlush(p);  }  p->iWriteRowid = iRowid;  p->bDelete = bDelete;  return fts5IndexReturn(p); } static int sqlite3Fts5IndexSync(Fts5Index *p){  assert( p->rc==SQLITE_OK );  fts5IndexFlush(p);  sqlite3Fts5IndexCloseReader(p);  return fts5IndexReturn(p); } static int sqlite3Fts5IndexRollback(Fts5Index *p){  sqlite3Fts5IndexCloseReader(p);  fts5IndexDiscardData(p);  fts5StructureInvalidate(p);  return SQLITE_OK; } static int sqlite3Fts5IndexReinit(Fts5Index *p){  Fts5Structure s;  fts5StructureInvalidate(p);  fts5IndexDiscardData(p);  memset(&s, 0, sizeof(Fts5Structure));  fts5DataWrite(p, FTS5_AVERAGES_ROWID, (const u8*)"", 0);  fts5StructureWrite(p, &s);  return fts5IndexReturn(p); } static int sqlite3Fts5IndexOpen(  Fts5Config *pConfig,  int bCreate,  Fts5Index **pp,  char **pzErr ){  int rc = SQLITE_OK;  Fts5Index *p;  *pp = p = (Fts5Index*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Index));  if( rc==SQLITE_OK ){  p->pConfig = pConfig;  p->nWorkUnit = FTS5_WORK_UNIT;  p->zDataTbl = sqlite3Fts5Mprintf(&rc, "%s_data", pConfig->zName);  if( p->zDataTbl && bCreate ){  rc = sqlite3Fts5CreateTable(  pConfig, "data", "id INTEGER PRIMARY KEY, block BLOB", 0, pzErr  );  if( rc==SQLITE_OK ){  rc = sqlite3Fts5CreateTable(pConfig, "idx",  "segid, term, pgno, PRIMARY KEY(segid, term)",  1, pzErr  );  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexReinit(p);  }  }  }  assert( rc!=SQLITE_OK || p->rc==SQLITE_OK );  if( rc ){  sqlite3Fts5IndexClose(p);  *pp = 0;  }  return rc; } static int sqlite3Fts5IndexClose(Fts5Index *p){  int rc = SQLITE_OK;  if( p ){  assert( p->pReader==0 );  fts5StructureInvalidate(p);  sqlite3_finalize(p->pWriter);  sqlite3_finalize(p->pDeleter);  sqlite3_finalize(p->pIdxWriter);  sqlite3_finalize(p->pIdxDeleter);  sqlite3_finalize(p->pIdxSelect);  sqlite3_finalize(p->pDataVersion);  sqlite3Fts5HashFree(p->pHash);  sqlite3_free(p->zDataTbl);  sqlite3_free(p);  }  return rc; } static int sqlite3Fts5IndexCharlenToBytelen(  const char *p,  int nByte,  int nChar ){  int n = 0;  int i;  for(i=0; i<nChar; i++){  if( n>=nByte ) return 0;  if( (unsigned char)p[n++]>=0xc0 ){  if( n>=nByte ) return 0;  while( (p[n] & 0xc0)==0x80 ){  n++;  if( n>=nByte ){  if( i+1==nChar ) break;  return 0;  }  }  }  }  return n; } static int fts5IndexCharlen(const char *pIn, int nIn){  int nChar = 0;  int i = 0;  while( i<nIn ){  if( (unsigned char)pIn[i++]>=0xc0 ){  while( i<nIn && (pIn[i] & 0xc0)==0x80 ) i++;  }  nChar++;  }  return nChar; } static int sqlite3Fts5IndexWrite(  Fts5Index *p,  int iCol,  int iPos,  const char *pToken, int nToken ){  int i;  int rc = SQLITE_OK;  Fts5Config *pConfig = p->pConfig;  assert( p->rc==SQLITE_OK );  assert( (iCol<0)==p->bDelete );  rc = sqlite3Fts5HashWrite(  p->pHash, p->iWriteRowid, iCol, iPos, FTS5_MAIN_PREFIX, pToken, nToken  );  for(i=0; i<pConfig->nPrefix && rc==SQLITE_OK; i++){  const int nChar = pConfig->aPrefix[i];  int nByte = sqlite3Fts5IndexCharlenToBytelen(pToken, nToken, nChar);  if( nByte ){  rc = sqlite3Fts5HashWrite(p->pHash,  p->iWriteRowid, iCol, iPos, (char)(FTS5_MAIN_PREFIX+i+1), pToken,  nByte  );  }  }  return rc; } static int sqlite3Fts5IndexQuery(  Fts5Index *p,  const char *pToken, int nToken,  int flags,  Fts5Colset *pColset,  Fts5IndexIter **ppIter ){  Fts5Config *pConfig = p->pConfig;  Fts5Iter *pRet = 0;  Fts5Buffer buf = {0, 0, 0};  assert( (flags & FTS5INDEX_QUERY_SCAN)==0 || flags==FTS5INDEX_QUERY_SCAN );  if( sqlite3Fts5BufferSize(&p->rc, &buf, nToken+1)==0 ){  int iIdx = 0;  int iPrefixIdx = 0;  if( nToken ) memcpy(&buf.p[1], pToken, nToken);
#ifdef SQLITE_DEBUG
 if( pConfig->bPrefixIndex==0 || (flags & FTS5INDEX_QUERY_TEST_NOIDX) ){  assert( flags & FTS5INDEX_QUERY_PREFIX );  iIdx = 1+pConfig->nPrefix;  }else
#endif
 if( flags & FTS5INDEX_QUERY_PREFIX ){  int nChar = fts5IndexCharlen(pToken, nToken);  for(iIdx=1; iIdx<=pConfig->nPrefix; iIdx++){  int nIdxChar = pConfig->aPrefix[iIdx-1];  if( nIdxChar==nChar ) break;  if( nIdxChar==nChar+1 ) iPrefixIdx = iIdx;  }  }  if( iIdx<=pConfig->nPrefix ){  Fts5Structure *pStruct = fts5StructureRead(p);  buf.p[0] = (u8)(FTS5_MAIN_PREFIX + iIdx);  if( pStruct ){  fts5MultiIterNew(p, pStruct, flags | FTS5INDEX_QUERY_SKIPEMPTY,  pColset, buf.p, nToken+1, -1, 0, &pRet  );  fts5StructureRelease(pStruct);  }  }else{  int bDesc = (flags & FTS5INDEX_QUERY_DESC)!=0;  fts5SetupPrefixIter(p, bDesc, iPrefixIdx, buf.p, nToken+1, pColset,&pRet);  if( pRet==0 ){  assert( p->rc!=SQLITE_OK );  }else{  assert( pRet->pColset==0 );  fts5IterSetOutputCb(&p->rc, pRet);  if( p->rc==SQLITE_OK ){  Fts5SegIter *pSeg = &pRet->aSeg[pRet->aFirst[1].iFirst];  if( pSeg->pLeaf ) pRet->xSetOutputs(pRet, pSeg);  }  }  }  if( p->rc ){  sqlite3Fts5IterClose((Fts5IndexIter*)pRet);  pRet = 0;  sqlite3Fts5IndexCloseReader(p);  }  *ppIter = (Fts5IndexIter*)pRet;  sqlite3Fts5BufferFree(&buf);  }  return fts5IndexReturn(p); } static int sqlite3Fts5IterNext(Fts5IndexIter *pIndexIter){  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;  assert( pIter->pIndex->rc==SQLITE_OK );  fts5MultiIterNext(pIter->pIndex, pIter, 0, 0);  return fts5IndexReturn(pIter->pIndex); } static int sqlite3Fts5IterNextScan(Fts5IndexIter *pIndexIter){  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;  Fts5Index *p = pIter->pIndex;  assert( pIter->pIndex->rc==SQLITE_OK );  fts5MultiIterNext(p, pIter, 0, 0);  if( p->rc==SQLITE_OK ){  Fts5SegIter *pSeg = &pIter->aSeg[ pIter->aFirst[1].iFirst ];  if( pSeg->pLeaf && pSeg->term.p[0]!=FTS5_MAIN_PREFIX ){  fts5DataRelease(pSeg->pLeaf);  pSeg->pLeaf = 0;  pIter->base.bEof = 1;  }  }  return fts5IndexReturn(pIter->pIndex); } static int sqlite3Fts5IterNextFrom(Fts5IndexIter *pIndexIter, i64 iMatch){  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;  fts5MultiIterNextFrom(pIter->pIndex, pIter, iMatch);  return fts5IndexReturn(pIter->pIndex); } static const char *sqlite3Fts5IterTerm(Fts5IndexIter *pIndexIter, int *pn){  int n;  const char *z = (const char*)fts5MultiIterTerm((Fts5Iter*)pIndexIter, &n);  assert_nc( z || n<=1 );  *pn = n-1;  return (z ? &z[1] : 0); } static void sqlite3Fts5IterClose(Fts5IndexIter *pIndexIter){  if( pIndexIter ){  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;  Fts5Index *pIndex = pIter->pIndex;  fts5MultiIterFree(pIter);  sqlite3Fts5IndexCloseReader(pIndex);  } } static int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize){  int nCol = p->pConfig->nCol;  Fts5Data *pData;  *pnRow = 0;  memset(anSize, 0, sizeof(i64) * nCol);  pData = fts5DataRead(p, FTS5_AVERAGES_ROWID);  if( p->rc==SQLITE_OK && pData->nn ){  int i = 0;  int iCol;  i += fts5GetVarint(&pData->p[i], (u64*)pnRow);  for(iCol=0; i<pData->nn && iCol<nCol; iCol++){  i += fts5GetVarint(&pData->p[i], (u64*)&anSize[iCol]);  }  }  fts5DataRelease(pData);  return fts5IndexReturn(p); } static int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8 *pData, int nData){  assert( p->rc==SQLITE_OK );  fts5DataWrite(p, FTS5_AVERAGES_ROWID, pData, nData);  return fts5IndexReturn(p); } static int sqlite3Fts5IndexReads(Fts5Index *p){  return p->nRead; } static int sqlite3Fts5IndexSetCookie(Fts5Index *p, int iNew){  int rc;  Fts5Config *pConfig = p->pConfig;  u8 aCookie[4];  sqlite3_blob *pBlob = 0;  assert( p->rc==SQLITE_OK );  sqlite3Fts5Put32(aCookie, iNew);  rc = sqlite3_blob_open(pConfig->db, pConfig->zDb, p->zDataTbl,  "block", FTS5_STRUCTURE_ROWID, 1, &pBlob  );  if( rc==SQLITE_OK ){  sqlite3_blob_write(pBlob, aCookie, 4, 0);  rc = sqlite3_blob_close(pBlob);  }  return rc; } static int sqlite3Fts5IndexLoadConfig(Fts5Index *p){  Fts5Structure *pStruct;  pStruct = fts5StructureRead(p);  fts5StructureRelease(pStruct);  return fts5IndexReturn(p); } static u64 sqlite3Fts5IndexEntryCksum(  i64 iRowid,  int iCol,  int iPos,  int iIdx,  const char *pTerm,  int nTerm ){  int i;  u64 ret = iRowid;  ret += (ret<<3) + iCol;  ret += (ret<<3) + iPos;  if( iIdx>=0 ) ret += (ret<<3) + (FTS5_MAIN_PREFIX + iIdx);  for(i=0; i<nTerm; i++) ret += (ret<<3) + pTerm[i];  return ret; }
#ifdef SQLITE_DEBUG
static void fts5TestDlidxReverse(  Fts5Index *p,  int iSegid,  int iLeaf ){  Fts5DlidxIter *pDlidx = 0;  u64 cksum1 = 13;  u64 cksum2 = 13;  for(pDlidx=fts5DlidxIterInit(p, 0, iSegid, iLeaf);  fts5DlidxIterEof(p, pDlidx)==0;  fts5DlidxIterNext(p, pDlidx)  ){  i64 iRowid = fts5DlidxIterRowid(pDlidx);  int pgno = fts5DlidxIterPgno(pDlidx);  assert( pgno>iLeaf );  cksum1 += iRowid + ((i64)pgno<<32);  }  fts5DlidxIterFree(pDlidx);  pDlidx = 0;  for(pDlidx=fts5DlidxIterInit(p, 1, iSegid, iLeaf);  fts5DlidxIterEof(p, pDlidx)==0;  fts5DlidxIterPrev(p, pDlidx)  ){  i64 iRowid = fts5DlidxIterRowid(pDlidx);  int pgno = fts5DlidxIterPgno(pDlidx);  assert( fts5DlidxIterPgno(pDlidx)>iLeaf );  cksum2 += iRowid + ((i64)pgno<<32);  }  fts5DlidxIterFree(pDlidx);  pDlidx = 0;  if( p->rc==SQLITE_OK && cksum1!=cksum2 ) p->rc = FTS5_CORRUPT; } static int fts5QueryCksum(  Fts5Index *p,  int iIdx,  const char *z,  int n,  int flags,  u64 *pCksum ){  int eDetail = p->pConfig->eDetail;  u64 cksum = *pCksum;  Fts5IndexIter *pIter = 0;  int rc = sqlite3Fts5IndexQuery(p, z, n, flags, 0, &pIter);  while( rc==SQLITE_OK && ALWAYS(pIter!=0) && 0==sqlite3Fts5IterEof(pIter) ){  i64 rowid = pIter->iRowid;  if( eDetail==FTS5_DETAIL_NONE ){  cksum ^= sqlite3Fts5IndexEntryCksum(rowid, 0, 0, iIdx, z, n);  }else{  Fts5PoslistReader sReader;  for(sqlite3Fts5PoslistReaderInit(pIter->pData, pIter->nData, &sReader);  sReader.bEof==0;  sqlite3Fts5PoslistReaderNext(&sReader)  ){  int iCol = FTS5_POS2COLUMN(sReader.iPos);  int iOff = FTS5_POS2OFFSET(sReader.iPos);  cksum ^= sqlite3Fts5IndexEntryCksum(rowid, iCol, iOff, iIdx, z, n);  }  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IterNext(pIter);  }  }  sqlite3Fts5IterClose(pIter);  *pCksum = cksum;  return rc; } static int fts5TestUtf8(const char *z, int n){  int i = 0;  assert_nc( n>0 );  while( i<n ){  if( (z[i] & 0x80)==0x00 ){  i++;  }else  if( (z[i] & 0xE0)==0xC0 ){  if( i+1>=n || (z[i+1] & 0xC0)!=0x80 ) return 1;  i += 2;  }else  if( (z[i] & 0xF0)==0xE0 ){  if( i+2>=n || (z[i+1] & 0xC0)!=0x80 || (z[i+2] & 0xC0)!=0x80 ) return 1;  i += 3;  }else  if( (z[i] & 0xF8)==0xF0 ){  if( i+3>=n || (z[i+1] & 0xC0)!=0x80 || (z[i+2] & 0xC0)!=0x80 ) return 1;  if( (z[i+2] & 0xC0)!=0x80 ) return 1;  i += 3;  }else{  return 1;  }  }  return 0; } static void fts5TestTerm(  Fts5Index *p,  Fts5Buffer *pPrev,  const char *z, int n,  u64 expected,  u64 *pCksum ){  int rc = p->rc;  if( pPrev->n==0 ){  fts5BufferSet(&rc, pPrev, n, (const u8*)z);  }else  if( rc==SQLITE_OK && (pPrev->n!=n || memcmp(pPrev->p, z, n)) ){  u64 cksum3 = *pCksum;  const char *zTerm = (const char*)&pPrev->p[1];  int nTerm = pPrev->n-1;  int iIdx = (pPrev->p[0] - FTS5_MAIN_PREFIX);  int flags = (iIdx==0 ? 0 : FTS5INDEX_QUERY_PREFIX);  u64 ck1 = 0;  u64 ck2 = 0;  rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, flags, &ck1);  if( rc==SQLITE_OK ){  int f = flags|FTS5INDEX_QUERY_DESC;  rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);  }  if( rc==SQLITE_OK && ck1!=ck2 ) rc = FTS5_CORRUPT;  if( p->nPendingData==0 && 0==fts5TestUtf8(zTerm, nTerm) ){  if( iIdx>0 && rc==SQLITE_OK ){  int f = flags|FTS5INDEX_QUERY_TEST_NOIDX;  ck2 = 0;  rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);  if( rc==SQLITE_OK && ck1!=ck2 ) rc = FTS5_CORRUPT;  }  if( iIdx>0 && rc==SQLITE_OK ){  int f = flags|FTS5INDEX_QUERY_TEST_NOIDX|FTS5INDEX_QUERY_DESC;  ck2 = 0;  rc = fts5QueryCksum(p, iIdx, zTerm, nTerm, f, &ck2);  if( rc==SQLITE_OK && ck1!=ck2 ) rc = FTS5_CORRUPT;  }  }  cksum3 ^= ck1;  fts5BufferSet(&rc, pPrev, n, (const u8*)z);  if( rc==SQLITE_OK && cksum3!=expected ){  rc = FTS5_CORRUPT;  }  *pCksum = cksum3;  }  p->rc = rc; }
#else
# define fts5TestDlidxReverse(x,y,z)
# define fts5TestTerm(u,v,w,x,y,z)
#endif
static void fts5IndexIntegrityCheckEmpty(  Fts5Index *p,  Fts5StructureSegment *pSeg,  int iFirst,  int iNoRowid,  int iLast ){  int i;  for(i=iFirst; p->rc==SQLITE_OK && i<=iLast; i++){  Fts5Data *pLeaf = fts5DataRead(p, FTS5_SEGMENT_ROWID(pSeg->iSegid, i));  if( pLeaf ){  if( !fts5LeafIsTermless(pLeaf) ) p->rc = FTS5_CORRUPT;  if( i>=iNoRowid && 0!=fts5LeafFirstRowidOff(pLeaf) ) p->rc = FTS5_CORRUPT;  }  fts5DataRelease(pLeaf);  } } static void fts5IntegrityCheckPgidx(Fts5Index *p, Fts5Data *pLeaf){  int iTermOff = 0;  int ii;  Fts5Buffer buf1 = {0,0,0};  Fts5Buffer buf2 = {0,0,0};  ii = pLeaf->szLeaf;  while( ii<pLeaf->nn && p->rc==SQLITE_OK ){  int res;  int iOff;  int nIncr;  ii += fts5GetVarint32(&pLeaf->p[ii], nIncr);  iTermOff += nIncr;  iOff = iTermOff;  if( iOff>=pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  }else if( iTermOff==nIncr ){  int nByte;  iOff += fts5GetVarint32(&pLeaf->p[iOff], nByte);  if( (iOff+nByte)>pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  fts5BufferSet(&p->rc, &buf1, nByte, &pLeaf->p[iOff]);  }  }else{  int nKeep, nByte;  iOff += fts5GetVarint32(&pLeaf->p[iOff], nKeep);  iOff += fts5GetVarint32(&pLeaf->p[iOff], nByte);  if( nKeep>buf1.n || (iOff+nByte)>pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  buf1.n = nKeep;  fts5BufferAppendBlob(&p->rc, &buf1, nByte, &pLeaf->p[iOff]);  }  if( p->rc==SQLITE_OK ){  res = fts5BufferCompare(&buf1, &buf2);  if( res<=0 ) p->rc = FTS5_CORRUPT;  }  }  fts5BufferSet(&p->rc, &buf2, buf1.n, buf1.p);  }  fts5BufferFree(&buf1);  fts5BufferFree(&buf2); } static void fts5IndexIntegrityCheckSegment(  Fts5Index *p,  Fts5StructureSegment *pSeg ){  Fts5Config *pConfig = p->pConfig;  sqlite3_stmt *pStmt = 0;  int rc2;  int iIdxPrevLeaf = pSeg->pgnoFirst-1;  int iDlidxPrevLeaf = pSeg->pgnoLast;  if( pSeg->pgnoFirst==0 ) return;  fts5IndexPrepareStmt(p, &pStmt, sqlite3_mprintf(  "SELECT segid, term, (pgno>>1), (pgno&1) FROM %Q.'%q_idx' WHERE segid=%d "  "ORDER BY 1, 2",  pConfig->zDb, pConfig->zName, pSeg->iSegid  ));  while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){  i64 iRow;  Fts5Data *pLeaf;  const char *zIdxTerm = (const char*)sqlite3_column_blob(pStmt, 1);  int nIdxTerm = sqlite3_column_bytes(pStmt, 1);  int iIdxLeaf = sqlite3_column_int(pStmt, 2);  int bIdxDlidx = sqlite3_column_int(pStmt, 3);  if( iIdxLeaf<pSeg->pgnoFirst ) continue;  iRow = FTS5_SEGMENT_ROWID(pSeg->iSegid, iIdxLeaf);  pLeaf = fts5LeafRead(p, iRow);  if( pLeaf==0 ) break;  if( pLeaf->nn<=pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  int iOff;  int iRowidOff;  int nTerm;  int res;  iOff = fts5LeafFirstTermOff(pLeaf);  iRowidOff = fts5LeafFirstRowidOff(pLeaf);  if( iRowidOff>=iOff || iOff>=pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  iOff += fts5GetVarint32(&pLeaf->p[iOff], nTerm);  res = fts5Memcmp(&pLeaf->p[iOff], zIdxTerm, MIN(nTerm, nIdxTerm));  if( res==0 ) res = nTerm - nIdxTerm;  if( res<0 ) p->rc = FTS5_CORRUPT;  }  fts5IntegrityCheckPgidx(p, pLeaf);  }  fts5DataRelease(pLeaf);  if( p->rc ) break;  fts5IndexIntegrityCheckEmpty(  p, pSeg, iIdxPrevLeaf+1, iDlidxPrevLeaf+1, iIdxLeaf-1  );  if( p->rc ) break;  if( bIdxDlidx ){  Fts5DlidxIter *pDlidx = 0;  int iPrevLeaf = iIdxLeaf;  int iSegid = pSeg->iSegid;  int iPg = 0;  i64 iKey;  for(pDlidx=fts5DlidxIterInit(p, 0, iSegid, iIdxLeaf);  fts5DlidxIterEof(p, pDlidx)==0;  fts5DlidxIterNext(p, pDlidx)  ){  for(iPg=iPrevLeaf+1; iPg<fts5DlidxIterPgno(pDlidx); iPg++){  iKey = FTS5_SEGMENT_ROWID(iSegid, iPg);  pLeaf = fts5DataRead(p, iKey);  if( pLeaf ){  if( fts5LeafFirstRowidOff(pLeaf)!=0 ) p->rc = FTS5_CORRUPT;  fts5DataRelease(pLeaf);  }  }  iPrevLeaf = fts5DlidxIterPgno(pDlidx);  iKey = FTS5_SEGMENT_ROWID(iSegid, iPrevLeaf);  pLeaf = fts5DataRead(p, iKey);  if( pLeaf ){  i64 iRowid;  int iRowidOff = fts5LeafFirstRowidOff(pLeaf);  ASSERT_SZLEAF_OK(pLeaf);  if( iRowidOff>=pLeaf->szLeaf ){  p->rc = FTS5_CORRUPT;  }else{  fts5GetVarint(&pLeaf->p[iRowidOff], (u64*)&iRowid);  if( iRowid!=fts5DlidxIterRowid(pDlidx) ) p->rc = FTS5_CORRUPT;  }  fts5DataRelease(pLeaf);  }  }  iDlidxPrevLeaf = iPg;  fts5DlidxIterFree(pDlidx);  fts5TestDlidxReverse(p, iSegid, iIdxLeaf);  }else{  iDlidxPrevLeaf = pSeg->pgnoLast;  }  iIdxPrevLeaf = iIdxLeaf;  }  rc2 = sqlite3_finalize(pStmt);  if( p->rc==SQLITE_OK ) p->rc = rc2;
#if 0
 if( p->rc==SQLITE_OK && iter.iLeaf!=pSeg->pgnoLast ){  p->rc = FTS5_CORRUPT;  }
#endif
} static int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum, int bUseCksum){  int eDetail = p->pConfig->eDetail;  u64 cksum2 = 0;  Fts5Buffer poslist = {0,0,0};  Fts5Iter *pIter;  Fts5Structure *pStruct;  int iLvl, iSeg;
#ifdef SQLITE_DEBUG
 u64 cksum3 = 0;  Fts5Buffer term = {0,0,0};
#endif
 const int flags = FTS5INDEX_QUERY_NOOUTPUT;  pStruct = fts5StructureRead(p);  if( pStruct==0 ){  assert( p->rc!=SQLITE_OK );  return fts5IndexReturn(p);  }  for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){  for(iSeg=0; iSeg<pStruct->aLevel[iLvl].nSeg; iSeg++){  Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];  fts5IndexIntegrityCheckSegment(p, pSeg);  }  }  for(fts5MultiIterNew(p, pStruct, flags, 0, 0, 0, -1, 0, &pIter);  fts5MultiIterEof(p, pIter)==0;  fts5MultiIterNext(p, pIter, 0, 0)  ){  int n;  i64 iPos = 0;  int iOff = 0;  i64 iRowid = fts5MultiIterRowid(pIter);  char *z = (char*)fts5MultiIterTerm(pIter, &n);  fts5TestTerm(p, &term, z, n, cksum2, &cksum3);  if( eDetail==FTS5_DETAIL_NONE ){  if( 0==fts5MultiIterIsEmpty(p, pIter) ){  cksum2 ^= sqlite3Fts5IndexEntryCksum(iRowid, 0, 0, -1, z, n);  }  }else{  poslist.n = 0;  fts5SegiterPoslist(p, &pIter->aSeg[pIter->aFirst[1].iFirst], 0, &poslist);  fts5BufferAppendBlob(&p->rc, &poslist, 4, (const u8*)"\0\0\0\0");  while( 0==sqlite3Fts5PoslistNext64(poslist.p, poslist.n, &iOff, &iPos) ){  int iCol = FTS5_POS2COLUMN(iPos);  int iTokOff = FTS5_POS2OFFSET(iPos);  cksum2 ^= sqlite3Fts5IndexEntryCksum(iRowid, iCol, iTokOff, -1, z, n);  }  }  }  fts5TestTerm(p, &term, 0, 0, cksum2, &cksum3);  fts5MultiIterFree(pIter);  if( p->rc==SQLITE_OK && bUseCksum && cksum!=cksum2 ) p->rc = FTS5_CORRUPT;  fts5StructureRelease(pStruct);
#ifdef SQLITE_DEBUG
 fts5BufferFree(&term);
#endif
 fts5BufferFree(&poslist);  return fts5IndexReturn(p); }
#ifdef SQLITE_TEST
static void fts5DecodeRowid(  i64 iRowid,  int *piSegid,  int *pbDlidx,  int *piHeight,  int *piPgno ){  *piPgno = (int)(iRowid & (((i64)1 << FTS5_DATA_PAGE_B) - 1));  iRowid >>= FTS5_DATA_PAGE_B;  *piHeight = (int)(iRowid & (((i64)1 << FTS5_DATA_HEIGHT_B) - 1));  iRowid >>= FTS5_DATA_HEIGHT_B;  *pbDlidx = (int)(iRowid & 0x0001);  iRowid >>= FTS5_DATA_DLI_B;  *piSegid = (int)(iRowid & (((i64)1 << FTS5_DATA_ID_B) - 1)); }
#endif
#ifdef SQLITE_TEST
static void fts5DebugRowid(int *pRc, Fts5Buffer *pBuf, i64 iKey){  int iSegid, iHeight, iPgno, bDlidx;  fts5DecodeRowid(iKey, &iSegid, &bDlidx, &iHeight, &iPgno);  if( iSegid==0 ){  if( iKey==FTS5_AVERAGES_ROWID ){  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{averages} ");  }else{  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{structure}");  }  }  else{  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "{%ssegid=%d h=%d pgno=%d}",  bDlidx ? "dlidx " : "", iSegid, iHeight, iPgno  );  } }
#endif
#ifdef SQLITE_TEST
static void fts5DebugStructure(  int *pRc,  Fts5Buffer *pBuf,  Fts5Structure *p ){  int iLvl, iSeg;  for(iLvl=0; iLvl<p->nLevel; iLvl++){  Fts5StructureLevel *pLvl = &p->aLevel[iLvl];  sqlite3Fts5BufferAppendPrintf(pRc, pBuf,  " {lvl=%d nMerge=%d nSeg=%d", iLvl, pLvl->nMerge, pLvl->nSeg  );  for(iSeg=0; iSeg<pLvl->nSeg; iSeg++){  Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " {id=%d leaves=%d..%d}",  pSeg->iSegid, pSeg->pgnoFirst, pSeg->pgnoLast  );  }  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "}");  } }
#endif
#ifdef SQLITE_TEST
static void fts5DecodeStructure(  int *pRc,  Fts5Buffer *pBuf,  const u8 *pBlob, int nBlob ){  int rc;  Fts5Structure *p = 0;  rc = fts5StructureDecode(pBlob, nBlob, 0, &p);  if( rc!=SQLITE_OK ){  *pRc = rc;  return;  }  fts5DebugStructure(pRc, pBuf, p);  fts5StructureRelease(p); }
#endif
#ifdef SQLITE_TEST
static void fts5DecodeAverages(  int *pRc,  Fts5Buffer *pBuf,  const u8 *pBlob, int nBlob ){  int i = 0;  const char *zSpace = "";  while( i<nBlob ){  u64 iVal;  i += sqlite3Fts5GetVarint(&pBlob[i], &iVal);  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, "%s%d", zSpace, (int)iVal);  zSpace = " ";  } }
#endif
#ifdef SQLITE_TEST
static int fts5DecodePoslist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){  int iOff = 0;  while( iOff<n ){  int iVal;  iOff += fts5GetVarint32(&a[iOff], iVal);  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " %d", iVal);  }  return iOff; }
#endif
#ifdef SQLITE_TEST
static int fts5DecodeDoclist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){  i64 iDocid = 0;  int iOff = 0;  if( n>0 ){  iOff = sqlite3Fts5GetVarint(a, (u64*)&iDocid);  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);  }  while( iOff<n ){  int nPos;  int bDel;  iOff += fts5GetPoslistSize(&a[iOff], &nPos, &bDel);  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " nPos=%d%s", nPos, bDel?"*":"");  iOff += fts5DecodePoslist(pRc, pBuf, &a[iOff], MIN(n-iOff, nPos));  if( iOff<n ){  i64 iDelta;  iOff += sqlite3Fts5GetVarint(&a[iOff], (u64*)&iDelta);  iDocid += iDelta;  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " id=%lld", iDocid);  }  }  return iOff; }
#endif
#ifdef SQLITE_TEST
static void fts5DecodeRowidList(  int *pRc,  Fts5Buffer *pBuf,  const u8 *pData, int nData ){  int i = 0;  i64 iRowid = 0;  while( i<nData ){  const char *zApp = "";  u64 iVal;  i += sqlite3Fts5GetVarint(&pData[i], &iVal);  iRowid += iVal;  if( i<nData && pData[i]==0x00 ){  i++;  if( i<nData && pData[i]==0x00 ){  i++;  zApp = "+";  }else{  zApp = "*";  }  }  sqlite3Fts5BufferAppendPrintf(pRc, pBuf, " %lld%s", iRowid, zApp);  } }
#endif
#ifdef SQLITE_TEST
static void fts5DecodeFunction(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal ){  i64 iRowid;  int iSegid,iHeight,iPgno,bDlidx;  const u8 *aBlob; int n;  u8 *a = 0;  Fts5Buffer s;  int rc = SQLITE_OK;  sqlite3_int64 nSpace = 0;  int eDetailNone = (sqlite3_user_data(pCtx)!=0);  assert( nArg==2 );  UNUSED_PARAM(nArg);  memset(&s, 0, sizeof(Fts5Buffer));  iRowid = sqlite3_value_int64(apVal[0]);  n = sqlite3_value_bytes(apVal[1]);  aBlob = sqlite3_value_blob(apVal[1]);  nSpace = n + FTS5_DATA_ZERO_PADDING;  a = (u8*)sqlite3Fts5MallocZero(&rc, nSpace);  if( a==0 ) goto decode_out;  if( n>0 ) memcpy(a, aBlob, n);  fts5DecodeRowid(iRowid, &iSegid, &bDlidx, &iHeight, &iPgno);  fts5DebugRowid(&rc, &s, iRowid);  if( bDlidx ){  Fts5Data dlidx;  Fts5DlidxLvl lvl;  dlidx.p = a;  dlidx.nn = n;  memset(&lvl, 0, sizeof(Fts5DlidxLvl));  lvl.pData = &dlidx;  lvl.iLeafPgno = iPgno;  for(fts5DlidxLvlNext(&lvl); lvl.bEof==0; fts5DlidxLvlNext(&lvl)){  sqlite3Fts5BufferAppendPrintf(&rc, &s,  " %d(%lld)", lvl.iLeafPgno, lvl.iRowid  );  }  }else if( iSegid==0 ){  if( iRowid==FTS5_AVERAGES_ROWID ){  fts5DecodeAverages(&rc, &s, a, n);  }else{  fts5DecodeStructure(&rc, &s, a, n);  }  }else if( eDetailNone ){  Fts5Buffer term;  int szLeaf;  int iPgidxOff = szLeaf = fts5GetU16(&a[2]);  int iTermOff;  int nKeep = 0;  int iOff;  memset(&term, 0, sizeof(Fts5Buffer));  if( szLeaf<n ){  iPgidxOff += fts5GetVarint32(&a[iPgidxOff], iTermOff);  }else{  iTermOff = szLeaf;  }  fts5DecodeRowidList(&rc, &s, &a[4], iTermOff-4);  iOff = iTermOff;  while( iOff<szLeaf ){  int nAppend;  iOff += fts5GetVarint32(&a[iOff], nAppend);  term.n = nKeep;  fts5BufferAppendBlob(&rc, &term, nAppend, &a[iOff]);  sqlite3Fts5BufferAppendPrintf(  &rc, &s, " term=%.*s", term.n, (const char*)term.p  );  iOff += nAppend;  if( iPgidxOff<n ){  int nIncr;  iPgidxOff += fts5GetVarint32(&a[iPgidxOff], nIncr);  iTermOff += nIncr;  }else{  iTermOff = szLeaf;  }  fts5DecodeRowidList(&rc, &s, &a[iOff], iTermOff-iOff);  iOff = iTermOff;  if( iOff<szLeaf ){  iOff += fts5GetVarint32(&a[iOff], nKeep);  }  }  fts5BufferFree(&term);  }else{  Fts5Buffer term;  int szLeaf;  int iPgidxOff;  int iPgidxPrev = 0;  int iTermOff = 0;  int iRowidOff = 0;  int iOff;  int nDoclist;  memset(&term, 0, sizeof(Fts5Buffer));  if( n<4 ){  sqlite3Fts5BufferSet(&rc, &s, 7, (const u8*)"corrupt");  goto decode_out;  }else{  iRowidOff = fts5GetU16(&a[0]);  iPgidxOff = szLeaf = fts5GetU16(&a[2]);  if( iPgidxOff<n ){  fts5GetVarint32(&a[iPgidxOff], iTermOff);  }else if( iPgidxOff>n ){  rc = FTS5_CORRUPT;  goto decode_out;  }  }  if( iRowidOff!=0 ){  iOff = iRowidOff;  }else if( iTermOff!=0 ){  iOff = iTermOff;  }else{  iOff = szLeaf;  }  if( iOff>n ){  rc = FTS5_CORRUPT;  goto decode_out;  }  fts5DecodePoslist(&rc, &s, &a[4], iOff-4);  nDoclist = (iTermOff ? iTermOff : szLeaf) - iOff;  if( nDoclist+iOff>n ){  rc = FTS5_CORRUPT;  goto decode_out;  }  fts5DecodeDoclist(&rc, &s, &a[iOff], nDoclist);  while( iPgidxOff<n && rc==SQLITE_OK ){  int bFirst = (iPgidxOff==szLeaf);  int nByte;  int iEnd;  iPgidxOff += fts5GetVarint32(&a[iPgidxOff], nByte);  iPgidxPrev += nByte;  iOff = iPgidxPrev;  if( iPgidxOff<n ){  fts5GetVarint32(&a[iPgidxOff], nByte);  iEnd = iPgidxPrev + nByte;  }else{  iEnd = szLeaf;  }  if( iEnd>szLeaf ){  rc = FTS5_CORRUPT;  break;  }  if( bFirst==0 ){  iOff += fts5GetVarint32(&a[iOff], nByte);  if( nByte>term.n ){  rc = FTS5_CORRUPT;  break;  }  term.n = nByte;  }  iOff += fts5GetVarint32(&a[iOff], nByte);  if( iOff+nByte>n ){  rc = FTS5_CORRUPT;  break;  }  fts5BufferAppendBlob(&rc, &term, nByte, &a[iOff]);  iOff += nByte;  sqlite3Fts5BufferAppendPrintf(  &rc, &s, " term=%.*s", term.n, (const char*)term.p  );  iOff += fts5DecodeDoclist(&rc, &s, &a[iOff], iEnd-iOff);  }  fts5BufferFree(&term);  }  decode_out:  sqlite3_free(a);  if( rc==SQLITE_OK ){  sqlite3_result_text(pCtx, (const char*)s.p, s.n, SQLITE_TRANSIENT);  }else{  sqlite3_result_error_code(pCtx, rc);  }  fts5BufferFree(&s); }
#endif
#ifdef SQLITE_TEST
static void fts5RowidFunction(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apVal ){  const char *zArg;  if( nArg==0 ){  sqlite3_result_error(pCtx, "should be: fts5_rowid(subject, ....)", -1);  }else{  zArg = (const char*)sqlite3_value_text(apVal[0]);  if( 0==sqlite3_stricmp(zArg, "segment") ){  i64 iRowid;  int segid, pgno;  if( nArg!=3 ){  sqlite3_result_error(pCtx,  "should be: fts5_rowid('segment', segid, pgno))", -1  );  }else{  segid = sqlite3_value_int(apVal[1]);  pgno = sqlite3_value_int(apVal[2]);  iRowid = FTS5_SEGMENT_ROWID(segid, pgno);  sqlite3_result_int64(pCtx, iRowid);  }  }else{  sqlite3_result_error(pCtx,  "first arg to fts5_rowid() must be 'segment'" , -1  );  }  } }
#endif
static int sqlite3Fts5IndexInit(sqlite3 *db){
#ifdef SQLITE_TEST
 int rc = sqlite3_create_function(  db, "fts5_decode", 2, SQLITE_UTF8, 0, fts5DecodeFunction, 0, 0  );  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(  db, "fts5_decode_none", 2,  SQLITE_UTF8, (void*)db, fts5DecodeFunction, 0, 0  );  }  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(  db, "fts5_rowid", -1, SQLITE_UTF8, 0, fts5RowidFunction, 0, 0  );  }  return rc;
#else
 return SQLITE_OK;  UNUSED_PARAM(db);
#endif
} static int sqlite3Fts5IndexReset(Fts5Index *p){  assert( p->pStruct==0 || p->iStructVersion!=0 );  if( fts5IndexDataVersion(p)!=p->iStructVersion ){  fts5StructureInvalidate(p);  }  return fts5IndexReturn(p); }
#ifdef SQLITE_DEBUG
SQLITE_API int sqlite3_fts5_may_be_corrupt = 1;
#endif
typedef struct Fts5Auxdata Fts5Auxdata; typedef struct Fts5Auxiliary Fts5Auxiliary; typedef struct Fts5Cursor Fts5Cursor; typedef struct Fts5FullTable Fts5FullTable; typedef struct Fts5Sorter Fts5Sorter; typedef struct Fts5TokenizerModule Fts5TokenizerModule; struct Fts5TransactionState {  int eState;  int iSavepoint; }; struct Fts5Global {  fts5_api api;  sqlite3 *db;  i64 iNextId;  Fts5Auxiliary *pAux;  Fts5TokenizerModule *pTok;  Fts5TokenizerModule *pDfltTok;  Fts5Cursor *pCsr; }; struct Fts5Auxiliary {  Fts5Global *pGlobal;  char *zFunc;  void *pUserData;  fts5_extension_function xFunc;  void (*xDestroy)(void*);  Fts5Auxiliary *pNext; }; struct Fts5TokenizerModule {  char *zName;  void *pUserData;  fts5_tokenizer x;  void (*xDestroy)(void*);  Fts5TokenizerModule *pNext; }; struct Fts5FullTable {  Fts5Table p;  Fts5Storage *pStorage;  Fts5Global *pGlobal;  Fts5Cursor *pSortCsr;
#ifdef SQLITE_DEBUG
 struct Fts5TransactionState ts;
#endif
}; struct Fts5MatchPhrase {  Fts5Buffer *pPoslist;  int nTerm; }; struct Fts5Sorter {  sqlite3_stmt *pStmt;  i64 iRowid;  const u8 *aPoslist;  int nIdx;  int aIdx[1]; }; struct Fts5Cursor {  sqlite3_vtab_cursor base;  Fts5Cursor *pNext;  int *aColumnSize;  i64 iCsrId;  int ePlan;  int bDesc;  i64 iFirstRowid;  i64 iLastRowid;  sqlite3_stmt *pStmt;  Fts5Expr *pExpr;  Fts5Sorter *pSorter;  int csrflags;  i64 iSpecial;  char *zRank;  char *zRankArgs;  Fts5Auxiliary *pRank;  int nRankArg;  sqlite3_value **apRankArg;  sqlite3_stmt *pRankArgStmt;  Fts5Auxiliary *pAux;  Fts5Auxdata *pAuxdata;  Fts5PoslistReader *aInstIter;  int nInstAlloc;  int nInstCount;  int *aInst; };
#define FTS5_BI_MATCH 0x0001
#define FTS5_BI_RANK  0x0002
#define FTS5_BI_ROWID_EQ  0x0004
#define FTS5_BI_ROWID_LE  0x0008
#define FTS5_BI_ROWID_GE  0x0010
#define FTS5_BI_ORDER_RANK  0x0020
#define FTS5_BI_ORDER_ROWID 0x0040
#define FTS5_BI_ORDER_DESC  0x0080
#define FTS5CSR_EOF  0x01
#define FTS5CSR_REQUIRE_CONTENT  0x02
#define FTS5CSR_REQUIRE_DOCSIZE  0x04
#define FTS5CSR_REQUIRE_INST 0x08
#define FTS5CSR_FREE_ZRANK 0x10
#define FTS5CSR_REQUIRE_RESEEK 0x20
#define FTS5CSR_REQUIRE_POSLIST  0x40
#define BitFlagAllTest(x,y) (((x) & (y))==(y))
#define BitFlagTest(x,y) (((x) & (y))!=0)
#define CsrFlagSet(pCsr, flag)  ((pCsr)->csrflags |= (flag))
#define CsrFlagClear(pCsr, flag) ((pCsr)->csrflags &= ~(flag))
#define CsrFlagTest(pCsr, flag) ((pCsr)->csrflags & (flag))
struct Fts5Auxdata {  Fts5Auxiliary *pAux;  void *pPtr;  void(*xDelete)(void*);  Fts5Auxdata *pNext; };
#ifdef SQLITE_DEBUG
#define FTS5_BEGIN 1
#define FTS5_SYNC  2
#define FTS5_COMMIT  3
#define FTS5_ROLLBACK  4
#define FTS5_SAVEPOINT 5
#define FTS5_RELEASE 6
#define FTS5_ROLLBACKTO 7
static void fts5CheckTransactionState(Fts5FullTable *p, int op, int iSavepoint){  switch( op ){  case FTS5_BEGIN:  assert( p->ts.eState==0 );  p->ts.eState = 1;  p->ts.iSavepoint = -1;  break;  case FTS5_SYNC:  assert( p->ts.eState==1 );  p->ts.eState = 2;  break;  case FTS5_COMMIT:  assert( p->ts.eState==2 );  p->ts.eState = 0;  break;  case FTS5_ROLLBACK:  assert( p->ts.eState==1 || p->ts.eState==2 || p->ts.eState==0 );  p->ts.eState = 0;  break;  case FTS5_SAVEPOINT:  assert( p->ts.eState==1 );  assert( iSavepoint>=0 );  assert( iSavepoint>=p->ts.iSavepoint );  p->ts.iSavepoint = iSavepoint;  break;  case FTS5_RELEASE:  assert( p->ts.eState==1 );  assert( iSavepoint>=0 );  assert( iSavepoint<=p->ts.iSavepoint );  p->ts.iSavepoint = iSavepoint-1;  break;  case FTS5_ROLLBACKTO:  assert( p->ts.eState==1 );  assert( iSavepoint>=-1 );  p->ts.iSavepoint = iSavepoint;  break;  } }
#else
# define fts5CheckTransactionState(x,y,z)
#endif
static int fts5IsContentless(Fts5FullTable *pTab){  return pTab->p.pConfig->eContent==FTS5_CONTENT_NONE; } static void fts5FreeVtab(Fts5FullTable *pTab){  if( pTab ){  sqlite3Fts5IndexClose(pTab->p.pIndex);  sqlite3Fts5StorageClose(pTab->pStorage);  sqlite3Fts5ConfigFree(pTab->p.pConfig);  sqlite3_free(pTab);  } } static int fts5DisconnectMethod(sqlite3_vtab *pVtab){  fts5FreeVtab((Fts5FullTable*)pVtab);  return SQLITE_OK; } static int fts5DestroyMethod(sqlite3_vtab *pVtab){  Fts5Table *pTab = (Fts5Table*)pVtab;  int rc = sqlite3Fts5DropAll(pTab->pConfig);  if( rc==SQLITE_OK ){  fts5FreeVtab((Fts5FullTable*)pVtab);  }  return rc; } static int fts5InitVtab(  int bCreate,  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVTab,  char **pzErr ){  Fts5Global *pGlobal = (Fts5Global*)pAux;  const char **azConfig = (const char**)argv;  int rc = SQLITE_OK;  Fts5Config *pConfig = 0;  Fts5FullTable *pTab = 0;  pTab = (Fts5FullTable*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5FullTable));  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ConfigParse(pGlobal, db, argc, azConfig, &pConfig, pzErr);  assert( (rc==SQLITE_OK && *pzErr==0) || pConfig==0 );  }  if( rc==SQLITE_OK ){  pTab->p.pConfig = pConfig;  pTab->pGlobal = pGlobal;  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexOpen(pConfig, bCreate, &pTab->p.pIndex, pzErr);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageOpen(  pConfig, pTab->p.pIndex, bCreate, &pTab->pStorage, pzErr  );  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ConfigDeclareVtab(pConfig);  }  if( rc==SQLITE_OK ){  assert( pConfig->pzErrmsg==0 );  pConfig->pzErrmsg = pzErr;  rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);  sqlite3Fts5IndexRollback(pTab->p.pIndex);  pConfig->pzErrmsg = 0;  }  if( rc!=SQLITE_OK ){  fts5FreeVtab(pTab);  pTab = 0;  }else if( bCreate ){  fts5CheckTransactionState(pTab, FTS5_BEGIN, 0);  }  *ppVTab = (sqlite3_vtab*)pTab;  return rc; } static int fts5ConnectMethod(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return fts5InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr); } static int fts5CreateMethod(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return fts5InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr); }
#define FTS5_PLAN_MATCH 1
#define FTS5_PLAN_SOURCE  2
#define FTS5_PLAN_SPECIAL 3
#define FTS5_PLAN_SORTED_MATCH  4
#define FTS5_PLAN_SCAN  5
#define FTS5_PLAN_ROWID 6
static void fts5SetUniqueFlag(sqlite3_index_info *pIdxInfo){
#if SQLITE_VERSION_NUMBER>=3008012
#ifndef SQLITE_CORE
 if( sqlite3_libversion_number()>=3008012 )
#endif
 {  pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_UNIQUE;  }
#endif
} static int fts5UsePatternMatch(  Fts5Config *pConfig,  struct sqlite3_index_constraint *p ){  assert( FTS5_PATTERN_GLOB==SQLITE_INDEX_CONSTRAINT_GLOB );  assert( FTS5_PATTERN_LIKE==SQLITE_INDEX_CONSTRAINT_LIKE );  if( pConfig->ePattern==FTS5_PATTERN_GLOB && p->op==FTS5_PATTERN_GLOB ){  return 1;  }  if( pConfig->ePattern==FTS5_PATTERN_LIKE   && (p->op==FTS5_PATTERN_LIKE || p->op==FTS5_PATTERN_GLOB)  ){  return 1;  }  return 0; } static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){  Fts5Table *pTab = (Fts5Table*)pVTab;  Fts5Config *pConfig = pTab->pConfig;  const int nCol = pConfig->nCol;  int idxFlags = 0;  int i;  char *idxStr;  int iIdxStr = 0;  int iCons = 0;  int bSeenEq = 0;  int bSeenGt = 0;  int bSeenLt = 0;  int bSeenMatch = 0;  int bSeenRank = 0;  assert( SQLITE_INDEX_CONSTRAINT_EQ<SQLITE_INDEX_CONSTRAINT_MATCH );  assert( SQLITE_INDEX_CONSTRAINT_GT<SQLITE_INDEX_CONSTRAINT_MATCH );  assert( SQLITE_INDEX_CONSTRAINT_LE<SQLITE_INDEX_CONSTRAINT_MATCH );  assert( SQLITE_INDEX_CONSTRAINT_GE<SQLITE_INDEX_CONSTRAINT_MATCH );  assert( SQLITE_INDEX_CONSTRAINT_LE<SQLITE_INDEX_CONSTRAINT_MATCH );  if( pConfig->bLock ){  pTab->base.zErrMsg = sqlite3_mprintf(  "recursively defined fts5 content table"  );  return SQLITE_ERROR;  }  idxStr = (char*)sqlite3_malloc(pInfo->nConstraint * 8 + 1);  if( idxStr==0 ) return SQLITE_NOMEM;  pInfo->idxStr = idxStr;  pInfo->needToFreeIdxStr = 1;  for(i=0; i<pInfo->nConstraint; i++){  struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];  int iCol = p->iColumn;  if( p->op==SQLITE_INDEX_CONSTRAINT_MATCH   || (p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol>=nCol)  ){  if( p->usable==0 || iCol<0 ){  pInfo->estimatedCost = 1e50;  assert( iIdxStr < pInfo->nConstraint*6 + 1 );  idxStr[iIdxStr] = 0;  return SQLITE_OK;  }else{  if( iCol==nCol+1 ){  if( bSeenRank ) continue;  idxStr[iIdxStr++] = 'r';  bSeenRank = 1;  }else if( iCol>=0 ){  bSeenMatch = 1;  idxStr[iIdxStr++] = 'M';  sqlite3_snprintf(6, &idxStr[iIdxStr], "%d", iCol);  idxStr += strlen(&idxStr[iIdxStr]);  assert( idxStr[iIdxStr]=='\0' );  }  pInfo->aConstraintUsage[i].argvIndex = ++iCons;  pInfo->aConstraintUsage[i].omit = 1;  }  }else if( p->usable ){  if( iCol>=0 && iCol<nCol && fts5UsePatternMatch(pConfig, p) ){  assert( p->op==FTS5_PATTERN_LIKE || p->op==FTS5_PATTERN_GLOB );  idxStr[iIdxStr++] = p->op==FTS5_PATTERN_LIKE ? 'L' : 'G';  sqlite3_snprintf(6, &idxStr[iIdxStr], "%d", iCol);  idxStr += strlen(&idxStr[iIdxStr]);  pInfo->aConstraintUsage[i].argvIndex = ++iCons;  assert( idxStr[iIdxStr]=='\0' );  }else if( bSeenEq==0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ && iCol<0 ){  idxStr[iIdxStr++] = '=';  bSeenEq = 1;  pInfo->aConstraintUsage[i].argvIndex = ++iCons;  }  }  }  if( bSeenEq==0 ){  for(i=0; i<pInfo->nConstraint; i++){  struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];  if( p->iColumn<0 && p->usable ){  int op = p->op;  if( op==SQLITE_INDEX_CONSTRAINT_LT || op==SQLITE_INDEX_CONSTRAINT_LE ){  if( bSeenLt ) continue;  idxStr[iIdxStr++] = '<';  pInfo->aConstraintUsage[i].argvIndex = ++iCons;  bSeenLt = 1;  }else  if( op==SQLITE_INDEX_CONSTRAINT_GT || op==SQLITE_INDEX_CONSTRAINT_GE ){  if( bSeenGt ) continue;  idxStr[iIdxStr++] = '>';  pInfo->aConstraintUsage[i].argvIndex = ++iCons;  bSeenGt = 1;  }  }  }  }  idxStr[iIdxStr] = '\0';  if( pInfo->nOrderBy==1 ){  int iSort = pInfo->aOrderBy[0].iColumn;  if( iSort==(pConfig->nCol+1) && bSeenMatch ){  idxFlags |= FTS5_BI_ORDER_RANK;  }else if( iSort==-1 ){  idxFlags |= FTS5_BI_ORDER_ROWID;  }  if( BitFlagTest(idxFlags, FTS5_BI_ORDER_RANK|FTS5_BI_ORDER_ROWID) ){  pInfo->orderByConsumed = 1;  if( pInfo->aOrderBy[0].desc ){  idxFlags |= FTS5_BI_ORDER_DESC;  }  }  }  if( bSeenEq ){  pInfo->estimatedCost = bSeenMatch ? 100.0 : 10.0;  if( bSeenMatch==0 ) fts5SetUniqueFlag(pInfo);  }else if( bSeenLt && bSeenGt ){  pInfo->estimatedCost = bSeenMatch ? 500.0 : 250000.0;  }else if( bSeenLt || bSeenGt ){  pInfo->estimatedCost = bSeenMatch ? 750.0 : 750000.0;  }else{  pInfo->estimatedCost = bSeenMatch ? 1000.0 : 1000000.0;  }  pInfo->idxNum = idxFlags;  return SQLITE_OK; } static int fts5NewTransaction(Fts5FullTable *pTab){  Fts5Cursor *pCsr;  for(pCsr=pTab->pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){  if( pCsr->base.pVtab==(sqlite3_vtab*)pTab ) return SQLITE_OK;  }  return sqlite3Fts5StorageReset(pTab->pStorage); } static int fts5OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){  Fts5FullTable *pTab = (Fts5FullTable*)pVTab;  Fts5Config *pConfig = pTab->p.pConfig;  Fts5Cursor *pCsr = 0;  sqlite3_int64 nByte;  int rc;  rc = fts5NewTransaction(pTab);  if( rc==SQLITE_OK ){  nByte = sizeof(Fts5Cursor) + pConfig->nCol * sizeof(int);  pCsr = (Fts5Cursor*)sqlite3_malloc64(nByte);  if( pCsr ){  Fts5Global *pGlobal = pTab->pGlobal;  memset(pCsr, 0, (size_t)nByte);  pCsr->aColumnSize = (int*)&pCsr[1];  pCsr->pNext = pGlobal->pCsr;  pGlobal->pCsr = pCsr;  pCsr->iCsrId = ++pGlobal->iNextId;  }else{  rc = SQLITE_NOMEM;  }  }  *ppCsr = (sqlite3_vtab_cursor*)pCsr;  return rc; } static int fts5StmtType(Fts5Cursor *pCsr){  if( pCsr->ePlan==FTS5_PLAN_SCAN ){  return (pCsr->bDesc) ? FTS5_STMT_SCAN_DESC : FTS5_STMT_SCAN_ASC;  }  return FTS5_STMT_LOOKUP; } static void fts5CsrNewrow(Fts5Cursor *pCsr){  CsrFlagSet(pCsr,  FTS5CSR_REQUIRE_CONTENT  | FTS5CSR_REQUIRE_DOCSIZE  | FTS5CSR_REQUIRE_INST  | FTS5CSR_REQUIRE_POSLIST  ); } static void fts5FreeCursorComponents(Fts5Cursor *pCsr){  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  Fts5Auxdata *pData;  Fts5Auxdata *pNext;  sqlite3_free(pCsr->aInstIter);  sqlite3_free(pCsr->aInst);  if( pCsr->pStmt ){  int eStmt = fts5StmtType(pCsr);  sqlite3Fts5StorageStmtRelease(pTab->pStorage, eStmt, pCsr->pStmt);  }  if( pCsr->pSorter ){  Fts5Sorter *pSorter = pCsr->pSorter;  sqlite3_finalize(pSorter->pStmt);  sqlite3_free(pSorter);  }  if( pCsr->ePlan!=FTS5_PLAN_SOURCE ){  sqlite3Fts5ExprFree(pCsr->pExpr);  }  for(pData=pCsr->pAuxdata; pData; pData=pNext){  pNext = pData->pNext;  if( pData->xDelete ) pData->xDelete(pData->pPtr);  sqlite3_free(pData);  }  sqlite3_finalize(pCsr->pRankArgStmt);  sqlite3_free(pCsr->apRankArg);  if( CsrFlagTest(pCsr, FTS5CSR_FREE_ZRANK) ){  sqlite3_free(pCsr->zRank);  sqlite3_free(pCsr->zRankArgs);  }  sqlite3Fts5IndexCloseReader(pTab->p.pIndex);  memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan - (u8*)pCsr)); } static int fts5CloseMethod(sqlite3_vtab_cursor *pCursor){  if( pCursor ){  Fts5FullTable *pTab = (Fts5FullTable*)(pCursor->pVtab);  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;  Fts5Cursor **pp;  fts5FreeCursorComponents(pCsr);  for(pp=&pTab->pGlobal->pCsr; (*pp)!=pCsr; pp=&(*pp)->pNext);  *pp = pCsr->pNext;  sqlite3_free(pCsr);  }  return SQLITE_OK; } static int fts5SorterNext(Fts5Cursor *pCsr){  Fts5Sorter *pSorter = pCsr->pSorter;  int rc;  rc = sqlite3_step(pSorter->pStmt);  if( rc==SQLITE_DONE ){  rc = SQLITE_OK;  CsrFlagSet(pCsr, FTS5CSR_EOF);  }else if( rc==SQLITE_ROW ){  const u8 *a;  const u8 *aBlob;  int nBlob;  int i;  int iOff = 0;  rc = SQLITE_OK;  pSorter->iRowid = sqlite3_column_int64(pSorter->pStmt, 0);  nBlob = sqlite3_column_bytes(pSorter->pStmt, 1);  aBlob = a = sqlite3_column_blob(pSorter->pStmt, 1);  if( nBlob>0 ){  for(i=0; i<(pSorter->nIdx-1); i++){  int iVal;  a += fts5GetVarint32(a, iVal);  iOff += iVal;  pSorter->aIdx[i] = iOff;  }  pSorter->aIdx[i] = &aBlob[nBlob] - a;  pSorter->aPoslist = a;  }  fts5CsrNewrow(pCsr);  }  return rc; } static void fts5TripCursors(Fts5FullTable *pTab){  Fts5Cursor *pCsr;  for(pCsr=pTab->pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){  if( pCsr->ePlan==FTS5_PLAN_MATCH   && pCsr->base.pVtab==(sqlite3_vtab*)pTab  ){  CsrFlagSet(pCsr, FTS5CSR_REQUIRE_RESEEK);  }  } } static int fts5CursorReseek(Fts5Cursor *pCsr, int *pbSkip){  int rc = SQLITE_OK;  assert( *pbSkip==0 );  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_RESEEK) ){  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  int bDesc = pCsr->bDesc;  i64 iRowid = sqlite3Fts5ExprRowid(pCsr->pExpr);  rc = sqlite3Fts5ExprFirst(pCsr->pExpr, pTab->p.pIndex, iRowid, bDesc);  if( rc==SQLITE_OK && iRowid!=sqlite3Fts5ExprRowid(pCsr->pExpr) ){  *pbSkip = 1;  }  CsrFlagClear(pCsr, FTS5CSR_REQUIRE_RESEEK);  fts5CsrNewrow(pCsr);  if( sqlite3Fts5ExprEof(pCsr->pExpr) ){  CsrFlagSet(pCsr, FTS5CSR_EOF);  *pbSkip = 1;  }  }  return rc; } static int fts5NextMethod(sqlite3_vtab_cursor *pCursor){  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;  int rc;  assert( (pCsr->ePlan<3)==  (pCsr->ePlan==FTS5_PLAN_MATCH || pCsr->ePlan==FTS5_PLAN_SOURCE)  );  assert( !CsrFlagTest(pCsr, FTS5CSR_EOF) );  if( pCsr->ePlan<3 ){  int bSkip = 0;  if( (rc = fts5CursorReseek(pCsr, &bSkip)) || bSkip ) return rc;  rc = sqlite3Fts5ExprNext(pCsr->pExpr, pCsr->iLastRowid);  CsrFlagSet(pCsr, sqlite3Fts5ExprEof(pCsr->pExpr));  fts5CsrNewrow(pCsr);  }else{  switch( pCsr->ePlan ){  case FTS5_PLAN_SPECIAL: {  CsrFlagSet(pCsr, FTS5CSR_EOF);  rc = SQLITE_OK;  break;  }  case FTS5_PLAN_SORTED_MATCH: {  rc = fts5SorterNext(pCsr);  break;  }  default: {  Fts5Config *pConfig = ((Fts5Table*)pCursor->pVtab)->pConfig;  pConfig->bLock++;  rc = sqlite3_step(pCsr->pStmt);  pConfig->bLock--;  if( rc!=SQLITE_ROW ){  CsrFlagSet(pCsr, FTS5CSR_EOF);  rc = sqlite3_reset(pCsr->pStmt);  if( rc!=SQLITE_OK ){  pCursor->pVtab->zErrMsg = sqlite3_mprintf(  "%s", sqlite3_errmsg(pConfig->db)  );  }  }else{  rc = SQLITE_OK;  }  break;  }  }  }  return rc; } static int fts5PrepareStatement(  sqlite3_stmt **ppStmt,  Fts5Config *pConfig,  const char *zFmt,  ... ){  sqlite3_stmt *pRet = 0;  int rc;  char *zSql;  va_list ap;  va_start(ap, zFmt);  zSql = sqlite3_vmprintf(zFmt, ap);  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_prepare_v3(pConfig->db, zSql, -1,  SQLITE_PREPARE_PERSISTENT, &pRet, 0);  if( rc!=SQLITE_OK ){  *pConfig->pzErrmsg = sqlite3_mprintf("%s", sqlite3_errmsg(pConfig->db));  }  sqlite3_free(zSql);  }  va_end(ap);  *ppStmt = pRet;  return rc; } static int fts5CursorFirstSorted(  Fts5FullTable *pTab,  Fts5Cursor *pCsr,  int bDesc ){  Fts5Config *pConfig = pTab->p.pConfig;  Fts5Sorter *pSorter;  int nPhrase;  sqlite3_int64 nByte;  int rc;  const char *zRank = pCsr->zRank;  const char *zRankArgs = pCsr->zRankArgs;  nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);  nByte = sizeof(Fts5Sorter) + sizeof(int) * (nPhrase-1);  pSorter = (Fts5Sorter*)sqlite3_malloc64(nByte);  if( pSorter==0 ) return SQLITE_NOMEM;  memset(pSorter, 0, (size_t)nByte);  pSorter->nIdx = nPhrase;  rc = fts5PrepareStatement(&pSorter->pStmt, pConfig,  "SELECT rowid, rank FROM %Q.%Q ORDER BY %s(\"%w\"%s%s) %s",  pConfig->zDb, pConfig->zName, zRank, pConfig->zName,  (zRankArgs ? ", " : ""),  (zRankArgs ? zRankArgs : ""),  bDesc ? "DESC" : "ASC"  );  pCsr->pSorter = pSorter;  if( rc==SQLITE_OK ){  assert( pTab->pSortCsr==0 );  pTab->pSortCsr = pCsr;  rc = fts5SorterNext(pCsr);  pTab->pSortCsr = 0;  }  if( rc!=SQLITE_OK ){  sqlite3_finalize(pSorter->pStmt);  sqlite3_free(pSorter);  pCsr->pSorter = 0;  }  return rc; } static int fts5CursorFirst(Fts5FullTable *pTab, Fts5Cursor *pCsr, int bDesc){  int rc;  Fts5Expr *pExpr = pCsr->pExpr;  rc = sqlite3Fts5ExprFirst(pExpr, pTab->p.pIndex, pCsr->iFirstRowid, bDesc);  if( sqlite3Fts5ExprEof(pExpr) ){  CsrFlagSet(pCsr, FTS5CSR_EOF);  }  fts5CsrNewrow(pCsr);  return rc; } static int fts5SpecialMatch(  Fts5FullTable *pTab,  Fts5Cursor *pCsr,  const char *zQuery ){  int rc = SQLITE_OK;  const char *z = zQuery;  int n;  while( z[0]==' ' ) z++;  for(n=0; z[n] && z[n]!=' '; n++);  assert( pTab->p.base.zErrMsg==0 );  pCsr->ePlan = FTS5_PLAN_SPECIAL;  if( n==5 && 0==sqlite3_strnicmp("reads", z, n) ){  pCsr->iSpecial = sqlite3Fts5IndexReads(pTab->p.pIndex);  }  else if( n==2 && 0==sqlite3_strnicmp("id", z, n) ){  pCsr->iSpecial = pCsr->iCsrId;  }  else{  pTab->p.base.zErrMsg = sqlite3_mprintf("unknown special query: %.*s", n, z);  rc = SQLITE_ERROR;  }  return rc; } static Fts5Auxiliary *fts5FindAuxiliary(Fts5FullTable *pTab, const char *zName){  Fts5Auxiliary *pAux;  for(pAux=pTab->pGlobal->pAux; pAux; pAux=pAux->pNext){  if( sqlite3_stricmp(zName, pAux->zFunc)==0 ) return pAux;  }  return 0; } static int fts5FindRankFunction(Fts5Cursor *pCsr){  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  Fts5Config *pConfig = pTab->p.pConfig;  int rc = SQLITE_OK;  Fts5Auxiliary *pAux = 0;  const char *zRank = pCsr->zRank;  const char *zRankArgs = pCsr->zRankArgs;  if( zRankArgs ){  char *zSql = sqlite3Fts5Mprintf(&rc, "SELECT %s", zRankArgs);  if( zSql ){  sqlite3_stmt *pStmt = 0;  rc = sqlite3_prepare_v3(pConfig->db, zSql, -1,  SQLITE_PREPARE_PERSISTENT, &pStmt, 0);  sqlite3_free(zSql);  assert( rc==SQLITE_OK || pCsr->pRankArgStmt==0 );  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pStmt) ){  sqlite3_int64 nByte;  pCsr->nRankArg = sqlite3_column_count(pStmt);  nByte = sizeof(sqlite3_value*)*pCsr->nRankArg;  pCsr->apRankArg = (sqlite3_value**)sqlite3Fts5MallocZero(&rc, nByte);  if( rc==SQLITE_OK ){  int i;  for(i=0; i<pCsr->nRankArg; i++){  pCsr->apRankArg[i] = sqlite3_column_value(pStmt, i);  }  }  pCsr->pRankArgStmt = pStmt;  }else{  rc = sqlite3_finalize(pStmt);  assert( rc!=SQLITE_OK );  }  }  }  }  if( rc==SQLITE_OK ){  pAux = fts5FindAuxiliary(pTab, zRank);  if( pAux==0 ){  assert( pTab->p.base.zErrMsg==0 );  pTab->p.base.zErrMsg = sqlite3_mprintf("no such function: %s", zRank);  rc = SQLITE_ERROR;  }  }  pCsr->pRank = pAux;  return rc; } static int fts5CursorParseRank(  Fts5Config *pConfig,  Fts5Cursor *pCsr,  sqlite3_value *pRank ){  int rc = SQLITE_OK;  if( pRank ){  const char *z = (const char*)sqlite3_value_text(pRank);  char *zRank = 0;  char *zRankArgs = 0;  if( z==0 ){  if( sqlite3_value_type(pRank)==SQLITE_NULL ) rc = SQLITE_ERROR;  }else{  rc = sqlite3Fts5ConfigParseRank(z, &zRank, &zRankArgs);  }  if( rc==SQLITE_OK ){  pCsr->zRank = zRank;  pCsr->zRankArgs = zRankArgs;  CsrFlagSet(pCsr, FTS5CSR_FREE_ZRANK);  }else if( rc==SQLITE_ERROR ){  pCsr->base.pVtab->zErrMsg = sqlite3_mprintf(  "parse error in rank function: %s", z  );  }  }else{  if( pConfig->zRank ){  pCsr->zRank = (char*)pConfig->zRank;  pCsr->zRankArgs = (char*)pConfig->zRankArgs;  }else{  pCsr->zRank = (char*)FTS5_DEFAULT_RANK;  pCsr->zRankArgs = 0;  }  }  return rc; } static i64 fts5GetRowidLimit(sqlite3_value *pVal, i64 iDefault){  if( pVal ){  int eType = sqlite3_value_numeric_type(pVal);  if( eType==SQLITE_INTEGER ){  return sqlite3_value_int64(pVal);  }  }  return iDefault; } static int fts5FilterMethod(  sqlite3_vtab_cursor *pCursor,  int idxNum,  const char *idxStr,  int nVal,  sqlite3_value **apVal ){  Fts5FullTable *pTab = (Fts5FullTable*)(pCursor->pVtab);  Fts5Config *pConfig = pTab->p.pConfig;  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;  int rc = SQLITE_OK;  int bDesc;  int bOrderByRank;  sqlite3_value *pRank = 0;  sqlite3_value *pRowidEq = 0;  sqlite3_value *pRowidLe = 0;  sqlite3_value *pRowidGe = 0;  int iCol;  char **pzErrmsg = pConfig->pzErrmsg;  int i;  int iIdxStr = 0;  Fts5Expr *pExpr = 0;  if( pConfig->bLock ){  pTab->p.base.zErrMsg = sqlite3_mprintf(  "recursively defined fts5 content table"  );  return SQLITE_ERROR;  }  if( pCsr->ePlan ){  fts5FreeCursorComponents(pCsr);  memset(&pCsr->ePlan, 0, sizeof(Fts5Cursor) - ((u8*)&pCsr->ePlan-(u8*)pCsr));  }  assert( pCsr->pStmt==0 );  assert( pCsr->pExpr==0 );  assert( pCsr->csrflags==0 );  assert( pCsr->pRank==0 );  assert( pCsr->zRank==0 );  assert( pCsr->zRankArgs==0 );  assert( pTab->pSortCsr==0 || nVal==0 );  assert( pzErrmsg==0 || pzErrmsg==&pTab->p.base.zErrMsg );  pConfig->pzErrmsg = &pTab->p.base.zErrMsg;  for(i=0; i<nVal; i++){  switch( idxStr[iIdxStr++] ){  case 'r':  pRank = apVal[i];  break;  case 'M': {  const char *zText = (const char*)sqlite3_value_text(apVal[i]);  if( zText==0 ) zText = "";  iCol = 0;  do{  iCol = iCol*10 + (idxStr[iIdxStr]-'0');  iIdxStr++;  }while( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' );  if( zText[0]=='*' ){  rc = fts5SpecialMatch(pTab, pCsr, &zText[1]);  goto filter_out;  }else{  char **pzErr = &pTab->p.base.zErrMsg;  rc = sqlite3Fts5ExprNew(pConfig, 0, iCol, zText, &pExpr, pzErr);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ExprAnd(&pCsr->pExpr, pExpr);  pExpr = 0;  }  if( rc!=SQLITE_OK ) goto filter_out;  }  break;  }  case 'L':  case 'G': {  int bGlob = (idxStr[iIdxStr-1]=='G');  const char *zText = (const char*)sqlite3_value_text(apVal[i]);  iCol = 0;  do{  iCol = iCol*10 + (idxStr[iIdxStr]-'0');  iIdxStr++;  }while( idxStr[iIdxStr]>='0' && idxStr[iIdxStr]<='9' );  if( zText ){  rc = sqlite3Fts5ExprPattern(pConfig, bGlob, iCol, zText, &pExpr);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ExprAnd(&pCsr->pExpr, pExpr);  pExpr = 0;  }  if( rc!=SQLITE_OK ) goto filter_out;  break;  }  case '=':  pRowidEq = apVal[i];  break;  case '<':  pRowidLe = apVal[i];  break;  default: assert( idxStr[iIdxStr-1]=='>' );  pRowidGe = apVal[i];  break;  }  }  bOrderByRank = ((idxNum & FTS5_BI_ORDER_RANK) ? 1 : 0);  pCsr->bDesc = bDesc = ((idxNum & FTS5_BI_ORDER_DESC) ? 1 : 0);  if( pRowidEq ){  pRowidLe = pRowidGe = pRowidEq;  }  if( bDesc ){  pCsr->iFirstRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);  pCsr->iLastRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);  }else{  pCsr->iLastRowid = fts5GetRowidLimit(pRowidLe, LARGEST_INT64);  pCsr->iFirstRowid = fts5GetRowidLimit(pRowidGe, SMALLEST_INT64);  }  if( pTab->pSortCsr ){  assert( pRowidEq==0 && pRowidLe==0 && pRowidGe==0 && pRank==0 );  assert( nVal==0 && bOrderByRank==0 && bDesc==0 );  assert( pCsr->iLastRowid==LARGEST_INT64 );  assert( pCsr->iFirstRowid==SMALLEST_INT64 );  if( pTab->pSortCsr->bDesc ){  pCsr->iLastRowid = pTab->pSortCsr->iFirstRowid;  pCsr->iFirstRowid = pTab->pSortCsr->iLastRowid;  }else{  pCsr->iLastRowid = pTab->pSortCsr->iLastRowid;  pCsr->iFirstRowid = pTab->pSortCsr->iFirstRowid;  }  pCsr->ePlan = FTS5_PLAN_SOURCE;  pCsr->pExpr = pTab->pSortCsr->pExpr;  rc = fts5CursorFirst(pTab, pCsr, bDesc);  }else if( pCsr->pExpr ){  rc = fts5CursorParseRank(pConfig, pCsr, pRank);  if( rc==SQLITE_OK ){  if( bOrderByRank ){  pCsr->ePlan = FTS5_PLAN_SORTED_MATCH;  rc = fts5CursorFirstSorted(pTab, pCsr, bDesc);  }else{  pCsr->ePlan = FTS5_PLAN_MATCH;  rc = fts5CursorFirst(pTab, pCsr, bDesc);  }  }  }else if( pConfig->zContent==0 ){  *pConfig->pzErrmsg = sqlite3_mprintf(  "%s: table does not support scanning", pConfig->zName  );  rc = SQLITE_ERROR;  }else{  pCsr->ePlan = (pRowidEq ? FTS5_PLAN_ROWID : FTS5_PLAN_SCAN);  rc = sqlite3Fts5StorageStmt(  pTab->pStorage, fts5StmtType(pCsr), &pCsr->pStmt, &pTab->p.base.zErrMsg  );  if( rc==SQLITE_OK ){  if( pRowidEq!=0 ){  assert( pCsr->ePlan==FTS5_PLAN_ROWID );  sqlite3_bind_value(pCsr->pStmt, 1, pRowidEq);  }else{  sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iFirstRowid);  sqlite3_bind_int64(pCsr->pStmt, 2, pCsr->iLastRowid);  }  rc = fts5NextMethod(pCursor);  }  }  filter_out:  sqlite3Fts5ExprFree(pExpr);  pConfig->pzErrmsg = pzErrmsg;  return rc; } static int fts5EofMethod(sqlite3_vtab_cursor *pCursor){  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;  return (CsrFlagTest(pCsr, FTS5CSR_EOF) ? 1 : 0); } static i64 fts5CursorRowid(Fts5Cursor *pCsr){  assert( pCsr->ePlan==FTS5_PLAN_MATCH   || pCsr->ePlan==FTS5_PLAN_SORTED_MATCH   || pCsr->ePlan==FTS5_PLAN_SOURCE  );  if( pCsr->pSorter ){  return pCsr->pSorter->iRowid;  }else{  return sqlite3Fts5ExprRowid(pCsr->pExpr);  } } static int fts5RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;  int ePlan = pCsr->ePlan;  assert( CsrFlagTest(pCsr, FTS5CSR_EOF)==0 );  switch( ePlan ){  case FTS5_PLAN_SPECIAL:  *pRowid = 0;  break;  case FTS5_PLAN_SOURCE:  case FTS5_PLAN_MATCH:  case FTS5_PLAN_SORTED_MATCH:  *pRowid = fts5CursorRowid(pCsr);  break;  default:  *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);  break;  }  return SQLITE_OK; } static int fts5SeekCursor(Fts5Cursor *pCsr, int bErrormsg){  int rc = SQLITE_OK;  if( pCsr->pStmt==0 ){  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  int eStmt = fts5StmtType(pCsr);  rc = sqlite3Fts5StorageStmt(  pTab->pStorage, eStmt, &pCsr->pStmt, (bErrormsg?&pTab->p.base.zErrMsg:0)  );  assert( rc!=SQLITE_OK || pTab->p.base.zErrMsg==0 );  assert( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_CONTENT) );  }  if( rc==SQLITE_OK && CsrFlagTest(pCsr, FTS5CSR_REQUIRE_CONTENT) ){  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);  assert( pCsr->pExpr );  sqlite3_reset(pCsr->pStmt);  sqlite3_bind_int64(pCsr->pStmt, 1, fts5CursorRowid(pCsr));  pTab->pConfig->bLock++;  rc = sqlite3_step(pCsr->pStmt);  pTab->pConfig->bLock--;  if( rc==SQLITE_ROW ){  rc = SQLITE_OK;  CsrFlagClear(pCsr, FTS5CSR_REQUIRE_CONTENT);  }else{  rc = sqlite3_reset(pCsr->pStmt);  if( rc==SQLITE_OK ){  rc = FTS5_CORRUPT;  }else if( pTab->pConfig->pzErrmsg ){  *pTab->pConfig->pzErrmsg = sqlite3_mprintf(  "%s", sqlite3_errmsg(pTab->pConfig->db)  );  }  }  }  return rc; } static void fts5SetVtabError(Fts5FullTable *p, const char *zFormat, ...){  va_list ap;  va_start(ap, zFormat);  assert( p->p.base.zErrMsg==0 );  p->p.base.zErrMsg = sqlite3_vmprintf(zFormat, ap);  va_end(ap); } static int fts5SpecialInsert(  Fts5FullTable *pTab,  const char *zCmd,  sqlite3_value *pVal ){  Fts5Config *pConfig = pTab->p.pConfig;  int rc = SQLITE_OK;  int bError = 0;  if( 0==sqlite3_stricmp("delete-all", zCmd) ){  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){  fts5SetVtabError(pTab,  "'delete-all' may only be used with a "  "contentless or external content fts5 table"  );  rc = SQLITE_ERROR;  }else{  rc = sqlite3Fts5StorageDeleteAll(pTab->pStorage);  }  }else if( 0==sqlite3_stricmp("rebuild", zCmd) ){  if( pConfig->eContent==FTS5_CONTENT_NONE ){  fts5SetVtabError(pTab,  "'rebuild' may not be used with a contentless fts5 table"  );  rc = SQLITE_ERROR;  }else{  rc = sqlite3Fts5StorageRebuild(pTab->pStorage);  }  }else if( 0==sqlite3_stricmp("optimize", zCmd) ){  rc = sqlite3Fts5StorageOptimize(pTab->pStorage);  }else if( 0==sqlite3_stricmp("merge", zCmd) ){  int nMerge = sqlite3_value_int(pVal);  rc = sqlite3Fts5StorageMerge(pTab->pStorage, nMerge);  }else if( 0==sqlite3_stricmp("integrity-check", zCmd) ){  int iArg = sqlite3_value_int(pVal);  rc = sqlite3Fts5StorageIntegrity(pTab->pStorage, iArg);
#ifdef SQLITE_DEBUG
 }else if( 0==sqlite3_stricmp("prefix-index", zCmd) ){  pConfig->bPrefixIndex = sqlite3_value_int(pVal);
#endif
 }else{  rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ConfigSetValue(pTab->p.pConfig, zCmd, pVal, &bError);  }  if( rc==SQLITE_OK ){  if( bError ){  rc = SQLITE_ERROR;  }else{  rc = sqlite3Fts5StorageConfigValue(pTab->pStorage, zCmd, pVal, 0);  }  }  }  return rc; } static int fts5SpecialDelete(  Fts5FullTable *pTab,  sqlite3_value **apVal ){  int rc = SQLITE_OK;  int eType1 = sqlite3_value_type(apVal[1]);  if( eType1==SQLITE_INTEGER ){  sqlite3_int64 iDel = sqlite3_value_int64(apVal[1]);  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, &apVal[2]);  }  return rc; } static void fts5StorageInsert(  int *pRc,  Fts5FullTable *pTab,  sqlite3_value **apVal,  i64 *piRowid ){  int rc = *pRc;  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, piRowid);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal, *piRowid);  }  *pRc = rc; } static int fts5UpdateMethod(  sqlite3_vtab *pVtab,  int nArg,  sqlite3_value **apVal,  sqlite_int64 *pRowid ){  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;  Fts5Config *pConfig = pTab->p.pConfig;  int eType0;  int rc = SQLITE_OK;  assert( pTab->ts.eState==1 );  assert( pVtab->zErrMsg==0 );  assert( nArg==1 || nArg==(2+pConfig->nCol+2) );  assert( sqlite3_value_type(apVal[0])==SQLITE_INTEGER   || sqlite3_value_type(apVal[0])==SQLITE_NULL  );  assert( pTab->p.pConfig->pzErrmsg==0 );  pTab->p.pConfig->pzErrmsg = &pTab->p.base.zErrMsg;  fts5TripCursors(pTab);  eType0 = sqlite3_value_type(apVal[0]);  if( eType0==SQLITE_NULL   && sqlite3_value_type(apVal[2+pConfig->nCol])!=SQLITE_NULL  ){  const char *z = (const char*)sqlite3_value_text(apVal[2+pConfig->nCol]);  if( pConfig->eContent!=FTS5_CONTENT_NORMAL  && 0==sqlite3_stricmp("delete", z)  ){  rc = fts5SpecialDelete(pTab, apVal);  }else{  rc = fts5SpecialInsert(pTab, z, apVal[2 + pConfig->nCol + 1]);  }  }else{  int eConflict = SQLITE_ABORT;  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){  eConflict = sqlite3_vtab_on_conflict(pConfig->db);  }  assert( eType0==SQLITE_INTEGER || eType0==SQLITE_NULL );  assert( nArg!=1 || eType0==SQLITE_INTEGER );  if( eType0==SQLITE_INTEGER && fts5IsContentless(pTab) ){  pTab->p.base.zErrMsg = sqlite3_mprintf(  "cannot %s contentless fts5 table: %s",  (nArg>1 ? "UPDATE" : "DELETE from"), pConfig->zName  );  rc = SQLITE_ERROR;  }  else if( nArg==1 ){  i64 iDel = sqlite3_value_int64(apVal[0]);  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, 0);  }  else{  int eType1 = sqlite3_value_numeric_type(apVal[1]);  if( eType1!=SQLITE_INTEGER && eType1!=SQLITE_NULL ){  rc = SQLITE_MISMATCH;  }  else if( eType0!=SQLITE_INTEGER ){  if( eConflict==SQLITE_REPLACE && eType1==SQLITE_INTEGER ){  i64 iNew = sqlite3_value_int64(apVal[1]);  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0);  }  fts5StorageInsert(&rc, pTab, apVal, pRowid);  }  else{  i64 iOld = sqlite3_value_int64(apVal[0]);  i64 iNew = sqlite3_value_int64(apVal[1]);  if( eType1==SQLITE_INTEGER && iOld!=iNew ){  if( eConflict==SQLITE_REPLACE ){  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0);  }  fts5StorageInsert(&rc, pTab, apVal, pRowid);  }else{  rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, pRowid);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal,*pRowid);  }  }  }else{  rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);  fts5StorageInsert(&rc, pTab, apVal, pRowid);  }  }  }  }  pTab->p.pConfig->pzErrmsg = 0;  return rc; } static int fts5SyncMethod(sqlite3_vtab *pVtab){  int rc;  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;  fts5CheckTransactionState(pTab, FTS5_SYNC, 0);  pTab->p.pConfig->pzErrmsg = &pTab->p.base.zErrMsg;  fts5TripCursors(pTab);  rc = sqlite3Fts5StorageSync(pTab->pStorage);  pTab->p.pConfig->pzErrmsg = 0;  return rc; } static int fts5BeginMethod(sqlite3_vtab *pVtab){  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_BEGIN, 0);  fts5NewTransaction((Fts5FullTable*)pVtab);  return SQLITE_OK; } static int fts5CommitMethod(sqlite3_vtab *pVtab){  UNUSED_PARAM(pVtab);  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_COMMIT, 0);  return SQLITE_OK; } static int fts5RollbackMethod(sqlite3_vtab *pVtab){  int rc;  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;  fts5CheckTransactionState(pTab, FTS5_ROLLBACK, 0);  rc = sqlite3Fts5StorageRollback(pTab->pStorage);  return rc; } static int fts5CsrPoslist(Fts5Cursor*, int, const u8**, int*); static void *fts5ApiUserData(Fts5Context *pCtx){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  return pCsr->pAux->pUserData; } static int fts5ApiColumnCount(Fts5Context *pCtx){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  return ((Fts5Table*)(pCsr->base.pVtab))->pConfig->nCol; } static int fts5ApiColumnTotalSize(  Fts5Context *pCtx,  int iCol,  sqlite3_int64 *pnToken ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  return sqlite3Fts5StorageSize(pTab->pStorage, iCol, pnToken); } static int fts5ApiRowCount(Fts5Context *pCtx, i64 *pnRow){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  return sqlite3Fts5StorageRowCount(pTab->pStorage, pnRow); } static int fts5ApiTokenize(  Fts5Context *pCtx,  const char *pText, int nText,  void *pUserData,  int (*xToken)(void*, int, const char*, int, int, int) ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);  return sqlite3Fts5Tokenize(  pTab->pConfig, FTS5_TOKENIZE_AUX, pText, nText, pUserData, xToken  ); } static int fts5ApiPhraseCount(Fts5Context *pCtx){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  return sqlite3Fts5ExprPhraseCount(pCsr->pExpr); } static int fts5ApiPhraseSize(Fts5Context *pCtx, int iPhrase){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  return sqlite3Fts5ExprPhraseSize(pCsr->pExpr, iPhrase); } static int fts5ApiColumnText(  Fts5Context *pCtx,  int iCol,  const char **pz,  int *pn ){  int rc = SQLITE_OK;  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  if( fts5IsContentless((Fts5FullTable*)(pCsr->base.pVtab))   || pCsr->ePlan==FTS5_PLAN_SPECIAL  ){  *pz = 0;  *pn = 0;  }else{  rc = fts5SeekCursor(pCsr, 0);  if( rc==SQLITE_OK ){  *pz = (const char*)sqlite3_column_text(pCsr->pStmt, iCol+1);  *pn = sqlite3_column_bytes(pCsr->pStmt, iCol+1);  }  }  return rc; } static int fts5CsrPoslist(  Fts5Cursor *pCsr,  int iPhrase,  const u8 **pa,  int *pn ){  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;  int rc = SQLITE_OK;  int bLive = (pCsr->pSorter==0);  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_POSLIST) ){  if( pConfig->eDetail!=FTS5_DETAIL_FULL ){  Fts5PoslistPopulator *aPopulator;  int i;  aPopulator = sqlite3Fts5ExprClearPoslists(pCsr->pExpr, bLive);  if( aPopulator==0 ) rc = SQLITE_NOMEM;  for(i=0; i<pConfig->nCol && rc==SQLITE_OK; i++){  int n; const char *z;  rc = fts5ApiColumnText((Fts5Context*)pCsr, i, &z, &n);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5ExprPopulatePoslists(  pConfig, pCsr->pExpr, aPopulator, i, z, n  );  }  }  sqlite3_free(aPopulator);  if( pCsr->pSorter ){  sqlite3Fts5ExprCheckPoslists(pCsr->pExpr, pCsr->pSorter->iRowid);  }  }  CsrFlagClear(pCsr, FTS5CSR_REQUIRE_POSLIST);  }  if( pCsr->pSorter && pConfig->eDetail==FTS5_DETAIL_FULL ){  Fts5Sorter *pSorter = pCsr->pSorter;  int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);  *pn = pSorter->aIdx[iPhrase] - i1;  *pa = &pSorter->aPoslist[i1];  }else{  *pn = sqlite3Fts5ExprPoslist(pCsr->pExpr, iPhrase, pa);  }  return rc; } static int fts5CacheInstArray(Fts5Cursor *pCsr){  int rc = SQLITE_OK;  Fts5PoslistReader *aIter;  int nIter;  int nCol = ((Fts5Table*)pCsr->base.pVtab)->pConfig->nCol;  nIter = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);  if( pCsr->aInstIter==0 ){  sqlite3_int64 nByte = sizeof(Fts5PoslistReader) * nIter;  pCsr->aInstIter = (Fts5PoslistReader*)sqlite3Fts5MallocZero(&rc, nByte);  }  aIter = pCsr->aInstIter;  if( aIter ){  int nInst = 0;  int i;  for(i=0; i<nIter && rc==SQLITE_OK; i++){  const u8 *a;  int n;  rc = fts5CsrPoslist(pCsr, i, &a, &n);  if( rc==SQLITE_OK ){  sqlite3Fts5PoslistReaderInit(a, n, &aIter[i]);  }  }  if( rc==SQLITE_OK ){  while( 1 ){  int *aInst;  int iBest = -1;  for(i=0; i<nIter; i++){  if( (aIter[i].bEof==0)  && (iBest<0 || aIter[i].iPos<aIter[iBest].iPos)  ){  iBest = i;  }  }  if( iBest<0 ) break;  nInst++;  if( nInst>=pCsr->nInstAlloc ){  int nNewSize = pCsr->nInstAlloc ? pCsr->nInstAlloc*2 : 32;  aInst = (int*)sqlite3_realloc64(  pCsr->aInst, nNewSize*sizeof(int)*3  );  if( aInst ){  pCsr->aInst = aInst;  pCsr->nInstAlloc = nNewSize;  }else{  nInst--;  rc = SQLITE_NOMEM;  break;  }  }  aInst = &pCsr->aInst[3 * (nInst-1)];  aInst[0] = iBest;  aInst[1] = FTS5_POS2COLUMN(aIter[iBest].iPos);  aInst[2] = FTS5_POS2OFFSET(aIter[iBest].iPos);  if( aInst[1]<0 || aInst[1]>=nCol ){  rc = FTS5_CORRUPT;  break;  }  sqlite3Fts5PoslistReaderNext(&aIter[iBest]);  }  }  pCsr->nInstCount = nInst;  CsrFlagClear(pCsr, FTS5CSR_REQUIRE_INST);  }  return rc; } static int fts5ApiInstCount(Fts5Context *pCtx, int *pnInst){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  int rc = SQLITE_OK;  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST)==0   || SQLITE_OK==(rc = fts5CacheInstArray(pCsr)) ){  *pnInst = pCsr->nInstCount;  }  return rc; } static int fts5ApiInst(  Fts5Context *pCtx,  int iIdx,  int *piPhrase,  int *piCol,  int *piOff ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  int rc = SQLITE_OK;  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST)==0   || SQLITE_OK==(rc = fts5CacheInstArray(pCsr))  ){  if( iIdx<0 || iIdx>=pCsr->nInstCount ){  rc = SQLITE_RANGE;
#if 0
 }else if( fts5IsOffsetless((Fts5Table*)pCsr->base.pVtab) ){  *piPhrase = pCsr->aInst[iIdx*3];  *piCol = pCsr->aInst[iIdx*3 + 2];  *piOff = -1;
#endif
 }else{  *piPhrase = pCsr->aInst[iIdx*3];  *piCol = pCsr->aInst[iIdx*3 + 1];  *piOff = pCsr->aInst[iIdx*3 + 2];  }  }  return rc; } static sqlite3_int64 fts5ApiRowid(Fts5Context *pCtx){  return fts5CursorRowid((Fts5Cursor*)pCtx); } static int fts5ColumnSizeCb(  void *pContext,  int tflags,  const char *pUnused,  int nUnused,  int iUnused1,  int iUnused2 ){  int *pCnt = (int*)pContext;  UNUSED_PARAM2(pUnused, nUnused);  UNUSED_PARAM2(iUnused1, iUnused2);  if( (tflags & FTS5_TOKEN_COLOCATED)==0 ){  (*pCnt)++;  }  return SQLITE_OK; } static int fts5ApiColumnSize(Fts5Context *pCtx, int iCol, int *pnToken){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  Fts5Config *pConfig = pTab->p.pConfig;  int rc = SQLITE_OK;  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_DOCSIZE) ){  if( pConfig->bColumnsize ){  i64 iRowid = fts5CursorRowid(pCsr);  rc = sqlite3Fts5StorageDocsize(pTab->pStorage, iRowid, pCsr->aColumnSize);  }else if( pConfig->zContent==0 ){  int i;  for(i=0; i<pConfig->nCol; i++){  if( pConfig->abUnindexed[i]==0 ){  pCsr->aColumnSize[i] = -1;  }  }  }else{  int i;  for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){  if( pConfig->abUnindexed[i]==0 ){  const char *z; int n;  void *p = (void*)(&pCsr->aColumnSize[i]);  pCsr->aColumnSize[i] = 0;  rc = fts5ApiColumnText(pCtx, i, &z, &n);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5Tokenize(  pConfig, FTS5_TOKENIZE_AUX, z, n, p, fts5ColumnSizeCb  );  }  }  }  }  CsrFlagClear(pCsr, FTS5CSR_REQUIRE_DOCSIZE);  }  if( iCol<0 ){  int i;  *pnToken = 0;  for(i=0; i<pConfig->nCol; i++){  *pnToken += pCsr->aColumnSize[i];  }  }else if( iCol<pConfig->nCol ){  *pnToken = pCsr->aColumnSize[iCol];  }else{  *pnToken = 0;  rc = SQLITE_RANGE;  }  return rc; } static int fts5ApiSetAuxdata(  Fts5Context *pCtx,  void *pPtr,  void(*xDelete)(void*) ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5Auxdata *pData;  for(pData=pCsr->pAuxdata; pData; pData=pData->pNext){  if( pData->pAux==pCsr->pAux ) break;  }  if( pData ){  if( pData->xDelete ){  pData->xDelete(pData->pPtr);  }  }else{  int rc = SQLITE_OK;  pData = (Fts5Auxdata*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Auxdata));  if( pData==0 ){  if( xDelete ) xDelete(pPtr);  return rc;  }  pData->pAux = pCsr->pAux;  pData->pNext = pCsr->pAuxdata;  pCsr->pAuxdata = pData;  }  pData->xDelete = xDelete;  pData->pPtr = pPtr;  return SQLITE_OK; } static void *fts5ApiGetAuxdata(Fts5Context *pCtx, int bClear){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5Auxdata *pData;  void *pRet = 0;  for(pData=pCsr->pAuxdata; pData; pData=pData->pNext){  if( pData->pAux==pCsr->pAux ) break;  }  if( pData ){  pRet = pData->pPtr;  if( bClear ){  pData->pPtr = 0;  pData->xDelete = 0;  }  }  return pRet; } static void fts5ApiPhraseNext(  Fts5Context *pUnused,  Fts5PhraseIter *pIter,  int *piCol, int *piOff ){  UNUSED_PARAM(pUnused);  if( pIter->a>=pIter->b ){  *piCol = -1;  *piOff = -1;  }else{  int iVal;  pIter->a += fts5GetVarint32(pIter->a, iVal);  if( iVal==1 ){  pIter->a += fts5GetVarint32(pIter->a, iVal);  *piCol = iVal;  *piOff = 0;  pIter->a += fts5GetVarint32(pIter->a, iVal);  }  *piOff += (iVal-2);  } } static int fts5ApiPhraseFirst(  Fts5Context *pCtx,  int iPhrase,  Fts5PhraseIter *pIter,  int *piCol, int *piOff ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  int n;  int rc = fts5CsrPoslist(pCsr, iPhrase, &pIter->a, &n);  if( rc==SQLITE_OK ){  assert( pIter->a || n==0 );  pIter->b = (pIter->a ? &pIter->a[n] : 0);  *piCol = 0;  *piOff = 0;  fts5ApiPhraseNext(pCtx, pIter, piCol, piOff);  }  return rc; } static void fts5ApiPhraseNextColumn(  Fts5Context *pCtx,  Fts5PhraseIter *pIter,  int *piCol ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;  if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){  if( pIter->a>=pIter->b ){  *piCol = -1;  }else{  int iIncr;  pIter->a += fts5GetVarint32(&pIter->a[0], iIncr);  *piCol += (iIncr-2);  }  }else{  while( 1 ){  int dummy;  if( pIter->a>=pIter->b ){  *piCol = -1;  return;  }  if( pIter->a[0]==0x01 ) break;  pIter->a += fts5GetVarint32(pIter->a, dummy);  }  pIter->a += 1 + fts5GetVarint32(&pIter->a[1], *piCol);  } } static int fts5ApiPhraseFirstColumn(  Fts5Context *pCtx,  int iPhrase,  Fts5PhraseIter *pIter,  int *piCol ){  int rc = SQLITE_OK;  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;  if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){  Fts5Sorter *pSorter = pCsr->pSorter;  int n;  if( pSorter ){  int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);  n = pSorter->aIdx[iPhrase] - i1;  pIter->a = &pSorter->aPoslist[i1];  }else{  rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, iPhrase, &pIter->a, &n);  }  if( rc==SQLITE_OK ){  assert( pIter->a || n==0 );  pIter->b = (pIter->a ? &pIter->a[n] : 0);  *piCol = 0;  fts5ApiPhraseNextColumn(pCtx, pIter, piCol);  }  }else{  int n;  rc = fts5CsrPoslist(pCsr, iPhrase, &pIter->a, &n);  if( rc==SQLITE_OK ){  assert( pIter->a || n==0 );  pIter->b = (pIter->a ? &pIter->a[n] : 0);  if( n<=0 ){  *piCol = -1;  }else if( pIter->a[0]==0x01 ){  pIter->a += 1 + fts5GetVarint32(&pIter->a[1], *piCol);  }else{  *piCol = 0;  }  }  }  return rc; } static int fts5ApiQueryPhrase(Fts5Context*, int, void*,  int(*)(const Fts5ExtensionApi*, Fts5Context*, void*) ); static const Fts5ExtensionApi sFts5Api = {  2,  fts5ApiUserData,  fts5ApiColumnCount,  fts5ApiRowCount,  fts5ApiColumnTotalSize,  fts5ApiTokenize,  fts5ApiPhraseCount,  fts5ApiPhraseSize,  fts5ApiInstCount,  fts5ApiInst,  fts5ApiRowid,  fts5ApiColumnText,  fts5ApiColumnSize,  fts5ApiQueryPhrase,  fts5ApiSetAuxdata,  fts5ApiGetAuxdata,  fts5ApiPhraseFirst,  fts5ApiPhraseNext,  fts5ApiPhraseFirstColumn,  fts5ApiPhraseNextColumn, }; static int fts5ApiQueryPhrase(  Fts5Context *pCtx,  int iPhrase,  void *pUserData,  int(*xCallback)(const Fts5ExtensionApi*, Fts5Context*, void*) ){  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;  Fts5FullTable *pTab = (Fts5FullTable*)(pCsr->base.pVtab);  int rc;  Fts5Cursor *pNew = 0;  rc = fts5OpenMethod(pCsr->base.pVtab, (sqlite3_vtab_cursor**)&pNew);  if( rc==SQLITE_OK ){  pNew->ePlan = FTS5_PLAN_MATCH;  pNew->iFirstRowid = SMALLEST_INT64;  pNew->iLastRowid = LARGEST_INT64;  pNew->base.pVtab = (sqlite3_vtab*)pTab;  rc = sqlite3Fts5ExprClonePhrase(pCsr->pExpr, iPhrase, &pNew->pExpr);  }  if( rc==SQLITE_OK ){  for(rc = fts5CursorFirst(pTab, pNew, 0);  rc==SQLITE_OK && CsrFlagTest(pNew, FTS5CSR_EOF)==0;  rc = fts5NextMethod((sqlite3_vtab_cursor*)pNew)  ){  rc = xCallback(&sFts5Api, (Fts5Context*)pNew, pUserData);  if( rc!=SQLITE_OK ){  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  break;  }  }  }  fts5CloseMethod((sqlite3_vtab_cursor*)pNew);  return rc; } static void fts5ApiInvoke(  Fts5Auxiliary *pAux,  Fts5Cursor *pCsr,  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  assert( pCsr->pAux==0 );  pCsr->pAux = pAux;  pAux->xFunc(&sFts5Api, (Fts5Context*)pCsr, context, argc, argv);  pCsr->pAux = 0; } static Fts5Cursor *fts5CursorFromCsrid(Fts5Global *pGlobal, i64 iCsrId){  Fts5Cursor *pCsr;  for(pCsr=pGlobal->pCsr; pCsr; pCsr=pCsr->pNext){  if( pCsr->iCsrId==iCsrId ) break;  }  return pCsr; } static void fts5ApiCallback(  sqlite3_context *context,  int argc,  sqlite3_value **argv ){  Fts5Auxiliary *pAux;  Fts5Cursor *pCsr;  i64 iCsrId;  assert( argc>=1 );  pAux = (Fts5Auxiliary*)sqlite3_user_data(context);  iCsrId = sqlite3_value_int64(argv[0]);  pCsr = fts5CursorFromCsrid(pAux->pGlobal, iCsrId);  if( pCsr==0 || pCsr->ePlan==0 ){  char *zErr = sqlite3_mprintf("no such cursor: %lld", iCsrId);  sqlite3_result_error(context, zErr, -1);  sqlite3_free(zErr);  }else{  fts5ApiInvoke(pAux, pCsr, context, argc-1, &argv[1]);  } } static Fts5Table *sqlite3Fts5TableFromCsrid(  Fts5Global *pGlobal,  i64 iCsrId ){  Fts5Cursor *pCsr;  pCsr = fts5CursorFromCsrid(pGlobal, iCsrId);  if( pCsr ){  return (Fts5Table*)pCsr->base.pVtab;  }  return 0; } static int fts5PoslistBlob(sqlite3_context *pCtx, Fts5Cursor *pCsr){  int i;  int rc = SQLITE_OK;  int nPhrase = sqlite3Fts5ExprPhraseCount(pCsr->pExpr);  Fts5Buffer val;  memset(&val, 0, sizeof(Fts5Buffer));  switch( ((Fts5Table*)(pCsr->base.pVtab))->pConfig->eDetail ){  case FTS5_DETAIL_FULL:  for(i=0; i<(nPhrase-1); i++){  const u8 *dummy;  int nByte = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &dummy);  sqlite3Fts5BufferAppendVarint(&rc, &val, nByte);  }  for(i=0; i<nPhrase; i++){  const u8 *pPoslist;  int nPoslist;  nPoslist = sqlite3Fts5ExprPoslist(pCsr->pExpr, i, &pPoslist);  sqlite3Fts5BufferAppendBlob(&rc, &val, nPoslist, pPoslist);  }  break;  case FTS5_DETAIL_COLUMNS:  for(i=0; rc==SQLITE_OK && i<(nPhrase-1); i++){  const u8 *dummy;  int nByte;  rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, i, &dummy, &nByte);  sqlite3Fts5BufferAppendVarint(&rc, &val, nByte);  }  for(i=0; rc==SQLITE_OK && i<nPhrase; i++){  const u8 *pPoslist;  int nPoslist;  rc = sqlite3Fts5ExprPhraseCollist(pCsr->pExpr, i, &pPoslist, &nPoslist);  sqlite3Fts5BufferAppendBlob(&rc, &val, nPoslist, pPoslist);  }  break;  default:  break;  }  sqlite3_result_blob(pCtx, val.p, val.n, sqlite3_free);  return rc; } static int fts5ColumnMethod(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *pCtx,  int iCol ){  Fts5FullTable *pTab = (Fts5FullTable*)(pCursor->pVtab);  Fts5Config *pConfig = pTab->p.pConfig;  Fts5Cursor *pCsr = (Fts5Cursor*)pCursor;  int rc = SQLITE_OK;  assert( CsrFlagTest(pCsr, FTS5CSR_EOF)==0 );  if( pCsr->ePlan==FTS5_PLAN_SPECIAL ){  if( iCol==pConfig->nCol ){  sqlite3_result_int64(pCtx, pCsr->iSpecial);  }  }else  if( iCol==pConfig->nCol ){  sqlite3_result_int64(pCtx, pCsr->iCsrId);  }else if( iCol==pConfig->nCol+1 ){  if( pCsr->ePlan==FTS5_PLAN_SOURCE ){  fts5PoslistBlob(pCtx, pCsr);  }else if(  pCsr->ePlan==FTS5_PLAN_MATCH   || pCsr->ePlan==FTS5_PLAN_SORTED_MATCH  ){  if( pCsr->pRank || SQLITE_OK==(rc = fts5FindRankFunction(pCsr)) ){  fts5ApiInvoke(pCsr->pRank, pCsr, pCtx, pCsr->nRankArg, pCsr->apRankArg);  }  }  }else if( !fts5IsContentless(pTab) ){  pConfig->pzErrmsg = &pTab->p.base.zErrMsg;  rc = fts5SeekCursor(pCsr, 1);  if( rc==SQLITE_OK ){  sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));  }  pConfig->pzErrmsg = 0;  }  return rc; } static int fts5FindFunctionMethod(  sqlite3_vtab *pVtab,  int nUnused,  const char *zName,  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),  void **ppArg ){  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;  Fts5Auxiliary *pAux;  UNUSED_PARAM(nUnused);  pAux = fts5FindAuxiliary(pTab, zName);  if( pAux ){  *pxFunc = fts5ApiCallback;  *ppArg = (void*)pAux;  return 1;  }  return 0; } static int fts5RenameMethod(  sqlite3_vtab *pVtab,  const char *zName ){  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;  return sqlite3Fts5StorageRename(pTab->pStorage, zName); } static int sqlite3Fts5FlushToDisk(Fts5Table *pTab){  fts5TripCursors((Fts5FullTable*)pTab);  return sqlite3Fts5StorageSync(((Fts5FullTable*)pTab)->pStorage); } static int fts5SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){  UNUSED_PARAM(iSavepoint);  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_SAVEPOINT, iSavepoint);  return sqlite3Fts5FlushToDisk((Fts5Table*)pVtab); } static int fts5ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){  UNUSED_PARAM(iSavepoint);  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_RELEASE, iSavepoint);  return sqlite3Fts5FlushToDisk((Fts5Table*)pVtab); } static int fts5RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;  UNUSED_PARAM(iSavepoint);  fts5CheckTransactionState(pTab, FTS5_ROLLBACKTO, iSavepoint);  fts5TripCursors(pTab);  return sqlite3Fts5StorageRollback(pTab->pStorage); } static int fts5CreateAux(  fts5_api *pApi,  const char *zName,  void *pUserData,  fts5_extension_function xFunc,  void(*xDestroy)(void*) ){  Fts5Global *pGlobal = (Fts5Global*)pApi;  int rc = sqlite3_overload_function(pGlobal->db, zName, -1);  if( rc==SQLITE_OK ){  Fts5Auxiliary *pAux;  sqlite3_int64 nName;  sqlite3_int64 nByte;  nName = strlen(zName) + 1;  nByte = sizeof(Fts5Auxiliary) + nName;  pAux = (Fts5Auxiliary*)sqlite3_malloc64(nByte);  if( pAux ){  memset(pAux, 0, (size_t)nByte);  pAux->zFunc = (char*)&pAux[1];  memcpy(pAux->zFunc, zName, nName);  pAux->pGlobal = pGlobal;  pAux->pUserData = pUserData;  pAux->xFunc = xFunc;  pAux->xDestroy = xDestroy;  pAux->pNext = pGlobal->pAux;  pGlobal->pAux = pAux;  }else{  rc = SQLITE_NOMEM;  }  }  return rc; } static int fts5CreateTokenizer(  fts5_api *pApi,  const char *zName,  void *pUserData,  fts5_tokenizer *pTokenizer,  void(*xDestroy)(void*) ){  Fts5Global *pGlobal = (Fts5Global*)pApi;  Fts5TokenizerModule *pNew;  sqlite3_int64 nName;  sqlite3_int64 nByte;  int rc = SQLITE_OK;  nName = strlen(zName) + 1;  nByte = sizeof(Fts5TokenizerModule) + nName;  pNew = (Fts5TokenizerModule*)sqlite3_malloc64(nByte);  if( pNew ){  memset(pNew, 0, (size_t)nByte);  pNew->zName = (char*)&pNew[1];  memcpy(pNew->zName, zName, nName);  pNew->pUserData = pUserData;  pNew->x = *pTokenizer;  pNew->xDestroy = xDestroy;  pNew->pNext = pGlobal->pTok;  pGlobal->pTok = pNew;  if( pNew->pNext==0 ){  pGlobal->pDfltTok = pNew;  }  }else{  rc = SQLITE_NOMEM;  }  return rc; } static Fts5TokenizerModule *fts5LocateTokenizer(  Fts5Global *pGlobal,  const char *zName ){  Fts5TokenizerModule *pMod = 0;  if( zName==0 ){  pMod = pGlobal->pDfltTok;  }else{  for(pMod=pGlobal->pTok; pMod; pMod=pMod->pNext){  if( sqlite3_stricmp(zName, pMod->zName)==0 ) break;  }  }  return pMod; } static int fts5FindTokenizer(  fts5_api *pApi,  const char *zName,  void **ppUserData,  fts5_tokenizer *pTokenizer ){  int rc = SQLITE_OK;  Fts5TokenizerModule *pMod;  pMod = fts5LocateTokenizer((Fts5Global*)pApi, zName);  if( pMod ){  *pTokenizer = pMod->x;  *ppUserData = pMod->pUserData;  }else{  memset(pTokenizer, 0, sizeof(fts5_tokenizer));  rc = SQLITE_ERROR;  }  return rc; } static int sqlite3Fts5GetTokenizer(  Fts5Global *pGlobal,  const char **azArg,  int nArg,  Fts5Config *pConfig,  char **pzErr ){  Fts5TokenizerModule *pMod;  int rc = SQLITE_OK;  pMod = fts5LocateTokenizer(pGlobal, nArg==0 ? 0 : azArg[0]);  if( pMod==0 ){  assert( nArg>0 );  rc = SQLITE_ERROR;  *pzErr = sqlite3_mprintf("no such tokenizer: %s", azArg[0]);  }else{  rc = pMod->x.xCreate(  pMod->pUserData, (azArg?&azArg[1]:0), (nArg?nArg-1:0), &pConfig->pTok  );  pConfig->pTokApi = &pMod->x;  if( rc!=SQLITE_OK ){  if( pzErr ) *pzErr = sqlite3_mprintf("error in tokenizer constructor");  }else{  pConfig->ePattern = sqlite3Fts5TokenizerPattern(  pMod->x.xCreate, pConfig->pTok  );  }  }  if( rc!=SQLITE_OK ){  pConfig->pTokApi = 0;  pConfig->pTok = 0;  }  return rc; } static void fts5ModuleDestroy(void *pCtx){  Fts5TokenizerModule *pTok, *pNextTok;  Fts5Auxiliary *pAux, *pNextAux;  Fts5Global *pGlobal = (Fts5Global*)pCtx;  for(pAux=pGlobal->pAux; pAux; pAux=pNextAux){  pNextAux = pAux->pNext;  if( pAux->xDestroy ) pAux->xDestroy(pAux->pUserData);  sqlite3_free(pAux);  }  for(pTok=pGlobal->pTok; pTok; pTok=pNextTok){  pNextTok = pTok->pNext;  if( pTok->xDestroy ) pTok->xDestroy(pTok->pUserData);  sqlite3_free(pTok);  }  sqlite3_free(pGlobal); } static void fts5Fts5Func(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apArg ){  Fts5Global *pGlobal = (Fts5Global*)sqlite3_user_data(pCtx);  fts5_api **ppApi;  UNUSED_PARAM(nArg);  assert( nArg==1 );  ppApi = (fts5_api**)sqlite3_value_pointer(apArg[0], "fts5_api_ptr");  if( ppApi ) *ppApi = &pGlobal->api; } static void fts5SourceIdFunc(  sqlite3_context *pCtx,  int nArg,  sqlite3_value **apUnused ){  assert( nArg==0 );  UNUSED_PARAM2(nArg, apUnused);  sqlite3_result_text(pCtx, "fts5: 2022-01-06 13:25:41 872ba256cbf61d9290b571c0e6d82a20c224ca3ad82971edc46b29818d5d17a0", -1, SQLITE_TRANSIENT); } static int fts5ShadowName(const char *zName){  static const char *azName[] = {  "config", "content", "data", "docsize", "idx"  };  unsigned int i;  for(i=0; i<sizeof(azName)/sizeof(azName[0]); i++){  if( sqlite3_stricmp(zName, azName[i])==0 ) return 1;  }  return 0; } static int fts5Init(sqlite3 *db){  static const sqlite3_module fts5Mod = {  3,  fts5CreateMethod,  fts5ConnectMethod,  fts5BestIndexMethod,  fts5DisconnectMethod,  fts5DestroyMethod,  fts5OpenMethod,  fts5CloseMethod,  fts5FilterMethod,  fts5NextMethod,  fts5EofMethod,  fts5ColumnMethod,  fts5RowidMethod,  fts5UpdateMethod,  fts5BeginMethod,  fts5SyncMethod,  fts5CommitMethod,  fts5RollbackMethod,  fts5FindFunctionMethod,  fts5RenameMethod,  fts5SavepointMethod,  fts5ReleaseMethod,  fts5RollbackToMethod,  fts5ShadowName  };  int rc;  Fts5Global *pGlobal = 0;  pGlobal = (Fts5Global*)sqlite3_malloc(sizeof(Fts5Global));  if( pGlobal==0 ){  rc = SQLITE_NOMEM;  }else{  void *p = (void*)pGlobal;  memset(pGlobal, 0, sizeof(Fts5Global));  pGlobal->db = db;  pGlobal->api.iVersion = 2;  pGlobal->api.xCreateFunction = fts5CreateAux;  pGlobal->api.xCreateTokenizer = fts5CreateTokenizer;  pGlobal->api.xFindTokenizer = fts5FindTokenizer;  rc = sqlite3_create_module_v2(db, "fts5", &fts5Mod, p, fts5ModuleDestroy);  if( rc==SQLITE_OK ) rc = sqlite3Fts5IndexInit(db);  if( rc==SQLITE_OK ) rc = sqlite3Fts5ExprInit(pGlobal, db);  if( rc==SQLITE_OK ) rc = sqlite3Fts5AuxInit(&pGlobal->api);  if( rc==SQLITE_OK ) rc = sqlite3Fts5TokenizerInit(&pGlobal->api);  if( rc==SQLITE_OK ) rc = sqlite3Fts5VocabInit(pGlobal, db);  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(  db, "fts5", 1, SQLITE_UTF8, p, fts5Fts5Func, 0, 0  );  }  if( rc==SQLITE_OK ){  rc = sqlite3_create_function(  db, "fts5_source_id", 0, SQLITE_UTF8, p, fts5SourceIdFunc, 0, 0  );  }  }
#ifdef SQLITE_FTS5_ENABLE_TEST_MI
 if( rc==SQLITE_OK ){  extern int sqlite3Fts5TestRegisterMatchinfo(sqlite3*);  rc = sqlite3Fts5TestRegisterMatchinfo(db);  }
#endif
 return rc; }
#ifndef SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_fts_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  SQLITE_EXTENSION_INIT2(pApi);  (void)pzErrMsg;  return fts5Init(db); }
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_fts5_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  SQLITE_EXTENSION_INIT2(pApi);  (void)pzErrMsg;  return fts5Init(db); }
#else
SQLITE_PRIVATE int sqlite3Fts5Init(sqlite3 *db){  return fts5Init(db); }
#endif
struct Fts5Storage {  Fts5Config *pConfig;  Fts5Index *pIndex;  int bTotalsValid;  i64 nTotalRow;  i64 *aTotalSize;  sqlite3_stmt *aStmt[11]; };
#if FTS5_STMT_SCAN_ASC!=0
# error "FTS5_STMT_SCAN_ASC mismatch"
#endif
#if FTS5_STMT_SCAN_DESC!=1
# error "FTS5_STMT_SCAN_DESC mismatch"
#endif
#if FTS5_STMT_LOOKUP!=2
# error "FTS5_STMT_LOOKUP mismatch"
#endif
#define FTS5_STMT_INSERT_CONTENT 3
#define FTS5_STMT_REPLACE_CONTENT 4
#define FTS5_STMT_DELETE_CONTENT 5
#define FTS5_STMT_REPLACE_DOCSIZE 6
#define FTS5_STMT_DELETE_DOCSIZE 7
#define FTS5_STMT_LOOKUP_DOCSIZE 8
#define FTS5_STMT_REPLACE_CONFIG 9
#define FTS5_STMT_SCAN 10
static int fts5StorageGetStmt(  Fts5Storage *p,  int eStmt,  sqlite3_stmt **ppStmt,  char **pzErrMsg ){  int rc = SQLITE_OK;  assert( p->pConfig->bColumnsize || (  eStmt!=FTS5_STMT_REPLACE_DOCSIZE   && eStmt!=FTS5_STMT_DELETE_DOCSIZE   && eStmt!=FTS5_STMT_LOOKUP_DOCSIZE  ));  assert( eStmt>=0 && eStmt<ArraySize(p->aStmt) );  if( p->aStmt[eStmt]==0 ){  const char *azStmt[] = {  "SELECT %s FROM %s T WHERE T.%Q >= ? AND T.%Q <= ? ORDER BY T.%Q ASC",  "SELECT %s FROM %s T WHERE T.%Q <= ? AND T.%Q >= ? ORDER BY T.%Q DESC",  "SELECT %s FROM %s T WHERE T.%Q=?",  "INSERT INTO %Q.'%q_content' VALUES(%s)",  "REPLACE INTO %Q.'%q_content' VALUES(%s)",  "DELETE FROM %Q.'%q_content' WHERE id=?",  "REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",  "DELETE FROM %Q.'%q_docsize' WHERE id=?",  "SELECT sz FROM %Q.'%q_docsize' WHERE id=?",  "REPLACE INTO %Q.'%q_config' VALUES(?,?)",  "SELECT %s FROM %s AS T",  };  Fts5Config *pC = p->pConfig;  char *zSql = 0;  switch( eStmt ){  case FTS5_STMT_SCAN:  zSql = sqlite3_mprintf(azStmt[eStmt],  pC->zContentExprlist, pC->zContent  );  break;  case FTS5_STMT_SCAN_ASC:  case FTS5_STMT_SCAN_DESC:  zSql = sqlite3_mprintf(azStmt[eStmt], pC->zContentExprlist,  pC->zContent, pC->zContentRowid, pC->zContentRowid,  pC->zContentRowid  );  break;  case FTS5_STMT_LOOKUP:  zSql = sqlite3_mprintf(azStmt[eStmt],  pC->zContentExprlist, pC->zContent, pC->zContentRowid  );  break;  case FTS5_STMT_INSERT_CONTENT:  case FTS5_STMT_REPLACE_CONTENT: {  int nCol = pC->nCol + 1;  char *zBind;  int i;  zBind = sqlite3_malloc64(1 + nCol*2);  if( zBind ){  for(i=0; i<nCol; i++){  zBind[i*2] = '?';  zBind[i*2 + 1] = ',';  }  zBind[i*2-1] = '\0';  zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName, zBind);  sqlite3_free(zBind);  }  break;  }  default:  zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName);  break;  }  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  int f = SQLITE_PREPARE_PERSISTENT;  if( eStmt>FTS5_STMT_LOOKUP ) f |= SQLITE_PREPARE_NO_VTAB;  p->pConfig->bLock++;  rc = sqlite3_prepare_v3(pC->db, zSql, -1, f, &p->aStmt[eStmt], 0);  p->pConfig->bLock--;  sqlite3_free(zSql);  if( rc!=SQLITE_OK && pzErrMsg ){  *pzErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pC->db));  }  }  }  *ppStmt = p->aStmt[eStmt];  sqlite3_reset(*ppStmt);  return rc; } static int fts5ExecPrintf(  sqlite3 *db,  char **pzErr,  const char *zFormat,  ... ){  int rc;  va_list ap;  char *zSql;  va_start(ap, zFormat);  zSql = sqlite3_vmprintf(zFormat, ap);  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  rc = sqlite3_exec(db, zSql, 0, 0, pzErr);  sqlite3_free(zSql);  }  va_end(ap);  return rc; } static int sqlite3Fts5DropAll(Fts5Config *pConfig){  int rc = fts5ExecPrintf(pConfig->db, 0,  "DROP TABLE IF EXISTS %Q.'%q_data';"  "DROP TABLE IF EXISTS %Q.'%q_idx';"  "DROP TABLE IF EXISTS %Q.'%q_config';",  pConfig->zDb, pConfig->zName,  pConfig->zDb, pConfig->zName,  pConfig->zDb, pConfig->zName  );  if( rc==SQLITE_OK && pConfig->bColumnsize ){  rc = fts5ExecPrintf(pConfig->db, 0,  "DROP TABLE IF EXISTS %Q.'%q_docsize';",  pConfig->zDb, pConfig->zName  );  }  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){  rc = fts5ExecPrintf(pConfig->db, 0,  "DROP TABLE IF EXISTS %Q.'%q_content';",  pConfig->zDb, pConfig->zName  );  }  return rc; } static void fts5StorageRenameOne(  Fts5Config *pConfig,  int *pRc,  const char *zTail,  const char *zName ){  if( *pRc==SQLITE_OK ){  *pRc = fts5ExecPrintf(pConfig->db, 0,  "ALTER TABLE %Q.'%q_%s' RENAME TO '%q_%s';",  pConfig->zDb, pConfig->zName, zTail, zName, zTail  );  } } static int sqlite3Fts5StorageRename(Fts5Storage *pStorage, const char *zName){  Fts5Config *pConfig = pStorage->pConfig;  int rc = sqlite3Fts5StorageSync(pStorage);  fts5StorageRenameOne(pConfig, &rc, "data", zName);  fts5StorageRenameOne(pConfig, &rc, "idx", zName);  fts5StorageRenameOne(pConfig, &rc, "config", zName);  if( pConfig->bColumnsize ){  fts5StorageRenameOne(pConfig, &rc, "docsize", zName);  }  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){  fts5StorageRenameOne(pConfig, &rc, "content", zName);  }  return rc; } static int sqlite3Fts5CreateTable(  Fts5Config *pConfig,  const char *zPost,  const char *zDefn,  int bWithout,  char **pzErr ){  int rc;  char *zErr = 0;  rc = fts5ExecPrintf(pConfig->db, &zErr, "CREATE TABLE %Q.'%q_%q'(%s)%s",  pConfig->zDb, pConfig->zName, zPost, zDefn,
#ifndef SQLITE_FTS5_NO_WITHOUT_ROWID
 bWithout?" WITHOUT ROWID":
#endif
 ""  );  if( zErr ){  *pzErr = sqlite3_mprintf(  "fts5: error creating shadow table %q_%s: %s",  pConfig->zName, zPost, zErr  );  sqlite3_free(zErr);  }  return rc; } static int sqlite3Fts5StorageOpen(  Fts5Config *pConfig,  Fts5Index *pIndex,  int bCreate,  Fts5Storage **pp,  char **pzErr ){  int rc = SQLITE_OK;  Fts5Storage *p;  sqlite3_int64 nByte;  nByte = sizeof(Fts5Storage)  + pConfig->nCol * sizeof(i64);  *pp = p = (Fts5Storage*)sqlite3_malloc64(nByte);  if( !p ) return SQLITE_NOMEM;  memset(p, 0, (size_t)nByte);  p->aTotalSize = (i64*)&p[1];  p->pConfig = pConfig;  p->pIndex = pIndex;  if( bCreate ){  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){  int nDefn = 32 + pConfig->nCol*10;  char *zDefn = sqlite3_malloc64(32 + (sqlite3_int64)pConfig->nCol * 10);  if( zDefn==0 ){  rc = SQLITE_NOMEM;  }else{  int i;  int iOff;  sqlite3_snprintf(nDefn, zDefn, "id INTEGER PRIMARY KEY");  iOff = (int)strlen(zDefn);  for(i=0; i<pConfig->nCol; i++){  sqlite3_snprintf(nDefn-iOff, &zDefn[iOff], ", c%d", i);  iOff += (int)strlen(&zDefn[iOff]);  }  rc = sqlite3Fts5CreateTable(pConfig, "content", zDefn, 0, pzErr);  }  sqlite3_free(zDefn);  }  if( rc==SQLITE_OK && pConfig->bColumnsize ){  rc = sqlite3Fts5CreateTable(  pConfig, "docsize", "id INTEGER PRIMARY KEY, sz BLOB", 0, pzErr  );  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5CreateTable(  pConfig, "config", "k PRIMARY KEY, v", 1, pzErr  );  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageConfigValue(p, "version", 0, FTS5_CURRENT_VERSION);  }  }  if( rc ){  sqlite3Fts5StorageClose(p);  *pp = 0;  }  return rc; } static int sqlite3Fts5StorageClose(Fts5Storage *p){  int rc = SQLITE_OK;  if( p ){  int i;  for(i=0; i<ArraySize(p->aStmt); i++){  sqlite3_finalize(p->aStmt[i]);  }  sqlite3_free(p);  }  return rc; } typedef struct Fts5InsertCtx Fts5InsertCtx; struct Fts5InsertCtx {  Fts5Storage *pStorage;  int iCol;  int szCol; }; static int fts5StorageInsertCallback(  void *pContext,  int tflags,  const char *pToken,  int nToken,  int iUnused1,  int iUnused2 ){  Fts5InsertCtx *pCtx = (Fts5InsertCtx*)pContext;  Fts5Index *pIdx = pCtx->pStorage->pIndex;  UNUSED_PARAM2(iUnused1, iUnused2);  if( nToken>FTS5_MAX_TOKEN_SIZE ) nToken = FTS5_MAX_TOKEN_SIZE;  if( (tflags & FTS5_TOKEN_COLOCATED)==0 || pCtx->szCol==0 ){  pCtx->szCol++;  }  return sqlite3Fts5IndexWrite(pIdx, pCtx->iCol, pCtx->szCol-1, pToken, nToken); } static int fts5StorageDeleteFromIndex(  Fts5Storage *p,  i64 iDel,  sqlite3_value **apVal ){  Fts5Config *pConfig = p->pConfig;  sqlite3_stmt *pSeek = 0;  int rc;  int rc2;  int iCol;  Fts5InsertCtx ctx;  if( apVal==0 ){  rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP, &pSeek, 0);  if( rc!=SQLITE_OK ) return rc;  sqlite3_bind_int64(pSeek, 1, iDel);  if( sqlite3_step(pSeek)!=SQLITE_ROW ){  return sqlite3_reset(pSeek);  }  }  ctx.pStorage = p;  ctx.iCol = -1;  rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 1, iDel);  for(iCol=1; rc==SQLITE_OK && iCol<=pConfig->nCol; iCol++){  if( pConfig->abUnindexed[iCol-1]==0 ){  const char *zText;  int nText;  assert( pSeek==0 || apVal==0 );  assert( pSeek!=0 || apVal!=0 );  if( pSeek ){  zText = (const char*)sqlite3_column_text(pSeek, iCol);  nText = sqlite3_column_bytes(pSeek, iCol);  }else if( ALWAYS(apVal) ){  zText = (const char*)sqlite3_value_text(apVal[iCol-1]);  nText = sqlite3_value_bytes(apVal[iCol-1]);  }else{  continue;  }  ctx.szCol = 0;  rc = sqlite3Fts5Tokenize(pConfig, FTS5_TOKENIZE_DOCUMENT,  zText, nText, (void*)&ctx, fts5StorageInsertCallback  );  p->aTotalSize[iCol-1] -= (i64)ctx.szCol;  if( p->aTotalSize[iCol-1]<0 ){  rc = FTS5_CORRUPT;  }  }  }  if( rc==SQLITE_OK && p->nTotalRow<1 ){  rc = FTS5_CORRUPT;  }else{  p->nTotalRow--;  }  rc2 = sqlite3_reset(pSeek);  if( rc==SQLITE_OK ) rc = rc2;  return rc; } static int fts5StorageInsertDocsize(  Fts5Storage *p,  i64 iRowid,  Fts5Buffer *pBuf ){  int rc = SQLITE_OK;  if( p->pConfig->bColumnsize ){  sqlite3_stmt *pReplace = 0;  rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pReplace, 1, iRowid);  sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);  sqlite3_step(pReplace);  rc = sqlite3_reset(pReplace);  sqlite3_bind_null(pReplace, 2);  }  }  return rc; } static int fts5StorageLoadTotals(Fts5Storage *p, int bCache){  int rc = SQLITE_OK;  if( p->bTotalsValid==0 ){  rc = sqlite3Fts5IndexGetAverages(p->pIndex, &p->nTotalRow, p->aTotalSize);  p->bTotalsValid = bCache;  }  return rc; } static int fts5StorageSaveTotals(Fts5Storage *p){  int nCol = p->pConfig->nCol;  int i;  Fts5Buffer buf;  int rc = SQLITE_OK;  memset(&buf, 0, sizeof(buf));  sqlite3Fts5BufferAppendVarint(&rc, &buf, p->nTotalRow);  for(i=0; i<nCol; i++){  sqlite3Fts5BufferAppendVarint(&rc, &buf, p->aTotalSize[i]);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexSetAverages(p->pIndex, buf.p, buf.n);  }  sqlite3_free(buf.p);  return rc; } static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64 iDel, sqlite3_value **apVal){  Fts5Config *pConfig = p->pConfig;  int rc;  sqlite3_stmt *pDel = 0;  assert( pConfig->eContent!=FTS5_CONTENT_NORMAL || apVal==0 );  rc = fts5StorageLoadTotals(p, 1);  if( rc==SQLITE_OK ){  rc = fts5StorageDeleteFromIndex(p, iDel, apVal);  }  if( rc==SQLITE_OK && pConfig->bColumnsize ){  rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_DOCSIZE, &pDel, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pDel, 1, iDel);  sqlite3_step(pDel);  rc = sqlite3_reset(pDel);  }  }  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){  if( rc==SQLITE_OK ){  rc = fts5StorageGetStmt(p, FTS5_STMT_DELETE_CONTENT, &pDel, 0);  }  if( rc==SQLITE_OK ){  sqlite3_bind_int64(pDel, 1, iDel);  sqlite3_step(pDel);  rc = sqlite3_reset(pDel);  }  }  return rc; } static int sqlite3Fts5StorageDeleteAll(Fts5Storage *p){  Fts5Config *pConfig = p->pConfig;  int rc;  p->bTotalsValid = 0;  rc = fts5ExecPrintf(pConfig->db, 0,  "DELETE FROM %Q.'%q_data';"  "DELETE FROM %Q.'%q_idx';",  pConfig->zDb, pConfig->zName,  pConfig->zDb, pConfig->zName  );  if( rc==SQLITE_OK && pConfig->bColumnsize ){  rc = fts5ExecPrintf(pConfig->db, 0,  "DELETE FROM %Q.'%q_docsize';",  pConfig->zDb, pConfig->zName  );  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexReinit(p->pIndex);  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5StorageConfigValue(p, "version", 0, FTS5_CURRENT_VERSION);  }  return rc; } static int sqlite3Fts5StorageRebuild(Fts5Storage *p){  Fts5Buffer buf = {0,0,0};  Fts5Config *pConfig = p->pConfig;  sqlite3_stmt *pScan = 0;  Fts5InsertCtx ctx;  int rc, rc2;  memset(&ctx, 0, sizeof(Fts5InsertCtx));  ctx.pStorage = p;  rc = sqlite3Fts5StorageDeleteAll(p);  if( rc==SQLITE_OK ){  rc = fts5StorageLoadTotals(p, 1);  }  if( rc==SQLITE_OK ){  rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);  }  while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pScan) ){  i64 iRowid = sqlite3_column_int64(pScan, 0);  sqlite3Fts5BufferZero(&buf);  rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 0, iRowid);  for(ctx.iCol=0; rc==SQLITE_OK && ctx.iCol<pConfig->nCol; ctx.iCol++){  ctx.szCol = 0;  if( pConfig->abUnindexed[ctx.iCol]==0 ){  const char *zText = (const char*)sqlite3_column_text(pScan, ctx.iCol+1);  int nText = sqlite3_column_bytes(pScan, ctx.iCol+1);  rc = sqlite3Fts5Tokenize(pConfig,  FTS5_TOKENIZE_DOCUMENT,  zText, nText,  (void*)&ctx,  fts5StorageInsertCallback  );  }  sqlite3Fts5BufferAppendVarint(&rc, &buf, ctx.szCol);  p->aTotalSize[ctx.iCol] += (i64)ctx.szCol;  }  p->nTotalRow++;  if( rc==SQLITE_OK ){  rc = fts5StorageInsertDocsize(p, iRowid, &buf);  }  }  sqlite3_free(buf.p);  rc2 = sqlite3_reset(pScan);  if( rc==SQLITE_OK ) rc = rc2;  if( rc==SQLITE_OK ){  rc = fts5StorageSaveTotals(p);  }  return rc; } static int sqlite3Fts5StorageOptimize(Fts5Storage *p){  return sqlite3Fts5IndexOptimize(p->pIndex); } static int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge){  return sqlite3Fts5IndexMerge(p->pIndex, nMerge); } static int sqlite3Fts5StorageReset(Fts5Storage *p){  return sqlite3Fts5IndexReset(p->pIndex); } static int fts5StorageNewRowid(Fts5Storage *p, i64 *piRowid){  int rc = SQLITE_MISMATCH;  if( p->pConfig->bColumnsize ){  sqlite3_stmt *pReplace = 0;  rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_DOCSIZE, &pReplace, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_null(pReplace, 1);  sqlite3_bind_null(pReplace, 2);  sqlite3_step(pReplace);  rc = sqlite3_reset(pReplace);  }  if( rc==SQLITE_OK ){  *piRowid = sqlite3_last_insert_rowid(p->pConfig->db);  }  }  return rc; } static int sqlite3Fts5StorageContentInsert(  Fts5Storage *p,  sqlite3_value **apVal,  i64 *piRowid ){  Fts5Config *pConfig = p->pConfig;  int rc = SQLITE_OK;  if( pConfig->eContent!=FTS5_CONTENT_NORMAL ){  if( sqlite3_value_type(apVal[1])==SQLITE_INTEGER ){  *piRowid = sqlite3_value_int64(apVal[1]);  }else{  rc = fts5StorageNewRowid(p, piRowid);  }  }else{  sqlite3_stmt *pInsert = 0;  int i;  rc = fts5StorageGetStmt(p, FTS5_STMT_INSERT_CONTENT, &pInsert, 0);  for(i=1; rc==SQLITE_OK && i<=pConfig->nCol+1; i++){  rc = sqlite3_bind_value(pInsert, i, apVal[i]);  }  if( rc==SQLITE_OK ){  sqlite3_step(pInsert);  rc = sqlite3_reset(pInsert);  }  *piRowid = sqlite3_last_insert_rowid(pConfig->db);  }  return rc; } static int sqlite3Fts5StorageIndexInsert(  Fts5Storage *p,  sqlite3_value **apVal,  i64 iRowid ){  Fts5Config *pConfig = p->pConfig;  int rc = SQLITE_OK;  Fts5InsertCtx ctx;  Fts5Buffer buf;  memset(&buf, 0, sizeof(Fts5Buffer));  ctx.pStorage = p;  rc = fts5StorageLoadTotals(p, 1);  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 0, iRowid);  }  for(ctx.iCol=0; rc==SQLITE_OK && ctx.iCol<pConfig->nCol; ctx.iCol++){  ctx.szCol = 0;  if( pConfig->abUnindexed[ctx.iCol]==0 ){  const char *zText = (const char*)sqlite3_value_text(apVal[ctx.iCol+2]);  int nText = sqlite3_value_bytes(apVal[ctx.iCol+2]);  rc = sqlite3Fts5Tokenize(pConfig,  FTS5_TOKENIZE_DOCUMENT,  zText, nText,  (void*)&ctx,  fts5StorageInsertCallback  );  }  sqlite3Fts5BufferAppendVarint(&rc, &buf, ctx.szCol);  p->aTotalSize[ctx.iCol] += (i64)ctx.szCol;  }  p->nTotalRow++;  if( rc==SQLITE_OK ){  rc = fts5StorageInsertDocsize(p, iRowid, &buf);  }  sqlite3_free(buf.p);  return rc; } static int fts5StorageCount(Fts5Storage *p, const char *zSuffix, i64 *pnRow){  Fts5Config *pConfig = p->pConfig;  char *zSql;  int rc;  zSql = sqlite3_mprintf("SELECT count(*) FROM %Q.'%q_%s'",  pConfig->zDb, pConfig->zName, zSuffix  );  if( zSql==0 ){  rc = SQLITE_NOMEM;  }else{  sqlite3_stmt *pCnt = 0;  rc = sqlite3_prepare_v2(pConfig->db, zSql, -1, &pCnt, 0);  if( rc==SQLITE_OK ){  if( SQLITE_ROW==sqlite3_step(pCnt) ){  *pnRow = sqlite3_column_int64(pCnt, 0);  }  rc = sqlite3_finalize(pCnt);  }  }  sqlite3_free(zSql);  return rc; } typedef struct Fts5IntegrityCtx Fts5IntegrityCtx; struct Fts5IntegrityCtx {  i64 iRowid;  int iCol;  int szCol;  u64 cksum;  Fts5Termset *pTermset;  Fts5Config *pConfig; }; static int fts5StorageIntegrityCallback(  void *pContext,  int tflags,  const char *pToken,  int nToken,  int iUnused1,  int iUnused2 ){  Fts5IntegrityCtx *pCtx = (Fts5IntegrityCtx*)pContext;  Fts5Termset *pTermset = pCtx->pTermset;  int bPresent;  int ii;  int rc = SQLITE_OK;  int iPos;  int iCol;  UNUSED_PARAM2(iUnused1, iUnused2);  if( nToken>FTS5_MAX_TOKEN_SIZE ) nToken = FTS5_MAX_TOKEN_SIZE;  if( (tflags & FTS5_TOKEN_COLOCATED)==0 || pCtx->szCol==0 ){  pCtx->szCol++;  }  switch( pCtx->pConfig->eDetail ){  case FTS5_DETAIL_FULL:  iPos = pCtx->szCol-1;  iCol = pCtx->iCol;  break;  case FTS5_DETAIL_COLUMNS:  iPos = pCtx->iCol;  iCol = 0;  break;  default:  assert( pCtx->pConfig->eDetail==FTS5_DETAIL_NONE );  iPos = 0;  iCol = 0;  break;  }  rc = sqlite3Fts5TermsetAdd(pTermset, 0, pToken, nToken, &bPresent);  if( rc==SQLITE_OK && bPresent==0 ){  pCtx->cksum ^= sqlite3Fts5IndexEntryCksum(  pCtx->iRowid, iCol, iPos, 0, pToken, nToken  );  }  for(ii=0; rc==SQLITE_OK && ii<pCtx->pConfig->nPrefix; ii++){  const int nChar = pCtx->pConfig->aPrefix[ii];  int nByte = sqlite3Fts5IndexCharlenToBytelen(pToken, nToken, nChar);  if( nByte ){  rc = sqlite3Fts5TermsetAdd(pTermset, ii+1, pToken, nByte, &bPresent);  if( bPresent==0 ){  pCtx->cksum ^= sqlite3Fts5IndexEntryCksum(  pCtx->iRowid, iCol, iPos, ii+1, pToken, nByte  );  }  }  }  return rc; } static int sqlite3Fts5StorageIntegrity(Fts5Storage *p, int iArg){  Fts5Config *pConfig = p->pConfig;  int rc = SQLITE_OK;  int *aColSize;  i64 *aTotalSize;  Fts5IntegrityCtx ctx;  sqlite3_stmt *pScan;  int bUseCksum;  memset(&ctx, 0, sizeof(Fts5IntegrityCtx));  ctx.pConfig = p->pConfig;  aTotalSize = (i64*)sqlite3_malloc64(pConfig->nCol*(sizeof(int)+sizeof(i64)));  if( !aTotalSize ) return SQLITE_NOMEM;  aColSize = (int*)&aTotalSize[pConfig->nCol];  memset(aTotalSize, 0, sizeof(i64) * pConfig->nCol);  bUseCksum = (pConfig->eContent==FTS5_CONTENT_NORMAL   || (pConfig->eContent==FTS5_CONTENT_EXTERNAL && iArg)  );  if( bUseCksum ){  rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);  if( rc==SQLITE_OK ){  int rc2;  while( SQLITE_ROW==sqlite3_step(pScan) ){  int i;  ctx.iRowid = sqlite3_column_int64(pScan, 0);  ctx.szCol = 0;  if( pConfig->bColumnsize ){  rc = sqlite3Fts5StorageDocsize(p, ctx.iRowid, aColSize);  }  if( rc==SQLITE_OK && pConfig->eDetail==FTS5_DETAIL_NONE ){  rc = sqlite3Fts5TermsetNew(&ctx.pTermset);  }  for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){  if( pConfig->abUnindexed[i] ) continue;  ctx.iCol = i;  ctx.szCol = 0;  if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){  rc = sqlite3Fts5TermsetNew(&ctx.pTermset);  }  if( rc==SQLITE_OK ){  const char *zText = (const char*)sqlite3_column_text(pScan, i+1);  int nText = sqlite3_column_bytes(pScan, i+1);  rc = sqlite3Fts5Tokenize(pConfig,  FTS5_TOKENIZE_DOCUMENT,  zText, nText,  (void*)&ctx,  fts5StorageIntegrityCallback  );  }  if( rc==SQLITE_OK && pConfig->bColumnsize && ctx.szCol!=aColSize[i] ){  rc = FTS5_CORRUPT;  }  aTotalSize[i] += ctx.szCol;  if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){  sqlite3Fts5TermsetFree(ctx.pTermset);  ctx.pTermset = 0;  }  }  sqlite3Fts5TermsetFree(ctx.pTermset);  ctx.pTermset = 0;  if( rc!=SQLITE_OK ) break;  }  rc2 = sqlite3_reset(pScan);  if( rc==SQLITE_OK ) rc = rc2;  }  if( rc==SQLITE_OK ){  int i;  rc = fts5StorageLoadTotals(p, 0);  for(i=0; rc==SQLITE_OK && i<pConfig->nCol; i++){  if( p->aTotalSize[i]!=aTotalSize[i] ) rc = FTS5_CORRUPT;  }  }  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){  i64 nRow = 0;  rc = fts5StorageCount(p, "content", &nRow);  if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;  }  if( rc==SQLITE_OK && pConfig->bColumnsize ){  i64 nRow = 0;  rc = fts5StorageCount(p, "docsize", &nRow);  if( rc==SQLITE_OK && nRow!=p->nTotalRow ) rc = FTS5_CORRUPT;  }  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexIntegrityCheck(p->pIndex, ctx.cksum, bUseCksum);  }  sqlite3_free(aTotalSize);  return rc; } static int sqlite3Fts5StorageStmt(  Fts5Storage *p,  int eStmt,  sqlite3_stmt **pp,  char **pzErrMsg ){  int rc;  assert( eStmt==FTS5_STMT_SCAN_ASC   || eStmt==FTS5_STMT_SCAN_DESC   || eStmt==FTS5_STMT_LOOKUP  );  rc = fts5StorageGetStmt(p, eStmt, pp, pzErrMsg);  if( rc==SQLITE_OK ){  assert( p->aStmt[eStmt]==*pp );  p->aStmt[eStmt] = 0;  }  return rc; } static void sqlite3Fts5StorageStmtRelease(  Fts5Storage *p,  int eStmt,  sqlite3_stmt *pStmt ){  assert( eStmt==FTS5_STMT_SCAN_ASC   || eStmt==FTS5_STMT_SCAN_DESC   || eStmt==FTS5_STMT_LOOKUP  );  if( p->aStmt[eStmt]==0 ){  sqlite3_reset(pStmt);  p->aStmt[eStmt] = pStmt;  }else{  sqlite3_finalize(pStmt);  } } static int fts5StorageDecodeSizeArray(  int *aCol, int nCol,  const u8 *aBlob, int nBlob ){  int i;  int iOff = 0;  for(i=0; i<nCol; i++){  if( iOff>=nBlob ) return 1;  iOff += fts5GetVarint32(&aBlob[iOff], aCol[i]);  }  return (iOff!=nBlob); } static int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol){  int nCol = p->pConfig->nCol;  sqlite3_stmt *pLookup = 0;  int rc;  assert( p->pConfig->bColumnsize );  rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP_DOCSIZE, &pLookup, 0);  if( pLookup ){  int bCorrupt = 1;  assert( rc==SQLITE_OK );  sqlite3_bind_int64(pLookup, 1, iRowid);  if( SQLITE_ROW==sqlite3_step(pLookup) ){  const u8 *aBlob = sqlite3_column_blob(pLookup, 0);  int nBlob = sqlite3_column_bytes(pLookup, 0);  if( 0==fts5StorageDecodeSizeArray(aCol, nCol, aBlob, nBlob) ){  bCorrupt = 0;  }  }  rc = sqlite3_reset(pLookup);  if( bCorrupt && rc==SQLITE_OK ){  rc = FTS5_CORRUPT;  }  }else{  assert( rc!=SQLITE_OK );  }  return rc; } static int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnToken){  int rc = fts5StorageLoadTotals(p, 0);  if( rc==SQLITE_OK ){  *pnToken = 0;  if( iCol<0 ){  int i;  for(i=0; i<p->pConfig->nCol; i++){  *pnToken += p->aTotalSize[i];  }  }else if( iCol<p->pConfig->nCol ){  *pnToken = p->aTotalSize[iCol];  }else{  rc = SQLITE_RANGE;  }  }  return rc; } static int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow){  int rc = fts5StorageLoadTotals(p, 0);  if( rc==SQLITE_OK ){  *pnRow = p->nTotalRow;  if( p->nTotalRow<=0 ) rc = FTS5_CORRUPT;  }  return rc; } static int sqlite3Fts5StorageSync(Fts5Storage *p){  int rc = SQLITE_OK;  i64 iLastRowid = sqlite3_last_insert_rowid(p->pConfig->db);  if( p->bTotalsValid ){  rc = fts5StorageSaveTotals(p);  p->bTotalsValid = 0;  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IndexSync(p->pIndex);  }  sqlite3_set_last_insert_rowid(p->pConfig->db, iLastRowid);  return rc; } static int sqlite3Fts5StorageRollback(Fts5Storage *p){  p->bTotalsValid = 0;  return sqlite3Fts5IndexRollback(p->pIndex); } static int sqlite3Fts5StorageConfigValue(  Fts5Storage *p,  const char *z,  sqlite3_value *pVal,  int iVal ){  sqlite3_stmt *pReplace = 0;  int rc = fts5StorageGetStmt(p, FTS5_STMT_REPLACE_CONFIG, &pReplace, 0);  if( rc==SQLITE_OK ){  sqlite3_bind_text(pReplace, 1, z, -1, SQLITE_STATIC);  if( pVal ){  sqlite3_bind_value(pReplace, 2, pVal);  }else{  sqlite3_bind_int(pReplace, 2, iVal);  }  sqlite3_step(pReplace);  rc = sqlite3_reset(pReplace);  sqlite3_bind_null(pReplace, 1);  }  if( rc==SQLITE_OK && pVal ){  int iNew = p->pConfig->iCookie + 1;  rc = sqlite3Fts5IndexSetCookie(p->pIndex, iNew);  if( rc==SQLITE_OK ){  p->pConfig->iCookie = iNew;  }  }  return rc; } static unsigned char aAsciiTokenChar[128] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, }; typedef struct AsciiTokenizer AsciiTokenizer; struct AsciiTokenizer {  unsigned char aTokenChar[128]; }; static void fts5AsciiAddExceptions(  AsciiTokenizer *p,  const char *zArg,  int bTokenChars ){  int i;  for(i=0; zArg[i]; i++){  if( (zArg[i] & 0x80)==0 ){  p->aTokenChar[(int)zArg[i]] = (unsigned char)bTokenChars;  }  } } static void fts5AsciiDelete(Fts5Tokenizer *p){  sqlite3_free(p); } static int fts5AsciiCreate(  void *pUnused,  const char **azArg, int nArg,  Fts5Tokenizer **ppOut ){  int rc = SQLITE_OK;  AsciiTokenizer *p = 0;  UNUSED_PARAM(pUnused);  if( nArg%2 ){  rc = SQLITE_ERROR;  }else{  p = sqlite3_malloc(sizeof(AsciiTokenizer));  if( p==0 ){  rc = SQLITE_NOMEM;  }else{  int i;  memset(p, 0, sizeof(AsciiTokenizer));  memcpy(p->aTokenChar, aAsciiTokenChar, sizeof(aAsciiTokenChar));  for(i=0; rc==SQLITE_OK && i<nArg; i+=2){  const char *zArg = azArg[i+1];  if( 0==sqlite3_stricmp(azArg[i], "tokenchars") ){  fts5AsciiAddExceptions(p, zArg, 1);  }else  if( 0==sqlite3_stricmp(azArg[i], "separators") ){  fts5AsciiAddExceptions(p, zArg, 0);  }else{  rc = SQLITE_ERROR;  }  }  if( rc!=SQLITE_OK ){  fts5AsciiDelete((Fts5Tokenizer*)p);  p = 0;  }  }  }  *ppOut = (Fts5Tokenizer*)p;  return rc; } static void asciiFold(char *aOut, const char *aIn, int nByte){  int i;  for(i=0; i<nByte; i++){  char c = aIn[i];  if( c>='A' && c<='Z' ) c += 32;  aOut[i] = c;  } } static int fts5AsciiTokenize(  Fts5Tokenizer *pTokenizer,  void *pCtx,  int iUnused,  const char *pText, int nText,  int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd) ){  AsciiTokenizer *p = (AsciiTokenizer*)pTokenizer;  int rc = SQLITE_OK;  int ie;  int is = 0;  char aFold[64];  int nFold = sizeof(aFold);  char *pFold = aFold;  unsigned char *a = p->aTokenChar;  UNUSED_PARAM(iUnused);  while( is<nText && rc==SQLITE_OK ){  int nByte;  while( is<nText && ((pText[is]&0x80)==0 && a[(int)pText[is]]==0) ){  is++;  }  if( is==nText ) break;  ie = is+1;  while( ie<nText && ((pText[ie]&0x80) || a[(int)pText[ie]] ) ){  ie++;  }  nByte = ie-is;  if( nByte>nFold ){  if( pFold!=aFold ) sqlite3_free(pFold);  pFold = sqlite3_malloc64((sqlite3_int64)nByte*2);  if( pFold==0 ){  rc = SQLITE_NOMEM;  break;  }  nFold = nByte*2;  }  asciiFold(pFold, &pText[is], nByte);  rc = xToken(pCtx, 0, pFold, nByte, is, ie);  is = ie+1;  }  if( pFold!=aFold ) sqlite3_free(pFold);  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  return rc; }
#ifndef SQLITE_AMALGAMATION
static const unsigned char sqlite3Utf8Trans1[] = {  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00, };
#define READ_UTF8(zIn, zTerm, c)   c = *(zIn++);  if( c>=0xc0 ){   c = sqlite3Utf8Trans1[c-0xc0];   while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){  c = (c<<6) + (0x3f & *(zIn++));  }  if( c<0x80   || (c&0xFFFFF800)==0xD800  || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }  }

#define WRITE_UTF8(zOut, c) {  if( c<0x00080 ){   *zOut++ = (unsigned char)(c&0xFF);   }  else if( c<0x00800 ){  *zOut++ = 0xC0 + (unsigned char)((c>>6)&0x1F);   *zOut++ = 0x80 + (unsigned char)(c & 0x3F);  }  else if( c<0x10000 ){  *zOut++ = 0xE0 + (unsigned char)((c>>12)&0x0F);  *zOut++ = 0x80 + (unsigned char)((c>>6) & 0x3F);   *zOut++ = 0x80 + (unsigned char)(c & 0x3F);  }else{   *zOut++ = 0xF0 + (unsigned char)((c>>18) & 0x07);  *zOut++ = 0x80 + (unsigned char)((c>>12) & 0x3F);  *zOut++ = 0x80 + (unsigned char)((c>>6) & 0x3F);   *zOut++ = 0x80 + (unsigned char)(c & 0x3F);  } }

#endif
typedef struct Unicode61Tokenizer Unicode61Tokenizer; struct Unicode61Tokenizer {  unsigned char aTokenChar[128];  char *aFold;  int nFold;  int eRemoveDiacritic;  int nException;  int *aiException;  unsigned char aCategory[32]; };
#define FTS5_REMOVE_DIACRITICS_NONE 0
#define FTS5_REMOVE_DIACRITICS_SIMPLE 1
#define FTS5_REMOVE_DIACRITICS_COMPLEX 2
static int fts5UnicodeAddExceptions(  Unicode61Tokenizer *p,  const char *z,  int bTokenChars ){  int rc = SQLITE_OK;  int n = (int)strlen(z);  int *aNew;  if( n>0 ){  aNew = (int*)sqlite3_realloc64(p->aiException,   (n+p->nException)*sizeof(int));  if( aNew ){  int nNew = p->nException;  const unsigned char *zCsr = (const unsigned char*)z;  const unsigned char *zTerm = (const unsigned char*)&z[n];  while( zCsr<zTerm ){  u32 iCode;  int bToken;  READ_UTF8(zCsr, zTerm, iCode);  if( iCode<128 ){  p->aTokenChar[iCode] = (unsigned char)bTokenChars;  }else{  bToken = p->aCategory[sqlite3Fts5UnicodeCategory(iCode)];  assert( (bToken==0 || bToken==1) );  assert( (bTokenChars==0 || bTokenChars==1) );  if( bToken!=bTokenChars && sqlite3Fts5UnicodeIsdiacritic(iCode)==0 ){  int i;  for(i=0; i<nNew; i++){  if( (u32)aNew[i]>iCode ) break;  }  memmove(&aNew[i+1], &aNew[i], (nNew-i)*sizeof(int));  aNew[i] = iCode;  nNew++;  }  }  }  p->aiException = aNew;  p->nException = nNew;  }else{  rc = SQLITE_NOMEM;  }  }  return rc; } static int fts5UnicodeIsException(Unicode61Tokenizer *p, int iCode){  if( p->nException>0 ){  int *a = p->aiException;  int iLo = 0;  int iHi = p->nException-1;  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  if( iCode==a[iTest] ){  return 1;  }else if( iCode>a[iTest] ){  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  }  return 0; } static void fts5UnicodeDelete(Fts5Tokenizer *pTok){  if( pTok ){  Unicode61Tokenizer *p = (Unicode61Tokenizer*)pTok;  sqlite3_free(p->aiException);  sqlite3_free(p->aFold);  sqlite3_free(p);  }  return; } static int unicodeSetCategories(Unicode61Tokenizer *p, const char *zCat){  const char *z = zCat;  while( *z ){  while( *z==' ' || *z=='\t' ) z++;  if( *z && sqlite3Fts5UnicodeCatParse(z, p->aCategory) ){  return SQLITE_ERROR;  }  while( *z!=' ' && *z!='\t' && *z!='\0' ) z++;  }  sqlite3Fts5UnicodeAscii(p->aCategory, p->aTokenChar);  return SQLITE_OK; } static int fts5UnicodeCreate(  void *pUnused,  const char **azArg, int nArg,  Fts5Tokenizer **ppOut ){  int rc = SQLITE_OK;  Unicode61Tokenizer *p = 0;  UNUSED_PARAM(pUnused);  if( nArg%2 ){  rc = SQLITE_ERROR;  }else{  p = (Unicode61Tokenizer*)sqlite3_malloc(sizeof(Unicode61Tokenizer));  if( p ){  const char *zCat = "L* N* Co";  int i;  memset(p, 0, sizeof(Unicode61Tokenizer));  p->eRemoveDiacritic = FTS5_REMOVE_DIACRITICS_SIMPLE;  p->nFold = 64;  p->aFold = sqlite3_malloc64(p->nFold * sizeof(char));  if( p->aFold==0 ){  rc = SQLITE_NOMEM;  }  for(i=0; rc==SQLITE_OK && i<nArg; i+=2){  if( 0==sqlite3_stricmp(azArg[i], "categories") ){  zCat = azArg[i+1];  }  }  if( rc==SQLITE_OK ){  rc = unicodeSetCategories(p, zCat);  }  for(i=0; rc==SQLITE_OK && i<nArg; i+=2){  const char *zArg = azArg[i+1];  if( 0==sqlite3_stricmp(azArg[i], "remove_diacritics") ){  if( (zArg[0]!='0' && zArg[0]!='1' && zArg[0]!='2') || zArg[1] ){  rc = SQLITE_ERROR;  }else{  p->eRemoveDiacritic = (zArg[0] - '0');  assert( p->eRemoveDiacritic==FTS5_REMOVE_DIACRITICS_NONE   || p->eRemoveDiacritic==FTS5_REMOVE_DIACRITICS_SIMPLE   || p->eRemoveDiacritic==FTS5_REMOVE_DIACRITICS_COMPLEX  );  }  }else  if( 0==sqlite3_stricmp(azArg[i], "tokenchars") ){  rc = fts5UnicodeAddExceptions(p, zArg, 1);  }else  if( 0==sqlite3_stricmp(azArg[i], "separators") ){  rc = fts5UnicodeAddExceptions(p, zArg, 0);  }else  if( 0==sqlite3_stricmp(azArg[i], "categories") ){  }else{  rc = SQLITE_ERROR;  }  }  }else{  rc = SQLITE_NOMEM;  }  if( rc!=SQLITE_OK ){  fts5UnicodeDelete((Fts5Tokenizer*)p);  p = 0;  }  *ppOut = (Fts5Tokenizer*)p;  }  return rc; } static int fts5UnicodeIsAlnum(Unicode61Tokenizer *p, int iCode){  return (  p->aCategory[sqlite3Fts5UnicodeCategory((u32)iCode)]  ^ fts5UnicodeIsException(p, iCode)  ); } static int fts5UnicodeTokenize(  Fts5Tokenizer *pTokenizer,  void *pCtx,  int iUnused,  const char *pText, int nText,  int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd) ){  Unicode61Tokenizer *p = (Unicode61Tokenizer*)pTokenizer;  int rc = SQLITE_OK;  unsigned char *a = p->aTokenChar;  unsigned char *zTerm = (unsigned char*)&pText[nText];  unsigned char *zCsr = (unsigned char *)pText;  char *aFold = p->aFold;  int nFold = p->nFold;  const char *pEnd = &aFold[nFold-6];  UNUSED_PARAM(iUnused);  while( rc==SQLITE_OK ){  u32 iCode;  char *zOut = aFold;  int is;  int ie;  while( 1 ){  if( zCsr>=zTerm ) goto tokenize_done;  if( *zCsr & 0x80 ) {  is = zCsr - (unsigned char*)pText;  READ_UTF8(zCsr, zTerm, iCode);  if( fts5UnicodeIsAlnum(p, iCode) ){  goto non_ascii_tokenchar;  }  }else{  if( a[*zCsr] ){  is = zCsr - (unsigned char*)pText;  goto ascii_tokenchar;  }  zCsr++;  }  }  while( zCsr<zTerm ){  if( zOut>pEnd ){  aFold = sqlite3_malloc64((sqlite3_int64)nFold*2);  if( aFold==0 ){  rc = SQLITE_NOMEM;  goto tokenize_done;  }  zOut = &aFold[zOut - p->aFold];  memcpy(aFold, p->aFold, nFold);  sqlite3_free(p->aFold);  p->aFold = aFold;  p->nFold = nFold = nFold*2;  pEnd = &aFold[nFold-6];  }  if( *zCsr & 0x80 ){  READ_UTF8(zCsr, zTerm, iCode);  if( fts5UnicodeIsAlnum(p,iCode)||sqlite3Fts5UnicodeIsdiacritic(iCode) ){  non_ascii_tokenchar:  iCode = sqlite3Fts5UnicodeFold(iCode, p->eRemoveDiacritic);  if( iCode ) WRITE_UTF8(zOut, iCode);  }else{  break;  }  }else if( a[*zCsr]==0 ){  break;  }else{  ascii_tokenchar:  if( *zCsr>='A' && *zCsr<='Z' ){  *zOut++ = *zCsr + 32;  }else{  *zOut++ = *zCsr;  }  zCsr++;  }  ie = zCsr - (unsigned char*)pText;  }  rc = xToken(pCtx, 0, aFold, zOut-aFold, is, ie);  }  tokenize_done:  if( rc==SQLITE_DONE ) rc = SQLITE_OK;  return rc; }
#define FTS5_PORTER_MAX_TOKEN 64
typedef struct PorterTokenizer PorterTokenizer; struct PorterTokenizer {  fts5_tokenizer tokenizer;  Fts5Tokenizer *pTokenizer;  char aBuf[FTS5_PORTER_MAX_TOKEN + 64]; }; static void fts5PorterDelete(Fts5Tokenizer *pTok){  if( pTok ){  PorterTokenizer *p = (PorterTokenizer*)pTok;  if( p->pTokenizer ){  p->tokenizer.xDelete(p->pTokenizer);  }  sqlite3_free(p);  } } static int fts5PorterCreate(  void *pCtx,  const char **azArg, int nArg,  Fts5Tokenizer **ppOut ){  fts5_api *pApi = (fts5_api*)pCtx;  int rc = SQLITE_OK;  PorterTokenizer *pRet;  void *pUserdata = 0;  const char *zBase = "unicode61";  if( nArg>0 ){  zBase = azArg[0];  }  pRet = (PorterTokenizer*)sqlite3_malloc(sizeof(PorterTokenizer));  if( pRet ){  memset(pRet, 0, sizeof(PorterTokenizer));  rc = pApi->xFindTokenizer(pApi, zBase, &pUserdata, &pRet->tokenizer);  }else{  rc = SQLITE_NOMEM;  }  if( rc==SQLITE_OK ){  int nArg2 = (nArg>0 ? nArg-1 : 0);  const char **azArg2 = (nArg2 ? &azArg[1] : 0);  rc = pRet->tokenizer.xCreate(pUserdata, azArg2, nArg2, &pRet->pTokenizer);  }  if( rc!=SQLITE_OK ){  fts5PorterDelete((Fts5Tokenizer*)pRet);  pRet = 0;  }  *ppOut = (Fts5Tokenizer*)pRet;  return rc; } typedef struct PorterContext PorterContext; struct PorterContext {  void *pCtx;  int (*xToken)(void*, int, const char*, int, int, int);  char *aBuf; }; typedef struct PorterRule PorterRule; struct PorterRule {  const char *zSuffix;  int nSuffix;  int (*xCond)(char *zStem, int nStem);  const char *zOutput;  int nOutput; };
#if 0
static int fts5PorterApply(char *aBuf, int *pnBuf, PorterRule *aRule){  int ret = -1;  int nBuf = *pnBuf;  PorterRule *p;  for(p=aRule; p->zSuffix; p++){  assert( strlen(p->zSuffix)==p->nSuffix );  assert( strlen(p->zOutput)==p->nOutput );  if( nBuf<p->nSuffix ) continue;  if( 0==memcmp(&aBuf[nBuf - p->nSuffix], p->zSuffix, p->nSuffix) ) break;  }  if( p->zSuffix ){  int nStem = nBuf - p->nSuffix;  if( p->xCond==0 || p->xCond(aBuf, nStem) ){  memcpy(&aBuf[nStem], p->zOutput, p->nOutput);  *pnBuf = nStem + p->nOutput;  ret = p - aRule;  }  }  return ret; }
#endif
static int fts5PorterIsVowel(char c, int bYIsVowel){  return (  c=='a' || c=='e' || c=='i' || c=='o' || c=='u' || (bYIsVowel && c=='y')  ); } static int fts5PorterGobbleVC(char *zStem, int nStem, int bPrevCons){  int i;  int bCons = bPrevCons;  for(i=0; i<nStem; i++){  if( 0==(bCons = !fts5PorterIsVowel(zStem[i], bCons)) ) break;  }  for(i++; i<nStem; i++){  if( (bCons = !fts5PorterIsVowel(zStem[i], bCons)) ) return i+1;  }  return 0; } static int fts5Porter_MGt0(char *zStem, int nStem){  return !!fts5PorterGobbleVC(zStem, nStem, 0); } static int fts5Porter_MGt1(char *zStem, int nStem){  int n;  n = fts5PorterGobbleVC(zStem, nStem, 0);  if( n && fts5PorterGobbleVC(&zStem[n], nStem-n, 1) ){  return 1;  }  return 0; } static int fts5Porter_MEq1(char *zStem, int nStem){  int n;  n = fts5PorterGobbleVC(zStem, nStem, 0);  if( n && 0==fts5PorterGobbleVC(&zStem[n], nStem-n, 1) ){  return 1;  }  return 0; } static int fts5Porter_Ostar(char *zStem, int nStem){  if( zStem[nStem-1]=='w' || zStem[nStem-1]=='x' || zStem[nStem-1]=='y' ){  return 0;  }else{  int i;  int mask = 0;  int bCons = 0;  for(i=0; i<nStem; i++){  bCons = !fts5PorterIsVowel(zStem[i], bCons);  assert( bCons==0 || bCons==1 );  mask = (mask << 1) + bCons;  }  return ((mask & 0x0007)==0x0005);  } } static int fts5Porter_MGt1_and_S_or_T(char *zStem, int nStem){  assert( nStem>0 );  return (zStem[nStem-1]=='s' || zStem[nStem-1]=='t')  && fts5Porter_MGt1(zStem, nStem); } static int fts5Porter_Vowel(char *zStem, int nStem){  int i;  for(i=0; i<nStem; i++){  if( fts5PorterIsVowel(zStem[i], i>0) ){  return 1;  }  }  return 0; } static int fts5PorterStep4(char *aBuf, int *pnBuf){  int ret = 0;  int nBuf = *pnBuf;  switch( aBuf[nBuf-2] ){  case 'a':  if( nBuf>2 && 0==memcmp("al", &aBuf[nBuf-2], 2) ){  if( fts5Porter_MGt1(aBuf, nBuf-2) ){  *pnBuf = nBuf - 2;  }  }  break;  case 'c':  if( nBuf>4 && 0==memcmp("ance", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt1(aBuf, nBuf-4) ){  *pnBuf = nBuf - 4;  }  }else if( nBuf>4 && 0==memcmp("ence", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt1(aBuf, nBuf-4) ){  *pnBuf = nBuf - 4;  }  }  break;  case 'e':  if( nBuf>2 && 0==memcmp("er", &aBuf[nBuf-2], 2) ){  if( fts5Porter_MGt1(aBuf, nBuf-2) ){  *pnBuf = nBuf - 2;  }  }  break;  case 'i':  if( nBuf>2 && 0==memcmp("ic", &aBuf[nBuf-2], 2) ){  if( fts5Porter_MGt1(aBuf, nBuf-2) ){  *pnBuf = nBuf - 2;  }  }  break;  case 'l':  if( nBuf>4 && 0==memcmp("able", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt1(aBuf, nBuf-4) ){  *pnBuf = nBuf - 4;  }  }else if( nBuf>4 && 0==memcmp("ible", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt1(aBuf, nBuf-4) ){  *pnBuf = nBuf - 4;  }  }  break;  case 'n':  if( nBuf>3 && 0==memcmp("ant", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }else if( nBuf>5 && 0==memcmp("ement", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt1(aBuf, nBuf-5) ){  *pnBuf = nBuf - 5;  }  }else if( nBuf>4 && 0==memcmp("ment", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt1(aBuf, nBuf-4) ){  *pnBuf = nBuf - 4;  }  }else if( nBuf>3 && 0==memcmp("ent", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  case 'o':  if( nBuf>3 && 0==memcmp("ion", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1_and_S_or_T(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }else if( nBuf>2 && 0==memcmp("ou", &aBuf[nBuf-2], 2) ){  if( fts5Porter_MGt1(aBuf, nBuf-2) ){  *pnBuf = nBuf - 2;  }  }  break;  case 's':  if( nBuf>3 && 0==memcmp("ism", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  case 't':  if( nBuf>3 && 0==memcmp("ate", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }else if( nBuf>3 && 0==memcmp("iti", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  case 'u':  if( nBuf>3 && 0==memcmp("ous", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  case 'v':  if( nBuf>3 && 0==memcmp("ive", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  case 'z':  if( nBuf>3 && 0==memcmp("ize", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt1(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  }  return ret; } static int fts5PorterStep1B2(char *aBuf, int *pnBuf){  int ret = 0;  int nBuf = *pnBuf;  switch( aBuf[nBuf-2] ){  case 'a':  if( nBuf>2 && 0==memcmp("at", &aBuf[nBuf-2], 2) ){  memcpy(&aBuf[nBuf-2], "ate", 3);  *pnBuf = nBuf - 2 + 3;  ret = 1;  }  break;  case 'b':  if( nBuf>2 && 0==memcmp("bl", &aBuf[nBuf-2], 2) ){  memcpy(&aBuf[nBuf-2], "ble", 3);  *pnBuf = nBuf - 2 + 3;  ret = 1;  }  break;  case 'i':  if( nBuf>2 && 0==memcmp("iz", &aBuf[nBuf-2], 2) ){  memcpy(&aBuf[nBuf-2], "ize", 3);  *pnBuf = nBuf - 2 + 3;  ret = 1;  }  break;  }  return ret; } static int fts5PorterStep2(char *aBuf, int *pnBuf){  int ret = 0;  int nBuf = *pnBuf;  switch( aBuf[nBuf-2] ){  case 'a':  if( nBuf>7 && 0==memcmp("ational", &aBuf[nBuf-7], 7) ){  if( fts5Porter_MGt0(aBuf, nBuf-7) ){  memcpy(&aBuf[nBuf-7], "ate", 3);  *pnBuf = nBuf - 7 + 3;  }  }else if( nBuf>6 && 0==memcmp("tional", &aBuf[nBuf-6], 6) ){  if( fts5Porter_MGt0(aBuf, nBuf-6) ){  memcpy(&aBuf[nBuf-6], "tion", 4);  *pnBuf = nBuf - 6 + 4;  }  }  break;  case 'c':  if( nBuf>4 && 0==memcmp("enci", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "ence", 4);  *pnBuf = nBuf - 4 + 4;  }  }else if( nBuf>4 && 0==memcmp("anci", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "ance", 4);  *pnBuf = nBuf - 4 + 4;  }  }  break;  case 'e':  if( nBuf>4 && 0==memcmp("izer", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "ize", 3);  *pnBuf = nBuf - 4 + 3;  }  }  break;  case 'g':  if( nBuf>4 && 0==memcmp("logi", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "log", 3);  *pnBuf = nBuf - 4 + 3;  }  }  break;  case 'l':  if( nBuf>3 && 0==memcmp("bli", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt0(aBuf, nBuf-3) ){  memcpy(&aBuf[nBuf-3], "ble", 3);  *pnBuf = nBuf - 3 + 3;  }  }else if( nBuf>4 && 0==memcmp("alli", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "al", 2);  *pnBuf = nBuf - 4 + 2;  }  }else if( nBuf>5 && 0==memcmp("entli", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "ent", 3);  *pnBuf = nBuf - 5 + 3;  }  }else if( nBuf>3 && 0==memcmp("eli", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt0(aBuf, nBuf-3) ){  memcpy(&aBuf[nBuf-3], "e", 1);  *pnBuf = nBuf - 3 + 1;  }  }else if( nBuf>5 && 0==memcmp("ousli", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "ous", 3);  *pnBuf = nBuf - 5 + 3;  }  }  break;  case 'o':  if( nBuf>7 && 0==memcmp("ization", &aBuf[nBuf-7], 7) ){  if( fts5Porter_MGt0(aBuf, nBuf-7) ){  memcpy(&aBuf[nBuf-7], "ize", 3);  *pnBuf = nBuf - 7 + 3;  }  }else if( nBuf>5 && 0==memcmp("ation", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "ate", 3);  *pnBuf = nBuf - 5 + 3;  }  }else if( nBuf>4 && 0==memcmp("ator", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "ate", 3);  *pnBuf = nBuf - 4 + 3;  }  }  break;  case 's':  if( nBuf>5 && 0==memcmp("alism", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "al", 2);  *pnBuf = nBuf - 5 + 2;  }  }else if( nBuf>7 && 0==memcmp("iveness", &aBuf[nBuf-7], 7) ){  if( fts5Porter_MGt0(aBuf, nBuf-7) ){  memcpy(&aBuf[nBuf-7], "ive", 3);  *pnBuf = nBuf - 7 + 3;  }  }else if( nBuf>7 && 0==memcmp("fulness", &aBuf[nBuf-7], 7) ){  if( fts5Porter_MGt0(aBuf, nBuf-7) ){  memcpy(&aBuf[nBuf-7], "ful", 3);  *pnBuf = nBuf - 7 + 3;  }  }else if( nBuf>7 && 0==memcmp("ousness", &aBuf[nBuf-7], 7) ){  if( fts5Porter_MGt0(aBuf, nBuf-7) ){  memcpy(&aBuf[nBuf-7], "ous", 3);  *pnBuf = nBuf - 7 + 3;  }  }  break;  case 't':  if( nBuf>5 && 0==memcmp("aliti", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "al", 2);  *pnBuf = nBuf - 5 + 2;  }  }else if( nBuf>5 && 0==memcmp("iviti", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "ive", 3);  *pnBuf = nBuf - 5 + 3;  }  }else if( nBuf>6 && 0==memcmp("biliti", &aBuf[nBuf-6], 6) ){  if( fts5Porter_MGt0(aBuf, nBuf-6) ){  memcpy(&aBuf[nBuf-6], "ble", 3);  *pnBuf = nBuf - 6 + 3;  }  }  break;  }  return ret; } static int fts5PorterStep3(char *aBuf, int *pnBuf){  int ret = 0;  int nBuf = *pnBuf;  switch( aBuf[nBuf-2] ){  case 'a':  if( nBuf>4 && 0==memcmp("ical", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  memcpy(&aBuf[nBuf-4], "ic", 2);  *pnBuf = nBuf - 4 + 2;  }  }  break;  case 's':  if( nBuf>4 && 0==memcmp("ness", &aBuf[nBuf-4], 4) ){  if( fts5Porter_MGt0(aBuf, nBuf-4) ){  *pnBuf = nBuf - 4;  }  }  break;  case 't':  if( nBuf>5 && 0==memcmp("icate", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "ic", 2);  *pnBuf = nBuf - 5 + 2;  }  }else if( nBuf>5 && 0==memcmp("iciti", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "ic", 2);  *pnBuf = nBuf - 5 + 2;  }  }  break;  case 'u':  if( nBuf>3 && 0==memcmp("ful", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt0(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  }  }  break;  case 'v':  if( nBuf>5 && 0==memcmp("ative", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  *pnBuf = nBuf - 5;  }  }  break;  case 'z':  if( nBuf>5 && 0==memcmp("alize", &aBuf[nBuf-5], 5) ){  if( fts5Porter_MGt0(aBuf, nBuf-5) ){  memcpy(&aBuf[nBuf-5], "al", 2);  *pnBuf = nBuf - 5 + 2;  }  }  break;  }  return ret; } static int fts5PorterStep1B(char *aBuf, int *pnBuf){  int ret = 0;  int nBuf = *pnBuf;  switch( aBuf[nBuf-2] ){  case 'e':  if( nBuf>3 && 0==memcmp("eed", &aBuf[nBuf-3], 3) ){  if( fts5Porter_MGt0(aBuf, nBuf-3) ){  memcpy(&aBuf[nBuf-3], "ee", 2);  *pnBuf = nBuf - 3 + 2;  }  }else if( nBuf>2 && 0==memcmp("ed", &aBuf[nBuf-2], 2) ){  if( fts5Porter_Vowel(aBuf, nBuf-2) ){  *pnBuf = nBuf - 2;  ret = 1;  }  }  break;  case 'n':  if( nBuf>3 && 0==memcmp("ing", &aBuf[nBuf-3], 3) ){  if( fts5Porter_Vowel(aBuf, nBuf-3) ){  *pnBuf = nBuf - 3;  ret = 1;  }  }  break;  }  return ret; } static void fts5PorterStep1A(char *aBuf, int *pnBuf){  int nBuf = *pnBuf;  if( aBuf[nBuf-1]=='s' ){  if( aBuf[nBuf-2]=='e' ){  if( (nBuf>4 && aBuf[nBuf-4]=='s' && aBuf[nBuf-3]=='s')   || (nBuf>3 && aBuf[nBuf-3]=='i' )  ){  *pnBuf = nBuf-2;  }else{  *pnBuf = nBuf-1;  }  }  else if( aBuf[nBuf-2]!='s' ){  *pnBuf = nBuf-1;  }  } } static int fts5PorterCb(  void *pCtx,  int tflags,  const char *pToken,  int nToken,  int iStart,  int iEnd ){  PorterContext *p = (PorterContext*)pCtx;  char *aBuf;  int nBuf;  if( nToken>FTS5_PORTER_MAX_TOKEN || nToken<3 ) goto pass_through;  aBuf = p->aBuf;  nBuf = nToken;  memcpy(aBuf, pToken, nBuf);  fts5PorterStep1A(aBuf, &nBuf);  if( fts5PorterStep1B(aBuf, &nBuf) ){  if( fts5PorterStep1B2(aBuf, &nBuf)==0 ){  char c = aBuf[nBuf-1];  if( fts5PorterIsVowel(c, 0)==0   && c!='l' && c!='s' && c!='z' && c==aBuf[nBuf-2]  ){  nBuf--;  }else if( fts5Porter_MEq1(aBuf, nBuf) && fts5Porter_Ostar(aBuf, nBuf) ){  aBuf[nBuf++] = 'e';  }  }  }  if( aBuf[nBuf-1]=='y' && fts5Porter_Vowel(aBuf, nBuf-1) ){  aBuf[nBuf-1] = 'i';  }  fts5PorterStep2(aBuf, &nBuf);  fts5PorterStep3(aBuf, &nBuf);  fts5PorterStep4(aBuf, &nBuf);  assert( nBuf>0 );  if( aBuf[nBuf-1]=='e' ){  if( fts5Porter_MGt1(aBuf, nBuf-1)   || (fts5Porter_MEq1(aBuf, nBuf-1) && !fts5Porter_Ostar(aBuf, nBuf-1))  ){  nBuf--;  }  }  if( nBuf>1 && aBuf[nBuf-1]=='l'   && aBuf[nBuf-2]=='l' && fts5Porter_MGt1(aBuf, nBuf-1)  ){  nBuf--;  }  return p->xToken(p->pCtx, tflags, aBuf, nBuf, iStart, iEnd);  pass_through:  return p->xToken(p->pCtx, tflags, pToken, nToken, iStart, iEnd); } static int fts5PorterTokenize(  Fts5Tokenizer *pTokenizer,  void *pCtx,  int flags,  const char *pText, int nText,  int (*xToken)(void*, int, const char*, int nToken, int iStart, int iEnd) ){  PorterTokenizer *p = (PorterTokenizer*)pTokenizer;  PorterContext sCtx;  sCtx.xToken = xToken;  sCtx.pCtx = pCtx;  sCtx.aBuf = p->aBuf;  return p->tokenizer.xTokenize(  p->pTokenizer, (void*)&sCtx, flags, pText, nText, fts5PorterCb  ); } typedef struct TrigramTokenizer TrigramTokenizer; struct TrigramTokenizer {  int bFold; }; static void fts5TriDelete(Fts5Tokenizer *p){  sqlite3_free(p); } static int fts5TriCreate(  void *pUnused,  const char **azArg,  int nArg,  Fts5Tokenizer **ppOut ){  int rc = SQLITE_OK;  TrigramTokenizer *pNew = (TrigramTokenizer*)sqlite3_malloc(sizeof(*pNew));  UNUSED_PARAM(pUnused);  if( pNew==0 ){  rc = SQLITE_NOMEM;  }else{  int i;  pNew->bFold = 1;  for(i=0; rc==SQLITE_OK && i<nArg; i+=2){  const char *zArg = azArg[i+1];  if( 0==sqlite3_stricmp(azArg[i], "case_sensitive") ){  if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1] ){  rc = SQLITE_ERROR;  }else{  pNew->bFold = (zArg[0]=='0');  }  }else{  rc = SQLITE_ERROR;  }  }  if( rc!=SQLITE_OK ){  fts5TriDelete((Fts5Tokenizer*)pNew);  pNew = 0;  }  }  *ppOut = (Fts5Tokenizer*)pNew;  return rc; } static int fts5TriTokenize(  Fts5Tokenizer *pTok,  void *pCtx,  int unusedFlags,  const char *pText, int nText,  int (*xToken)(void*, int, const char*, int, int, int) ){  TrigramTokenizer *p = (TrigramTokenizer*)pTok;  int rc = SQLITE_OK;  char aBuf[32];  const unsigned char *zIn = (const unsigned char*)pText;  const unsigned char *zEof = &zIn[nText];  u32 iCode;  UNUSED_PARAM(unusedFlags);  while( 1 ){  char *zOut = aBuf;  int iStart = zIn - (const unsigned char*)pText;  const unsigned char *zNext;  READ_UTF8(zIn, zEof, iCode);  if( iCode==0 ) break;  zNext = zIn;  if( zIn<zEof ){  if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);  WRITE_UTF8(zOut, iCode);  READ_UTF8(zIn, zEof, iCode);  if( iCode==0 ) break;  }else{  break;  }  if( zIn<zEof ){  if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);  WRITE_UTF8(zOut, iCode);  READ_UTF8(zIn, zEof, iCode);  if( iCode==0 ) break;  if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);  WRITE_UTF8(zOut, iCode);  }else{  break;  }  rc = xToken(pCtx, 0, aBuf, zOut-aBuf, iStart, iStart + zOut-aBuf);  if( rc!=SQLITE_OK ) break;  zIn = zNext;  }  return rc; } static int sqlite3Fts5TokenizerPattern(  int (*xCreate)(void*, const char**, int, Fts5Tokenizer**),  Fts5Tokenizer *pTok ){  if( xCreate==fts5TriCreate ){  TrigramTokenizer *p = (TrigramTokenizer*)pTok;  return p->bFold ? FTS5_PATTERN_LIKE : FTS5_PATTERN_GLOB;  }  return FTS5_PATTERN_NONE; } static int sqlite3Fts5TokenizerInit(fts5_api *pApi){  struct BuiltinTokenizer {  const char *zName;  fts5_tokenizer x;  } aBuiltin[] = {  { "unicode61", {fts5UnicodeCreate, fts5UnicodeDelete, fts5UnicodeTokenize}},  { "ascii", {fts5AsciiCreate, fts5AsciiDelete, fts5AsciiTokenize }},  { "porter", {fts5PorterCreate, fts5PorterDelete, fts5PorterTokenize }},  { "trigram", {fts5TriCreate, fts5TriDelete, fts5TriTokenize}},  };  int rc = SQLITE_OK;  int i;  for(i=0; rc==SQLITE_OK && i<ArraySize(aBuiltin); i++){  rc = pApi->xCreateTokenizer(pApi,  aBuiltin[i].zName,  (void*)pApi,  &aBuiltin[i].x,  0  );  }  return rc; } static int fts5_remove_diacritic(int c, int bComplex){  unsigned short aDia[] = {  0, 1797, 1848, 1859, 1891, 1928, 1940, 1995,   2024, 2040, 2060, 2110, 2168, 2206, 2264, 2286,   2344, 2383, 2472, 2488, 2516, 2596, 2668, 2732,   2782, 2842, 2894, 2954, 2984, 3000, 3028, 3336,   3456, 3696, 3712, 3728, 3744, 3766, 3832, 3896,   3912, 3928, 3944, 3968, 4008, 4040, 4056, 4106,   4138, 4170, 4202, 4234, 4266, 4296, 4312, 4344,   4408, 4424, 4442, 4472, 4488, 4504, 6148, 6198,   6264, 6280, 6360, 6429, 6505, 6529, 61448, 61468,  61512, 61534, 61592, 61610, 61642, 61672, 61688, 61704,  61726, 61784, 61800, 61816, 61836, 61880, 61896, 61914,  61948, 61998, 62062, 62122, 62154, 62184, 62200, 62218,  62252, 62302, 62364, 62410, 62442, 62478, 62536, 62554,  62584, 62604, 62640, 62648, 62656, 62664, 62730, 62766,  62830, 62890, 62924, 62974, 63032, 63050, 63082, 63118,  63182, 63242, 63274, 63310, 63368, 63390,  };
#define HIBIT ((unsigned char)0x80)
 unsigned char aChar[] = {  '\0', 'a', 'c', 'e', 'i', 'n',  'o', 'u', 'y', 'y', 'a', 'c',  'd', 'e', 'e', 'g', 'h', 'i',  'j', 'k', 'l', 'n', 'o', 'r',  's', 't', 'u', 'u', 'w', 'y',  'z', 'o', 'u', 'a', 'i', 'o',  'u', 'u'|HIBIT, 'a'|HIBIT, 'g', 'k', 'o',  'o'|HIBIT, 'j', 'g', 'n', 'a'|HIBIT, 'a',  'e', 'i', 'o', 'r', 'u', 's',  't', 'h', 'a', 'e', 'o'|HIBIT, 'o',  'o'|HIBIT, 'y', '\0', '\0', '\0', '\0',  '\0', '\0', '\0', '\0', 'a', 'b',  'c'|HIBIT, 'd', 'd', 'e'|HIBIT, 'e', 'e'|HIBIT,  'f', 'g', 'h', 'h', 'i', 'i'|HIBIT,  'k', 'l', 'l'|HIBIT, 'l', 'm', 'n',  'o'|HIBIT, 'p', 'r', 'r'|HIBIT, 'r', 's',  's'|HIBIT, 't', 'u', 'u'|HIBIT, 'v', 'w',  'w', 'x', 'y', 'z', 'h', 't',  'w', 'y', 'a', 'a'|HIBIT, 'a'|HIBIT, 'a'|HIBIT,  'e', 'e'|HIBIT, 'e'|HIBIT, 'i', 'o', 'o'|HIBIT,  'o'|HIBIT, 'o'|HIBIT, 'u', 'u'|HIBIT, 'u'|HIBIT, 'y',  };  unsigned int key = (((unsigned int)c)<<3) | 0x00000007;  int iRes = 0;  int iHi = sizeof(aDia)/sizeof(aDia[0]) - 1;  int iLo = 0;  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  if( key >= aDia[iTest] ){  iRes = iTest;  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  assert( key>=aDia[iRes] );  if( bComplex==0 && (aChar[iRes] & 0x80) ) return c;  return (c > (aDia[iRes]>>3) + (aDia[iRes]&0x07)) ? c : ((int)aChar[iRes] & 0x7F); } static int sqlite3Fts5UnicodeIsdiacritic(int c){  unsigned int mask0 = 0x08029FDF;  unsigned int mask1 = 0x000361F8;  if( c<768 || c>817 ) return 0;  return (c < 768+32) ?  (mask0 & ((unsigned int)1 << (c-768))) :  (mask1 & ((unsigned int)1 << (c-768-32))); } static int sqlite3Fts5UnicodeFold(int c, int eRemoveDiacritic){  static const struct TableEntry {  unsigned short iCode;  unsigned char flags;  unsigned char nRange;  } aEntry[] = {  {65, 14, 26}, {181, 64, 1}, {192, 14, 23},  {216, 14, 7}, {256, 1, 48}, {306, 1, 6},  {313, 1, 16}, {330, 1, 46}, {376, 116, 1},  {377, 1, 6}, {383, 104, 1}, {385, 50, 1},  {386, 1, 4}, {390, 44, 1}, {391, 0, 1},  {393, 42, 2}, {395, 0, 1}, {398, 32, 1},  {399, 38, 1}, {400, 40, 1}, {401, 0, 1},  {403, 42, 1}, {404, 46, 1}, {406, 52, 1},  {407, 48, 1}, {408, 0, 1}, {412, 52, 1},  {413, 54, 1}, {415, 56, 1}, {416, 1, 6},  {422, 60, 1}, {423, 0, 1}, {425, 60, 1},  {428, 0, 1}, {430, 60, 1}, {431, 0, 1},  {433, 58, 2}, {435, 1, 4}, {439, 62, 1},  {440, 0, 1}, {444, 0, 1}, {452, 2, 1},  {453, 0, 1}, {455, 2, 1}, {456, 0, 1},  {458, 2, 1}, {459, 1, 18}, {478, 1, 18},  {497, 2, 1}, {498, 1, 4}, {502, 122, 1},  {503, 134, 1}, {504, 1, 40}, {544, 110, 1},  {546, 1, 18}, {570, 70, 1}, {571, 0, 1},  {573, 108, 1}, {574, 68, 1}, {577, 0, 1},  {579, 106, 1}, {580, 28, 1}, {581, 30, 1},  {582, 1, 10}, {837, 36, 1}, {880, 1, 4},  {886, 0, 1}, {902, 18, 1}, {904, 16, 3},  {908, 26, 1}, {910, 24, 2}, {913, 14, 17},  {931, 14, 9}, {962, 0, 1}, {975, 4, 1},  {976, 140, 1}, {977, 142, 1}, {981, 146, 1},  {982, 144, 1}, {984, 1, 24}, {1008, 136, 1},  {1009, 138, 1}, {1012, 130, 1}, {1013, 128, 1},  {1015, 0, 1}, {1017, 152, 1}, {1018, 0, 1},  {1021, 110, 3}, {1024, 34, 16}, {1040, 14, 32},  {1120, 1, 34}, {1162, 1, 54}, {1216, 6, 1},  {1217, 1, 14}, {1232, 1, 88}, {1329, 22, 38},  {4256, 66, 38}, {4295, 66, 1}, {4301, 66, 1},  {7680, 1, 150}, {7835, 132, 1}, {7838, 96, 1},  {7840, 1, 96}, {7944, 150, 8}, {7960, 150, 6},  {7976, 150, 8}, {7992, 150, 8}, {8008, 150, 6},  {8025, 151, 8}, {8040, 150, 8}, {8072, 150, 8},  {8088, 150, 8}, {8104, 150, 8}, {8120, 150, 2},  {8122, 126, 2}, {8124, 148, 1}, {8126, 100, 1},  {8136, 124, 4}, {8140, 148, 1}, {8152, 150, 2},  {8154, 120, 2}, {8168, 150, 2}, {8170, 118, 2},  {8172, 152, 1}, {8184, 112, 2}, {8186, 114, 2},  {8188, 148, 1}, {8486, 98, 1}, {8490, 92, 1},  {8491, 94, 1}, {8498, 12, 1}, {8544, 8, 16},  {8579, 0, 1}, {9398, 10, 26}, {11264, 22, 47},  {11360, 0, 1}, {11362, 88, 1}, {11363, 102, 1},  {11364, 90, 1}, {11367, 1, 6}, {11373, 84, 1},  {11374, 86, 1}, {11375, 80, 1}, {11376, 82, 1},  {11378, 0, 1}, {11381, 0, 1}, {11390, 78, 2},  {11392, 1, 100}, {11499, 1, 4}, {11506, 0, 1},  {42560, 1, 46}, {42624, 1, 24}, {42786, 1, 14},  {42802, 1, 62}, {42873, 1, 4}, {42877, 76, 1},  {42878, 1, 10}, {42891, 0, 1}, {42893, 74, 1},  {42896, 1, 4}, {42912, 1, 10}, {42922, 72, 1},  {65313, 14, 26},  };  static const unsigned short aiOff[] = {   1, 2, 8, 15, 16, 26, 28, 32,   37, 38, 40, 48, 63, 64, 69, 71,   79, 80, 116, 202, 203, 205, 206, 207,   209, 210, 211, 213, 214, 217, 218, 219,   775, 7264, 10792, 10795, 23228, 23256, 30204, 54721,   54753, 54754, 54756, 54787, 54793, 54809, 57153, 57274,   57921, 58019, 58363, 61722, 65268, 65341, 65373, 65406,   65408, 65410, 65415, 65424, 65436, 65439, 65450, 65462,   65472, 65476, 65478, 65480, 65482, 65488, 65506, 65511,   65514, 65521, 65527, 65528, 65529,  };  int ret = c;  assert( sizeof(unsigned short)==2 && sizeof(unsigned char)==1 );  if( c<128 ){  if( c>='A' && c<='Z' ) ret = c + ('a' - 'A');  }else if( c<65536 ){  const struct TableEntry *p;  int iHi = sizeof(aEntry)/sizeof(aEntry[0]) - 1;  int iLo = 0;  int iRes = -1;  assert( c>aEntry[0].iCode );  while( iHi>=iLo ){  int iTest = (iHi + iLo) / 2;  int cmp = (c - aEntry[iTest].iCode);  if( cmp>=0 ){  iRes = iTest;  iLo = iTest+1;  }else{  iHi = iTest-1;  }  }  assert( iRes>=0 && c>=aEntry[iRes].iCode );  p = &aEntry[iRes];  if( c<(p->iCode + p->nRange) && 0==(0x01 & p->flags & (p->iCode ^ c)) ){  ret = (c + (aiOff[p->flags>>1])) & 0x0000FFFF;  assert( ret>0 );  }  if( eRemoveDiacritic ){  ret = fts5_remove_diacritic(ret, eRemoveDiacritic==2);  }  }  else if( c>=66560 && c<66600 ){  ret = c + 40;  }  return ret; } static int sqlite3Fts5UnicodeCatParse(const char *zCat, u8 *aArray){  aArray[0] = 1;  switch( zCat[0] ){  case 'C':  switch( zCat[1] ){  case 'c': aArray[1] = 1; break;  case 'f': aArray[2] = 1; break;  case 'n': aArray[3] = 1; break;  case 's': aArray[4] = 1; break;  case 'o': aArray[31] = 1; break;  case '*':  aArray[1] = 1;  aArray[2] = 1;  aArray[3] = 1;  aArray[4] = 1;  aArray[31] = 1;  break;  default: return 1; }  break;  case 'L':  switch( zCat[1] ){  case 'l': aArray[5] = 1; break;  case 'm': aArray[6] = 1; break;  case 'o': aArray[7] = 1; break;  case 't': aArray[8] = 1; break;  case 'u': aArray[9] = 1; break;  case 'C': aArray[30] = 1; break;  case '*':  aArray[5] = 1;  aArray[6] = 1;  aArray[7] = 1;  aArray[8] = 1;  aArray[9] = 1;  aArray[30] = 1;  break;  default: return 1; }  break;  case 'M':  switch( zCat[1] ){  case 'c': aArray[10] = 1; break;  case 'e': aArray[11] = 1; break;  case 'n': aArray[12] = 1; break;  case '*':  aArray[10] = 1;  aArray[11] = 1;  aArray[12] = 1;  break;  default: return 1; }  break;  case 'N':  switch( zCat[1] ){  case 'd': aArray[13] = 1; break;  case 'l': aArray[14] = 1; break;  case 'o': aArray[15] = 1; break;  case '*':  aArray[13] = 1;  aArray[14] = 1;  aArray[15] = 1;  break;  default: return 1; }  break;  case 'P':  switch( zCat[1] ){  case 'c': aArray[16] = 1; break;  case 'd': aArray[17] = 1; break;  case 'e': aArray[18] = 1; break;  case 'f': aArray[19] = 1; break;  case 'i': aArray[20] = 1; break;  case 'o': aArray[21] = 1; break;  case 's': aArray[22] = 1; break;  case '*':  aArray[16] = 1;  aArray[17] = 1;  aArray[18] = 1;  aArray[19] = 1;  aArray[20] = 1;  aArray[21] = 1;  aArray[22] = 1;  break;  default: return 1; }  break;  case 'S':  switch( zCat[1] ){  case 'c': aArray[23] = 1; break;  case 'k': aArray[24] = 1; break;  case 'm': aArray[25] = 1; break;  case 'o': aArray[26] = 1; break;  case '*':  aArray[23] = 1;  aArray[24] = 1;  aArray[25] = 1;  aArray[26] = 1;  break;  default: return 1; }  break;  case 'Z':  switch( zCat[1] ){  case 'l': aArray[27] = 1; break;  case 'p': aArray[28] = 1; break;  case 's': aArray[29] = 1; break;  case '*':  aArray[27] = 1;  aArray[28] = 1;  aArray[29] = 1;  break;  default: return 1; }  break;  }  return 0; } static u16 aFts5UnicodeBlock[] = {  0, 1471, 1753, 1760, 1760, 1760, 1760, 1760, 1760, 1760,  1760, 1760, 1760, 1760, 1760, 1763, 1765,  }; static u16 aFts5UnicodeMap[] = {  0, 32, 33, 36, 37, 40, 41, 42, 43, 44,  45, 46, 48, 58, 60, 63, 65, 91, 92, 93,  94, 95, 96, 97, 123, 124, 125, 126, 127, 160,  161, 162, 166, 167, 168, 169, 170, 171, 172, 173,  174, 175, 176, 177, 178, 180, 181, 182, 184, 185,  186, 187, 188, 191, 192, 215, 216, 223, 247, 248,  256, 312, 313, 329, 330, 377, 383, 385, 387, 388,  391, 394, 396, 398, 402, 403, 405, 406, 409, 412,  414, 415, 417, 418, 423, 427, 428, 431, 434, 436,  437, 440, 442, 443, 444, 446, 448, 452, 453, 454,  455, 456, 457, 458, 459, 460, 461, 477, 478, 496,  497, 498, 499, 500, 503, 505, 506, 564, 570, 572,  573, 575, 577, 580, 583, 584, 592, 660, 661, 688,  706, 710, 722, 736, 741, 748, 749, 750, 751, 768,  880, 884, 885, 886, 890, 891, 894, 900, 902, 903,  904, 908, 910, 912, 913, 931, 940, 975, 977, 978,  981, 984, 1008, 1012, 1014, 1015, 1018, 1020, 1021, 1072,  1120, 1154, 1155, 1160, 1162, 1217, 1231, 1232, 1329, 1369,  1370, 1377, 1417, 1418, 1423, 1425, 1470, 1471, 1472, 1473,  1475, 1476, 1478, 1479, 1488, 1520, 1523, 1536, 1542, 1545,  1547, 1548, 1550, 1552, 1563, 1566, 1568, 1600, 1601, 1611,  1632, 1642, 1646, 1648, 1649, 1748, 1749, 1750, 1757, 1758,  1759, 1765, 1767, 1769, 1770, 1774, 1776, 1786, 1789, 1791,  1792, 1807, 1808, 1809, 1810, 1840, 1869, 1958, 1969, 1984,  1994, 2027, 2036, 2038, 2039, 2042, 2048, 2070, 2074, 2075,  2084, 2085, 2088, 2089, 2096, 2112, 2137, 2142, 2208, 2210,  2276, 2304, 2307, 2308, 2362, 2363, 2364, 2365, 2366, 2369,  2377, 2381, 2382, 2384, 2385, 2392, 2402, 2404, 2406, 2416,  2417, 2418, 2425, 2433, 2434, 2437, 2447, 2451, 2474, 2482,  2486, 2492, 2493, 2494, 2497, 2503, 2507, 2509, 2510, 2519,  2524, 2527, 2530, 2534, 2544, 2546, 2548, 2554, 2555, 2561,  2563, 2565, 2575, 2579, 2602, 2610, 2613, 2616, 2620, 2622,  2625, 2631, 2635, 2641, 2649, 2654, 2662, 2672, 2674, 2677,  2689, 2691, 2693, 2703, 2707, 2730, 2738, 2741, 2748, 2749,  2750, 2753, 2759, 2761, 2763, 2765, 2768, 2784, 2786, 2790,  2800, 2801, 2817, 2818, 2821, 2831, 2835, 2858, 2866, 2869,  2876, 2877, 2878, 2879, 2880, 2881, 2887, 2891, 2893, 2902,  2903, 2908, 2911, 2914, 2918, 2928, 2929, 2930, 2946, 2947,  2949, 2958, 2962, 2969, 2972, 2974, 2979, 2984, 2990, 3006,  3008, 3009, 3014, 3018, 3021, 3024, 3031, 3046, 3056, 3059,  3065, 3066, 3073, 3077, 3086, 3090, 3114, 3125, 3133, 3134,  3137, 3142, 3146, 3157, 3160, 3168, 3170, 3174, 3192, 3199,  3202, 3205, 3214, 3218, 3242, 3253, 3260, 3261, 3262, 3263,  3264, 3270, 3271, 3274, 3276, 3285, 3294, 3296, 3298, 3302,  3313, 3330, 3333, 3342, 3346, 3389, 3390, 3393, 3398, 3402,  3405, 3406, 3415, 3424, 3426, 3430, 3440, 3449, 3450, 3458,  3461, 3482, 3507, 3517, 3520, 3530, 3535, 3538, 3542, 3544,  3570, 3572, 3585, 3633, 3634, 3636, 3647, 3648, 3654, 3655,  3663, 3664, 3674, 3713, 3716, 3719, 3722, 3725, 3732, 3737,  3745, 3749, 3751, 3754, 3757, 3761, 3762, 3764, 3771, 3773,  3776, 3782, 3784, 3792, 3804, 3840, 3841, 3844, 3859, 3860,  3861, 3864, 3866, 3872, 3882, 3892, 3893, 3894, 3895, 3896,  3897, 3898, 3899, 3900, 3901, 3902, 3904, 3913, 3953, 3967,  3968, 3973, 3974, 3976, 3981, 3993, 4030, 4038, 4039, 4046,  4048, 4053, 4057, 4096, 4139, 4141, 4145, 4146, 4152, 4153,  4155, 4157, 4159, 4160, 4170, 4176, 4182, 4184, 4186, 4190,  4193, 4194, 4197, 4199, 4206, 4209, 4213, 4226, 4227, 4229,  4231, 4237, 4238, 4239, 4240, 4250, 4253, 4254, 4256, 4295,  4301, 4304, 4347, 4348, 4349, 4682, 4688, 4696, 4698, 4704,  4746, 4752, 4786, 4792, 4800, 4802, 4808, 4824, 4882, 4888,  4957, 4960, 4969, 4992, 5008, 5024, 5120, 5121, 5741, 5743,  5760, 5761, 5787, 5788, 5792, 5867, 5870, 5888, 5902, 5906,  5920, 5938, 5941, 5952, 5970, 5984, 5998, 6002, 6016, 6068,  6070, 6071, 6078, 6086, 6087, 6089, 6100, 6103, 6104, 6107,  6108, 6109, 6112, 6128, 6144, 6150, 6151, 6155, 6158, 6160,  6176, 6211, 6212, 6272, 6313, 6314, 6320, 6400, 6432, 6435,  6439, 6441, 6448, 6450, 6451, 6457, 6464, 6468, 6470, 6480,  6512, 6528, 6576, 6593, 6600, 6608, 6618, 6622, 6656, 6679,  6681, 6686, 6688, 6741, 6742, 6743, 6744, 6752, 6753, 6754,  6755, 6757, 6765, 6771, 6783, 6784, 6800, 6816, 6823, 6824,  6912, 6916, 6917, 6964, 6965, 6966, 6971, 6972, 6973, 6978,  6979, 6981, 6992, 7002, 7009, 7019, 7028, 7040, 7042, 7043,  7073, 7074, 7078, 7080, 7082, 7083, 7084, 7086, 7088, 7098,  7142, 7143, 7144, 7146, 7149, 7150, 7151, 7154, 7164, 7168,  7204, 7212, 7220, 7222, 7227, 7232, 7245, 7248, 7258, 7288,  7294, 7360, 7376, 7379, 7380, 7393, 7394, 7401, 7405, 7406,  7410, 7412, 7413, 7424, 7468, 7531, 7544, 7545, 7579, 7616,  7676, 7680, 7830, 7838, 7936, 7944, 7952, 7960, 7968, 7976,  7984, 7992, 8000, 8008, 8016, 8025, 8027, 8029, 8031, 8033,  8040, 8048, 8064, 8072, 8080, 8088, 8096, 8104, 8112, 8118,  8120, 8124, 8125, 8126, 8127, 8130, 8134, 8136, 8140, 8141,  8144, 8150, 8152, 8157, 8160, 8168, 8173, 8178, 8182, 8184,  8188, 8189, 8192, 8203, 8208, 8214, 8216, 8217, 8218, 8219,  8221, 8222, 8223, 8224, 8232, 8233, 8234, 8239, 8240, 8249,  8250, 8251, 8255, 8257, 8260, 8261, 8262, 8263, 8274, 8275,  8276, 8277, 8287, 8288, 8298, 8304, 8305, 8308, 8314, 8317,  8318, 8319, 8320, 8330, 8333, 8334, 8336, 8352, 8400, 8413,  8417, 8418, 8421, 8448, 8450, 8451, 8455, 8456, 8458, 8459,  8462, 8464, 8467, 8468, 8469, 8470, 8472, 8473, 8478, 8484,  8485, 8486, 8487, 8488, 8489, 8490, 8494, 8495, 8496, 8500,  8501, 8505, 8506, 8508, 8510, 8512, 8517, 8519, 8522, 8523,  8524, 8526, 8527, 8528, 8544, 8579, 8581, 8585, 8592, 8597,  8602, 8604, 8608, 8609, 8611, 8612, 8614, 8615, 8622, 8623,  8654, 8656, 8658, 8659, 8660, 8661, 8692, 8960, 8968, 8972,  8992, 8994, 9001, 9002, 9003, 9084, 9085, 9115, 9140, 9180,  9186, 9216, 9280, 9312, 9372, 9450, 9472, 9655, 9656, 9665,  9666, 9720, 9728, 9839, 9840, 9985, 10088, 10089, 10090, 10091,  10092, 10093, 10094, 10095, 10096, 10097, 10098, 10099, 10100, 10101,  10102, 10132, 10176, 10181, 10182, 10183, 10214, 10215, 10216, 10217,  10218, 10219, 10220, 10221, 10222, 10223, 10224, 10240, 10496, 10627,  10628, 10629, 10630, 10631, 10632, 10633, 10634, 10635, 10636, 10637,  10638, 10639, 10640, 10641, 10642, 10643, 10644, 10645, 10646, 10647,  10648, 10649, 10712, 10713, 10714, 10715, 10716, 10748, 10749, 10750,  11008, 11056, 11077, 11079, 11088, 11264, 11312, 11360, 11363, 11365,  11367, 11374, 11377, 11378, 11380, 11381, 11383, 11388, 11390, 11393,  11394, 11492, 11493, 11499, 11503, 11506, 11513, 11517, 11518, 11520,  11559, 11565, 11568, 11631, 11632, 11647, 11648, 11680, 11688, 11696,  11704, 11712, 11720, 11728, 11736, 11744, 11776, 11778, 11779, 11780,  11781, 11782, 11785, 11786, 11787, 11788, 11789, 11790, 11799, 11800,  11802, 11803, 11804, 11805, 11806, 11808, 11809, 11810, 11811, 11812,  11813, 11814, 11815, 11816, 11817, 11818, 11823, 11824, 11834, 11904,  11931, 12032, 12272, 12288, 12289, 12292, 12293, 12294, 12295, 12296,  12297, 12298, 12299, 12300, 12301, 12302, 12303, 12304, 12305, 12306,  12308, 12309, 12310, 12311, 12312, 12313, 12314, 12315, 12316, 12317,  12318, 12320, 12321, 12330, 12334, 12336, 12337, 12342, 12344, 12347,  12348, 12349, 12350, 12353, 12441, 12443, 12445, 12447, 12448, 12449,  12539, 12540, 12543, 12549, 12593, 12688, 12690, 12694, 12704, 12736,  12784, 12800, 12832, 12842, 12872, 12880, 12881, 12896, 12928, 12938,  12977, 12992, 13056, 13312, 19893, 19904, 19968, 40908, 40960, 40981,  40982, 42128, 42192, 42232, 42238, 42240, 42508, 42509, 42512, 42528,  42538, 42560, 42606, 42607, 42608, 42611, 42612, 42622, 42623, 42624,  42655, 42656, 42726, 42736, 42738, 42752, 42775, 42784, 42786, 42800,  42802, 42864, 42865, 42873, 42878, 42888, 42889, 42891, 42896, 42912,  43000, 43002, 43003, 43010, 43011, 43014, 43015, 43019, 43020, 43043,  43045, 43047, 43048, 43056, 43062, 43064, 43065, 43072, 43124, 43136,  43138, 43188, 43204, 43214, 43216, 43232, 43250, 43256, 43259, 43264,  43274, 43302, 43310, 43312, 43335, 43346, 43359, 43360, 43392, 43395,  43396, 43443, 43444, 43446, 43450, 43452, 43453, 43457, 43471, 43472,  43486, 43520, 43561, 43567, 43569, 43571, 43573, 43584, 43587, 43588,  43596, 43597, 43600, 43612, 43616, 43632, 43633, 43639, 43642, 43643,  43648, 43696, 43697, 43698, 43701, 43703, 43705, 43710, 43712, 43713,  43714, 43739, 43741, 43742, 43744, 43755, 43756, 43758, 43760, 43762,  43763, 43765, 43766, 43777, 43785, 43793, 43808, 43816, 43968, 44003,  44005, 44006, 44008, 44009, 44011, 44012, 44013, 44016, 44032, 55203,  55216, 55243, 55296, 56191, 56319, 57343, 57344, 63743, 63744, 64112,  64256, 64275, 64285, 64286, 64287, 64297, 64298, 64312, 64318, 64320,  64323, 64326, 64434, 64467, 64830, 64831, 64848, 64914, 65008, 65020,  65021, 65024, 65040, 65047, 65048, 65049, 65056, 65072, 65073, 65075,  65077, 65078, 65079, 65080, 65081, 65082, 65083, 65084, 65085, 65086,  65087, 65088, 65089, 65090, 65091, 65092, 65093, 65095, 65096, 65097,  65101, 65104, 65108, 65112, 65113, 65114, 65115, 65116, 65117, 65118,  65119, 65122, 65123, 65124, 65128, 65129, 65130, 65136, 65142, 65279,  65281, 65284, 65285, 65288, 65289, 65290, 65291, 65292, 65293, 65294,  65296, 65306, 65308, 65311, 65313, 65339, 65340, 65341, 65342, 65343,  65344, 65345, 65371, 65372, 65373, 65374, 65375, 65376, 65377, 65378,  65379, 65380, 65382, 65392, 65393, 65438, 65440, 65474, 65482, 65490,  65498, 65504, 65506, 65507, 65508, 65509, 65512, 65513, 65517, 65529,  65532, 0, 13, 40, 60, 63, 80, 128, 256, 263,  311, 320, 373, 377, 394, 400, 464, 509, 640, 672,  768, 800, 816, 833, 834, 842, 896, 927, 928, 968,  976, 977, 1024, 1064, 1104, 1184, 2048, 2056, 2058, 2103,  2108, 2111, 2135, 2136, 2304, 2326, 2335, 2336, 2367, 2432,  2494, 2560, 2561, 2565, 2572, 2576, 2581, 2585, 2616, 2623,  2624, 2640, 2656, 2685, 2687, 2816, 2873, 2880, 2904, 2912,  2936, 3072, 3680, 4096, 4097, 4098, 4099, 4152, 4167, 4178,  4198, 4224, 4226, 4227, 4272, 4275, 4279, 4281, 4283, 4285,  4286, 4304, 4336, 4352, 4355, 4391, 4396, 4397, 4406, 4416,  4480, 4482, 4483, 4531, 4534, 4543, 4545, 4549, 4560, 5760,  5803, 5804, 5805, 5806, 5808, 5814, 5815, 5824, 8192, 9216,  9328, 12288, 26624, 28416, 28496, 28497, 28559, 28563, 45056, 53248,  53504, 53545, 53605, 53607, 53610, 53613, 53619, 53627, 53635, 53637,  53644, 53674, 53678, 53760, 53826, 53829, 54016, 54112, 54272, 54298,  54324, 54350, 54358, 54376, 54402, 54428, 54430, 54434, 54437, 54441,  54446, 54454, 54459, 54461, 54469, 54480, 54506, 54532, 54535, 54541,  54550, 54558, 54584, 54587, 54592, 54598, 54602, 54610, 54636, 54662,  54688, 54714, 54740, 54766, 54792, 54818, 54844, 54870, 54896, 54922,  54952, 54977, 54978, 55003, 55004, 55010, 55035, 55036, 55061, 55062,  55068, 55093, 55094, 55119, 55120, 55126, 55151, 55152, 55177, 55178,  55184, 55209, 55210, 55235, 55236, 55242, 55246, 60928, 60933, 60961,  60964, 60967, 60969, 60980, 60985, 60987, 60994, 60999, 61001, 61003,  61005, 61009, 61012, 61015, 61017, 61019, 61021, 61023, 61025, 61028,  61031, 61036, 61044, 61049, 61054, 61056, 61067, 61089, 61093, 61099,  61168, 61440, 61488, 61600, 61617, 61633, 61649, 61696, 61712, 61744,  61808, 61926, 61968, 62016, 62032, 62208, 62256, 62263, 62336, 62368,  62406, 62432, 62464, 62528, 62530, 62713, 62720, 62784, 62800, 62971,  63045, 63104, 63232, 0, 42710, 42752, 46900, 46912, 47133, 63488,  1, 32, 256, 0, 65533,  }; static u16 aFts5UnicodeData[] = {  1025, 61, 117, 55, 117, 54, 50, 53, 57, 53,  49, 85, 333, 85, 121, 85, 841, 54, 53, 50,  56, 48, 56, 837, 54, 57, 50, 57, 1057, 61,  53, 151, 58, 53, 56, 58, 39, 52, 57, 34,  58, 56, 58, 57, 79, 56, 37, 85, 56, 47,  39, 51, 111, 53, 745, 57, 233, 773, 57, 261,  1822, 37, 542, 37, 1534, 222, 69, 73, 37, 126,  126, 73, 69, 137, 37, 73, 37, 105, 101, 73,  37, 73, 37, 190, 158, 37, 126, 126, 73, 37,  126, 94, 37, 39, 94, 69, 135, 41, 40, 37,  41, 40, 37, 41, 40, 37, 542, 37, 606, 37,  41, 40, 37, 126, 73, 37, 1886, 197, 73, 37,  73, 69, 126, 105, 37, 286, 2181, 39, 869, 582,  152, 390, 472, 166, 248, 38, 56, 38, 568, 3596,  158, 38, 56, 94, 38, 101, 53, 88, 41, 53,  105, 41, 73, 37, 553, 297, 1125, 94, 37, 105,  101, 798, 133, 94, 57, 126, 94, 37, 1641, 1541,  1118, 58, 172, 75, 1790, 478, 37, 2846, 1225, 38,  213, 1253, 53, 49, 55, 1452, 49, 44, 53, 76,  53, 76, 53, 44, 871, 103, 85, 162, 121, 85,  55, 85, 90, 364, 53, 85, 1031, 38, 327, 684,  333, 149, 71, 44, 3175, 53, 39, 236, 34, 58,  204, 70, 76, 58, 140, 71, 333, 103, 90, 39,  469, 34, 39, 44, 967, 876, 2855, 364, 39, 333,  1063, 300, 70, 58, 117, 38, 711, 140, 38, 300,  38, 108, 38, 172, 501, 807, 108, 53, 39, 359,  876, 108, 42, 1735, 44, 42, 44, 39, 106, 268,  138, 44, 74, 39, 236, 327, 76, 85, 333, 53,  38, 199, 231, 44, 74, 263, 71, 711, 231, 39,  135, 44, 39, 106, 140, 74, 74, 44, 39, 42,  71, 103, 76, 333, 71, 87, 207, 58, 55, 76,  42, 199, 71, 711, 231, 71, 71, 71, 44, 106,  76, 76, 108, 44, 135, 39, 333, 76, 103, 44,  76, 42, 295, 103, 711, 231, 71, 167, 44, 39,  106, 172, 76, 42, 74, 44, 39, 71, 76, 333,  53, 55, 44, 74, 263, 71, 711, 231, 71, 167,  44, 39, 42, 44, 42, 140, 74, 74, 44, 44,  42, 71, 103, 76, 333, 58, 39, 207, 44, 39,  199, 103, 135, 71, 39, 71, 71, 103, 391, 74,  44, 74, 106, 106, 44, 39, 42, 333, 111, 218,  55, 58, 106, 263, 103, 743, 327, 167, 39, 108,  138, 108, 140, 76, 71, 71, 76, 333, 239, 58,  74, 263, 103, 743, 327, 167, 44, 39, 42, 44,  170, 44, 74, 74, 76, 74, 39, 71, 76, 333,  71, 74, 263, 103, 1319, 39, 106, 140, 106, 106,  44, 39, 42, 71, 76, 333, 207, 58, 199, 74,  583, 775, 295, 39, 231, 44, 106, 108, 44, 266,  74, 53, 1543, 44, 71, 236, 55, 199, 38, 268,  53, 333, 85, 71, 39, 71, 39, 39, 135, 231,  103, 39, 39, 71, 135, 44, 71, 204, 76, 39,  167, 38, 204, 333, 135, 39, 122, 501, 58, 53,  122, 76, 218, 333, 335, 58, 44, 58, 44, 58,  44, 54, 50, 54, 50, 74, 263, 1159, 460, 42,  172, 53, 76, 167, 364, 1164, 282, 44, 218, 90,  181, 154, 85, 1383, 74, 140, 42, 204, 42, 76,  74, 76, 39, 333, 213, 199, 74, 76, 135, 108,  39, 106, 71, 234, 103, 140, 423, 44, 74, 76,  202, 44, 39, 42, 333, 106, 44, 90, 1225, 41,  41, 1383, 53, 38, 10631, 135, 231, 39, 135, 1319,  135, 1063, 135, 231, 39, 135, 487, 1831, 135, 2151,  108, 309, 655, 519, 346, 2727, 49, 19847, 85, 551,  61, 839, 54, 50, 2407, 117, 110, 423, 135, 108,  583, 108, 85, 583, 76, 423, 103, 76, 1671, 76,  42, 236, 266, 44, 74, 364, 117, 38, 117, 55,  39, 44, 333, 335, 213, 49, 149, 108, 61, 333,  1127, 38, 1671, 1319, 44, 39, 2247, 935, 108, 138,  76, 106, 74, 44, 202, 108, 58, 85, 333, 967,  167, 1415, 554, 231, 74, 333, 47, 1114, 743, 76,  106, 85, 1703, 42, 44, 42, 236, 44, 42, 44,  74, 268, 202, 332, 44, 333, 333, 245, 38, 213,  140, 42, 1511, 44, 42, 172, 42, 44, 170, 44,  74, 231, 333, 245, 346, 300, 314, 76, 42, 967,  42, 140, 74, 76, 42, 44, 74, 71, 333, 1415,  44, 42, 76, 106, 44, 42, 108, 74, 149, 1159,  266, 268, 74, 76, 181, 333, 103, 333, 967, 198,  85, 277, 108, 53, 428, 42, 236, 135, 44, 135,  74, 44, 71, 1413, 2022, 421, 38, 1093, 1190, 1260,  140, 4830, 261, 3166, 261, 265, 197, 201, 261, 265,  261, 265, 197, 201, 261, 41, 41, 41, 94, 229,  265, 453, 261, 264, 261, 264, 261, 264, 165, 69,  137, 40, 56, 37, 120, 101, 69, 137, 40, 120,  133, 69, 137, 120, 261, 169, 120, 101, 69, 137,  40, 88, 381, 162, 209, 85, 52, 51, 54, 84,  51, 54, 52, 277, 59, 60, 162, 61, 309, 52,  51, 149, 80, 117, 57, 54, 50, 373, 57, 53,  48, 341, 61, 162, 194, 47, 38, 207, 121, 54,  50, 38, 335, 121, 54, 50, 422, 855, 428, 139,  44, 107, 396, 90, 41, 154, 41, 90, 37, 105,  69, 105, 37, 58, 41, 90, 57, 169, 218, 41,  58, 41, 58, 41, 58, 137, 58, 37, 137, 37,  135, 37, 90, 69, 73, 185, 94, 101, 58, 57,  90, 37, 58, 527, 1134, 94, 142, 47, 185, 186,  89, 154, 57, 90, 57, 90, 57, 250, 57, 1018,  89, 90, 57, 58, 57, 1018, 8601, 282, 153, 666,  89, 250, 54, 50, 2618, 57, 986, 825, 1306, 217,  602, 1274, 378, 1935, 2522, 719, 5882, 57, 314, 57,  1754, 281, 3578, 57, 4634, 3322, 54, 50, 54, 50,  54, 50, 54, 50, 54, 50, 54, 50, 54, 50,  975, 1434, 185, 54, 50, 1017, 54, 50, 54, 50,  54, 50, 54, 50, 54, 50, 537, 8218, 4217, 54,  50, 54, 50, 54, 50, 54, 50, 54, 50, 54,  50, 54, 50, 54, 50, 54, 50, 54, 50, 54,  50, 2041, 54, 50, 54, 50, 1049, 54, 50, 8281,  1562, 697, 90, 217, 346, 1513, 1509, 126, 73, 69,  254, 105, 37, 94, 37, 94, 165, 70, 105, 37,  3166, 37, 218, 158, 108, 94, 149, 47, 85, 1221,  37, 37, 1799, 38, 53, 44, 743, 231, 231, 231,  231, 231, 231, 231, 231, 1036, 85, 52, 51, 52,  51, 117, 52, 51, 53, 52, 51, 309, 49, 85,  49, 53, 52, 51, 85, 52, 51, 54, 50, 54,  50, 54, 50, 54, 50, 181, 38, 341, 81, 858,  2874, 6874, 410, 61, 117, 58, 38, 39, 46, 54,  50, 54, 50, 54, 50, 54, 50, 54, 50, 90,  54, 50, 54, 50, 54, 50, 54, 50, 49, 54,  82, 58, 302, 140, 74, 49, 166, 90, 110, 38,  39, 53, 90, 2759, 76, 88, 70, 39, 49, 2887,  53, 102, 39, 1319, 3015, 90, 143, 346, 871, 1178,  519, 1018, 335, 986, 271, 58, 495, 1050, 335, 1274,  495, 2042, 8218, 39, 39, 2074, 39, 39, 679, 38,  36583, 1786, 1287, 198, 85, 8583, 38, 117, 519, 333,  71, 1502, 39, 44, 107, 53, 332, 53, 38, 798,  44, 2247, 334, 76, 213, 760, 294, 88, 478, 69,  2014, 38, 261, 190, 350, 38, 88, 158, 158, 382,  70, 37, 231, 44, 103, 44, 135, 44, 743, 74,  76, 42, 154, 207, 90, 55, 58, 1671, 149, 74,  1607, 522, 44, 85, 333, 588, 199, 117, 39, 333,  903, 268, 85, 743, 364, 74, 53, 935, 108, 42,  1511, 44, 74, 140, 74, 44, 138, 437, 38, 333,  85, 1319, 204, 74, 76, 74, 76, 103, 44, 263,  44, 42, 333, 149, 519, 38, 199, 122, 39, 42,  1543, 44, 39, 108, 71, 76, 167, 76, 39, 44,  39, 71, 38, 85, 359, 42, 76, 74, 85, 39,  70, 42, 44, 199, 199, 199, 231, 231, 1127, 74,  44, 74, 44, 74, 53, 42, 44, 333, 39, 39,  743, 1575, 36, 68, 68, 36, 63, 63, 11719, 3399,  229, 165, 39, 44, 327, 57, 423, 167, 39, 71,  71, 3463, 536, 11623, 54, 50, 2055, 1735, 391, 55,  58, 524, 245, 54, 50, 53, 236, 53, 81, 80,  54, 50, 54, 50, 54, 50, 54, 50, 54, 50,  54, 50, 54, 50, 54, 50, 85, 54, 50, 149,  112, 117, 149, 49, 54, 50, 54, 50, 54, 50,  117, 57, 49, 121, 53, 55, 85, 167, 4327, 34,  117, 55, 117, 54, 50, 53, 57, 53, 49, 85,  333, 85, 121, 85, 841, 54, 53, 50, 56, 48,  56, 837, 54, 57, 50, 57, 54, 50, 53, 54,  50, 85, 327, 38, 1447, 70, 999, 199, 199, 199,  103, 87, 57, 56, 58, 87, 58, 153, 90, 98,  90, 391, 839, 615, 71, 487, 455, 3943, 117, 1455,  314, 1710, 143, 570, 47, 410, 1466, 44, 935, 1575,  999, 143, 551, 46, 263, 46, 967, 53, 1159, 263,  53, 174, 1289, 1285, 2503, 333, 199, 39, 1415, 71,  39, 743, 53, 271, 711, 207, 53, 839, 53, 1799,  71, 39, 108, 76, 140, 135, 103, 871, 108, 44,  271, 309, 935, 79, 53, 1735, 245, 711, 271, 615,  271, 2343, 1007, 42, 44, 42, 1703, 492, 245, 655,  333, 76, 42, 1447, 106, 140, 74, 76, 85, 34,  149, 807, 333, 108, 1159, 172, 42, 268, 333, 149,  76, 42, 1543, 106, 300, 74, 135, 149, 333, 1383,  44, 42, 44, 74, 204, 42, 44, 333, 28135, 3182,  149, 34279, 18215, 2215, 39, 1482, 140, 422, 71, 7898,  1274, 1946, 74, 108, 122, 202, 258, 268, 90, 236,  986, 140, 1562, 2138, 108, 58, 2810, 591, 841, 837,  841, 229, 581, 841, 837, 41, 73, 41, 73, 137,  265, 133, 37, 229, 357, 841, 837, 73, 137, 265,  233, 837, 73, 137, 169, 41, 233, 837, 841, 837,  841, 837, 841, 837, 841, 837, 841, 837, 841, 901,  809, 57, 805, 57, 197, 809, 57, 805, 57, 197,  809, 57, 805, 57, 197, 809, 57, 805, 57, 197,  809, 57, 805, 57, 197, 94, 1613, 135, 871, 71,  39, 39, 327, 135, 39, 39, 39, 39, 39, 39,  103, 71, 39, 39, 39, 39, 39, 39, 71, 39,  135, 231, 135, 135, 39, 327, 551, 103, 167, 551,  89, 1434, 3226, 506, 474, 506, 506, 367, 1018, 1946,  1402, 954, 1402, 314, 90, 1082, 218, 2266, 666, 1210,  186, 570, 2042, 58, 5850, 154, 2010, 154, 794, 2266,  378, 2266, 3738, 39, 39, 39, 39, 39, 39, 17351,  34, 3074, 7692, 63, 63,  }; static int sqlite3Fts5UnicodeCategory(u32 iCode) {  int iRes = -1;  int iHi;  int iLo;  int ret;  u16 iKey;  if( iCode>=(1<<20) ){  return 0;  }  iLo = aFts5UnicodeBlock[(iCode>>16)];  iHi = aFts5UnicodeBlock[1+(iCode>>16)];  iKey = (iCode & 0xFFFF);  while( iHi>iLo ){  int iTest = (iHi + iLo) / 2;  assert( iTest>=iLo && iTest<iHi );  if( iKey>=aFts5UnicodeMap[iTest] ){  iRes = iTest;  iLo = iTest+1;  }else{  iHi = iTest;  }  }  if( iRes<0 ) return 0;  if( iKey>=(aFts5UnicodeMap[iRes]+(aFts5UnicodeData[iRes]>>5)) ) return 0;  ret = aFts5UnicodeData[iRes] & 0x1F;  if( ret!=30 ) return ret;  return ((iKey - aFts5UnicodeMap[iRes]) & 0x01) ? 5 : 9; } static void sqlite3Fts5UnicodeAscii(u8 *aArray, u8 *aAscii){  int i = 0;  int iTbl = 0;  while( i<128 ){  int bToken = aArray[ aFts5UnicodeData[iTbl] & 0x1F ];  int n = (aFts5UnicodeData[iTbl] >> 5) + i;  for(; i<128 && i<n; i++){  aAscii[i] = (u8)bToken;  }  iTbl++;  }  aAscii[0] = 0; } static int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v){  u32 a,b;  a = *p;  if (!(a&0x80))  {  *v = a;  return 1;  }  p++;  b = *p;  if (!(b&0x80))  {  a &= 0x7f;  a = a<<7;  *v = a | b;  return 2;  }  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  a &= (0x7f<<14)|(0x7f);  b &= 0x7f;  b = b<<7;  *v = a | b;  return 3;  }  {  u64 v64;  u8 n;  p -= 2;  n = sqlite3Fts5GetVarint(p, &v64);  *v = ((u32)v64) & 0x7FFFFFFF;  assert( n>3 && n<=9 );  return n;  } }
#define SLOT_2_0  0x001fc07f
#define SLOT_4_2_0  0xf01fc07f
static u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){  u32 a,b,s;  a = *p;  if (!(a&0x80))  {  *v = a;  return 1;  }  p++;  b = *p;  if (!(b&0x80))  {  a &= 0x7f;  a = a<<7;  a |= b;  *v = a;  return 2;  }  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  a &= SLOT_2_0;  b &= 0x7f;  b = b<<7;  a |= b;  *v = a;  return 3;  }  a &= SLOT_2_0;  p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  b &= SLOT_2_0;  a = a<<7;  a |= b;  *v = a;  return 4;  }  b &= SLOT_2_0;  s = a;  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  b = b<<7;  a |= b;  s = s>>18;  *v = ((u64)s)<<32 | a;  return 5;  }  s = s<<7;  s |= b;  p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  a &= SLOT_2_0;  a = a<<7;  a |= b;  s = s>>18;  *v = ((u64)s)<<32 | a;  return 6;  }  p++;  a = a<<14;  a |= *p;  if (!(a&0x80))  {  a &= SLOT_4_2_0;  b &= SLOT_2_0;  b = b<<7;  a |= b;  s = s>>11;  *v = ((u64)s)<<32 | a;  return 7;  }  a &= SLOT_2_0;  p++;  b = b<<14;  b |= *p;  if (!(b&0x80))  {  b &= SLOT_4_2_0;  a = a<<7;  a |= b;  s = s>>4;  *v = ((u64)s)<<32 | a;  return 8;  }  p++;  a = a<<15;  a |= *p;  b &= SLOT_2_0;  b = b<<8;  a |= b;  s = s<<4;  b = p[-4];  b &= 0x7f;  b = b>>3;  s |= b;  *v = ((u64)s)<<32 | a;  return 9; }
#ifdef SQLITE_NOINLINE
# define FTS5_NOINLINE SQLITE_NOINLINE
#else
# define FTS5_NOINLINE
#endif
static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, u64 v){  int i, j, n;  u8 buf[10];  if( v & (((u64)0xff000000)<<32) ){  p[8] = (u8)v;  v >>= 8;  for(i=7; i>=0; i--){  p[i] = (u8)((v & 0x7f) | 0x80);  v >>= 7;  }  return 9;  }  n = 0;  do{  buf[n++] = (u8)((v & 0x7f) | 0x80);  v >>= 7;  }while( v!=0 );  buf[0] &= 0x7f;  assert( n<=9 );  for(i=0, j=n-1; j>=0; j--, i++){  p[i] = buf[j];  }  return n; } static int sqlite3Fts5PutVarint(unsigned char *p, u64 v){  if( v<=0x7f ){  p[0] = v&0x7f;  return 1;  }  if( v<=0x3fff ){  p[0] = ((v>>7)&0x7f)|0x80;  p[1] = v&0x7f;  return 2;  }  return fts5PutVarint64(p,v); } static int sqlite3Fts5GetVarintLen(u32 iVal){
#if 0
 if( iVal<(1 << 7 ) ) return 1;
#endif
 assert( iVal>=(1 << 7) );  if( iVal<(1 << 14) ) return 2;  if( iVal<(1 << 21) ) return 3;  if( iVal<(1 << 28) ) return 4;  return 5; } typedef struct Fts5VocabTable Fts5VocabTable; typedef struct Fts5VocabCursor Fts5VocabCursor; struct Fts5VocabTable {  sqlite3_vtab base;  char *zFts5Tbl;  char *zFts5Db;  sqlite3 *db;  Fts5Global *pGlobal;  int eType;  unsigned bBusy; }; struct Fts5VocabCursor {  sqlite3_vtab_cursor base;  sqlite3_stmt *pStmt;  Fts5Table *pFts5;  int bEof;  Fts5IndexIter *pIter;  void *pStruct;  int nLeTerm;  char *zLeTerm;  int iCol;  i64 *aCnt;  i64 *aDoc;  i64 rowid;  Fts5Buffer term;  i64 iInstPos;  int iInstOff; };
#define FTS5_VOCAB_COL 0
#define FTS5_VOCAB_ROW 1
#define FTS5_VOCAB_INSTANCE 2
#define FTS5_VOCAB_COL_SCHEMA "term, col, doc, cnt"
#define FTS5_VOCAB_ROW_SCHEMA "term, doc, cnt"
#define FTS5_VOCAB_INST_SCHEMA "term, doc, col, offset"
#define FTS5_VOCAB_TERM_EQ 0x01
#define FTS5_VOCAB_TERM_GE 0x02
#define FTS5_VOCAB_TERM_LE 0x04
static int fts5VocabTableType(const char *zType, char **pzErr, int *peType){  int rc = SQLITE_OK;  char *zCopy = sqlite3Fts5Strndup(&rc, zType, -1);  if( rc==SQLITE_OK ){  sqlite3Fts5Dequote(zCopy);  if( sqlite3_stricmp(zCopy, "col")==0 ){  *peType = FTS5_VOCAB_COL;  }else  if( sqlite3_stricmp(zCopy, "row")==0 ){  *peType = FTS5_VOCAB_ROW;  }else  if( sqlite3_stricmp(zCopy, "instance")==0 ){  *peType = FTS5_VOCAB_INSTANCE;  }else  {  *pzErr = sqlite3_mprintf("fts5vocab: unknown table type: %Q", zCopy);  rc = SQLITE_ERROR;  }  sqlite3_free(zCopy);  }  return rc; } static int fts5VocabDisconnectMethod(sqlite3_vtab *pVtab){  Fts5VocabTable *pTab = (Fts5VocabTable*)pVtab;  sqlite3_free(pTab);  return SQLITE_OK; } static int fts5VocabDestroyMethod(sqlite3_vtab *pVtab){  Fts5VocabTable *pTab = (Fts5VocabTable*)pVtab;  sqlite3_free(pTab);  return SQLITE_OK; } static int fts5VocabInitVtab(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVTab,  char **pzErr ){  const char *azSchema[] = {  "CREATE TABlE vocab(" FTS5_VOCAB_COL_SCHEMA ")",  "CREATE TABlE vocab(" FTS5_VOCAB_ROW_SCHEMA ")",  "CREATE TABlE vocab(" FTS5_VOCAB_INST_SCHEMA ")"  };  Fts5VocabTable *pRet = 0;  int rc = SQLITE_OK;  int bDb;  bDb = (argc==6 && strlen(argv[1])==4 && memcmp("temp", argv[1], 4)==0);  if( argc!=5 && bDb==0 ){  *pzErr = sqlite3_mprintf("wrong number of vtable arguments");  rc = SQLITE_ERROR;  }else{  int nByte;  const char *zDb = bDb ? argv[3] : argv[1];  const char *zTab = bDb ? argv[4] : argv[3];  const char *zType = bDb ? argv[5] : argv[4];  int nDb = (int)strlen(zDb)+1;  int nTab = (int)strlen(zTab)+1;  int eType = 0;  rc = fts5VocabTableType(zType, pzErr, &eType);  if( rc==SQLITE_OK ){  assert( eType>=0 && eType<ArraySize(azSchema) );  rc = sqlite3_declare_vtab(db, azSchema[eType]);  }  nByte = sizeof(Fts5VocabTable) + nDb + nTab;  pRet = sqlite3Fts5MallocZero(&rc, nByte);  if( pRet ){  pRet->pGlobal = (Fts5Global*)pAux;  pRet->eType = eType;  pRet->db = db;  pRet->zFts5Tbl = (char*)&pRet[1];  pRet->zFts5Db = &pRet->zFts5Tbl[nTab];  memcpy(pRet->zFts5Tbl, zTab, nTab);  memcpy(pRet->zFts5Db, zDb, nDb);  sqlite3Fts5Dequote(pRet->zFts5Tbl);  sqlite3Fts5Dequote(pRet->zFts5Db);  }  }  *ppVTab = (sqlite3_vtab*)pRet;  return rc; } static int fts5VocabConnectMethod(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr); } static int fts5VocabCreateMethod(  sqlite3 *db,  void *pAux,  int argc,  const char * const *argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr); } static int fts5VocabBestIndexMethod(  sqlite3_vtab *pUnused,  sqlite3_index_info *pInfo ){  int i;  int iTermEq = -1;  int iTermGe = -1;  int iTermLe = -1;  int idxNum = 0;  int nArg = 0;  UNUSED_PARAM(pUnused);  for(i=0; i<pInfo->nConstraint; i++){  struct sqlite3_index_constraint *p = &pInfo->aConstraint[i];  if( p->usable==0 ) continue;  if( p->iColumn==0 ){  if( p->op==SQLITE_INDEX_CONSTRAINT_EQ ) iTermEq = i;  if( p->op==SQLITE_INDEX_CONSTRAINT_LE ) iTermLe = i;  if( p->op==SQLITE_INDEX_CONSTRAINT_LT ) iTermLe = i;  if( p->op==SQLITE_INDEX_CONSTRAINT_GE ) iTermGe = i;  if( p->op==SQLITE_INDEX_CONSTRAINT_GT ) iTermGe = i;  }  }  if( iTermEq>=0 ){  idxNum |= FTS5_VOCAB_TERM_EQ;  pInfo->aConstraintUsage[iTermEq].argvIndex = ++nArg;  pInfo->estimatedCost = 100;  }else{  pInfo->estimatedCost = 1000000;  if( iTermGe>=0 ){  idxNum |= FTS5_VOCAB_TERM_GE;  pInfo->aConstraintUsage[iTermGe].argvIndex = ++nArg;  pInfo->estimatedCost = pInfo->estimatedCost / 2;  }  if( iTermLe>=0 ){  idxNum |= FTS5_VOCAB_TERM_LE;  pInfo->aConstraintUsage[iTermLe].argvIndex = ++nArg;  pInfo->estimatedCost = pInfo->estimatedCost / 2;  }  }  if( pInfo->nOrderBy==1   && pInfo->aOrderBy[0].iColumn==0   && pInfo->aOrderBy[0].desc==0  ){  pInfo->orderByConsumed = 1;  }  pInfo->idxNum = idxNum;  return SQLITE_OK; } static int fts5VocabOpenMethod(  sqlite3_vtab *pVTab,  sqlite3_vtab_cursor **ppCsr ){  Fts5VocabTable *pTab = (Fts5VocabTable*)pVTab;  Fts5Table *pFts5 = 0;  Fts5VocabCursor *pCsr = 0;  int rc = SQLITE_OK;  sqlite3_stmt *pStmt = 0;  char *zSql = 0;  if( pTab->bBusy ){  pVTab->zErrMsg = sqlite3_mprintf(   "recursive definition for %s.%s", pTab->zFts5Db, pTab->zFts5Tbl  );  return SQLITE_ERROR;  }  zSql = sqlite3Fts5Mprintf(&rc,  "SELECT t.%Q FROM %Q.%Q AS t WHERE t.%Q MATCH '*id'",  pTab->zFts5Tbl, pTab->zFts5Db, pTab->zFts5Tbl, pTab->zFts5Tbl  );  if( zSql ){  rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pStmt, 0);  }  sqlite3_free(zSql);  assert( rc==SQLITE_OK || pStmt==0 );  if( rc==SQLITE_ERROR ) rc = SQLITE_OK;  pTab->bBusy = 1;  if( pStmt && sqlite3_step(pStmt)==SQLITE_ROW ){  i64 iId = sqlite3_column_int64(pStmt, 0);  pFts5 = sqlite3Fts5TableFromCsrid(pTab->pGlobal, iId);  }  pTab->bBusy = 0;  if( rc==SQLITE_OK ){  if( pFts5==0 ){  rc = sqlite3_finalize(pStmt);  pStmt = 0;  if( rc==SQLITE_OK ){  pVTab->zErrMsg = sqlite3_mprintf(  "no such fts5 table: %s.%s", pTab->zFts5Db, pTab->zFts5Tbl  );  rc = SQLITE_ERROR;  }  }else{  rc = sqlite3Fts5FlushToDisk(pFts5);  }  }  if( rc==SQLITE_OK ){  i64 nByte = pFts5->pConfig->nCol * sizeof(i64)*2 + sizeof(Fts5VocabCursor);  pCsr = (Fts5VocabCursor*)sqlite3Fts5MallocZero(&rc, nByte);  }  if( pCsr ){  pCsr->pFts5 = pFts5;  pCsr->pStmt = pStmt;  pCsr->aCnt = (i64*)&pCsr[1];  pCsr->aDoc = &pCsr->aCnt[pFts5->pConfig->nCol];  }else{  sqlite3_finalize(pStmt);  }  *ppCsr = (sqlite3_vtab_cursor*)pCsr;  return rc; } static void fts5VocabResetCursor(Fts5VocabCursor *pCsr){  pCsr->rowid = 0;  sqlite3Fts5IterClose(pCsr->pIter);  sqlite3Fts5StructureRelease(pCsr->pStruct);  pCsr->pStruct = 0;  pCsr->pIter = 0;  sqlite3_free(pCsr->zLeTerm);  pCsr->nLeTerm = -1;  pCsr->zLeTerm = 0;  pCsr->bEof = 0; } static int fts5VocabCloseMethod(sqlite3_vtab_cursor *pCursor){  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;  fts5VocabResetCursor(pCsr);  sqlite3Fts5BufferFree(&pCsr->term);  sqlite3_finalize(pCsr->pStmt);  sqlite3_free(pCsr);  return SQLITE_OK; } static int fts5VocabInstanceNewTerm(Fts5VocabCursor *pCsr){  int rc = SQLITE_OK;  if( sqlite3Fts5IterEof(pCsr->pIter) ){  pCsr->bEof = 1;  }else{  const char *zTerm;  int nTerm;  zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);  if( pCsr->nLeTerm>=0 ){  int nCmp = MIN(nTerm, pCsr->nLeTerm);  int bCmp = memcmp(pCsr->zLeTerm, zTerm, nCmp);  if( bCmp<0 || (bCmp==0 && pCsr->nLeTerm<nTerm) ){  pCsr->bEof = 1;  }  }  sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);  }  return rc; } static int fts5VocabInstanceNext(Fts5VocabCursor *pCsr){  int eDetail = pCsr->pFts5->pConfig->eDetail;  int rc = SQLITE_OK;  Fts5IndexIter *pIter = pCsr->pIter;  i64 *pp = &pCsr->iInstPos;  int *po = &pCsr->iInstOff;  assert( sqlite3Fts5IterEof(pIter)==0 );  assert( pCsr->bEof==0 );  while( eDetail==FTS5_DETAIL_NONE  || sqlite3Fts5PoslistNext64(pIter->pData, pIter->nData, po, pp)  ){  pCsr->iInstPos = 0;  pCsr->iInstOff = 0;  rc = sqlite3Fts5IterNextScan(pCsr->pIter);  if( rc==SQLITE_OK ){  rc = fts5VocabInstanceNewTerm(pCsr);  if( pCsr->bEof || eDetail==FTS5_DETAIL_NONE ) break;  }  if( rc ){  pCsr->bEof = 1;  break;  }  }  return rc; } static int fts5VocabNextMethod(sqlite3_vtab_cursor *pCursor){  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;  Fts5VocabTable *pTab = (Fts5VocabTable*)pCursor->pVtab;  int nCol = pCsr->pFts5->pConfig->nCol;  int rc;  rc = sqlite3Fts5StructureTest(pCsr->pFts5->pIndex, pCsr->pStruct);  if( rc!=SQLITE_OK ) return rc;  pCsr->rowid++;  if( pTab->eType==FTS5_VOCAB_INSTANCE ){  return fts5VocabInstanceNext(pCsr);  }  if( pTab->eType==FTS5_VOCAB_COL ){  for(pCsr->iCol++; pCsr->iCol<nCol; pCsr->iCol++){  if( pCsr->aDoc[pCsr->iCol] ) break;  }  }  if( pTab->eType!=FTS5_VOCAB_COL || pCsr->iCol>=nCol ){  if( sqlite3Fts5IterEof(pCsr->pIter) ){  pCsr->bEof = 1;  }else{  const char *zTerm;  int nTerm;  zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);  assert( nTerm>=0 );  if( pCsr->nLeTerm>=0 ){  int nCmp = MIN(nTerm, pCsr->nLeTerm);  int bCmp = memcmp(pCsr->zLeTerm, zTerm, nCmp);  if( bCmp<0 || (bCmp==0 && pCsr->nLeTerm<nTerm) ){  pCsr->bEof = 1;  return SQLITE_OK;  }  }  sqlite3Fts5BufferSet(&rc, &pCsr->term, nTerm, (const u8*)zTerm);  memset(pCsr->aCnt, 0, nCol * sizeof(i64));  memset(pCsr->aDoc, 0, nCol * sizeof(i64));  pCsr->iCol = 0;  assert( pTab->eType==FTS5_VOCAB_COL || pTab->eType==FTS5_VOCAB_ROW );  while( rc==SQLITE_OK ){  int eDetail = pCsr->pFts5->pConfig->eDetail;  const u8 *pPos; int nPos;  i64 iPos = 0;  int iOff = 0;  pPos = pCsr->pIter->pData;  nPos = pCsr->pIter->nData;  switch( pTab->eType ){  case FTS5_VOCAB_ROW:  if( eDetail==FTS5_DETAIL_FULL ){  while( 0==sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos) ){  pCsr->aCnt[0]++;  }  }  pCsr->aDoc[0]++;  break;  case FTS5_VOCAB_COL:  if( eDetail==FTS5_DETAIL_FULL ){  int iCol = -1;  while( 0==sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos) ){  int ii = FTS5_POS2COLUMN(iPos);  if( iCol!=ii ){  if( ii>=nCol ){  rc = FTS5_CORRUPT;  break;  }  pCsr->aDoc[ii]++;  iCol = ii;  }  pCsr->aCnt[ii]++;  }  }else if( eDetail==FTS5_DETAIL_COLUMNS ){  while( 0==sqlite3Fts5PoslistNext64(pPos, nPos, &iOff,&iPos) ){  assert_nc( iPos>=0 && iPos<nCol );  if( iPos>=nCol ){  rc = FTS5_CORRUPT;  break;  }  pCsr->aDoc[iPos]++;  }  }else{  assert( eDetail==FTS5_DETAIL_NONE );  pCsr->aDoc[0]++;  }  break;  default:  assert( pTab->eType==FTS5_VOCAB_INSTANCE );  break;  }  if( rc==SQLITE_OK ){  rc = sqlite3Fts5IterNextScan(pCsr->pIter);  }  if( pTab->eType==FTS5_VOCAB_INSTANCE ) break;  if( rc==SQLITE_OK ){  zTerm = sqlite3Fts5IterTerm(pCsr->pIter, &nTerm);  if( nTerm!=pCsr->term.n  || (nTerm>0 && memcmp(zTerm, pCsr->term.p, nTerm))  ){  break;  }  if( sqlite3Fts5IterEof(pCsr->pIter) ) break;  }  }  }  }  if( rc==SQLITE_OK && pCsr->bEof==0 && pTab->eType==FTS5_VOCAB_COL ){  for(; pCsr->iCol<nCol && pCsr->aDoc[pCsr->iCol]==0; pCsr->iCol++);  if( pCsr->iCol==nCol ){  rc = FTS5_CORRUPT;  }  }  return rc; } static int fts5VocabFilterMethod(  sqlite3_vtab_cursor *pCursor,  int idxNum,  const char *zUnused,  int nUnused,  sqlite3_value **apVal ){  Fts5VocabTable *pTab = (Fts5VocabTable*)pCursor->pVtab;  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;  int eType = pTab->eType;  int rc = SQLITE_OK;  int iVal = 0;  int f = FTS5INDEX_QUERY_SCAN;  const char *zTerm = 0;  int nTerm = 0;  sqlite3_value *pEq = 0;  sqlite3_value *pGe = 0;  sqlite3_value *pLe = 0;  UNUSED_PARAM2(zUnused, nUnused);  fts5VocabResetCursor(pCsr);  if( idxNum & FTS5_VOCAB_TERM_EQ ) pEq = apVal[iVal++];  if( idxNum & FTS5_VOCAB_TERM_GE ) pGe = apVal[iVal++];  if( idxNum & FTS5_VOCAB_TERM_LE ) pLe = apVal[iVal++];  if( pEq ){  zTerm = (const char *)sqlite3_value_text(pEq);  nTerm = sqlite3_value_bytes(pEq);  f = 0;  }else{  if( pGe ){  zTerm = (const char *)sqlite3_value_text(pGe);  nTerm = sqlite3_value_bytes(pGe);  }  if( pLe ){  const char *zCopy = (const char *)sqlite3_value_text(pLe);  if( zCopy==0 ) zCopy = "";  pCsr->nLeTerm = sqlite3_value_bytes(pLe);  pCsr->zLeTerm = sqlite3_malloc(pCsr->nLeTerm+1);  if( pCsr->zLeTerm==0 ){  rc = SQLITE_NOMEM;  }else{  memcpy(pCsr->zLeTerm, zCopy, pCsr->nLeTerm+1);  }  }  }  if( rc==SQLITE_OK ){  Fts5Index *pIndex = pCsr->pFts5->pIndex;  rc = sqlite3Fts5IndexQuery(pIndex, zTerm, nTerm, f, 0, &pCsr->pIter);  if( rc==SQLITE_OK ){  pCsr->pStruct = sqlite3Fts5StructureRef(pIndex);  }  }  if( rc==SQLITE_OK && eType==FTS5_VOCAB_INSTANCE ){  rc = fts5VocabInstanceNewTerm(pCsr);  }  if( rc==SQLITE_OK && !pCsr->bEof   && (eType!=FTS5_VOCAB_INSTANCE  || pCsr->pFts5->pConfig->eDetail!=FTS5_DETAIL_NONE)  ){  rc = fts5VocabNextMethod(pCursor);  }  return rc; } static int fts5VocabEofMethod(sqlite3_vtab_cursor *pCursor){  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;  return pCsr->bEof; } static int fts5VocabColumnMethod(  sqlite3_vtab_cursor *pCursor,  sqlite3_context *pCtx,  int iCol ){  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;  int eDetail = pCsr->pFts5->pConfig->eDetail;  int eType = ((Fts5VocabTable*)(pCursor->pVtab))->eType;  i64 iVal = 0;  if( iCol==0 ){  sqlite3_result_text(  pCtx, (const char*)pCsr->term.p, pCsr->term.n, SQLITE_TRANSIENT  );  }else if( eType==FTS5_VOCAB_COL ){  assert( iCol==1 || iCol==2 || iCol==3 );  if( iCol==1 ){  if( eDetail!=FTS5_DETAIL_NONE ){  const char *z = pCsr->pFts5->pConfig->azCol[pCsr->iCol];  sqlite3_result_text(pCtx, z, -1, SQLITE_STATIC);  }  }else if( iCol==2 ){  iVal = pCsr->aDoc[pCsr->iCol];  }else{  iVal = pCsr->aCnt[pCsr->iCol];  }  }else if( eType==FTS5_VOCAB_ROW ){  assert( iCol==1 || iCol==2 );  if( iCol==1 ){  iVal = pCsr->aDoc[0];  }else{  iVal = pCsr->aCnt[0];  }  }else{  assert( eType==FTS5_VOCAB_INSTANCE );  switch( iCol ){  case 1:  sqlite3_result_int64(pCtx, pCsr->pIter->iRowid);  break;  case 2: {  int ii = -1;  if( eDetail==FTS5_DETAIL_FULL ){  ii = FTS5_POS2COLUMN(pCsr->iInstPos);  }else if( eDetail==FTS5_DETAIL_COLUMNS ){  ii = (int)pCsr->iInstPos;  }  if( ii>=0 && ii<pCsr->pFts5->pConfig->nCol ){  const char *z = pCsr->pFts5->pConfig->azCol[ii];  sqlite3_result_text(pCtx, z, -1, SQLITE_STATIC);  }  break;  }  default: {  assert( iCol==3 );  if( eDetail==FTS5_DETAIL_FULL ){  int ii = FTS5_POS2OFFSET(pCsr->iInstPos);  sqlite3_result_int(pCtx, ii);  }  break;  }  }  }  if( iVal>0 ) sqlite3_result_int64(pCtx, iVal);  return SQLITE_OK; } static int fts5VocabRowidMethod(  sqlite3_vtab_cursor *pCursor,  sqlite_int64 *pRowid ){  Fts5VocabCursor *pCsr = (Fts5VocabCursor*)pCursor;  *pRowid = pCsr->rowid;  return SQLITE_OK; } static int sqlite3Fts5VocabInit(Fts5Global *pGlobal, sqlite3 *db){  static const sqlite3_module fts5Vocab = {  2,  fts5VocabCreateMethod,  fts5VocabConnectMethod,  fts5VocabBestIndexMethod,  fts5VocabDisconnectMethod,  fts5VocabDestroyMethod,  fts5VocabOpenMethod,  fts5VocabCloseMethod,  fts5VocabFilterMethod,  fts5VocabNextMethod,  fts5VocabEofMethod,  fts5VocabColumnMethod,  fts5VocabRowidMethod,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0  };  void *p = (void*)pGlobal;  return sqlite3_create_module_v2(db, "fts5vocab", &fts5Vocab, p, 0); }
#endif
#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB)
#if !defined(SQLITEINT_H)
#endif
SQLITE_EXTENSION_INIT1
#ifndef SQLITE_OMIT_VIRTUALTABLE
typedef struct stmt_vtab stmt_vtab; struct stmt_vtab {  sqlite3_vtab base;  sqlite3 *db; }; typedef struct stmt_cursor stmt_cursor; struct stmt_cursor {  sqlite3_vtab_cursor base;  sqlite3 *db;  sqlite3_stmt *pStmt;  sqlite3_int64 iRowid; }; static int stmtConnect(  sqlite3 *db,  void *pAux,  int argc, const char *const*argv,  sqlite3_vtab **ppVtab,  char **pzErr ){  stmt_vtab *pNew;  int rc;
#define STMT_COLUMN_SQL  0
#define STMT_COLUMN_NCOL 1
#define STMT_COLUMN_RO 2
#define STMT_COLUMN_BUSY 3
#define STMT_COLUMN_NSCAN  4
#define STMT_COLUMN_NSORT  5
#define STMT_COLUMN_NAIDX  6
#define STMT_COLUMN_NSTEP  7
#define STMT_COLUMN_REPREP 8
#define STMT_COLUMN_RUN  9
#define STMT_COLUMN_MEM 10
 rc = sqlite3_declare_vtab(db,   "CREATE TABLE x(sql,ncol,ro,busy,nscan,nsort,naidx,nstep,"  "reprep,run,mem)");  if( rc==SQLITE_OK ){  pNew = sqlite3_malloc( sizeof(*pNew) );  *ppVtab = (sqlite3_vtab*)pNew;  if( pNew==0 ) return SQLITE_NOMEM;  memset(pNew, 0, sizeof(*pNew));  pNew->db = db;  }  return rc; } static int stmtDisconnect(sqlite3_vtab *pVtab){  sqlite3_free(pVtab);  return SQLITE_OK; } static int stmtOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){  stmt_cursor *pCur;  pCur = sqlite3_malloc( sizeof(*pCur) );  if( pCur==0 ) return SQLITE_NOMEM;  memset(pCur, 0, sizeof(*pCur));  pCur->db = ((stmt_vtab*)p)->db;  *ppCursor = &pCur->base;  return SQLITE_OK; } static int stmtClose(sqlite3_vtab_cursor *cur){  sqlite3_free(cur);  return SQLITE_OK; } static int stmtNext(sqlite3_vtab_cursor *cur){  stmt_cursor *pCur = (stmt_cursor*)cur;  pCur->iRowid++;  pCur->pStmt = sqlite3_next_stmt(pCur->db, pCur->pStmt);  return SQLITE_OK; } static int stmtColumn(  sqlite3_vtab_cursor *cur,  sqlite3_context *ctx,  int i ){  stmt_cursor *pCur = (stmt_cursor*)cur;  switch( i ){  case STMT_COLUMN_SQL: {  sqlite3_result_text(ctx, sqlite3_sql(pCur->pStmt), -1, SQLITE_TRANSIENT);  break;  }  case STMT_COLUMN_NCOL: {  sqlite3_result_int(ctx, sqlite3_column_count(pCur->pStmt));  break;  }  case STMT_COLUMN_RO: {  sqlite3_result_int(ctx, sqlite3_stmt_readonly(pCur->pStmt));  break;  }  case STMT_COLUMN_BUSY: {  sqlite3_result_int(ctx, sqlite3_stmt_busy(pCur->pStmt));  break;  }  default: {  assert( i==STMT_COLUMN_MEM );  i = SQLITE_STMTSTATUS_MEMUSED +  STMT_COLUMN_NSCAN - SQLITE_STMTSTATUS_FULLSCAN_STEP;  }  case STMT_COLUMN_NSCAN:  case STMT_COLUMN_NSORT:  case STMT_COLUMN_NAIDX:  case STMT_COLUMN_NSTEP:  case STMT_COLUMN_REPREP:  case STMT_COLUMN_RUN: {  sqlite3_result_int(ctx, sqlite3_stmt_status(pCur->pStmt,  i-STMT_COLUMN_NSCAN+SQLITE_STMTSTATUS_FULLSCAN_STEP, 0));  break;  }  }  return SQLITE_OK; } static int stmtRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){  stmt_cursor *pCur = (stmt_cursor*)cur;  *pRowid = pCur->iRowid;  return SQLITE_OK; } static int stmtEof(sqlite3_vtab_cursor *cur){  stmt_cursor *pCur = (stmt_cursor*)cur;  return pCur->pStmt==0; } static int stmtFilter(  sqlite3_vtab_cursor *pVtabCursor,  int idxNum, const char *idxStr,  int argc, sqlite3_value **argv ){  stmt_cursor *pCur = (stmt_cursor *)pVtabCursor;  pCur->pStmt = 0;  pCur->iRowid = 0;  return stmtNext(pVtabCursor); } static int stmtBestIndex(  sqlite3_vtab *tab,  sqlite3_index_info *pIdxInfo ){  pIdxInfo->estimatedCost = (double)500;  pIdxInfo->estimatedRows = 500;  return SQLITE_OK; } static sqlite3_module stmtModule = {  0,  0,  stmtConnect,  stmtBestIndex,  stmtDisconnect,  0,  stmtOpen,  stmtClose,  stmtFilter,  stmtNext,  stmtEof,  stmtColumn,  stmtRowid,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, };
#endif
SQLITE_PRIVATE int sqlite3StmtVtabInit(sqlite3 *db){  int rc = SQLITE_OK;
#ifndef SQLITE_OMIT_VIRTUALTABLE
 rc = sqlite3_create_module(db, "sqlite_stmt", &stmtModule, 0);
#endif
 return rc; }
#ifndef SQLITE_CORE
#ifdef _WIN32
__declspec(dllexport)
#endif
SQLITE_API int sqlite3_stmt_init(  sqlite3 *db,  char **pzErrMsg,  const sqlite3_api_routines *pApi ){  int rc = SQLITE_OK;  SQLITE_EXTENSION_INIT2(pApi);
#ifndef SQLITE_OMIT_VIRTUALTABLE
 rc = sqlite3StmtVtabInit(db);
#endif
 return rc; }
#endif
#endif
SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; } 